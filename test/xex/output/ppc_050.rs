pub fn sub_8260DC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260DC18 size=20
    let mut pc: u32 = 0x8260DC18;
    'dispatch: loop {
        match pc {
            0x8260DC18 => {
    //   block [0x8260DC18..0x8260DC2C)
	// 8260DC18: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8260DC1C: 40980010  bge cr6, 0x8260dc2c
	if !ctx.cr[6].lt {
		sub_8260DC2C(ctx, base);
		return;
	}
	// 8260DC20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260DC24: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 8260DC28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DC2C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260DC2C size=20
    let mut pc: u32 = 0x8260DC2C;
    'dispatch: loop {
        match pc {
            0x8260DC2C => {
    //   block [0x8260DC2C..0x8260DC40)
	// 8260DC2C: 2F040064  cmpwi cr6, r4, 0x64
	ctx.cr[6].compare_i32(ctx.r[4].s32, 100, &mut ctx.xer);
	// 8260DC30: 40990010  ble cr6, 0x8260dc40
	if !ctx.cr[6].gt {
		sub_8260DC40(ctx, base);
		return;
	}
	// 8260DC34: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 8260DC38: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 8260DC3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260DC40 size=8
    let mut pc: u32 = 0x8260DC40;
    'dispatch: loop {
        match pc {
            0x8260DC40 => {
    //   block [0x8260DC40..0x8260DC48)
	// 8260DC40: 90830044  stw r4, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[4].u32 ) };
	// 8260DC44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260DC48 size=20
    let mut pc: u32 = 0x8260DC48;
    'dispatch: loop {
        match pc {
            0x8260DC48 => {
    //   block [0x8260DC48..0x8260DC5C)
	// 8260DC48: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8260DC4C: 40980010  bge cr6, 0x8260dc5c
	if !ctx.cr[6].lt {
		sub_8260DC5C(ctx, base);
		return;
	}
	// 8260DC50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260DC54: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 8260DC58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DC5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260DC5C size=20
    let mut pc: u32 = 0x8260DC5C;
    'dispatch: loop {
        match pc {
            0x8260DC5C => {
    //   block [0x8260DC5C..0x8260DC70)
	// 8260DC5C: 2F040064  cmpwi cr6, r4, 0x64
	ctx.cr[6].compare_i32(ctx.r[4].s32, 100, &mut ctx.xer);
	// 8260DC60: 40990010  ble cr6, 0x8260dc70
	if !ctx.cr[6].gt {
		sub_8260DC70(ctx, base);
		return;
	}
	// 8260DC64: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 8260DC68: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 8260DC6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260DC70 size=8
    let mut pc: u32 = 0x8260DC70;
    'dispatch: loop {
        match pc {
            0x8260DC70 => {
    //   block [0x8260DC70..0x8260DC78)
	// 8260DC70: 9083004C  stw r4, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[4].u32 ) };
	// 8260DC74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260DC78 size=20
    let mut pc: u32 = 0x8260DC78;
    'dispatch: loop {
        match pc {
            0x8260DC78 => {
    //   block [0x8260DC78..0x8260DC8C)
	// 8260DC78: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8260DC7C: 40980010  bge cr6, 0x8260dc8c
	if !ctx.cr[6].lt {
		sub_8260DC8C(ctx, base);
		return;
	}
	// 8260DC80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260DC84: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8260DC88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DC8C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260DC8C size=20
    let mut pc: u32 = 0x8260DC8C;
    'dispatch: loop {
        match pc {
            0x8260DC8C => {
    //   block [0x8260DC8C..0x8260DCA0)
	// 8260DC8C: 2F040064  cmpwi cr6, r4, 0x64
	ctx.cr[6].compare_i32(ctx.r[4].s32, 100, &mut ctx.xer);
	// 8260DC90: 40990010  ble cr6, 0x8260dca0
	if !ctx.cr[6].gt {
		sub_8260DCA0(ctx, base);
		return;
	}
	// 8260DC94: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 8260DC98: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8260DC9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DCA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260DCA0 size=8
    let mut pc: u32 = 0x8260DCA0;
    'dispatch: loop {
        match pc {
            0x8260DCA0 => {
    //   block [0x8260DCA0..0x8260DCA8)
	// 8260DCA0: 90830064  stw r4, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[4].u32 ) };
	// 8260DCA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260DCA8 size=20
    let mut pc: u32 = 0x8260DCA8;
    'dispatch: loop {
        match pc {
            0x8260DCA8 => {
    //   block [0x8260DCA8..0x8260DCBC)
	// 8260DCA8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8260DCAC: 40980010  bge cr6, 0x8260dcbc
	if !ctx.cr[6].lt {
		sub_8260DCBC(ctx, base);
		return;
	}
	// 8260DCB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260DCB4: 91630068  stw r11, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8260DCB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DCBC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260DCBC size=20
    let mut pc: u32 = 0x8260DCBC;
    'dispatch: loop {
        match pc {
            0x8260DCBC => {
    //   block [0x8260DCBC..0x8260DCD0)
	// 8260DCBC: 2F040064  cmpwi cr6, r4, 0x64
	ctx.cr[6].compare_i32(ctx.r[4].s32, 100, &mut ctx.xer);
	// 8260DCC0: 40990010  ble cr6, 0x8260dcd0
	if !ctx.cr[6].gt {
		sub_8260DCD0(ctx, base);
		return;
	}
	// 8260DCC4: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 8260DCC8: 91630068  stw r11, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8260DCCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260DCD0 size=8
    let mut pc: u32 = 0x8260DCD0;
    'dispatch: loop {
        match pc {
            0x8260DCD0 => {
    //   block [0x8260DCD0..0x8260DCD8)
	// 8260DCD0: 90830068  stw r4, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[4].u32 ) };
	// 8260DCD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DCD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260DCD8 size=112
    let mut pc: u32 = 0x8260DCD8;
    'dispatch: loop {
        match pc {
            0x8260DCD8 => {
    //   block [0x8260DCD8..0x8260DD48)
	// 8260DCD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260DCDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8260DCE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8260DCE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8260DCE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260DCEC: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 8260DCF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260DCF4: 4BC1A405  bl 0x822280f8
	ctx.lr = 0x8260DCF8;
	sub_822280F8(ctx, base);
	// 8260DCF8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8260DCFC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8260DD00: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260DD04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260DD08: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260DD0C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8260DD10: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8260DD14: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8260DD18: 481E4959  bl 0x827f2670
	ctx.lr = 0x8260DD1C;
	sub_827F2670(ctx, base);
	// 8260DD1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8260DD20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8260DD24: 7FE903A6  mtctr r31
	ctx.ctr.u64 = ctx.r[31].u64;
	// 8260DD28: 4E800421  bctrl
	ctx.lr = 0x8260DD2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8260DD2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8260DD30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8260DD34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260DD38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8260DD3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8260DD40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8260DD44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260DD48 size=108
    let mut pc: u32 = 0x8260DD48;
    'dispatch: loop {
        match pc {
            0x8260DD48 => {
    //   block [0x8260DD48..0x8260DDB4)
	// 8260DD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260DD4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8260DD50: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DDB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260DDB8 size=100
    let mut pc: u32 = 0x8260DDB8;
    'dispatch: loop {
        match pc {
            0x8260DDB8 => {
    //   block [0x8260DDB8..0x8260DE1C)
	// 8260DDB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260DDBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8260DDC0: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260DE20 size=100
    let mut pc: u32 = 0x8260DE20;
    'dispatch: loop {
        match pc {
            0x8260DE20 => {
    //   block [0x8260DE20..0x8260DE84)
	// 8260DE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260DE24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8260DE28: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260DEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260DEC0 size=576
    let mut pc: u32 = 0x8260DEC0;
    'dispatch: loop {
        match pc {
            0x8260DEC0 => {
    //   block [0x8260DEC0..0x8260E0E8)
	// 8260DEC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260DEC4: 4869B545  bl 0x82ca9408
	ctx.lr = 0x8260DEC8;
	sub_82CA93D0(ctx, base);
	// 8260DEC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260DECC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8260DED0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8260DED4: 4BDC06ED  bl 0x823ce5c0
	ctx.lr = 0x8260DED8;
	sub_823CE5C0(ctx, base);
	// 8260DED8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8260DEDC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8260DEE0: 38AB824C  addi r5, r11, -0x7db4
	ctx.r[5].s64 = ctx.r[11].s64 + -32180;
	// 8260DEE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260DEE8: 4BDC0319  bl 0x823ce200
	ctx.lr = 0x8260DEEC;
	sub_823CE200(ctx, base);
	// 8260DEEC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8260DEF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8260DEF4: 419A01F4  beq cr6, 0x8260e0e8
	if ctx.cr[6].eq {
	pc = 0x8260E0E8; continue 'dispatch;
	}
	// 8260DEF8: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260DEFC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8260DF00: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260DF04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260DF08: 4BC1B201  bl 0x82229108
	ctx.lr = 0x8260DF0C;
	sub_82229108(ctx, base);
	// 8260DF0C: 3D608261  lis r11, -0x7d9f
	ctx.r[11].s64 = -2107572224;
	// 8260DF10: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8260DF14: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260DF18: 3BABDD48  addi r29, r11, -0x22b8
	ctx.r[29].s64 = ctx.r[11].s64 + -8888;
	// 8260DF1C: 4BC19965  bl 0x82227880
	ctx.lr = 0x8260DF20;
	sub_82227880(ctx, base);
	// 8260DF20: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8260DF24: 3D408235  lis r10, -0x7dcb
	ctx.r[10].s64 = -2110455808;
	// 8260DF28: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8260DF2C: 388AC358  addi r4, r10, -0x3ca8
	ctx.r[4].s64 = ctx.r[10].s64 + -15528;
	// 8260DF30: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260DF34: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8260DF38: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8260DF3C: 4BB8CB45  bl 0x8219aa80
	ctx.lr = 0x8260DF40;
	sub_8219AA80(ctx, base);
	// 8260DF40: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8260DF44: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8260DF48: 3BA98254  addi r29, r9, -0x7dac
	ctx.r[29].s64 = ctx.r[9].s64 + -32172;
	// 8260DF4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260DF50: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8260DF54: 4BDC04CD  bl 0x823ce420
	ctx.lr = 0x8260DF58;
	sub_823CE420(ctx, base);
	// 8260DF58: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8260DF5C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8260DF60: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260DF64: 48416765  bl 0x82a246c8
	ctx.lr = 0x8260DF68;
	sub_82A246C8(ctx, base);
	// 8260DF68: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260DF6C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8260DF70: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 8260DF74: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 8260DF78: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260DF7C: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260DF80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260DF84: 4BC1B185  bl 0x82229108
	ctx.lr = 0x8260DF88;
	sub_82229108(ctx, base);
	// 8260DF88: 3D608261  lis r11, -0x7d9f
	ctx.r[11].s64 = -2107572224;
	// 8260DF8C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8260DF90: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260DF94: 3BABDDB8  addi r29, r11, -0x2248
	ctx.r[29].s64 = ctx.r[11].s64 + -8776;
	// 8260DF98: 4BC198E9  bl 0x82227880
	ctx.lr = 0x8260DF9C;
	sub_82227880(ctx, base);
	// 8260DF9C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8260DFA0: 3CC08255  lis r6, -0x7dab
	ctx.r[6].s64 = -2108358656;
	// 8260DFA4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8260DFA8: 3886BA08  addi r4, r6, -0x45f8
	ctx.r[4].s64 = ctx.r[6].s64 + -17912;
	// 8260DFAC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260DFB0: 93C70000  stw r30, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8260DFB4: 93A70004  stw r29, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8260DFB8: 4BB8CAC9  bl 0x8219aa80
	ctx.lr = 0x8260DFBC;
	sub_8219AA80(ctx, base);
	// 8260DFBC: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 8260DFC0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8260DFC4: 3BA58268  addi r29, r5, -0x7d98
	ctx.r[29].s64 = ctx.r[5].s64 + -32152;
	// 8260DFC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260DFCC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8260DFD0: 4BDC0451  bl 0x823ce420
	ctx.lr = 0x8260DFD4;
	sub_823CE420(ctx, base);
	// 8260DFD4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8260DFD8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8260DFDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260DFE0: 484166E9  bl 0x82a246c8
	ctx.lr = 0x8260DFE4;
	sub_82A246C8(ctx, base);
	// 8260DFE4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260DFE8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8260DFEC: 386BFFF8  addi r3, r11, -8
	ctx.r[3].s64 = ctx.r[11].s64 + -8;
	// 8260DFF0: 907C0008  stw r3, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 8260DFF4: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260DFF8: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260DFFC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260E000: 4BC1B109  bl 0x82229108
	ctx.lr = 0x8260E004;
	sub_82229108(ctx, base);
	// 8260E004: 3D608261  lis r11, -0x7d9f
	ctx.r[11].s64 = -2107572224;
	// 8260E008: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260E00C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8260E010: 3BABDE20  addi r29, r11, -0x21e0
	ctx.r[29].s64 = ctx.r[11].s64 + -8672;
	// 8260E014: 4BC1986D  bl 0x82227880
	ctx.lr = 0x8260E018;
	sub_82227880(ctx, base);
	// 8260E018: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8260E01C: 3D408245  lis r10, -0x7dbb
	ctx.r[10].s64 = -2109407232;
	// 8260E020: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8260E024: 388A1240  addi r4, r10, 0x1240
	ctx.r[4].s64 = ctx.r[10].s64 + 4672;
	// 8260E028: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260E02C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8260E030: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8260E034: 4BB8CA4D  bl 0x8219aa80
	ctx.lr = 0x8260E038;
	sub_8219AA80(ctx, base);
	// 8260E038: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8260E03C: 3BA98280  addi r29, r9, -0x7d80
	ctx.r[29].s64 = ctx.r[9].s64 + -32128;
	// 8260E040: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8260E044: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260E048: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8260E04C: 4BDC03D5  bl 0x823ce420
	ctx.lr = 0x8260E050;
	sub_823CE420(ctx, base);
	// 8260E050: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8260E054: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8260E058: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260E05C: 4841666D  bl 0x82a246c8
	ctx.lr = 0x8260E060;
	sub_82A246C8(ctx, base);
	// 8260E060: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260E064: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8260E068: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 8260E06C: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 8260E070: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260E074: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260E078: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8260E07C: 4BC1B08D  bl 0x82229108
	ctx.lr = 0x8260E080;
	sub_82229108(ctx, base);
	// 8260E080: 3D608261  lis r11, -0x7d9f
	ctx.r[11].s64 = -2107572224;
	// 8260E084: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8260E088: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8260E08C: 3BEBDE88  addi r31, r11, -0x2178
	ctx.r[31].s64 = ctx.r[11].s64 + -8568;
	// 8260E090: 4BC197F1  bl 0x82227880
	ctx.lr = 0x8260E094;
	sub_82227880(ctx, base);
	// 8260E094: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8260E098: 3CC08251  lis r6, -0x7daf
	ctx.r[6].s64 = -2108620800;
	// 8260E09C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8260E0A0: 38866BD8  addi r4, r6, 0x6bd8
	ctx.r[4].s64 = ctx.r[6].s64 + 27608;
	// 8260E0A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8260E0A8: 93C70000  stw r30, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8260E0AC: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8260E0B0: 4BB8C9D1  bl 0x8219aa80
	ctx.lr = 0x8260E0B4;
	sub_8219AA80(ctx, base);
	// 8260E0B4: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 8260E0B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8260E0BC: 3BE58294  addi r31, r5, -0x7d6c
	ctx.r[31].s64 = ctx.r[5].s64 + -32108;
	// 8260E0C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260E0C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8260E0C8: 4BDC0359  bl 0x823ce420
	ctx.lr = 0x8260E0CC;
	sub_823CE420(ctx, base);
	// 8260E0CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8260E0D0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8260E0D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8260E0D8: 484165F1  bl 0x82a246c8
	ctx.lr = 0x8260E0DC;
	sub_82A246C8(ctx, base);
	// 8260E0DC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260E0E0: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 8260E0E4: 909D0008  stw r4, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x8260E0E8; continue 'dispatch;
            }
            0x8260E0E8 => {
    //   block [0x8260E0E8..0x8260E100)
	// 8260E0E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260E0EC: 4BBA9A2D  bl 0x821b7b18
	ctx.lr = 0x8260E0F0;
	sub_821B7B18(ctx, base);
	// 8260E0F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8260E0F4: 4BBA9A25  bl 0x821b7b18
	ctx.lr = 0x8260E0F8;
	sub_821B7B18(ctx, base);
	// 8260E0F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8260E0FC: 4869B35C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260E100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260E100 size=240
    let mut pc: u32 = 0x8260E100;
    'dispatch: loop {
        match pc {
            0x8260E100 => {
    //   block [0x8260E100..0x8260E1F0)
	// 8260E100: 81630088  lwz r11, 0x88(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 8260E104: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8260E108: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 8260E10C: 3921FFD0  addi r9, r1, -0x30
	ctx.r[9].s64 = ctx.r[1].s64 + -48;
	// 8260E110: 38C1FFD0  addi r6, r1, -0x30
	ctx.r[6].s64 = ctx.r[1].s64 + -48;
	// 8260E114: 38A1FFF0  addi r5, r1, -0x10
	ctx.r[5].s64 = ctx.r[1].s64 + -16;
	// 8260E118: 3901FFE0  addi r8, r1, -0x20
	ctx.r[8].s64 = ctx.r[1].s64 + -32;
	// 8260E11C: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260E1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260E1F0 size=132
    let mut pc: u32 = 0x8260E1F0;
    'dispatch: loop {
        match pc {
            0x8260E1F0 => {
    //   block [0x8260E1F0..0x8260E218)
	// 8260E1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260E1F4: 4869B211  bl 0x82ca9404
	ctx.lr = 0x8260E1F8;
	sub_82CA93D0(ctx, base);
	// 8260E1F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260E1FC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8260E200: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8260E204: 3BDC0014  addi r30, r28, 0x14
	ctx.r[30].s64 = ctx.r[28].s64 + 20;
	// 8260E208: 807C0018  lwz r3, 0x18(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 8260E20C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260E210: 419A0008  beq cr6, 0x8260e218
	if ctx.cr[6].eq {
	pc = 0x8260E218; continue 'dispatch;
	}
	// 8260E214: 4BC0DB25  bl 0x8221bd38
	ctx.lr = 0x8260E218;
	sub_8221BD38(ctx, base);
	pc = 0x8260E218; continue 'dispatch;
            }
            0x8260E218 => {
    //   block [0x8260E218..0x8260E23C)
	// 8260E218: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8260E21C: 3BBC0004  addi r29, r28, 4
	ctx.r[29].s64 = ctx.r[28].s64 + 4;
	// 8260E220: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8260E224: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8260E228: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8260E22C: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260E230: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260E234: 419A0008  beq cr6, 0x8260e23c
	if ctx.cr[6].eq {
	pc = 0x8260E23C; continue 'dispatch;
	}
	// 8260E238: 4BC0DB01  bl 0x8221bd38
	ctx.lr = 0x8260E23C;
	sub_8221BD38(ctx, base);
	pc = 0x8260E23C; continue 'dispatch;
            }
            0x8260E23C => {
    //   block [0x8260E23C..0x8260E26C)
	// 8260E23C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8260E240: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8260E244: 576A07FE  clrlwi r10, r27, 0x1f
	ctx.r[10].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	// 8260E248: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8260E24C: 392B2B90  addi r9, r11, 0x2b90
	ctx.r[9].s64 = ctx.r[11].s64 + 11152;
	// 8260E250: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8260E254: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260E258: 913C0000  stw r9, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8260E25C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260E260: 419A000C  beq cr6, 0x8260e26c
	if ctx.cr[6].eq {
	pc = 0x8260E26C; continue 'dispatch;
	}
	// 8260E264: 4BC0DAD5  bl 0x8221bd38
	ctx.lr = 0x8260E268;
	sub_8221BD38(ctx, base);
	// 8260E268: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x8260E26C; continue 'dispatch;
            }
            0x8260E26C => {
    //   block [0x8260E26C..0x8260E274)
	// 8260E26C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8260E270: 4869B1E4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260E278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260E278 size=124
    let mut pc: u32 = 0x8260E278;
    'dispatch: loop {
        match pc {
            0x8260E278 => {
    //   block [0x8260E278..0x8260E2F4)
	// 8260E278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260E27C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8260E280: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8260E284: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260E288: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 8260E28C: 90810060  stw r4, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u32 ) };
	// 8260E290: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 8260E294: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 8260E298: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260E29C: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 8260E2A0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260E2F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260E2F8 size=144
    let mut pc: u32 = 0x8260E2F8;
    'dispatch: loop {
        match pc {
            0x8260E2F8 => {
    //   block [0x8260E2F8..0x8260E388)
	// 8260E2F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260E2FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8260E300: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8260E304: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8260E308: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260E30C: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 8260E310: 90810060  stw r4, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u32 ) };
	// 8260E314: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 8260E318: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 8260E31C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260E320: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8260E324: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260E388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8260E388 size=552
    let mut pc: u32 = 0x8260E388;
    'dispatch: loop {
        match pc {
            0x8260E388 => {
    //   block [0x8260E388..0x8260E444)
	// 8260E388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260E38C: 4869B07D  bl 0x82ca9408
	ctx.lr = 0x8260E390;
	sub_82CA93D0(ctx, base);
	// 8260E390: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260E394: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8260E398: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8260E39C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8260E3A0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260E3A4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8260E3A8: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 8260E3AC: 2F080010  cmpwi cr6, r8, 0x10
	ctx.cr[6].compare_i32(ctx.r[8].s32, 16, &mut ctx.xer);
	// 8260E3B0: 419801F4  blt cr6, 0x8260e5a4
	if ctx.cr[6].lt {
	pc = 0x8260E5A4; continue 'dispatch;
	}
	// 8260E3B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260E3B8: 409801EC  bge cr6, 0x8260e5a4
	if !ctx.cr[6].lt {
	pc = 0x8260E5A4; continue 'dispatch;
	}
	// 8260E3BC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8260E3C0: 392A9700  addi r9, r10, -0x6900
	ctx.r[9].s64 = ctx.r[10].s64 + -26880;
	// 8260E3C4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8260E3C8: 419A01DC  beq cr6, 0x8260e5a4
	if ctx.cr[6].eq {
	pc = 0x8260E5A4; continue 'dispatch;
	}
	// 8260E3CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260E3D0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8260E3D4: 409A01D0  bne cr6, 0x8260e5a4
	if !ctx.cr[6].eq {
	pc = 0x8260E5A4; continue 'dispatch;
	}
	// 8260E3D8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8260E3DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260E3E0: 4BC29CF1  bl 0x822380d0
	ctx.lr = 0x8260E3E4;
	sub_822380D0(ctx, base);
	// 8260E3E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8260E3E8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8260E3EC: 419A01B8  beq cr6, 0x8260e5a4
	if ctx.cr[6].eq {
	pc = 0x8260E5A4; continue 'dispatch;
	}
	// 8260E3F0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8260E3F4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8260E3F8: 38AB79B0  addi r5, r11, 0x79b0
	ctx.r[5].s64 = ctx.r[11].s64 + 31152;
	// 8260E3FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260E400: 4BC19BC9  bl 0x82227fc8
	ctx.lr = 0x8260E404;
	sub_82227FC8(ctx, base);
	// 8260E404: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8260E408: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8260E40C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260E410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260E414: 419A0100  beq cr6, 0x8260e514
	if ctx.cr[6].eq {
	pc = 0x8260E514; continue 'dispatch;
	}
	// 8260E418: 4BC19CE1  bl 0x822280f8
	ctx.lr = 0x8260E41C;
	sub_822280F8(ctx, base);
	// 8260E41C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260E420: 4BC19141  bl 0x82227560
	ctx.lr = 0x8260E424;
	sub_82227560(ctx, base);
	// 8260E424: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8260E428: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8260E42C: 419A0018  beq cr6, 0x8260e444
	if ctx.cr[6].eq {
	pc = 0x8260E444; continue 'dispatch;
	}
	// 8260E430: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 8260E434: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8260E438: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8260E43C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260E440: 409A0008  bne cr6, 0x8260e448
	if !ctx.cr[6].eq {
	pc = 0x8260E448; continue 'dispatch;
	}
	pc = 0x8260E444; continue 'dispatch;
            }
            0x8260E444 => {
    //   block [0x8260E444..0x8260E448)
	// 8260E444: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8260E448; continue 'dispatch;
            }
            0x8260E448 => {
    //   block [0x8260E448..0x8260E514)
	// 8260E448: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8260E44C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260E450: 419A0154  beq cr6, 0x8260e5a4
	if ctx.cr[6].eq {
	pc = 0x8260E5A4; continue 'dispatch;
	}
	// 8260E454: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260E458: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8260E45C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8260E460: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 8260E464: 2F080018  cmpwi cr6, r8, 0x18
	ctx.cr[6].compare_i32(ctx.r[8].s32, 24, &mut ctx.xer);
	// 8260E468: 4198013C  blt cr6, 0x8260e5a4
	if ctx.cr[6].lt {
	pc = 0x8260E5A4; continue 'dispatch;
	}
	// 8260E46C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8260E470: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 8260E474: 38AB7A20  addi r5, r11, 0x7a20
	ctx.r[5].s64 = ctx.r[11].s64 + 31264;
	// 8260E478: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260E47C: 4BC19B4D  bl 0x82227fc8
	ctx.lr = 0x8260E480;
	sub_82227FC8(ctx, base);
	// 8260E480: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8260E484: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260E488: 419A011C  beq cr6, 0x8260e5a4
	if ctx.cr[6].eq {
	pc = 0x8260E5A4; continue 'dispatch;
	}
	// 8260E48C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 8260E490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260E494: 4BC19C65  bl 0x822280f8
	ctx.lr = 0x8260E498;
	sub_822280F8(ctx, base);
	// 8260E498: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8260E49C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8260E4A0: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 8260E4A4: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 8260E4A8: 38E10064  addi r7, r1, 0x64
	ctx.r[7].s64 = ctx.r[1].s64 + 100;
	// 8260E4AC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8260E4B0: C02B9490  lfs f1, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8260E4B4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8260E4B8: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8260E4BC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8260E4C0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8260E4C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x8260E514; continue 'dispatch;
            }
            0x8260E514 => {
    //   block [0x8260E514..0x8260E5A4)
	// 8260E514: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8260E518: 38AB7A20  addi r5, r11, 0x7a20
	ctx.r[5].s64 = ctx.r[11].s64 + 31264;
	// 8260E51C: 4BC19AAD  bl 0x82227fc8
	ctx.lr = 0x8260E520;
	sub_82227FC8(ctx, base);
	// 8260E520: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8260E524: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260E528: 419A007C  beq cr6, 0x8260e5a4
	if ctx.cr[6].eq {
	pc = 0x8260E5A4; continue 'dispatch;
	}
	// 8260E52C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8260E530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260E534: 4BC19BC5  bl 0x822280f8
	ctx.lr = 0x8260E538;
	sub_822280F8(ctx, base);
	// 8260E538: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8260E53C: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 8260E540: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 8260E544: 38C1006C  addi r6, r1, 0x6c
	ctx.r[6].s64 = ctx.r[1].s64 + 108;
	// 8260E548: 39410064  addi r10, r1, 0x64
	ctx.r[10].s64 = ctx.r[1].s64 + 100;
	// 8260E54C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 8260E550: C02B9490  lfs f1, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8260E554: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8260E558: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8260E55C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8260E560: C1A94138  lfs f13, 0x4138(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16696 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8260E564: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260E568: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8260E56C: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	pc = 0x8260E5A4; continue 'dispatch;
            }
            0x8260E5A4 => {
    //   block [0x8260E5A4..0x8260E5B0)
	// 8260E5A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8260E5A8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8260E5AC: 4869AEAC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260E5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260E5B0 size=204
    let mut pc: u32 = 0x8260E5B0;
    'dispatch: loop {
        match pc {
            0x8260E5B0 => {
    //   block [0x8260E5B0..0x8260E664)
	// 8260E5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260E5B4: 4869AE59  bl 0x82ca940c
	ctx.lr = 0x8260E5B8;
	sub_82CA93D0(ctx, base);
	// 8260E5B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260E5BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8260E5C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8260E5C4: 4BDBFFFD  bl 0x823ce5c0
	ctx.lr = 0x8260E5C8;
	sub_823CE5C0(ctx, base);
	// 8260E5C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8260E5CC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8260E5D0: 38AB82B0  addi r5, r11, -0x7d50
	ctx.r[5].s64 = ctx.r[11].s64 + -32080;
	// 8260E5D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260E5D8: 4BDBFC29  bl 0x823ce200
	ctx.lr = 0x8260E5DC;
	sub_823CE200(ctx, base);
	// 8260E5DC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8260E5E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260E5E4: 419A0080  beq cr6, 0x8260e664
	if ctx.cr[6].eq {
	pc = 0x8260E664; continue 'dispatch;
	}
	// 8260E5E8: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260E5EC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8260E5F0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260E5F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8260E5F8: 4BC1AB11  bl 0x82229108
	ctx.lr = 0x8260E5FC;
	sub_82229108(ctx, base);
	// 8260E5FC: 3D608261  lis r11, -0x7d9f
	ctx.r[11].s64 = -2107572224;
	// 8260E600: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8260E604: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8260E608: 3BEBE388  addi r31, r11, -0x1c78
	ctx.r[31].s64 = ctx.r[11].s64 + -7288;
	// 8260E60C: 4BC19275  bl 0x82227880
	ctx.lr = 0x8260E610;
	sub_82227880(ctx, base);
	// 8260E610: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8260E614: 3D408248  lis r10, -0x7db8
	ctx.r[10].s64 = -2109210624;
	// 8260E618: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8260E61C: 388A1200  addi r4, r10, 0x1200
	ctx.r[4].s64 = ctx.r[10].s64 + 4608;
	// 8260E620: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8260E624: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8260E628: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8260E62C: 4BB8C455  bl 0x8219aa80
	ctx.lr = 0x8260E630;
	sub_8219AA80(ctx, base);
	// 8260E630: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8260E634: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8260E638: 3BE982C0  addi r31, r9, -0x7d40
	ctx.r[31].s64 = ctx.r[9].s64 + -32064;
	// 8260E63C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260E640: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8260E644: 4BDBFDDD  bl 0x823ce420
	ctx.lr = 0x8260E648;
	sub_823CE420(ctx, base);
	// 8260E648: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8260E64C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8260E650: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8260E654: 48416075  bl 0x82a246c8
	ctx.lr = 0x8260E658;
	sub_82A246C8(ctx, base);
	// 8260E658: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260E65C: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 8260E660: 911D0008  stw r8, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x8260E664; continue 'dispatch;
            }
            0x8260E664 => {
    //   block [0x8260E664..0x8260E67C)
	// 8260E664: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260E668: 4BBA94B1  bl 0x821b7b18
	ctx.lr = 0x8260E66C;
	sub_821B7B18(ctx, base);
	// 8260E66C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8260E670: 4BBA94A9  bl 0x821b7b18
	ctx.lr = 0x8260E674;
	sub_821B7B18(ctx, base);
	// 8260E674: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8260E678: 4869ADE4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260E680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260E680 size=208
    let mut pc: u32 = 0x8260E680;
    'dispatch: loop {
        match pc {
            0x8260E680 => {
    //   block [0x8260E680..0x8260E708)
	// 8260E680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260E684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8260E688: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8260E68C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8260E690: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260E694: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8260E698: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8260E69C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8260E6A0: 4099008C  ble cr6, 0x8260e72c
	if !ctx.cr[6].gt {
	pc = 0x8260E72C; continue 'dispatch;
	}
	// 8260E6A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8260E6A8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8260E6AC: 388B82CC  addi r4, r11, -0x7d34
	ctx.r[4].s64 = ctx.r[11].s64 + -32052;
	// 8260E6B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260E6B4: 4BC1E81D  bl 0x8222ced0
	ctx.lr = 0x8260E6B8;
	sub_8222CED0(ctx, base);
	// 8260E6B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8260E6BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8260E6C0: 4BB8DF29  bl 0x8219c5e8
	ctx.lr = 0x8260E6C4;
	sub_8219C5E8(ctx, base);
	// 8260E6C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260E6C8: 4BC06711  bl 0x82214dd8
	ctx.lr = 0x8260E6CC;
	sub_82214DD8(ctx, base);
	// 8260E6CC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8260E6D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260E6D4: 419A0058  beq cr6, 0x8260e72c
	if ctx.cr[6].eq {
	pc = 0x8260E72C; continue 'dispatch;
	}
	// 8260E6D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8260E6DC: 4BBA3E1D  bl 0x821b24f8
	ctx.lr = 0x8260E6E0;
	sub_821B24F8(ctx, base);
	// 8260E6E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8260E6E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8260E6E8: 483F22A9  bl 0x82a00990
	ctx.lr = 0x8260E6EC;
	sub_82A00990(ctx, base);
	// 8260E6EC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8260E6F0: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8260E6F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260E6F8: 40980010  bge cr6, 0x8260e708
	if !ctx.cr[6].lt {
	pc = 0x8260E708; continue 'dispatch;
	}
	// 8260E6FC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 8260E700: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8260E704: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	pc = 0x8260E708; continue 'dispatch;
            }
            0x8260E708 => {
    //   block [0x8260E708..0x8260E724)
	// 8260E708: 419A001C  beq cr6, 0x8260e724
	if ctx.cr[6].eq {
	pc = 0x8260E724; continue 'dispatch;
	}
	// 8260E70C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8260E710: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8260E714: 48174E15  bl 0x82783528
	ctx.lr = 0x8260E718;
	sub_82783528(ctx, base);
	// 8260E718: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8260E71C: 4BC0D61D  bl 0x8221bd38
	ctx.lr = 0x8260E720;
	sub_8221BD38(ctx, base);
	// 8260E720: 48000014  b 0x8260e734
	pc = 0x8260E734; continue 'dispatch;
            }
            0x8260E724 => {
    //   block [0x8260E724..0x8260E72C)
	// 8260E724: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8260E728: 4BC0D611  bl 0x8221bd38
	ctx.lr = 0x8260E72C;
	sub_8221BD38(ctx, base);
	pc = 0x8260E72C; continue 'dispatch;
            }
            0x8260E72C => {
    //   block [0x8260E72C..0x8260E734)
	// 8260E72C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260E730: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8260E734; continue 'dispatch;
            }
            0x8260E734 => {
    //   block [0x8260E734..0x8260E750)
	// 8260E734: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8260E738: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8260E73C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260E740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8260E744: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8260E748: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8260E74C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260E750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260E750 size=276
    let mut pc: u32 = 0x8260E750;
    'dispatch: loop {
        match pc {
            0x8260E750 => {
    //   block [0x8260E750..0x8260E790)
	// 8260E750: 80A40024  lwz r5, 0x24(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 8260E754: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8260E758: 54AAE7FE  rlwinm r10, r5, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x0000000Fu64;
	// 8260E75C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8260E760: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260E764: 419A00E8  beq cr6, 0x8260e84c
	if ctx.cr[6].eq {
	pc = 0x8260E84C; continue 'dispatch;
	}
	// 8260E768: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 8260E76C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260E770: 419A0020  beq cr6, 0x8260e790
	if ctx.cr[6].eq {
	pc = 0x8260E790; continue 'dispatch;
	}
	// 8260E774: 894B0004  lbz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260E778: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8260E77C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8260E780: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8260E784: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8260E788: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260E78C: 480000C4  b 0x8260e850
	pc = 0x8260E850; continue 'dispatch;
            }
            0x8260E790 => {
    //   block [0x8260E790..0x8260E7AC)
	// 8260E790: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8260E794: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 8260E798: 9061FFF0  stw r3, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[3].u32 ) };
	// 8260E79C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8260E7A0: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 8260E7A4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8260E7A8: 40810054  ble 0x8260e7fc
	if !ctx.cr[0].gt {
	pc = 0x8260E7FC; continue 'dispatch;
	}
	pc = 0x8260E7AC; continue 'dispatch;
            }
            0x8260E7AC => {
    //   block [0x8260E7AC..0x8260E7CC)
	// 8260E7AC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8260E7B0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8260E7B4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8260E7B8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260E7BC: 2F070004  cmpwi cr6, r7, 4
	ctx.cr[6].compare_i32(ctx.r[7].s32, 4, &mut ctx.xer);
	// 8260E7C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8260E7C4: 41980008  blt cr6, 0x8260e7cc
	if ctx.cr[6].lt {
	pc = 0x8260E7CC; continue 'dispatch;
	}
	// 8260E7C8: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x8260E7CC; continue 'dispatch;
            }
            0x8260E7CC => {
    //   block [0x8260E7CC..0x8260E7E8)
	// 8260E7CC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8260E7D0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8260E7D4: 419A0014  beq cr6, 0x8260e7e8
	if ctx.cr[6].eq {
	pc = 0x8260E7E8; continue 'dispatch;
	}
	// 8260E7D8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8260E7DC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8260E7E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8260E7E4: 4800000C  b 0x8260e7f0
	pc = 0x8260E7F0; continue 'dispatch;
            }
            0x8260E7E8 => {
    //   block [0x8260E7E8..0x8260E7F0)
	// 8260E7E8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8260E7EC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8260E7F0; continue 'dispatch;
            }
            0x8260E7F0 => {
    //   block [0x8260E7F0..0x8260E7FC)
	// 8260E7F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8260E7F4: 4199FFB8  bgt cr6, 0x8260e7ac
	if ctx.cr[6].gt {
	pc = 0x8260E7AC; continue 'dispatch;
	}
	// 8260E7F8: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	pc = 0x8260E7FC; continue 'dispatch;
            }
            0x8260E7FC => {
    //   block [0x8260E7FC..0x8260E818)
	// 8260E7FC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8260E800: 419A003C  beq cr6, 0x8260e83c
	if ctx.cr[6].eq {
	pc = 0x8260E83C; continue 'dispatch;
	}
	// 8260E804: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260E808: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8260E80C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8260E810: 41990008  bgt cr6, 0x8260e818
	if ctx.cr[6].gt {
	pc = 0x8260E818; continue 'dispatch;
	}
	// 8260E814: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x8260E818; continue 'dispatch;
            }
            0x8260E818 => {
    //   block [0x8260E818..0x8260E83C)
	// 8260E818: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8260E81C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260E820: 409A001C  bne cr6, 0x8260e83c
	if !ctx.cr[6].eq {
	pc = 0x8260E83C; continue 'dispatch;
	}
	// 8260E824: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8260E828: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8260E82C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 8260E830: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 8260E834: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260E838: 48000018  b 0x8260e850
	pc = 0x8260E850; continue 'dispatch;
            }
            0x8260E83C => {
    //   block [0x8260E83C..0x8260E84C)
	// 8260E83C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8260E840: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8260E844: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260E848: 48000008  b 0x8260e850
	pc = 0x8260E850; continue 'dispatch;
            }
            0x8260E84C => {
    //   block [0x8260E84C..0x8260E850)
	// 8260E84C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	pc = 0x8260E850; continue 'dispatch;
            }
            0x8260E850 => {
    //   block [0x8260E850..0x8260E864)
	// 8260E850: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8260E854: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260E858: 419A000C  beq cr6, 0x8260e864
	if ctx.cr[6].eq {
		sub_8260E864(ctx, base);
		return;
	}
	// 8260E85C: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8260E860: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260E864(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260E864 size=408
    let mut pc: u32 = 0x8260E864;
    'dispatch: loop {
        match pc {
            0x8260E864 => {
    //   block [0x8260E864..0x8260E89C)
	// 8260E864: 54AADFFE  rlwinm r10, r5, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 8260E868: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8260E86C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260E870: 419A00E4  beq cr6, 0x8260e954
	if ctx.cr[6].eq {
	pc = 0x8260E954; continue 'dispatch;
	}
	// 8260E874: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 8260E878: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8260E87C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260E880: 419A001C  beq cr6, 0x8260e89c
	if ctx.cr[6].eq {
	pc = 0x8260E89C; continue 'dispatch;
	}
	// 8260E884: 896B0005  lbz r11, 5(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 8260E888: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8260E88C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8260E890: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260E894: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8260E898: 480000C0  b 0x8260e958
	pc = 0x8260E958; continue 'dispatch;
            }
            0x8260E89C => {
    //   block [0x8260E89C..0x8260E8B4)
	// 8260E89C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 8260E8A0: 9061FFF0  stw r3, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[3].u32 ) };
	// 8260E8A4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8260E8A8: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 8260E8AC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8260E8B0: 40810054  ble 0x8260e904
	if !ctx.cr[0].gt {
	pc = 0x8260E904; continue 'dispatch;
	}
	pc = 0x8260E8B4; continue 'dispatch;
            }
            0x8260E8B4 => {
    //   block [0x8260E8B4..0x8260E8D4)
	// 8260E8B4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8260E8B8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8260E8BC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8260E8C0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260E8C4: 2F070005  cmpwi cr6, r7, 5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 5, &mut ctx.xer);
	// 8260E8C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8260E8CC: 41980008  blt cr6, 0x8260e8d4
	if ctx.cr[6].lt {
	pc = 0x8260E8D4; continue 'dispatch;
	}
	// 8260E8D0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x8260E8D4; continue 'dispatch;
            }
            0x8260E8D4 => {
    //   block [0x8260E8D4..0x8260E8F0)
	// 8260E8D4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8260E8D8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8260E8DC: 419A0014  beq cr6, 0x8260e8f0
	if ctx.cr[6].eq {
	pc = 0x8260E8F0; continue 'dispatch;
	}
	// 8260E8E0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8260E8E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8260E8E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8260E8EC: 4800000C  b 0x8260e8f8
	pc = 0x8260E8F8; continue 'dispatch;
            }
            0x8260E8F0 => {
    //   block [0x8260E8F0..0x8260E8F8)
	// 8260E8F0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8260E8F4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8260E8F8; continue 'dispatch;
            }
            0x8260E8F8 => {
    //   block [0x8260E8F8..0x8260E904)
	// 8260E8F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8260E8FC: 4199FFB8  bgt cr6, 0x8260e8b4
	if ctx.cr[6].gt {
	pc = 0x8260E8B4; continue 'dispatch;
	}
	// 8260E900: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	pc = 0x8260E904; continue 'dispatch;
            }
            0x8260E904 => {
    //   block [0x8260E904..0x8260E920)
	// 8260E904: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8260E908: 419A003C  beq cr6, 0x8260e944
	if ctx.cr[6].eq {
	pc = 0x8260E944; continue 'dispatch;
	}
	// 8260E90C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260E910: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 8260E914: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8260E918: 41990008  bgt cr6, 0x8260e920
	if ctx.cr[6].gt {
	pc = 0x8260E920; continue 'dispatch;
	}
	// 8260E91C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x8260E920; continue 'dispatch;
            }
            0x8260E920 => {
    //   block [0x8260E920..0x8260E944)
	// 8260E920: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8260E924: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260E928: 409A001C  bne cr6, 0x8260e944
	if !ctx.cr[6].eq {
	pc = 0x8260E944; continue 'dispatch;
	}
	// 8260E92C: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8260E930: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8260E934: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 8260E938: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 8260E93C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260E940: 48000018  b 0x8260e958
	pc = 0x8260E958; continue 'dispatch;
            }
            0x8260E944 => {
    //   block [0x8260E944..0x8260E954)
	// 8260E944: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8260E948: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8260E94C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260E950: 48000008  b 0x8260e958
	pc = 0x8260E958; continue 'dispatch;
            }
            0x8260E954 => {
    //   block [0x8260E954..0x8260E958)
	// 8260E954: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	pc = 0x8260E958; continue 'dispatch;
            }
            0x8260E958 => {
    //   block [0x8260E958..0x8260E97C)
	// 8260E958: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8260E95C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260E960: 419A009C  beq cr6, 0x8260e9fc
	if ctx.cr[6].eq {
		sub_8260E9FC(ctx, base);
		return;
	}
	// 8260E964: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 8260E968: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8260E96C: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260E970: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260E974: 40990008  ble cr6, 0x8260e97c
	if !ctx.cr[6].gt {
	pc = 0x8260E97C; continue 'dispatch;
	}
	// 8260E978: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260E97C; continue 'dispatch;
            }
            0x8260E97C => {
    //   block [0x8260E97C..0x8260E984)
	// 8260E97C: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260E980: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x8260E984; continue 'dispatch;
            }
            0x8260E984 => {
    //   block [0x8260E984..0x8260E990)
	// 8260E984: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8260E988: 40990008  ble cr6, 0x8260e990
	if !ctx.cr[6].gt {
	pc = 0x8260E990; continue 'dispatch;
	}
	// 8260E98C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260E990; continue 'dispatch;
            }
            0x8260E990 => {
    //   block [0x8260E990..0x8260E99C)
	// 8260E990: 7F094840  cmplw cr6, r9, r9
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8260E994: 419A0008  beq cr6, 0x8260e99c
	if ctx.cr[6].eq {
	pc = 0x8260E99C; continue 'dispatch;
	}
	// 8260E998: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260E99C; continue 'dispatch;
            }
            0x8260E99C => {
    //   block [0x8260E99C..0x8260E9B0)
	// 8260E99C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8260E9A0: 419A005C  beq cr6, 0x8260e9fc
	if ctx.cr[6].eq {
		sub_8260E9FC(ctx, base);
		return;
	}
	// 8260E9A4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260E9A8: 41980008  blt cr6, 0x8260e9b0
	if ctx.cr[6].lt {
	pc = 0x8260E9B0; continue 'dispatch;
	}
	// 8260E9AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260E9B0; continue 'dispatch;
            }
            0x8260E9B0 => {
    //   block [0x8260E9B0..0x8260E9C8)
	// 8260E9B0: 88CB003C  lbz r6, 0x3c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 8260E9B4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8260E9B8: 419A001C  beq cr6, 0x8260e9d4
	if ctx.cr[6].eq {
	pc = 0x8260E9D4; continue 'dispatch;
	}
	// 8260E9BC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260E9C0: 41980008  blt cr6, 0x8260e9c8
	if ctx.cr[6].lt {
	pc = 0x8260E9C8; continue 'dispatch;
	}
	// 8260E9C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260E9C8; continue 'dispatch;
            }
            0x8260E9C8 => {
    //   block [0x8260E9C8..0x8260E9D4)
	// 8260E9C8: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260E9CC: 2F06FFFF  cmpwi cr6, r6, -1
	ctx.cr[6].compare_i32(ctx.r[6].s32, -1, &mut ctx.xer);
	// 8260E9D0: 409A0018  bne cr6, 0x8260e9e8
	if !ctx.cr[6].eq {
	pc = 0x8260E9E8; continue 'dispatch;
	}
	pc = 0x8260E9D4; continue 'dispatch;
            }
            0x8260E9D4 => {
    //   block [0x8260E9D4..0x8260E9E0)
	// 8260E9D4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260E9D8: 41980008  blt cr6, 0x8260e9e0
	if ctx.cr[6].lt {
	pc = 0x8260E9E0; continue 'dispatch;
	}
	// 8260E9DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260E9E0; continue 'dispatch;
            }
            0x8260E9E0 => {
    //   block [0x8260E9E0..0x8260E9E8)
	// 8260E9E0: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 8260E9E4: 4BFFFFA0  b 0x8260e984
	pc = 0x8260E984; continue 'dispatch;
            }
            0x8260E9E8 => {
    //   block [0x8260E9E8..0x8260E9F4)
	// 8260E9E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260E9EC: 41980008  blt cr6, 0x8260e9f4
	if ctx.cr[6].lt {
	pc = 0x8260E9F4; continue 'dispatch;
	}
	// 8260E9F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260E9F4; continue 'dispatch;
            }
            0x8260E9F4 => {
    //   block [0x8260E9F4..0x8260E9FC)
	// 8260E9F4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260E9F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260E9FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260E9FC size=8
    let mut pc: u32 = 0x8260E9FC;
    'dispatch: loop {
        match pc {
            0x8260E9FC => {
    //   block [0x8260E9FC..0x8260EA04)
	// 8260E9FC: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 8260EA00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260EA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260EA08 size=204
    let mut pc: u32 = 0x8260EA08;
    'dispatch: loop {
        match pc {
            0x8260EA08 => {
    //   block [0x8260EA08..0x8260EA2C)
	// 8260EA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260EA0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8260EA10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260EA14: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260EA18: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 8260EA1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260EA20: 409A000C  bne cr6, 0x8260ea2c
	if !ctx.cr[6].eq {
	pc = 0x8260EA2C; continue 'dispatch;
	}
	// 8260EA24: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8260EA28: 48000010  b 0x8260ea38
	pc = 0x8260EA38; continue 'dispatch;
            }
            0x8260EA2C => {
    //   block [0x8260EA2C..0x8260EA38)
	// 8260EA2C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8260EA30: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8260EA34: 7D293670  srawi r9, r9, 6
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 6) as i64;
	pc = 0x8260EA38; continue 'dispatch;
            }
            0x8260EA38 => {
    //   block [0x8260EA38..0x8260EA94)
	// 8260EA38: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260EA3C: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8260EA40: 7D483670  srawi r8, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 6) as i64;
	// 8260EA44: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8260EA48: 40980064  bge cr6, 0x8260eaac
	if !ctx.cr[6].lt {
	pc = 0x8260EAAC; continue 'dispatch;
	}
	// 8260EA4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260EA50: 419A0044  beq cr6, 0x8260ea94
	if ctx.cr[6].eq {
	pc = 0x8260EA94; continue 'dispatch;
	}
	// 8260EA54: 81060000  lwz r8, 0(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260EA58: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8260EA5C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8260EA60: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8260EA64: 80E60004  lwz r7, 4(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260EA68: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 8260EA6C: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260EA70: 90AB0008  stw r5, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	pc = 0x8260EA94; continue 'dispatch;
            }
            0x8260EA94 => {
    //   block [0x8260EA94..0x8260EAAC)
	// 8260EA94: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 8260EA98: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8260EA9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8260EAA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260EAA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8260EAA8: 4E800020  blr
	return;
            }
            0x8260EAAC => {
    //   block [0x8260EAAC..0x8260EAD4)
	// 8260EAAC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8260EAB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8260EAB4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8260EAB8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8260EABC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8260EAC0: 48000091  bl 0x8260eb50
	ctx.lr = 0x8260EAC4;
	sub_8260EB50(ctx, base);
	// 8260EAC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8260EAC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260EACC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8260EAD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260EAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260EAD8 size=116
    let mut pc: u32 = 0x8260EAD8;
    'dispatch: loop {
        match pc {
            0x8260EAD8 => {
    //   block [0x8260EAD8..0x8260EB38)
	// 8260EAD8: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 8260EADC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8260EAE0: 419A0060  beq cr6, 0x8260eb40
	if ctx.cr[6].eq {
	pc = 0x8260EB40; continue 'dispatch;
	}
	// 8260EAE4: 39640008  addi r11, r4, 8
	ctx.r[11].s64 = ctx.r[4].s64 + 8;
	// 8260EAE8: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8260EAEC: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 8260EAF0: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8260EAF4: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 8260EAF8: 346BFFF8  addic. r3, r11, -8
	ctx.xer.ca = (ctx.r[11].u32 > (!(-8 as u32)));
	ctx.r[3].s64 = ctx.r[11].s64 + -8;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8260EAFC: 4182003C  beq 0x8260eb38
	if ctx.cr[0].eq {
	pc = 0x8260EB38; continue 'dispatch;
	}
	// 8260EB00: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260EB04: 906BFFF8  stw r3, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[3].u32 ) };
	// 8260EB08: 80660004  lwz r3, 4(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260EB0C: 906BFFFC  stw r3, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[3].u32 ) };
	// 8260EB10: 80660008  lwz r3, 8(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260EB14: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x8260EB38; continue 'dispatch;
            }
            0x8260EB38 => {
    //   block [0x8260EB38..0x8260EB40)
	// 8260EB38: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 8260EB3C: 4200FFBC  bdnz 0x8260eaf8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8260EAF8; continue 'dispatch;
	}
	pc = 0x8260EB40; continue 'dispatch;
            }
            0x8260EB40 => {
    //   block [0x8260EB40..0x8260EB4C)
	// 8260EB40: 54AB3032  slwi r11, r5, 6
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8260EB44: 7C6B2214  add r3, r11, r4
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 8260EB48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260EB50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8260EB50 size=612
    let mut pc: u32 = 0x8260EB50;
    'dispatch: loop {
        match pc {
            0x8260EB50 => {
    //   block [0x8260EB50..0x8260EDB4)
	// 8260EB50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260EB54: 4869A8B5  bl 0x82ca9408
	ctx.lr = 0x8260EB58;
	sub_82CA93D0(ctx, base);
	// 8260EB58: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260EB5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260EB60: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260EB64: 81060004  lwz r8, 4(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260EB68: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8260EB6C: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260EB70: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 8260EB74: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 8260EB78: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8260EB7C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8260EB80: C0060030  lfs f0, 0x30(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8260EB84: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260EB88: C1A60034  lfs f13, 0x34(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260EDB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260EDB8 size=132
    let mut pc: u32 = 0x8260EDB8;
    'dispatch: loop {
        match pc {
            0x8260EDB8 => {
    //   block [0x8260EDB8..0x8260EE3C)
	// 8260EDB8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 8260EDBC: 7D692050  subf r11, r9, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 8260EDC0: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 8260EDC4: 7D6A3670  srawi r10, r11, 6
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 6) as i64;
	// 8260EDC8: 554B3032  slwi r11, r10, 6
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8260EDCC: 7C6B2A14  add r3, r11, r5
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 8260EDD0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8260EDD4: 39490010  addi r10, r9, 0x10
	ctx.r[10].s64 = ctx.r[9].s64 + 16;
	// 8260EDD8: 39650008  addi r11, r5, 8
	ctx.r[11].s64 = ctx.r[5].s64 + 8;
	// 8260EDDC: 7D254850  subf r9, r5, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[5].s64;
	// 8260EDE0: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 8260EDE4: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8260EDE8: 39000018  li r8, 0x18
	ctx.r[8].s64 = 24;
	// 8260EDEC: 80AAFFF0  lwz r5, -0x10(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16 as u32) ) } as u64;
	// 8260EDF0: 90ABFFF8  stw r5, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[5].u32 ) };
	// 8260EDF4: 80AAFFF4  lwz r5, -0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 8260EDF8: 90ABFFFC  stw r5, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[5].u32 ) };
	// 8260EDFC: 7CA9582E  lwzx r5, r9, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8260EE00: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260EE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260EE40 size=124
    let mut pc: u32 = 0x8260EE40;
    'dispatch: loop {
        match pc {
            0x8260EE40 => {
    //   block [0x8260EE40..0x8260EEA4)
	// 8260EE40: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 8260EE44: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 8260EE48: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8260EE4C: 39640008  addi r11, r4, 8
	ctx.r[11].s64 = ctx.r[4].s64 + 8;
	// 8260EE50: 7D441850  subf r10, r4, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	// 8260EE54: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 8260EE58: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8260EE5C: 39000018  li r8, 0x18
	ctx.r[8].s64 = 24;
	// 8260EE60: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8260EE64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260EE68: 419A003C  beq cr6, 0x8260eea4
	if ctx.cr[6].eq {
	pc = 0x8260EEA4; continue 'dispatch;
	}
	// 8260EE6C: 808BFFF8  lwz r4, -8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260EE70: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 8260EE74: 808BFFFC  lwz r4, -4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8260EE78: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 8260EE7C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260EE80: 7C8A592E  stwx r4, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[4].u32) };
	pc = 0x8260EEA4; continue 'dispatch;
            }
            0x8260EEA4 => {
    //   block [0x8260EEA4..0x8260EEBC)
	// 8260EEA4: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 8260EEA8: 38630040  addi r3, r3, 0x40
	ctx.r[3].s64 = ctx.r[3].s64 + 64;
	// 8260EEAC: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 8260EEB0: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 8260EEB4: 409AFFB0  bne cr6, 0x8260ee64
	if !ctx.cr[6].eq {
	pc = 0x8260EE64; continue 'dispatch;
	}
	// 8260EEB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260EEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260EEC0 size=104
    let mut pc: u32 = 0x8260EEC0;
    'dispatch: loop {
        match pc {
            0x8260EEC0 => {
    //   block [0x8260EEC0..0x8260EF28)
	// 8260EEC0: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 8260EEC4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8260EEC8: 39450010  addi r10, r5, 0x10
	ctx.r[10].s64 = ctx.r[5].s64 + 16;
	// 8260EECC: 39250020  addi r9, r5, 0x20
	ctx.r[9].s64 = ctx.r[5].s64 + 32;
	// 8260EED0: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 8260EED4: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 8260EED8: 39000018  li r8, 0x18
	ctx.r[8].s64 = 24;
	// 8260EEDC: 80C50000  lwz r6, 0(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260EEE0: 90CBFFF8  stw r6, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[6].u32 ) };
	// 8260EEE4: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260EEE8: 906BFFFC  stw r3, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[3].u32 ) };
	// 8260EEEC: 80C50008  lwz r6, 8(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260EEF0: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260EF28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260EF28 size=60
    let mut pc: u32 = 0x8260EF28;
    'dispatch: loop {
        match pc {
            0x8260EF28 => {
    //   block [0x8260EF28..0x8260EF64)
	// 8260EF28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260EF2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8260EF30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8260EF34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260EF38: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8260EF3C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8260EF40: 388B8740  addi r4, r11, -0x78c0
	ctx.r[4].s64 = ctx.r[11].s64 + -30912;
	// 8260EF44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260EF48: 4BC1DF89  bl 0x8222ced0
	ctx.lr = 0x8260EF4C;
	sub_8222CED0(ctx, base);
	// 8260EF4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260EF50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8260EF54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260EF58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8260EF5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8260EF60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260EF78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260EF78 size=216
    let mut pc: u32 = 0x8260EF78;
    'dispatch: loop {
        match pc {
            0x8260EF78 => {
    //   block [0x8260EF78..0x8260EFAC)
	// 8260EF78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260EF7C: 4869A485  bl 0x82ca9400
	ctx.lr = 0x8260EF80;
	sub_82CA93D0(ctx, base);
	// 8260EF80: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260EF84: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8260EF88: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8260EF8C: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 8260EF90: 834B0010  lwz r26, 0x10(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8260EF94: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8260EF98: 419A00A0  beq cr6, 0x8260f038
	if ctx.cr[6].eq {
	pc = 0x8260F038; continue 'dispatch;
	}
	// 8260EF9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8260EFA0: 83C40000  lwz r30, 0(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260EFA4: 83FC0020  lwz r31, 0x20(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 8260EFA8: 3B6B0CA0  addi r27, r11, 0xca0
	ctx.r[27].s64 = ctx.r[11].s64 + 3232;
	pc = 0x8260EFAC; continue 'dispatch;
            }
            0x8260EFAC => {
    //   block [0x8260EFAC..0x8260EFC0)
	// 8260EFAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260EFB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8260EFB4: 4098000C  bge cr6, 0x8260efc0
	if !ctx.cr[6].lt {
	pc = 0x8260EFC0; continue 'dispatch;
	}
	// 8260EFB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260EFBC: 48000010  b 0x8260efcc
	pc = 0x8260EFCC; continue 'dispatch;
            }
            0x8260EFC0 => {
    //   block [0x8260EFC0..0x8260EFCC)
	// 8260EFC0: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260EFC4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8260EFC8: 7D69502E  lwzx r11, r9, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	pc = 0x8260EFCC; continue 'dispatch;
            }
            0x8260EFCC => {
    //   block [0x8260EFCC..0x8260EFDC)
	// 8260EFCC: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8260EFD0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8260EFD4: 409A0034  bne cr6, 0x8260f008
	if !ctx.cr[6].eq {
	pc = 0x8260F008; continue 'dispatch;
	}
	// 8260EFD8: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	pc = 0x8260EFDC; continue 'dispatch;
            }
            0x8260EFDC => {
    //   block [0x8260EFDC..0x8260F000)
	// 8260EFDC: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260EFE0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260EFE4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8260EFE8: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 8260EFEC: 419A0014  beq cr6, 0x8260f000
	if ctx.cr[6].eq {
	pc = 0x8260F000; continue 'dispatch;
	}
	// 8260EFF0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8260EFF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8260EFF8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8260EFFC: 419AFFE0  beq cr6, 0x8260efdc
	if ctx.cr[6].eq {
	pc = 0x8260EFDC; continue 'dispatch;
	}
	pc = 0x8260F000; continue 'dispatch;
            }
            0x8260F000 => {
    //   block [0x8260F000..0x8260F008)
	// 8260F000: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 8260F004: 48000014  b 0x8260f018
	pc = 0x8260F018; continue 'dispatch;
            }
            0x8260F008 => {
    //   block [0x8260F008..0x8260F018)
	// 8260F008: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8260F00C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260F010: 4BC5E7E9  bl 0x8226d7f8
	ctx.lr = 0x8260F014;
	sub_8226D7F8(ctx, base);
	// 8260F014: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	pc = 0x8260F018; continue 'dispatch;
            }
            0x8260F018 => {
    //   block [0x8260F018..0x8260F038)
	// 8260F018: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8260F01C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8260F020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260F024: 409A0020  bne cr6, 0x8260f044
	if !ctx.cr[6].eq {
	pc = 0x8260F044; continue 'dispatch;
	}
	// 8260F028: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 8260F02C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 8260F030: 7F1DD040  cmplw cr6, r29, r26
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8260F034: 409AFF78  bne cr6, 0x8260efac
	if !ctx.cr[6].eq {
	pc = 0x8260EFAC; continue 'dispatch;
	}
	pc = 0x8260F038; continue 'dispatch;
            }
            0x8260F038 => {
    //   block [0x8260F038..0x8260F044)
	// 8260F038: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 8260F03C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8260F040: 4869A410  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x8260F044 => {
    //   block [0x8260F044..0x8260F050)
	// 8260F044: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8260F048: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8260F04C: 4869A404  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260F050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8260F050 size=112
    let mut pc: u32 = 0x8260F050;
    'dispatch: loop {
        match pc {
            0x8260F050 => {
    //   block [0x8260F050..0x8260F0C0)
	// 8260F050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260F054: 4869A3B9  bl 0x82ca940c
	ctx.lr = 0x8260F058;
	sub_82CA93D0(ctx, base);
	// 8260F058: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8260F05C: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260F060: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260F064: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8260F068: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 8260F06C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8260F070: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8260F074: 83BF0018  lwz r29, 0x18(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8260F078: 388B00E0  addi r4, r11, 0xe0
	ctx.r[4].s64 = ctx.r[11].s64 + 224;
	// 8260F07C: 48748285  bl 0x82d57300
	ctx.lr = 0x8260F080;
	sub_82D57300(ctx, base);
	// 8260F080: 38BF0060  addi r5, r31, 0x60
	ctx.r[5].s64 = ctx.r[31].s64 + 96;
	// 8260F084: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8260F088: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8260F08C: 48748275  bl 0x82d57300
	ctx.lr = 0x8260F090;
	sub_82D57300(ctx, base);
	// 8260F090: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8260F094: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260F098: C3FE000C  lfs f31, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8260F09C: 4874786D  bl 0x82d56908
	ctx.lr = 0x8260F0A0;
	sub_82D56908(ctx, base);
	// 8260F0A0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8260F0A4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8260F0A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8260F0AC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8260F0B0: 488437E1  bl 0x82e52890
	ctx.lr = 0x8260F0B4;
	sub_82E52890(ctx, base);
	// 8260F0B4: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8260F0B8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8260F0BC: 4869A3A0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260F0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8260F0C0 size=284
    let mut pc: u32 = 0x8260F0C0;
    'dispatch: loop {
        match pc {
            0x8260F0C0 => {
    //   block [0x8260F0C0..0x8260F0F8)
	// 8260F0C0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8260F0C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260F0C8: 392A8314  addi r9, r10, -0x7cec
	ctx.r[9].s64 = ctx.r[10].s64 + -31980;
	// 8260F0CC: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8260F0D0: 39430008  addi r10, r3, 8
	ctx.r[10].s64 = ctx.r[3].s64 + 8;
	// 8260F0D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8260F0D8: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260F0DC: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 8260F0E0: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260F0E4: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8260F0E8: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260F0EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260F0F0: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8260F0F4: 419A0020  beq cr6, 0x8260f114
	if ctx.cr[6].eq {
	pc = 0x8260F114; continue 'dispatch;
	}
	pc = 0x8260F0F8; continue 'dispatch;
            }
            0x8260F0F8 => {
    //   block [0x8260F0F8..0x8260F114)
	// 8260F0F8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8260F0FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8260F100: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8260F104: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8260F108: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8260F10C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8260F110: 4082FFE8  bne 0x8260f0f8
	if !ctx.cr[0].eq {
	pc = 0x8260F0F8; continue 'dispatch;
	}
	pc = 0x8260F114; continue 'dispatch;
            }
            0x8260F114 => {
    //   block [0x8260F114..0x8260F1DC)
	// 8260F114: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8260F118: 90E3001C  stw r7, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 8260F11C: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 8260F120: 90A30014  stw r5, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 8260F124: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 8260F128: 90C30018  stw r6, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 8260F12C: 38E00050  li r7, 0x50
	ctx.r[7].s64 = 80;
	// 8260F130: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 8260F134: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8260F138: F9630028  std r11, 0x28(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u64 ) };
	// 8260F13C: C00A9490  lfs f0, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8260F140: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 8260F144: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8260F148: 3C808000  lis r4, -0x8000
	ctx.r[4].s64 = -2147483648;
	// 8260F14C: 81486CA4  lwz r10, 0x6ca4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27812 as u32) ) } as u64;
	// 8260F150: 90C30020  stw r6, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[6].u32 ) };
	// 8260F154: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8260F158: 90A30030  stw r5, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[5].u32 ) };
	// 8260F15C: 99630034  stb r11, 0x34(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 8260F160: 91430038  stw r10, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 8260F164: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 8260F168: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 8260F16C: 90830044  stw r4, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[4].u32 ) };
	// 8260F170: 91486CA4  stw r10, 0x6ca4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27812 as u32), ctx.r[10].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260F1E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260F1E0 size=208
    let mut pc: u32 = 0x8260F1E0;
    'dispatch: loop {
        match pc {
            0x8260F1E0 => {
    //   block [0x8260F1E0..0x8260F244)
	// 8260F1E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260F1E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8260F1E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8260F1EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260F1F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260F1F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8260F1F8: 394B8314  addi r10, r11, -0x7cec
	ctx.r[10].s64 = ctx.r[11].s64 + -31980;
	// 8260F1FC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8260F200: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8260F204: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260F208: 419A003C  beq cr6, 0x8260f244
	if ctx.cr[6].eq {
	pc = 0x8260F244; continue 'dispatch;
	}
	// 8260F20C: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260F210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260F214: 419A0030  beq cr6, 0x8260f244
	if ctx.cr[6].eq {
	pc = 0x8260F244; continue 'dispatch;
	}
	// 8260F218: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 8260F21C: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 8260F220: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 8260F224: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 8260F228: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8260F22C: 409A0018  bne cr6, 0x8260f244
	if !ctx.cr[6].eq {
	pc = 0x8260F244; continue 'dispatch;
	}
	// 8260F230: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260F234: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8260F238: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260F23C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8260F240: 4E800421  bctrl
	ctx.lr = 0x8260F244;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8260F244 => {
    //   block [0x8260F244..0x8260F28C)
	// 8260F244: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8260F248: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 8260F24C: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 8260F250: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 8260F254: 4BB84BE5  bl 0x82193e38
	ctx.lr = 0x8260F258;
	sub_82193E38(ctx, base);
	// 8260F258: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8260F25C: 913F0068  stw r9, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 8260F260: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 8260F264: 55680000  rlwinm r8, r11, 0, 0, 0
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8260F268: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8260F26C: 409A0020  bne cr6, 0x8260f28c
	if !ctx.cr[6].eq {
	pc = 0x8260F28C; continue 'dispatch;
	}
	// 8260F270: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260F274: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 8260F278: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 8260F27C: 809F003C  lwz r4, 0x3c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 8260F280: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8260F284: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8260F288: 48746041  bl 0x82d552c8
	ctx.lr = 0x8260F28C;
	sub_82D552C8(ctx, base);
	pc = 0x8260F28C; continue 'dispatch;
            }
            0x8260F28C => {
    //   block [0x8260F28C..0x8260F2B0)
	// 8260F28C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8260F290: 4BBA8889  bl 0x821b7b18
	ctx.lr = 0x8260F294;
	sub_821B7B18(ctx, base);
	// 8260F294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260F298: 4BC8B5B9  bl 0x8229a850
	ctx.lr = 0x8260F29C;
	sub_8229A850(ctx, base);
	// 8260F29C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8260F2A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260F2A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8260F2A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8260F2AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260F2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260F2B0 size=80
    let mut pc: u32 = 0x8260F2B0;
    'dispatch: loop {
        match pc {
            0x8260F2B0 => {
    //   block [0x8260F2B0..0x8260F2E8)
	// 8260F2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260F2B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8260F2B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8260F2BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8260F2C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260F2C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260F2C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8260F2CC: 4BFFFF15  bl 0x8260f1e0
	ctx.lr = 0x8260F2D0;
	sub_8260F1E0(ctx, base);
	// 8260F2D0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8260F2D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260F2D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260F2DC: 419A000C  beq cr6, 0x8260f2e8
	if ctx.cr[6].eq {
	pc = 0x8260F2E8; continue 'dispatch;
	}
	// 8260F2E0: 4BC0CA59  bl 0x8221bd38
	ctx.lr = 0x8260F2E4;
	sub_8221BD38(ctx, base);
	// 8260F2E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8260F2E8; continue 'dispatch;
            }
            0x8260F2E8 => {
    //   block [0x8260F2E8..0x8260F300)
	// 8260F2E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8260F2EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260F2F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8260F2F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8260F2F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8260F2FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260F300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8260F300 size=1532
    let mut pc: u32 = 0x8260F300;
    'dispatch: loop {
        match pc {
            0x8260F300 => {
    //   block [0x8260F300..0x8260F348)
	// 8260F300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260F304: 4869A0DD  bl 0x82ca93e0
	ctx.lr = 0x8260F308;
	sub_82CA93D0(ctx, base);
	// 8260F308: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260F30C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8260F310: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8260F314: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 8260F318: 3BEB8BF4  addi r31, r11, -0x740c
	ctx.r[31].s64 = ctx.r[11].s64 + -29708;
	// 8260F31C: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 8260F320: E95D0060  ld r10, 0x60(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) };
	// 8260F324: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8260F328: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260F32C: F9410078  std r10, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u64 ) };
	// 8260F330: 48003361  bl 0x82612690
	ctx.lr = 0x8260F334;
	sub_82612690(ctx, base);
	// 8260F334: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 8260F338: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260F33C: 419A000C  beq cr6, 0x8260f348
	if ctx.cr[6].eq {
	pc = 0x8260F348; continue 'dispatch;
	}
	// 8260F340: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8260F344: 419A0008  beq cr6, 0x8260f34c
	if ctx.cr[6].eq {
	pc = 0x8260F34C; continue 'dispatch;
	}
	pc = 0x8260F348; continue 'dispatch;
            }
            0x8260F348 => {
    //   block [0x8260F348..0x8260F34C)
	// 8260F348: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260F34C; continue 'dispatch;
            }
            0x8260F34C => {
    //   block [0x8260F34C..0x8260F368)
	// 8260F34C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260F350: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8260F354: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8260F358: 419A0060  beq cr6, 0x8260f3b8
	if ctx.cr[6].eq {
	pc = 0x8260F3B8; continue 'dispatch;
	}
	// 8260F35C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260F360: 409A0008  bne cr6, 0x8260f368
	if !ctx.cr[6].eq {
	pc = 0x8260F368; continue 'dispatch;
	}
	// 8260F364: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260F368; continue 'dispatch;
            }
            0x8260F368 => {
    //   block [0x8260F368..0x8260F378)
	// 8260F368: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260F36C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260F370: 409A0008  bne cr6, 0x8260f378
	if !ctx.cr[6].eq {
	pc = 0x8260F378; continue 'dispatch;
	}
	// 8260F374: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260F378; continue 'dispatch;
            }
            0x8260F378 => {
    //   block [0x8260F378..0x8260F3B8)
	// 8260F378: 83EB0044  lwz r31, 0x44(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 8260F37C: 81520004  lwz r10, 4(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260F380: 83CB0040  lwz r30, 0x40(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8260F384: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8260F388: 419A0560  beq cr6, 0x8260f8e8
	if ctx.cr[6].eq {
	pc = 0x8260F8E8; continue 'dispatch;
	}
	// 8260F38C: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 8260F390: 4BBA8789  bl 0x821b7b18
	ctx.lr = 0x8260F394;
	sub_821B7B18(ctx, base);
	// 8260F394: 93D20000  stw r30, 0(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8260F398: 93F20004  stw r31, 4(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8260F39C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8260F3A0: 419A0548  beq cr6, 0x8260f8e8
	if ctx.cr[6].eq {
	pc = 0x8260F8E8; continue 'dispatch;
	}
	// 8260F3A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260F3A8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8260F3AC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8260F3B0: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 8260F3B4: 4869A07C  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            0x8260F3B8 => {
    //   block [0x8260F3B8..0x8260F8E8)
	// 8260F3B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260F3BC: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 8260F3C0: 48003059  bl 0x82612418
	ctx.lr = 0x8260F3C4;
	sub_82612418(ctx, base);
	// 8260F3C4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8260F3C8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8260F3CC: 48772665  bl 0x82d81a30
	ctx.lr = 0x8260F3D0;
	sub_82D81A30(ctx, base);
	// 8260F3D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8260F3D4: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 8260F3D8: 392BE0E0  addi r9, r11, -0x1f20
	ctx.r[9].s64 = ctx.r[11].s64 + -7968;
	// 8260F3DC: 390A1190  addi r8, r10, 0x1190
	ctx.r[8].s64 = ctx.r[10].s64 + 4496;
	// 8260F3E0: 38E100E0  addi r7, r1, 0xe0
	ctx.r[7].s64 = ctx.r[1].s64 + 224;
	// 8260F3E4: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 8260F3E8: C02BE0E0  lfs f1, -0x1f20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7968 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8260F3EC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8260F3F0: C009D570  lfs f0, -0x2a90(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10896 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8260F3F4: 98C10181  stb r6, 0x181(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(385 as u32), ctx.r[6].u8 ) };
	pc = 0x8260F8E8; continue 'dispatch;
            }
            0x8260F8E8 => {
    //   block [0x8260F8E8..0x8260F8FC)
	// 8260F8E8: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 8260F8EC: 48699B44  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
	// 8260F8F0: E9610078  ld r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 8260F8F4: F9640000  std r11, 0(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8260F8F8: 4BFFFF8C  b 0x8260f884
	pc = 0x8260F884; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260F900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260F900 size=700
    let mut pc: u32 = 0x8260F900;
    'dispatch: loop {
        match pc {
            0x8260F900 => {
    //   block [0x8260F900..0x8260F954)
	// 8260F900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260F904: 48699AFD  bl 0x82ca9400
	ctx.lr = 0x8260F908;
	sub_82CA93D0(ctx, base);
	// 8260F908: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260F90C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260F910: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8260F914: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8260F918: 3B4B8BF4  addi r26, r11, -0x740c
	ctx.r[26].s64 = ctx.r[11].s64 + -29708;
	// 8260F91C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8260F920: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260F924: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8260F928: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8260F92C: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 8260F930: 48002D61  bl 0x82612690
	ctx.lr = 0x8260F934;
	sub_82612690(ctx, base);
	// 8260F934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260F938: 4BBA81E1  bl 0x821b7b18
	ctx.lr = 0x8260F93C;
	sub_821B7B18(ctx, base);
	// 8260F93C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8260F940: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8260F944: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260F948: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 8260F94C: 409A0008  bne cr6, 0x8260f954
	if !ctx.cr[6].eq {
	pc = 0x8260F954; continue 'dispatch;
	}
	// 8260F950: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260F954; continue 'dispatch;
            }
            0x8260F954 => {
    //   block [0x8260F954..0x8260F968)
	// 8260F954: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260F958: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8260F95C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260F960: 409A0008  bne cr6, 0x8260f968
	if !ctx.cr[6].eq {
	pc = 0x8260F968; continue 'dispatch;
	}
	// 8260F964: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260F968; continue 'dispatch;
            }
            0x8260F968 => {
    //   block [0x8260F968..0x8260F9A0)
	// 8260F968: 3BEB0018  addi r31, r11, 0x18
	ctx.r[31].s64 = ctx.r[11].s64 + 24;
	// 8260F96C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 8260F970: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260F974: 419A0240  beq cr6, 0x8260fbb4
	if ctx.cr[6].eq {
	pc = 0x8260FBB4; continue 'dispatch;
	}
	// 8260F978: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260F97C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8260F980: 409A0234  bne cr6, 0x8260fbb4
	if !ctx.cr[6].eq {
	pc = 0x8260FBB4; continue 'dispatch;
	}
	// 8260F984: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8260F988: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 8260F98C: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8260F990: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8260F994: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8260F998: 419A0064  beq cr6, 0x8260f9fc
	if ctx.cr[6].eq {
	pc = 0x8260F9FC; continue 'dispatch;
	}
	// 8260F99C: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	pc = 0x8260F9A0; continue 'dispatch;
            }
            0x8260F9A0 => {
    //   block [0x8260F9A0..0x8260F9BC)
	// 8260F9A0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8260F9A4: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8260F9A8: 7D4AE82E  lwzx r10, r10, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 8260F9AC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8260F9B0: 4098000C  bge cr6, 0x8260f9bc
	if !ctx.cr[6].lt {
	pc = 0x8260F9BC; continue 'dispatch;
	}
	// 8260F9B4: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 8260F9B8: 48000010  b 0x8260f9c8
	pc = 0x8260F9C8; continue 'dispatch;
            }
            0x8260F9BC => {
    //   block [0x8260F9BC..0x8260F9C8)
	// 8260F9BC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260F9C0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8260F9C4: 7FCA582E  lwzx r30, r10, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x8260F9C8; continue 'dispatch;
            }
            0x8260F9C8 => {
    //   block [0x8260F9C8..0x8260F9FC)
	// 8260F9C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8260F9CC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260F9D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260F9D4: 48768495  bl 0x82d77e68
	ctx.lr = 0x8260F9D8;
	sub_82D77E68(ctx, base);
	// 8260F9D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8260F9DC: 48770A05  bl 0x82d803e0
	ctx.lr = 0x8260F9E0;
	sub_82D803E0(ctx, base);
	// 8260F9E0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8260F9E4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 8260F9E8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8260F9EC: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8260F9F0: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8260F9F4: 7F1C4840  cmplw cr6, r28, r9
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8260F9F8: 409AFFA8  bne cr6, 0x8260f9a0
	if !ctx.cr[6].eq {
	pc = 0x8260F9A0; continue 'dispatch;
	}
	pc = 0x8260F9FC; continue 'dispatch;
            }
            0x8260F9FC => {
    //   block [0x8260F9FC..0x8260FA40)
	// 8260F9FC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8260FA00: 936B000C  stw r27, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 8260FA04: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8260FA08: A1430004  lhz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FA0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260FA10: 419A0030  beq cr6, 0x8260fa40
	if ctx.cr[6].eq {
	pc = 0x8260FA40; continue 'dispatch;
	}
	// 8260FA14: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 8260FA18: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 8260FA1C: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 8260FA20: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 8260FA24: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8260FA28: 409A0018  bne cr6, 0x8260fa40
	if !ctx.cr[6].eq {
	pc = 0x8260FA40; continue 'dispatch;
	}
	// 8260FA2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FA30: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8260FA34: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FA38: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8260FA3C: 4E800421  bctrl
	ctx.lr = 0x8260FA40;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8260FA40 => {
    //   block [0x8260FA40..0x8260FA90)
	// 8260FA40: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8260FA44: 937F0010  stw r27, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[27].u32 ) };
	// 8260FA48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260FA4C: 419A0048  beq cr6, 0x8260fa94
	if ctx.cr[6].eq {
	pc = 0x8260FA94; continue 'dispatch;
	}
	// 8260FA50: 48827001  bl 0x82e36a50
	ctx.lr = 0x8260FA54;
	sub_82E36A50(ctx, base);
	// 8260FA54: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8260FA58: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FA5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260FA60: 419A0030  beq cr6, 0x8260fa90
	if ctx.cr[6].eq {
	pc = 0x8260FA90; continue 'dispatch;
	}
	// 8260FA64: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 8260FA68: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 8260FA6C: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 8260FA70: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 8260FA74: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8260FA78: 409A0018  bne cr6, 0x8260fa90
	if !ctx.cr[6].eq {
	pc = 0x8260FA90; continue 'dispatch;
	}
	// 8260FA7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FA80: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8260FA84: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FA88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8260FA8C: 4E800421  bctrl
	ctx.lr = 0x8260FA90;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8260FA90 => {
    //   block [0x8260FA90..0x8260FA94)
	// 8260FA90: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	pc = 0x8260FA94; continue 'dispatch;
            }
            0x8260FA94 => {
    //   block [0x8260FA94..0x8260FAE4)
	// 8260FA94: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260FA98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260FA9C: 419A004C  beq cr6, 0x8260fae8
	if ctx.cr[6].eq {
	pc = 0x8260FAE8; continue 'dispatch;
	}
	// 8260FAA0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FAA4: 4884216D  bl 0x82e51c10
	ctx.lr = 0x8260FAA8;
	sub_82E51C10(ctx, base);
	// 8260FAA8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260FAAC: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FAB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260FAB4: 419A0030  beq cr6, 0x8260fae4
	if ctx.cr[6].eq {
	pc = 0x8260FAE4; continue 'dispatch;
	}
	// 8260FAB8: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 8260FABC: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 8260FAC0: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 8260FAC4: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 8260FAC8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8260FACC: 409A0018  bne cr6, 0x8260fae4
	if !ctx.cr[6].eq {
	pc = 0x8260FAE4; continue 'dispatch;
	}
	// 8260FAD0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FAD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8260FAD8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FADC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8260FAE0: 4E800421  bctrl
	ctx.lr = 0x8260FAE4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8260FAE4 => {
    //   block [0x8260FAE4..0x8260FAE8)
	// 8260FAE4: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x8260FAE8; continue 'dispatch;
            }
            0x8260FAE8 => {
    //   block [0x8260FAE8..0x8260FB20)
	// 8260FAE8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FAEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260FAF0: 419A0070  beq cr6, 0x8260fb60
	if ctx.cr[6].eq {
	pc = 0x8260FB60; continue 'dispatch;
	}
	// 8260FAF4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FAF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260FAFC: 419A0024  beq cr6, 0x8260fb20
	if ctx.cr[6].eq {
	pc = 0x8260FB20; continue 'dispatch;
	}
	// 8260FB00: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8260FB04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8260FB08: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8260FB0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8260FB10: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 8260FB14: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8260FB18: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FB1C: 4876F72D  bl 0x82d7f248
	ctx.lr = 0x8260FB20;
	sub_82D7F248(ctx, base);
	pc = 0x8260FB20; continue 'dispatch;
            }
            0x8260FB20 => {
    //   block [0x8260FB20..0x8260FB5C)
	// 8260FB20: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FB24: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FB28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260FB2C: 419A0030  beq cr6, 0x8260fb5c
	if ctx.cr[6].eq {
	pc = 0x8260FB5C; continue 'dispatch;
	}
	// 8260FB30: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 8260FB34: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 8260FB38: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 8260FB3C: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 8260FB40: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8260FB44: 409A0018  bne cr6, 0x8260fb5c
	if !ctx.cr[6].eq {
	pc = 0x8260FB5C; continue 'dispatch;
	}
	// 8260FB48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FB4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8260FB50: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FB54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8260FB58: 4E800421  bctrl
	ctx.lr = 0x8260FB5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8260FB5C => {
    //   block [0x8260FB5C..0x8260FB60)
	// 8260FB5C: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	pc = 0x8260FB60; continue 'dispatch;
            }
            0x8260FB60 => {
    //   block [0x8260FB60..0x8260FBA4)
	// 8260FB60: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FB64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260FB68: 419A0040  beq cr6, 0x8260fba8
	if ctx.cr[6].eq {
	pc = 0x8260FBA8; continue 'dispatch;
	}
	// 8260FB6C: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FB70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260FB74: 419A0030  beq cr6, 0x8260fba4
	if ctx.cr[6].eq {
	pc = 0x8260FBA4; continue 'dispatch;
	}
	// 8260FB78: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 8260FB7C: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 8260FB80: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 8260FB84: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 8260FB88: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8260FB8C: 409A0018  bne cr6, 0x8260fba4
	if !ctx.cr[6].eq {
	pc = 0x8260FBA4; continue 'dispatch;
	}
	// 8260FB90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FB94: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8260FB98: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FB9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8260FBA0: 4E800421  bctrl
	ctx.lr = 0x8260FBA4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8260FBA4 => {
    //   block [0x8260FBA4..0x8260FBA8)
	// 8260FBA4: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x8260FBA8; continue 'dispatch;
            }
            0x8260FBA8 => {
    //   block [0x8260FBA8..0x8260FBB4)
	// 8260FBA8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8260FBAC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8260FBB0: 480029F9  bl 0x826125a8
	ctx.lr = 0x8260FBB4;
	sub_826125A8(ctx, base);
	pc = 0x8260FBB4; continue 'dispatch;
            }
            0x8260FBB4 => {
    //   block [0x8260FBB4..0x8260FBBC)
	// 8260FBB4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8260FBB8: 48699898  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260FBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260FBC0 size=312
    let mut pc: u32 = 0x8260FBC0;
    'dispatch: loop {
        match pc {
            0x8260FBC0 => {
    //   block [0x8260FBC0..0x8260FBF8)
	// 8260FBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260FBC4: 48699841  bl 0x82ca9404
	ctx.lr = 0x8260FBC8;
	sub_82CA93D0(ctx, base);
	// 8260FBC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260FBCC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8260FBD0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8260FBD4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8260FBD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260FBDC: 388B8BF4  addi r4, r11, -0x740c
	ctx.r[4].s64 = ctx.r[11].s64 + -29708;
	// 8260FBE0: 80BB0000  lwz r5, 0(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FBE4: 48002AAD  bl 0x82612690
	ctx.lr = 0x8260FBE8;
	sub_82612690(ctx, base);
	// 8260FBE8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8260FBEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260FBF0: 409A0008  bne cr6, 0x8260fbf8
	if !ctx.cr[6].eq {
	pc = 0x8260FBF8; continue 'dispatch;
	}
	// 8260FBF4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FBF8; continue 'dispatch;
            }
            0x8260FBF8 => {
    //   block [0x8260FBF8..0x8260FC0C)
	// 8260FBF8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FBFC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8260FC00: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260FC04: 409A0008  bne cr6, 0x8260fc0c
	if !ctx.cr[6].eq {
	pc = 0x8260FC0C; continue 'dispatch;
	}
	// 8260FC08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FC0C; continue 'dispatch;
            }
            0x8260FC0C => {
    //   block [0x8260FC0C..0x8260FC64)
	// 8260FC0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8260FC10: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8260FC14: 390A0B7C  addi r8, r10, 0xb7c
	ctx.r[8].s64 = ctx.r[10].s64 + 2940;
	// 8260FC18: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 8260FC1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8260FC20: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 8260FC24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260FC28: 3B8B0018  addi r28, r11, 0x18
	ctx.r[28].s64 = ctx.r[11].s64 + 24;
	// 8260FC2C: 4BC04C6D  bl 0x82214898
	ctx.lr = 0x8260FC30;
	sub_82214898(ctx, base);
	// 8260FC30: 3BFE0038  addi r31, r30, 0x38
	ctx.r[31].s64 = ctx.r[30].s64 + 56;
	// 8260FC34: 387C001C  addi r3, r28, 0x1c
	ctx.r[3].s64 = ctx.r[28].s64 + 28;
	// 8260FC38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260FC3C: 480025AD  bl 0x826121e8
	ctx.lr = 0x8260FC40;
	sub_826121E8(ctx, base);
	// 8260FC40: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8260FC44: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8260FC48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260FC4C: 419A0020  beq cr6, 0x8260fc6c
	if ctx.cr[6].eq {
	pc = 0x8260FC6C; continue 'dispatch;
	}
	// 8260FC50: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FC54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260FC58: 419A000C  beq cr6, 0x8260fc64
	if ctx.cr[6].eq {
	pc = 0x8260FC64; continue 'dispatch;
	}
	// 8260FC5C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8260FC60: 48000010  b 0x8260fc70
	pc = 0x8260FC70; continue 'dispatch;
            }
            0x8260FC64 => {
    //   block [0x8260FC64..0x8260FC6C)
	// 8260FC64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260FC68: 4BB841D1  bl 0x82193e38
	ctx.lr = 0x8260FC6C;
	sub_82193E38(ctx, base);
	pc = 0x8260FC6C; continue 'dispatch;
            }
            0x8260FC6C => {
    //   block [0x8260FC6C..0x8260FC70)
	// 8260FC6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8260FC70; continue 'dispatch;
            }
            0x8260FC70 => {
    //   block [0x8260FC70..0x8260FCB8)
	// 8260FC70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8260FC74: 4BC04C25  bl 0x82214898
	ctx.lr = 0x8260FC78;
	sub_82214898(ctx, base);
	// 8260FC78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8260FC7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260FC80: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 8260FC84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8260FC88: 4BB841B1  bl 0x82193e38
	ctx.lr = 0x8260FC8C;
	sub_82193E38(ctx, base);
	// 8260FC8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8260FC90: 389B0008  addi r4, r27, 8
	ctx.r[4].s64 = ctx.r[27].s64 + 8;
	// 8260FC94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260FC98: 48078501  bl 0x82688198
	ctx.lr = 0x8260FC9C;
	sub_82688198(ctx, base);
	// 8260FC9C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8260FCA0: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8260FCA4: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FCA8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8260FCAC: 4098000C  bge cr6, 0x8260fcb8
	if !ctx.cr[6].lt {
	pc = 0x8260FCB8; continue 'dispatch;
	}
	// 8260FCB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260FCB4: 48000010  b 0x8260fcc4
	pc = 0x8260FCC4; continue 'dispatch;
            }
            0x8260FCB8 => {
    //   block [0x8260FCB8..0x8260FCC4)
	// 8260FCB8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260FCBC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8260FCC0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x8260FCC4; continue 'dispatch;
            }
            0x8260FCC4 => {
    //   block [0x8260FCC4..0x8260FCF8)
	// 8260FCC4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8260FCC8: 808B0070  lwz r4, 0x70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8260FCCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260FCD0: 4BC1D201  bl 0x8222ced0
	ctx.lr = 0x8260FCD4;
	sub_8222CED0(ctx, base);
	// 8260FCD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8260FCD8: 807C0010  lwz r3, 0x10(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 8260FCDC: 4BFFF29D  bl 0x8260ef78
	ctx.lr = 0x8260FCE0;
	sub_8260EF78(ctx, base);
	// 8260FCE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260FCE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260FCE8: 4BC050F1  bl 0x82214dd8
	ctx.lr = 0x8260FCEC;
	sub_82214DD8(ctx, base);
	// 8260FCEC: 93FE0020  stw r31, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 8260FCF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8260FCF4: 48699760  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260FCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260FCF8 size=408
    let mut pc: u32 = 0x8260FCF8;
    'dispatch: loop {
        match pc {
            0x8260FCF8 => {
    //   block [0x8260FCF8..0x8260FD30)
	// 8260FCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260FCFC: 4869970D  bl 0x82ca9408
	ctx.lr = 0x8260FD00;
	sub_82CA93D0(ctx, base);
	// 8260FD00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260FD04: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8260FD08: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8260FD0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8260FD10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260FD14: 388B8BF4  addi r4, r11, -0x740c
	ctx.r[4].s64 = ctx.r[11].s64 + -29708;
	// 8260FD18: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FD1C: 48002975  bl 0x82612690
	ctx.lr = 0x8260FD20;
	sub_82612690(ctx, base);
	// 8260FD20: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8260FD24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260FD28: 409A0008  bne cr6, 0x8260fd30
	if !ctx.cr[6].eq {
	pc = 0x8260FD30; continue 'dispatch;
	}
	// 8260FD2C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FD30; continue 'dispatch;
            }
            0x8260FD30 => {
    //   block [0x8260FD30..0x8260FD44)
	// 8260FD30: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FD34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8260FD38: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260FD3C: 409A0008  bne cr6, 0x8260fd44
	if !ctx.cr[6].eq {
	pc = 0x8260FD44; continue 'dispatch;
	}
	// 8260FD40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FD44; continue 'dispatch;
            }
            0x8260FD44 => {
    //   block [0x8260FD44..0x8260FD60)
	// 8260FD44: 810B0050  lwz r8, 0x50(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 8260FD48: 3BAB0018  addi r29, r11, 0x18
	ctx.r[29].s64 = ctx.r[11].s64 + 24;
	// 8260FD4C: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8260FD50: 3BFD0030  addi r31, r29, 0x30
	ctx.r[31].s64 = ctx.r[29].s64 + 48;
	// 8260FD54: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8260FD58: 40990008  ble cr6, 0x8260fd60
	if !ctx.cr[6].gt {
	pc = 0x8260FD60; continue 'dispatch;
	}
	// 8260FD5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FD60; continue 'dispatch;
            }
            0x8260FD60 => {
    //   block [0x8260FD60..0x8260FD74)
	// 8260FD60: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260FD64: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FD68: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260FD6C: 40990008  ble cr6, 0x8260fd74
	if !ctx.cr[6].gt {
	pc = 0x8260FD74; continue 'dispatch;
	}
	// 8260FD70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FD74; continue 'dispatch;
            }
            0x8260FD74 => {
    //   block [0x8260FD74..0x8260FD88)
	// 8260FD74: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FD78: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260FD7C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8260FD80: 40990008  ble cr6, 0x8260fd88
	if !ctx.cr[6].gt {
	pc = 0x8260FD88; continue 'dispatch;
	}
	// 8260FD84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FD88; continue 'dispatch;
            }
            0x8260FD88 => {
    //   block [0x8260FD88..0x8260FDA4)
	// 8260FD88: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8260FD8C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260FD90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8260FD94: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8260FD98: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 8260FD9C: 419A0020  beq cr6, 0x8260fdbc
	if ctx.cr[6].eq {
	pc = 0x8260FDBC; continue 'dispatch;
	}
	// 8260FDA0: 813E0038  lwz r9, 0x38(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	pc = 0x8260FDA4; continue 'dispatch;
            }
            0x8260FDA4 => {
    //   block [0x8260FDA4..0x8260FDBC)
	// 8260FDA4: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FDA8: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8260FDAC: 419A0010  beq cr6, 0x8260fdbc
	if ctx.cr[6].eq {
	pc = 0x8260FDBC; continue 'dispatch;
	}
	// 8260FDB0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8260FDB4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260FDB8: 409AFFEC  bne cr6, 0x8260fda4
	if !ctx.cr[6].eq {
	pc = 0x8260FDA4; continue 'dispatch;
	}
	pc = 0x8260FDBC; continue 'dispatch;
            }
            0x8260FDBC => {
    //   block [0x8260FDBC..0x8260FDD0)
	// 8260FDBC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8260FDC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260FDC4: 419A000C  beq cr6, 0x8260fdd0
	if ctx.cr[6].eq {
	pc = 0x8260FDD0; continue 'dispatch;
	}
	// 8260FDC8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8260FDCC: 419A0008  beq cr6, 0x8260fdd4
	if ctx.cr[6].eq {
	pc = 0x8260FDD4; continue 'dispatch;
	}
	pc = 0x8260FDD0; continue 'dispatch;
            }
            0x8260FDD0 => {
    //   block [0x8260FDD0..0x8260FDD4)
	// 8260FDD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FDD4; continue 'dispatch;
            }
            0x8260FDD4 => {
    //   block [0x8260FDD4..0x8260FDFC)
	// 8260FDD4: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8260FDD8: 419A0094  beq cr6, 0x8260fe6c
	if ctx.cr[6].eq {
	pc = 0x8260FE6C; continue 'dispatch;
	}
	// 8260FDDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8260FDE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8260FDE4: 48000E3D  bl 0x82610c20
	ctx.lr = 0x8260FDE8;
	sub_82610C20(ctx, base);
	// 8260FDE8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260FDEC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FDF0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260FDF4: 40990008  ble cr6, 0x8260fdfc
	if !ctx.cr[6].gt {
	pc = 0x8260FDFC; continue 'dispatch;
	}
	// 8260FDF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FDFC; continue 'dispatch;
            }
            0x8260FDFC => {
    //   block [0x8260FDFC..0x8260FE18)
	// 8260FDFC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FE00: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260FE04: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8260FE08: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8260FE0C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8260FE10: 40990008  ble cr6, 0x8260fe18
	if !ctx.cr[6].gt {
	pc = 0x8260FE18; continue 'dispatch;
	}
	// 8260FE14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FE18; continue 'dispatch;
            }
            0x8260FE18 => {
    //   block [0x8260FE18..0x8260FE60)
	// 8260FE18: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8260FE1C: 38DE0038  addi r6, r30, 0x38
	ctx.r[6].s64 = ctx.r[30].s64 + 56;
	// 8260FE20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8260FE24: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8260FE28: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8260FE2C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8260FE30: 48004771  bl 0x826145a0
	ctx.lr = 0x8260FE34;
	sub_826145A0(ctx, base);
	// 8260FE34: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8260FE38: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260FE3C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8260FE40: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8260FE44: 38A30004  addi r5, r3, 4
	ctx.r[5].s64 = ctx.r[3].s64 + 4;
	// 8260FE48: 7D255050  subf r9, r5, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 8260FE4C: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8260FE50: 40810010  ble 0x8260fe60
	if !ctx.cr[0].gt {
	pc = 0x8260FE60; continue 'dispatch;
	}
	// 8260FE54: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8260FE58: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 8260FE5C: 4869A1CD  bl 0x82caa028
	ctx.lr = 0x8260FE60;
	sub_82CAA028(ctx, base);
	pc = 0x8260FE60; continue 'dispatch;
            }
            0x8260FE60 => {
    //   block [0x8260FE60..0x8260FE6C)
	// 8260FE60: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8260FE64: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 8260FE68: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x8260FE6C; continue 'dispatch;
            }
            0x8260FE6C => {
    //   block [0x8260FE6C..0x8260FE90)
	// 8260FE6C: 3BFE0038  addi r31, r30, 0x38
	ctx.r[31].s64 = ctx.r[30].s64 + 56;
	// 8260FE70: 387D001C  addi r3, r29, 0x1c
	ctx.r[3].s64 = ctx.r[29].s64 + 28;
	// 8260FE74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260FE78: 48002499  bl 0x82612310
	ctx.lr = 0x8260FE7C;
	sub_82612310(ctx, base);
	// 8260FE7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260FE80: 387C0008  addi r3, r28, 8
	ctx.r[3].s64 = ctx.r[28].s64 + 8;
	// 8260FE84: 4BE45DBD  bl 0x82455c40
	ctx.lr = 0x8260FE88;
	sub_82455C40(ctx, base);
	// 8260FE88: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8260FE8C: 486995CC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260FE90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8260FE90 size=768
    let mut pc: u32 = 0x8260FE90;
    'dispatch: loop {
        match pc {
            0x8260FE90 => {
    //   block [0x8260FE90..0x8260FEC4)
	// 8260FE90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260FE94: 48699555  bl 0x82ca93e8
	ctx.lr = 0x8260FE98;
	sub_82CA93D0(ctx, base);
	// 8260FE98: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260FE9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260FEA0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8260FEA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260FEA8: 388B8BF4  addi r4, r11, -0x740c
	ctx.r[4].s64 = ctx.r[11].s64 + -29708;
	// 8260FEAC: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FEB0: 480027E1  bl 0x82612690
	ctx.lr = 0x8260FEB4;
	sub_82612690(ctx, base);
	// 8260FEB4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8260FEB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260FEBC: 409A0008  bne cr6, 0x8260fec4
	if !ctx.cr[6].eq {
	pc = 0x8260FEC4; continue 'dispatch;
	}
	// 8260FEC0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FEC4; continue 'dispatch;
            }
            0x8260FEC4 => {
    //   block [0x8260FEC4..0x8260FED8)
	// 8260FEC4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FEC8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8260FECC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260FED0: 409A0008  bne cr6, 0x8260fed8
	if !ctx.cr[6].eq {
	pc = 0x8260FED8; continue 'dispatch;
	}
	// 8260FED4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FED8; continue 'dispatch;
            }
            0x8260FED8 => {
    //   block [0x8260FED8..0x8260FF00)
	// 8260FED8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8260FEDC: 3A9F0008  addi r20, r31, 8
	ctx.r[20].s64 = ctx.r[31].s64 + 8;
	// 8260FEE0: 3AAB0018  addi r21, r11, 0x18
	ctx.r[21].s64 = ctx.r[11].s64 + 24;
	// 8260FEE4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8260FEE8: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 8260FEEC: 3ACB4C30  addi r22, r11, 0x4c30
	ctx.r[22].s64 = ctx.r[11].s64 + 19504;
	// 8260FEF0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FEF4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 8260FEF8: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8260FEFC: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	pc = 0x8260FF00; continue 'dispatch;
            }
            0x8260FF00 => {
    //   block [0x8260FF00..0x8260FF18)
	// 8260FF00: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8260FF04: 81340004  lwz r9, 4(r20)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FF08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260FF0C: 419A000C  beq cr6, 0x8260ff18
	if ctx.cr[6].eq {
	pc = 0x8260FF18; continue 'dispatch;
	}
	// 8260FF10: 7F0AA040  cmplw cr6, r10, r20
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[20].u32, &mut ctx.xer);
	// 8260FF14: 419A0008  beq cr6, 0x8260ff1c
	if ctx.cr[6].eq {
	pc = 0x8260FF1C; continue 'dispatch;
	}
	pc = 0x8260FF18; continue 'dispatch;
            }
            0x8260FF18 => {
    //   block [0x8260FF18..0x8260FF1C)
	// 8260FF18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FF1C; continue 'dispatch;
            }
            0x8260FF1C => {
    //   block [0x8260FF1C..0x8260FF34)
	// 8260FF1C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8260FF20: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8260FF24: 419A0264  beq cr6, 0x82610188
	if ctx.cr[6].eq {
	pc = 0x82610188; continue 'dispatch;
	}
	// 8260FF28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260FF2C: 409A0008  bne cr6, 0x8260ff34
	if !ctx.cr[6].eq {
	pc = 0x8260FF34; continue 'dispatch;
	}
	// 8260FF30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FF34; continue 'dispatch;
            }
            0x8260FF34 => {
    //   block [0x8260FF34..0x8260FF44)
	// 8260FF34: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FF38: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8260FF3C: 409A0008  bne cr6, 0x8260ff44
	if !ctx.cr[6].eq {
	pc = 0x8260FF44; continue 'dispatch;
	}
	// 8260FF40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FF44; continue 'dispatch;
            }
            0x8260FF44 => {
    //   block [0x8260FF44..0x8260FF78)
	// 8260FF44: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8260FF48: 3BF5001C  addi r31, r21, 0x1c
	ctx.r[31].s64 = ctx.r[21].s64 + 28;
	// 8260FF4C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8260FF50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260FF54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8260FF58: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8260FF5C: 4BF6ECAD  bl 0x8257ec08
	ctx.lr = 0x8260FF60;
	sub_8257EC08(ctx, base);
	// 8260FF60: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8260FF64: 81350020  lwz r9, 0x20(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(32 as u32) ) } as u64;
	// 8260FF68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260FF6C: 419A000C  beq cr6, 0x8260ff78
	if ctx.cr[6].eq {
	pc = 0x8260FF78; continue 'dispatch;
	}
	// 8260FF70: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8260FF74: 419A0008  beq cr6, 0x8260ff7c
	if ctx.cr[6].eq {
	pc = 0x8260FF7C; continue 'dispatch;
	}
	pc = 0x8260FF78; continue 'dispatch;
            }
            0x8260FF78 => {
    //   block [0x8260FF78..0x8260FF7C)
	// 8260FF78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FF7C; continue 'dispatch;
            }
            0x8260FF7C => {
    //   block [0x8260FF7C..0x8260FF94)
	// 8260FF7C: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8260FF80: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8260FF84: 419A01F8  beq cr6, 0x8261017c
	if ctx.cr[6].eq {
	pc = 0x8261017C; continue 'dispatch;
	}
	// 8260FF88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260FF8C: 409A0008  bne cr6, 0x8260ff94
	if !ctx.cr[6].eq {
	pc = 0x8260FF94; continue 'dispatch;
	}
	// 8260FF90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FF94; continue 'dispatch;
            }
            0x8260FF94 => {
    //   block [0x8260FF94..0x8260FFA4)
	// 8260FF94: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FF98: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8260FF9C: 409A0008  bne cr6, 0x8260ffa4
	if !ctx.cr[6].eq {
	pc = 0x8260FFA4; continue 'dispatch;
	}
	// 8260FFA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FFA4; continue 'dispatch;
            }
            0x8260FFA4 => {
    //   block [0x8260FFA4..0x8260FFD8)
	// 8260FFA4: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 8260FFA8: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 8260FFAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260FFB0: 419A01CC  beq cr6, 0x8261017c
	if ctx.cr[6].eq {
	pc = 0x8261017C; continue 'dispatch;
	}
	// 8260FFB4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FFB8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8260FFBC: 419A003C  beq cr6, 0x8260fff8
	if ctx.cr[6].eq {
	pc = 0x8260FFF8; continue 'dispatch;
	}
	// 8260FFC0: 550B003E  slwi r11, r8, 0
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8260FFC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260FFC8: 419A01B4  beq cr6, 0x8261017c
	if ctx.cr[6].eq {
	pc = 0x8261017C; continue 'dispatch;
	}
	// 8260FFCC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8260FFD0: 409A0008  bne cr6, 0x8260ffd8
	if !ctx.cr[6].eq {
	pc = 0x8260FFD8; continue 'dispatch;
	}
	// 8260FFD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8260FFD8; continue 'dispatch;
            }
            0x8260FFD8 => {
    //   block [0x8260FFD8..0x8260FFF8)
	// 8260FFD8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260FFDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260FFE0: 419A002C  beq cr6, 0x8261000c
	if ctx.cr[6].eq {
	pc = 0x8261000C; continue 'dispatch;
	}
	// 8260FFE4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260FFE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260FFEC: 419A001C  beq cr6, 0x82610008
	if ctx.cr[6].eq {
	pc = 0x82610008; continue 'dispatch;
	}
	// 8260FFF0: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8260FFF4: 4800001C  b 0x82610010
	pc = 0x82610010; continue 'dispatch;
            }
            0x8260FFF8 => {
    //   block [0x8260FFF8..0x82610008)
	// 8260FFF8: 4BB83E41  bl 0x82193e38
	ctx.lr = 0x8260FFFC;
	sub_82193E38(ctx, base);
	// 8260FFFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82610000: 4BCF0129  bl 0x82300128
	ctx.lr = 0x82610004;
	sub_82300128(ctx, base);
	// 82610004: 4BFFFEFC  b 0x8260ff00
	pc = 0x8260FF00; continue 'dispatch;
            }
            0x82610008 => {
    //   block [0x82610008..0x8261000C)
	// 82610008: 4BB83E31  bl 0x82193e38
	ctx.lr = 0x8261000C;
	sub_82193E38(ctx, base);
	pc = 0x8261000C; continue 'dispatch;
            }
            0x8261000C => {
    //   block [0x8261000C..0x82610010)
	// 8261000C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82610010; continue 'dispatch;
            }
            0x82610010 => {
    //   block [0x82610010..0x8261003C)
	// 82610010: 81490020  lwz r10, 0x20(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82610014: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82610018: 419A0164  beq cr6, 0x8261017c
	if ctx.cr[6].eq {
	pc = 0x8261017C; continue 'dispatch;
	}
	// 8261001C: 81750010  lwz r11, 0x10(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(16 as u32) ) } as u64;
	// 82610020: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82610024: 810B0020  lwz r8, 0x20(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82610028: 7D4A402E  lwzx r10, r10, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8261002C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82610030: 4098000C  bge cr6, 0x8261003c
	if !ctx.cr[6].lt {
	pc = 0x8261003C; continue 'dispatch;
	}
	// 82610034: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82610038: 48000010  b 0x82610048
	pc = 0x82610048; continue 'dispatch;
            }
            0x8261003C => {
    //   block [0x8261003C..0x82610048)
	// 8261003C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82610040: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82610044: 7EEA582E  lwzx r23, r10, r11
	ctx.r[23].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x82610048; continue 'dispatch;
            }
            0x82610048 => {
    //   block [0x82610048..0x82610094)
	// 82610048: 83890014  lwz r28, 0x14(r9)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 8261004C: 831C002C  lwz r24, 0x2c(r28)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 82610050: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82610054: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82610058: 40990124  ble cr6, 0x8261017c
	if !ctx.cr[6].gt {
	pc = 0x8261017C; continue 'dispatch;
	}
	// 8261005C: 570A003E  slwi r10, r24, 0
	ctx.r[10].u32 = ctx.r[24].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82610060: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82610064: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82610068: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8261006C: 419A0110  beq cr6, 0x8261017c
	if ctx.cr[6].eq {
	pc = 0x8261017C; continue 'dispatch;
	}
	// 82610070: 3BA00030  li r29, 0x30
	ctx.r[29].s64 = 48;
	// 82610074: 3B400002  li r26, 2
	ctx.r[26].s64 = 2;
	// 82610078: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 8261007C: 813C0020  lwz r9, 0x20(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82610080: 7D7B482E  lwzx r11, r27, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82610084: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82610088: 4098000C  bge cr6, 0x82610094
	if !ctx.cr[6].lt {
	pc = 0x82610094; continue 'dispatch;
	}
	// 8261008C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82610090: 48000010  b 0x826100a0
	pc = 0x826100A0; continue 'dispatch;
            }
            0x82610094 => {
    //   block [0x82610094..0x826100A0)
	// 82610094: 811C0008  lwz r8, 8(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82610098: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8261009C: 7FE7402E  lwzx r31, r7, r8
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	pc = 0x826100A0; continue 'dispatch;
            }
            0x826100A0 => {
    //   block [0x826100A0..0x826100C4)
	// 826100A0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 826100A4: 7D4BD22E  lhzx r10, r11, r26
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 826100A8: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 826100AC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 826100B0: 419A00AC  beq cr6, 0x8261015c
	if ctx.cr[6].eq {
	pc = 0x8261015C; continue 'dispatch;
	}
	// 826100B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826100B8: 409A000C  bne cr6, 0x826100c4
	if !ctx.cr[6].eq {
	pc = 0x826100C4; continue 'dispatch;
	}
	// 826100BC: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 826100C0: 48000028  b 0x826100e8
	pc = 0x826100E8; continue 'dispatch;
            }
            0x826100C4 => {
    //   block [0x826100C4..0x826100DC)
	// 826100C4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826100C8: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 826100CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826100D0: 4098000C  bge cr6, 0x826100dc
	if !ctx.cr[6].lt {
	pc = 0x826100DC; continue 'dispatch;
	}
	// 826100D4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826100D8: 48000010  b 0x826100e8
	pc = 0x826100E8; continue 'dispatch;
            }
            0x826100DC => {
    //   block [0x826100DC..0x826100E8)
	// 826100DC: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 826100E0: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 826100E4: 7FC9502E  lwzx r30, r9, r10
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	pc = 0x826100E8; continue 'dispatch;
            }
            0x826100E8 => {
    //   block [0x826100E8..0x8261015C)
	// 826100E8: 81780014  lwz r11, 0x14(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) } as u64;
	// 826100EC: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 826100F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826100F4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 826100F8: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	pc = 0x8261015C; continue 'dispatch;
            }
            0x8261015C => {
    //   block [0x8261015C..0x8261017C)
	// 8261015C: 815C002C  lwz r10, 0x2c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 82610160: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82610164: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82610168: 3B5A0002  addi r26, r26, 2
	ctx.r[26].s64 = ctx.r[26].s64 + 2;
	// 8261016C: 3BBD0030  addi r29, r29, 0x30
	ctx.r[29].s64 = ctx.r[29].s64 + 48;
	// 82610170: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82610174: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82610178: 409AFF04  bne cr6, 0x8261007c
	if !ctx.cr[6].eq {
	pc = 0x8261007C; continue 'dispatch;
	}
	pc = 0x8261017C; continue 'dispatch;
            }
            0x8261017C => {
    //   block [0x8261017C..0x82610188)
	// 8261017C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82610180: 4BCEFFA9  bl 0x82300128
	ctx.lr = 0x82610184;
	sub_82300128(ctx, base);
	// 82610184: 4BFFFD7C  b 0x8260ff00
	pc = 0x8260FF00; continue 'dispatch;
            }
            0x82610188 => {
    //   block [0x82610188..0x82610190)
	// 82610188: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 8261018C: 486992AC  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82610190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82610190 size=1004
    let mut pc: u32 = 0x82610190;
    'dispatch: loop {
        match pc {
            0x82610190 => {
    //   block [0x82610190..0x8261057C)
	// 82610190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82610194: 48699251  bl 0x82ca93e4
	ctx.lr = 0x82610198;
	sub_82CA93D0(ctx, base);
	// 82610198: DBC1FF80  stfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 8261019C: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 826101A0: 3980FF60  li r12, -0xa0
	ctx.r[12].s64 = -160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82610580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82610580 size=1692
    let mut pc: u32 = 0x82610580;
    'dispatch: loop {
        match pc {
            0x82610580 => {
    //   block [0x82610580..0x82610C1C)
	// 82610580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82610584: 48698E4D  bl 0x82ca93d0
	ctx.lr = 0x82610588;
	sub_82CA93D0(ctx, base);
	// 82610588: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 8261058C: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82610C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82610C20 size=576
    let mut pc: u32 = 0x82610C20;
    'dispatch: loop {
        match pc {
            0x82610C20 => {
    //   block [0x82610C20..0x82610C4C)
	// 82610C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82610C24: 486987D1  bl 0x82ca93f4
	ctx.lr = 0x82610C28;
	sub_82CA93D0(ctx, base);
	// 82610C28: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82610C2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82610C30: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82610C34: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82610C38: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 82610C3C: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82610C40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82610C44: 419A0074  beq cr6, 0x82610cb8
	if ctx.cr[6].eq {
	pc = 0x82610CB8; continue 'dispatch;
	}
	// 82610C48: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	pc = 0x82610C4C; continue 'dispatch;
            }
            0x82610C4C => {
    //   block [0x82610C4C..0x82610C9C)
	// 82610C4C: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 82610C50: 80780000  lwz r3, 0(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82610C54: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82610C58: 4876DA71  bl 0x82d7e6c8
	ctx.lr = 0x82610C5C;
	sub_82D7E6C8(ctx, base);
	// 82610C5C: 815E003C  lwz r10, 0x3c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 82610C60: 7C7F502E  lwzx r3, r31, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82610C64: A1230004  lhz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82610C68: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82610C6C: 419A0030  beq cr6, 0x82610c9c
	if ctx.cr[6].eq {
	pc = 0x82610C9C; continue 'dispatch;
	}
	// 82610C70: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 82610C74: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82610C78: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 82610C7C: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 82610C80: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82610C84: 409A0018  bne cr6, 0x82610c9c
	if !ctx.cr[6].eq {
	pc = 0x82610C9C; continue 'dispatch;
	}
	// 82610C88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82610C8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82610C90: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82610C94: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82610C98: 4E800421  bctrl
	ctx.lr = 0x82610C9C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82610C9C => {
    //   block [0x82610C9C..0x82610CB8)
	// 82610C9C: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 82610CA0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82610CA4: 7EFF592E  stwx r23, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[23].u32) };
	// 82610CA8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82610CAC: 815E0040  lwz r10, 0x40(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82610CB0: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82610CB4: 409AFF98  bne cr6, 0x82610c4c
	if !ctx.cr[6].eq {
	pc = 0x82610C4C; continue 'dispatch;
	}
	pc = 0x82610CB8; continue 'dispatch;
            }
            0x82610CB8 => {
    //   block [0x82610CB8..0x82610CE0)
	// 82610CB8: 92FE0040  stw r23, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[23].u32 ) };
	// 82610CBC: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82610CC0: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82610CC4: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82610CC8: 810B0020  lwz r8, 0x20(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82610CCC: 7D49402E  lwzx r10, r9, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82610CD0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82610CD4: 4098000C  bge cr6, 0x82610ce0
	if !ctx.cr[6].lt {
	pc = 0x82610CE0; continue 'dispatch;
	}
	// 82610CD8: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 82610CDC: 48000010  b 0x82610cec
	pc = 0x82610CEC; continue 'dispatch;
            }
            0x82610CE0 => {
    //   block [0x82610CE0..0x82610CEC)
	// 82610CE0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82610CE4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82610CE8: 7F4A582E  lwzx r26, r10, r11
	ctx.r[26].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x82610CEC; continue 'dispatch;
            }
            0x82610CEC => {
    //   block [0x82610CEC..0x82610D08)
	// 82610CEC: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82610CF0: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 82610CF4: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82610CF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82610CFC: 419A00F0  beq cr6, 0x82610dec
	if ctx.cr[6].eq {
	pc = 0x82610DEC; continue 'dispatch;
	}
	// 82610D00: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 82610D04: 3B20002C  li r25, 0x2c
	ctx.r[25].s64 = 44;
	pc = 0x82610D08; continue 'dispatch;
            }
            0x82610D08 => {
    //   block [0x82610D08..0x82610D4C)
	// 82610D08: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82610D0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82610D10: 80980000  lwz r4, 0(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82610D14: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82610D18: 7FEAE02E  lwzx r31, r10, r28
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82610D1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82610D20: 4876D8C9  bl 0x82d7e5e8
	ctx.lr = 0x82610D24;
	sub_82D7E5E8(ctx, base);
	// 82610D24: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82610D28: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82610D2C: 409A00A8  bne cr6, 0x82610dd4
	if !ctx.cr[6].eq {
	pc = 0x82610DD4; continue 'dispatch;
	}
	// 82610D30: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82610D34: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82610D38: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82610D3C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82610D40: 4098000C  bge cr6, 0x82610d4c
	if !ctx.cr[6].lt {
	pc = 0x82610D4C; continue 'dispatch;
	}
	// 82610D44: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 82610D48: 48000010  b 0x82610d58
	pc = 0x82610D58; continue 'dispatch;
            }
            0x82610D4C => {
    //   block [0x82610D4C..0x82610D58)
	// 82610D4C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82610D50: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82610D54: 7FAA582E  lwzx r29, r10, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x82610D58; continue 'dispatch;
            }
            0x82610D58 => {
    //   block [0x82610D58..0x82610DC8)
	// 82610D58: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82610D5C: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82610D60: 38A0002B  li r5, 0x2b
	ctx.r[5].s64 = 43;
	// 82610D64: 3880002C  li r4, 0x2c
	ctx.r[4].s64 = 44;
	// 82610D68: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82610D6C: 487444DD  bl 0x82d55248
	ctx.lr = 0x82610D70;
	sub_82D55248(ctx, base);
	// 82610D70: B3230004  sth r25, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[25].u16 ) };
	// 82610D74: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82610D78: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82610D7C: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82610D80: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82610D84: 487763AD  bl 0x82d87130
	ctx.lr = 0x82610D88;
	sub_82D87130(ctx, base);
	// 82610D88: A13F0004  lhz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82610D8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82610D90: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82610D94: 419A0034  beq cr6, 0x82610dc8
	if ctx.cr[6].eq {
	pc = 0x82610DC8; continue 'dispatch;
	}
	// 82610D98: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 82610D9C: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82610DA0: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 82610DA4: B13F0006  sth r9, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 82610DA8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82610DAC: 409A001C  bne cr6, 0x82610dc8
	if !ctx.cr[6].eq {
	pc = 0x82610DC8; continue 'dispatch;
	}
	// 82610DB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82610DB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82610DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82610DBC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82610DC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82610DC4: 4E800421  bctrl
	ctx.lr = 0x82610DC8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82610DC8 => {
    //   block [0x82610DC8..0x82610DD4)
	// 82610DC8: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82610DCC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82610DD0: 7FAAE12E  stwx r29, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[29].u32) };
	pc = 0x82610DD4; continue 'dispatch;
            }
            0x82610DD4 => {
    //   block [0x82610DD4..0x82610DEC)
	// 82610DD4: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82610DD8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82610DDC: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82610DE0: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82610DE4: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82610DE8: 409AFF20  bne cr6, 0x82610d08
	if !ctx.cr[6].eq {
	pc = 0x82610D08; continue 'dispatch;
	}
	pc = 0x82610DEC; continue 'dispatch;
            }
            0x82610DEC => {
    //   block [0x82610DEC..0x82610E08)
	// 82610DEC: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82610DF0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82610DF4: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82610DF8: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82610DFC: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82610E00: 419A0058  beq cr6, 0x82610e58
	if ctx.cr[6].eq {
	pc = 0x82610E58; continue 'dispatch;
	}
	// 82610E04: 3BE00004  li r31, 4
	ctx.r[31].s64 = 4;
	pc = 0x82610E08; continue 'dispatch;
            }
            0x82610E08 => {
    //   block [0x82610E08..0x82610E24)
	// 82610E08: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82610E0C: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82610E10: 7D4AF82E  lwzx r10, r10, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82610E14: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82610E18: 4098000C  bge cr6, 0x82610e24
	if !ctx.cr[6].lt {
	pc = 0x82610E24; continue 'dispatch;
	}
	// 82610E1C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82610E20: 48000010  b 0x82610e30
	pc = 0x82610E30; continue 'dispatch;
            }
            0x82610E24 => {
    //   block [0x82610E24..0x82610E30)
	// 82610E24: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82610E28: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82610E2C: 7CAA582E  lwzx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x82610E30; continue 'dispatch;
            }
            0x82610E30 => {
    //   block [0x82610E30..0x82610E58)
	// 82610E30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82610E34: 80980000  lwz r4, 0(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82610E38: 48767031  bl 0x82d77e68
	ctx.lr = 0x82610E3C;
	sub_82D77E68(ctx, base);
	// 82610E3C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82610E40: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82610E44: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82610E48: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82610E4C: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82610E50: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82610E54: 409AFFB4  bne cr6, 0x82610e08
	if !ctx.cr[6].eq {
	pc = 0x82610E08; continue 'dispatch;
	}
	pc = 0x82610E58; continue 'dispatch;
            }
            0x82610E58 => {
    //   block [0x82610E58..0x82610E60)
	// 82610E58: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82610E5C: 486985E8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82610E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82610E60 size=872
    let mut pc: u32 = 0x82610E60;
    'dispatch: loop {
        match pc {
            0x82610E60 => {
    //   block [0x82610E60..0x82610E8C)
	// 82610E60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82610E64: 4869858D  bl 0x82ca93f0
	ctx.lr = 0x82610E68;
	sub_82CA93D0(ctx, base);
	// 82610E68: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82610E6C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 82610E70: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82610E74: 3B160030  addi r24, r22, 0x30
	ctx.r[24].s64 = ctx.r[22].s64 + 48;
	// 82610E78: 81760034  lwz r11, 0x34(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(52 as u32) ) } as u64;
	// 82610E7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82610E80: 409A000C  bne cr6, 0x82610e8c
	if !ctx.cr[6].eq {
	pc = 0x82610E8C; continue 'dispatch;
	}
	// 82610E84: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82610E88: 48000010  b 0x82610e98
	pc = 0x82610E98; continue 'dispatch;
            }
            0x82610E8C => {
    //   block [0x82610E8C..0x82610E98)
	// 82610E8C: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82610E90: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82610E94: 7D3B1670  srawi r27, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x82610E98; continue 'dispatch;
            }
            0x82610E98 => {
    //   block [0x82610E98..0x82610EC4)
	// 82610E98: 81770010  lwz r11, 0x10(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(16 as u32) ) } as u64;
	// 82610E9C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82610EA0: 409A009C  bne cr6, 0x82610f3c
	if !ctx.cr[6].eq {
	pc = 0x82610F3C; continue 'dispatch;
	}
	// 82610EA4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82610EA8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82610EAC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82610EB0: 419A0310  beq cr6, 0x826111c0
	if ctx.cr[6].eq {
	pc = 0x826111C0; continue 'dispatch;
	}
	// 82610EB4: 83F80004  lwz r31, 4(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82610EB8: 3BB70008  addi r29, r23, 8
	ctx.r[29].s64 = ctx.r[23].s64 + 8;
	// 82610EBC: 8357000C  lwz r26, 0xc(r23)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 82610EC0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82610EC4; continue 'dispatch;
            }
            0x82610EC4 => {
    //   block [0x82610EC4..0x82610EE0)
	// 82610EC4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82610EC8: 419A0018  beq cr6, 0x82610ee0
	if ctx.cr[6].eq {
	pc = 0x82610EE0; continue 'dispatch;
	}
	// 82610ECC: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82610ED0: 7D5F5850  subf r10, r31, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 82610ED4: 7D4B1670  srawi r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 82610ED8: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82610EDC: 41980008  blt cr6, 0x82610ee4
	if ctx.cr[6].lt {
	pc = 0x82610EE4; continue 'dispatch;
	}
	pc = 0x82610EE0; continue 'dispatch;
            }
            0x82610EE0 => {
    //   block [0x82610EE0..0x82610EE4)
	// 82610EE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82610EE4; continue 'dispatch;
            }
            0x82610EE4 => {
    //   block [0x82610EE4..0x82610F10)
	// 82610EE4: 7D7EF82E  lwzx r11, r30, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82610EE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82610EEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82610EF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82610EF4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82610EF8: 4BD7E021  bl 0x8238ef18
	ctx.lr = 0x82610EFC;
	sub_8238EF18(ctx, base);
	// 82610EFC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82610F00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82610F04: 419A000C  beq cr6, 0x82610f10
	if ctx.cr[6].eq {
	pc = 0x82610F10; continue 'dispatch;
	}
	// 82610F08: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82610F0C: 419A0008  beq cr6, 0x82610f14
	if ctx.cr[6].eq {
	pc = 0x82610F14; continue 'dispatch;
	}
	pc = 0x82610F10; continue 'dispatch;
            }
            0x82610F10 => {
    //   block [0x82610F10..0x82610F14)
	// 82610F10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82610F14; continue 'dispatch;
            }
            0x82610F14 => {
    //   block [0x82610F14..0x82610F24)
	// 82610F14: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82610F18: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82610F1C: 419A0008  beq cr6, 0x82610f24
	if ctx.cr[6].eq {
	pc = 0x82610F24; continue 'dispatch;
	}
	// 82610F20: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	pc = 0x82610F24; continue 'dispatch;
            }
            0x82610F24 => {
    //   block [0x82610F24..0x82610F3C)
	// 82610F24: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82610F28: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82610F2C: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82610F30: 409AFF94  bne cr6, 0x82610ec4
	if !ctx.cr[6].eq {
	pc = 0x82610EC4; continue 'dispatch;
	}
	// 82610F34: 7F19D840  cmplw cr6, r25, r27
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82610F38: 419A0288  beq cr6, 0x826111c0
	if ctx.cr[6].eq {
	pc = 0x826111C0; continue 'dispatch;
	}
	pc = 0x82610F3C; continue 'dispatch;
            }
            0x82610F3C => {
    //   block [0x82610F3C..0x82610F44)
	// 82610F3C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82610F40: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82610F44; continue 'dispatch;
            }
            0x82610F44 => {
    //   block [0x82610F44..0x82610F5C)
	// 82610F44: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82610F48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82610F4C: 419A0010  beq cr6, 0x82610f5c
	if ctx.cr[6].eq {
	pc = 0x82610F5C; continue 'dispatch;
	}
	// 82610F50: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82610F54: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82610F58: 7D2B1670  srawi r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x82610F5C; continue 'dispatch;
            }
            0x82610F5C => {
    //   block [0x82610F5C..0x82610F84)
	// 82610F5C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82610F60: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82610F64: 419A00F0  beq cr6, 0x82611054
	if ctx.cr[6].eq {
	pc = 0x82611054; continue 'dispatch;
	}
	// 82610F68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82610F6C: 419A0018  beq cr6, 0x82610f84
	if ctx.cr[6].eq {
	pc = 0x82610F84; continue 'dispatch;
	}
	// 82610F70: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82610F74: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82610F78: 7D2A1670  srawi r10, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 82610F7C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82610F80: 41980008  blt cr6, 0x82610f88
	if ctx.cr[6].lt {
	pc = 0x82610F88; continue 'dispatch;
	}
	pc = 0x82610F84; continue 'dispatch;
            }
            0x82610F84 => {
    //   block [0x82610F84..0x82610F88)
	// 82610F84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82610F88; continue 'dispatch;
            }
            0x82610F88 => {
    //   block [0x82610F88..0x82610FB0)
	// 82610F88: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82610F8C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82610F90: 3896001C  addi r4, r22, 0x1c
	ctx.r[4].s64 = ctx.r[22].s64 + 28;
	// 82610F94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82610F98: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82610F9C: 4BF6DC6D  bl 0x8257ec08
	ctx.lr = 0x82610FA0;
	sub_8257EC08(ctx, base);
	// 82610FA0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82610FA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82610FA8: 409A0008  bne cr6, 0x82610fb0
	if !ctx.cr[6].eq {
	pc = 0x82610FB0; continue 'dispatch;
	}
	// 82610FAC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82610FB0; continue 'dispatch;
            }
            0x82610FB0 => {
    //   block [0x82610FB0..0x82610FC4)
	// 82610FB0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82610FB4: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82610FB8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82610FBC: 409A0008  bne cr6, 0x82610fc4
	if !ctx.cr[6].eq {
	pc = 0x82610FC4; continue 'dispatch;
	}
	// 82610FC0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82610FC4; continue 'dispatch;
            }
            0x82610FC4 => {
    //   block [0x82610FC4..0x82610FF8)
	// 82610FC4: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82610FC8: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 82610FCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82610FD0: 419A0078  beq cr6, 0x82611048
	if ctx.cr[6].eq {
	pc = 0x82611048; continue 'dispatch;
	}
	// 82610FD4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82610FD8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82610FDC: 419A004C  beq cr6, 0x82611028
	if ctx.cr[6].eq {
	pc = 0x82611028; continue 'dispatch;
	}
	// 82610FE0: 550B003E  slwi r11, r8, 0
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82610FE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82610FE8: 419A0060  beq cr6, 0x82611048
	if ctx.cr[6].eq {
	pc = 0x82611048; continue 'dispatch;
	}
	// 82610FEC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82610FF0: 409A0008  bne cr6, 0x82610ff8
	if !ctx.cr[6].eq {
	pc = 0x82610FF8; continue 'dispatch;
	}
	// 82610FF4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82610FF8; continue 'dispatch;
            }
            0x82610FF8 => {
    //   block [0x82610FF8..0x82611028)
	// 82610FF8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82610FFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611000: 419A003C  beq cr6, 0x8261103c
	if ctx.cr[6].eq {
	pc = 0x8261103C; continue 'dispatch;
	}
	// 82611004: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611008: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261100C: 419A002C  beq cr6, 0x82611038
	if ctx.cr[6].eq {
	pc = 0x82611038; continue 'dispatch;
	}
	// 82611010: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82611014: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82611018: 4BFFFC09  bl 0x82610c20
	ctx.lr = 0x8261101C;
	sub_82610C20(ctx, base);
	// 8261101C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82611020: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82611024: 4BFFFF20  b 0x82610f44
	pc = 0x82610F44; continue 'dispatch;
            }
            0x82611028 => {
    //   block [0x82611028..0x82611038)
	// 82611028: 4BB82E11  bl 0x82193e38
	ctx.lr = 0x8261102C;
	sub_82193E38(ctx, base);
	// 8261102C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82611030: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82611034: 4BFFFF10  b 0x82610f44
	pc = 0x82610F44; continue 'dispatch;
            }
            0x82611038 => {
    //   block [0x82611038..0x8261103C)
	// 82611038: 4BB82E01  bl 0x82193e38
	ctx.lr = 0x8261103C;
	sub_82193E38(ctx, base);
	pc = 0x8261103C; continue 'dispatch;
            }
            0x8261103C => {
    //   block [0x8261103C..0x82611048)
	// 8261103C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82611040: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82611044: 4BFFFBDD  bl 0x82610c20
	ctx.lr = 0x82611048;
	sub_82610C20(ctx, base);
	pc = 0x82611048; continue 'dispatch;
            }
            0x82611048 => {
    //   block [0x82611048..0x82611054)
	// 82611048: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8261104C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82611050: 4BFFFEF4  b 0x82610f44
	pc = 0x82610F44; continue 'dispatch;
            }
            0x82611054 => {
    //   block [0x82611054..0x82611064)
	// 82611054: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82611058: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261105C: 40990008  ble cr6, 0x82611064
	if !ctx.cr[6].gt {
	pc = 0x82611064; continue 'dispatch;
	}
	// 82611060: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611064; continue 'dispatch;
            }
            0x82611064 => {
    //   block [0x82611064..0x82611078)
	// 82611064: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 82611068: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261106C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82611070: 40990008  ble cr6, 0x82611078
	if !ctx.cr[6].gt {
	pc = 0x82611078; continue 'dispatch;
	}
	// 82611074: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611078; continue 'dispatch;
            }
            0x82611078 => {
    //   block [0x82611078..0x826110AC)
	// 82611078: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8261107C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82611080: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82611084: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 82611088: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261108C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82611090: 485EFA71  bl 0x82c00b00
	ctx.lr = 0x82611094;
	sub_82C00B00(ctx, base);
	// 82611094: 8157000C  lwz r10, 0xc(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 82611098: 3BF70008  addi r31, r23, 8
	ctx.r[31].s64 = ctx.r[23].s64 + 8;
	// 8261109C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 826110A0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826110A4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 826110A8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x826110AC; continue 'dispatch;
            }
            0x826110AC => {
    //   block [0x826110AC..0x826110C0)
	// 826110AC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826110B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826110B4: 419A000C  beq cr6, 0x826110c0
	if ctx.cr[6].eq {
	pc = 0x826110C0; continue 'dispatch;
	}
	// 826110B8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 826110BC: 419A0008  beq cr6, 0x826110c4
	if ctx.cr[6].eq {
	pc = 0x826110C4; continue 'dispatch;
	}
	pc = 0x826110C0; continue 'dispatch;
            }
            0x826110C0 => {
    //   block [0x826110C0..0x826110C4)
	// 826110C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826110C4; continue 'dispatch;
            }
            0x826110C4 => {
    //   block [0x826110C4..0x826110D8)
	// 826110C4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 826110C8: 419A00F8  beq cr6, 0x826111c0
	if ctx.cr[6].eq {
	pc = 0x826111C0; continue 'dispatch;
	}
	// 826110CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826110D0: 409A0008  bne cr6, 0x826110d8
	if !ctx.cr[6].eq {
	pc = 0x826110D8; continue 'dispatch;
	}
	// 826110D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826110D8; continue 'dispatch;
            }
            0x826110D8 => {
    //   block [0x826110D8..0x826110E8)
	// 826110D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826110DC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826110E0: 409A0008  bne cr6, 0x826110e8
	if !ctx.cr[6].eq {
	pc = 0x826110E8; continue 'dispatch;
	}
	// 826110E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826110E8; continue 'dispatch;
            }
            0x826110E8 => {
    //   block [0x826110E8..0x82611110)
	// 826110E8: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 826110EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826110F0: 3896001C  addi r4, r22, 0x1c
	ctx.r[4].s64 = ctx.r[22].s64 + 28;
	// 826110F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826110F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826110FC: 4BF6DB0D  bl 0x8257ec08
	ctx.lr = 0x82611100;
	sub_8257EC08(ctx, base);
	// 82611100: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82611104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611108: 409A0008  bne cr6, 0x82611110
	if !ctx.cr[6].eq {
	pc = 0x82611110; continue 'dispatch;
	}
	// 8261110C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611110; continue 'dispatch;
            }
            0x82611110 => {
    //   block [0x82611110..0x82611124)
	// 82611110: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611114: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82611118: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8261111C: 409A0008  bne cr6, 0x82611124
	if !ctx.cr[6].eq {
	pc = 0x82611124; continue 'dispatch;
	}
	// 82611120: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611124; continue 'dispatch;
            }
            0x82611124 => {
    //   block [0x82611124..0x82611158)
	// 82611124: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82611128: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 8261112C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611130: 419A007C  beq cr6, 0x826111ac
	if ctx.cr[6].eq {
	pc = 0x826111AC; continue 'dispatch;
	}
	// 82611134: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611138: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8261113C: 419A003C  beq cr6, 0x82611178
	if ctx.cr[6].eq {
	pc = 0x82611178; continue 'dispatch;
	}
	// 82611140: 550B003E  slwi r11, r8, 0
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82611144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611148: 419A0064  beq cr6, 0x826111ac
	if ctx.cr[6].eq {
	pc = 0x826111AC; continue 'dispatch;
	}
	// 8261114C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82611150: 409A0008  bne cr6, 0x82611158
	if !ctx.cr[6].eq {
	pc = 0x82611158; continue 'dispatch;
	}
	// 82611154: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611158; continue 'dispatch;
            }
            0x82611158 => {
    //   block [0x82611158..0x82611178)
	// 82611158: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261115C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611160: 419A0034  beq cr6, 0x82611194
	if ctx.cr[6].eq {
	pc = 0x82611194; continue 'dispatch;
	}
	// 82611164: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611168: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261116C: 419A0024  beq cr6, 0x82611190
	if ctx.cr[6].eq {
	pc = 0x82611190; continue 'dispatch;
	}
	// 82611170: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82611174: 48000024  b 0x82611198
	pc = 0x82611198; continue 'dispatch;
            }
            0x82611178 => {
    //   block [0x82611178..0x82611190)
	// 82611178: 4BB82CC1  bl 0x82193e38
	ctx.lr = 0x8261117C;
	sub_82193E38(ctx, base);
	// 8261117C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82611180: 4BCEEFA9  bl 0x82300128
	ctx.lr = 0x82611184;
	sub_82300128(ctx, base);
	// 82611184: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82611188: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261118C: 4BFFFF20  b 0x826110ac
	pc = 0x826110AC; continue 'dispatch;
            }
            0x82611190 => {
    //   block [0x82611190..0x82611194)
	// 82611190: 4BB82CA9  bl 0x82193e38
	ctx.lr = 0x82611194;
	sub_82193E38(ctx, base);
	pc = 0x82611194; continue 'dispatch;
            }
            0x82611194 => {
    //   block [0x82611194..0x82611198)
	// 82611194: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82611198; continue 'dispatch;
            }
            0x82611198 => {
    //   block [0x82611198..0x826111AC)
	// 82611198: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 8261119C: 4BFFF3E5  bl 0x82610580
	ctx.lr = 0x826111A0;
	sub_82610580(ctx, base);
	// 826111A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826111A4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 826111A8: 4BD6B031  bl 0x8237c1d8
	ctx.lr = 0x826111AC;
	sub_8237C1D8(ctx, base);
	pc = 0x826111AC; continue 'dispatch;
            }
            0x826111AC => {
    //   block [0x826111AC..0x826111C0)
	// 826111AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826111B0: 4BCEEF79  bl 0x82300128
	ctx.lr = 0x826111B4;
	sub_82300128(ctx, base);
	// 826111B4: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826111B8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826111BC: 4BFFFEF0  b 0x826110ac
	pc = 0x826110AC; continue 'dispatch;
            }
            0x826111C0 => {
    //   block [0x826111C0..0x826111C8)
	// 826111C0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 826111C4: 4869827C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826111C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826111C8 size=156
    let mut pc: u32 = 0x826111C8;
    'dispatch: loop {
        match pc {
            0x826111C8 => {
    //   block [0x826111C8..0x82611214)
	// 826111C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826111CC: 48698241  bl 0x82ca940c
	ctx.lr = 0x826111D0;
	sub_82CA93D0(ctx, base);
	// 826111D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826111D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826111D8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826111DC: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 826111E0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 826111E4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 826111E8: 409A002C  bne cr6, 0x82611214
	if !ctx.cr[6].eq {
	pc = 0x82611214; continue 'dispatch;
	}
	// 826111EC: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 826111F0: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826111F4: 556B087C  rlwinm r11, r11, 1, 1, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 826111F8: 809F0040  lwz r4, 0x40(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 826111FC: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82611200: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82611204: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 82611208: 54E52036  slwi r5, r7, 4
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8261120C: 7C68482E  lwzx r3, r8, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82611210: 487440B9  bl 0x82d552c8
	ctx.lr = 0x82611214;
	sub_82D552C8(ctx, base);
	pc = 0x82611214; continue 'dispatch;
            }
            0x82611214 => {
    //   block [0x82611214..0x8261125C)
	// 82611214: 3BDF002C  addi r30, r31, 0x2c
	ctx.r[30].s64 = ctx.r[31].s64 + 44;
	// 82611218: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 8261121C: 48406B45  bl 0x82a17d60
	ctx.lr = 0x82611220;
	sub_82A17D60(ctx, base);
	// 82611220: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82611224: 4BBA68F5  bl 0x821b7b18
	ctx.lr = 0x82611228;
	sub_821B7B18(ctx, base);
	// 82611228: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 8261122C: 4BDCB5FD  bl 0x823dc828
	ctx.lr = 0x82611230;
	sub_823DC828(ctx, base);
	// 82611230: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82611234: 4BDCB5F5  bl 0x823dc828
	ctx.lr = 0x82611238;
	sub_823DC828(ctx, base);
	// 82611238: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8261123C: 57AA07FE  clrlwi r10, r29, 0x1f
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 82611240: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 82611244: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82611248: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8261124C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82611250: 419A000C  beq cr6, 0x8261125c
	if ctx.cr[6].eq {
	pc = 0x8261125C; continue 'dispatch;
	}
	// 82611254: 4BC0AAE5  bl 0x8221bd38
	ctx.lr = 0x82611258;
	sub_8221BD38(ctx, base);
	// 82611258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8261125C; continue 'dispatch;
            }
            0x8261125C => {
    //   block [0x8261125C..0x82611264)
	// 8261125C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82611260: 486981FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82611268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82611268 size=380
    let mut pc: u32 = 0x82611268;
    'dispatch: loop {
        match pc {
            0x82611268 => {
    //   block [0x82611268..0x826112DC)
	// 82611268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261126C: 48698181  bl 0x82ca93ec
	ctx.lr = 0x82611270;
	sub_82CA93D0(ctx, base);
	// 82611270: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82611274: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 82611278: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8261127C: 4800057D  bl 0x826117f8
	ctx.lr = 0x82611280;
	sub_826117F8(ctx, base);
	// 82611280: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82611284: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82611288: 388B8308  addi r4, r11, -0x7cf8
	ctx.r[4].s64 = ctx.r[11].s64 + -31992;
	// 8261128C: 4BC9875D  bl 0x822a99e8
	ctx.lr = 0x82611290;
	sub_822A99E8(ctx, base);
	// 82611290: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82611294: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82611298: 419A0144  beq cr6, 0x826113dc
	if ctx.cr[6].eq {
	pc = 0x826113DC; continue 'dispatch;
	}
	// 8261129C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826112A0: 483EF6F1  bl 0x82a00990
	ctx.lr = 0x826112A4;
	sub_82A00990(ctx, base);
	// 826112A4: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 826112A8: 82A1005C  lwz r21, 0x5c(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826112AC: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826112B0: 7F1EA840  cmplw cr6, r30, r21
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[21].u32, &mut ctx.xer);
	// 826112B4: 419A0120  beq cr6, 0x826113d4
	if ctx.cr[6].eq {
	pc = 0x826113D4; continue 'dispatch;
	}
	// 826112B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 826112BC: 3D20D6F3  lis r9, -0x290d
	ctx.r[9].s64 = -688717824;
	// 826112C0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 826112C4: 613A7228  ori r26, r9, 0x7228
	ctx.r[26].u64 = ctx.r[9].u64 | 29224;
	// 826112C8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826112CC: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 826112D0: 3F00834A  lis r24, -0x7cb6
	ctx.r[24].s64 = -2092302336;
	// 826112D4: 3B6B0E0C  addi r27, r11, 0xe0c
	ctx.r[27].s64 = ctx.r[11].s64 + 3596;
	// 826112D8: 3B2AE460  addi r25, r10, -0x1ba0
	ctx.r[25].s64 = ctx.r[10].s64 + -7072;
	pc = 0x826112DC; continue 'dispatch;
            }
            0x826112DC => {
    //   block [0x826112DC..0x82611318)
	// 826112DC: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826112E0: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 826112E4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826112E8: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 826112EC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826112F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826112F4: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 826112F8: 419A0020  beq cr6, 0x82611318
	if ctx.cr[6].eq {
	pc = 0x82611318; continue 'dispatch;
	}
	// 826112FC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82611300: 409A0018  bne cr6, 0x82611318
	if !ctx.cr[6].eq {
	pc = 0x82611318; continue 'dispatch;
	}
	// 82611304: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611308: 8138E454  lwz r9, -0x1bac(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 8261130C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82611310: 409A0008  bne cr6, 0x82611318
	if !ctx.cr[6].eq {
	pc = 0x82611318; continue 'dispatch;
	}
	// 82611314: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x82611318; continue 'dispatch;
            }
            0x82611318 => {
    //   block [0x82611318..0x82611364)
	// 82611318: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261131C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611320: 419A00A8  beq cr6, 0x826113c8
	if ctx.cr[6].eq {
	pc = 0x826113C8; continue 'dispatch;
	}
	// 82611324: 8156002C  lwz r10, 0x2c(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(44 as u32) ) } as u64;
	// 82611328: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261132C: 419A009C  beq cr6, 0x826113c8
	if ctx.cr[6].eq {
	pc = 0x826113C8; continue 'dispatch;
	}
	// 82611330: 7D4BD050  subf r10, r11, r26
	ctx.r[10].s64 = ctx.r[26].s64 - ctx.r[11].s64;
	// 82611334: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82611338: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8261133C: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82611340: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 82611344: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82611348: 4BC0DF11  bl 0x8221f258
	ctx.lr = 0x8261134C;
	sub_8221F258(ctx, base);
	// 8261134C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82611350: 419A0014  beq cr6, 0x82611364
	if ctx.cr[6].eq {
	pc = 0x82611364; continue 'dispatch;
	}
	// 82611354: 93630000  stw r27, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82611358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261135C: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82611360: 48000008  b 0x82611368
	pc = 0x82611368; continue 'dispatch;
            }
            0x82611364 => {
    //   block [0x82611364..0x82611368)
	// 82611364: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x82611368; continue 'dispatch;
            }
            0x82611368 => {
    //   block [0x82611368..0x826113A0)
	// 82611368: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8261136C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82611370: 419A0030  beq cr6, 0x826113a0
	if ctx.cr[6].eq {
	pc = 0x826113A0; continue 'dispatch;
	}
	// 82611374: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82611378: 4BC0DEE1  bl 0x8221f258
	ctx.lr = 0x8261137C;
	sub_8221F258(ctx, base);
	// 8261137C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82611380: 419A0020  beq cr6, 0x826113a0
	if ctx.cr[6].eq {
	pc = 0x826113A0; continue 'dispatch;
	}
	// 82611384: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82611388: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8261138C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82611390: 394B9238  addi r10, r11, -0x6dc8
	ctx.r[10].s64 = ctx.r[11].s64 + -28104;
	// 82611394: 92E30000  stw r23, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82611398: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8261139C: 48000008  b 0x826113a4
	pc = 0x826113A4; continue 'dispatch;
            }
            0x826113A0 => {
    //   block [0x826113A0..0x826113A4)
	// 826113A0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x826113A4; continue 'dispatch;
            }
            0x826113A4 => {
    //   block [0x826113A4..0x826113C8)
	// 826113A4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826113A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826113AC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 826113B0: 48000649  bl 0x826119f8
	ctx.lr = 0x826113B4;
	sub_826119F8(ctx, base);
	// 826113B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826113B8: 3876001C  addi r3, r22, 0x1c
	ctx.r[3].s64 = ctx.r[22].s64 + 28;
	// 826113BC: 4BCE458D  bl 0x822f5948
	ctx.lr = 0x826113C0;
	sub_822F5948(ctx, base);
	// 826113C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826113C4: 4BBA6755  bl 0x821b7b18
	ctx.lr = 0x826113C8;
	sub_821B7B18(ctx, base);
	pc = 0x826113C8; continue 'dispatch;
            }
            0x826113C8 => {
    //   block [0x826113C8..0x826113D4)
	// 826113C8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 826113CC: 7F1EA840  cmplw cr6, r30, r21
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[21].u32, &mut ctx.xer);
	// 826113D0: 409AFF0C  bne cr6, 0x826112dc
	if !ctx.cr[6].eq {
	pc = 0x826112DC; continue 'dispatch;
	}
	pc = 0x826113D4; continue 'dispatch;
            }
            0x826113D4 => {
    //   block [0x826113D4..0x826113DC)
	// 826113D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826113D8: 4BC0A961  bl 0x8221bd38
	ctx.lr = 0x826113DC;
	sub_8221BD38(ctx, base);
	pc = 0x826113DC; continue 'dispatch;
            }
            0x826113DC => {
    //   block [0x826113DC..0x826113E4)
	// 826113DC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826113E0: 4869805C  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826113E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826113E8 size=488
    let mut pc: u32 = 0x826113E8;
    'dispatch: loop {
        match pc {
            0x826113E8 => {
    //   block [0x826113E8..0x8261143C)
	// 826113E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826113EC: 48698019  bl 0x82ca9404
	ctx.lr = 0x826113F0;
	sub_82CA93D0(ctx, base);
	// 826113F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826113F4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826113F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826113FC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611400: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82611404: 5528D7FE  rlwinm r8, r9, 0x1a, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 82611408: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8261140C: 419A00F8  beq cr6, 0x82611504
	if ctx.cr[6].eq {
	pc = 0x82611504; continue 'dispatch;
	}
	// 82611410: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82611414: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82611418: 419A0024  beq cr6, 0x8261143c
	if ctx.cr[6].eq {
	pc = 0x8261143C; continue 'dispatch;
	}
	// 8261141C: 894A0006  lbz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 82611420: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82611424: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82611428: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261142C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611430: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82611434: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82611438: 480000D0  b 0x82611508
	pc = 0x82611508; continue 'dispatch;
            }
            0x8261143C => {
    //   block [0x8261143C..0x8261145C)
	// 8261143C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82611440: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82611444: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82611448: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8261144C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82611450: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82611454: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82611458: 40810054  ble 0x826114ac
	if !ctx.cr[0].gt {
	pc = 0x826114AC; continue 'dispatch;
	}
	pc = 0x8261145C; continue 'dispatch;
            }
            0x8261145C => {
    //   block [0x8261145C..0x8261147C)
	// 8261145C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82611460: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82611464: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82611468: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261146C: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 82611470: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82611474: 41980008  blt cr6, 0x8261147c
	if ctx.cr[6].lt {
	pc = 0x8261147C; continue 'dispatch;
	}
	// 82611478: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8261147C; continue 'dispatch;
            }
            0x8261147C => {
    //   block [0x8261147C..0x82611498)
	// 8261147C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82611480: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82611484: 419A0014  beq cr6, 0x82611498
	if ctx.cr[6].eq {
	pc = 0x82611498; continue 'dispatch;
	}
	// 82611488: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261148C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82611490: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82611494: 4800000C  b 0x826114a0
	pc = 0x826114A0; continue 'dispatch;
            }
            0x82611498 => {
    //   block [0x82611498..0x826114A0)
	// 82611498: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261149C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x826114A0; continue 'dispatch;
            }
            0x826114A0 => {
    //   block [0x826114A0..0x826114AC)
	// 826114A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826114A4: 4199FFB8  bgt cr6, 0x8261145c
	if ctx.cr[6].gt {
	pc = 0x8261145C; continue 'dispatch;
	}
	// 826114A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x826114AC; continue 'dispatch;
            }
            0x826114AC => {
    //   block [0x826114AC..0x826114C8)
	// 826114AC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 826114B0: 419A0040  beq cr6, 0x826114f0
	if ctx.cr[6].eq {
	pc = 0x826114F0; continue 'dispatch;
	}
	// 826114B4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 826114B8: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 826114BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826114C0: 41990008  bgt cr6, 0x826114c8
	if ctx.cr[6].gt {
	pc = 0x826114C8; continue 'dispatch;
	}
	// 826114C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x826114C8; continue 'dispatch;
            }
            0x826114C8 => {
    //   block [0x826114C8..0x826114F0)
	// 826114C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 826114CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826114D0: 409A0020  bne cr6, 0x826114f0
	if !ctx.cr[6].eq {
	pc = 0x826114F0; continue 'dispatch;
	}
	// 826114D4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 826114D8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 826114DC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826114E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826114E4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 826114E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826114EC: 4800001C  b 0x82611508
	pc = 0x82611508; continue 'dispatch;
            }
            0x826114F0 => {
    //   block [0x826114F0..0x82611504)
	// 826114F0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 826114F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826114F8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 826114FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82611500: 48000008  b 0x82611508
	pc = 0x82611508; continue 'dispatch;
            }
            0x82611504 => {
    //   block [0x82611504..0x82611508)
	// 82611504: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82611508; continue 'dispatch;
            }
            0x82611508 => {
    //   block [0x82611508..0x82611520)
	// 82611508: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261150C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611510: 419A00B8  beq cr6, 0x826115c8
	if ctx.cr[6].eq {
	pc = 0x826115C8; continue 'dispatch;
	}
	// 82611514: 838A0094  lwz r28, 0x94(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(148 as u32) ) } as u64;
	// 82611518: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8261151C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82611520; continue 'dispatch;
            }
            0x82611520 => {
    //   block [0x82611520..0x82611538)
	// 82611520: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 82611524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611528: 419A0010  beq cr6, 0x82611538
	if ctx.cr[6].eq {
	pc = 0x82611538; continue 'dispatch;
	}
	// 8261152C: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82611530: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82611534: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x82611538; continue 'dispatch;
            }
            0x82611538 => {
    //   block [0x82611538..0x82611560)
	// 82611538: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261153C: 419A008C  beq cr6, 0x826115c8
	if ctx.cr[6].eq {
	pc = 0x826115C8; continue 'dispatch;
	}
	// 82611540: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 82611544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611548: 419A0018  beq cr6, 0x82611560
	if ctx.cr[6].eq {
	pc = 0x82611560; continue 'dispatch;
	}
	// 8261154C: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82611550: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82611554: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82611558: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261155C: 41980008  blt cr6, 0x82611564
	if ctx.cr[6].lt {
	pc = 0x82611564; continue 'dispatch;
	}
	pc = 0x82611560; continue 'dispatch;
            }
            0x82611560 => {
    //   block [0x82611560..0x82611564)
	// 82611560: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611564; continue 'dispatch;
            }
            0x82611564 => {
    //   block [0x82611564..0x82611580)
	// 82611564: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82611568: 7FFE582E  lwzx r31, r30, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8261156C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611570: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82611574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611578: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8261157C: 419A0020  beq cr6, 0x8261159c
	if ctx.cr[6].eq {
	pc = 0x8261159C; continue 'dispatch;
	}
	pc = 0x82611580; continue 'dispatch;
            }
            0x82611580 => {
    //   block [0x82611580..0x8261159C)
	// 82611580: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82611584: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82611588: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8261158C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82611590: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82611594: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82611598: 4082FFE8  bne 0x82611580
	if !ctx.cr[0].eq {
	pc = 0x82611580; continue 'dispatch;
	}
	pc = 0x8261159C; continue 'dispatch;
            }
            0x8261159C => {
    //   block [0x8261159C..0x826115C8)
	// 8261159C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 826115A0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826115A4: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 826115A8: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826115AC: 482B7035  bl 0x828c85e0
	ctx.lr = 0x826115B0;
	sub_828C85E0(ctx, base);
	// 826115B0: F87F0028  std r3, 0x28(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[3].u64 ) };
	// 826115B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826115B8: 4BBA6561  bl 0x821b7b18
	ctx.lr = 0x826115BC;
	sub_821B7B18(ctx, base);
	// 826115BC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 826115C0: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 826115C4: 4BFFFF5C  b 0x82611520
	pc = 0x82611520; continue 'dispatch;
            }
            0x826115C8 => {
    //   block [0x826115C8..0x826115D0)
	// 826115C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826115CC: 48697E88  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826115D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826115D0 size=212
    let mut pc: u32 = 0x826115D0;
    'dispatch: loop {
        match pc {
            0x826115D0 => {
    //   block [0x826115D0..0x8261160C)
	// 826115D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826115D4: 48697E39  bl 0x82ca940c
	ctx.lr = 0x826115D8;
	sub_82CA93D0(ctx, base);
	// 826115D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826115DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826115E0: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 826115E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826115E8: 419A00B4  beq cr6, 0x8261169c
	if ctx.cr[6].eq {
	pc = 0x8261169C; continue 'dispatch;
	}
	// 826115EC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 826115F0: 3BDD000C  addi r30, r29, 0xc
	ctx.r[30].s64 = ctx.r[29].s64 + 12;
	// 826115F4: 917D004C  stw r11, 0x4c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 826115F8: 83FD0010  lwz r31, 0x10(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 826115FC: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82611600: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82611604: 40990008  ble cr6, 0x8261160c
	if !ctx.cr[6].gt {
	pc = 0x8261160C; continue 'dispatch;
	}
	// 82611608: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261160C; continue 'dispatch;
            }
            0x8261160C => {
    //   block [0x8261160C..0x82611620)
	// 8261160C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82611610: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611614: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82611618: 40990008  ble cr6, 0x82611620
	if !ctx.cr[6].gt {
	pc = 0x82611620; continue 'dispatch;
	}
	// 8261161C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611620; continue 'dispatch;
            }
            0x82611620 => {
    //   block [0x82611620..0x8261162C)
	// 82611620: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82611624: 419A0008  beq cr6, 0x8261162c
	if ctx.cr[6].eq {
	pc = 0x8261162C; continue 'dispatch;
	}
	// 82611628: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261162C; continue 'dispatch;
            }
            0x8261162C => {
    //   block [0x8261162C..0x82611640)
	// 8261162C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82611630: 419A006C  beq cr6, 0x8261169c
	if ctx.cr[6].eq {
	pc = 0x8261169C; continue 'dispatch;
	}
	// 82611634: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82611638: 41980008  blt cr6, 0x82611640
	if ctx.cr[6].lt {
	pc = 0x82611640; continue 'dispatch;
	}
	// 8261163C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611640; continue 'dispatch;
            }
            0x82611640 => {
    //   block [0x82611640..0x82611658)
	// 82611640: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611644: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261164C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82611650: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82611654: 419A0020  beq cr6, 0x82611674
	if ctx.cr[6].eq {
	pc = 0x82611674; continue 'dispatch;
	}
	pc = 0x82611658; continue 'dispatch;
            }
            0x82611658 => {
    //   block [0x82611658..0x82611674)
	// 82611658: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8261165C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82611660: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82611664: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82611668: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8261166C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82611670: 4082FFE8  bne 0x82611658
	if !ctx.cr[0].eq {
	pc = 0x82611658; continue 'dispatch;
	}
	pc = 0x82611674; continue 'dispatch;
            }
            0x82611674 => {
    //   block [0x82611674..0x82611694)
	// 82611674: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82611678: 48000751  bl 0x82611dc8
	ctx.lr = 0x8261167C;
	sub_82611DC8(ctx, base);
	// 8261167C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82611680: 4BBA6499  bl 0x821b7b18
	ctx.lr = 0x82611684;
	sub_821B7B18(ctx, base);
	// 82611684: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82611688: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261168C: 41980008  blt cr6, 0x82611694
	if ctx.cr[6].lt {
	pc = 0x82611694; continue 'dispatch;
	}
	// 82611690: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611694; continue 'dispatch;
            }
            0x82611694 => {
    //   block [0x82611694..0x8261169C)
	// 82611694: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82611698: 4BFFFF74  b 0x8261160c
	pc = 0x8261160C; continue 'dispatch;
            }
            0x8261169C => {
    //   block [0x8261169C..0x826116A4)
	// 8261169C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826116A0: 48697DBC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826116A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826116A8 size=224
    let mut pc: u32 = 0x826116A8;
    'dispatch: loop {
        match pc {
            0x826116A8 => {
    //   block [0x826116A8..0x826116D0)
	// 826116A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826116AC: 48697D59  bl 0x82ca9404
	ctx.lr = 0x826116B0;
	sub_82CA93D0(ctx, base);
	// 826116B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826116B4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 826116B8: 3BBC000C  addi r29, r28, 0xc
	ctx.r[29].s64 = ctx.r[28].s64 + 12;
	// 826116BC: 83DC0010  lwz r30, 0x10(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 826116C0: 815C0014  lwz r10, 0x14(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 826116C4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 826116C8: 40990008  ble cr6, 0x826116d0
	if !ctx.cr[6].gt {
	pc = 0x826116D0; continue 'dispatch;
	}
	// 826116CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826116D0; continue 'dispatch;
            }
            0x826116D0 => {
    //   block [0x826116D0..0x826116D4)
	// 826116D0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x826116D4; continue 'dispatch;
            }
            0x826116D4 => {
    //   block [0x826116D4..0x826116E8)
	// 826116D4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 826116D8: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 826116DC: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826116E0: 40990008  ble cr6, 0x826116e8
	if !ctx.cr[6].gt {
	pc = 0x826116E8; continue 'dispatch;
	}
	// 826116E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826116E8; continue 'dispatch;
            }
            0x826116E8 => {
    //   block [0x826116E8..0x826116F4)
	// 826116E8: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 826116EC: 419A0008  beq cr6, 0x826116f4
	if ctx.cr[6].eq {
	pc = 0x826116F4; continue 'dispatch;
	}
	// 826116F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826116F4; continue 'dispatch;
            }
            0x826116F4 => {
    //   block [0x826116F4..0x82611708)
	// 826116F4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826116F8: 419A0080  beq cr6, 0x82611778
	if ctx.cr[6].eq {
	pc = 0x82611778; continue 'dispatch;
	}
	// 826116FC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82611700: 41980008  blt cr6, 0x82611708
	if ctx.cr[6].lt {
	pc = 0x82611708; continue 'dispatch;
	}
	// 82611704: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611708; continue 'dispatch;
            }
            0x82611708 => {
    //   block [0x82611708..0x82611720)
	// 82611708: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261170C: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611714: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82611718: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8261171C: 419A0020  beq cr6, 0x8261173c
	if ctx.cr[6].eq {
	pc = 0x8261173C; continue 'dispatch;
	}
	pc = 0x82611720; continue 'dispatch;
            }
            0x82611720 => {
    //   block [0x82611720..0x8261173C)
	// 82611720: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82611724: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82611728: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8261172C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82611730: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82611734: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82611738: 4082FFE8  bne 0x82611720
	if !ctx.cr[0].eq {
	pc = 0x82611720; continue 'dispatch;
	}
	pc = 0x8261173C; continue 'dispatch;
            }
            0x8261173C => {
    //   block [0x8261173C..0x82611758)
	// 8261173C: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82611740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611744: 419A0014  beq cr6, 0x82611758
	if ctx.cr[6].eq {
	pc = 0x82611758; continue 'dispatch;
	}
	// 82611748: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261174C: 387C002C  addi r3, r28, 0x2c
	ctx.r[3].s64 = ctx.r[28].s64 + 44;
	// 82611750: 4BFFE5A9  bl 0x8260fcf8
	ctx.lr = 0x82611754;
	sub_8260FCF8(ctx, base);
	// 82611754: 9B7F0034  stb r27, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[27].u8 ) };
	pc = 0x82611758; continue 'dispatch;
            }
            0x82611758 => {
    //   block [0x82611758..0x82611770)
	// 82611758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261175C: 4BBA63BD  bl 0x821b7b18
	ctx.lr = 0x82611760;
	sub_821B7B18(ctx, base);
	// 82611760: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82611764: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82611768: 41980008  blt cr6, 0x82611770
	if ctx.cr[6].lt {
	pc = 0x82611770; continue 'dispatch;
	}
	// 8261176C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611770; continue 'dispatch;
            }
            0x82611770 => {
    //   block [0x82611770..0x82611778)
	// 82611770: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82611774: 4BFFFF60  b 0x826116d4
	pc = 0x826116D4; continue 'dispatch;
            }
            0x82611778 => {
    //   block [0x82611778..0x82611788)
	// 82611778: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8261177C: 917C004C  stw r11, 0x4c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82611780: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82611784: 48697CD0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82611788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82611788 size=52
    let mut pc: u32 = 0x82611788;
    'dispatch: loop {
        match pc {
            0x82611788 => {
    //   block [0x82611788..0x826117BC)
	// 82611788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261178C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82611790: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82611794: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82611798: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261179C: 4800005D  bl 0x826117f8
	ctx.lr = 0x826117A0;
	sub_826117F8(ctx, base);
	// 826117A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826117A4: 4BFFFE2D  bl 0x826115d0
	ctx.lr = 0x826117A8;
	sub_826115D0(ctx, base);
	// 826117A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826117AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826117B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826117B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826117B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826117C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826117C0 size=52
    let mut pc: u32 = 0x826117C0;
    'dispatch: loop {
        match pc {
            0x826117C0 => {
    //   block [0x826117C0..0x826117F4)
	// 826117C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826117C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826117C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826117CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826117D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826117D4: 4BFFFED5  bl 0x826116a8
	ctx.lr = 0x826117D8;
	sub_826116A8(ctx, base);
	// 826117D8: 387F002C  addi r3, r31, 0x2c
	ctx.r[3].s64 = ctx.r[31].s64 + 44;
	// 826117DC: 4BFFE125  bl 0x8260f900
	ctx.lr = 0x826117E0;
	sub_8260F900(ctx, base);
	// 826117E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826117E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826117E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826117EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826117F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826117F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826117F8 size=508
    let mut pc: u32 = 0x826117F8;
    'dispatch: loop {
        match pc {
            0x826117F8 => {
    //   block [0x826117F8..0x82611884)
	// 826117F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826117FC: 48697C0D  bl 0x82ca9408
	ctx.lr = 0x82611800;
	sub_82CA93D0(ctx, base);
	// 82611800: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82611804: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82611808: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261180C: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82611810: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611814: 812A005C  lwz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 82611818: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8261181C: 4E800421  bctrl
	ctx.lr = 0x82611820;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82611820: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82611824: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82611828: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8261182C: 419A01C0  beq cr6, 0x826119ec
	if ctx.cr[6].eq {
	pc = 0x826119EC; continue 'dispatch;
	}
	// 82611830: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82611834: 4810B1BD  bl 0x8271c9f0
	ctx.lr = 0x82611838;
	sub_8271C9F0(ctx, base);
	// 82611838: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261183C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611840: 419A01AC  beq cr6, 0x826119ec
	if ctx.cr[6].eq {
	pc = 0x826119EC; continue 'dispatch;
	}
	// 82611844: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611848: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 8261184C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82611850: 5549D7FE  rlwinm r9, r10, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82611854: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82611858: 419A00E8  beq cr6, 0x82611940
	if ctx.cr[6].eq {
	pc = 0x82611940; continue 'dispatch;
	}
	// 8261185C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82611860: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82611864: 419A0020  beq cr6, 0x82611884
	if ctx.cr[6].eq {
	pc = 0x82611884; continue 'dispatch;
	}
	// 82611868: 894A0006  lbz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 8261186C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82611870: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82611874: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82611878: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261187C: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611880: 480000C4  b 0x82611944
	pc = 0x82611944; continue 'dispatch;
            }
            0x82611884 => {
    //   block [0x82611884..0x826118A0)
	// 82611884: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82611888: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261188C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82611890: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82611894: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82611898: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261189C: 40810054  ble 0x826118f0
	if !ctx.cr[0].gt {
	pc = 0x826118F0; continue 'dispatch;
	}
	pc = 0x826118A0; continue 'dispatch;
            }
            0x826118A0 => {
    //   block [0x826118A0..0x826118C0)
	// 826118A0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 826118A4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 826118A8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 826118AC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 826118B0: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 826118B4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826118B8: 41980008  blt cr6, 0x826118c0
	if ctx.cr[6].lt {
	pc = 0x826118C0; continue 'dispatch;
	}
	// 826118BC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x826118C0; continue 'dispatch;
            }
            0x826118C0 => {
    //   block [0x826118C0..0x826118DC)
	// 826118C0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 826118C4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 826118C8: 419A0014  beq cr6, 0x826118dc
	if ctx.cr[6].eq {
	pc = 0x826118DC; continue 'dispatch;
	}
	// 826118CC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 826118D0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826118D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 826118D8: 4800000C  b 0x826118e4
	pc = 0x826118E4; continue 'dispatch;
            }
            0x826118DC => {
    //   block [0x826118DC..0x826118E4)
	// 826118DC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 826118E0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x826118E4; continue 'dispatch;
            }
            0x826118E4 => {
    //   block [0x826118E4..0x826118F0)
	// 826118E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826118E8: 4199FFB8  bgt cr6, 0x826118a0
	if ctx.cr[6].gt {
	pc = 0x826118A0; continue 'dispatch;
	}
	// 826118EC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x826118F0; continue 'dispatch;
            }
            0x826118F0 => {
    //   block [0x826118F0..0x8261190C)
	// 826118F0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 826118F4: 419A003C  beq cr6, 0x82611930
	if ctx.cr[6].eq {
	pc = 0x82611930; continue 'dispatch;
	}
	// 826118F8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 826118FC: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82611900: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82611904: 41990008  bgt cr6, 0x8261190c
	if ctx.cr[6].gt {
	pc = 0x8261190C; continue 'dispatch;
	}
	// 82611908: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8261190C; continue 'dispatch;
            }
            0x8261190C => {
    //   block [0x8261190C..0x82611930)
	// 8261190C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82611910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611914: 409A001C  bne cr6, 0x82611930
	if !ctx.cr[6].eq {
	pc = 0x82611930; continue 'dispatch;
	}
	// 82611918: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8261191C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82611920: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82611924: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611928: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261192C: 48000018  b 0x82611944
	pc = 0x82611944; continue 'dispatch;
            }
            0x82611930 => {
    //   block [0x82611930..0x82611940)
	// 82611930: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82611934: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611938: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261193C: 48000008  b 0x82611944
	pc = 0x82611944; continue 'dispatch;
            }
            0x82611940 => {
    //   block [0x82611940..0x82611944)
	// 82611940: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82611944; continue 'dispatch;
            }
            0x82611944 => {
    //   block [0x82611944..0x8261197C)
	// 82611944: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82611948: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261194C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611950: 419A0088  beq cr6, 0x826119d8
	if ctx.cr[6].eq {
	pc = 0x826119D8; continue 'dispatch;
	}
	// 82611954: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82611958: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8261195C: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82611960: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82611964: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82611968: 409A0014  bne cr6, 0x8261197c
	if !ctx.cr[6].eq {
	pc = 0x8261197C; continue 'dispatch;
	}
	// 8261196C: 389F002C  addi r4, r31, 0x2c
	ctx.r[4].s64 = ctx.r[31].s64 + 44;
	// 82611970: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82611974: 4BF6D01D  bl 0x8257e990
	ctx.lr = 0x82611978;
	sub_8257E990(ctx, base);
	// 82611978: 48000044  b 0x826119bc
	pc = 0x826119BC; continue 'dispatch;
            }
            0x8261197C => {
    //   block [0x8261197C..0x826119B0)
	// 8261197C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82611980: 409A003C  bne cr6, 0x826119bc
	if !ctx.cr[6].eq {
	pc = 0x826119BC; continue 'dispatch;
	}
	// 82611984: 389F002C  addi r4, r31, 0x2c
	ctx.r[4].s64 = ctx.r[31].s64 + 44;
	// 82611988: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8261198C: 4BF6D005  bl 0x8257e990
	ctx.lr = 0x82611990;
	sub_8257E990(ctx, base);
	// 82611990: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82611994: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82611998: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 8261199C: 809F0094  lwz r4, 0x94(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 826119A0: 7D235050  subf r9, r3, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 826119A4: 7D095BD7  divw. r8, r9, r11
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 826119A8: 40820008  bne 0x826119b0
	if !ctx.cr[0].eq {
	pc = 0x826119B0; continue 'dispatch;
	}
	// 826119AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	pc = 0x826119B0; continue 'dispatch;
            }
            0x826119B0 => {
    //   block [0x826119B0..0x826119BC)
	// 826119B0: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 826119B4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826119B8: 48561AF9  bl 0x82b734b0
	ctx.lr = 0x826119BC;
	sub_82B734B0(ctx, base);
	pc = 0x826119BC; continue 'dispatch;
            }
            0x826119BC => {
    //   block [0x826119BC..0x826119D8)
	// 826119BC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826119C0: 80DF0094  lwz r6, 0x94(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 826119C4: 389C0040  addi r4, r28, 0x40
	ctx.r[4].s64 = ctx.r[28].s64 + 64;
	// 826119C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826119CC: 4BC7DDB5  bl 0x8228f780
	ctx.lr = 0x826119D0;
	sub_8228F780(ctx, base);
	// 826119D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826119D4: 4BFA858D  bl 0x825b9f60
	ctx.lr = 0x826119D8;
	sub_825B9F60(ctx, base);
	pc = 0x826119D8; continue 'dispatch;
            }
            0x826119D8 => {
    //   block [0x826119D8..0x826119EC)
	// 826119D8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 826119DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826119E0: 387C002C  addi r3, r28, 0x2c
	ctx.r[3].s64 = ctx.r[28].s64 + 44;
	// 826119E4: 38AB0080  addi r5, r11, 0x80
	ctx.r[5].s64 = ctx.r[11].s64 + 128;
	// 826119E8: 4BFFD919  bl 0x8260f300
	ctx.lr = 0x826119EC;
	sub_8260F300(ctx, base);
	pc = 0x826119EC; continue 'dispatch;
            }
            0x826119EC => {
    //   block [0x826119EC..0x826119F4)
	// 826119EC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826119F0: 48697A68  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826119F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826119F8 size=564
    let mut pc: u32 = 0x826119F8;
    'dispatch: loop {
        match pc {
            0x826119F8 => {
    //   block [0x826119F8..0x82611B04)
	// 826119F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826119FC: 486979FD  bl 0x82ca93f8
	ctx.lr = 0x82611A00;
	sub_82CA93D0(ctx, base);
	// 82611A00: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82611A04: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82611A08: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82611A0C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82611A10: 8178002C  lwz r11, 0x2c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(44 as u32) ) } as u64;
	// 82611A14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611A18: 419A020C  beq cr6, 0x82611c24
	if ctx.cr[6].eq {
	pc = 0x82611C24; continue 'dispatch;
	}
	// 82611A1C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82611A20: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82611A24: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 82611A28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82611A2C: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 82611A30: 48275F31  bl 0x82887960
	ctx.lr = 0x82611A34;
	sub_82887960(ctx, base);
	// 82611A34: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82611A38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611A3C: 419A01E0  beq cr6, 0x82611c1c
	if ctx.cr[6].eq {
	pc = 0x82611C1C; continue 'dispatch;
	}
	// 82611A40: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82611A44: 386BB678  addi r3, r11, -0x4988
	ctx.r[3].s64 = ctx.r[11].s64 + -18824;
	// 82611A48: 48743D09  bl 0x82d55750
	ctx.lr = 0x82611A4C;
	sub_82D55750(ctx, base);
	// 82611A4C: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82611A50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82611A54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82611A58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82611A5C: 4875FA7D  bl 0x82d714d8
	ctx.lr = 0x82611A60;
	sub_82D714D8(ctx, base);
	// 82611A60: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82611A64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82611A68: 3B8A79E4  addi r28, r10, 0x79e4
	ctx.r[28].s64 = ctx.r[10].s64 + 31204;
	// 82611A6C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82611A70: 48743CE1  bl 0x82d55750
	ctx.lr = 0x82611A74;
	sub_82D55750(ctx, base);
	// 82611A74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82611A78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82611A7C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82611A80: 4875FA59  bl 0x82d714d8
	ctx.lr = 0x82611A84;
	sub_82D714D8(ctx, base);
	// 82611A84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82611A88: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82611A8C: 48743CC5  bl 0x82d55750
	ctx.lr = 0x82611A90;
	sub_82D55750(ctx, base);
	// 82611A90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82611A94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82611A98: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82611A9C: 4875FA3D  bl 0x82d714d8
	ctx.lr = 0x82611AA0;
	sub_82D714D8(ctx, base);
	// 82611AA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82611AA4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82611AA8: 419A0174  beq cr6, 0x82611c1c
	if ctx.cr[6].eq {
	pc = 0x82611C1C; continue 'dispatch;
	}
	// 82611AAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82611AB0: 419A016C  beq cr6, 0x82611c1c
	if ctx.cr[6].eq {
	pc = 0x82611C1C; continue 'dispatch;
	}
	// 82611AB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82611AB8: 419A0164  beq cr6, 0x82611c1c
	if ctx.cr[6].eq {
	pc = 0x82611C1C; continue 'dispatch;
	}
	// 82611ABC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611AC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82611AC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82611AC8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82611ACC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82611AD0: 4E800421  bctrl
	ctx.lr = 0x82611AD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82611AD4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82611AD8: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 82611ADC: 4BC0D77D  bl 0x8221f258
	ctx.lr = 0x82611AE0;
	sub_8221F258(ctx, base);
	// 82611AE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82611AE4: 419A0020  beq cr6, 0x82611b04
	if ctx.cr[6].eq {
	pc = 0x82611B04; continue 'dispatch;
	}
	// 82611AE8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82611AEC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82611AF0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82611AF4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82611AF8: 4BFFD5C9  bl 0x8260f0c0
	ctx.lr = 0x82611AFC;
	sub_8260F0C0(ctx, base);
	// 82611AFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82611B00: 48000008  b 0x82611b08
	pc = 0x82611B08; continue 'dispatch;
            }
            0x82611B04 => {
    //   block [0x82611B04..0x82611B08)
	// 82611B04: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	pc = 0x82611B08; continue 'dispatch;
            }
            0x82611B08 => {
    //   block [0x82611B08..0x82611B44)
	// 82611B08: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82611B0C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82611B10: 419A0034  beq cr6, 0x82611b44
	if ctx.cr[6].eq {
	pc = 0x82611B44; continue 'dispatch;
	}
	// 82611B14: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82611B18: 4BC0D741  bl 0x8221f258
	ctx.lr = 0x82611B1C;
	sub_8221F258(ctx, base);
	// 82611B1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82611B20: 419A0024  beq cr6, 0x82611b44
	if ctx.cr[6].eq {
	pc = 0x82611B44; continue 'dispatch;
	}
	// 82611B24: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82611B28: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82611B2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82611B30: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82611B34: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82611B38: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82611B3C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82611B40: 48000008  b 0x82611b48
	pc = 0x82611B48; continue 'dispatch;
            }
            0x82611B44 => {
    //   block [0x82611B44..0x82611B48)
	// 82611B44: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	pc = 0x82611B48; continue 'dispatch;
            }
            0x82611B48 => {
    //   block [0x82611B48..0x82611B98)
	// 82611B48: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611B4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82611B50: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82611B54: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82611B58: 392A0B7C  addi r9, r10, 0xb7c
	ctx.r[9].s64 = ctx.r[10].s64 + 2940;
	// 82611B5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82611B60: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82611B64: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82611B68: 811B0004  lwz r8, 4(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611B6C: 911F0060  stw r8, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 82611B70: 4BC02D29  bl 0x82214898
	ctx.lr = 0x82611B74;
	sub_82214898(ctx, base);
	// 82611B74: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82611B78: 3BDF0064  addi r30, r31, 0x64
	ctx.r[30].s64 = ctx.r[31].s64 + 100;
	// 82611B7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611B80: 419A0020  beq cr6, 0x82611ba0
	if ctx.cr[6].eq {
	pc = 0x82611BA0; continue 'dispatch;
	}
	// 82611B84: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611B88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82611B8C: 419A000C  beq cr6, 0x82611b98
	if ctx.cr[6].eq {
	pc = 0x82611B98; continue 'dispatch;
	}
	// 82611B90: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82611B94: 48000010  b 0x82611ba4
	pc = 0x82611BA4; continue 'dispatch;
            }
            0x82611B98 => {
    //   block [0x82611B98..0x82611BA0)
	// 82611B98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82611B9C: 4BB8229D  bl 0x82193e38
	ctx.lr = 0x82611BA0;
	sub_82193E38(ctx, base);
	pc = 0x82611BA0; continue 'dispatch;
            }
            0x82611BA0 => {
    //   block [0x82611BA0..0x82611BA4)
	// 82611BA0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	pc = 0x82611BA4; continue 'dispatch;
            }
            0x82611BA4 => {
    //   block [0x82611BA4..0x82611C14)
	// 82611BA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82611BA8: 4BC02CF1  bl 0x82214898
	ctx.lr = 0x82611BAC;
	sub_82214898(ctx, base);
	// 82611BAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82611BB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82611BB4: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 82611BB8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82611BBC: 4BB8227D  bl 0x82193e38
	ctx.lr = 0x82611BC0;
	sub_82193E38(ctx, base);
	// 82611BC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82611BC4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82611BC8: 48000201  bl 0x82611dc8
	ctx.lr = 0x82611BCC;
	sub_82611DC8(ctx, base);
	// 82611BCC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82611BD0: 3878000C  addi r3, r24, 0xc
	ctx.r[3].s64 = ctx.r[24].s64 + 12;
	// 82611BD4: 4BCE3D75  bl 0x822f5948
	ctx.lr = 0x82611BD8;
	sub_822F5948(ctx, base);
	// 82611BD8: A13C0004  lhz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611BDC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82611BE0: 419A0034  beq cr6, 0x82611c14
	if ctx.cr[6].eq {
	pc = 0x82611C14; continue 'dispatch;
	}
	// 82611BE4: A17C0006  lhz r11, 6(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(6 as u32) ) } as u64;
	// 82611BE8: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82611BEC: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 82611BF0: B13C0006  sth r9, 6(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 82611BF4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82611BF8: 409A001C  bne cr6, 0x82611c14
	if !ctx.cr[6].eq {
	pc = 0x82611C14; continue 'dispatch;
	}
	// 82611BFC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611C00: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82611C04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82611C08: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611C0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82611C10: 4E800421  bctrl
	ctx.lr = 0x82611C14;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82611C14 => {
    //   block [0x82611C14..0x82611C1C)
	// 82611C14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82611C18: 4BBA5F01  bl 0x821b7b18
	ctx.lr = 0x82611C1C;
	sub_821B7B18(ctx, base);
	pc = 0x82611C1C; continue 'dispatch;
            }
            0x82611C1C => {
    //   block [0x82611C1C..0x82611C24)
	// 82611C1C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82611C20: 4BBA5EF9  bl 0x821b7b18
	ctx.lr = 0x82611C24;
	sub_821B7B18(ctx, base);
	pc = 0x82611C24; continue 'dispatch;
            }
            0x82611C24 => {
    //   block [0x82611C24..0x82611C2C)
	// 82611C24: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82611C28: 48697820  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82611C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82611C30 size=408
    let mut pc: u32 = 0x82611C30;
    'dispatch: loop {
        match pc {
            0x82611C30 => {
    //   block [0x82611C30..0x82611C5C)
	// 82611C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82611C34: 486977CD  bl 0x82ca9400
	ctx.lr = 0x82611C38;
	sub_82CA93D0(ctx, base);
	// 82611C38: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82611C3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82611C40: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82611C44: 3B5E000C  addi r26, r30, 0xc
	ctx.r[26].s64 = ctx.r[30].s64 + 12;
	// 82611C48: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82611C4C: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82611C50: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82611C54: 40990008  ble cr6, 0x82611c5c
	if !ctx.cr[6].gt {
	pc = 0x82611C5C; continue 'dispatch;
	}
	// 82611C58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611C5C; continue 'dispatch;
            }
            0x82611C5C => {
    //   block [0x82611C5C..0x82611C60)
	// 82611C5C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x82611C60; continue 'dispatch;
            }
            0x82611C60 => {
    //   block [0x82611C60..0x82611C74)
	// 82611C60: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82611C64: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611C68: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82611C6C: 40990008  ble cr6, 0x82611c74
	if !ctx.cr[6].gt {
	pc = 0x82611C74; continue 'dispatch;
	}
	// 82611C70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611C74; continue 'dispatch;
            }
            0x82611C74 => {
    //   block [0x82611C74..0x82611C80)
	// 82611C74: 7F1AD040  cmplw cr6, r26, r26
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82611C78: 419A0008  beq cr6, 0x82611c80
	if ctx.cr[6].eq {
	pc = 0x82611C80; continue 'dispatch;
	}
	// 82611C7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611C80; continue 'dispatch;
            }
            0x82611C80 => {
    //   block [0x82611C80..0x82611C94)
	// 82611C80: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82611C84: 419A013C  beq cr6, 0x82611dc0
	if ctx.cr[6].eq {
	pc = 0x82611DC0; continue 'dispatch;
	}
	// 82611C88: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82611C8C: 41980008  blt cr6, 0x82611c94
	if ctx.cr[6].lt {
	pc = 0x82611C94; continue 'dispatch;
	}
	// 82611C90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611C94; continue 'dispatch;
            }
            0x82611C94 => {
    //   block [0x82611C94..0x82611CAC)
	// 82611C94: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611C98: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611C9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611CA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82611CA4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82611CA8: 419A0020  beq cr6, 0x82611cc8
	if ctx.cr[6].eq {
	pc = 0x82611CC8; continue 'dispatch;
	}
	pc = 0x82611CAC; continue 'dispatch;
            }
            0x82611CAC => {
    //   block [0x82611CAC..0x82611CC8)
	// 82611CAC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82611CB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82611CB4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82611CB8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82611CBC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82611CC0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82611CC4: 4082FFE8  bne 0x82611cac
	if !ctx.cr[0].eq {
	pc = 0x82611CAC; continue 'dispatch;
	}
	pc = 0x82611CC8; continue 'dispatch;
            }
            0x82611CC8 => {
    //   block [0x82611CC8..0x82611CEC)
	// 82611CC8: 816A0068  lwz r11, 0x68(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(104 as u32) ) } as u64;
	// 82611CCC: 386A0064  addi r3, r10, 0x64
	ctx.r[3].s64 = ctx.r[10].s64 + 100;
	// 82611CD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611CD4: 419A001C  beq cr6, 0x82611cf0
	if ctx.cr[6].eq {
	pc = 0x82611CF0; continue 'dispatch;
	}
	// 82611CD8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611CDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82611CE0: 419A000C  beq cr6, 0x82611cec
	if ctx.cr[6].eq {
	pc = 0x82611CEC; continue 'dispatch;
	}
	// 82611CE4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82611CE8: 4800000C  b 0x82611cf4
	pc = 0x82611CF4; continue 'dispatch;
            }
            0x82611CEC => {
    //   block [0x82611CEC..0x82611CF0)
	// 82611CEC: 4BB8214D  bl 0x82193e38
	ctx.lr = 0x82611CF0;
	sub_82193E38(ctx, base);
	pc = 0x82611CF0; continue 'dispatch;
            }
            0x82611CF0 => {
    //   block [0x82611CF0..0x82611CF4)
	// 82611CF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82611CF4; continue 'dispatch;
            }
            0x82611CF4 => {
    //   block [0x82611CF4..0x82611D14)
	// 82611CF4: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82611CF8: 419A0024  beq cr6, 0x82611d1c
	if ctx.cr[6].eq {
	pc = 0x82611D1C; continue 'dispatch;
	}
	// 82611CFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82611D00: 4BBA5E19  bl 0x821b7b18
	ctx.lr = 0x82611D04;
	sub_821B7B18(ctx, base);
	// 82611D04: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82611D08: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82611D0C: 41980008  blt cr6, 0x82611d14
	if ctx.cr[6].lt {
	pc = 0x82611D14; continue 'dispatch;
	}
	// 82611D10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82611D14; continue 'dispatch;
            }
            0x82611D14 => {
    //   block [0x82611D14..0x82611D1C)
	// 82611D14: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82611D18: 4BFFFF48  b 0x82611c60
	pc = 0x82611C60; continue 'dispatch;
            }
            0x82611D1C => {
    //   block [0x82611D1C..0x82611D3C)
	// 82611D1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82611D20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82611D24: 48000265  bl 0x82611f88
	ctx.lr = 0x82611D28;
	sub_82611F88(ctx, base);
	// 82611D28: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82611D2C: 837A0008  lwz r27, 8(r26)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82611D30: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82611D34: 419A0054  beq cr6, 0x82611d88
	if ctx.cr[6].eq {
	pc = 0x82611D88; continue 'dispatch;
	}
	// 82611D38: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	pc = 0x82611D3C; continue 'dispatch;
            }
            0x82611D3C => {
    //   block [0x82611D3C..0x82611D78)
	// 82611D3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611D40: 3BBF0008  addi r29, r31, 8
	ctx.r[29].s64 = ctx.r[31].s64 + 8;
	// 82611D44: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82611D48: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611D4C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82611D50: 419A0028  beq cr6, 0x82611d78
	if ctx.cr[6].eq {
	pc = 0x82611D78; continue 'dispatch;
	}
	// 82611D54: 387FFFFC  addi r3, r31, -4
	ctx.r[3].s64 = ctx.r[31].s64 + -4;
	// 82611D58: 4BBA5DC1  bl 0x821b7b18
	ctx.lr = 0x82611D5C;
	sub_821B7B18(ctx, base);
	// 82611D5C: 939FFFFC  stw r28, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[28].u32 ) };
	// 82611D60: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82611D64: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82611D68: 419A0010  beq cr6, 0x82611d78
	if ctx.cr[6].eq {
	pc = 0x82611D78; continue 'dispatch;
	}
	// 82611D6C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611D70: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82611D74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82611D78; continue 'dispatch;
            }
            0x82611D78 => {
    //   block [0x82611D78..0x82611D88)
	// 82611D78: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82611D7C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82611D80: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82611D84: 409AFFB8  bne cr6, 0x82611d3c
	if !ctx.cr[6].eq {
	pc = 0x82611D3C; continue 'dispatch;
	}
	pc = 0x82611D88; continue 'dispatch;
            }
            0x82611D88 => {
    //   block [0x82611D88..0x82611D98)
	// 82611D88: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82611D8C: 3BFEFFF8  addi r31, r30, -8
	ctx.r[31].s64 = ctx.r[30].s64 + -8;
	// 82611D90: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82611D94: 419A0018  beq cr6, 0x82611dac
	if ctx.cr[6].eq {
	pc = 0x82611DAC; continue 'dispatch;
	}
	pc = 0x82611D98; continue 'dispatch;
            }
            0x82611D98 => {
    //   block [0x82611D98..0x82611DAC)
	// 82611D98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82611D9C: 4BBA5D7D  bl 0x821b7b18
	ctx.lr = 0x82611DA0;
	sub_821B7B18(ctx, base);
	// 82611DA0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82611DA4: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82611DA8: 409AFFF0  bne cr6, 0x82611d98
	if !ctx.cr[6].eq {
	pc = 0x82611D98; continue 'dispatch;
	}
	pc = 0x82611DAC; continue 'dispatch;
            }
            0x82611DAC => {
    //   block [0x82611DAC..0x82611DC0)
	// 82611DAC: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82611DB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82611DB4: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 82611DB8: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82611DBC: 4BBA5D5D  bl 0x821b7b18
	ctx.lr = 0x82611DC0;
	sub_821B7B18(ctx, base);
	pc = 0x82611DC0; continue 'dispatch;
            }
            0x82611DC0 => {
    //   block [0x82611DC0..0x82611DC8)
	// 82611DC0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82611DC4: 4869768C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82611DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82611DC8 size=444
    let mut pc: u32 = 0x82611DC8;
    'dispatch: loop {
        match pc {
            0x82611DC8 => {
    //   block [0x82611DC8..0x82611E34)
	// 82611DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82611DCC: 48697639  bl 0x82ca9404
	ctx.lr = 0x82611DD0;
	sub_82CA93D0(ctx, base);
	// 82611DD0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82611DD4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82611DD8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82611DDC: 897D0034  lbz r11, 0x34(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 82611DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611DE4: 409A0198  bne cr6, 0x82611f7c
	if !ctx.cr[6].eq {
	pc = 0x82611F7C; continue 'dispatch;
	}
	// 82611DE8: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 82611DEC: 3B7C002C  addi r27, r28, 0x2c
	ctx.r[27].s64 = ctx.r[28].s64 + 44;
	// 82611DF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611DF4: 419A0188  beq cr6, 0x82611f7c
	if ctx.cr[6].eq {
	pc = 0x82611F7C; continue 'dispatch;
	}
	// 82611DF8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611DFC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82611E00: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82611E04: 5549D7FE  rlwinm r9, r10, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82611E08: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82611E0C: 419A00D4  beq cr6, 0x82611ee0
	if ctx.cr[6].eq {
	pc = 0x82611EE0; continue 'dispatch;
	}
	// 82611E10: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82611E14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82611E18: 419A001C  beq cr6, 0x82611e34
	if ctx.cr[6].eq {
	pc = 0x82611E34; continue 'dispatch;
	}
	// 82611E1C: 894A0006  lbz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 82611E20: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82611E24: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82611E28: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82611E2C: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611E30: 480000B0  b 0x82611ee0
	pc = 0x82611EE0; continue 'dispatch;
            }
            0x82611E34 => {
    //   block [0x82611E34..0x82611E50)
	// 82611E34: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82611E38: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82611E3C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82611E40: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82611E44: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82611E48: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82611E4C: 40810054  ble 0x82611ea0
	if !ctx.cr[0].gt {
	pc = 0x82611EA0; continue 'dispatch;
	}
	pc = 0x82611E50; continue 'dispatch;
            }
            0x82611E50 => {
    //   block [0x82611E50..0x82611E70)
	// 82611E50: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82611E54: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82611E58: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82611E5C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611E60: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 82611E64: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82611E68: 41980008  blt cr6, 0x82611e70
	if ctx.cr[6].lt {
	pc = 0x82611E70; continue 'dispatch;
	}
	// 82611E6C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82611E70; continue 'dispatch;
            }
            0x82611E70 => {
    //   block [0x82611E70..0x82611E8C)
	// 82611E70: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82611E74: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82611E78: 419A0014  beq cr6, 0x82611e8c
	if ctx.cr[6].eq {
	pc = 0x82611E8C; continue 'dispatch;
	}
	// 82611E7C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82611E80: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82611E84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82611E88: 4800000C  b 0x82611e94
	pc = 0x82611E94; continue 'dispatch;
            }
            0x82611E8C => {
    //   block [0x82611E8C..0x82611E94)
	// 82611E8C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82611E90: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82611E94; continue 'dispatch;
            }
            0x82611E94 => {
    //   block [0x82611E94..0x82611EA0)
	// 82611E94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82611E98: 4199FFB8  bgt cr6, 0x82611e50
	if ctx.cr[6].gt {
	pc = 0x82611E50; continue 'dispatch;
	}
	// 82611E9C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82611EA0; continue 'dispatch;
            }
            0x82611EA0 => {
    //   block [0x82611EA0..0x82611EBC)
	// 82611EA0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82611EA4: 419A0034  beq cr6, 0x82611ed8
	if ctx.cr[6].eq {
	pc = 0x82611ED8; continue 'dispatch;
	}
	// 82611EA8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611EAC: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82611EB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82611EB4: 41990008  bgt cr6, 0x82611ebc
	if ctx.cr[6].gt {
	pc = 0x82611EBC; continue 'dispatch;
	}
	// 82611EB8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82611EBC; continue 'dispatch;
            }
            0x82611EBC => {
    //   block [0x82611EBC..0x82611ED8)
	// 82611EBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82611EC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611EC4: 409A0014  bne cr6, 0x82611ed8
	if !ctx.cr[6].eq {
	pc = 0x82611ED8; continue 'dispatch;
	}
	// 82611EC8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82611ECC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82611ED0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82611ED4: 48000008  b 0x82611edc
	pc = 0x82611EDC; continue 'dispatch;
            }
            0x82611ED8 => {
    //   block [0x82611ED8..0x82611EDC)
	// 82611ED8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x82611EDC; continue 'dispatch;
            }
            0x82611EDC => {
    //   block [0x82611EDC..0x82611EE0)
	// 82611EDC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82611EE0; continue 'dispatch;
            }
            0x82611EE0 => {
    //   block [0x82611EE0..0x82611F54)
	// 82611EE0: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82611EE4: 807D0024  lwz r3, 0x24(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 82611EE8: 809F0094  lwz r4, 0x94(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82611EEC: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82611EF0: 482B66F1  bl 0x828c85e0
	ctx.lr = 0x82611EF4;
	sub_828C85E0(ctx, base);
	// 82611EF4: F87D0028  std r3, 0x28(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[3].u64 ) };
	// 82611EF8: 83DF0098  lwz r30, 0x98(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82611EFC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82611F00: 419A0054  beq cr6, 0x82611f54
	if ctx.cr[6].eq {
	pc = 0x82611F54; continue 'dispatch;
	}
	// 82611F04: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82611F08: 83FF0094  lwz r31, 0x94(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82611F0C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82611F10: 388B0840  addi r4, r11, 0x840
	ctx.r[4].s64 = ctx.r[11].s64 + 2112;
	// 82611F14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82611F18: 4BC1AFB9  bl 0x8222ced0
	ctx.lr = 0x82611F1C;
	sub_8222CED0(ctx, base);
	// 82611F1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82611F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82611F24: 4BBA35E5  bl 0x821b5508
	ctx.lr = 0x82611F28;
	sub_821B5508(ctx, base);
	// 82611F28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82611F2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82611F30: 4BC02EA9  bl 0x82214dd8
	ctx.lr = 0x82611F34;
	sub_82214DD8(ctx, base);
	// 82611F34: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82611F38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82611F3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82611F40: 48569FD1  bl 0x82b7bf10
	ctx.lr = 0x82611F44;
	sub_82B7BF10(ctx, base);
	// 82611F44: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82611F48: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	pc = 0x82611F54; continue 'dispatch;
            }
            0x82611F54 => {
    //   block [0x82611F54..0x82611F7C)
	// 82611F54: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82611F58: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82611F5C: 4BFFDC65  bl 0x8260fbc0
	ctx.lr = 0x82611F60;
	sub_8260FBC0(ctx, base);
	// 82611F60: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 82611F64: 815C004C  lwz r10, 0x4c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 82611F68: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82611F6C: 40990008  ble cr6, 0x82611f74
	if !ctx.cr[6].gt {
	pc = 0x82611F74; continue 'dispatch;
	}
	// 82611F70: 917C004C  stw r11, 0x4c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82611F74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82611F78: 997D0034  stb r11, 0x34(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	pc = 0x82611F7C; continue 'dispatch;
            }
            0x82611F7C => {
    //   block [0x82611F7C..0x82611F84)
	// 82611F7C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82611F80: 486974D4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82611F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82611F88 size=304
    let mut pc: u32 = 0x82611F88;
    'dispatch: loop {
        match pc {
            0x82611F88 => {
    //   block [0x82611F88..0x82611FBC)
	// 82611F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82611F8C: 48697481  bl 0x82ca940c
	ctx.lr = 0x82611F90;
	sub_82CA93D0(ctx, base);
	// 82611F90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82611F94: 83E40000  lwz r31, 0(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611F98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82611F9C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82611FA0: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82611FA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611FA8: 419A0014  beq cr6, 0x82611fbc
	if ctx.cr[6].eq {
	pc = 0x82611FBC; continue 'dispatch;
	}
	// 82611FAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82611FB0: 387D002C  addi r3, r29, 0x2c
	ctx.r[3].s64 = ctx.r[29].s64 + 44;
	// 82611FB4: 4BFFDD45  bl 0x8260fcf8
	ctx.lr = 0x82611FB8;
	sub_8260FCF8(ctx, base);
	// 82611FB8: 9BDF0034  stb r30, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u8 ) };
	pc = 0x82611FBC; continue 'dispatch;
            }
            0x82611FBC => {
    //   block [0x82611FBC..0x82611FF8)
	// 82611FBC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82611FC0: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82611FC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82611FC8: 419A0030  beq cr6, 0x82611ff8
	if ctx.cr[6].eq {
	pc = 0x82611FF8; continue 'dispatch;
	}
	// 82611FCC: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 82611FD0: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82611FD4: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 82611FD8: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 82611FDC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82611FE0: 409A0018  bne cr6, 0x82611ff8
	if !ctx.cr[6].eq {
	pc = 0x82611FF8; continue 'dispatch;
	}
	// 82611FE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611FE8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82611FEC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82611FF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82611FF4: 4E800421  bctrl
	ctx.lr = 0x82611FF8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82611FF8 => {
    //   block [0x82611FF8..0x8261201C)
	// 82611FF8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82611FFC: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82612000: 393D000C  addi r9, r29, 0xc
	ctx.r[9].s64 = ctx.r[29].s64 + 12;
	// 82612004: 917D004C  stw r11, 0x4c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82612008: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 8261200C: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82612010: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82612014: 40990008  ble cr6, 0x8261201c
	if !ctx.cr[6].gt {
	pc = 0x8261201C; continue 'dispatch;
	}
	// 82612018: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261201C; continue 'dispatch;
            }
            0x8261201C => {
    //   block [0x8261201C..0x82612034)
	// 8261201C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82612020: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82612024: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82612028: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8261202C: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82612030: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82612034; continue 'dispatch;
            }
            0x82612034 => {
    //   block [0x82612034..0x82612048)
	// 82612034: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82612038: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261203C: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82612040: 40990008  ble cr6, 0x82612048
	if !ctx.cr[6].gt {
	pc = 0x82612048; continue 'dispatch;
	}
	// 82612044: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612048; continue 'dispatch;
            }
            0x82612048 => {
    //   block [0x82612048..0x82612058)
	// 82612048: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8261204C: 419A000C  beq cr6, 0x82612058
	if ctx.cr[6].eq {
	pc = 0x82612058; continue 'dispatch;
	}
	// 82612050: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82612054: 419A0008  beq cr6, 0x8261205c
	if ctx.cr[6].eq {
	pc = 0x8261205C; continue 'dispatch;
	}
	pc = 0x82612058; continue 'dispatch;
            }
            0x82612058 => {
    //   block [0x82612058..0x8261205C)
	// 82612058: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261205C; continue 'dispatch;
            }
            0x8261205C => {
    //   block [0x8261205C..0x82612070)
	// 8261205C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82612060: 419A0050  beq cr6, 0x826120b0
	if ctx.cr[6].eq {
	pc = 0x826120B0; continue 'dispatch;
	}
	// 82612064: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82612068: 409A0008  bne cr6, 0x82612070
	if !ctx.cr[6].eq {
	pc = 0x82612070; continue 'dispatch;
	}
	// 8261206C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612070; continue 'dispatch;
            }
            0x82612070 => {
    //   block [0x82612070..0x82612080)
	// 82612070: 81680008  lwz r11, 8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82612074: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82612078: 41980008  blt cr6, 0x82612080
	if ctx.cr[6].lt {
	pc = 0x82612080; continue 'dispatch;
	}
	// 8261207C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612080; continue 'dispatch;
            }
            0x82612080 => {
    //   block [0x82612080..0x82612098)
	// 82612080: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82612084: 80FD004C  lwz r7, 0x4c(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 82612088: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261208C: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82612090: 40990008  ble cr6, 0x82612098
	if !ctx.cr[6].gt {
	pc = 0x82612098; continue 'dispatch;
	}
	// 82612094: 917D004C  stw r11, 0x4c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	pc = 0x82612098; continue 'dispatch;
            }
            0x82612098 => {
    //   block [0x82612098..0x826120A8)
	// 82612098: 81680008  lwz r11, 8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261209C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826120A0: 41980008  blt cr6, 0x826120a8
	if ctx.cr[6].lt {
	pc = 0x826120A8; continue 'dispatch;
	}
	// 826120A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826120A8; continue 'dispatch;
            }
            0x826120A8 => {
    //   block [0x826120A8..0x826120B0)
	// 826120A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826120AC: 4BFFFF88  b 0x82612034
	pc = 0x82612034; continue 'dispatch;
            }
            0x826120B0 => {
    //   block [0x826120B0..0x826120B8)
	// 826120B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826120B4: 486973A8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826120B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826120B8 size=64
    let mut pc: u32 = 0x826120B8;
    'dispatch: loop {
        match pc {
            0x826120B8 => {
    //   block [0x826120B8..0x826120E4)
	// 826120B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826120BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826120C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826120C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826120C8: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 826120CC: 3BE3002C  addi r31, r3, 0x2c
	ctx.r[31].s64 = ctx.r[3].s64 + 44;
	// 826120D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826120D4: 419A0010  beq cr6, 0x826120e4
	if ctx.cr[6].eq {
	pc = 0x826120E4; continue 'dispatch;
	}
	// 826120D8: 4BFFF5D1  bl 0x826116a8
	ctx.lr = 0x826120DC;
	sub_826116A8(ctx, base);
	// 826120DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826120E0: 4BFFD821  bl 0x8260f900
	ctx.lr = 0x826120E4;
	sub_8260F900(ctx, base);
	pc = 0x826120E4; continue 'dispatch;
            }
            0x826120E4 => {
    //   block [0x826120E4..0x826120F8)
	// 826120E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826120E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826120EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826120F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826120F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826120F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826120F8 size=112
    let mut pc: u32 = 0x826120F8;
    'dispatch: loop {
        match pc {
            0x826120F8 => {
    //   block [0x826120F8..0x82612150)
	// 826120F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826120FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82612100: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82612104: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82612108: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261210C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82612110: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82612114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82612118: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261211C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612120: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82612124: 4E800421  bctrl
	ctx.lr = 0x82612128;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82612128: 2F03000A  cmpwi cr6, r3, 0xa
	ctx.cr[6].compare_i32(ctx.r[3].s32, 10, &mut ctx.xer);
	// 8261212C: 409A0024  bne cr6, 0x82612150
	if !ctx.cr[6].eq {
	pc = 0x82612150; continue 'dispatch;
	}
	// 82612130: 897F0004  lbz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612138: 419A0018  beq cr6, 0x82612150
	if ctx.cr[6].eq {
	pc = 0x82612150; continue 'dispatch;
	}
	// 8261213C: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82612140: 387E002C  addi r3, r30, 0x2c
	ctx.r[3].s64 = ctx.r[30].s64 + 44;
	// 82612144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612148: 419A0008  beq cr6, 0x82612150
	if ctx.cr[6].eq {
	pc = 0x82612150; continue 'dispatch;
	}
	// 8261214C: 4BFFDD45  bl 0x8260fe90
	ctx.lr = 0x82612150;
	sub_8260FE90(ctx, base);
            }
            0x82612150 => {
    //   block [0x82612150..0x82612168)
	// 82612150: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82612154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82612158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261215C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82612160: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82612164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82612168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82612168 size=128
    let mut pc: u32 = 0x82612168;
    'dispatch: loop {
        match pc {
            0x82612168 => {
    //   block [0x82612168..0x826121C8)
	// 82612168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261216C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82612170: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82612174: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82612178: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261217C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82612180: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82612184: 4BBA5995  bl 0x821b7b18
	ctx.lr = 0x82612188;
	sub_821B7B18(ctx, base);
	// 82612188: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8261218C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82612190: 419A0040  beq cr6, 0x826121d0
	if ctx.cr[6].eq {
	pc = 0x826121D0; continue 'dispatch;
	}
	// 82612194: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82612198: 4BC0D0C1  bl 0x8221f258
	ctx.lr = 0x8261219C;
	sub_8221F258(ctx, base);
	// 8261219C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826121A0: 419A0028  beq cr6, 0x826121c8
	if ctx.cr[6].eq {
	pc = 0x826121C8; continue 'dispatch;
	}
	// 826121A4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826121A8: 3D208261  lis r9, -0x7d9f
	ctx.r[9].s64 = -2107572224;
	// 826121AC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826121B0: 38E93070  addi r7, r9, 0x3070
	ctx.r[7].s64 = ctx.r[9].s64 + 12400;
	// 826121B4: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 826121B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826121BC: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 826121C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826121C4: 48000008  b 0x826121cc
	pc = 0x826121CC; continue 'dispatch;
            }
            0x826121C8 => {
    //   block [0x826121C8..0x826121CC)
	// 826121C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x826121CC; continue 'dispatch;
            }
            0x826121CC => {
    //   block [0x826121CC..0x826121D0)
	// 826121CC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x826121D0; continue 'dispatch;
            }
            0x826121D0 => {
    //   block [0x826121D0..0x826121E8)
	// 826121D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826121D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826121D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826121DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826121E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826121E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826121E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826121E8 size=292
    let mut pc: u32 = 0x826121E8;
    'dispatch: loop {
        match pc {
            0x826121E8 => {
    //   block [0x826121E8..0x82612214)
	// 826121E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826121EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826121F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826121F4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826121F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826121FC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612200: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612204: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82612208: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261220C: 409A0030  bne cr6, 0x8261223c
	if !ctx.cr[6].eq {
	pc = 0x8261223C; continue 'dispatch;
	}
	// 82612210: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82612214; continue 'dispatch;
            }
            0x82612214 => {
    //   block [0x82612214..0x82612228)
	// 82612214: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82612218: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8261221C: 4098000C  bge cr6, 0x82612228
	if !ctx.cr[6].lt {
	pc = 0x82612228; continue 'dispatch;
	}
	// 82612220: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82612224: 4800000C  b 0x82612230
	pc = 0x82612230; continue 'dispatch;
            }
            0x82612228 => {
    //   block [0x82612228..0x82612230)
	// 82612228: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8261222C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82612230; continue 'dispatch;
            }
            0x82612230 => {
    //   block [0x82612230..0x8261223C)
	// 82612230: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82612234: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82612238: 419AFFDC  beq cr6, 0x82612214
	if ctx.cr[6].eq {
	pc = 0x82612214; continue 'dispatch;
	}
	pc = 0x8261223C; continue 'dispatch;
            }
            0x8261223C => {
    //   block [0x8261223C..0x82612268)
	// 8261223C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612240: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82612244: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82612248: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8261224C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82612250: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82612254: 419A0014  beq cr6, 0x82612268
	if ctx.cr[6].eq {
	pc = 0x82612268; continue 'dispatch;
	}
	// 82612258: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261225C: 80EA000C  lwz r7, 0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82612260: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82612264: 40980074  bge cr6, 0x826122d8
	if !ctx.cr[6].lt {
	pc = 0x826122D8; continue 'dispatch;
	}
	pc = 0x82612268; continue 'dispatch;
            }
            0x82612268 => {
    //   block [0x82612268..0x826122D8)
	// 82612268: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261226C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82612270: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82612274: 390A0B7C  addi r8, r10, 0xb7c
	ctx.r[8].s64 = ctx.r[10].s64 + 2940;
	// 82612278: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 8261227C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82612280: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82612284: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82612288: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8261228C: 4BB84AE5  bl 0x82196d70
	ctx.lr = 0x82612290;
	sub_82196D70(ctx, base);
	// 82612290: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82612294: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82612298: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8261229C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826122A0: 48000509  bl 0x826127a8
	ctx.lr = 0x826122A4;
	sub_826127A8(ctx, base);
	// 826122A4: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 826122A8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826122AC: 3BE70B7C  addi r31, r7, 0xb7c
	ctx.r[31].s64 = ctx.r[7].s64 + 2940;
	// 826122B0: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 826122B4: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 826122B8: E8A60000  ld r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 826122BC: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 826122C0: 4BB81B79  bl 0x82193e38
	ctx.lr = 0x826122C4;
	sub_82193E38(ctx, base);
	// 826122C4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 826122C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826122CC: 4BB81B6D  bl 0x82193e38
	ctx.lr = 0x826122D0;
	sub_82193E38(ctx, base);
	// 826122D0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826122D4: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x826122D8; continue 'dispatch;
            }
            0x826122D8 => {
    //   block [0x826122D8..0x826122E4)
	// 826122D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 826122DC: 409A0008  bne cr6, 0x826122e4
	if !ctx.cr[6].eq {
	pc = 0x826122E4; continue 'dispatch;
	}
	// 826122E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826122E4; continue 'dispatch;
            }
            0x826122E4 => {
    //   block [0x826122E4..0x826122F4)
	// 826122E4: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 826122E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 826122EC: 409A0008  bne cr6, 0x826122f4
	if !ctx.cr[6].eq {
	pc = 0x826122F4; continue 'dispatch;
	}
	// 826122F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826122F4; continue 'dispatch;
            }
            0x826122F4 => {
    //   block [0x826122F4..0x8261230C)
	// 826122F4: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 826122F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826122FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82612300: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82612304: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82612308: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82612310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82612310 size=260
    let mut pc: u32 = 0x82612310;
    'dispatch: loop {
        match pc {
            0x82612310 => {
    //   block [0x82612310..0x82612338)
	// 82612310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82612314: 486970F5  bl 0x82ca9408
	ctx.lr = 0x82612318;
	sub_82CA93D0(ctx, base);
	// 82612318: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261231C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82612320: 839D0004  lwz r28, 4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612324: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612328: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 8261232C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82612330: 409A0030  bne cr6, 0x82612360
	if !ctx.cr[6].eq {
	pc = 0x82612360; continue 'dispatch;
	}
	// 82612334: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82612338; continue 'dispatch;
            }
            0x82612338 => {
    //   block [0x82612338..0x82612350)
	// 82612338: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261233C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82612340: 40980010  bge cr6, 0x82612350
	if !ctx.cr[6].lt {
	pc = 0x82612350; continue 'dispatch;
	}
	// 82612344: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 82612348: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261234C: 48000008  b 0x82612354
	pc = 0x82612354; continue 'dispatch;
            }
            0x82612350 => {
    //   block [0x82612350..0x82612354)
	// 82612350: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82612354; continue 'dispatch;
            }
            0x82612354 => {
    //   block [0x82612354..0x82612360)
	// 82612354: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82612358: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261235C: 419AFFDC  beq cr6, 0x82612338
	if ctx.cr[6].eq {
	pc = 0x82612338; continue 'dispatch;
	}
	pc = 0x82612360; continue 'dispatch;
            }
            0x82612360 => {
    //   block [0x82612360..0x82612384)
	// 82612360: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612364: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82612368: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8261236C: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82612370: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612374: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82612378: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261237C: 409A0030  bne cr6, 0x826123ac
	if !ctx.cr[6].eq {
	pc = 0x826123AC; continue 'dispatch;
	}
	// 82612380: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82612384; continue 'dispatch;
            }
            0x82612384 => {
    //   block [0x82612384..0x82612398)
	// 82612384: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82612388: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8261238C: 4098000C  bge cr6, 0x82612398
	if !ctx.cr[6].lt {
	pc = 0x82612398; continue 'dispatch;
	}
	// 82612390: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82612394: 4800000C  b 0x826123a0
	pc = 0x826123A0; continue 'dispatch;
            }
            0x82612398 => {
    //   block [0x82612398..0x826123A0)
	// 82612398: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8261239C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x826123A0; continue 'dispatch;
            }
            0x826123A0 => {
    //   block [0x826123A0..0x826123AC)
	// 826123A0: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 826123A4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 826123A8: 419AFFDC  beq cr6, 0x82612384
	if ctx.cr[6].eq {
	pc = 0x82612384; continue 'dispatch;
	}
	pc = 0x826123AC; continue 'dispatch;
            }
            0x826123AC => {
    //   block [0x826123AC..0x826123C0)
	// 826123AC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 826123B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826123B4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 826123B8: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 826123BC: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	pc = 0x826123C0; continue 'dispatch;
            }
            0x826123C0 => {
    //   block [0x826123C0..0x826123D4)
	// 826123C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826123C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826123C8: 419A000C  beq cr6, 0x826123d4
	if ctx.cr[6].eq {
	pc = 0x826123D4; continue 'dispatch;
	}
	// 826123CC: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 826123D0: 419A0008  beq cr6, 0x826123d8
	if ctx.cr[6].eq {
	pc = 0x826123D8; continue 'dispatch;
	}
	pc = 0x826123D4; continue 'dispatch;
            }
            0x826123D4 => {
    //   block [0x826123D4..0x826123D8)
	// 826123D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826123D8; continue 'dispatch;
            }
            0x826123D8 => {
    //   block [0x826123D8..0x826123F4)
	// 826123D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826123DC: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 826123E0: 419A0014  beq cr6, 0x826123f4
	if ctx.cr[6].eq {
	pc = 0x826123F4; continue 'dispatch;
	}
	// 826123E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826123E8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 826123EC: 4BE2AA05  bl 0x8243cdf0
	ctx.lr = 0x826123F0;
	sub_8243CDF0(ctx, base);
	// 826123F0: 4BFFFFD0  b 0x826123c0
	pc = 0x826123C0; continue 'dispatch;
            }
            0x826123F4 => {
    //   block [0x826123F4..0x82612414)
	// 826123F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826123F8: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 826123FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82612400: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82612404: 480005C5  bl 0x826129c8
	ctx.lr = 0x82612408;
	sub_826129C8(ctx, base);
	// 82612408: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261240C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82612410: 48697048  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82612418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82612418 size=288
    let mut pc: u32 = 0x82612418;
    'dispatch: loop {
        match pc {
            0x82612418 => {
    //   block [0x82612418..0x82612454)
	// 82612418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261241C: 48696FF1  bl 0x82ca940c
	ctx.lr = 0x82612420;
	sub_82CA93D0(ctx, base);
	// 82612420: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82612424: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82612428: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8261242C: 3BCB8BF4  addi r30, r11, -0x740c
	ctx.r[30].s64 = ctx.r[11].s64 + -29708;
	// 82612430: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82612434: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82612438: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8261243C: 48000AED  bl 0x82612f28
	ctx.lr = 0x82612440;
	sub_82612F28(ctx, base);
	// 82612440: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82612444: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82612448: 419A000C  beq cr6, 0x82612454
	if ctx.cr[6].eq {
	pc = 0x82612454; continue 'dispatch;
	}
	// 8261244C: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82612450: 419A0008  beq cr6, 0x82612458
	if ctx.cr[6].eq {
	pc = 0x82612458; continue 'dispatch;
	}
	pc = 0x82612454; continue 'dispatch;
            }
            0x82612454 => {
    //   block [0x82612454..0x82612458)
	// 82612454: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612458; continue 'dispatch;
            }
            0x82612458 => {
    //   block [0x82612458..0x82612484)
	// 82612458: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261245C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82612460: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82612464: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82612468: 419A0028  beq cr6, 0x82612490
	if ctx.cr[6].eq {
	pc = 0x82612490; continue 'dispatch;
	}
	// 8261246C: E97D0000  ld r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 82612470: E90A0010  ld r8, 0x10(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	// 82612474: 7F2B4040  cmpld cr6, r11, r8
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[8].u64, &mut ctx.xer);
	// 82612478: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261247C: 41980008  blt cr6, 0x82612484
	if ctx.cr[6].lt {
	pc = 0x82612484; continue 'dispatch;
	}
	// 82612480: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82612484; continue 'dispatch;
            }
            0x82612484 => {
    //   block [0x82612484..0x82612490)
	// 82612484: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82612488: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261248C: 419A0084  beq cr6, 0x82612510
	if ctx.cr[6].eq {
	pc = 0x82612510; continue 'dispatch;
	}
	pc = 0x82612490; continue 'dispatch;
            }
            0x82612490 => {
    //   block [0x82612490..0x82612510)
	// 82612490: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82612494: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82612498: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8261249C: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 826124A0: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 826124A4: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 826124A8: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 826124AC: 48405A75  bl 0x82a17f20
	ctx.lr = 0x826124B0;
	sub_82A17F20(ctx, base);
	// 826124B0: E97D0000  ld r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 826124B4: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 826124B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826124BC: 93E1008C  stw r31, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 826124C0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826124C4: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 826124C8: 93E10098  stw r31, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[31].u32 ) };
	// 826124CC: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 826124D0: F96100B0  std r11, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u64 ) };
	// 826124D4: 48000ABD  bl 0x82612f90
	ctx.lr = 0x826124D8;
	sub_82612F90(ctx, base);
	// 826124D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826124DC: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 826124E0: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 826124E4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826124E8: 48000659  bl 0x82612b40
	ctx.lr = 0x826124EC;
	sub_82612B40(ctx, base);
	// 826124EC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 826124F0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826124F4: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 826124F8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 826124FC: 4800023D  bl 0x82612738
	ctx.lr = 0x82612500;
	sub_82612738(ctx, base);
	// 82612500: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82612504: 48000235  bl 0x82612738
	ctx.lr = 0x82612508;
	sub_82612738(ctx, base);
	// 82612508: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261250C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82612510; continue 'dispatch;
            }
            0x82612510 => {
    //   block [0x82612510..0x8261251C)
	// 82612510: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82612514: 409A0008  bne cr6, 0x8261251c
	if !ctx.cr[6].eq {
	pc = 0x8261251C; continue 'dispatch;
	}
	// 82612518: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261251C; continue 'dispatch;
            }
            0x8261251C => {
    //   block [0x8261251C..0x8261252C)
	// 8261251C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612520: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82612524: 409A0008  bne cr6, 0x8261252c
	if !ctx.cr[6].eq {
	pc = 0x8261252C; continue 'dispatch;
	}
	// 82612528: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261252C; continue 'dispatch;
            }
            0x8261252C => {
    //   block [0x8261252C..0x82612538)
	// 8261252C: 386A0018  addi r3, r10, 0x18
	ctx.r[3].s64 = ctx.r[10].s64 + 24;
	// 82612530: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82612534: 48696F28  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82612538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82612538 size=112
    let mut pc: u32 = 0x82612538;
    'dispatch: loop {
        match pc {
            0x82612538 => {
    //   block [0x82612538..0x826125A8)
	// 82612538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261253C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82612540: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82612544: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82612548: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261254C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82612550: 3BEB8BF4  addi r31, r11, -0x740c
	ctx.r[31].s64 = ctx.r[11].s64 + -29708;
	// 82612554: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82612558: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261255C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82612560: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612564: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82612568: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8261256C: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82612570: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82612574: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82612578: 48000869  bl 0x82612de0
	ctx.lr = 0x8261257C;
	sub_82612DE0(ctx, base);
	// 8261257C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612580: 4BC097B9  bl 0x8221bd38
	ctx.lr = 0x82612584;
	sub_8221BD38(ctx, base);
	// 82612584: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82612588: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8261258C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82612590: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82612594: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82612598: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261259C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826125A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826125A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826125A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826125A8 size=228
    let mut pc: u32 = 0x826125A8;
    'dispatch: loop {
        match pc {
            0x826125A8 => {
    //   block [0x826125A8..0x826125D8)
	// 826125A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826125AC: 48696E5D  bl 0x82ca9408
	ctx.lr = 0x826125B0;
	sub_82CA93D0(ctx, base);
	// 826125B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826125B4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 826125B8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 826125BC: 3BCB8BF4  addi r30, r11, -0x740c
	ctx.r[30].s64 = ctx.r[11].s64 + -29708;
	// 826125C0: 839E0004  lwz r28, 4(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826125C4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 826125C8: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 826125CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826125D0: 409A0044  bne cr6, 0x82612614
	if !ctx.cr[6].eq {
	pc = 0x82612614; continue 'dispatch;
	}
	// 826125D4: E9250000  ld r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	pc = 0x826125D8; continue 'dispatch;
            }
            0x826125D8 => {
    //   block [0x826125D8..0x826125EC)
	// 826125D8: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 826125DC: 7F295040  cmpld cr6, r9, r10
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[10].u64, &mut ctx.xer);
	// 826125E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826125E4: 41980008  blt cr6, 0x826125ec
	if ctx.cr[6].lt {
	pc = 0x826125EC; continue 'dispatch;
	}
	// 826125E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x826125EC; continue 'dispatch;
            }
            0x826125EC => {
    //   block [0x826125EC..0x82612604)
	// 826125EC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 826125F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826125F4: 419A0010  beq cr6, 0x82612604
	if ctx.cr[6].eq {
	pc = 0x82612604; continue 'dispatch;
	}
	// 826125F8: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 826125FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82612600: 48000008  b 0x82612608
	pc = 0x82612608; continue 'dispatch;
            }
            0x82612604 => {
    //   block [0x82612604..0x82612608)
	// 82612604: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82612608; continue 'dispatch;
            }
            0x82612608 => {
    //   block [0x82612608..0x82612614)
	// 82612608: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 8261260C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82612610: 419AFFC8  beq cr6, 0x826125d8
	if ctx.cr[6].eq {
	pc = 0x826125D8; continue 'dispatch;
	}
	pc = 0x82612614; continue 'dispatch;
            }
            0x82612614 => {
    //   block [0x82612614..0x82612638)
	// 82612614: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82612618: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 8261261C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82612620: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82612624: 48000905  bl 0x82612f28
	ctx.lr = 0x82612628;
	sub_82612F28(ctx, base);
	// 82612628: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8261262C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82612630: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82612634: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	pc = 0x82612638; continue 'dispatch;
            }
            0x82612638 => {
    //   block [0x82612638..0x8261264C)
	// 82612638: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261263C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612640: 419A000C  beq cr6, 0x8261264c
	if ctx.cr[6].eq {
	pc = 0x8261264C; continue 'dispatch;
	}
	// 82612644: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82612648: 419A0008  beq cr6, 0x82612650
	if ctx.cr[6].eq {
	pc = 0x82612650; continue 'dispatch;
	}
	pc = 0x8261264C; continue 'dispatch;
            }
            0x8261264C => {
    //   block [0x8261264C..0x82612650)
	// 8261264C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612650; continue 'dispatch;
            }
            0x82612650 => {
    //   block [0x82612650..0x8261266C)
	// 82612650: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82612654: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82612658: 419A0014  beq cr6, 0x8261266c
	if ctx.cr[6].eq {
	pc = 0x8261266C; continue 'dispatch;
	}
	// 8261265C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82612660: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82612664: 48001B7D  bl 0x826141e0
	ctx.lr = 0x82612668;
	sub_826141E0(ctx, base);
	// 82612668: 4BFFFFD0  b 0x82612638
	pc = 0x82612638; continue 'dispatch;
            }
            0x8261266C => {
    //   block [0x8261266C..0x8261268C)
	// 8261266C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82612670: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82612674: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82612678: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8261267C: 48000765  bl 0x82612de0
	ctx.lr = 0x82612680;
	sub_82612DE0(ctx, base);
	// 82612680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82612684: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82612688: 48696DD0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82612690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82612690 size=164
    let mut pc: u32 = 0x82612690;
    'dispatch: loop {
        match pc {
            0x82612690 => {
    //   block [0x82612690..0x826126CC)
	// 82612690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82612694: 48696D79  bl 0x82ca940c
	ctx.lr = 0x82612698;
	sub_82CA93D0(ctx, base);
	// 82612698: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261269C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 826126A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826126A4: 3BEB8BF4  addi r31, r11, -0x740c
	ctx.r[31].s64 = ctx.r[11].s64 + -29708;
	// 826126A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826126AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826126B0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826126B4: 48000875  bl 0x82612f28
	ctx.lr = 0x826126B8;
	sub_82612F28(ctx, base);
	// 826126B8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826126BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826126C0: 419A000C  beq cr6, 0x826126cc
	if ctx.cr[6].eq {
	pc = 0x826126CC; continue 'dispatch;
	}
	// 826126C4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 826126C8: 419A0008  beq cr6, 0x826126d0
	if ctx.cr[6].eq {
	pc = 0x826126D0; continue 'dispatch;
	}
	pc = 0x826126CC; continue 'dispatch;
            }
            0x826126CC => {
    //   block [0x826126CC..0x826126D0)
	// 826126CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826126D0; continue 'dispatch;
            }
            0x826126D0 => {
    //   block [0x826126D0..0x826126F8)
	// 826126D0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826126D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826126D8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 826126DC: 419A0030  beq cr6, 0x8261270c
	if ctx.cr[6].eq {
	pc = 0x8261270C; continue 'dispatch;
	}
	// 826126E0: E90B0010  ld r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 826126E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826126E8: E93E0000  ld r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 826126EC: 7F294040  cmpld cr6, r9, r8
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[8].u64, &mut ctx.xer);
	// 826126F0: 41980008  blt cr6, 0x826126f8
	if ctx.cr[6].lt {
	pc = 0x826126F8; continue 'dispatch;
	}
	// 826126F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x826126F8; continue 'dispatch;
            }
            0x826126F8 => {
    //   block [0x826126F8..0x8261270C)
	// 826126F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 826126FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612700: 409A000C  bne cr6, 0x8261270c
	if !ctx.cr[6].eq {
	pc = 0x8261270C; continue 'dispatch;
	}
	// 82612704: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82612708: 48000010  b 0x82612718
	pc = 0x82612718; continue 'dispatch;
            }
            0x8261270C => {
    //   block [0x8261270C..0x82612718)
	// 8261270C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82612710: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82612714: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	pc = 0x82612718; continue 'dispatch;
            }
            0x82612718 => {
    //   block [0x82612718..0x82612734)
	// 82612718: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261271C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82612720: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612724: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82612728: 913D0004  stw r9, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8261272C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82612730: 48696D2C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82612738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82612738 size=108
    let mut pc: u32 = 0x82612738;
    'dispatch: loop {
        match pc {
            0x82612738 => {
    //   block [0x82612738..0x82612764)
	// 82612738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261273C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82612740: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82612744: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82612748: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261274C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82612750: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 82612754: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82612758: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261275C: 419A0008  beq cr6, 0x82612764
	if ctx.cr[6].eq {
	pc = 0x82612764; continue 'dispatch;
	}
	// 82612760: 4BC095D9  bl 0x8221bd38
	ctx.lr = 0x82612764;
	sub_8221BD38(ctx, base);
	pc = 0x82612764; continue 'dispatch;
            }
            0x82612764 => {
    //   block [0x82612764..0x826127A4)
	// 82612764: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82612768: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8261276C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82612770: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82612774: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82612778: 4BBA53A1  bl 0x821b7b18
	ctx.lr = 0x8261277C;
	sub_821B7B18(ctx, base);
	// 8261277C: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82612780: 48000359  bl 0x82612ad8
	ctx.lr = 0x82612784;
	sub_82612AD8(ctx, base);
	// 82612784: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82612788: 4BBA5391  bl 0x821b7b18
	ctx.lr = 0x8261278C;
	sub_821B7B18(ctx, base);
	// 8261278C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82612790: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82612794: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82612798: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8261279C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826127A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826127A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826127A8 size=540
    let mut pc: u32 = 0x826127A8;
    'dispatch: loop {
        match pc {
            0x826127A8 => {
    //   block [0x826127A8..0x826127FC)
	// 826127A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826127AC: 48696C59  bl 0x82ca9404
	ctx.lr = 0x826127B0;
	sub_82CA93D0(ctx, base);
	// 826127B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826127B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826127B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826127BC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826127C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826127C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826127C8: FB8100C0  std r28, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u64 ) };
	// 826127CC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 826127D0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826127D4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826127D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826127DC: 409A0020  bne cr6, 0x826127fc
	if !ctx.cr[6].eq {
	pc = 0x826127FC; continue 'dispatch;
	}
	// 826127E0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 826127E4: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826127E8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826127EC: 48000F8D  bl 0x82613778
	ctx.lr = 0x826127F0;
	sub_82613778(ctx, base);
	// 826127F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826127F4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826127F8: 48696C5C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x826127FC => {
    //   block [0x826127FC..0x82612818)
	// 826127FC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612800: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82612804: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612808: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261280C: 419A000C  beq cr6, 0x82612818
	if ctx.cr[6].eq {
	pc = 0x82612818; continue 'dispatch;
	}
	// 82612810: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82612814: 419A0008  beq cr6, 0x8261281c
	if ctx.cr[6].eq {
	pc = 0x8261281C; continue 'dispatch;
	}
	pc = 0x82612818; continue 'dispatch;
            }
            0x82612818 => {
    //   block [0x82612818..0x8261281C)
	// 82612818: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261281C; continue 'dispatch;
            }
            0x8261281C => {
    //   block [0x8261281C..0x8261285C)
	// 8261281C: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82612820: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82612824: 409A0038  bne cr6, 0x8261285c
	if !ctx.cr[6].eq {
	pc = 0x8261285C; continue 'dispatch;
	}
	// 82612828: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261282C: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82612830: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82612834: 40980160  bge cr6, 0x82612994
	if !ctx.cr[6].lt {
	pc = 0x82612994; continue 'dispatch;
	}
	// 82612838: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 8261283C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82612840: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82612844: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82612848: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261284C: 48000F2D  bl 0x82613778
	ctx.lr = 0x82612850;
	sub_82613778(ctx, base);
	// 82612850: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82612854: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82612858: 48696BFC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261285C => {
    //   block [0x8261285C..0x8261286C)
	// 8261285C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612860: 419A000C  beq cr6, 0x8261286c
	if ctx.cr[6].eq {
	pc = 0x8261286C; continue 'dispatch;
	}
	// 82612864: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82612868: 419A0008  beq cr6, 0x82612870
	if ctx.cr[6].eq {
	pc = 0x82612870; continue 'dispatch;
	}
	pc = 0x8261286C; continue 'dispatch;
            }
            0x8261286C => {
    //   block [0x8261286C..0x82612870)
	// 8261286C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612870; continue 'dispatch;
            }
            0x82612870 => {
    //   block [0x82612870..0x826128AC)
	// 82612870: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82612874: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82612878: 409A0034  bne cr6, 0x826128ac
	if !ctx.cr[6].eq {
	pc = 0x826128AC; continue 'dispatch;
	}
	// 8261287C: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82612880: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82612884: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82612888: 4098010C  bge cr6, 0x82612994
	if !ctx.cr[6].lt {
	pc = 0x82612994; continue 'dispatch;
	}
	// 8261288C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82612890: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82612894: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82612898: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261289C: 48000EDD  bl 0x82613778
	ctx.lr = 0x826128A0;
	sub_82613778(ctx, base);
	// 826128A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826128A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826128A8: 48696BAC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x826128AC => {
    //   block [0x826128AC..0x826128F8)
	// 826128AC: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 826128B0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 826128B4: 40980058  bge cr6, 0x8261290c
	if !ctx.cr[6].lt {
	pc = 0x8261290C; continue 'dispatch;
	}
	// 826128B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826128BC: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 826128C0: 4804DC89  bl 0x82660548
	ctx.lr = 0x826128C4;
	sub_82660548(ctx, base);
	// 826128C4: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826128C8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826128CC: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 826128D0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826128D4: 40980038  bge cr6, 0x8261290c
	if !ctx.cr[6].lt {
	pc = 0x8261290C; continue 'dispatch;
	}
	// 826128D8: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 826128DC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 826128E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826128E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826128E8: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 826128EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826128F0: 409A0090  bne cr6, 0x82612980
	if !ctx.cr[6].eq {
	pc = 0x82612980; continue 'dispatch;
	}
	// 826128F4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x826128F8; continue 'dispatch;
            }
            0x826128F8 => {
    //   block [0x826128F8..0x8261290C)
	// 826128F8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826128FC: 48000E7D  bl 0x82613778
	ctx.lr = 0x82612900;
	sub_82613778(ctx, base);
	// 82612900: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82612904: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82612908: 48696B4C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261290C => {
    //   block [0x8261290C..0x8261293C)
	// 8261290C: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82612910: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82612914: 40980080  bge cr6, 0x82612994
	if !ctx.cr[6].lt {
	pc = 0x82612994; continue 'dispatch;
	}
	// 82612918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261291C: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 82612920: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612924: 4BE2A4CD  bl 0x8243cdf0
	ctx.lr = 0x82612928;
	sub_8243CDF0(ctx, base);
	// 82612928: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261292C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612930: 419A000C  beq cr6, 0x8261293c
	if ctx.cr[6].eq {
	pc = 0x8261293C; continue 'dispatch;
	}
	// 82612934: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82612938: 419A0008  beq cr6, 0x82612940
	if ctx.cr[6].eq {
	pc = 0x82612940; continue 'dispatch;
	}
	pc = 0x8261293C; continue 'dispatch;
            }
            0x8261293C => {
    //   block [0x8261293C..0x82612940)
	// 8261293C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612940; continue 'dispatch;
            }
            0x82612940 => {
    //   block [0x82612940..0x82612960)
	// 82612940: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612944: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82612948: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8261294C: 419A0014  beq cr6, 0x82612960
	if ctx.cr[6].eq {
	pc = 0x82612960; continue 'dispatch;
	}
	// 82612950: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82612954: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82612958: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261295C: 40980038  bge cr6, 0x82612994
	if !ctx.cr[6].lt {
	pc = 0x82612994; continue 'dispatch;
	}
	pc = 0x82612960; continue 'dispatch;
            }
            0x82612960 => {
    //   block [0x82612960..0x82612980)
	// 82612960: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82612964: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82612968: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261296C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82612970: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82612974: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82612978: 419AFF80  beq cr6, 0x826128f8
	if ctx.cr[6].eq {
	pc = 0x826128F8; continue 'dispatch;
	}
	// 8261297C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82612980; continue 'dispatch;
            }
            0x82612980 => {
    //   block [0x82612980..0x82612994)
	// 82612980: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82612984: 48000DF5  bl 0x82613778
	ctx.lr = 0x82612988;
	sub_82613778(ctx, base);
	// 82612988: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261298C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82612990: 48696AC4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82612994 => {
    //   block [0x82612994..0x826129C4)
	// 82612994: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82612998: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261299C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826129A0: 48000831  bl 0x826131d0
	ctx.lr = 0x826129A4;
	sub_826131D0(ctx, base);
	// 826129A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826129A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826129AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826129B0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826129B4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826129B8: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 826129BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826129C0: 48696A94  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826129C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826129C8 size=268
    let mut pc: u32 = 0x826129C8;
    'dispatch: loop {
        match pc {
            0x826129C8 => {
    //   block [0x826129C8..0x82612A00)
	// 826129C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826129CC: 48696A39  bl 0x82ca9404
	ctx.lr = 0x826129D0;
	sub_82CA93D0(ctx, base);
	// 826129D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826129D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826129D8: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 826129DC: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 826129E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826129E4: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 826129E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 826129EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826129F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826129F4: 419A000C  beq cr6, 0x82612a00
	if ctx.cr[6].eq {
	pc = 0x82612A00; continue 'dispatch;
	}
	// 826129F8: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 826129FC: 419A0008  beq cr6, 0x82612a04
	if ctx.cr[6].eq {
	pc = 0x82612A04; continue 'dispatch;
	}
	pc = 0x82612A00; continue 'dispatch;
            }
            0x82612A00 => {
    //   block [0x82612A00..0x82612A04)
	// 82612A00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612A04; continue 'dispatch;
            }
            0x82612A04 => {
    //   block [0x82612A04..0x82612A28)
	// 82612A04: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82612A08: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82612A0C: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82612A10: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82612A14: 409A0068  bne cr6, 0x82612a7c
	if !ctx.cr[6].eq {
	pc = 0x82612A7C; continue 'dispatch;
	}
	// 82612A18: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82612A1C: 419A000C  beq cr6, 0x82612a28
	if ctx.cr[6].eq {
	pc = 0x82612A28; continue 'dispatch;
	}
	// 82612A20: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82612A24: 419A0008  beq cr6, 0x82612a2c
	if ctx.cr[6].eq {
	pc = 0x82612A2C; continue 'dispatch;
	}
	pc = 0x82612A28; continue 'dispatch;
            }
            0x82612A28 => {
    //   block [0x82612A28..0x82612A2C)
	// 82612A28: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612A2C; continue 'dispatch;
            }
            0x82612A2C => {
    //   block [0x82612A2C..0x82612A7C)
	// 82612A2C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82612A30: 409A004C  bne cr6, 0x82612a7c
	if !ctx.cr[6].eq {
	pc = 0x82612A7C; continue 'dispatch;
	}
	// 82612A34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82612A38: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612A3C: 4BD73125  bl 0x82385b60
	ctx.lr = 0x82612A40;
	sub_82385B60(ctx, base);
	// 82612A40: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612A44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82612A48: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82612A4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82612A50: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82612A54: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612A58: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82612A5C: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82612A60: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612A64: 91080008  stw r8, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82612A68: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612A6C: 80C70000  lwz r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82612A70: 90DD0004  stw r6, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82612A74: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82612A78: 486969DC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82612A7C => {
    //   block [0x82612A7C..0x82612A8C)
	// 82612A7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82612A80: 419A000C  beq cr6, 0x82612a8c
	if ctx.cr[6].eq {
	pc = 0x82612A8C; continue 'dispatch;
	}
	// 82612A84: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82612A88: 419A0008  beq cr6, 0x82612a90
	if ctx.cr[6].eq {
	pc = 0x82612A90; continue 'dispatch;
	}
	pc = 0x82612A8C; continue 'dispatch;
            }
            0x82612A8C => {
    //   block [0x82612A8C..0x82612A90)
	// 82612A8C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612A90; continue 'dispatch;
            }
            0x82612A90 => {
    //   block [0x82612A90..0x82612AC4)
	// 82612A90: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82612A94: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82612A98: 419A002C  beq cr6, 0x82612ac4
	if ctx.cr[6].eq {
	pc = 0x82612AC4; continue 'dispatch;
	}
	// 82612A9C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82612AA0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82612AA4: 4BE2A34D  bl 0x8243cdf0
	ctx.lr = 0x82612AA8;
	sub_8243CDF0(ctx, base);
	// 82612AA8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82612AAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82612AB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82612AB4: 4800085D  bl 0x82613310
	ctx.lr = 0x82612AB8;
	sub_82613310(ctx, base);
	// 82612AB8: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82612ABC: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82612AC0: 4BFFFFBC  b 0x82612a7c
	pc = 0x82612A7C; continue 'dispatch;
            }
            0x82612AC4 => {
    //   block [0x82612AC4..0x82612AD4)
	// 82612AC4: F8BD0000  std r5, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82612AC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82612ACC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82612AD0: 48696984  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82612AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82612AD8 size=104
    let mut pc: u32 = 0x82612AD8;
    'dispatch: loop {
        match pc {
            0x82612AD8 => {
    //   block [0x82612AD8..0x82612B40)
	// 82612AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82612ADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82612AE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82612AE4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82612AE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82612AEC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82612AF0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82612AF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82612AF8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82612AFC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612B00: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82612B04: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82612B08: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82612B0C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82612B10: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82612B14: 4BFFFEB5  bl 0x826129c8
	ctx.lr = 0x82612B18;
	sub_826129C8(ctx, base);
	// 82612B18: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612B1C: 4BC0921D  bl 0x8221bd38
	ctx.lr = 0x82612B20;
	sub_8221BD38(ctx, base);
	// 82612B20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82612B24: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82612B28: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82612B2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82612B30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82612B34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82612B38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82612B3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82612B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82612B40 size=668
    let mut pc: u32 = 0x82612B40;
    'dispatch: loop {
        match pc {
            0x82612B40 => {
    //   block [0x82612B40..0x82612B9C)
	// 82612B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82612B44: 486968B9  bl 0x82ca93fc
	ctx.lr = 0x82612B48;
	sub_82CA93D0(ctx, base);
	// 82612B48: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82612B4C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82612B50: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82612B54: 3BEB8BF4  addi r31, r11, -0x740c
	ctx.r[31].s64 = ctx.r[11].s64 + -29708;
	// 82612B58: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82612B5C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82612B60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82612B64: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 82612B68: FB4100D0  std r26, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[26].u64 ) };
	// 82612B6C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82612B70: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82612B74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612B78: 409A0024  bne cr6, 0x82612b9c
	if !ctx.cr[6].eq {
	pc = 0x82612B9C; continue 'dispatch;
	}
	// 82612B7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82612B80: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612B84: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82612B88: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82612B8C: 480013D5  bl 0x82613f60
	ctx.lr = 0x82612B90;
	sub_82613F60(ctx, base);
	// 82612B90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82612B94: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82612B98: 486968B4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82612B9C => {
    //   block [0x82612B9C..0x82612BB8)
	// 82612B9C: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612BA0: 816100D0  lwz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82612BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612BA8: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82612BAC: 419A000C  beq cr6, 0x82612bb8
	if ctx.cr[6].eq {
	pc = 0x82612BB8; continue 'dispatch;
	}
	// 82612BB0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82612BB4: 419A0008  beq cr6, 0x82612bbc
	if ctx.cr[6].eq {
	pc = 0x82612BBC; continue 'dispatch;
	}
	pc = 0x82612BB8; continue 'dispatch;
            }
            0x82612BB8 => {
    //   block [0x82612BB8..0x82612BBC)
	// 82612BB8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612BBC; continue 'dispatch;
            }
            0x82612BBC => {
    //   block [0x82612BBC..0x82612BE0)
	// 82612BBC: 836100D4  lwz r27, 0xd4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82612BC0: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82612BC4: 409A004C  bne cr6, 0x82612c10
	if !ctx.cr[6].eq {
	pc = 0x82612C10; continue 'dispatch;
	}
	// 82612BC8: E97D0000  ld r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 82612BCC: E95B0010  ld r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	// 82612BD0: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82612BD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82612BD8: 41980008  blt cr6, 0x82612be0
	if ctx.cr[6].lt {
	pc = 0x82612BE0; continue 'dispatch;
	}
	// 82612BDC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82612BE0; continue 'dispatch;
            }
            0x82612BE0 => {
    //   block [0x82612BE0..0x82612C10)
	// 82612BE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82612BE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612BE8: 419A01C4  beq cr6, 0x82612dac
	if ctx.cr[6].eq {
	pc = 0x82612DAC; continue 'dispatch;
	}
	// 82612BEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82612BF0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82612BF4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82612BF8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82612BFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82612C00: 48001361  bl 0x82613f60
	ctx.lr = 0x82612C04;
	sub_82613F60(ctx, base);
	// 82612C04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82612C08: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82612C0C: 48696840  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82612C10 => {
    //   block [0x82612C10..0x82612C20)
	// 82612C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612C14: 419A000C  beq cr6, 0x82612c20
	if ctx.cr[6].eq {
	pc = 0x82612C20; continue 'dispatch;
	}
	// 82612C18: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82612C1C: 419A0008  beq cr6, 0x82612c24
	if ctx.cr[6].eq {
	pc = 0x82612C24; continue 'dispatch;
	}
	pc = 0x82612C20; continue 'dispatch;
            }
            0x82612C20 => {
    //   block [0x82612C20..0x82612C24)
	// 82612C20: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612C24; continue 'dispatch;
            }
            0x82612C24 => {
    //   block [0x82612C24..0x82612C48)
	// 82612C24: E97D0000  ld r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 82612C28: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82612C2C: 409A0048  bne cr6, 0x82612c74
	if !ctx.cr[6].eq {
	pc = 0x82612C74; continue 'dispatch;
	}
	// 82612C30: 80DC0008  lwz r6, 8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82612C34: E9460010  ld r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	// 82612C38: 7F2A5840  cmpld cr6, r10, r11
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[11].u64, &mut ctx.xer);
	// 82612C3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82612C40: 41980008  blt cr6, 0x82612c48
	if ctx.cr[6].lt {
	pc = 0x82612C48; continue 'dispatch;
	}
	// 82612C44: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82612C48; continue 'dispatch;
            }
            0x82612C48 => {
    //   block [0x82612C48..0x82612C74)
	// 82612C48: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82612C4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612C50: 419A015C  beq cr6, 0x82612dac
	if ctx.cr[6].eq {
	pc = 0x82612DAC; continue 'dispatch;
	}
	// 82612C54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82612C58: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82612C5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82612C60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82612C64: 480012FD  bl 0x82613f60
	ctx.lr = 0x82612C68;
	sub_82613F60(ctx, base);
	// 82612C68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82612C6C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82612C70: 486967DC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82612C74 => {
    //   block [0x82612C74..0x82612C88)
	// 82612C74: E95B0010  ld r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	// 82612C78: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82612C7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82612C80: 41980008  blt cr6, 0x82612c88
	if ctx.cr[6].lt {
	pc = 0x82612C88; continue 'dispatch;
	}
	// 82612C84: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x82612C88; continue 'dispatch;
            }
            0x82612C88 => {
    //   block [0x82612C88..0x82612CBC)
	// 82612C88: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82612C8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82612C90: 419A0070  beq cr6, 0x82612d00
	if ctx.cr[6].eq {
	pc = 0x82612D00; continue 'dispatch;
	}
	// 82612C94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82612C98: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 82612C9C: 4800183D  bl 0x826144d8
	ctx.lr = 0x82612CA0;
	sub_826144D8(ctx, base);
	// 82612CA0: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82612CA4: E97D0000  ld r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 82612CA8: E9460010  ld r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	// 82612CAC: 7F2A5840  cmpld cr6, r10, r11
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[11].u64, &mut ctx.xer);
	// 82612CB0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82612CB4: 41980008  blt cr6, 0x82612cbc
	if ctx.cr[6].lt {
	pc = 0x82612CBC; continue 'dispatch;
	}
	// 82612CB8: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x82612CBC; continue 'dispatch;
            }
            0x82612CBC => {
    //   block [0x82612CBC..0x82612CE8)
	// 82612CBC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82612CC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82612CC4: 419A0038  beq cr6, 0x82612cfc
	if ctx.cr[6].eq {
	pc = 0x82612CFC; continue 'dispatch;
	}
	// 82612CC8: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82612CCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82612CD0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82612CD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82612CD8: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82612CDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82612CE0: 409A00B8  bne cr6, 0x82612d98
	if !ctx.cr[6].eq {
	pc = 0x82612D98; continue 'dispatch;
	}
	// 82612CE4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82612CE8; continue 'dispatch;
            }
            0x82612CE8 => {
    //   block [0x82612CE8..0x82612CFC)
	// 82612CE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82612CEC: 48001275  bl 0x82613f60
	ctx.lr = 0x82612CF0;
	sub_82613F60(ctx, base);
	// 82612CF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82612CF4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82612CF8: 48696754  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82612CFC => {
    //   block [0x82612CFC..0x82612D00)
	// 82612CFC: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82612D00; continue 'dispatch;
            }
            0x82612D00 => {
    //   block [0x82612D00..0x82612D14)
	// 82612D00: E95B0010  ld r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	// 82612D04: 7F2A5840  cmpld cr6, r10, r11
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[11].u64, &mut ctx.xer);
	// 82612D08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82612D0C: 41980008  blt cr6, 0x82612d14
	if ctx.cr[6].lt {
	pc = 0x82612D14; continue 'dispatch;
	}
	// 82612D10: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82612D14; continue 'dispatch;
            }
            0x82612D14 => {
    //   block [0x82612D14..0x82612D40)
	// 82612D14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82612D18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612D1C: 419A0090  beq cr6, 0x82612dac
	if ctx.cr[6].eq {
	pc = 0x82612DAC; continue 'dispatch;
	}
	// 82612D20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82612D24: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 82612D28: 480014B9  bl 0x826141e0
	ctx.lr = 0x82612D2C;
	sub_826141E0(ctx, base);
	// 82612D2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82612D30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612D34: 419A000C  beq cr6, 0x82612d40
	if ctx.cr[6].eq {
	pc = 0x82612D40; continue 'dispatch;
	}
	// 82612D38: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82612D3C: 419A0008  beq cr6, 0x82612d44
	if ctx.cr[6].eq {
	pc = 0x82612D44; continue 'dispatch;
	}
	pc = 0x82612D40; continue 'dispatch;
            }
            0x82612D40 => {
    //   block [0x82612D40..0x82612D44)
	// 82612D40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612D44; continue 'dispatch;
            }
            0x82612D44 => {
    //   block [0x82612D44..0x82612D6C)
	// 82612D44: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612D48: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82612D4C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82612D50: 419A0028  beq cr6, 0x82612d78
	if ctx.cr[6].eq {
	pc = 0x82612D78; continue 'dispatch;
	}
	// 82612D54: E97D0000  ld r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 82612D58: E9460010  ld r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	// 82612D5C: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82612D60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82612D64: 41980008  blt cr6, 0x82612d6c
	if ctx.cr[6].lt {
	pc = 0x82612D6C; continue 'dispatch;
	}
	// 82612D68: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82612D6C; continue 'dispatch;
            }
            0x82612D6C => {
    //   block [0x82612D6C..0x82612D78)
	// 82612D6C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82612D70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612D74: 419A0038  beq cr6, 0x82612dac
	if ctx.cr[6].eq {
	pc = 0x82612DAC; continue 'dispatch;
	}
	pc = 0x82612D78; continue 'dispatch;
            }
            0x82612D78 => {
    //   block [0x82612D78..0x82612D98)
	// 82612D78: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82612D7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82612D80: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82612D84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82612D88: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82612D8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82612D90: 419AFF58  beq cr6, 0x82612ce8
	if ctx.cr[6].eq {
	pc = 0x82612CE8; continue 'dispatch;
	}
	// 82612D94: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82612D98; continue 'dispatch;
            }
            0x82612D98 => {
    //   block [0x82612D98..0x82612DAC)
	// 82612D98: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82612D9C: 480011C5  bl 0x82613f60
	ctx.lr = 0x82612DA0;
	sub_82613F60(ctx, base);
	// 82612DA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82612DA4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82612DA8: 486966A4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82612DAC => {
    //   block [0x82612DAC..0x82612DDC)
	// 82612DAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82612DB0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82612DB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82612DB8: 48000C19  bl 0x826139d0
	ctx.lr = 0x82612DBC;
	sub_826139D0(ctx, base);
	// 82612DBC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82612DC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82612DC4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82612DC8: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82612DCC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612DD0: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82612DD4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82612DD8: 48696674  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82612DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82612DE0 size=328
    let mut pc: u32 = 0x82612DE0;
    'dispatch: loop {
        match pc {
            0x82612DE0 => {
    //   block [0x82612DE0..0x82612E1C)
	// 82612DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82612DE4: 48696621  bl 0x82ca9404
	ctx.lr = 0x82612DE8;
	sub_82CA93D0(ctx, base);
	// 82612DE8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82612DEC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82612DF0: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82612DF4: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82612DF8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82612DFC: 3BEB8BF4  addi r31, r11, -0x740c
	ctx.r[31].s64 = ctx.r[11].s64 + -29708;
	// 82612E00: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82612E04: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82612E08: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612E0C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82612E10: 419A000C  beq cr6, 0x82612e1c
	if ctx.cr[6].eq {
	pc = 0x82612E1C; continue 'dispatch;
	}
	// 82612E14: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82612E18: 419A0008  beq cr6, 0x82612e20
	if ctx.cr[6].eq {
	pc = 0x82612E20; continue 'dispatch;
	}
	pc = 0x82612E1C; continue 'dispatch;
            }
            0x82612E1C => {
    //   block [0x82612E1C..0x82612E20)
	// 82612E1C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612E20; continue 'dispatch;
            }
            0x82612E20 => {
    //   block [0x82612E20..0x82612E44)
	// 82612E20: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82612E24: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82612E28: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82612E2C: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82612E30: 409A00A0  bne cr6, 0x82612ed0
	if !ctx.cr[6].eq {
	pc = 0x82612ED0; continue 'dispatch;
	}
	// 82612E34: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82612E38: 419A000C  beq cr6, 0x82612e44
	if ctx.cr[6].eq {
	pc = 0x82612E44; continue 'dispatch;
	}
	// 82612E3C: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82612E40: 419A0008  beq cr6, 0x82612e48
	if ctx.cr[6].eq {
	pc = 0x82612E48; continue 'dispatch;
	}
	pc = 0x82612E44; continue 'dispatch;
            }
            0x82612E44 => {
    //   block [0x82612E44..0x82612E48)
	// 82612E44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612E48; continue 'dispatch;
            }
            0x82612E48 => {
    //   block [0x82612E48..0x82612E64)
	// 82612E48: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82612E4C: 409A0084  bne cr6, 0x82612ed0
	if !ctx.cr[6].eq {
	pc = 0x82612ED0; continue 'dispatch;
	}
	// 82612E50: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612E54: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82612E58: 895D0059  lbz r10, 0x59(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(89 as u32) ) } as u64;
	// 82612E5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82612E60: 409A0038  bne cr6, 0x82612e98
	if !ctx.cr[6].eq {
	pc = 0x82612E98; continue 'dispatch;
	}
	pc = 0x82612E64; continue 'dispatch;
            }
            0x82612E64 => {
    //   block [0x82612E64..0x82612E98)
	// 82612E64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82612E68: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82612E6C: 4800148D  bl 0x826142f8
	ctx.lr = 0x82612E70;
	sub_826142F8(ctx, base);
	// 82612E70: 387D0018  addi r3, r29, 0x18
	ctx.r[3].s64 = ctx.r[29].s64 + 24;
	// 82612E74: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82612E78: 4BFFF8C1  bl 0x82612738
	ctx.lr = 0x82612E7C;
	sub_82612738(ctx, base);
	// 82612E7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82612E80: 4BC08EB9  bl 0x8221bd38
	ctx.lr = 0x82612E84;
	sub_8221BD38(ctx, base);
	// 82612E84: 897E0059  lbz r11, 0x59(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(89 as u32) ) } as u64;
	// 82612E88: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82612E8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612E90: 419AFFD4  beq cr6, 0x82612e64
	if ctx.cr[6].eq {
	pc = 0x82612E64; continue 'dispatch;
	}
	// 82612E94: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82612E98; continue 'dispatch;
            }
            0x82612E98 => {
    //   block [0x82612E98..0x82612ED0)
	// 82612E98: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82612E9C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82612EA0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82612EA4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82612EA8: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82612EAC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612EB0: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82612EB4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612EB8: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82612EBC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612EC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82612EC4: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82612EC8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82612ECC: 48696588  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82612ED0 => {
    //   block [0x82612ED0..0x82612EE0)
	// 82612ED0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82612ED4: 419A000C  beq cr6, 0x82612ee0
	if ctx.cr[6].eq {
	pc = 0x82612EE0; continue 'dispatch;
	}
	// 82612ED8: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82612EDC: 419A0008  beq cr6, 0x82612ee4
	if ctx.cr[6].eq {
	pc = 0x82612EE4; continue 'dispatch;
	}
	pc = 0x82612EE0; continue 'dispatch;
            }
            0x82612EE0 => {
    //   block [0x82612EE0..0x82612EE4)
	// 82612EE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82612EE4; continue 'dispatch;
            }
            0x82612EE4 => {
    //   block [0x82612EE4..0x82612F18)
	// 82612EE4: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82612EE8: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82612EEC: 419A002C  beq cr6, 0x82612f18
	if ctx.cr[6].eq {
	pc = 0x82612F18; continue 'dispatch;
	}
	// 82612EF0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82612EF4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82612EF8: 480012E9  bl 0x826141e0
	ctx.lr = 0x82612EFC;
	sub_826141E0(ctx, base);
	// 82612EFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82612F00: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82612F04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82612F08: 48000C29  bl 0x82613b30
	ctx.lr = 0x82612F0C;
	sub_82613B30(ctx, base);
	// 82612F0C: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82612F10: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82612F14: 4BFFFFBC  b 0x82612ed0
	pc = 0x82612ED0; continue 'dispatch;
            }
            0x82612F18 => {
    //   block [0x82612F18..0x82612F28)
	// 82612F18: F8BC0000  std r5, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82612F1C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82612F20: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82612F24: 48696530  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82612F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82612F28 size=104
    let mut pc: u32 = 0x82612F28;
    'dispatch: loop {
        match pc {
            0x82612F28 => {
    //   block [0x82612F28..0x82612F48)
	// 82612F28: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82612F2C: 390B8BF4  addi r8, r11, -0x740c
	ctx.r[8].s64 = ctx.r[11].s64 + -29708;
	// 82612F30: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612F34: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612F38: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82612F3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82612F40: 409A0044  bne cr6, 0x82612f84
	if !ctx.cr[6].eq {
	pc = 0x82612F84; continue 'dispatch;
	}
	// 82612F44: E8E50000  ld r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	pc = 0x82612F48; continue 'dispatch;
            }
            0x82612F48 => {
    //   block [0x82612F48..0x82612F5C)
	// 82612F48: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 82612F4C: 7F2A3840  cmpld cr6, r10, r7
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[7].u64, &mut ctx.xer);
	// 82612F50: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82612F54: 41980008  blt cr6, 0x82612f5c
	if ctx.cr[6].lt {
	pc = 0x82612F5C; continue 'dispatch;
	}
	// 82612F58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82612F5C; continue 'dispatch;
            }
            0x82612F5C => {
    //   block [0x82612F5C..0x82612F70)
	// 82612F5C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82612F60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82612F64: 419A000C  beq cr6, 0x82612f70
	if ctx.cr[6].eq {
	pc = 0x82612F70; continue 'dispatch;
	}
	// 82612F68: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82612F6C: 4800000C  b 0x82612f78
	pc = 0x82612F78; continue 'dispatch;
            }
            0x82612F70 => {
    //   block [0x82612F70..0x82612F78)
	// 82612F70: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82612F74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82612F78; continue 'dispatch;
            }
            0x82612F78 => {
    //   block [0x82612F78..0x82612F84)
	// 82612F78: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82612F7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82612F80: 419AFFC8  beq cr6, 0x82612f48
	if ctx.cr[6].eq {
	pc = 0x82612F48; continue 'dispatch;
	}
	pc = 0x82612F84; continue 'dispatch;
            }
            0x82612F84 => {
    //   block [0x82612F84..0x82612F90)
	// 82612F84: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82612F88: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82612F8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82612F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82612F90 size=224
    let mut pc: u32 = 0x82612F90;
    'dispatch: loop {
        match pc {
            0x82612F90 => {
    //   block [0x82612F90..0x82612FEC)
	// 82612F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82612F94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82612F98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82612F9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82612FA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82612FA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82612FA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82612FAC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82612FB0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82612FB4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82612FB8: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82612FBC: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82612FC0: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82612FC4: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82612FC8: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82612FCC: 80FE0010  lwz r7, 0x10(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82612FD0: 90FF0010  stw r7, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 82612FD4: 80DE0014  lwz r6, 0x14(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82612FD8: 90DF0014  stw r6, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 82612FDC: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82612FE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82612FE4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82612FE8: 419A0020  beq cr6, 0x82613008
	if ctx.cr[6].eq {
	pc = 0x82613008; continue 'dispatch;
	}
	pc = 0x82612FEC; continue 'dispatch;
            }
            0x82612FEC => {
    //   block [0x82612FEC..0x82613008)
	// 82612FEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82612FF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82612FF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82612FF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82612FFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82613000: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82613004: 4082FFE8  bne 0x82612fec
	if !ctx.cr[0].eq {
	pc = 0x82612FEC; continue 'dispatch;
	}
	pc = 0x82613008; continue 'dispatch;
            }
            0x82613008 => {
    //   block [0x82613008..0x8261302C)
	// 82613008: 389E001C  addi r4, r30, 0x1c
	ctx.r[4].s64 = ctx.r[30].s64 + 28;
	// 8261300C: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82613010: 480000F1  bl 0x82613100
	ctx.lr = 0x82613014;
	sub_82613100(ctx, base);
	// 82613014: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82613018: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8261301C: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82613020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82613024: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82613028: 419A0020  beq cr6, 0x82613048
	if ctx.cr[6].eq {
	pc = 0x82613048; continue 'dispatch;
	}
	pc = 0x8261302C; continue 'dispatch;
            }
            0x8261302C => {
    //   block [0x8261302C..0x82613048)
	// 8261302C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82613030: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82613034: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82613038: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8261303C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82613040: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82613044: 4082FFE8  bne 0x8261302c
	if !ctx.cr[0].eq {
	pc = 0x8261302C; continue 'dispatch;
	}
	pc = 0x82613048; continue 'dispatch;
            }
            0x82613048 => {
    //   block [0x82613048..0x82613070)
	// 82613048: 389E0030  addi r4, r30, 0x30
	ctx.r[4].s64 = ctx.r[30].s64 + 48;
	// 8261304C: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82613050: 4BD68EF9  bl 0x8237bf48
	ctx.lr = 0x82613054;
	sub_8237BF48(ctx, base);
	// 82613054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82613058: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261305C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82613060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82613064: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82613068: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261306C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82613070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82613070 size=140
    let mut pc: u32 = 0x82613070;
    'dispatch: loop {
        match pc {
            0x82613070 => {
    //   block [0x82613070..0x826130CC)
	// 82613070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82613074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82613078: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261307C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82613080: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82613084: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82613088: 419A0060  beq cr6, 0x826130e8
	if ctx.cr[6].eq {
	pc = 0x826130E8; continue 'dispatch;
	}
	// 8261308C: 4BB8E44D  bl 0x821a14d8
	ctx.lr = 0x82613090;
	sub_821A14D8(ctx, base);
	// 82613090: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613094: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82613098: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8261309C: 8123005C  lwz r9, 0x5c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) } as u64;
	// 826130A0: 81030034  lwz r8, 0x34(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 826130A4: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 826130A8: 41980024  blt cr6, 0x826130cc
	if ctx.cr[6].lt {
	pc = 0x826130CC; continue 'dispatch;
	}
	// 826130AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826130B0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 826130B4: 48742075  bl 0x82d55128
	ctx.lr = 0x826130B8;
	sub_82D55128(ctx, base);
	// 826130B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826130BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826130C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826130C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826130C8: 4E800020  blr
	return;
            }
            0x826130CC => {
    //   block [0x826130CC..0x826130E8)
	// 826130CC: 8143005C  lwz r10, 0x5c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) } as u64;
	// 826130D0: 39630058  addi r11, r3, 0x58
	ctx.r[11].s64 = ctx.r[3].s64 + 88;
	// 826130D4: 81630058  lwz r11, 0x58(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 826130D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826130DC: 9143005C  stw r10, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 826130E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826130E4: 93E30058  stw r31, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	pc = 0x826130E8; continue 'dispatch;
            }
            0x826130E8 => {
    //   block [0x826130E8..0x826130FC)
	// 826130E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826130EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826130F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826130F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826130F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82613100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82613100 size=204
    let mut pc: u32 = 0x82613100;
    'dispatch: loop {
        match pc {
            0x82613100 => {
    //   block [0x82613100..0x82613160)
	// 82613100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82613104: 48696309  bl 0x82ca940c
	ctx.lr = 0x82613108;
	sub_82CA93D0(ctx, base);
	// 82613108: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261310C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82613110: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82613114: 48404E0D  bl 0x82a17f20
	ctx.lr = 0x82613118;
	sub_82A17F20(ctx, base);
	// 82613118: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261311C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82613120: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613124: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613128: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8261312C: 4800132D  bl 0x82614458
	ctx.lr = 0x82613130;
	sub_82614458(ctx, base);
	// 82613130: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82613134: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613138: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261313C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82613140: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613144: 890A0019  lbz r8, 0x19(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(25 as u32) ) } as u64;
	// 82613148: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8261314C: 409A0068  bne cr6, 0x826131b4
	if !ctx.cr[6].eq {
	pc = 0x826131B4; continue 'dispatch;
	}
	// 82613150: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613154: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82613158: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8261315C: 409A0018  bne cr6, 0x82613174
	if !ctx.cr[6].eq {
	pc = 0x82613174; continue 'dispatch;
	}
	pc = 0x82613160; continue 'dispatch;
            }
            0x82613160 => {
    //   block [0x82613160..0x82613174)
	// 82613160: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82613164: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613168: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 8261316C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82613170: 419AFFF0  beq cr6, 0x82613160
	if ctx.cr[6].eq {
	pc = 0x82613160; continue 'dispatch;
	}
	pc = 0x82613174; continue 'dispatch;
            }
            0x82613174 => {
    //   block [0x82613174..0x82613190)
	// 82613174: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82613178: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261317C: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613180: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613184: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82613188: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8261318C: 409A0018  bne cr6, 0x826131a4
	if !ctx.cr[6].eq {
	pc = 0x826131A4; continue 'dispatch;
	}
	pc = 0x82613190; continue 'dispatch;
            }
            0x82613190 => {
    //   block [0x82613190..0x826131A4)
	// 82613190: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82613194: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613198: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 8261319C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 826131A0: 419AFFF0  beq cr6, 0x82613190
	if ctx.cr[6].eq {
	pc = 0x82613190; continue 'dispatch;
	}
	pc = 0x826131A4; continue 'dispatch;
            }
            0x826131A4 => {
    //   block [0x826131A4..0x826131B4)
	// 826131A4: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826131A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826131AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826131B0: 486962AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x826131B4 => {
    //   block [0x826131B4..0x826131CC)
	// 826131B4: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826131B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826131BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826131C0: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 826131C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826131C8: 48696294  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826131D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826131D0 size=316
    let mut pc: u32 = 0x826131D0;
    'dispatch: loop {
        match pc {
            0x826131D0 => {
    //   block [0x826131D0..0x82613208)
	// 826131D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826131D4: 4869622D  bl 0x82ca9400
	ctx.lr = 0x826131D8;
	sub_82CA93D0(ctx, base);
	// 826131D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826131DC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 826131E0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 826131E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826131E8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 826131EC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 826131F0: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 826131F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826131F8: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 826131FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82613200: 409A003C  bne cr6, 0x8261323c
	if !ctx.cr[6].eq {
	pc = 0x8261323C; continue 'dispatch;
	}
	// 82613204: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82613208; continue 'dispatch;
            }
            0x82613208 => {
    //   block [0x82613208..0x8261322C)
	// 82613208: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261320C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82613210: 7D095010  subfc r8, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82613214: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82613218: 54FD07FE  clrlwi r29, r7, 0x1f
	ctx.r[29].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 8261321C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82613220: 419A000C  beq cr6, 0x8261322c
	if ctx.cr[6].eq {
	pc = 0x8261322C; continue 'dispatch;
	}
	// 82613224: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613228: 48000008  b 0x82613230
	pc = 0x82613230; continue 'dispatch;
            }
            0x8261322C => {
    //   block [0x8261322C..0x82613230)
	// 8261322C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82613230; continue 'dispatch;
            }
            0x82613230 => {
    //   block [0x82613230..0x8261323C)
	// 82613230: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82613234: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82613238: 419AFFD0  beq cr6, 0x82613208
	if ctx.cr[6].eq {
	pc = 0x82613208; continue 'dispatch;
	}
	pc = 0x8261323C; continue 'dispatch;
            }
            0x8261323C => {
    //   block [0x8261323C..0x8261329C)
	// 8261323C: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82613240: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82613244: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82613248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261324C: 419A0054  beq cr6, 0x826132a0
	if ctx.cr[6].eq {
	pc = 0x826132A0; continue 'dispatch;
	}
	// 82613250: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82613258: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261325C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82613260: 409A003C  bne cr6, 0x8261329c
	if !ctx.cr[6].eq {
	pc = 0x8261329C; continue 'dispatch;
	}
	// 82613264: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82613268: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 8261326C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82613270: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82613274: 48000505  bl 0x82613778
	ctx.lr = 0x82613278;
	sub_82613778(ctx, base);
	// 82613278: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8261327C: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82613280: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82613284: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613288: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261328C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82613290: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82613294: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82613298: 486961B8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261329C => {
    //   block [0x8261329C..0x826132A0)
	// 8261329C: 4804D2AD  bl 0x82660548
	ctx.lr = 0x826132A0;
	sub_82660548(ctx, base);
	pc = 0x826132A0; continue 'dispatch;
            }
            0x826132A0 => {
    //   block [0x826132A0..0x826132F0)
	// 826132A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826132A4: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826132A8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826132AC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 826132B0: 40980040  bge cr6, 0x826132f0
	if !ctx.cr[6].lt {
	pc = 0x826132F0; continue 'dispatch;
	}
	// 826132B4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 826132B8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 826132BC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826132C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826132C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826132C8: 480004B1  bl 0x82613778
	ctx.lr = 0x826132CC;
	sub_82613778(ctx, base);
	// 826132CC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826132D0: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 826132D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826132D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826132DC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826132E0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826132E4: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 826132E8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826132EC: 48696164  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x826132F0 => {
    //   block [0x826132F0..0x8261330C)
	// 826132F0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 826132F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826132F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826132FC: 995E0008  stb r10, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82613300: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82613304: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82613308: 48696148  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82613310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82613310 size=1128
    let mut pc: u32 = 0x82613310;
    'dispatch: loop {
        match pc {
            0x82613310 => {
    //   block [0x82613310..0x8261337C)
	// 82613310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82613314: 486960E9  bl 0x82ca93fc
	ctx.lr = 0x82613318;
	sub_82CA93D0(ctx, base);
	// 82613318: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261331C: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 82613320: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82613324: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82613328: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8261332C: 897F0019  lbz r11, 0x19(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 82613330: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82613334: 419A0048  beq cr6, 0x8261337c
	if ctx.cr[6].eq {
	pc = 0x8261337C; continue 'dispatch;
	}
	// 82613338: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8261333C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82613340: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 82613344: 4BCDEBFD  bl 0x822f1f40
	ctx.lr = 0x82613348;
	sub_822F1F40(ctx, base);
	// 82613348: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8261334C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82613350: 4BCDEA61  bl 0x822f1db0
	ctx.lr = 0x82613354;
	sub_822F1DB0(ctx, base);
	// 82613354: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82613358: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8261335C: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 82613360: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82613364: 4BCDEABD  bl 0x822f1e20
	ctx.lr = 0x82613368;
	sub_822F1E20(ctx, base);
	// 82613368: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 8261336C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82613370: 48068471  bl 0x8267b7e0
	ctx.lr = 0x82613374;
	sub_8267B7E0(ctx, base);
	// 82613374: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82613378: 4BB5E499  bl 0x82171810
	ctx.lr = 0x8261337C;
	sub_82171810(ctx, base);
	pc = 0x8261337C; continue 'dispatch;
            }
            0x8261337C => {
    //   block [0x8261337C..0x826133A0)
	// 8261337C: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82613380: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 82613384: 4BE29A6D  bl 0x8243cdf0
	ctx.lr = 0x82613388;
	sub_8243CDF0(ctx, base);
	// 82613388: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261338C: 896A0019  lbz r11, 0x19(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(25 as u32) ) } as u64;
	// 82613390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82613394: 419A000C  beq cr6, 0x826133a0
	if ctx.cr[6].eq {
	pc = 0x826133A0; continue 'dispatch;
	}
	// 82613398: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261339C: 4800002C  b 0x826133c8
	pc = 0x826133C8; continue 'dispatch;
            }
            0x826133A0 => {
    //   block [0x826133A0..0x826133B8)
	// 826133A0: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 826133A4: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 826133A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 826133AC: 419A000C  beq cr6, 0x826133b8
	if ctx.cr[6].eq {
	pc = 0x826133B8; continue 'dispatch;
	}
	// 826133B0: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 826133B4: 48000014  b 0x826133c8
	pc = 0x826133C8; continue 'dispatch;
            }
            0x826133B8 => {
    //   block [0x826133B8..0x826133C8)
	// 826133B8: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 826133BC: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 826133C0: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826133C4: 409A00F0  bne cr6, 0x826134b4
	if !ctx.cr[6].eq {
	pc = 0x826134B4; continue 'dispatch;
	}
	pc = 0x826133C8; continue 'dispatch;
            }
            0x826133C8 => {
    //   block [0x826133C8..0x826133DC)
	// 826133C8: 897C0019  lbz r11, 0x19(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(25 as u32) ) } as u64;
	// 826133CC: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 826133D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826133D4: 409A0008  bne cr6, 0x826133dc
	if !ctx.cr[6].eq {
	pc = 0x826133DC; continue 'dispatch;
	}
	// 826133D8: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x826133DC; continue 'dispatch;
            }
            0x826133DC => {
    //   block [0x826133DC..0x826133F4)
	// 826133DC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826133E0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826133E4: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 826133E8: 409A000C  bne cr6, 0x826133f4
	if !ctx.cr[6].eq {
	pc = 0x826133F4; continue 'dispatch;
	}
	// 826133EC: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 826133F0: 4800001C  b 0x8261340c
	pc = 0x8261340C; continue 'dispatch;
            }
            0x826133F4 => {
    //   block [0x826133F4..0x82613408)
	// 826133F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826133F8: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 826133FC: 409A000C  bne cr6, 0x82613408
	if !ctx.cr[6].eq {
	pc = 0x82613408; continue 'dispatch;
	}
	// 82613400: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82613404: 48000008  b 0x8261340c
	pc = 0x8261340C; continue 'dispatch;
            }
            0x82613408 => {
    //   block [0x82613408..0x8261340C)
	// 82613408: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x8261340C; continue 'dispatch;
            }
            0x8261340C => {
    //   block [0x8261340C..0x82613430)
	// 8261340C: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613410: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613414: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82613418: 409A0044  bne cr6, 0x8261345c
	if !ctx.cr[6].eq {
	pc = 0x8261345C; continue 'dispatch;
	}
	// 8261341C: 897C0019  lbz r11, 0x19(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(25 as u32) ) } as u64;
	// 82613420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82613424: 419A000C  beq cr6, 0x82613430
	if ctx.cr[6].eq {
	pc = 0x82613430; continue 'dispatch;
	}
	// 82613428: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 8261342C: 4800002C  b 0x82613458
	pc = 0x82613458; continue 'dispatch;
            }
            0x82613430 => {
    //   block [0x82613430..0x82613444)
	// 82613430: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613434: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82613438: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 8261343C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82613440: 409A0018  bne cr6, 0x82613458
	if !ctx.cr[6].eq {
	pc = 0x82613458; continue 'dispatch;
	}
	pc = 0x82613444; continue 'dispatch;
            }
            0x82613444 => {
    //   block [0x82613444..0x82613458)
	// 82613444: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82613448: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261344C: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82613450: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82613454: 419AFFF0  beq cr6, 0x82613444
	if ctx.cr[6].eq {
	pc = 0x82613444; continue 'dispatch;
	}
	pc = 0x82613458; continue 'dispatch;
            }
            0x82613458 => {
    //   block [0x82613458..0x8261345C)
	// 82613458: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x8261345C; continue 'dispatch;
            }
            0x8261345C => {
    //   block [0x8261345C..0x82613484)
	// 8261345C: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613460: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613464: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82613468: 409A00E0  bne cr6, 0x82613548
	if !ctx.cr[6].eq {
	pc = 0x82613548; continue 'dispatch;
	}
	// 8261346C: 897C0019  lbz r11, 0x19(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(25 as u32) ) } as u64;
	// 82613470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82613474: 419A0010  beq cr6, 0x82613484
	if ctx.cr[6].eq {
	pc = 0x82613484; continue 'dispatch;
	}
	// 82613478: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 8261347C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82613480: 480000C8  b 0x82613548
	pc = 0x82613548; continue 'dispatch;
            }
            0x82613484 => {
    //   block [0x82613484..0x82613498)
	// 82613484: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613488: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 8261348C: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82613490: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82613494: 409A0018  bne cr6, 0x826134ac
	if !ctx.cr[6].eq {
	pc = 0x826134AC; continue 'dispatch;
	}
	pc = 0x82613498; continue 'dispatch;
            }
            0x82613498 => {
    //   block [0x82613498..0x826134AC)
	// 82613498: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8261349C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826134A0: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 826134A4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 826134A8: 419AFFF0  beq cr6, 0x82613498
	if ctx.cr[6].eq {
	pc = 0x82613498; continue 'dispatch;
	}
	pc = 0x826134AC; continue 'dispatch;
            }
            0x826134AC => {
    //   block [0x826134AC..0x826134B4)
	// 826134AC: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826134B0: 48000098  b 0x82613548
	pc = 0x82613548; continue 'dispatch;
            }
            0x826134B4 => {
    //   block [0x826134B4..0x826134D4)
	// 826134B4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826134B8: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826134BC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826134C0: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 826134C4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 826134C8: 409A000C  bne cr6, 0x826134d4
	if !ctx.cr[6].eq {
	pc = 0x826134D4; continue 'dispatch;
	}
	// 826134CC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 826134D0: 4800002C  b 0x826134fc
	pc = 0x826134FC; continue 'dispatch;
            }
            0x826134D4 => {
    //   block [0x826134D4..0x826134E8)
	// 826134D4: 895C0019  lbz r10, 0x19(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(25 as u32) ) } as u64;
	// 826134D8: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826134DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826134E0: 409A0008  bne cr6, 0x826134e8
	if !ctx.cr[6].eq {
	pc = 0x826134E8; continue 'dispatch;
	}
	// 826134E4: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x826134E8; continue 'dispatch;
            }
            0x826134E8 => {
    //   block [0x826134E8..0x826134FC)
	// 826134E8: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 826134EC: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 826134F0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826134F4: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 826134F8: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x826134FC; continue 'dispatch;
            }
            0x826134FC => {
    //   block [0x826134FC..0x82613514)
	// 826134FC: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613500: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613504: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82613508: 409A000C  bne cr6, 0x82613514
	if !ctx.cr[6].eq {
	pc = 0x82613514; continue 'dispatch;
	}
	// 8261350C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82613510: 48000020  b 0x82613530
	pc = 0x82613530; continue 'dispatch;
            }
            0x82613514 => {
    //   block [0x82613514..0x8261352C)
	// 82613514: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613518: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261351C: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82613520: 409A000C  bne cr6, 0x8261352c
	if !ctx.cr[6].eq {
	pc = 0x8261352C; continue 'dispatch;
	}
	// 82613524: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82613528: 48000008  b 0x82613530
	pc = 0x82613530; continue 'dispatch;
            }
            0x8261352C => {
    //   block [0x8261352C..0x82613530)
	// 8261352C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82613530; continue 'dispatch;
            }
            0x82613530 => {
    //   block [0x82613530..0x82613548)
	// 82613530: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613534: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82613538: 890B0018  lbz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8261353C: 893A0018  lbz r9, 0x18(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 82613540: 992B0018  stb r9, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u8 ) };
	// 82613544: 991A0018  stb r8, 0x18(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(24 as u32), ctx.r[8].u8 ) };
	pc = 0x82613548; continue 'dispatch;
            }
            0x82613548 => {
    //   block [0x82613548..0x8261356C)
	// 82613548: 897A0018  lbz r11, 0x18(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 8261354C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82613550: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82613554: 409A0194  bne cr6, 0x826136e8
	if !ctx.cr[6].eq {
	pc = 0x826136E8; continue 'dispatch;
	}
	// 82613558: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261355C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82613560: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613564: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82613568: 419A017C  beq cr6, 0x826136e4
	if ctx.cr[6].eq {
	pc = 0x826136E4; continue 'dispatch;
	}
	pc = 0x8261356C; continue 'dispatch;
            }
            0x8261356C => {
    //   block [0x8261356C..0x826135AC)
	// 8261356C: 897C0018  lbz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82613570: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82613574: 409A0170  bne cr6, 0x826136e4
	if !ctx.cr[6].eq {
	pc = 0x826136E4; continue 'dispatch;
	}
	// 82613578: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261357C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82613580: 409A00A8  bne cr6, 0x82613628
	if !ctx.cr[6].eq {
	pc = 0x82613628; continue 'dispatch;
	}
	// 82613584: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613588: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8261358C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82613590: 409A001C  bne cr6, 0x826135ac
	if !ctx.cr[6].eq {
	pc = 0x826135AC; continue 'dispatch;
	}
	// 82613594: 9BCB0018  stb r30, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82613598: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261359C: 9BBF0018  stb r29, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 826135A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826135A4: 485F6F45  bl 0x82c0a4e8
	ctx.lr = 0x826135A8;
	sub_82C0A4E8(ctx, base);
	// 826135A8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x826135AC; continue 'dispatch;
            }
            0x826135AC => {
    //   block [0x826135AC..0x826135D8)
	// 826135AC: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 826135B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826135B4: 409A00C8  bne cr6, 0x8261367c
	if !ctx.cr[6].eq {
	pc = 0x8261367C; continue 'dispatch;
	}
	// 826135B8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826135BC: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 826135C0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 826135C4: 409A0014  bne cr6, 0x826135d8
	if !ctx.cr[6].eq {
	pc = 0x826135D8; continue 'dispatch;
	}
	// 826135C8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826135CC: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 826135D0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 826135D4: 419A00A4  beq cr6, 0x82613678
	if ctx.cr[6].eq {
	pc = 0x82613678; continue 'dispatch;
	}
	pc = 0x826135D8; continue 'dispatch;
            }
            0x826135D8 => {
    //   block [0x826135D8..0x82613604)
	// 826135D8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826135DC: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 826135E0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 826135E4: 409A0020  bne cr6, 0x82613604
	if !ctx.cr[6].eq {
	pc = 0x82613604; continue 'dispatch;
	}
	// 826135E8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826135EC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 826135F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826135F4: 9BCA0018  stb r30, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 826135F8: 9BAB0018  stb r29, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 826135FC: 485F6F65  bl 0x82c0a560
	ctx.lr = 0x82613600;
	sub_82C0A560(ctx, base);
	// 82613600: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82613604; continue 'dispatch;
            }
            0x82613604 => {
    //   block [0x82613604..0x82613628)
	// 82613604: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82613608: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261360C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82613610: 994B0018  stb r10, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 82613614: 9BDF0018  stb r30, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82613618: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261361C: 9BC90018  stb r30, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82613620: 485F6EC9  bl 0x82c0a4e8
	ctx.lr = 0x82613624;
	sub_82C0A4E8(ctx, base);
	// 82613624: 480000C0  b 0x826136e4
	pc = 0x826136E4; continue 'dispatch;
            }
            0x82613628 => {
    //   block [0x82613628..0x8261364C)
	// 82613628: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8261362C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82613630: 409A001C  bne cr6, 0x8261364c
	if !ctx.cr[6].eq {
	pc = 0x8261364C; continue 'dispatch;
	}
	// 82613634: 9BCB0018  stb r30, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82613638: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261363C: 9BBF0018  stb r29, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 82613640: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82613644: 485F6F1D  bl 0x82c0a560
	ctx.lr = 0x82613648;
	sub_82C0A560(ctx, base);
	// 82613648: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261364C; continue 'dispatch;
            }
            0x8261364C => {
    //   block [0x8261364C..0x82613678)
	// 8261364C: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82613650: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82613654: 409A0028  bne cr6, 0x8261367c
	if !ctx.cr[6].eq {
	pc = 0x8261367C; continue 'dispatch;
	}
	// 82613658: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261365C: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82613660: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82613664: 409A0034  bne cr6, 0x82613698
	if !ctx.cr[6].eq {
	pc = 0x82613698; continue 'dispatch;
	}
	// 82613668: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261366C: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82613670: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82613674: 409A0024  bne cr6, 0x82613698
	if !ctx.cr[6].eq {
	pc = 0x82613698; continue 'dispatch;
	}
	pc = 0x82613678; continue 'dispatch;
            }
            0x82613678 => {
    //   block [0x82613678..0x8261367C)
	// 82613678: 9BAB0018  stb r29, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	pc = 0x8261367C; continue 'dispatch;
            }
            0x8261367C => {
    //   block [0x8261367C..0x82613698)
	// 8261367C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613680: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82613684: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613688: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261368C: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82613690: 409AFEDC  bne cr6, 0x8261356c
	if !ctx.cr[6].eq {
	pc = 0x8261356C; continue 'dispatch;
	}
	// 82613694: 48000050  b 0x826136e4
	pc = 0x826136E4; continue 'dispatch;
            }
            0x82613698 => {
    //   block [0x82613698..0x826136C4)
	// 82613698: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261369C: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 826136A0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 826136A4: 409A0020  bne cr6, 0x826136c4
	if !ctx.cr[6].eq {
	pc = 0x826136C4; continue 'dispatch;
	}
	// 826136A8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826136AC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 826136B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826136B4: 9BCA0018  stb r30, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 826136B8: 9BAB0018  stb r29, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 826136BC: 485F6E2D  bl 0x82c0a4e8
	ctx.lr = 0x826136C0;
	sub_82C0A4E8(ctx, base);
	// 826136C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x826136C4; continue 'dispatch;
            }
            0x826136C4 => {
    //   block [0x826136C4..0x826136E4)
	// 826136C4: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 826136C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826136CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826136D0: 994B0018  stb r10, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 826136D4: 9BDF0018  stb r30, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 826136D8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826136DC: 9BC90018  stb r30, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 826136E0: 485F6E81  bl 0x82c0a560
	ctx.lr = 0x826136E4;
	sub_82C0A560(ctx, base);
	pc = 0x826136E4; continue 'dispatch;
            }
            0x826136E4 => {
    //   block [0x826136E4..0x826136E8)
	// 826136E4: 9BDC0018  stb r30, 0x18(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	pc = 0x826136E8; continue 'dispatch;
            }
            0x826136E8 => {
    //   block [0x826136E8..0x82613730)
	// 826136E8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826136EC: 817A0014  lwz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 826136F0: 3BFA0010  addi r31, r26, 0x10
	ctx.r[31].s64 = ctx.r[26].s64 + 16;
	// 826136F4: 392A0B7C  addi r9, r10, 0xb7c
	ctx.r[9].s64 = ctx.r[10].s64 + 2940;
	// 826136F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826136FC: 913A0010  stw r9, 0x10(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82613700: 419A0034  beq cr6, 0x82613734
	if ctx.cr[6].eq {
	pc = 0x82613734; continue 'dispatch;
	}
	// 82613704: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613708: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8261370C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82613710: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613714: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613718: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261371C: 409A0014  bne cr6, 0x82613730
	if !ctx.cr[6].eq {
	pc = 0x82613730; continue 'dispatch;
	}
	// 82613720: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613724: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82613728: 409A0008  bne cr6, 0x82613730
	if !ctx.cr[6].eq {
	pc = 0x82613730; continue 'dispatch;
	}
	// 8261372C: 4BC0860D  bl 0x8221bd38
	ctx.lr = 0x82613730;
	sub_8221BD38(ctx, base);
	pc = 0x82613730; continue 'dispatch;
            }
            0x82613730 => {
    //   block [0x82613730..0x82613734)
	// 82613730: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	pc = 0x82613734; continue 'dispatch;
            }
            0x82613734 => {
    //   block [0x82613734..0x82613768)
	// 82613734: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82613738: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8261373C: 4BC085FD  bl 0x8221bd38
	ctx.lr = 0x82613740;
	sub_8221BD38(ctx, base);
	// 82613740: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613744: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82613748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261374C: 419A001C  beq cr6, 0x82613768
	if ctx.cr[6].eq {
	pc = 0x82613768; continue 'dispatch;
	}
	// 82613750: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82613754: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 82613758: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8261375C: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82613760: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82613764: 48695CE8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82613768 => {
    //   block [0x82613768..0x82613778)
	// 82613768: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 8261376C: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82613770: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82613774: 48695CD8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82613778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82613778 size=596
    let mut pc: u32 = 0x82613778;
    'dispatch: loop {
        match pc {
            0x82613778 => {
    //   block [0x82613778..0x826137F0)
	// 82613778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261377C: 48695C85  bl 0x82ca9400
	ctx.lr = 0x82613780;
	sub_82CA93D0(ctx, base);
	// 82613780: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82613784: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82613788: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 8261378C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82613790: 61695554  ori r9, r11, 0x5554
	ctx.r[9].u64 = ctx.r[11].u64 | 21844;
	// 82613794: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82613798: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261379C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 826137A0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 826137A4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 826137A8: 41980048  blt cr6, 0x826137f0
	if ctx.cr[6].lt {
	pc = 0x826137F0; continue 'dispatch;
	}
	// 826137AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 826137B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826137B4: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 826137B8: 4BCDE789  bl 0x822f1f40
	ctx.lr = 0x826137BC;
	sub_822F1F40(ctx, base);
	// 826137BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826137C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826137C4: 4BCDE5ED  bl 0x822f1db0
	ctx.lr = 0x826137C8;
	sub_822F1DB0(ctx, base);
	// 826137C8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 826137CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826137D0: 3B6A1720  addi r27, r10, 0x1720
	ctx.r[27].s64 = ctx.r[10].s64 + 5920;
	// 826137D4: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 826137D8: 4BCDE649  bl 0x822f1e20
	ctx.lr = 0x826137DC;
	sub_822F1E20(ctx, base);
	// 826137DC: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 826137E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826137E4: 48067FFD  bl 0x8267b7e0
	ctx.lr = 0x826137E8;
	sub_8267B7E0(ctx, base);
	// 826137E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826137EC: 4BB5E025  bl 0x82171810
	ctx.lr = 0x826137F0;
	sub_82171810(ctx, base);
	pc = 0x826137F0; continue 'dispatch;
            }
            0x826137F0 => {
    //   block [0x826137F0..0x82613840)
	// 826137F0: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826137F4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826137F8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 826137FC: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82613800: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82613804: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82613808: 48000A81  bl 0x82614288
	ctx.lr = 0x8261380C;
	sub_82614288(ctx, base);
	// 8261380C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613810: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613814: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82613818: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8261381C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82613820: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82613824: 409A001C  bne cr6, 0x82613840
	if !ctx.cr[6].eq {
	pc = 0x82613840; continue 'dispatch;
	}
	// 82613828: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 8261382C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613830: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82613834: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613838: 936A0008  stw r27, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 8261383C: 48000044  b 0x82613880
	pc = 0x82613880; continue 'dispatch;
            }
            0x82613840 => {
    //   block [0x82613840..0x82613868)
	// 82613840: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82613844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82613848: 419A0020  beq cr6, 0x82613868
	if ctx.cr[6].eq {
	pc = 0x82613868; continue 'dispatch;
	}
	// 8261384C: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82613850: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613854: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613858: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261385C: 409A0024  bne cr6, 0x82613880
	if !ctx.cr[6].eq {
	pc = 0x82613880; continue 'dispatch;
	}
	// 82613860: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82613864: 4800001C  b 0x82613880
	pc = 0x82613880; continue 'dispatch;
            }
            0x82613868 => {
    //   block [0x82613868..0x82613880)
	// 82613868: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 8261386C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613870: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613874: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82613878: 409A0008  bne cr6, 0x82613880
	if !ctx.cr[6].eq {
	pc = 0x82613880; continue 'dispatch;
	}
	// 8261387C: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82613880; continue 'dispatch;
            }
            0x82613880 => {
    //   block [0x82613880..0x826138A0)
	// 82613880: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613884: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 82613888: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 8261388C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82613890: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82613894: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82613898: 409A0114  bne cr6, 0x826139ac
	if !ctx.cr[6].eq {
	pc = 0x826139AC; continue 'dispatch;
	}
	// 8261389C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x826138A0; continue 'dispatch;
            }
            0x826138A0 => {
    //   block [0x826138A0..0x826138E8)
	// 826138A0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826138A4: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 826138A8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 826138AC: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 826138B0: 409A0078  bne cr6, 0x82613928
	if !ctx.cr[6].eq {
	pc = 0x82613928; continue 'dispatch;
	}
	// 826138B4: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 826138B8: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 826138BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 826138C0: 409A0028  bne cr6, 0x826138e8
	if !ctx.cr[6].eq {
	pc = 0x826138E8; continue 'dispatch;
	}
	// 826138C4: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 826138C8: 9BA90018  stb r29, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 826138CC: 9BAA0018  stb r29, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 826138D0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826138D4: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 826138D8: 9B870018  stb r28, 0x18(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(24 as u32), ctx.r[28].u8 ) };
	// 826138DC: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826138E0: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 826138E4: 480000B4  b 0x82613998
	pc = 0x82613998; continue 'dispatch;
            }
            0x826138E8 => {
    //   block [0x826138E8..0x82613900)
	// 826138E8: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 826138EC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826138F0: 409A0010  bne cr6, 0x82613900
	if !ctx.cr[6].eq {
	pc = 0x82613900; continue 'dispatch;
	}
	// 826138F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826138F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826138FC: 485F6BED  bl 0x82c0a4e8
	ctx.lr = 0x82613900;
	sub_82C0A4E8(ctx, base);
	pc = 0x82613900; continue 'dispatch;
            }
            0x82613900 => {
    //   block [0x82613900..0x82613928)
	// 82613900: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613904: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82613908: 9BAB0018  stb r29, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 8261390C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613910: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613914: 9B890018  stb r28, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[28].u8 ) };
	// 82613918: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261391C: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613920: 485F6C41  bl 0x82c0a560
	ctx.lr = 0x82613924;
	sub_82C0A560(ctx, base);
	// 82613924: 48000074  b 0x82613998
	pc = 0x82613998; continue 'dispatch;
            }
            0x82613928 => {
    //   block [0x82613928..0x8261395C)
	// 82613928: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261392C: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82613930: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82613934: 409A0028  bne cr6, 0x8261395c
	if !ctx.cr[6].eq {
	pc = 0x8261395C; continue 'dispatch;
	}
	// 82613938: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261393C: 9BA90018  stb r29, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 82613940: 9BAA0018  stb r29, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 82613944: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613948: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261394C: 9B870018  stb r28, 0x18(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(24 as u32), ctx.r[28].u8 ) };
	// 82613950: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613954: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613958: 48000040  b 0x82613998
	pc = 0x82613998; continue 'dispatch;
            }
            0x8261395C => {
    //   block [0x8261395C..0x82613974)
	// 8261395C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613960: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82613964: 409A0010  bne cr6, 0x82613974
	if !ctx.cr[6].eq {
	pc = 0x82613974; continue 'dispatch;
	}
	// 82613968: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261396C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82613970: 485F6BF1  bl 0x82c0a560
	ctx.lr = 0x82613974;
	sub_82C0A560(ctx, base);
	pc = 0x82613974; continue 'dispatch;
            }
            0x82613974 => {
    //   block [0x82613974..0x82613998)
	// 82613974: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613978: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261397C: 9BAB0018  stb r29, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 82613980: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613984: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613988: 9B890018  stb r28, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[28].u8 ) };
	// 8261398C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613990: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613994: 485F6B55  bl 0x82c0a4e8
	ctx.lr = 0x82613998;
	sub_82C0A4E8(ctx, base);
	pc = 0x82613998; continue 'dispatch;
            }
            0x82613998 => {
    //   block [0x82613998..0x826139AC)
	// 82613998: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261399C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826139A0: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 826139A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 826139A8: 419AFEF8  beq cr6, 0x826138a0
	if ctx.cr[6].eq {
	pc = 0x826138A0; continue 'dispatch;
	}
	pc = 0x826139AC; continue 'dispatch;
            }
            0x826139AC => {
    //   block [0x826139AC..0x826139CC)
	// 826139AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826139B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826139B4: 937A0004  stw r27, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 826139B8: 93DA0000  stw r30, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 826139BC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826139C0: 9BAA0018  stb r29, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 826139C4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826139C8: 48695A88  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826139D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826139D0 size=348
    let mut pc: u32 = 0x826139D0;
    'dispatch: loop {
        match pc {
            0x826139D0 => {
    //   block [0x826139D0..0x82613A10)
	// 826139D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826139D4: 48695A2D  bl 0x82ca9400
	ctx.lr = 0x826139D8;
	sub_82CA93D0(ctx, base);
	// 826139D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826139DC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 826139E0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 826139E4: 3B8B8BF4  addi r28, r11, -0x740c
	ctx.r[28].s64 = ctx.r[11].s64 + -29708;
	// 826139E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826139EC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 826139F0: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 826139F4: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 826139F8: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 826139FC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613A00: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82613A04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82613A08: 409A0044  bne cr6, 0x82613a4c
	if !ctx.cr[6].eq {
	pc = 0x82613A4C; continue 'dispatch;
	}
	// 82613A0C: E91B0000  ld r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	pc = 0x82613A10; continue 'dispatch;
            }
            0x82613A10 => {
    //   block [0x82613A10..0x82613A28)
	// 82613A10: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 82613A14: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82613A18: 7F285040  cmpld cr6, r8, r10
	ctx.cr[6].compare_u64(ctx.r[8].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82613A1C: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82613A20: 41980008  blt cr6, 0x82613a28
	if ctx.cr[6].lt {
	pc = 0x82613A28; continue 'dispatch;
	}
	// 82613A24: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82613A28; continue 'dispatch;
            }
            0x82613A28 => {
    //   block [0x82613A28..0x82613A3C)
	// 82613A28: 555E063E  clrlwi r30, r10, 0x18
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82613A2C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82613A30: 419A000C  beq cr6, 0x82613a3c
	if ctx.cr[6].eq {
	pc = 0x82613A3C; continue 'dispatch;
	}
	// 82613A34: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613A38: 48000008  b 0x82613a40
	pc = 0x82613A40; continue 'dispatch;
            }
            0x82613A3C => {
    //   block [0x82613A3C..0x82613A40)
	// 82613A3C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82613A40; continue 'dispatch;
            }
            0x82613A40 => {
    //   block [0x82613A40..0x82613A4C)
	// 82613A40: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82613A44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82613A48: 419AFFC8  beq cr6, 0x82613a10
	if ctx.cr[6].eq {
	pc = 0x82613A10; continue 'dispatch;
	}
	pc = 0x82613A4C; continue 'dispatch;
            }
            0x82613A4C => {
    //   block [0x82613A4C..0x82613AA8)
	// 82613A4C: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82613A50: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82613A54: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82613A58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82613A5C: 419A0050  beq cr6, 0x82613aac
	if ctx.cr[6].eq {
	pc = 0x82613AAC; continue 'dispatch;
	}
	// 82613A60: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613A64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82613A68: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82613A6C: 409A003C  bne cr6, 0x82613aa8
	if !ctx.cr[6].eq {
	pc = 0x82613AA8; continue 'dispatch;
	}
	// 82613A70: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82613A74: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82613A78: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82613A7C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82613A80: 480004E1  bl 0x82613f60
	ctx.lr = 0x82613A84;
	sub_82613F60(ctx, base);
	// 82613A84: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82613A88: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82613A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82613A90: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613A94: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613A98: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82613A9C: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82613AA0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82613AA4: 486959AC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82613AA8 => {
    //   block [0x82613AA8..0x82613AAC)
	// 82613AA8: 48000A31  bl 0x826144d8
	ctx.lr = 0x82613AAC;
	sub_826144D8(ctx, base);
	pc = 0x82613AAC; continue 'dispatch;
            }
            0x82613AAC => {
    //   block [0x82613AAC..0x82613AC8)
	// 82613AAC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82613AB0: E95B0000  ld r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 82613AB4: E92B0010  ld r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 82613AB8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82613ABC: 7F295040  cmpld cr6, r9, r10
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82613AC0: 41980008  blt cr6, 0x82613ac8
	if ctx.cr[6].lt {
	pc = 0x82613AC8; continue 'dispatch;
	}
	// 82613AC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82613AC8; continue 'dispatch;
            }
            0x82613AC8 => {
    //   block [0x82613AC8..0x82613B10)
	// 82613AC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82613ACC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82613AD0: 419A0040  beq cr6, 0x82613b10
	if ctx.cr[6].eq {
	pc = 0x82613B10; continue 'dispatch;
	}
	// 82613AD4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82613AD8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82613ADC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82613AE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82613AE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82613AE8: 48000479  bl 0x82613f60
	ctx.lr = 0x82613AEC;
	sub_82613F60(ctx, base);
	// 82613AEC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82613AF0: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82613AF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82613AF8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613AFC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613B00: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82613B04: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82613B08: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82613B0C: 48695944  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82613B10 => {
    //   block [0x82613B10..0x82613B2C)
	// 82613B10: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82613B14: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82613B18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82613B1C: 995F0008  stb r10, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82613B20: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82613B24: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82613B28: 48695928  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82613B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82613B30 size=1072
    let mut pc: u32 = 0x82613B30;
    'dispatch: loop {
        match pc {
            0x82613B30 => {
    //   block [0x82613B30..0x82613B98)
	// 82613B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82613B34: 486958C9  bl 0x82ca93fc
	ctx.lr = 0x82613B38;
	sub_82CA93D0(ctx, base);
	// 82613B38: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82613B3C: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 82613B40: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82613B44: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82613B48: 897F0059  lbz r11, 0x59(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(89 as u32) ) } as u64;
	// 82613B4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82613B50: 419A0048  beq cr6, 0x82613b98
	if ctx.cr[6].eq {
	pc = 0x82613B98; continue 'dispatch;
	}
	// 82613B54: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82613B58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82613B5C: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 82613B60: 4BCDE3E1  bl 0x822f1f40
	ctx.lr = 0x82613B64;
	sub_822F1F40(ctx, base);
	// 82613B64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82613B68: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82613B6C: 4BCDE245  bl 0x822f1db0
	ctx.lr = 0x82613B70;
	sub_822F1DB0(ctx, base);
	// 82613B70: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82613B74: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82613B78: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 82613B7C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82613B80: 4BCDE2A1  bl 0x822f1e20
	ctx.lr = 0x82613B84;
	sub_822F1E20(ctx, base);
	// 82613B84: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82613B88: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82613B8C: 48067C55  bl 0x8267b7e0
	ctx.lr = 0x82613B90;
	sub_8267B7E0(ctx, base);
	// 82613B90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82613B94: 4BB5DC7D  bl 0x82171810
	ctx.lr = 0x82613B98;
	sub_82171810(ctx, base);
	pc = 0x82613B98; continue 'dispatch;
            }
            0x82613B98 => {
    //   block [0x82613B98..0x82613BBC)
	// 82613B98: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82613B9C: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 82613BA0: 48000641  bl 0x826141e0
	ctx.lr = 0x82613BA4;
	sub_826141E0(ctx, base);
	// 82613BA4: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613BA8: 896A0059  lbz r11, 0x59(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(89 as u32) ) } as u64;
	// 82613BAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82613BB0: 419A000C  beq cr6, 0x82613bbc
	if ctx.cr[6].eq {
	pc = 0x82613BBC; continue 'dispatch;
	}
	// 82613BB4: 837A0008  lwz r27, 8(r26)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613BB8: 4800002C  b 0x82613be4
	pc = 0x82613BE4; continue 'dispatch;
            }
            0x82613BBC => {
    //   block [0x82613BBC..0x82613BD4)
	// 82613BBC: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613BC0: 892B0059  lbz r9, 0x59(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82613BC4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82613BC8: 419A000C  beq cr6, 0x82613bd4
	if ctx.cr[6].eq {
	pc = 0x82613BD4; continue 'dispatch;
	}
	// 82613BCC: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 82613BD0: 48000014  b 0x82613be4
	pc = 0x82613BE4; continue 'dispatch;
            }
            0x82613BD4 => {
    //   block [0x82613BD4..0x82613BE4)
	// 82613BD4: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82613BD8: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82613BDC: 836B0008  lwz r27, 8(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613BE0: 409A00FC  bne cr6, 0x82613cdc
	if !ctx.cr[6].eq {
	pc = 0x82613CDC; continue 'dispatch;
	}
	pc = 0x82613BE4; continue 'dispatch;
            }
            0x82613BE4 => {
    //   block [0x82613BE4..0x82613BF8)
	// 82613BE4: 897B0059  lbz r11, 0x59(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(89 as u32) ) } as u64;
	// 82613BE8: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613BEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82613BF0: 409A0008  bne cr6, 0x82613bf8
	if !ctx.cr[6].eq {
	pc = 0x82613BF8; continue 'dispatch;
	}
	// 82613BF4: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82613BF8; continue 'dispatch;
            }
            0x82613BF8 => {
    //   block [0x82613BF8..0x82613C18)
	// 82613BF8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82613BFC: 3B8B8BF4  addi r28, r11, -0x740c
	ctx.r[28].s64 = ctx.r[11].s64 + -29708;
	// 82613C00: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613C04: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613C08: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82613C0C: 409A000C  bne cr6, 0x82613c18
	if !ctx.cr[6].eq {
	pc = 0x82613C18; continue 'dispatch;
	}
	// 82613C10: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82613C14: 4800001C  b 0x82613c30
	pc = 0x82613C30; continue 'dispatch;
            }
            0x82613C18 => {
    //   block [0x82613C18..0x82613C2C)
	// 82613C18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613C1C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82613C20: 409A000C  bne cr6, 0x82613c2c
	if !ctx.cr[6].eq {
	pc = 0x82613C2C; continue 'dispatch;
	}
	// 82613C24: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82613C28: 48000008  b 0x82613c30
	pc = 0x82613C30; continue 'dispatch;
            }
            0x82613C2C => {
    //   block [0x82613C2C..0x82613C30)
	// 82613C2C: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82613C30; continue 'dispatch;
            }
            0x82613C30 => {
    //   block [0x82613C30..0x82613C54)
	// 82613C30: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613C34: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613C38: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82613C3C: 409A0048  bne cr6, 0x82613c84
	if !ctx.cr[6].eq {
	pc = 0x82613C84; continue 'dispatch;
	}
	// 82613C40: 897B0059  lbz r11, 0x59(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(89 as u32) ) } as u64;
	// 82613C44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82613C48: 419A000C  beq cr6, 0x82613c54
	if ctx.cr[6].eq {
	pc = 0x82613C54; continue 'dispatch;
	}
	// 82613C4C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82613C50: 4800002C  b 0x82613c7c
	pc = 0x82613C7C; continue 'dispatch;
            }
            0x82613C54 => {
    //   block [0x82613C54..0x82613C68)
	// 82613C54: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613C58: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82613C5C: 892B0059  lbz r9, 0x59(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82613C60: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82613C64: 409A0018  bne cr6, 0x82613c7c
	if !ctx.cr[6].eq {
	pc = 0x82613C7C; continue 'dispatch;
	}
	pc = 0x82613C68; continue 'dispatch;
            }
            0x82613C68 => {
    //   block [0x82613C68..0x82613C7C)
	// 82613C68: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82613C6C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613C70: 892B0059  lbz r9, 0x59(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82613C74: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82613C78: 419AFFF0  beq cr6, 0x82613c68
	if ctx.cr[6].eq {
	pc = 0x82613C68; continue 'dispatch;
	}
	pc = 0x82613C7C; continue 'dispatch;
            }
            0x82613C7C => {
    //   block [0x82613C7C..0x82613C84)
	// 82613C7C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613C80: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82613C84; continue 'dispatch;
            }
            0x82613C84 => {
    //   block [0x82613C84..0x82613CAC)
	// 82613C84: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613C88: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613C8C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82613C90: 409A00E8  bne cr6, 0x82613d78
	if !ctx.cr[6].eq {
	pc = 0x82613D78; continue 'dispatch;
	}
	// 82613C94: 897B0059  lbz r11, 0x59(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(89 as u32) ) } as u64;
	// 82613C98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82613C9C: 419A0010  beq cr6, 0x82613cac
	if ctx.cr[6].eq {
	pc = 0x82613CAC; continue 'dispatch;
	}
	// 82613CA0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82613CA4: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82613CA8: 480000D0  b 0x82613d78
	pc = 0x82613D78; continue 'dispatch;
            }
            0x82613CAC => {
    //   block [0x82613CAC..0x82613CC0)
	// 82613CAC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613CB0: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82613CB4: 890B0059  lbz r8, 0x59(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82613CB8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82613CBC: 409A0018  bne cr6, 0x82613cd4
	if !ctx.cr[6].eq {
	pc = 0x82613CD4; continue 'dispatch;
	}
	pc = 0x82613CC0; continue 'dispatch;
            }
            0x82613CC0 => {
    //   block [0x82613CC0..0x82613CD4)
	// 82613CC0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82613CC4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613CC8: 890B0059  lbz r8, 0x59(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82613CCC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82613CD0: 419AFFF0  beq cr6, 0x82613cc0
	if ctx.cr[6].eq {
	pc = 0x82613CC0; continue 'dispatch;
	}
	pc = 0x82613CD4; continue 'dispatch;
            }
            0x82613CD4 => {
    //   block [0x82613CD4..0x82613CDC)
	// 82613CD4: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82613CD8: 480000A0  b 0x82613d78
	pc = 0x82613D78; continue 'dispatch;
            }
            0x82613CDC => {
    //   block [0x82613CDC..0x82613CFC)
	// 82613CDC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82613CE0: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613CE4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82613CE8: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613CEC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82613CF0: 409A000C  bne cr6, 0x82613cfc
	if !ctx.cr[6].eq {
	pc = 0x82613CFC; continue 'dispatch;
	}
	// 82613CF4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82613CF8: 4800002C  b 0x82613d24
	pc = 0x82613D24; continue 'dispatch;
            }
            0x82613CFC => {
    //   block [0x82613CFC..0x82613D10)
	// 82613CFC: 895B0059  lbz r10, 0x59(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(89 as u32) ) } as u64;
	// 82613D00: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613D04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82613D08: 409A0008  bne cr6, 0x82613d10
	if !ctx.cr[6].eq {
	pc = 0x82613D10; continue 'dispatch;
	}
	// 82613D0C: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82613D10; continue 'dispatch;
            }
            0x82613D10 => {
    //   block [0x82613D10..0x82613D24)
	// 82613D10: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82613D14: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613D18: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82613D1C: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613D20: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82613D24; continue 'dispatch;
            }
            0x82613D24 => {
    //   block [0x82613D24..0x82613D44)
	// 82613D24: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82613D28: 3B8A8BF4  addi r28, r10, -0x740c
	ctx.r[28].s64 = ctx.r[10].s64 + -29708;
	// 82613D2C: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613D30: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613D34: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82613D38: 409A000C  bne cr6, 0x82613d44
	if !ctx.cr[6].eq {
	pc = 0x82613D44; continue 'dispatch;
	}
	// 82613D3C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82613D40: 48000020  b 0x82613d60
	pc = 0x82613D60; continue 'dispatch;
            }
            0x82613D44 => {
    //   block [0x82613D44..0x82613D5C)
	// 82613D44: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613D48: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613D4C: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82613D50: 409A000C  bne cr6, 0x82613d5c
	if !ctx.cr[6].eq {
	pc = 0x82613D5C; continue 'dispatch;
	}
	// 82613D54: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82613D58: 48000008  b 0x82613d60
	pc = 0x82613D60; continue 'dispatch;
            }
            0x82613D5C => {
    //   block [0x82613D5C..0x82613D60)
	// 82613D5C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82613D60; continue 'dispatch;
            }
            0x82613D60 => {
    //   block [0x82613D60..0x82613D78)
	// 82613D60: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613D64: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82613D68: 893A0058  lbz r9, 0x58(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(88 as u32) ) } as u64;
	// 82613D6C: 890B0058  lbz r8, 0x58(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82613D70: 992B0058  stb r9, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82613D74: 991A0058  stb r8, 0x58(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(88 as u32), ctx.r[8].u8 ) };
	pc = 0x82613D78; continue 'dispatch;
            }
            0x82613D78 => {
    //   block [0x82613D78..0x82613D9C)
	// 82613D78: 897A0058  lbz r11, 0x58(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(88 as u32) ) } as u64;
	// 82613D7C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82613D80: 409A0198  bne cr6, 0x82613f18
	if !ctx.cr[6].eq {
	pc = 0x82613F18; continue 'dispatch;
	}
	// 82613D84: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613D88: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82613D8C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613D90: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82613D94: 419A0180  beq cr6, 0x82613f14
	if ctx.cr[6].eq {
	pc = 0x82613F14; continue 'dispatch;
	}
	// 82613D98: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82613D9C; continue 'dispatch;
            }
            0x82613D9C => {
    //   block [0x82613D9C..0x82613DDC)
	// 82613D9C: 897B0058  lbz r11, 0x58(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 82613DA0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82613DA4: 409A0170  bne cr6, 0x82613f14
	if !ctx.cr[6].eq {
	pc = 0x82613F14; continue 'dispatch;
	}
	// 82613DA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613DAC: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82613DB0: 409A00A8  bne cr6, 0x82613e58
	if !ctx.cr[6].eq {
	pc = 0x82613E58; continue 'dispatch;
	}
	// 82613DB4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613DB8: 894B0058  lbz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82613DBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82613DC0: 409A001C  bne cr6, 0x82613ddc
	if !ctx.cr[6].eq {
	pc = 0x82613DDC; continue 'dispatch;
	}
	// 82613DC4: 9BAB0058  stb r29, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 82613DC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82613DCC: 9BDF0058  stb r30, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82613DD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82613DD4: 48000585  bl 0x82614358
	ctx.lr = 0x82613DD8;
	sub_82614358(ctx, base);
	// 82613DD8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82613DDC; continue 'dispatch;
            }
            0x82613DDC => {
    //   block [0x82613DDC..0x82613E08)
	// 82613DDC: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82613DE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82613DE4: 409A00C8  bne cr6, 0x82613eac
	if !ctx.cr[6].eq {
	pc = 0x82613EAC; continue 'dispatch;
	}
	// 82613DE8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613DEC: 892A0058  lbz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 82613DF0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82613DF4: 409A0014  bne cr6, 0x82613e08
	if !ctx.cr[6].eq {
	pc = 0x82613E08; continue 'dispatch;
	}
	// 82613DF8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613DFC: 892A0058  lbz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 82613E00: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82613E04: 419A00A4  beq cr6, 0x82613ea8
	if ctx.cr[6].eq {
	pc = 0x82613EA8; continue 'dispatch;
	}
	pc = 0x82613E08; continue 'dispatch;
            }
            0x82613E08 => {
    //   block [0x82613E08..0x82613E34)
	// 82613E08: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613E0C: 892A0058  lbz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 82613E10: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82613E14: 409A0020  bne cr6, 0x82613e34
	if !ctx.cr[6].eq {
	pc = 0x82613E34; continue 'dispatch;
	}
	// 82613E18: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613E1C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82613E20: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82613E24: 9BAA0058  stb r29, 0x58(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 82613E28: 9BCB0058  stb r30, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82613E2C: 480005AD  bl 0x826143d8
	ctx.lr = 0x82613E30;
	sub_826143D8(ctx, base);
	// 82613E30: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82613E34; continue 'dispatch;
            }
            0x82613E34 => {
    //   block [0x82613E34..0x82613E58)
	// 82613E34: 895F0058  lbz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82613E38: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82613E3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82613E40: 994B0058  stb r10, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 82613E44: 9BBF0058  stb r29, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 82613E48: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613E4C: 9BA90058  stb r29, 0x58(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 82613E50: 48000509  bl 0x82614358
	ctx.lr = 0x82613E54;
	sub_82614358(ctx, base);
	// 82613E54: 480000C0  b 0x82613f14
	pc = 0x82613F14; continue 'dispatch;
            }
            0x82613E58 => {
    //   block [0x82613E58..0x82613E7C)
	// 82613E58: 894B0058  lbz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82613E5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82613E60: 409A001C  bne cr6, 0x82613e7c
	if !ctx.cr[6].eq {
	pc = 0x82613E7C; continue 'dispatch;
	}
	// 82613E64: 9BAB0058  stb r29, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 82613E68: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82613E6C: 9BDF0058  stb r30, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82613E70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82613E74: 48000565  bl 0x826143d8
	ctx.lr = 0x82613E78;
	sub_826143D8(ctx, base);
	// 82613E78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82613E7C; continue 'dispatch;
            }
            0x82613E7C => {
    //   block [0x82613E7C..0x82613EA8)
	// 82613E7C: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82613E80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82613E84: 409A0028  bne cr6, 0x82613eac
	if !ctx.cr[6].eq {
	pc = 0x82613EAC; continue 'dispatch;
	}
	// 82613E88: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613E8C: 892A0058  lbz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 82613E90: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82613E94: 409A0034  bne cr6, 0x82613ec8
	if !ctx.cr[6].eq {
	pc = 0x82613EC8; continue 'dispatch;
	}
	// 82613E98: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613E9C: 892A0058  lbz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 82613EA0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82613EA4: 409A0024  bne cr6, 0x82613ec8
	if !ctx.cr[6].eq {
	pc = 0x82613EC8; continue 'dispatch;
	}
	pc = 0x82613EA8; continue 'dispatch;
            }
            0x82613EA8 => {
    //   block [0x82613EA8..0x82613EAC)
	// 82613EA8: 9BCB0058  stb r30, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	pc = 0x82613EAC; continue 'dispatch;
            }
            0x82613EAC => {
    //   block [0x82613EAC..0x82613EC8)
	// 82613EAC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613EB0: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 82613EB4: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613EB8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613EBC: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82613EC0: 409AFEDC  bne cr6, 0x82613d9c
	if !ctx.cr[6].eq {
	pc = 0x82613D9C; continue 'dispatch;
	}
	// 82613EC4: 48000050  b 0x82613f14
	pc = 0x82613F14; continue 'dispatch;
            }
            0x82613EC8 => {
    //   block [0x82613EC8..0x82613EF4)
	// 82613EC8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613ECC: 892A0058  lbz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 82613ED0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82613ED4: 409A0020  bne cr6, 0x82613ef4
	if !ctx.cr[6].eq {
	pc = 0x82613EF4; continue 'dispatch;
	}
	// 82613ED8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613EDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82613EE0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82613EE4: 9BAA0058  stb r29, 0x58(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 82613EE8: 9BCB0058  stb r30, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82613EEC: 4800046D  bl 0x82614358
	ctx.lr = 0x82613EF0;
	sub_82614358(ctx, base);
	// 82613EF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82613EF4; continue 'dispatch;
            }
            0x82613EF4 => {
    //   block [0x82613EF4..0x82613F14)
	// 82613EF4: 895F0058  lbz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82613EF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82613EFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82613F00: 994B0058  stb r10, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 82613F04: 9BBF0058  stb r29, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 82613F08: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82613F0C: 9BA90058  stb r29, 0x58(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 82613F10: 480004C9  bl 0x826143d8
	ctx.lr = 0x82613F14;
	sub_826143D8(ctx, base);
	pc = 0x82613F14; continue 'dispatch;
            }
            0x82613F14 => {
    //   block [0x82613F14..0x82613F18)
	// 82613F14: 9BBB0058  stb r29, 0x58(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	pc = 0x82613F18; continue 'dispatch;
            }
            0x82613F18 => {
    //   block [0x82613F18..0x82613F50)
	// 82613F18: 387A0018  addi r3, r26, 0x18
	ctx.r[3].s64 = ctx.r[26].s64 + 24;
	// 82613F1C: 4BFFE81D  bl 0x82612738
	ctx.lr = 0x82613F20;
	sub_82612738(ctx, base);
	// 82613F20: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82613F24: 4BC07E15  bl 0x8221bd38
	ctx.lr = 0x82613F28;
	sub_8221BD38(ctx, base);
	// 82613F28: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613F2C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82613F30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82613F34: 419A001C  beq cr6, 0x82613f50
	if ctx.cr[6].eq {
	pc = 0x82613F50; continue 'dispatch;
	}
	// 82613F38: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82613F3C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82613F40: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82613F44: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82613F48: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82613F4C: 48695500  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82613F50 => {
    //   block [0x82613F50..0x82613F60)
	// 82613F50: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82613F54: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82613F58: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82613F5C: 486954F0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82613F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82613F60 size=636
    let mut pc: u32 = 0x82613F60;
    'dispatch: loop {
        match pc {
            0x82613F60 => {
    //   block [0x82613F60..0x82613FDC)
	// 82613F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82613F64: 48695495  bl 0x82ca93f8
	ctx.lr = 0x82613F68;
	sub_82CA93D0(ctx, base);
	// 82613F68: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82613F6C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82613F70: 3D40038E  lis r10, 0x38e
	ctx.r[10].s64 = 59637760;
	// 82613F74: 3BCB8BF4  addi r30, r11, -0x740c
	ctx.r[30].s64 = ctx.r[11].s64 + -29708;
	// 82613F78: 614938E2  ori r9, r10, 0x38e2
	ctx.r[9].u64 = ctx.r[10].u64 | 14562;
	// 82613F7C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82613F80: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82613F84: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82613F88: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82613F8C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82613F90: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82613F94: 41980048  blt cr6, 0x82613fdc
	if ctx.cr[6].lt {
	pc = 0x82613FDC; continue 'dispatch;
	}
	// 82613F98: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82613F9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82613FA0: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 82613FA4: 4BCDDF9D  bl 0x822f1f40
	ctx.lr = 0x82613FA8;
	sub_822F1F40(ctx, base);
	// 82613FA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82613FAC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82613FB0: 4BCDDE01  bl 0x822f1db0
	ctx.lr = 0x82613FB4;
	sub_822F1DB0(ctx, base);
	// 82613FB4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82613FB8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82613FBC: 3BAA1720  addi r29, r10, 0x1720
	ctx.r[29].s64 = ctx.r[10].s64 + 5920;
	// 82613FC0: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82613FC4: 4BCDDE5D  bl 0x822f1e20
	ctx.lr = 0x82613FC8;
	sub_822F1E20(ctx, base);
	// 82613FC8: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82613FCC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82613FD0: 48067811  bl 0x8267b7e0
	ctx.lr = 0x82613FD4;
	sub_8267B7E0(ctx, base);
	// 82613FD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82613FD8: 4BB5D839  bl 0x82171810
	ctx.lr = 0x82613FDC;
	sub_82171810(ctx, base);
	pc = 0x82613FDC; continue 'dispatch;
            }
            0x82613FDC => {
    //   block [0x82613FDC..0x82614024)
	// 82613FDC: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82613FE0: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82613FE4: 4BC0B275  bl 0x8221f258
	ctx.lr = 0x82613FE8;
	sub_8221F258(ctx, base);
	// 82613FE8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82613FEC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82613FF0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82613FF4: 419A0030  beq cr6, 0x82614024
	if ctx.cr[6].eq {
	pc = 0x82614024; continue 'dispatch;
	}
	// 82613FF8: 397C0010  addi r11, r28, 0x10
	ctx.r[11].s64 = ctx.r[28].s64 + 16;
	// 82613FFC: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82614000: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82614004: 389B0008  addi r4, r27, 8
	ctx.r[4].s64 = ctx.r[27].s64 + 8;
	// 82614008: 93BC0008  stw r29, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 8261400C: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82614010: E97B0000  ld r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 82614014: F97C0010  std r11, 0x10(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 82614018: 4BFFEF79  bl 0x82612f90
	ctx.lr = 0x8261401C;
	sub_82612F90(ctx, base);
	// 8261401C: 9B3C0058  stb r25, 0x58(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(88 as u32), ctx.r[25].u8 ) };
	// 82614020: 9B3C0059  stb r25, 0x59(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(89 as u32), ctx.r[25].u8 ) };
	pc = 0x82614024; continue 'dispatch;
            }
            0x82614024 => {
    //   block [0x82614024..0x82614050)
	// 82614024: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82614028: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261402C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82614030: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82614034: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82614038: 409A0018  bne cr6, 0x82614050
	if !ctx.cr[6].eq {
	pc = 0x82614050; continue 'dispatch;
	}
	// 8261403C: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82614040: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614044: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82614048: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261404C: 48000044  b 0x82614090
	pc = 0x82614090; continue 'dispatch;
            }
            0x82614050 => {
    //   block [0x82614050..0x8261407C)
	// 82614050: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82614054: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82614058: 419A0024  beq cr6, 0x8261407c
	if ctx.cr[6].eq {
	pc = 0x8261407C; continue 'dispatch;
	}
	// 8261405C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82614060: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614064: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614068: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261406C: 409A0028  bne cr6, 0x82614094
	if !ctx.cr[6].eq {
	pc = 0x82614094; continue 'dispatch;
	}
	// 82614070: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82614074: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82614078: 4800001C  b 0x82614094
	pc = 0x82614094; continue 'dispatch;
            }
            0x8261407C => {
    //   block [0x8261407C..0x82614090)
	// 8261407C: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82614080: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614084: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82614088: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261408C: 409A0008  bne cr6, 0x82614094
	if !ctx.cr[6].eq {
	pc = 0x82614094; continue 'dispatch;
	}
	pc = 0x82614090; continue 'dispatch;
            }
            0x82614090 => {
    //   block [0x82614090..0x82614094)
	// 82614090: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x82614094; continue 'dispatch;
            }
            0x82614094 => {
    //   block [0x82614094..0x826140B0)
	// 82614094: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614098: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 8261409C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 826140A0: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 826140A4: 892A0058  lbz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 826140A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 826140AC: 409A0110  bne cr6, 0x826141bc
	if !ctx.cr[6].eq {
	pc = 0x826141BC; continue 'dispatch;
	}
	pc = 0x826140B0; continue 'dispatch;
            }
            0x826140B0 => {
    //   block [0x826140B0..0x826140F8)
	// 826140B0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826140B4: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 826140B8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 826140BC: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 826140C0: 409A0078  bne cr6, 0x82614138
	if !ctx.cr[6].eq {
	pc = 0x82614138; continue 'dispatch;
	}
	// 826140C4: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 826140C8: 892A0058  lbz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 826140CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 826140D0: 409A0028  bne cr6, 0x826140f8
	if !ctx.cr[6].eq {
	pc = 0x826140F8; continue 'dispatch;
	}
	// 826140D4: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 826140D8: 9BA90058  stb r29, 0x58(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 826140DC: 9BAA0058  stb r29, 0x58(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 826140E0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826140E4: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 826140E8: 9B270058  stb r25, 0x58(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(88 as u32), ctx.r[25].u8 ) };
	// 826140EC: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826140F0: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 826140F4: 480000B4  b 0x826141a8
	pc = 0x826141A8; continue 'dispatch;
            }
            0x826140F8 => {
    //   block [0x826140F8..0x82614110)
	// 826140F8: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 826140FC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82614100: 409A0010  bne cr6, 0x82614110
	if !ctx.cr[6].eq {
	pc = 0x82614110; continue 'dispatch;
	}
	// 82614104: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82614108: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8261410C: 4800024D  bl 0x82614358
	ctx.lr = 0x82614110;
	sub_82614358(ctx, base);
	pc = 0x82614110; continue 'dispatch;
            }
            0x82614110 => {
    //   block [0x82614110..0x82614138)
	// 82614110: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614114: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82614118: 9BAB0058  stb r29, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 8261411C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614120: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614124: 9B290058  stb r25, 0x58(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(88 as u32), ctx.r[25].u8 ) };
	// 82614128: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261412C: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614130: 480002A9  bl 0x826143d8
	ctx.lr = 0x82614134;
	sub_826143D8(ctx, base);
	// 82614134: 48000074  b 0x826141a8
	pc = 0x826141A8; continue 'dispatch;
            }
            0x82614138 => {
    //   block [0x82614138..0x8261416C)
	// 82614138: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261413C: 892A0058  lbz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 82614140: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82614144: 409A0028  bne cr6, 0x8261416c
	if !ctx.cr[6].eq {
	pc = 0x8261416C; continue 'dispatch;
	}
	// 82614148: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261414C: 9BA90058  stb r29, 0x58(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 82614150: 9BAA0058  stb r29, 0x58(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 82614154: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614158: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261415C: 9B270058  stb r25, 0x58(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(88 as u32), ctx.r[25].u8 ) };
	// 82614160: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614164: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614168: 48000040  b 0x826141a8
	pc = 0x826141A8; continue 'dispatch;
            }
            0x8261416C => {
    //   block [0x8261416C..0x82614184)
	// 8261416C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614170: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82614174: 409A0010  bne cr6, 0x82614184
	if !ctx.cr[6].eq {
	pc = 0x82614184; continue 'dispatch;
	}
	// 82614178: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261417C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82614180: 48000259  bl 0x826143d8
	ctx.lr = 0x82614184;
	sub_826143D8(ctx, base);
	pc = 0x82614184; continue 'dispatch;
            }
            0x82614184 => {
    //   block [0x82614184..0x826141A8)
	// 82614184: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614188: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261418C: 9BAB0058  stb r29, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 82614190: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614194: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614198: 9B290058  stb r25, 0x58(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(88 as u32), ctx.r[25].u8 ) };
	// 8261419C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826141A0: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 826141A4: 480001B5  bl 0x82614358
	ctx.lr = 0x826141A8;
	sub_82614358(ctx, base);
	pc = 0x826141A8; continue 'dispatch;
            }
            0x826141A8 => {
    //   block [0x826141A8..0x826141BC)
	// 826141A8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826141AC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826141B0: 892A0058  lbz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 826141B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 826141B8: 419AFEF8  beq cr6, 0x826140b0
	if ctx.cr[6].eq {
	pc = 0x826140B0; continue 'dispatch;
	}
	pc = 0x826141BC; continue 'dispatch;
            }
            0x826141BC => {
    //   block [0x826141BC..0x826141DC)
	// 826141BC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826141C0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 826141C4: 93980004  stw r28, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 826141C8: 93D80000  stw r30, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 826141CC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826141D0: 9BAA0058  stb r29, 0x58(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 826141D4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826141D8: 48695270  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826141E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826141E0 size=40
    let mut pc: u32 = 0x826141E0;
    'dispatch: loop {
        match pc {
            0x826141E0 => {
    //   block [0x826141E0..0x826141F0)
	// 826141E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826141E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826141E8: 409A0008  bne cr6, 0x826141f0
	if !ctx.cr[6].eq {
	pc = 0x826141F0; continue 'dispatch;
	}
	// 826141EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826141F0; continue 'dispatch;
            }
            0x826141F0 => {
    //   block [0x826141F0..0x82614208)
	// 826141F0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826141F4: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 826141F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826141FC: 419A000C  beq cr6, 0x82614208
	if ctx.cr[6].eq {
		sub_82614208(ctx, base);
		return;
	}
	// 82614200: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82614204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82614208 size=60
    let mut pc: u32 = 0x82614208;
    'dispatch: loop {
        match pc {
            0x82614208 => {
    //   block [0x82614208..0x82614228)
	// 82614208: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261420C: 892A0059  lbz r9, 0x59(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(89 as u32) ) } as u64;
	// 82614210: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82614214: 409A0030  bne cr6, 0x82614244
	if !ctx.cr[6].eq {
		sub_82614244(ctx, base);
		return;
	}
	// 82614218: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261421C: 892B0059  lbz r9, 0x59(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82614220: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82614224: 409A0018  bne cr6, 0x8261423c
	if !ctx.cr[6].eq {
	pc = 0x8261423C; continue 'dispatch;
	}
	pc = 0x82614228; continue 'dispatch;
            }
            0x82614228 => {
    //   block [0x82614228..0x8261423C)
	// 82614228: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8261422C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614230: 892B0059  lbz r9, 0x59(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82614234: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82614238: 419AFFF0  beq cr6, 0x82614228
	if ctx.cr[6].eq {
	pc = 0x82614228; continue 'dispatch;
	}
	pc = 0x8261423C; continue 'dispatch;
            }
            0x8261423C => {
    //   block [0x8261423C..0x82614244)
	// 8261423C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82614240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614244(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82614244 size=64
    let mut pc: u32 = 0x82614244;
    'dispatch: loop {
        match pc {
            0x82614244 => {
    //   block [0x82614244..0x82614254)
	// 82614244: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614248: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 8261424C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82614250: 409A002C  bne cr6, 0x8261427c
	if !ctx.cr[6].eq {
	pc = 0x8261427C; continue 'dispatch;
	}
	pc = 0x82614254; continue 'dispatch;
            }
            0x82614254 => {
    //   block [0x82614254..0x8261427C)
	// 82614254: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614258: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261425C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82614260: 409A001C  bne cr6, 0x8261427c
	if !ctx.cr[6].eq {
	pc = 0x8261427C; continue 'dispatch;
	}
	// 82614264: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82614268: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261426C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614270: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82614274: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82614278: 419AFFDC  beq cr6, 0x82614254
	if ctx.cr[6].eq {
	pc = 0x82614254; continue 'dispatch;
	}
	pc = 0x8261427C; continue 'dispatch;
            }
            0x8261427C => {
    //   block [0x8261427C..0x82614284)
	// 8261427C: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82614280: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82614288 size=112
    let mut pc: u32 = 0x82614288;
    'dispatch: loop {
        match pc {
            0x82614288 => {
    //   block [0x82614288..0x826142EC)
	// 82614288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261428C: 48695175  bl 0x82ca9400
	ctx.lr = 0x82614290;
	sub_82CA93D0(ctx, base);
	// 82614290: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82614294: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82614298: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8261429C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826142A0: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 826142A4: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 826142A8: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 826142AC: 4BC0AFAD  bl 0x8221f258
	ctx.lr = 0x826142B0;
	sub_8221F258(ctx, base);
	// 826142B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826142B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826142B8: 419A0034  beq cr6, 0x826142ec
	if ctx.cr[6].eq {
	pc = 0x826142EC; continue 'dispatch;
	}
	// 826142BC: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 826142C0: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 826142C4: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 826142C8: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 826142CC: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 826142D0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 826142D4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826142D8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 826142DC: 4BB82A95  bl 0x82196d70
	ctx.lr = 0x826142E0;
	sub_82196D70(ctx, base);
	// 826142E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826142E4: 9B5F0018  stb r26, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[26].u8 ) };
	// 826142E8: 995F0019  stb r10, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	pc = 0x826142EC; continue 'dispatch;
            }
            0x826142EC => {
    //   block [0x826142EC..0x826142F8)
	// 826142EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826142F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826142F4: 4869515C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826142F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826142F8 size=92
    let mut pc: u32 = 0x826142F8;
    'dispatch: loop {
        match pc {
            0x826142F8 => {
    //   block [0x826142F8..0x8261431C)
	// 826142F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826142FC: 48695111  bl 0x82ca940c
	ctx.lr = 0x82614300;
	sub_82CA93D0(ctx, base);
	// 82614300: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82614304: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82614308: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8261430C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82614310: 897E0059  lbz r11, 0x59(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(89 as u32) ) } as u64;
	// 82614314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82614318: 409A0034  bne cr6, 0x8261434c
	if !ctx.cr[6].eq {
	pc = 0x8261434C; continue 'dispatch;
	}
	pc = 0x8261431C; continue 'dispatch;
            }
            0x8261431C => {
    //   block [0x8261431C..0x8261434C)
	// 8261431C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82614320: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82614324: 4BFFFFD5  bl 0x826142f8
	ctx.lr = 0x82614328;
	sub_826142F8(ctx, base);
	// 82614328: 387E0018  addi r3, r30, 0x18
	ctx.r[3].s64 = ctx.r[30].s64 + 24;
	// 8261432C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614330: 4BFFE409  bl 0x82612738
	ctx.lr = 0x82614334;
	sub_82612738(ctx, base);
	// 82614334: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82614338: 4BC07A01  bl 0x8221bd38
	ctx.lr = 0x8261433C;
	sub_8221BD38(ctx, base);
	// 8261433C: 897F0059  lbz r11, 0x59(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(89 as u32) ) } as u64;
	// 82614340: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82614344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82614348: 419AFFD4  beq cr6, 0x8261431c
	if ctx.cr[6].eq {
	pc = 0x8261431C; continue 'dispatch;
	}
	pc = 0x8261434C; continue 'dispatch;
            }
            0x8261434C => {
    //   block [0x8261434C..0x82614354)
	// 8261434C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82614350: 4869510C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82614358 size=80
    let mut pc: u32 = 0x82614358;
    'dispatch: loop {
        match pc {
            0x82614358 => {
    //   block [0x82614358..0x82614378)
	// 82614358: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261435C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614360: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82614364: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614368: 892A0059  lbz r9, 0x59(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(89 as u32) ) } as u64;
	// 8261436C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82614370: 409A0008  bne cr6, 0x82614378
	if !ctx.cr[6].eq {
	pc = 0x82614378; continue 'dispatch;
	}
	// 82614374: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x82614378; continue 'dispatch;
            }
            0x82614378 => {
    //   block [0x82614378..0x826143A8)
	// 82614378: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8261437C: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614380: 390A8BF4  addi r8, r10, -0x740c
	ctx.r[8].s64 = ctx.r[10].s64 + -29708;
	// 82614384: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82614388: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261438C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614390: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82614394: 409A0014  bne cr6, 0x826143a8
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x826143A8);
		return;
	}
	// 82614398: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8261439C: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 826143A0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826143A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826143D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826143D8 size=80
    let mut pc: u32 = 0x826143D8;
    'dispatch: loop {
        match pc {
            0x826143D8 => {
    //   block [0x826143D8..0x826143F8)
	// 826143D8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 826143DC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826143E0: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826143E4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826143E8: 892A0059  lbz r9, 0x59(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(89 as u32) ) } as u64;
	// 826143EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 826143F0: 409A0008  bne cr6, 0x826143f8
	if !ctx.cr[6].eq {
	pc = 0x826143F8; continue 'dispatch;
	}
	// 826143F4: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x826143F8; continue 'dispatch;
            }
            0x826143F8 => {
    //   block [0x826143F8..0x82614428)
	// 826143F8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 826143FC: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614400: 390A8BF4  addi r8, r10, -0x740c
	ctx.r[8].s64 = ctx.r[10].s64 + -29708;
	// 82614404: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82614408: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261440C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614410: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82614414: 409A0014  bne cr6, 0x82614428
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82614428);
		return;
	}
	// 82614418: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8261441C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82614420: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82614424: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82614458 size=128
    let mut pc: u32 = 0x82614458;
    'dispatch: loop {
        match pc {
            0x82614458 => {
    //   block [0x82614458..0x826144A4)
	// 82614458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261445C: 48694FAD  bl 0x82ca9408
	ctx.lr = 0x82614460;
	sub_82CA93D0(ctx, base);
	// 82614460: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82614464: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82614468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261446C: 897E0019  lbz r11, 0x19(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25 as u32) ) } as u64;
	// 82614470: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614474: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82614478: 409A0054  bne cr6, 0x826144cc
	if !ctx.cr[6].eq {
	pc = 0x826144CC; continue 'dispatch;
	}
	// 8261447C: 5784003E  slwi r4, r28, 0
	ctx.r[4].u32 = ctx.r[28].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82614480: 891E0018  lbz r8, 0x18(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82614484: 38FE000C  addi r7, r30, 0xc
	ctx.r[7].s64 = ctx.r[30].s64 + 12;
	// 82614488: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 8261448C: 4BFFFDFD  bl 0x82614288
	ctx.lr = 0x82614490;
	sub_82614288(ctx, base);
	// 82614490: 897C0019  lbz r11, 0x19(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(25 as u32) ) } as u64;
	// 82614494: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82614498: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261449C: 419A0008  beq cr6, 0x826144a4
	if ctx.cr[6].eq {
	pc = 0x826144A4; continue 'dispatch;
	}
	// 826144A0: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	pc = 0x826144A4; continue 'dispatch;
            }
            0x826144A4 => {
    //   block [0x826144A4..0x826144CC)
	// 826144A4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826144A8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826144AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826144B0: 4BFFFFA9  bl 0x82614458
	ctx.lr = 0x826144B4;
	sub_82614458(ctx, base);
	// 826144B4: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 826144B8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826144BC: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 826144C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826144C4: 4BFFFF95  bl 0x82614458
	ctx.lr = 0x826144C8;
	sub_82614458(ctx, base);
	// 826144C8: 907D0008  stw r3, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	pc = 0x826144CC; continue 'dispatch;
            }
            0x826144CC => {
    //   block [0x826144CC..0x826144D8)
	// 826144CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826144D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826144D4: 48694F84  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826144D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826144D8 size=60
    let mut pc: u32 = 0x826144D8;
    'dispatch: loop {
        match pc {
            0x826144D8 => {
    //   block [0x826144D8..0x826144E8)
	// 826144D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826144DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826144E0: 409A0008  bne cr6, 0x826144e8
	if !ctx.cr[6].eq {
	pc = 0x826144E8; continue 'dispatch;
	}
	// 826144E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826144E8; continue 'dispatch;
            }
            0x826144E8 => {
    //   block [0x826144E8..0x82614514)
	// 826144E8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826144EC: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 826144F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826144F4: 419A0020  beq cr6, 0x82614514
	if ctx.cr[6].eq {
		sub_82614514(ctx, base);
		return;
	}
	// 826144F8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826144FC: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82614500: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82614504: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82614508: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8261450C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82614510: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614514(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82614514 size=60
    let mut pc: u32 = 0x82614514;
    'dispatch: loop {
        match pc {
            0x82614514 => {
    //   block [0x82614514..0x82614534)
	// 82614514: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614518: 892A0059  lbz r9, 0x59(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(89 as u32) ) } as u64;
	// 8261451C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82614520: 409A0030  bne cr6, 0x82614550
	if !ctx.cr[6].eq {
		sub_82614550(ctx, base);
		return;
	}
	// 82614524: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82614528: 892B0059  lbz r9, 0x59(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 8261452C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82614530: 409A0018  bne cr6, 0x82614548
	if !ctx.cr[6].eq {
	pc = 0x82614548; continue 'dispatch;
	}
	pc = 0x82614534; continue 'dispatch;
            }
            0x82614534 => {
    //   block [0x82614534..0x82614548)
	// 82614534: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82614538: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261453C: 892B0059  lbz r9, 0x59(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82614540: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82614544: 419AFFF0  beq cr6, 0x82614534
	if ctx.cr[6].eq {
	pc = 0x82614534; continue 'dispatch;
	}
	pc = 0x82614548; continue 'dispatch;
            }
            0x82614548 => {
    //   block [0x82614548..0x82614550)
	// 82614548: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8261454C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82614550 size=80
    let mut pc: u32 = 0x82614550;
    'dispatch: loop {
        match pc {
            0x82614550 => {
    //   block [0x82614550..0x82614560)
	// 82614550: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614554: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82614558: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261455C: 409A002C  bne cr6, 0x82614588
	if !ctx.cr[6].eq {
	pc = 0x82614588; continue 'dispatch;
	}
	pc = 0x82614560; continue 'dispatch;
            }
            0x82614560 => {
    //   block [0x82614560..0x82614588)
	// 82614560: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614564: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614568: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8261456C: 409A001C  bne cr6, 0x82614588
	if !ctx.cr[6].eq {
	pc = 0x82614588; continue 'dispatch;
	}
	// 82614570: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82614574: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82614578: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261457C: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 82614580: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82614584: 419AFFDC  beq cr6, 0x82614560
	if ctx.cr[6].eq {
	pc = 0x82614560; continue 'dispatch;
	}
	pc = 0x82614588; continue 'dispatch;
            }
            0x82614588 => {
    //   block [0x82614588..0x826145A0)
	// 82614588: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261458C: 892A0059  lbz r9, 0x59(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(89 as u32) ) } as u64;
	// 82614590: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82614594: 409AFF78  bne cr6, 0x8261450c
	if !ctx.cr[6].eq {
		sub_826144D8(ctx, base);
		return;
	}
	// 82614598: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8261459C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826145A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826145A0 size=108
    let mut pc: u32 = 0x826145A0;
    'dispatch: loop {
        match pc {
            0x826145A0 => {
    //   block [0x826145A0..0x826145C0)
	// 826145A0: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 826145A4: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 826145A8: F881FFF0  std r4, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u64 ) };
	// 826145AC: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 826145B0: 80810024  lwz r4, 0x24(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 826145B4: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 826145B8: 419A0020  beq cr6, 0x826145d8
	if ctx.cr[6].eq {
	pc = 0x826145D8; continue 'dispatch;
	}
	// 826145BC: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x826145C0; continue 'dispatch;
            }
            0x826145C0 => {
    //   block [0x826145C0..0x826145D8)
	// 826145C0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826145C4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 826145C8: 419A0010  beq cr6, 0x826145d8
	if ctx.cr[6].eq {
	pc = 0x826145D8; continue 'dispatch;
	}
	// 826145CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826145D0: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 826145D4: 409AFFEC  bne cr6, 0x826145c0
	if !ctx.cr[6].eq {
	pc = 0x826145C0; continue 'dispatch;
	}
	pc = 0x826145D8; continue 'dispatch;
            }
            0x826145D8 => {
    //   block [0x826145D8..0x826145F4)
	// 826145D8: 8141FFF0  lwz r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 826145DC: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 826145E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826145E4: 419A0010  beq cr6, 0x826145f4
	if ctx.cr[6].eq {
	pc = 0x826145F4; continue 'dispatch;
	}
	// 826145E8: 81210020  lwz r9, 0x20(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) } as u64;
	// 826145EC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 826145F0: 419A0008  beq cr6, 0x826145f8
	if ctx.cr[6].eq {
	pc = 0x826145F8; continue 'dispatch;
	}
	pc = 0x826145F4; continue 'dispatch;
            }
            0x826145F4 => {
    //   block [0x826145F4..0x826145F8)
	// 826145F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826145F8; continue 'dispatch;
            }
            0x826145F8 => {
    //   block [0x826145F8..0x8261460C)
	// 826145F8: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 826145FC: 409A0010  bne cr6, 0x8261460c
	if !ctx.cr[6].eq {
		sub_8261460C(ctx, base);
		return;
	}
	// 82614600: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82614604: F9630000  std r11, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82614608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261460C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8261460C size=180
    let mut pc: u32 = 0x8261460C;
    'dispatch: loop {
        match pc {
            0x8261460C => {
    //   block [0x8261460C..0x82614618)
	// 8261460C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82614610: 409A0008  bne cr6, 0x82614618
	if !ctx.cr[6].eq {
	pc = 0x82614618; continue 'dispatch;
	}
	// 82614614: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82614618; continue 'dispatch;
            }
            0x82614618 => {
    //   block [0x82614618..0x82614628)
	// 82614618: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261461C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82614620: 41980008  blt cr6, 0x82614628
	if ctx.cr[6].lt {
	pc = 0x82614628; continue 'dispatch;
	}
	// 82614624: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82614628; continue 'dispatch;
            }
            0x82614628 => {
    //   block [0x82614628..0x82614648)
	// 82614628: E901FFF0  ld r8, -0x10(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261462C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82614630: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82614634: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82614638: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 8261463C: 419A007C  beq cr6, 0x826146b8
	if ctx.cr[6].eq {
	pc = 0x826146B8; continue 'dispatch;
	}
	// 82614640: 80A1FFF0  lwz r5, -0x10(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82614644: 80E1FFF4  lwz r7, -0xc(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	pc = 0x82614648; continue 'dispatch;
            }
            0x82614648 => {
    //   block [0x82614648..0x82614668)
	// 82614648: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261464C: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614650: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82614654: 419A0058  beq cr6, 0x826146ac
	if ctx.cr[6].eq {
	pc = 0x826146AC; continue 'dispatch;
	}
	// 82614658: F901FFF8  std r8, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[8].u64 ) };
	// 8261465C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82614660: 409A0008  bne cr6, 0x82614668
	if !ctx.cr[6].eq {
	pc = 0x82614668; continue 'dispatch;
	}
	// 82614664: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82614668; continue 'dispatch;
            }
            0x82614668 => {
    //   block [0x82614668..0x82614678)
	// 82614668: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261466C: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82614670: 41980008  blt cr6, 0x82614678
	if ctx.cr[6].lt {
	pc = 0x82614678; continue 'dispatch;
	}
	// 82614674: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82614678; continue 'dispatch;
            }
            0x82614678 => {
    //   block [0x82614678..0x82614690)
	// 82614678: 8161FFF8  lwz r11, -8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261467C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82614680: 90E1FFF4  stw r7, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[7].u32 ) };
	// 82614684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82614688: 409A0008  bne cr6, 0x82614690
	if !ctx.cr[6].eq {
	pc = 0x82614690; continue 'dispatch;
	}
	// 8261468C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82614690; continue 'dispatch;
            }
            0x82614690 => {
    //   block [0x82614690..0x826146A4)
	// 82614690: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82614694: 8161FFFC  lwz r11, -4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82614698: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8261469C: 41980008  blt cr6, 0x826146a4
	if ctx.cr[6].lt {
	pc = 0x826146A4; continue 'dispatch;
	}
	// 826146A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826146A4; continue 'dispatch;
            }
            0x826146A4 => {
    //   block [0x826146A4..0x826146AC)
	// 826146A4: E901FFF0  ld r8, -0x10(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826146A8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x826146AC; continue 'dispatch;
            }
            0x826146AC => {
    //   block [0x826146AC..0x826146B8)
	// 826146AC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 826146B0: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 826146B4: 409AFF94  bne cr6, 0x82614648
	if !ctx.cr[6].eq {
	pc = 0x82614648; continue 'dispatch;
	}
	pc = 0x826146B8; continue 'dispatch;
            }
            0x826146B8 => {
    //   block [0x826146B8..0x826146C0)
	// 826146B8: F9030000  std r8, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 826146BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826146C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826146C0 size=584
    let mut pc: u32 = 0x826146C0;
    'dispatch: loop {
        match pc {
            0x826146C0 => {
    //   block [0x826146C0..0x826146E8)
	// 826146C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826146C4: 48694D3D  bl 0x82ca9400
	ctx.lr = 0x826146C8;
	sub_82CA93D0(ctx, base);
	// 826146C8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826146CC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 826146D0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826146D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826146D8: 409A0010  bne cr6, 0x826146e8
	if !ctx.cr[6].eq {
	pc = 0x826146E8; continue 'dispatch;
	}
	// 826146DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 826146E0: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 826146E4: 48000008  b 0x826146ec
	pc = 0x826146EC; continue 'dispatch;
            }
            0x826146E8 => {
    //   block [0x826146E8..0x826146EC)
	// 826146E8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x826146EC; continue 'dispatch;
            }
            0x826146EC => {
    //   block [0x826146EC..0x82614764)
	// 826146EC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826146F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826146F4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826146F8: 4BDB9EC9  bl 0x823ce5c0
	ctx.lr = 0x826146FC;
	sub_823CE5C0(ctx, base);
	// 826146FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82614700: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82614704: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82614708: 4BDB9AF9  bl 0x823ce200
	ctx.lr = 0x8261470C;
	sub_823CE200(ctx, base);
	// 8261470C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82614710: 4BBA3409  bl 0x821b7b18
	ctx.lr = 0x82614714;
	sub_821B7B18(ctx, base);
	// 82614714: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82614718: 4BC0AB41  bl 0x8221f258
	ctx.lr = 0x8261471C;
	sub_8221F258(ctx, base);
	// 8261471C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82614720: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82614724: 419A0040  beq cr6, 0x82614764
	if ctx.cr[6].eq {
	pc = 0x82614764; continue 'dispatch;
	}
	// 82614728: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8261472C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82614730: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 82614734: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82614738: 4BC0AB21  bl 0x8221f258
	ctx.lr = 0x8261473C;
	sub_8221F258(ctx, base);
	// 8261473C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82614740: 419A0028  beq cr6, 0x82614768
	if ctx.cr[6].eq {
	pc = 0x82614768; continue 'dispatch;
	}
	// 82614744: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82614748: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 8261474C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82614750: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82614754: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82614758: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8261475C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82614760: 4800000C  b 0x8261476c
	pc = 0x8261476C; continue 'dispatch;
            }
            0x82614764 => {
    //   block [0x82614764..0x82614768)
	// 82614764: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82614768; continue 'dispatch;
            }
            0x82614768 => {
    //   block [0x82614768..0x8261476C)
	// 82614768: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8261476C; continue 'dispatch;
            }
            0x8261476C => {
    //   block [0x8261476C..0x82614870)
	// 8261476C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82614770: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82614774: 419A00FC  beq cr6, 0x82614870
	if ctx.cr[6].eq {
	pc = 0x82614870; continue 'dispatch;
	}
	// 82614778: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261477C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82614780: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614784: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82614788: 4BC14981  bl 0x82229108
	ctx.lr = 0x8261478C;
	sub_82229108(ctx, base);
	// 8261478C: 3D608261  lis r11, -0x7d9f
	ctx.r[11].s64 = -2107572224;
	// 82614790: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82614794: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82614798: 3BCB4B10  addi r30, r11, 0x4b10
	ctx.r[30].s64 = ctx.r[11].s64 + 19216;
	// 8261479C: 4BC130E5  bl 0x82227880
	ctx.lr = 0x826147A0;
	sub_82227880(ctx, base);
	// 826147A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826147A4: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 826147A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826147AC: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 826147B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826147B4: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 826147B8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 826147BC: 4BB862C5  bl 0x8219aa80
	ctx.lr = 0x826147C0;
	sub_8219AA80(ctx, base);
	// 826147C0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 826147C4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826147C8: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 826147CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826147D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826147D4: 4BDB9C4D  bl 0x823ce420
	ctx.lr = 0x826147D8;
	sub_823CE420(ctx, base);
	// 826147D8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826147DC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 826147E0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826147E4: 4840FEE5  bl 0x82a246c8
	ctx.lr = 0x826147E8;
	sub_82A246C8(ctx, base);
	// 826147E8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 826147EC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 826147F0: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 826147F4: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 826147F8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826147FC: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614800: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82614804: 4BC14905  bl 0x82229108
	ctx.lr = 0x82614808;
	sub_82229108(ctx, base);
	// 82614808: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8261480C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82614810: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82614814: 3BEBA6B0  addi r31, r11, -0x5950
	ctx.r[31].s64 = ctx.r[11].s64 + -22864;
	// 82614818: 4BC13069  bl 0x82227880
	ctx.lr = 0x8261481C;
	sub_82227880(ctx, base);
	// 8261481C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82614820: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 82614824: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82614828: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 8261482C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82614830: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82614834: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82614838: 4BB86249  bl 0x8219aa80
	ctx.lr = 0x8261483C;
	sub_8219AA80(ctx, base);
	// 8261483C: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 82614840: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82614844: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 82614848: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261484C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82614850: 4BDB9BD1  bl 0x823ce420
	ctx.lr = 0x82614854;
	sub_823CE420(ctx, base);
	// 82614854: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82614858: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8261485C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82614860: 4840FE69  bl 0x82a246c8
	ctx.lr = 0x82614864;
	sub_82A246C8(ctx, base);
	// 82614864: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82614868: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 8261486C: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x82614870; continue 'dispatch;
            }
            0x82614870 => {
    //   block [0x82614870..0x82614880)
	// 82614870: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82614874: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82614878: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 8261487C: 419A0020  beq cr6, 0x8261489c
	if ctx.cr[6].eq {
	pc = 0x8261489C; continue 'dispatch;
	}
	pc = 0x82614880; continue 'dispatch;
            }
            0x82614880 => {
    //   block [0x82614880..0x8261489C)
	// 82614880: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82614884: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82614888: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8261488C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82614890: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82614894: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82614898: 4082FFE8  bne 0x82614880
	if !ctx.cr[0].eq {
	pc = 0x82614880; continue 'dispatch;
	}
	pc = 0x8261489C; continue 'dispatch;
            }
            0x8261489C => {
    //   block [0x8261489C..0x826148BC)
	// 8261489C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826148A0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826148A4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 826148A8: 4BCE10A1  bl 0x822f5948
	ctx.lr = 0x826148AC;
	sub_822F5948(ctx, base);
	// 826148AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826148B0: 4BBA3269  bl 0x821b7b18
	ctx.lr = 0x826148B4;
	sub_821B7B18(ctx, base);
	// 826148B4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826148B8: 419A0040  beq cr6, 0x826148f8
	if ctx.cr[6].eq {
	pc = 0x826148F8; continue 'dispatch;
	}
	pc = 0x826148BC; continue 'dispatch;
            }
            0x826148BC => {
    //   block [0x826148BC..0x826148F8)
	// 826148BC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 826148C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826148C4: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 826148C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 826148CC: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826148D0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826148D4: 4082FFE8  bne 0x826148bc
	if !ctx.cr[0].eq {
	pc = 0x826148BC; continue 'dispatch;
	}
	// 826148D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826148DC: 409A001C  bne cr6, 0x826148f8
	if !ctx.cr[6].eq {
	pc = 0x826148F8; continue 'dispatch;
	}
	// 826148E0: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 826148E4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 826148E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826148EC: 4E800421  bctrl
	ctx.lr = 0x826148F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826148F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826148F4: 4BC07445  bl 0x8221bd38
	ctx.lr = 0x826148F8;
	sub_8221BD38(ctx, base);
            }
            0x826148F8 => {
    //   block [0x826148F8..0x82614908)
	// 826148F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826148FC: 4BBA321D  bl 0x821b7b18
	ctx.lr = 0x82614900;
	sub_821B7B18(ctx, base);
	// 82614900: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82614904: 48694B4C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82614908 size=516
    let mut pc: u32 = 0x82614908;
    'dispatch: loop {
        match pc {
            0x82614908 => {
    //   block [0x82614908..0x82614944)
	// 82614908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261490C: 48694AF1  bl 0x82ca93fc
	ctx.lr = 0x82614910;
	sub_82CA93D0(ctx, base);
	// 82614910: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82614914: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82614918: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 8261491C: 3D408261  lis r10, -0x7d9f
	ctx.r[10].s64 = -2107572224;
	// 82614920: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 82614924: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82614928: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261492C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82614930: 3BAAEF68  addi r29, r10, -0x1098
	ctx.r[29].s64 = ctx.r[10].s64 + -4248;
	// 82614934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82614938: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8261493C: 419A0008  beq cr6, 0x82614944
	if ctx.cr[6].eq {
	pc = 0x82614944; continue 'dispatch;
	}
	// 82614940: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82614944; continue 'dispatch;
            }
            0x82614944 => {
    //   block [0x82614944..0x826149D8)
	// 82614944: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614948: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8261494C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614950: 4BDB9C71  bl 0x823ce5c0
	ctx.lr = 0x82614954;
	sub_823CE5C0(ctx, base);
	// 82614954: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82614958: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8261495C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82614960: 4BDB97B1  bl 0x823ce110
	ctx.lr = 0x82614964;
	sub_823CE110(ctx, base);
	// 82614964: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82614968: 4BBA31B1  bl 0x821b7b18
	ctx.lr = 0x8261496C;
	sub_821B7B18(ctx, base);
	// 8261496C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82614970: 4BC0A8E9  bl 0x8221f258
	ctx.lr = 0x82614974;
	sub_8221F258(ctx, base);
	// 82614974: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82614978: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261497C: 419A005C  beq cr6, 0x826149d8
	if ctx.cr[6].eq {
	pc = 0x826149D8; continue 'dispatch;
	}
	// 82614980: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82614984: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82614988: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8261498C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 82614990: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82614994: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82614998: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8261499C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 826149A0: 4BBDB8A1  bl 0x821f0240
	ctx.lr = 0x826149A4;
	sub_821F0240(ctx, base);
	// 826149A4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826149A8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 826149AC: 4BC0A8AD  bl 0x8221f258
	ctx.lr = 0x826149B0;
	sub_8221F258(ctx, base);
	// 826149B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826149B4: 419A0028  beq cr6, 0x826149dc
	if ctx.cr[6].eq {
	pc = 0x826149DC; continue 'dispatch;
	}
	// 826149B8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 826149BC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 826149C0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826149C4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 826149C8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826149CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826149D0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 826149D4: 4800000C  b 0x826149e0
	pc = 0x826149E0; continue 'dispatch;
            }
            0x826149D8 => {
    //   block [0x826149D8..0x826149DC)
	// 826149D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x826149DC; continue 'dispatch;
            }
            0x826149DC => {
    //   block [0x826149DC..0x826149E0)
	// 826149DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x826149E0; continue 'dispatch;
            }
            0x826149E0 => {
    //   block [0x826149E0..0x826149F4)
	// 826149E0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826149E4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 826149E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826149EC: 419A0008  beq cr6, 0x826149f4
	if ctx.cr[6].eq {
	pc = 0x826149F4; continue 'dispatch;
	}
	// 826149F0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x826149F4; continue 'dispatch;
            }
            0x826149F4 => {
    //   block [0x826149F4..0x82614A74)
	// 826149F4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826149F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826149FC: 419A0078  beq cr6, 0x82614a74
	if ctx.cr[6].eq {
	pc = 0x82614A74; continue 'dispatch;
	}
	// 82614A00: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614A04: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82614A08: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614A0C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82614A10: 4BC146F9  bl 0x82229108
	ctx.lr = 0x82614A14;
	sub_82229108(ctx, base);
	// 82614A14: 3D608261  lis r11, -0x7d9f
	ctx.r[11].s64 = -2107572224;
	// 82614A18: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82614A1C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82614A20: 3BCB4B50  addi r30, r11, 0x4b50
	ctx.r[30].s64 = ctx.r[11].s64 + 19280;
	// 82614A24: 4BC12E5D  bl 0x82227880
	ctx.lr = 0x82614A28;
	sub_82227880(ctx, base);
	// 82614A28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82614A2C: 3D40827C  lis r10, -0x7d84
	ctx.r[10].s64 = -2105802752;
	// 82614A30: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82614A34: 388AD6C8  addi r4, r10, -0x2938
	ctx.r[4].s64 = ctx.r[10].s64 + -10552;
	// 82614A38: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82614A3C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82614A40: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82614A44: 4BB8603D  bl 0x8219aa80
	ctx.lr = 0x82614A48;
	sub_8219AA80(ctx, base);
	// 82614A48: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82614A4C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82614A50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82614A54: 4BDB99CD  bl 0x823ce420
	ctx.lr = 0x82614A58;
	sub_823CE420(ctx, base);
	// 82614A58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82614A5C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82614A60: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82614A64: 4840FC65  bl 0x82a246c8
	ctx.lr = 0x82614A68;
	sub_82A246C8(ctx, base);
	// 82614A68: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82614A6C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82614A70: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82614A74; continue 'dispatch;
            }
            0x82614A74 => {
    //   block [0x82614A74..0x82614A84)
	// 82614A74: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82614A78: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82614A7C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82614A80: 419A0020  beq cr6, 0x82614aa0
	if ctx.cr[6].eq {
	pc = 0x82614AA0; continue 'dispatch;
	}
	pc = 0x82614A84; continue 'dispatch;
            }
            0x82614A84 => {
    //   block [0x82614A84..0x82614AA0)
	// 82614A84: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82614A88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82614A8C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82614A90: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82614A94: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82614A98: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82614A9C: 4082FFE8  bne 0x82614a84
	if !ctx.cr[0].eq {
	pc = 0x82614A84; continue 'dispatch;
	}
	pc = 0x82614AA0; continue 'dispatch;
            }
            0x82614AA0 => {
    //   block [0x82614AA0..0x82614AC0)
	// 82614AA0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614AA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82614AA8: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82614AAC: 4BCE0E9D  bl 0x822f5948
	ctx.lr = 0x82614AB0;
	sub_822F5948(ctx, base);
	// 82614AB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82614AB4: 4BBA3065  bl 0x821b7b18
	ctx.lr = 0x82614AB8;
	sub_821B7B18(ctx, base);
	// 82614AB8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82614ABC: 419A0040  beq cr6, 0x82614afc
	if ctx.cr[6].eq {
	pc = 0x82614AFC; continue 'dispatch;
	}
	pc = 0x82614AC0; continue 'dispatch;
            }
            0x82614AC0 => {
    //   block [0x82614AC0..0x82614AFC)
	// 82614AC0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82614AC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82614AC8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82614ACC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82614AD0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82614AD4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82614AD8: 4082FFE8  bne 0x82614ac0
	if !ctx.cr[0].eq {
	pc = 0x82614AC0; continue 'dispatch;
	}
	// 82614ADC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82614AE0: 409A001C  bne cr6, 0x82614afc
	if !ctx.cr[6].eq {
	pc = 0x82614AFC; continue 'dispatch;
	}
	// 82614AE4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82614AE8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614AEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82614AF0: 4E800421  bctrl
	ctx.lr = 0x82614AF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82614AF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82614AF8: 4BC07241  bl 0x8221bd38
	ctx.lr = 0x82614AFC;
	sub_8221BD38(ctx, base);
            }
            0x82614AFC => {
    //   block [0x82614AFC..0x82614B0C)
	// 82614AFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82614B00: 4BBA3019  bl 0x821b7b18
	ctx.lr = 0x82614B04;
	sub_821B7B18(ctx, base);
	// 82614B04: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82614B08: 48694944  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82614B10 size=56
    let mut pc: u32 = 0x82614B10;
    'dispatch: loop {
        match pc {
            0x82614B10 => {
    //   block [0x82614B10..0x82614B2C)
	// 82614B10: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82614B14: 419A0018  beq cr6, 0x82614b2c
	if ctx.cr[6].eq {
	pc = 0x82614B2C; continue 'dispatch;
	}
	// 82614B18: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82614B1C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82614B20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82614B24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82614B28: 409A0008  bne cr6, 0x82614b30
	if !ctx.cr[6].eq {
	pc = 0x82614B30; continue 'dispatch;
	}
	pc = 0x82614B2C; continue 'dispatch;
            }
            0x82614B2C => {
    //   block [0x82614B2C..0x82614B30)
	// 82614B2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82614B30; continue 'dispatch;
            }
            0x82614B30 => {
    //   block [0x82614B30..0x82614B48)
	// 82614B30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82614B34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82614B38: 419A0010  beq cr6, 0x82614b48
	if ctx.cr[6].eq {
		sub_82614B48(ctx, base);
		return;
	}
	// 82614B3C: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 82614B40: 556397FE  rlwinm r3, r11, 0x12, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00003FFFu64;
	// 82614B44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82614B48 size=8
    let mut pc: u32 = 0x82614B48;
    'dispatch: loop {
        match pc {
            0x82614B48 => {
    //   block [0x82614B48..0x82614B50)
	// 82614B48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82614B4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82614B50 size=376
    let mut pc: u32 = 0x82614B50;
    'dispatch: loop {
        match pc {
            0x82614B50 => {
    //   block [0x82614B50..0x82614B7C)
	// 82614B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82614B54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82614B58: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82614B5C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82614B60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82614B64: 419A0018  beq cr6, 0x82614b7c
	if ctx.cr[6].eq {
	pc = 0x82614B7C; continue 'dispatch;
	}
	// 82614B68: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82614B6C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82614B70: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82614B74: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82614B78: 409A0008  bne cr6, 0x82614b80
	if !ctx.cr[6].eq {
	pc = 0x82614B80; continue 'dispatch;
	}
	pc = 0x82614B7C; continue 'dispatch;
            }
            0x82614B7C => {
    //   block [0x82614B7C..0x82614B80)
	// 82614B7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82614B80; continue 'dispatch;
            }
            0x82614B80 => {
    //   block [0x82614B80..0x82614BCC)
	// 82614B80: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82614B84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82614B88: 419A0130  beq cr6, 0x82614cb8
	if ctx.cr[6].eq {
	pc = 0x82614CB8; continue 'dispatch;
	}
	// 82614B8C: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82614B90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82614B94: 552897FE  rlwinm r8, r9, 0x12, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00003FFFu64;
	// 82614B98: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82614B9C: 419A00F8  beq cr6, 0x82614c94
	if ctx.cr[6].eq {
	pc = 0x82614C94; continue 'dispatch;
	}
	// 82614BA0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82614BA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82614BA8: 419A0024  beq cr6, 0x82614bcc
	if ctx.cr[6].eq {
	pc = 0x82614BCC; continue 'dispatch;
	}
	// 82614BAC: 892A000E  lbz r9, 0xe(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(14 as u32) ) } as u64;
	// 82614BB0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82614BB4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82614BB8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82614BBC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614BC0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82614BC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82614BC8: 480000D0  b 0x82614c98
	pc = 0x82614C98; continue 'dispatch;
            }
            0x82614BCC => {
    //   block [0x82614BCC..0x82614BEC)
	// 82614BCC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82614BD0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82614BD4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82614BD8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82614BDC: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82614BE0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82614BE4: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82614BE8: 40810054  ble 0x82614c3c
	if !ctx.cr[0].gt {
	pc = 0x82614C3C; continue 'dispatch;
	}
	pc = 0x82614BEC; continue 'dispatch;
            }
            0x82614BEC => {
    //   block [0x82614BEC..0x82614C0C)
	// 82614BEC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82614BF0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82614BF4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82614BF8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614BFC: 2F07000E  cmpwi cr6, r7, 0xe
	ctx.cr[6].compare_i32(ctx.r[7].s32, 14, &mut ctx.xer);
	// 82614C00: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82614C04: 41980008  blt cr6, 0x82614c0c
	if ctx.cr[6].lt {
	pc = 0x82614C0C; continue 'dispatch;
	}
	// 82614C08: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82614C0C; continue 'dispatch;
            }
            0x82614C0C => {
    //   block [0x82614C0C..0x82614C28)
	// 82614C0C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82614C10: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82614C14: 419A0014  beq cr6, 0x82614c28
	if ctx.cr[6].eq {
	pc = 0x82614C28; continue 'dispatch;
	}
	// 82614C18: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82614C1C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82614C20: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82614C24: 4800000C  b 0x82614c30
	pc = 0x82614C30; continue 'dispatch;
            }
            0x82614C28 => {
    //   block [0x82614C28..0x82614C30)
	// 82614C28: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82614C2C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82614C30; continue 'dispatch;
            }
            0x82614C30 => {
    //   block [0x82614C30..0x82614C3C)
	// 82614C30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82614C34: 4199FFB8  bgt cr6, 0x82614bec
	if ctx.cr[6].gt {
	pc = 0x82614BEC; continue 'dispatch;
	}
	// 82614C38: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82614C3C; continue 'dispatch;
            }
            0x82614C3C => {
    //   block [0x82614C3C..0x82614C58)
	// 82614C3C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82614C40: 419A0040  beq cr6, 0x82614c80
	if ctx.cr[6].eq {
	pc = 0x82614C80; continue 'dispatch;
	}
	// 82614C44: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614C48: 2F0B000E  cmpwi cr6, r11, 0xe
	ctx.cr[6].compare_i32(ctx.r[11].s32, 14, &mut ctx.xer);
	// 82614C4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82614C50: 41990008  bgt cr6, 0x82614c58
	if ctx.cr[6].gt {
	pc = 0x82614C58; continue 'dispatch;
	}
	// 82614C54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82614C58; continue 'dispatch;
            }
            0x82614C58 => {
    //   block [0x82614C58..0x82614C80)
	// 82614C58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82614C5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82614C60: 409A0020  bne cr6, 0x82614c80
	if !ctx.cr[6].eq {
	pc = 0x82614C80; continue 'dispatch;
	}
	// 82614C64: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82614C68: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82614C6C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82614C70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614C74: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82614C78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82614C7C: 4800001C  b 0x82614c98
	pc = 0x82614C98; continue 'dispatch;
            }
            0x82614C80 => {
    //   block [0x82614C80..0x82614C94)
	// 82614C80: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82614C84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614C88: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82614C8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82614C90: 48000008  b 0x82614c98
	pc = 0x82614C98; continue 'dispatch;
            }
            0x82614C94 => {
    //   block [0x82614C94..0x82614C98)
	// 82614C94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82614C98; continue 'dispatch;
            }
            0x82614C98 => {
    //   block [0x82614C98..0x82614CB8)
	// 82614C98: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82614C9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82614CA0: 419A0018  beq cr6, 0x82614cb8
	if ctx.cr[6].eq {
	pc = 0x82614CB8; continue 'dispatch;
	}
	// 82614CA4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614CA8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82614CAC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82614CB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82614CB4: 4E800421  bctrl
	ctx.lr = 0x82614CB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82614CB8 => {
    //   block [0x82614CB8..0x82614CC8)
	// 82614CB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82614CBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82614CC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82614CC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82614CC8 size=224
    let mut pc: u32 = 0x82614CC8;
    'dispatch: loop {
        match pc {
            0x82614CC8 => {
    //   block [0x82614CC8..0x82614D04)
	// 82614CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82614CCC: 48694741  bl 0x82ca940c
	ctx.lr = 0x82614CD0;
	sub_82CA93D0(ctx, base);
	// 82614CD0: 81030010  lwz r8, 0x10(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82614CD4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82614CD8: 81680024  lwz r11, 0x24(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(36 as u32) ) } as u64;
	// 82614CDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82614CE0: 409A007C  bne cr6, 0x82614d5c
	if !ctx.cr[6].eq {
	pc = 0x82614D5C; continue 'dispatch;
	}
	// 82614CE4: 80C80030  lwz r6, 0x30(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(48 as u32) ) } as u64;
	// 82614CE8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82614CEC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82614CF0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82614CF4: 419A0054  beq cr6, 0x82614d48
	if ctx.cr[6].eq {
	pc = 0x82614D48; continue 'dispatch;
	}
	// 82614CF8: 83E80034  lwz r31, 0x34(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(52 as u32) ) } as u64;
	// 82614CFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82614D00: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	pc = 0x82614D04; continue 'dispatch;
            }
            0x82614D04 => {
    //   block [0x82614D04..0x82614D34)
	// 82614D04: 83C90000  lwz r30, 0(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614D08: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82614D0C: 419A0028  beq cr6, 0x82614d34
	if ctx.cr[6].eq {
	pc = 0x82614D34; continue 'dispatch;
	}
	// 82614D10: 83C80038  lwz r30, 0x38(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(56 as u32) ) } as u64;
	// 82614D14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82614D18: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614D1C: 7FDE582E  lwzx r30, r30, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82614D20: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82614D24: 409A0010  bne cr6, 0x82614d34
	if !ctx.cr[6].eq {
	pc = 0x82614D34; continue 'dispatch;
	}
	// 82614D28: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82614D2C: 419A0024  beq cr6, 0x82614d50
	if ctx.cr[6].eq {
	pc = 0x82614D50; continue 'dispatch;
	}
	// 82614D30: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	pc = 0x82614D34; continue 'dispatch;
            }
            0x82614D34 => {
    //   block [0x82614D34..0x82614D48)
	// 82614D34: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82614D38: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82614D3C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82614D40: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82614D44: 4198FFC0  blt cr6, 0x82614d04
	if ctx.cr[6].lt {
	pc = 0x82614D04; continue 'dispatch;
	}
	pc = 0x82614D48; continue 'dispatch;
            }
            0x82614D48 => {
    //   block [0x82614D48..0x82614D50)
	// 82614D48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82614D4C: 48694710  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82614D50 => {
    //   block [0x82614D50..0x82614D5C)
	// 82614D50: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82614D54: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82614D58: 48694704  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82614D5C => {
    //   block [0x82614D5C..0x82614D70)
	// 82614D5C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614D60: 5527103A  slwi r7, r9, 2
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82614D64: 7D67582E  lwzx r11, r7, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82614D68: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82614D6C: 419AFFDC  beq cr6, 0x82614d48
	if ctx.cr[6].eq {
	pc = 0x82614D48; continue 'dispatch;
	}
	pc = 0x82614D70; continue 'dispatch;
            }
            0x82614D70 => {
    //   block [0x82614D70..0x82614D98)
	// 82614D70: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82614D74: 419A0024  beq cr6, 0x82614d98
	if ctx.cr[6].eq {
	pc = 0x82614D98; continue 'dispatch;
	}
	// 82614D78: 81280044  lwz r9, 0x44(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(68 as u32) ) } as u64;
	// 82614D7C: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82614D80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82614D84: 7D67482E  lwzx r11, r7, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82614D88: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82614D8C: 409AFFE4  bne cr6, 0x82614d70
	if !ctx.cr[6].eq {
	pc = 0x82614D70; continue 'dispatch;
	}
	// 82614D90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82614D94: 486946C8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82614D98 => {
    //   block [0x82614D98..0x82614DA8)
	// 82614D98: 81480034  lwz r10, 0x34(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(52 as u32) ) } as u64;
	// 82614D9C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82614DA0: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82614DA4: 486946B8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82614DA8 size=340
    let mut pc: u32 = 0x82614DA8;
    'dispatch: loop {
        match pc {
            0x82614DA8 => {
    //   block [0x82614DA8..0x82614DF4)
	// 82614DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82614DAC: 4869465D  bl 0x82ca9408
	ctx.lr = 0x82614DB0;
	sub_82CA93D0(ctx, base);
	// 82614DB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82614DB4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82614DB8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82614DBC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614DC0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82614DC4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82614DC8: 4E800421  bctrl
	ctx.lr = 0x82614DCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82614DCC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82614DD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82614DD4: 4BFFFEF5  bl 0x82614cc8
	ctx.lr = 0x82614DD8;
	sub_82614CC8(ctx, base);
	// 82614DD8: 813D0010  lwz r9, 0x10(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82614DDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82614DE0: 83C90044  lwz r30, 0x44(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(68 as u32) ) } as u64;
	// 82614DE4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82614DE8: 419A00BC  beq cr6, 0x82614ea4
	if ctx.cr[6].eq {
	pc = 0x82614EA4; continue 'dispatch;
	}
	// 82614DEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82614DF0: 419A0100  beq cr6, 0x82614ef0
	if ctx.cr[6].eq {
	pc = 0x82614EF0; continue 'dispatch;
	}
            }
            0x82614DF4 => {
    //   block [0x82614DF4..0x82614E98)
	// 82614DF4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82614DF8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614DFC: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82614E00: 810B0038  lwz r8, 0x38(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82614E04: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82614E08: 7D69402E  lwzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82614E0C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82614E10: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82614E14: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82614E18: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82614E1C: 7F06E840  cmplw cr6, r6, r29
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82614E20: 409A00D0  bne cr6, 0x82614ef0
	if !ctx.cr[6].eq {
	pc = 0x82614EF0; continue 'dispatch;
	}
	// 82614E24: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614E28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82614E2C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82614E30: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82614E34: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82614E38: 4E800421  bctrl
	ctx.lr = 0x82614E3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82614E3C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82614E40: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82614E44: 419A0054  beq cr6, 0x82614e98
	if ctx.cr[6].eq {
	pc = 0x82614E98; continue 'dispatch;
	}
	// 82614E48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614E4C: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82614E50: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82614E54: 7D69F02E  lwzx r11, r9, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82614E58: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82614E5C: 419A0094  beq cr6, 0x82614ef0
	if ctx.cr[6].eq {
	pc = 0x82614EF0; continue 'dispatch;
	}
	// 82614E60: 812A0028  lwz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82614E64: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82614E68: 40980088  bge cr6, 0x82614ef0
	if !ctx.cr[6].lt {
	pc = 0x82614EF0; continue 'dispatch;
	}
	// 82614E6C: 814A0034  lwz r10, 0x34(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 82614E70: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82614E74: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82614E78: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82614E7C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82614E80: 419A0070  beq cr6, 0x82614ef0
	if ctx.cr[6].eq {
	pc = 0x82614EF0; continue 'dispatch;
	}
	// 82614E84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82614E88: 409AFF6C  bne cr6, 0x82614df4
	if !ctx.cr[6].eq {
	pc = 0x82614DF4; continue 'dispatch;
	}
	// 82614E8C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82614E90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82614E94: 486945C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82614E98 => {
    //   block [0x82614E98..0x82614EA4)
	// 82614E98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82614E9C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82614EA0: 486945B8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82614EA4 => {
    //   block [0x82614EA4..0x82614EB0)
	// 82614EA4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82614EA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82614EAC: 419A0044  beq cr6, 0x82614ef0
	if ctx.cr[6].eq {
	pc = 0x82614EF0; continue 'dispatch;
	}
	pc = 0x82614EB0; continue 'dispatch;
            }
            0x82614EB0 => {
    //   block [0x82614EB0..0x82614EF0)
	// 82614EB0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82614EB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82614EB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82614EBC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82614EC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82614EC4: 4E800421  bctrl
	ctx.lr = 0x82614EC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82614EC8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82614ECC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82614ED0: 419AFFC8  beq cr6, 0x82614e98
	if ctx.cr[6].eq {
	pc = 0x82614E98; continue 'dispatch;
	}
	// 82614ED4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82614ED8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82614EDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82614EE0: 4BFFFDE9  bl 0x82614cc8
	ctx.lr = 0x82614EE4;
	sub_82614CC8(ctx, base);
	// 82614EE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82614EE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82614EEC: 409AFFC4  bne cr6, 0x82614eb0
	if !ctx.cr[6].eq {
	pc = 0x82614EB0; continue 'dispatch;
	}
            }
            0x82614EF0 => {
    //   block [0x82614EF0..0x82614EFC)
	// 82614EF0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82614EF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82614EF8: 48694560  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82614F00 size=20
    let mut pc: u32 = 0x82614F00;
    'dispatch: loop {
        match pc {
            0x82614F00 => {
    //   block [0x82614F00..0x82614F14)
	// 82614F00: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82614F04: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82614F08: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82614F0C: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82614F10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82614F18 size=76
    let mut pc: u32 = 0x82614F18;
    'dispatch: loop {
        match pc {
            0x82614F18 => {
    //   block [0x82614F18..0x82614F50)
	// 82614F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82614F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82614F20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82614F24: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82614F28: 48001A01  bl 0x82616928
	ctx.lr = 0x82614F2C;
	sub_82616928(ctx, base);
	// 82614F2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82614F30: 419A0020  beq cr6, 0x82614f50
	if ctx.cr[6].eq {
	pc = 0x82614F50; continue 'dispatch;
	}
	// 82614F34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82614F38: 394B83E4  addi r10, r11, -0x7c1c
	ctx.r[10].s64 = ctx.r[11].s64 + -31772;
	// 82614F3C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82614F40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82614F44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82614F48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82614F4C: 4E800020  blr
	return;
            }
            0x82614F50 => {
    //   block [0x82614F50..0x82614F64)
	// 82614F50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82614F54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82614F58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82614F5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82614F60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82614F68 size=84
    let mut pc: u32 = 0x82614F68;
    'dispatch: loop {
        match pc {
            0x82614F68 => {
    //   block [0x82614F68..0x82614FA8)
	// 82614F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82614F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82614F70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82614F74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82614F78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82614F7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82614F80: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82614F84: 392B9128  addi r9, r11, -0x6ed8
	ctx.r[9].s64 = ctx.r[11].s64 + -28376;
	// 82614F88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82614F8C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82614F90: 419A0018  beq cr6, 0x82614fa8
	if ctx.cr[6].eq {
	pc = 0x82614FA8; continue 'dispatch;
	}
	// 82614F94: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82614F98: 814BDAB4  lwz r10, -0x254c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82614F9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82614FA0: 4E800421  bctrl
	ctx.lr = 0x82614FA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82614FA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            0x82614FA8 => {
    //   block [0x82614FA8..0x82614FBC)
	// 82614FA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82614FAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82614FB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82614FB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82614FB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82614FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82614FC0 size=132
    let mut pc: u32 = 0x82614FC0;
    'dispatch: loop {
        match pc {
            0x82614FC0 => {
    //   block [0x82614FC0..0x82615044)
	// 82614FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82614FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82614FC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82614FCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82614FD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82614FD4: 48876D5D  bl 0x82e8bd30
	ctx.lr = 0x82614FD8;
	sub_82E8BD30(ctx, base);
	// 82614FD8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82614FDC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82614FE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82614FE4: 39098378  addi r8, r9, -0x7c88
	ctx.r[8].s64 = ctx.r[9].s64 + -31880;
	// 82614FE8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82614FEC: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82614FF0: C00A0BEC  lfs f0, 0xbec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82614FF4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82614FF8: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82614FFC: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82615000: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82615004: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82615008: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 8261500C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82615010: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82615014: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82615018: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 8261501C: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82615020: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82615024: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82615028: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 8261502C: 98FF0010  stb r7, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u8 ) };
	// 82615030: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82615034: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82615038: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261503C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82615040: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82615048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82615048 size=116
    let mut pc: u32 = 0x82615048;
    'dispatch: loop {
        match pc {
            0x82615048 => {
    //   block [0x82615048..0x826150A4)
	// 82615048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261504C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82615050: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82615054: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82615058: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261505C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82615060: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82615064: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82615068: 394B8378  addi r10, r11, -0x7c88
	ctx.r[10].s64 = ctx.r[11].s64 + -31880;
	// 8261506C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82615070: 48000549  bl 0x826155b8
	ctx.lr = 0x82615074;
	sub_826155B8(ctx, base);
	// 82615074: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82615078: 57C807FE  clrlwi r8, r30, 0x1f
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8261507C: 38E99128  addi r7, r9, -0x6ed8
	ctx.r[7].s64 = ctx.r[9].s64 + -28376;
	// 82615080: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82615084: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82615088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261508C: 419A0018  beq cr6, 0x826150a4
	if ctx.cr[6].eq {
	pc = 0x826150A4; continue 'dispatch;
	}
	// 82615090: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82615094: 814BDAB4  lwz r10, -0x254c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82615098: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261509C: 4E800421  bctrl
	ctx.lr = 0x826150A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826150A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            0x826150A4 => {
    //   block [0x826150A4..0x826150BC)
	// 826150A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826150A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826150AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826150B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826150B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826150B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826150C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826150C0 size=68
    let mut pc: u32 = 0x826150C0;
    'dispatch: loop {
        match pc {
            0x826150C0 => {
    //   block [0x826150C0..0x82615104)
	// 826150C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826150C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826150C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826150CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826150D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826150D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 826150D8: 394B8378  addi r10, r11, -0x7c88
	ctx.r[10].s64 = ctx.r[11].s64 + -31880;
	// 826150DC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826150E0: 480004D9  bl 0x826155b8
	ctx.lr = 0x826150E4;
	sub_826155B8(ctx, base);
	// 826150E4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 826150E8: 39099128  addi r8, r9, -0x6ed8
	ctx.r[8].s64 = ctx.r[9].s64 + -28376;
	// 826150EC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 826150F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826150F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826150F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826150FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82615100: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82615108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82615108 size=208
    let mut pc: u32 = 0x82615108;
    'dispatch: loop {
        match pc {
            0x82615108 => {
    //   block [0x82615108..0x82615140)
	// 82615108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261510C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82615110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82615114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82615118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261511C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82615120: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82615124: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615128: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261512C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82615130: 4E800421  bctrl
	ctx.lr = 0x82615134;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82615134: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82615138: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261513C: 409A000C  bne cr6, 0x82615148
	if !ctx.cr[6].eq {
	pc = 0x82615148; continue 'dispatch;
	}
            }
            0x82615140 => {
    //   block [0x82615140..0x82615148)
	// 82615140: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82615144: 4800007C  b 0x826151c0
	pc = 0x826151C0; continue 'dispatch;
            }
            0x82615148 => {
    //   block [0x82615148..0x82615174)
	// 82615148: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261514C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82615150: 409A006C  bne cr6, 0x826151bc
	if !ctx.cr[6].eq {
	pc = 0x826151BC; continue 'dispatch;
	}
	// 82615154: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82615158: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261515C: 419AFFE4  beq cr6, 0x82615140
	if ctx.cr[6].eq {
	pc = 0x82615140; continue 'dispatch;
	}
	// 82615160: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615164: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82615168: 419AFFD8  beq cr6, 0x82615140
	if ctx.cr[6].eq {
	pc = 0x82615140; continue 'dispatch;
	}
	// 8261516C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615170: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82615174; continue 'dispatch;
            }
            0x82615174 => {
    //   block [0x82615174..0x826151A0)
	// 82615174: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261517C: 419A0024  beq cr6, 0x826151a0
	if ctx.cr[6].eq {
	pc = 0x826151A0; continue 'dispatch;
	}
	// 82615180: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82615184: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82615188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261518C: 419A0014  beq cr6, 0x826151a0
	if ctx.cr[6].eq {
	pc = 0x826151A0; continue 'dispatch;
	}
	// 82615190: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82615194: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82615198: 40990008  ble cr6, 0x826151a0
	if !ctx.cr[6].gt {
	pc = 0x826151A0; continue 'dispatch;
	}
	// 8261519C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	pc = 0x826151A0; continue 'dispatch;
            }
            0x826151A0 => {
    //   block [0x826151A0..0x826151BC)
	// 826151A0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826151A4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 826151A8: 4082FFCC  bne 0x82615174
	if !ctx.cr[0].eq {
	pc = 0x82615174; continue 'dispatch;
	}
	// 826151AC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 826151B0: 419AFF90  beq cr6, 0x82615140
	if ctx.cr[6].eq {
	pc = 0x82615140; continue 'dispatch;
	}
	// 826151B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826151B8: 48000521  bl 0x826156d8
	ctx.lr = 0x826151BC;
	sub_826156D8(ctx, base);
	pc = 0x826151BC; continue 'dispatch;
            }
            0x826151BC => {
    //   block [0x826151BC..0x826151C0)
	// 826151BC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x826151C0; continue 'dispatch;
            }
            0x826151C0 => {
    //   block [0x826151C0..0x826151D8)
	// 826151C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826151C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826151C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826151CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826151D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826151D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826151D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826151D8 size=288
    let mut pc: u32 = 0x826151D8;
    'dispatch: loop {
        match pc {
            0x826151D8 => {
    //   block [0x826151D8..0x82615238)
	// 826151D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826151DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826151E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826151E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826151E8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826151EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826151F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826151F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826151F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826151FC: 48BA6E65  bl 0x831bc060
	ctx.lr = 0x82615200;
	sub_831BC060(ctx, base);
	// 82615200: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82615204: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82615208: 386B8348  addi r3, r11, -0x7cb8
	ctx.r[3].s64 = ctx.r[11].s64 + -31928;
	// 8261520C: 48697945  bl 0x82cacb50
	ctx.lr = 0x82615210;
	sub_82CACB50(ctx, base);
	// 82615210: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82615214: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82615218: 409A0020  bne cr6, 0x82615238
	if !ctx.cr[6].eq {
	pc = 0x82615238; continue 'dispatch;
	}
	// 8261521C: 482F8AED  bl 0x8290dd08
	ctx.lr = 0x82615220;
	sub_8290DD08(ctx, base);
	// 82615220: 486951A1  bl 0x82caa3c0
	ctx.lr = 0x82615224;
	sub_82CAA3C0(ctx, base);
	// 82615224: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82615228: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261522C: 480004AD  bl 0x826156d8
	ctx.lr = 0x82615230;
	sub_826156D8(ctx, base);
	// 82615230: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82615234: 480000A8  b 0x826152dc
	pc = 0x826152DC; continue 'dispatch;
            }
            0x82615238 => {
    //   block [0x82615238..0x8261526C)
	// 82615238: 48BA6E29  bl 0x831bc060
	ctx.lr = 0x8261523C;
	sub_831BC060(ctx, base);
	// 8261523C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82615240: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82615244: 386B8360  addi r3, r11, -0x7ca0
	ctx.r[3].s64 = ctx.r[11].s64 + -31904;
	// 82615248: 48697909  bl 0x82cacb50
	ctx.lr = 0x8261524C;
	sub_82CACB50(ctx, base);
	// 8261524C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82615250: 409A0044  bne cr6, 0x82615294
	if !ctx.cr[6].eq {
	pc = 0x82615294; continue 'dispatch;
	}
	// 82615254: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82615258: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 8261525C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82615260: 419A000C  beq cr6, 0x8261526c
	if ctx.cr[6].eq {
	pc = 0x8261526C; continue 'dispatch;
	}
	// 82615264: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82615268: 4800000C  b 0x82615274
	pc = 0x82615274; continue 'dispatch;
            }
            0x8261526C => {
    //   block [0x8261526C..0x82615274)
	// 8261526C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82615270: C3EB9490  lfs f31, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82615274; continue 'dispatch;
            }
            0x82615274 => {
    //   block [0x82615274..0x82615294)
	// 82615274: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82615278: 482F8A91  bl 0x8290dd08
	ctx.lr = 0x8261527C;
	sub_8290DD08(ctx, base);
	// 8261527C: 48696935  bl 0x82cabbb0
	ctx.lr = 0x82615280;
	sub_82CABBB0(ctx, base);
	// 82615280: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82615284: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82615288: EDA007F2  fmuls f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8261528C: D1BE0020  stfs f13, 0x20(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82615290: 4800004C  b 0x826152dc
	pc = 0x826152DC; continue 'dispatch;
            }
            0x82615294 => {
    //   block [0x82615294..0x826152D0)
	// 82615294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82615298: 48BA6DC9  bl 0x831bc060
	ctx.lr = 0x8261529C;
	sub_831BC060(ctx, base);
	// 8261529C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 826152A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826152A4: 386B836C  addi r3, r11, -0x7c94
	ctx.r[3].s64 = ctx.r[11].s64 + -31892;
	// 826152A8: 486978A9  bl 0x82cacb50
	ctx.lr = 0x826152AC;
	sub_82CACB50(ctx, base);
	// 826152AC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 826152B0: 409A0020  bne cr6, 0x826152d0
	if !ctx.cr[6].eq {
	pc = 0x826152D0; continue 'dispatch;
	}
	// 826152B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826152B8: 482F8A51  bl 0x8290dd08
	ctx.lr = 0x826152BC;
	sub_8290DD08(ctx, base);
	// 826152BC: 486968F5  bl 0x82cabbb0
	ctx.lr = 0x826152C0;
	sub_82CABBB0(ctx, base);
	// 826152C0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826152C4: D01E001C  stfs f0, 0x1c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 826152C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826152CC: 48000010  b 0x826152dc
	pc = 0x826152DC; continue 'dispatch;
            }
            0x826152D0 => {
    //   block [0x826152D0..0x826152DC)
	// 826152D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826152D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826152D8: 48877191  bl 0x82e8c468
	ctx.lr = 0x826152DC;
	sub_82E8C468(ctx, base);
	pc = 0x826152DC; continue 'dispatch;
            }
            0x826152DC => {
    //   block [0x826152DC..0x826152F8)
	// 826152DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826152E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826152E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826152E8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826152EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826152F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826152F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826152F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826152F8 size=680
    let mut pc: u32 = 0x826152F8;
    'dispatch: loop {
        match pc {
            0x826152F8 => {
    //   block [0x826152F8..0x82615328)
	// 826152F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826152FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82615300: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82615304: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82615308: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261530C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82615310: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82615314: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82615318: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 8261531C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615320: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82615324: 419A0018  beq cr6, 0x8261533c
	if ctx.cr[6].eq {
	pc = 0x8261533C; continue 'dispatch;
	}
	pc = 0x82615328; continue 'dispatch;
            }
            0x82615328 => {
    //   block [0x82615328..0x8261533C)
	// 82615328: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8261532C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82615330: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82615334: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82615338: 409AFFF0  bne cr6, 0x82615328
	if !ctx.cr[6].eq {
	pc = 0x82615328; continue 'dispatch;
	}
	pc = 0x8261533C; continue 'dispatch;
            }
            0x8261533C => {
    //   block [0x8261533C..0x8261534C)
	// 8261533C: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82615340: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615344: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82615348: 419A0034  beq cr6, 0x8261537c
	if ctx.cr[6].eq {
	pc = 0x8261537C; continue 'dispatch;
	}
	pc = 0x8261534C; continue 'dispatch;
            }
            0x8261534C => {
    //   block [0x8261534C..0x8261537C)
	// 8261534C: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615350: 99690018  stb r11, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 82615354: 810A0010  lwz r8, 0x10(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82615358: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261535C: 80E90014  lwz r7, 0x14(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82615360: 54E5003E  slwi r5, r7, 0
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82615364: 91090014  stw r8, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82615368: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8261536C: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615370: 90CA0010  stw r6, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82615374: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82615378: 409AFFD4  bne cr6, 0x8261534c
	if !ctx.cr[6].eq {
	pc = 0x8261534C; continue 'dispatch;
	}
	pc = 0x8261537C; continue 'dispatch;
            }
            0x8261537C => {
    //   block [0x8261537C..0x82615394)
	// 8261537C: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82615380: 916A0014  stw r11, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82615384: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82615388: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261538C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82615390: 419A0018  beq cr6, 0x826153a8
	if ctx.cr[6].eq {
	pc = 0x826153A8; continue 'dispatch;
	}
	pc = 0x82615394; continue 'dispatch;
            }
            0x82615394 => {
    //   block [0x82615394..0x826153A8)
	// 82615394: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82615398: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8261539C: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 826153A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826153A4: 409AFFF0  bne cr6, 0x82615394
	if !ctx.cr[6].eq {
	pc = 0x82615394; continue 'dispatch;
	}
	pc = 0x826153A8; continue 'dispatch;
            }
            0x826153A8 => {
    //   block [0x826153A8..0x826153B8)
	// 826153A8: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 826153AC: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 826153B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 826153B4: 419A0034  beq cr6, 0x826153e8
	if ctx.cr[6].eq {
	pc = 0x826153E8; continue 'dispatch;
	}
	pc = 0x826153B8; continue 'dispatch;
            }
            0x826153B8 => {
    //   block [0x826153B8..0x826153E8)
	// 826153B8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 826153BC: 99690018  stb r11, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 826153C0: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 826153C4: 810A0010  lwz r8, 0x10(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 826153C8: 80E90014  lwz r7, 0x14(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 826153CC: 91090014  stw r8, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 826153D0: 54E5003E  slwi r5, r7, 0
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 826153D4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 826153D8: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 826153DC: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 826153E0: 90CA0010  stw r6, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 826153E4: 409AFFD4  bne cr6, 0x826153b8
	if !ctx.cr[6].eq {
	pc = 0x826153B8; continue 'dispatch;
	}
	pc = 0x826153E8; continue 'dispatch;
            }
            0x826153E8 => {
    //   block [0x826153E8..0x82615404)
	// 826153E8: 916A0014  stw r11, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 826153EC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 826153F0: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 826153F4: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 826153F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826153FC: 40990028  ble cr6, 0x82615424
	if !ctx.cr[6].gt {
	pc = 0x82615424; continue 'dispatch;
	}
	// 82615400: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82615404; continue 'dispatch;
            }
            0x82615404 => {
    //   block [0x82615404..0x82615424)
	// 82615404: 811F0038  lwz r8, 0x38(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82615408: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8261540C: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82615410: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82615414: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82615418: 80FF0030  lwz r7, 0x30(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261541C: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82615420: 4198FFE4  blt cr6, 0x82615404
	if ctx.cr[6].lt {
	pc = 0x82615404; continue 'dispatch;
	}
	pc = 0x82615424; continue 'dispatch;
            }
            0x82615424 => {
    //   block [0x82615424..0x82615438)
	// 82615424: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82615428: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 8261542C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82615430: 40990028  ble cr6, 0x82615458
	if !ctx.cr[6].gt {
	pc = 0x82615458; continue 'dispatch;
	}
	// 82615434: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82615438; continue 'dispatch;
            }
            0x82615438 => {
    //   block [0x82615438..0x82615458)
	// 82615438: 811F0040  lwz r8, 0x40(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 8261543C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82615440: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82615444: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82615448: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8261544C: 80FF0030  lwz r7, 0x30(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82615450: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82615454: 4198FFE4  blt cr6, 0x82615438
	if ctx.cr[6].lt {
	pc = 0x82615438; continue 'dispatch;
	}
	pc = 0x82615458; continue 'dispatch;
            }
            0x82615458 => {
    //   block [0x82615458..0x82615474)
	// 82615458: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8261545C: 811F0030  lwz r8, 0x30(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82615460: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82615464: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82615468: C00A0BEC  lfs f0, 0xbec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8261546C: 40990024  ble cr6, 0x82615490
	if !ctx.cr[6].gt {
	pc = 0x82615490; continue 'dispatch;
	}
	// 82615470: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82615474; continue 'dispatch;
            }
            0x82615474 => {
    //   block [0x82615474..0x82615490)
	// 82615474: 811F0048  lwz r8, 0x48(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82615478: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8261547C: 7C08552E  stfsx f0, r8, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82615480: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82615484: 80FF0030  lwz r7, 0x30(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82615488: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 8261548C: 4198FFE8  blt cr6, 0x82615474
	if ctx.cr[6].lt {
	pc = 0x82615474; continue 'dispatch;
	}
	pc = 0x82615490; continue 'dispatch;
            }
            0x82615490 => {
    //   block [0x82615490..0x826154A4)
	// 82615490: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82615494: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82615498: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261549C: 40990024  ble cr6, 0x826154c0
	if !ctx.cr[6].gt {
	pc = 0x826154C0; continue 'dispatch;
	}
	// 826154A0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x826154A4; continue 'dispatch;
            }
            0x826154A4 => {
    //   block [0x826154A4..0x826154C0)
	// 826154A4: 811F0044  lwz r8, 0x44(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 826154A8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826154AC: 7C0A452E  stfsx f0, r10, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 826154B0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 826154B4: 80FF0030  lwz r7, 0x30(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 826154B8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 826154BC: 4198FFE8  blt cr6, 0x826154a4
	if ctx.cr[6].lt {
	pc = 0x826154A4; continue 'dispatch;
	}
	pc = 0x826154C0; continue 'dispatch;
            }
            0x826154C0 => {
    //   block [0x826154C0..0x82615570)
	// 826154C0: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 826154C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826154C8: 419A00C0  beq cr6, 0x82615588
	if ctx.cr[6].eq {
	pc = 0x82615588; continue 'dispatch;
	}
	// 826154CC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 826154D0: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 826154D4: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 826154D8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826154DC: 38E983E0  addi r7, r9, -0x7c20
	ctx.r[7].s64 = ctx.r[9].s64 + -31776;
	// 826154E0: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 826154E4: 38A89128  addi r5, r8, -0x6ed8
	ctx.r[5].s64 = ctx.r[8].s64 + -28376;
	// 826154E8: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 826154EC: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 826154F0: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 826154F4: 90A10068  stw r5, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[5].u32 ) };
	// 826154F8: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 826154FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82615500: 809F0034  lwz r4, 0x34(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82615504: 48000FFD  bl 0x82616500
	ctx.lr = 0x82615508;
	sub_82616500(ctx, base);
	// 82615508: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8261550C: 57CA1838  slwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82615510: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615514: 3C60820D  lis r3, -0x7df3
	ctx.r[3].s64 = -2113077248;
	// 82615518: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261551C: 39439128  addi r10, r3, -0x6ed8
	ctx.r[10].s64 = ctx.r[3].s64 + -28376;
	// 82615520: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82615524: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82615528: 811F0018  lwz r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8261552C: 80FF0044  lwz r7, 0x44(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82615530: C0099484  lfs f0, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82615534: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82615538: 80C80000  lwz r6, 0(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261553C: 54C5103A  slwi r5, r6, 2
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82615540: 7C053D2E  stfsx f0, r5, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 82615544: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82615548: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8261554C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82615550: 419A0020  beq cr6, 0x82615570
	if ctx.cr[6].eq {
	pc = 0x82615570; continue 'dispatch;
	}
	// 82615554: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615558: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8261555C: 80BF0018  lwz r5, 0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82615560: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82615564: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615568: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261556C: 4E800421  bctrl
	ctx.lr = 0x82615570;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82615570 => {
    //   block [0x82615570..0x82615588)
	// 82615570: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82615574: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82615578: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261557C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615580: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82615584: 7C08552E  stfsx f0, r8, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	pc = 0x82615588; continue 'dispatch;
            }
            0x82615588 => {
    //   block [0x82615588..0x826155A0)
	// 82615588: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8261558C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82615590: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82615594: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82615598: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261559C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826155A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826155A0 size=20
    let mut pc: u32 = 0x826155A0;
    'dispatch: loop {
        match pc {
            0x826155A0 => {
    //   block [0x826155A0..0x826155B4)
	// 826155A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826155A4: 90830018  stw r4, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[4].u32 ) };
	// 826155A8: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 826155AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 826155B0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826155B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826155B8 size=288
    let mut pc: u32 = 0x826155B8;
    'dispatch: loop {
        match pc {
            0x826155B8 => {
    //   block [0x826155B8..0x826155F0)
	// 826155B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826155BC: 48693E51  bl 0x82ca940c
	ctx.lr = 0x826155C0;
	sub_82CA93D0(ctx, base);
	// 826155C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826155C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826155C8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826155CC: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 826155D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826155D4: 419A001C  beq cr6, 0x826155f0
	if ctx.cr[6].eq {
	pc = 0x826155F0; continue 'dispatch;
	}
	// 826155D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826155DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826155E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826155E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 826155E8: 4E800421  bctrl
	ctx.lr = 0x826155EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826155EC: 93BF0034  stw r29, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[29].u32 ) };
            }
            0x826155F0 => {
    //   block [0x826155F0..0x82615614)
	// 826155F0: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 826155F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826155F8: 419A001C  beq cr6, 0x82615614
	if ctx.cr[6].eq {
	pc = 0x82615614; continue 'dispatch;
	}
	// 826155FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615600: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82615604: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615608: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261560C: 4E800421  bctrl
	ctx.lr = 0x82615610;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82615610: 93BF003C  stw r29, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[29].u32 ) };
            }
            0x82615614 => {
    //   block [0x82615614..0x8261564C)
	// 82615614: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82615618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261561C: 419A0038  beq cr6, 0x82615654
	if ctx.cr[6].eq {
	pc = 0x82615654; continue 'dispatch;
	}
	// 82615620: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82615624: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82615628: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8261562C: 419A0020  beq cr6, 0x8261564c
	if ctx.cr[6].eq {
	pc = 0x8261564C; continue 'dispatch;
	}
	// 82615630: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615634: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82615638: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8261563C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615640: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82615644: 4E800421  bctrl
	ctx.lr = 0x82615648;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82615648: 48000008  b 0x82615650
	pc = 0x82615650; continue 'dispatch;
            }
            0x8261564C => {
    //   block [0x8261564C..0x82615650)
	// 8261564C: 4BC066ED  bl 0x8221bd38
	ctx.lr = 0x82615650;
	sub_8221BD38(ctx, base);
	pc = 0x82615650; continue 'dispatch;
            }
            0x82615650 => {
    //   block [0x82615650..0x82615654)
	// 82615650: 93BF0038  stw r29, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[29].u32 ) };
	pc = 0x82615654; continue 'dispatch;
            }
            0x82615654 => {
    //   block [0x82615654..0x8261568C)
	// 82615654: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82615658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261565C: 419A0038  beq cr6, 0x82615694
	if ctx.cr[6].eq {
	pc = 0x82615694; continue 'dispatch;
	}
	// 82615660: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82615664: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82615668: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8261566C: 419A0020  beq cr6, 0x8261568c
	if ctx.cr[6].eq {
	pc = 0x8261568C; continue 'dispatch;
	}
	// 82615670: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615674: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82615678: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8261567C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615680: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82615684: 4E800421  bctrl
	ctx.lr = 0x82615688;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82615688: 48000008  b 0x82615690
	pc = 0x82615690; continue 'dispatch;
            }
            0x8261568C => {
    //   block [0x8261568C..0x82615690)
	// 8261568C: 4BC066AD  bl 0x8221bd38
	ctx.lr = 0x82615690;
	sub_8221BD38(ctx, base);
	pc = 0x82615690; continue 'dispatch;
            }
            0x82615690 => {
    //   block [0x82615690..0x82615694)
	// 82615690: 93BF0040  stw r29, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[29].u32 ) };
	pc = 0x82615694; continue 'dispatch;
            }
            0x82615694 => {
    //   block [0x82615694..0x826156B4)
	// 82615694: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82615698: 3FC08330  lis r30, -0x7cd0
	ctx.r[30].s64 = -2094006272;
	// 8261569C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826156A0: 419A0014  beq cr6, 0x826156b4
	if ctx.cr[6].eq {
	pc = 0x826156B4; continue 'dispatch;
	}
	// 826156A4: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 826156A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826156AC: 4E800421  bctrl
	ctx.lr = 0x826156B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826156B0: 93BF0044  stw r29, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[29].u32 ) };
            }
            0x826156B4 => {
    //   block [0x826156B4..0x826156D0)
	// 826156B4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 826156B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826156BC: 419A0014  beq cr6, 0x826156d0
	if ctx.cr[6].eq {
	pc = 0x826156D0; continue 'dispatch;
	}
	// 826156C0: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 826156C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826156C8: 4E800421  bctrl
	ctx.lr = 0x826156CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826156CC: 93BF0048  stw r29, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[29].u32 ) };
            }
            0x826156D0 => {
    //   block [0x826156D0..0x826156D8)
	// 826156D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826156D4: 48693D88  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826156D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826156D8 size=472
    let mut pc: u32 = 0x826156D8;
    'dispatch: loop {
        match pc {
            0x826156D8 => {
    //   block [0x826156D8..0x826156F8)
	// 826156D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826156DC: 48693D21  bl 0x82ca93fc
	ctx.lr = 0x826156E0;
	sub_82CA93D0(ctx, base);
	// 826156E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826156E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826156E8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 826156EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826156F0: 409A0008  bne cr6, 0x826156f8
	if !ctx.cr[6].eq {
	pc = 0x826156F8; continue 'dispatch;
	}
	// 826156F4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	pc = 0x826156F8; continue 'dispatch;
            }
            0x826156F8 => {
    //   block [0x826156F8..0x82615730)
	// 826156F8: 817A0030  lwz r11, 0x30(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) } as u64;
	// 826156FC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82615700: 419A0194  beq cr6, 0x82615894
	if ctx.cr[6].eq {
	pc = 0x82615894; continue 'dispatch;
	}
	// 82615704: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82615708: 4BFFFEB1  bl 0x826155b8
	ctx.lr = 0x8261570C;
	sub_826155B8(ctx, base);
	// 8261570C: 93FA0030  stw r31, 0x30(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(48 as u32), ctx.r[31].u32 ) };
	// 82615710: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82615714: 48001215  bl 0x82616928
	ctx.lr = 0x82615718;
	sub_82616928(ctx, base);
	// 82615718: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8261571C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82615720: 419A0010  beq cr6, 0x82615730
	if ctx.cr[6].eq {
	pc = 0x82615730; continue 'dispatch;
	}
	// 82615724: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82615728: 48000C11  bl 0x82616338
	ctx.lr = 0x8261572C;
	sub_82616338(ctx, base);
	// 8261572C: 48000008  b 0x82615734
	pc = 0x82615734; continue 'dispatch;
            }
            0x82615730 => {
    //   block [0x82615730..0x82615734)
	// 82615730: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	pc = 0x82615734; continue 'dispatch;
            }
            0x82615734 => {
    //   block [0x82615734..0x82615754)
	// 82615734: 907A0034  stw r3, 0x34(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(52 as u32), ctx.r[3].u32 ) };
	// 82615738: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8261573C: 480011ED  bl 0x82616928
	ctx.lr = 0x82615740;
	sub_82616928(ctx, base);
	// 82615740: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82615744: 419A0010  beq cr6, 0x82615754
	if ctx.cr[6].eq {
	pc = 0x82615754; continue 'dispatch;
	}
	// 82615748: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261574C: 48000BED  bl 0x82616338
	ctx.lr = 0x82615750;
	sub_82616338(ctx, base);
	// 82615750: 48000008  b 0x82615758
	pc = 0x82615758; continue 'dispatch;
            }
            0x82615754 => {
    //   block [0x82615754..0x82615758)
	// 82615754: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	pc = 0x82615758; continue 'dispatch;
            }
            0x82615758 => {
    //   block [0x82615758..0x82615780)
	// 82615758: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 8261575C: 907A003C  stw r3, 0x3c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(60 as u32), ctx.r[3].u32 ) };
	// 82615760: 3BA0FFFB  li r29, -5
	ctx.r[29].s64 = -5;
	// 82615764: 617CFFFF  ori r28, r11, 0xffff
	ctx.r[28].u64 = ctx.r[11].u64 | 65535;
	// 82615768: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 8261576C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82615770: 409A0010  bne cr6, 0x82615780
	if !ctx.cr[6].eq {
	pc = 0x82615780; continue 'dispatch;
	}
	// 82615774: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82615778: 4BC09AE1  bl 0x8221f258
	ctx.lr = 0x8261577C;
	sub_8221F258(ctx, base);
	// 8261577C: 48000024  b 0x826157a0
	pc = 0x826157A0; continue 'dispatch;
            }
            0x82615780 => {
    //   block [0x82615780..0x82615798)
	// 82615780: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82615784: 41990014  bgt cr6, 0x82615798
	if ctx.cr[6].gt {
	pc = 0x82615798; continue 'dispatch;
	}
	// 82615788: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261578C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82615790: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82615794: 40990008  ble cr6, 0x8261579c
	if !ctx.cr[6].gt {
	pc = 0x8261579C; continue 'dispatch;
	}
	pc = 0x82615798; continue 'dispatch;
            }
            0x82615798 => {
    //   block [0x82615798..0x8261579C)
	// 82615798: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x8261579C; continue 'dispatch;
            }
            0x8261579C => {
    //   block [0x8261579C..0x826157A0)
	// 8261579C: 4800118D  bl 0x82616928
	ctx.lr = 0x826157A0;
	sub_82616928(ctx, base);
	pc = 0x826157A0; continue 'dispatch;
            }
            0x826157A0 => {
    //   block [0x826157A0..0x826157C4)
	// 826157A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 826157A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826157A8: 3BCB83E0  addi r30, r11, -0x7c20
	ctx.r[30].s64 = ctx.r[11].s64 + -31776;
	// 826157AC: 419A0034  beq cr6, 0x826157e0
	if ctx.cr[6].eq {
	pc = 0x826157E0; continue 'dispatch;
	}
	// 826157B0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 826157B4: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826157B8: 355FFFFF  addic. r10, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 826157BC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 826157C0: 41800018  blt 0x826157d8
	if ctx.cr[0].lt {
	pc = 0x826157D8; continue 'dispatch;
	}
	pc = 0x826157C4; continue 'dispatch;
            }
            0x826157C4 => {
    //   block [0x826157C4..0x826157D8)
	// 826157C4: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 826157C8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 826157CC: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 826157D0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 826157D4: 4080FFF0  bge 0x826157c4
	if !ctx.cr[0].lt {
	pc = 0x826157C4; continue 'dispatch;
	}
	pc = 0x826157D8; continue 'dispatch;
            }
            0x826157D8 => {
    //   block [0x826157D8..0x826157E0)
	// 826157D8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 826157DC: 48000008  b 0x826157e4
	pc = 0x826157E4; continue 'dispatch;
            }
            0x826157E0 => {
    //   block [0x826157E0..0x826157E4)
	// 826157E0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x826157E4; continue 'dispatch;
            }
            0x826157E4 => {
    //   block [0x826157E4..0x826157FC)
	// 826157E4: 917A0038  stw r11, 0x38(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 826157E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826157EC: 409A0010  bne cr6, 0x826157fc
	if !ctx.cr[6].eq {
	pc = 0x826157FC; continue 'dispatch;
	}
	// 826157F0: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 826157F4: 4BC09A65  bl 0x8221f258
	ctx.lr = 0x826157F8;
	sub_8221F258(ctx, base);
	// 826157F8: 48000024  b 0x8261581c
	pc = 0x8261581C; continue 'dispatch;
            }
            0x826157FC => {
    //   block [0x826157FC..0x82615814)
	// 826157FC: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82615800: 41990014  bgt cr6, 0x82615814
	if ctx.cr[6].gt {
	pc = 0x82615814; continue 'dispatch;
	}
	// 82615804: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82615808: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8261580C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82615810: 40990008  ble cr6, 0x82615818
	if !ctx.cr[6].gt {
	pc = 0x82615818; continue 'dispatch;
	}
	pc = 0x82615814; continue 'dispatch;
            }
            0x82615814 => {
    //   block [0x82615814..0x82615818)
	// 82615814: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82615818; continue 'dispatch;
            }
            0x82615818 => {
    //   block [0x82615818..0x8261581C)
	// 82615818: 48001111  bl 0x82616928
	ctx.lr = 0x8261581C;
	sub_82616928(ctx, base);
	pc = 0x8261581C; continue 'dispatch;
            }
            0x8261581C => {
    //   block [0x8261581C..0x82615838)
	// 8261581C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82615820: 419A0034  beq cr6, 0x82615854
	if ctx.cr[6].eq {
	pc = 0x82615854; continue 'dispatch;
	}
	// 82615824: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 82615828: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8261582C: 355FFFFF  addic. r10, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82615830: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82615834: 41800018  blt 0x8261584c
	if ctx.cr[0].lt {
	pc = 0x8261584C; continue 'dispatch;
	}
	pc = 0x82615838; continue 'dispatch;
            }
            0x82615838 => {
    //   block [0x82615838..0x8261584C)
	// 82615838: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8261583C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82615840: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82615844: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82615848: 4080FFF0  bge 0x82615838
	if !ctx.cr[0].lt {
	pc = 0x82615838; continue 'dispatch;
	}
	pc = 0x8261584C; continue 'dispatch;
            }
            0x8261584C => {
    //   block [0x8261584C..0x82615854)
	// 8261584C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82615850: 48000008  b 0x82615858
	pc = 0x82615858; continue 'dispatch;
            }
            0x82615854 => {
    //   block [0x82615854..0x82615858)
	// 82615854: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82615858; continue 'dispatch;
            }
            0x82615858 => {
    //   block [0x82615858..0x82615874)
	// 82615858: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 8261585C: 917A0040  stw r11, 0x40(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82615860: 57E3103A  slwi r3, r31, 2
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82615864: 615EFFFF  ori r30, r10, 0xffff
	ctx.r[30].u64 = ctx.r[10].u64 | 65535;
	// 82615868: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8261586C: 40990008  ble cr6, 0x82615874
	if !ctx.cr[6].gt {
	pc = 0x82615874; continue 'dispatch;
	}
	// 82615870: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82615874; continue 'dispatch;
            }
            0x82615874 => {
    //   block [0x82615874..0x8261588C)
	// 82615874: 480010B5  bl 0x82616928
	ctx.lr = 0x82615878;
	sub_82616928(ctx, base);
	// 82615878: 907A0044  stw r3, 0x44(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	// 8261587C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82615880: 57E3103A  slwi r3, r31, 2
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82615884: 40990008  ble cr6, 0x8261588c
	if !ctx.cr[6].gt {
	pc = 0x8261588C; continue 'dispatch;
	}
	// 82615888: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x8261588C; continue 'dispatch;
            }
            0x8261588C => {
    //   block [0x8261588C..0x82615894)
	// 8261588C: 4800109D  bl 0x82616928
	ctx.lr = 0x82615890;
	sub_82616928(ctx, base);
	// 82615890: 907A0048  stw r3, 0x48(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(72 as u32), ctx.r[3].u32 ) };
	pc = 0x82615894; continue 'dispatch;
            }
            0x82615894 => {
    //   block [0x82615894..0x826158B0)
	// 82615894: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615898: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8261589C: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 826158A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 826158A4: 4E800421  bctrl
	ctx.lr = 0x826158A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826158A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826158AC: 48693BA0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826158B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826158B0 size=196
    let mut pc: u32 = 0x826158B0;
    'dispatch: loop {
        match pc {
            0x826158B0 => {
    //   block [0x826158B0..0x826158F4)
	// 826158B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826158B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826158B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826158BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826158C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826158C4: 548B07BC  rlwinm r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 826158C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826158CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826158D0: 419A005C  beq cr6, 0x8261592c
	if ctx.cr[6].eq {
	pc = 0x8261592C; continue 'dispatch;
	}
	// 826158D4: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 826158D8: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 826158DC: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826158E0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826158E4: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 826158E8: 4180001C  blt 0x82615904
	if ctx.cr[0].lt {
	pc = 0x82615904; continue 'dispatch;
	}
	// 826158EC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 826158F0: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x826158F4; continue 'dispatch;
            }
            0x826158F4 => {
    //   block [0x826158F4..0x82615904)
	// 826158F4: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 826158F8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826158FC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82615900: 4080FFF4  bge 0x826158f4
	if !ctx.cr[0].lt {
	pc = 0x826158F4; continue 'dispatch;
	}
	pc = 0x82615904; continue 'dispatch;
            }
            0x82615904 => {
    //   block [0x82615904..0x82615924)
	// 82615904: 548B07FE  clrlwi r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82615908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261590C: 419A0018  beq cr6, 0x82615924
	if ctx.cr[6].eq {
	pc = 0x82615924; continue 'dispatch;
	}
	// 82615910: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82615914: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82615918: 814BDAB4  lwz r10, -0x254c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 8261591C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82615920: 4E800421  bctrl
	ctx.lr = 0x82615924;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82615924 => {
    //   block [0x82615924..0x8261592C)
	// 82615924: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82615928: 48000034  b 0x8261595c
	pc = 0x8261595C; continue 'dispatch;
            }
            0x8261592C => {
    //   block [0x8261592C..0x82615958)
	// 8261592C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82615930: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82615934: 392B9128  addi r9, r11, -0x6ed8
	ctx.r[9].s64 = ctx.r[11].s64 + -28376;
	// 82615938: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261593C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82615940: 419A0018  beq cr6, 0x82615958
	if ctx.cr[6].eq {
	pc = 0x82615958; continue 'dispatch;
	}
	// 82615944: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82615948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261594C: 814BDAB4  lwz r10, -0x254c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82615950: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82615954: 4E800421  bctrl
	ctx.lr = 0x82615958;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82615958 => {
    //   block [0x82615958..0x8261595C)
	// 82615958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8261595C; continue 'dispatch;
            }
            0x8261595C => {
    //   block [0x8261595C..0x82615974)
	// 8261595C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82615960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82615964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82615968: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8261596C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82615970: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82615978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82615978 size=28
    let mut pc: u32 = 0x82615978;
    'dispatch: loop {
        match pc {
            0x82615978 => {
    //   block [0x82615978..0x82615994)
	// 82615978: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8261597C: 894B0BA8  lbz r10, 0xba8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2984 as u32) ) } as u64;
	// 82615980: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82615984: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82615988: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8261598C: 994B0BA8  stb r10, 0xba8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2984 as u32), ctx.r[10].u8 ) };
	// 82615990: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82615998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82615998 size=240
    let mut pc: u32 = 0x82615998;
    'dispatch: loop {
        match pc {
            0x82615998 => {
    //   block [0x82615998..0x826159C4)
	// 82615998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261599C: 48693A69  bl 0x82ca9404
	ctx.lr = 0x826159A0;
	sub_82CA93D0(ctx, base);
	// 826159A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826159A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826159A8: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 826159AC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826159B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826159B4: 409A0010  bne cr6, 0x826159c4
	if !ctx.cr[6].eq {
	pc = 0x826159C4; continue 'dispatch;
	}
	// 826159B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826159BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826159C0: 48693A94  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x826159C4 => {
    //   block [0x826159C4..0x82615A88)
	// 826159C4: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826159C8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 826159CC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 826159D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826159D4: 392A83C4  addi r9, r10, -0x7c3c
	ctx.r[9].s64 = ctx.r[10].s64 + -31804;
	// 826159D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826159DC: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826159E0: 550A1838  slwi r10, r8, 3
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826159E4: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 826159E8: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 826159EC: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 826159F0: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 826159F4: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 826159F8: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 826159FC: 4BFFF3AD  bl 0x82614da8
	ctx.lr = 0x82615A00;
	sub_82614DA8(ctx, base);
	// 82615A00: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 82615A04: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 82615A08: 809F003C  lwz r4, 0x3c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82615A0C: 3B669128  addi r27, r6, -0x6ed8
	ctx.r[27].s64 = ctx.r[6].s64 + -28376;
	// 82615A10: 386583E0  addi r3, r5, -0x7c20
	ctx.r[3].s64 = ctx.r[5].s64 + -31776;
	// 82615A14: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82615A18: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 82615A1C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82615A20: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82615A24: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82615A28: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82615A2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82615A30: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615A34: 48000ACD  bl 0x82616500
	ctx.lr = 0x82615A38;
	sub_82616500(ctx, base);
	// 82615A38: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82615A3C: 57CA1838  slwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82615A40: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615A44: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82615A48: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82615A4C: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82615A50: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82615A54: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82615A58: 80FC0000  lwz r7, 0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615A5C: 54EA1838  slwi r10, r7, 3
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82615A60: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82615A64: 48000A25  bl 0x82616488
	ctx.lr = 0x82615A68;
	sub_82616488(ctx, base);
	// 82615A68: 80DC0000  lwz r6, 0(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615A6C: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82615A70: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82615A74: 54CB1838  slwi r11, r6, 3
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82615A78: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82615A7C: 93A50004  stw r29, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82615A80: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82615A84: 486939D0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82615A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82615A88 size=220
    let mut pc: u32 = 0x82615A88;
    'dispatch: loop {
        match pc {
            0x82615A88 => {
    //   block [0x82615A88..0x82615AB4)
	// 82615A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82615A8C: 48693979  bl 0x82ca9404
	ctx.lr = 0x82615A90;
	sub_82CA93D0(ctx, base);
	// 82615A90: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82615A94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82615A98: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82615A9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615AA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82615AA4: 409A0010  bne cr6, 0x82615ab4
	if !ctx.cr[6].eq {
	pc = 0x82615AB4; continue 'dispatch;
	}
	// 82615AA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82615AAC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82615AB0: 486939A4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82615AB4 => {
    //   block [0x82615AB4..0x82615B64)
	// 82615AB4: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615AB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82615ABC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82615AC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82615AC4: 394B83C4  addi r10, r11, -0x7c3c
	ctx.r[10].s64 = ctx.r[11].s64 + -31804;
	// 82615AC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82615ACC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82615AD0: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82615AD4: 4BFFF2D5  bl 0x82614da8
	ctx.lr = 0x82615AD8;
	sub_82614DA8(ctx, base);
	// 82615AD8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82615ADC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82615AE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82615AE4: 3B899128  addi r28, r9, -0x6ed8
	ctx.r[28].s64 = ctx.r[9].s64 + -28376;
	// 82615AE8: 80BF003C  lwz r5, 0x3c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82615AEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82615AF0: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82615AF4: 837D0000  lwz r27, 0(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615AF8: 576A1838  slwi r10, r27, 3
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82615AFC: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82615B00: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615B04: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 82615B08: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82615B0C: 4800005D  bl 0x82615b68
	ctx.lr = 0x82615B10;
	sub_82615B68(ctx, base);
	// 82615B10: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82615B14: 576A1838  slwi r10, r27, 3
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82615B18: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615B1C: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82615B20: 90E60004  stw r7, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82615B24: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82615B28: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82615B2C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82615B30: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615B34: 54AB1838  slwi r11, r5, 3
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82615B38: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82615B3C: 4800094D  bl 0x82616488
	ctx.lr = 0x82615B40;
	sub_82616488(ctx, base);
	// 82615B40: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615B44: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82615B48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82615B4C: 546B1838  slwi r11, r3, 3
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82615B50: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82615B54: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82615B58: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615B5C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82615B60: 486938F4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82615B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82615B68 size=152
    let mut pc: u32 = 0x82615B68;
    'dispatch: loop {
        match pc {
            0x82615B68 => {
    //   block [0x82615B68..0x82615BA8)
	// 82615B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82615B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82615B70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82615B74: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82615B78: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82615B7C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82615B80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82615B84: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82615B88: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82615B90: 419A003C  beq cr6, 0x82615bcc
	if ctx.cr[6].eq {
	pc = 0x82615BCC; continue 'dispatch;
	}
	// 82615B94: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615B98: 814A0048  lwz r10, 0x48(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82615B9C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615BA0: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82615BA4: 7C07542E  lfsx f0, r7, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82615BA8; continue 'dispatch;
            }
            0x82615BA8 => {
    //   block [0x82615BA8..0x82615BCC)
	// 82615BA8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615BAC: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615BB0: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82615BB4: 7DA7542E  lfsx f13, r7, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82615BB8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82615BBC: 41990010  bgt cr6, 0x82615bcc
	if ctx.cr[6].gt {
	pc = 0x82615BCC; continue 'dispatch;
	}
	// 82615BC0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82615BC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82615BC8: 409AFFE0  bne cr6, 0x82615ba8
	if !ctx.cr[6].eq {
	pc = 0x82615BA8; continue 'dispatch;
	}
	pc = 0x82615BCC; continue 'dispatch;
            }
            0x82615BCC => {
    //   block [0x82615BCC..0x82615C00)
	// 82615BCC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82615BD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82615BD4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82615BD8: 392A83E0  addi r9, r10, -0x7c20
	ctx.r[9].s64 = ctx.r[10].s64 + -31776;
	// 82615BDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82615BE0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82615BE4: 4800091D  bl 0x82616500
	ctx.lr = 0x82615BE8;
	sub_82616500(ctx, base);
	// 82615BE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82615BEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82615BF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82615BF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82615BF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82615BFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82615C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82615C00 size=1392
    let mut pc: u32 = 0x82615C00;
    'dispatch: loop {
        match pc {
            0x82615C00 => {
    //   block [0x82615C00..0x82615C5C)
	// 82615C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82615C04: 48693805  bl 0x82ca9408
	ctx.lr = 0x82615C08;
	sub_82CA93D0(ctx, base);
	// 82615C08: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82615C0C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82615C10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82615C14: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82615C18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82615C1C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615C20: C3EA9484  lfs f31, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82615C24: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82615C28: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82615C2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82615C30: 419A006C  beq cr6, 0x82615c9c
	if ctx.cr[6].eq {
	pc = 0x82615C9C; continue 'dispatch;
	}
	// 82615C34: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615C38: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82615C3C: 7D09502E  lwzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82615C40: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82615C44: 419A0058  beq cr6, 0x82615c9c
	if ctx.cr[6].eq {
	pc = 0x82615C9C; continue 'dispatch;
	}
	// 82615C48: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82615C4C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82615C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82615C54: 419A0008  beq cr6, 0x82615c5c
	if ctx.cr[6].eq {
	pc = 0x82615C5C; continue 'dispatch;
	}
	// 82615C58: 7C6B482E  lwzx r3, r11, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	pc = 0x82615C5C; continue 'dispatch;
            }
            0x82615C5C => {
    //   block [0x82615C5C..0x82615C9C)
	// 82615C5C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615C60: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82615C64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615C68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82615C6C: 80CA0024  lwz r6, 0x24(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82615C70: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82615C74: 808A002C  lwz r4, 0x2c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82615C78: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82615C7C: 4E800421  bctrl
	ctx.lr = 0x82615C80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82615C80: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82615C84: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82615C88: 409A0044  bne cr6, 0x82615ccc
	if !ctx.cr[6].eq {
	pc = 0x82615CCC; continue 'dispatch;
	}
	// 82615C8C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82615C90: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82615C94: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82615C98: 486937C0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82615C9C => {
    //   block [0x82615C9C..0x82615CCC)
	// 82615C9C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615CA0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82615CA4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82615CA8: 806B0024  lwz r3, 0x24(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82615CAC: 808B002C  lwz r4, 0x2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82615CB0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615CB4: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82615CB8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82615CBC: 4E800421  bctrl
	ctx.lr = 0x82615CC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82615CC0: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82615CC4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82615CC8: 419A0498  beq cr6, 0x82616160
	if ctx.cr[6].eq {
	pc = 0x82616160; continue 'dispatch;
	}
            }
            0x82615CCC => {
    //   block [0x82615CCC..0x82615DD8)
	// 82615CCC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615CD0: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82615CD4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615CD8: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615CDC: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82615CE0: 810B0038  lwz r8, 0x38(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82615CE4: 80CB0018  lwz r6, 0x18(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82615CE8: 80A90044  lwz r5, 0x44(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(68 as u32) ) } as u64;
	// 82615CEC: C1A9001C  lfs f13, 0x1c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82615CF0: 7D48382E  lwzx r10, r8, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82615CF4: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82615CF8: 7C8A4A14  add r4, r10, r9
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82615CFC: 5483103A  slwi r3, r4, 2
	ctx.r[3].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82615D00: 7D43302E  lwzx r10, r3, r6
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82615D04: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82615D08: 7D892C2E  lfsx f12, r9, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82615D0C: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82615D10: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 82615D14: 4199044C  bgt cr6, 0x82616160
	if ctx.cr[6].gt {
	pc = 0x82616160; continue 'dispatch;
	}
	// 82615D18: 550A003E  slwi r10, r8, 0
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82615D1C: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615D20: 54C5003E  slwi r5, r6, 0
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82615D24: 7D4A382E  lwzx r10, r10, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82615D28: C0080020  lfs f0, 0x20(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82615D2C: 81280018  lwz r9, 0x18(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 82615D30: 5546103A  slwi r6, r10, 2
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82615D34: 7CCA3214  add r6, r10, r6
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 82615D38: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82615D3C: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82615D40: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82615D44: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 82615D48: C169000C  lfs f11, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82615D4C: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 82615D50: C14A0004  lfs f10, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82615D54: ED2A6828  fsubs f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82615D58: C10A0008  lfs f8, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82615D5C: ECE86028  fsubs f7, f8, f12
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 82615D60: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82615D64: ECA65828  fsubs f5, f6, f11
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[11].f64) as f32) as f64);
	// 82615D68: EC890272  fmuls f4, f9, f9
	ctx.f[4].f64 = (((ctx.f[9].f64 * ctx.f[9].f64) as f32) as f64);
	// 82615D6C: EC6721FA  fmadds f3, f7, f7, f4
	ctx.f[3].f64 = (((ctx.f[7].f64 * ctx.f[7].f64 + ctx.f[4].f64) as f32) as f64);
	// 82615D70: EC45197A  fmadds f2, f5, f5, f3
	ctx.f[2].f64 = (((ctx.f[5].f64 * ctx.f[5].f64 + ctx.f[3].f64) as f32) as f64);
	// 82615D74: EC20102C  fsqrts f1, f2
	ctx.f[1].f64 = ((ctx.f[2].f64).sqrt() as f32) as f64;
	// 82615D78: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82615D7C: 419903E4  bgt cr6, 0x82616160
	if ctx.cr[6].gt {
	pc = 0x82616160; continue 'dispatch;
	}
	// 82615D80: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82615D84: 81480028  lwz r10, 0x28(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(40 as u32) ) } as u64;
	// 82615D88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82615D8C: 419A004C  beq cr6, 0x82615dd8
	if ctx.cr[6].eq {
	pc = 0x82615DD8; continue 'dispatch;
	}
	// 82615D90: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82615D94: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82615D98: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82615D9C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82615DA0: 7D6A382E  lwzx r11, r10, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82615DA4: 80680028  lwz r3, 0x28(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(40 as u32) ) } as u64;
	// 82615DA8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82615DAC: 8088002C  lwz r4, 0x2c(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(44 as u32) ) } as u64;
	// 82615DB0: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82615DB4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615DB8: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82615DBC: 7CAB4A14  add r5, r11, r9
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82615DC0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615DC4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82615DC8: 4E800421  bctrl
	ctx.lr = 0x82615DCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82615DCC: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82615DD0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82615DD4: 419A038C  beq cr6, 0x82616160
	if ctx.cr[6].eq {
	pc = 0x82616160; continue 'dispatch;
	}
            }
            0x82615DD8 => {
    //   block [0x82615DD8..0x82615F90)
	// 82615DD8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615DDC: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82615DE0: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615DE4: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82615DE8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615DEC: 38A883E0  addi r5, r8, -0x7c20
	ctx.r[5].s64 = ctx.r[8].s64 + -31776;
	// 82615DF0: 80DE0008  lwz r6, 8(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615DF4: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82615DF8: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82615DFC: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 82615E00: 808A003C  lwz r4, 0x3c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 82615E04: 806A0018  lwz r3, 0x18(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82615E08: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615E0C: 83A60044  lwz r29, 0x44(r6)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(68 as u32) ) } as u64;
	// 82615E10: 555C103A  slwi r28, r10, 2
	ctx.r[28].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82615E14: 81060040  lwz r8, 0x40(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(64 as u32) ) } as u64;
	// 82615E18: 7D44582E  lwzx r10, r4, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82615E1C: 80E60038  lwz r7, 0x38(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(56 as u32) ) } as u64;
	// 82615E20: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82615E24: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 82615E28: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82615E2C: 7D9CEC2E  lfsx f12, r28, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82615E30: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82615E34: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82615E38: 7CA6182E  lwzx r5, r6, r3
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82615E3C: 54BD1838  slwi r29, r5, 3
	ctx.r[29].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82615E40: 7C88EA14  add r4, r8, r29
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[29].u64;
	// 82615E44: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82615E48: 7C67EA14  add r3, r7, r29
	ctx.r[3].u64 = ctx.r[7].u64 + ctx.r[29].u64;
	// 82615E4C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615E50: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615E54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82615E58: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82615E5C: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82615E60: 419A0130  beq cr6, 0x82615f90
	if ctx.cr[6].eq {
	pc = 0x82615F90; continue 'dispatch;
	}
	// 82615E64: 838A0008  lwz r28, 8(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615E68: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615E6C: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615E70: 810A0048  lwz r8, 0x48(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82615E74: 5527103A  slwi r7, r9, 2
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82615E78: 7D87442E  lfsx f12, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82615E7C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82615E80: 409802E0  bge cr6, 0x82616160
	if !ctx.cr[6].lt {
	pc = 0x82616160; continue 'dispatch;
	}
	// 82615E84: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615E88: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82615E8C: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615E90: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82615E94: 39099128  addi r8, r9, -0x6ed8
	ctx.r[8].s64 = ctx.r[9].s64 + -28376;
	// 82615E98: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82615E9C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82615EA0: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 82615EA4: 80EA003C  lwz r7, 0x3c(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 82615EA8: 80AA0018  lwz r5, 0x18(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82615EAC: 81240044  lwz r9, 0x44(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(68 as u32) ) } as u64;
	// 82615EB0: 7D67582E  lwzx r11, r7, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82615EB4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82615EB8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82615EBC: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82615EC0: 7CA7282E  lwzx r5, r7, r5
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 82615EC4: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82615EC8: 7C0B4D2E  stfsx f0, r11, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82615ECC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615ED0: 81240048  lwz r9, 0x48(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82615ED4: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615ED8: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82615EDC: 80AA003C  lwz r5, 0x3c(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 82615EE0: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82615EE4: 7D67282E  lwzx r11, r7, r5
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 82615EE8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82615EEC: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82615EF0: 54E5103A  slwi r5, r7, 2
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82615EF4: 7D65402E  lwzx r11, r5, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82615EF8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82615EFC: 7DAA4D2E  stfsx f13, r10, r9
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82615F00: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615F04: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615F08: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82615F0C: 80A40034  lwz r5, 0x34(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82615F10: 80E9003C  lwz r7, 0x3c(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(60 as u32) ) } as u64;
	// 82615F14: 81290018  lwz r9, 0x18(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82615F18: 7D6B382E  lwzx r11, r11, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82615F1C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82615F20: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82615F24: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82615F28: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82615F2C: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82615F30: 4BFFFC39  bl 0x82615b68
	ctx.lr = 0x82615F34;
	sub_82615B68(ctx, base);
	// 82615F34: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615F38: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615F3C: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 82615F40: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82615F44: 38669128  addi r3, r6, -0x6ed8
	ctx.r[3].s64 = ctx.r[6].s64 + -28376;
	// 82615F48: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82615F4C: 81680038  lwz r11, 0x38(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(56 as u32) ) } as u64;
	// 82615F50: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82615F54: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82615F58: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615F5C: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 82615F60: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615F64: 550A1838  slwi r10, r8, 3
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82615F68: 81690040  lwz r11, 0x40(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 82615F6C: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82615F70: 90A70004  stw r5, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82615F74: 80DE0008  lwz r6, 8(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615F78: 8066003C  lwz r3, 0x3c(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(60 as u32) ) } as u64;
	// 82615F7C: 4800050D  bl 0x82616488
	ctx.lr = 0x82615F80;
	sub_82616488(ctx, base);
	// 82615F80: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82615F84: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82615F88: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82615F8C: 486934CC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82615F90 => {
    //   block [0x82615F90..0x8261609C)
	// 82615F90: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82615F94: 419A0108  beq cr6, 0x8261609c
	if ctx.cr[6].eq {
	pc = 0x8261609C; continue 'dispatch;
	}
	// 82615F98: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615F9C: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82615FA0: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615FA4: 80E90048  lwz r7, 0x48(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(72 as u32) ) } as u64;
	// 82615FA8: 5506103A  slwi r6, r8, 2
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82615FAC: 7D863C2E  lfsx f12, r6, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82615FB0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82615FB4: 409801AC  bge cr6, 0x82616160
	if !ctx.cr[6].lt {
	pc = 0x82616160; continue 'dispatch;
	}
	// 82615FB8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615FBC: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82615FC0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82615FC4: 810A003C  lwz r8, 0x3c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 82615FC8: 80EA0018  lwz r7, 0x18(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82615FCC: 80C90044  lwz r6, 0x44(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(68 as u32) ) } as u64;
	// 82615FD0: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82615FD4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82615FD8: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82615FDC: 54A3103A  slwi r3, r5, 2
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82615FE0: 7D63382E  lwzx r11, r3, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82615FE4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82615FE8: 7C0A352E  stfsx f0, r10, r6
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 82615FEC: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82615FF0: 80E90048  lwz r7, 0x48(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(72 as u32) ) } as u64;
	// 82615FF4: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82615FF8: 54C5103A  slwi r5, r6, 2
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82615FFC: 8068003C  lwz r3, 0x3c(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(60 as u32) ) } as u64;
	// 82616000: 81080018  lwz r8, 0x18(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 82616004: 7D63282E  lwzx r11, r3, r5
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 82616008: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8261600C: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82616010: 54C5103A  slwi r5, r6, 2
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82616014: 7C65402E  lwzx r3, r5, r8
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82616018: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261601C: 7DAB3D2E  stfsx f13, r11, r7
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 82616020: 80690034  lwz r3, 0x34(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) } as u64;
	// 82616024: 48000465  bl 0x82616488
	ctx.lr = 0x82616028;
	sub_82616488(ctx, base);
	// 82616028: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261602C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82616030: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82616034: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82616038: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8261603C: 390A9128  addi r8, r10, -0x6ed8
	ctx.r[8].s64 = ctx.r[10].s64 + -28376;
	// 82616040: 8149003C  lwz r10, 0x3c(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(60 as u32) ) } as u64;
	// 82616044: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82616048: 81290018  lwz r9, 0x18(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 8261604C: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 82616050: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82616054: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616058: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8261605C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82616060: 80A40034  lwz r5, 0x34(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82616064: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82616068: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261606C: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82616070: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82616074: 4BFFFAF5  bl 0x82615b68
	ctx.lr = 0x82616078;
	sub_82615B68(ctx, base);
	// 82616078: 80DE0008  lwz r6, 8(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261607C: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82616080: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82616084: 81660038  lwz r11, 0x38(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(56 as u32) ) } as u64;
	// 82616088: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8261608C: 90A40004  stw r5, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82616090: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82616094: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82616098: 486933C0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261609C => {
    //   block [0x8261609C..0x82616160)
	// 8261609C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826160A0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 826160A4: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 826160A8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 826160AC: 39099128  addi r8, r9, -0x6ed8
	ctx.r[8].s64 = ctx.r[9].s64 + -28376;
	// 826160B0: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 826160B4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826160B8: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 826160BC: 80EA003C  lwz r7, 0x3c(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 826160C0: 80AA0018  lwz r5, 0x18(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 826160C4: 81240044  lwz r9, 0x44(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(68 as u32) ) } as u64;
	// 826160C8: 7D67582E  lwzx r11, r7, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826160CC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826160D0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 826160D4: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 826160D8: 7CA7282E  lwzx r5, r7, r5
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 826160DC: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826160E0: 7C0B4D2E  stfsx f0, r11, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 826160E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826160E8: 81240048  lwz r9, 0x48(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 826160EC: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826160F0: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 826160F4: 80AA003C  lwz r5, 0x3c(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 826160F8: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 826160FC: 7D65382E  lwzx r11, r5, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82616100: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82616104: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82616108: 54E5103A  slwi r5, r7, 2
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8261610C: 7D65402E  lwzx r11, r5, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82616110: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82616114: 7DAA4D2E  stfsx f13, r10, r9
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82616118: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261611C: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82616120: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82616124: 80A40034  lwz r5, 0x34(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82616128: 80E9003C  lwz r7, 0x3c(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(60 as u32) ) } as u64;
	// 8261612C: 81290018  lwz r9, 0x18(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82616130: 7D67582E  lwzx r11, r7, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82616134: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82616138: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8261613C: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82616140: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82616144: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82616148: 4BFFFA21  bl 0x82615b68
	ctx.lr = 0x8261614C;
	sub_82615B68(ctx, base);
	// 8261614C: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616150: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82616154: 81680038  lwz r11, 0x38(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(56 as u32) ) } as u64;
	// 82616158: 7CCBEA14  add r6, r11, r29
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8261615C: 90E60004  stw r7, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x82616160; continue 'dispatch;
            }
            0x82616160 => {
    //   block [0x82616160..0x82616170)
	// 82616160: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82616164: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82616168: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8261616C: 486932EC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82616170 size=456
    let mut pc: u32 = 0x82616170;
    'dispatch: loop {
        match pc {
            0x82616170 => {
    //   block [0x82616170..0x82616198)
	// 82616170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82616174: 4869328D  bl 0x82ca9400
	ctx.lr = 0x82616178;
	sub_82CA93D0(ctx, base);
	// 82616178: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261617C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82616180: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82616184: 3BEBDAC0  addi r31, r11, -0x2540
	ctx.r[31].s64 = ctx.r[11].s64 + -9536;
	// 82616188: 815D0034  lwz r10, 0x34(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 8261618C: 83CA0008  lwz r30, 8(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616190: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82616194: 419A00C8  beq cr6, 0x8261625c
	if ctx.cr[6].eq {
	pc = 0x8261625C; continue 'dispatch;
	}
	pc = 0x82616198; continue 'dispatch;
            }
            0x82616198 => {
    //   block [0x82616198..0x826161C4)
	// 82616198: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261619C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826161A0: 419A0024  beq cr6, 0x826161c4
	if ctx.cr[6].eq {
	pc = 0x826161C4; continue 'dispatch;
	}
	// 826161A4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 826161A8: 38C0005C  li r6, 0x5c
	ctx.r[6].s64 = 92;
	// 826161AC: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 826161B0: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 826161B4: 3880005C  li r4, 0x5c
	ctx.r[4].s64 = 92;
	// 826161B8: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 826161BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 826161C0: 4E800421  bctrl
	ctx.lr = 0x826161C4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x826161C4 => {
    //   block [0x826161C4..0x82616250)
	// 826161C4: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 826161C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826161CC: 419A0084  beq cr6, 0x82616250
	if ctx.cr[6].eq {
	pc = 0x82616250; continue 'dispatch;
	}
	// 826161D0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826161D4: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 826161D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826161DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826161E0: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 826161E4: 419A006C  beq cr6, 0x82616250
	if ctx.cr[6].eq {
	pc = 0x82616250; continue 'dispatch;
	}
	// 826161E8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826161EC: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 826161F0: 808A003C  lwz r4, 0x3c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 826161F4: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 826161F8: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 826161FC: 83890038  lwz r28, 0x38(r9)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(56 as u32) ) } as u64;
	// 82616200: 5503103A  slwi r3, r8, 2
	ctx.r[3].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82616204: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82616208: 54BB103A  slwi r27, r5, 2
	ctx.r[27].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 8261620C: 81290018  lwz r9, 0x18(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82616210: 835F0048  lwz r26, 0x48(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82616214: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 82616218: 7D64182E  lwzx r11, r4, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 8261621C: 7D5BE02E  lwzx r10, r27, r28
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82616220: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82616224: 5543103A  slwi r3, r10, 2
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82616228: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 8261622C: 7C8A1A14  add r4, r10, r3
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82616230: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82616234: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82616238: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8261623C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82616240: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 82616244: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82616248: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 8261624C: 4E800421  bctrl
	ctx.lr = 0x82616250;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82616250 => {
    //   block [0x82616250..0x8261625C)
	// 82616250: 83DE0014  lwz r30, 0x14(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82616254: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82616258: 409AFF40  bne cr6, 0x82616198
	if !ctx.cr[6].eq {
	pc = 0x82616198; continue 'dispatch;
	}
	pc = 0x8261625C; continue 'dispatch;
            }
            0x8261625C => {
    //   block [0x8261625C..0x8261626C)
	// 8261625C: 817D003C  lwz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 82616260: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616264: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82616268: 419A00C8  beq cr6, 0x82616330
	if ctx.cr[6].eq {
	pc = 0x82616330; continue 'dispatch;
	}
	pc = 0x8261626C; continue 'dispatch;
            }
            0x8261626C => {
    //   block [0x8261626C..0x82616298)
	// 8261626C: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82616270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82616274: 419A0024  beq cr6, 0x82616298
	if ctx.cr[6].eq {
	pc = 0x82616298; continue 'dispatch;
	}
	// 82616278: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261627C: 38C0005C  li r6, 0x5c
	ctx.r[6].s64 = 92;
	// 82616280: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82616284: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 82616288: 388000FF  li r4, 0xff
	ctx.r[4].s64 = 255;
	// 8261628C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82616290: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82616294: 4E800421  bctrl
	ctx.lr = 0x82616298;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82616298 => {
    //   block [0x82616298..0x82616324)
	// 82616298: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261629C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826162A0: 419A0084  beq cr6, 0x82616324
	if ctx.cr[6].eq {
	pc = 0x82616324; continue 'dispatch;
	}
	// 826162A4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826162A8: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 826162AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826162B0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826162B4: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 826162B8: 419A006C  beq cr6, 0x82616324
	if ctx.cr[6].eq {
	pc = 0x82616324; continue 'dispatch;
	}
	// 826162BC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826162C0: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 826162C4: 808A003C  lwz r4, 0x3c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 826162C8: 38C00080  li r6, 0x80
	ctx.r[6].s64 = 128;
	// 826162CC: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 826162D0: 81690038  lwz r11, 0x38(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(56 as u32) ) } as u64;
	// 826162D4: 5503103A  slwi r3, r8, 2
	ctx.r[3].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 826162D8: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 826162DC: 54BD103A  slwi r29, r5, 2
	ctx.r[29].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 826162E0: 81290018  lwz r9, 0x18(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 826162E4: 839F0048  lwz r28, 0x48(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 826162E8: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 826162EC: 7D43202E  lwzx r10, r3, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 826162F0: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826162F4: 5543103A  slwi r3, r10, 2
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 826162F8: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 826162FC: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82616300: 7C8B2214  add r4, r11, r4
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82616304: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82616308: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261630C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82616310: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82616314: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 82616318: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 8261631C: 7F8903A6  mtctr r28
	ctx.ctr.u64 = ctx.r[28].u64;
	// 82616320: 4E800421  bctrl
	ctx.lr = 0x82616324;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82616324 => {
    //   block [0x82616324..0x82616330)
	// 82616324: 83DE0014  lwz r30, 0x14(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82616328: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261632C: 409AFF40  bne cr6, 0x8261626c
	if !ctx.cr[6].eq {
	pc = 0x8261626C; continue 'dispatch;
	}
	pc = 0x82616330; continue 'dispatch;
            }
            0x82616330 => {
    //   block [0x82616330..0x82616338)
	// 82616330: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82616334: 4869311C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82616338 size=332
    let mut pc: u32 = 0x82616338;
    'dispatch: loop {
        match pc {
            0x82616338 => {
    //   block [0x82616338..0x826163A0)
	// 82616338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261633C: 486930D1  bl 0x82ca940c
	ctx.lr = 0x82616340;
	sub_82CA93D0(ctx, base);
	// 82616340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82616344: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82616348: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261634C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82616350: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82616354: 394B83D8  addi r10, r11, -0x7c28
	ctx.r[10].s64 = ctx.r[11].s64 + -31784;
	// 82616358: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 8261635C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82616360: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82616364: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82616368: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 8261636C: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82616370: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82616374: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82616378: 419A0100  beq cr6, 0x82616478
	if ctx.cr[6].eq {
	pc = 0x82616478; continue 'dispatch;
	}
	// 8261637C: 3D600924  lis r11, 0x924
	ctx.r[11].s64 = 153354240;
	// 82616380: 616A9249  ori r10, r11, 0x9249
	ctx.r[10].u64 = ctx.r[11].u64 | 37449;
	// 82616384: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82616388: 41990018  bgt cr6, 0x826163a0
	if ctx.cr[6].gt {
	pc = 0x826163A0; continue 'dispatch;
	}
	// 8261638C: 1D7D001C  mulli r11, r29, 0x1c
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82616390: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82616394: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82616398: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261639C: 40990008  ble cr6, 0x826163a4
	if !ctx.cr[6].gt {
	pc = 0x826163A4; continue 'dispatch;
	}
	pc = 0x826163A0; continue 'dispatch;
            }
            0x826163A0 => {
    //   block [0x826163A0..0x826163A4)
	// 826163A0: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x826163A4; continue 'dispatch;
            }
            0x826163A4 => {
    //   block [0x826163A4..0x826163D8)
	// 826163A4: 48000585  bl 0x82616928
	ctx.lr = 0x826163A8;
	sub_82616928(ctx, base);
	// 826163A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826163AC: 419A0060  beq cr6, 0x8261640c
	if ctx.cr[6].eq {
	pc = 0x8261640C; continue 'dispatch;
	}
	// 826163B0: 38C30004  addi r6, r3, 4
	ctx.r[6].s64 = ctx.r[3].s64 + 4;
	// 826163B4: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 826163B8: 355DFFFF  addic. r10, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 826163BC: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 826163C0: 41800044  blt 0x82616404
	if ctx.cr[0].lt {
	pc = 0x82616404; continue 'dispatch;
	}
	// 826163C4: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 826163C8: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 826163CC: 3969000C  addi r11, r9, 0xc
	ctx.r[11].s64 = ctx.r[9].s64 + 12;
	// 826163D0: 39089128  addi r8, r8, -0x6ed8
	ctx.r[8].s64 = ctx.r[8].s64 + -28376;
	// 826163D4: 38E783DC  addi r7, r7, -0x7c24
	ctx.r[7].s64 = ctx.r[7].s64 + -31780;
	pc = 0x826163D8; continue 'dispatch;
            }
            0x826163D8 => {
    //   block [0x826163D8..0x82616404)
	// 826163D8: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 826163DC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 826163E0: 910BFFF8  stw r8, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[8].u32 ) };
	// 826163E4: 3929001C  addi r9, r9, 0x1c
	ctx.r[9].s64 = ctx.r[9].s64 + 28;
	// 826163E8: 93CBFFFC  stw r30, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[30].u32 ) };
	// 826163EC: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 826163F0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 826163F4: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 826163F8: 9BCB000C  stb r30, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u8 ) };
	// 826163FC: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 82616400: 4080FFD8  bge 0x826163d8
	if !ctx.cr[0].lt {
	pc = 0x826163D8; continue 'dispatch;
	}
	pc = 0x82616404; continue 'dispatch;
            }
            0x82616404 => {
    //   block [0x82616404..0x8261640C)
	// 82616404: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82616408: 48000008  b 0x82616410
	pc = 0x82616410; continue 'dispatch;
            }
            0x8261640C => {
    //   block [0x8261640C..0x82616410)
	// 8261640C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82616410; continue 'dispatch;
            }
            0x82616410 => {
    //   block [0x82616410..0x82616430)
	// 82616410: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82616414: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82616418: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8261641C: 93CB0010  stw r30, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82616420: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82616424: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82616428: 4099003C  ble cr6, 0x82616464
	if !ctx.cr[6].gt {
	pc = 0x82616464; continue 'dispatch;
	}
	// 8261642C: 3960001C  li r11, 0x1c
	ctx.r[11].s64 = 28;
	pc = 0x82616430; continue 'dispatch;
            }
            0x82616430 => {
    //   block [0x82616430..0x82616464)
	// 82616430: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82616434: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82616438: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8261643C: 3909FFE4  addi r8, r9, -0x1c
	ctx.r[8].s64 = ctx.r[9].s64 + -28;
	// 82616440: 91090010  stw r8, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82616444: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82616448: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8261644C: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 82616450: 80E90010  lwz r7, 0x10(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82616454: 91270014  stw r9, 0x14(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82616458: 80DF0018  lwz r6, 0x18(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8261645C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82616460: 4198FFD0  blt cr6, 0x82616430
	if ctx.cr[6].lt {
	pc = 0x82616430; continue 'dispatch;
	}
	pc = 0x82616464; continue 'dispatch;
            }
            0x82616464 => {
    //   block [0x82616464..0x82616478)
	// 82616464: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82616468: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261646C: 1D6B001C  mulli r11, r11, 0x1c
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82616470: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82616474: 93CAFFF8  stw r30, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[30].u32 ) };
	pc = 0x82616478; continue 'dispatch;
            }
            0x82616478 => {
    //   block [0x82616478..0x82616484)
	// 82616478: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261647C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82616480: 48692FDC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82616488 size=120
    let mut pc: u32 = 0x82616488;
    'dispatch: loop {
        match pc {
            0x82616488 => {
    //   block [0x82616488..0x826164A8)
	// 82616488: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261648C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82616490: 994B0018  stb r10, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 82616494: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616498: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8261649C: 409A000C  bne cr6, 0x826164a8
	if !ctx.cr[6].eq {
	pc = 0x826164A8; continue 'dispatch;
	}
	// 826164A0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 826164A4: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x826164A8; continue 'dispatch;
            }
            0x826164A8 => {
    //   block [0x826164A8..0x826164BC)
	// 826164A8: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 826164AC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 826164B0: 409A000C  bne cr6, 0x826164bc
	if !ctx.cr[6].eq {
	pc = 0x826164BC; continue 'dispatch;
	}
	// 826164B4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 826164B8: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x826164BC; continue 'dispatch;
            }
            0x826164BC => {
    //   block [0x826164BC..0x826164D0)
	// 826164BC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 826164C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826164C4: 419A000C  beq cr6, 0x826164d0
	if ctx.cr[6].eq {
	pc = 0x826164D0; continue 'dispatch;
	}
	// 826164C8: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 826164CC: 912A0014  stw r9, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	pc = 0x826164D0; continue 'dispatch;
            }
            0x826164D0 => {
    //   block [0x826164D0..0x826164E4)
	// 826164D0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 826164D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826164D8: 419A000C  beq cr6, 0x826164e4
	if ctx.cr[6].eq {
	pc = 0x826164E4; continue 'dispatch;
	}
	// 826164DC: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 826164E0: 912A0010  stw r9, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x826164E4; continue 'dispatch;
            }
            0x826164E4 => {
    //   block [0x826164E4..0x82616500)
	// 826164E4: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 826164E8: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 826164EC: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 826164F0: 392AFFFF  addi r9, r10, -1
	ctx.r[9].s64 = ctx.r[10].s64 + -1;
	// 826164F4: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 826164F8: 91230014  stw r9, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 826164FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82616500 size=52
    let mut pc: u32 = 0x82616500;
    'dispatch: loop {
        match pc {
            0x82616500 => {
    //   block [0x82616500..0x82616534)
	// 82616500: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82616504: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82616508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261650C: 409A0028  bne cr6, 0x82616534
	if !ctx.cr[6].eq {
		sub_82616534(ctx, base);
		return;
	}
	// 82616510: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82616514: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82616518: 392B83E0  addi r9, r11, -0x7c20
	ctx.r[9].s64 = ctx.r[11].s64 + -31776;
	// 8261651C: 390A9128  addi r8, r10, -0x6ed8
	ctx.r[8].s64 = ctx.r[10].s64 + -28376;
	// 82616520: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82616524: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82616528: 91060000  stw r8, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8261652C: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82616530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616534(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82616534 size=200
    let mut pc: u32 = 0x82616534;
    'dispatch: loop {
        match pc {
            0x82616534 => {
    //   block [0x82616534..0x8261659C)
	// 82616534: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82616538: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8261653C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82616540: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 82616544: 90E40014  stw r7, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 82616548: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8261654C: 91240010  stw r9, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82616550: 80E50004  lwz r7, 4(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82616554: 90EB0008  stw r7, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82616558: 80A50008  lwz r5, 8(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261655C: 90AB000C  stw r5, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 82616560: 990B0018  stb r8, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u8 ) };
	// 82616564: 409A0054  bne cr6, 0x826165b8
	if !ctx.cr[6].eq {
	pc = 0x826165B8; continue 'dispatch;
	}
	// 82616568: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261656C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82616570: 409A002C  bne cr6, 0x8261659c
	if !ctx.cr[6].eq {
	pc = 0x8261659C; continue 'dispatch;
	}
	// 82616574: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82616578: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8261657C: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82616580: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616584: 91490010  stw r10, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82616588: 8104000C  lwz r8, 0xc(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261658C: 91480010  stw r10, 0x10(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82616590: 80E4000C  lwz r7, 0xc(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82616594: 91470014  stw r10, 0x14(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82616598: 48000044  b 0x826165dc
	pc = 0x826165DC; continue 'dispatch;
            }
            0x8261659C => {
    //   block [0x8261659C..0x826165B8)
	// 8261659C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 826165A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826165A4: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 826165A8: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 826165AC: 91690014  stw r11, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 826165B0: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 826165B4: 48000028  b 0x826165dc
	pc = 0x826165DC; continue 'dispatch;
            }
            0x826165B8 => {
    //   block [0x826165B8..0x826165D8)
	// 826165B8: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 826165BC: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 826165C0: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 826165C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 826165C8: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 826165CC: 419A000C  beq cr6, 0x826165d8
	if ctx.cr[6].eq {
	pc = 0x826165D8; continue 'dispatch;
	}
	// 826165D0: 91690014  stw r11, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 826165D4: 48000008  b 0x826165dc
	pc = 0x826165DC; continue 'dispatch;
            }
            0x826165D8 => {
    //   block [0x826165D8..0x826165DC)
	// 826165D8: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x826165DC; continue 'dispatch;
            }
            0x826165DC => {
    //   block [0x826165DC..0x826165FC)
	// 826165DC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 826165E0: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826165E4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 826165E8: 390A83E0  addi r8, r10, -0x7c20
	ctx.r[8].s64 = ctx.r[10].s64 + -31776;
	// 826165EC: 38E99128  addi r7, r9, -0x6ed8
	ctx.r[7].s64 = ctx.r[9].s64 + -28376;
	// 826165F0: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 826165F4: 90E60000  stw r7, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 826165F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82616600 size=184
    let mut pc: u32 = 0x82616600;
    'dispatch: loop {
        match pc {
            0x82616600 => {
    //   block [0x82616600..0x8261666C)
	// 82616600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82616604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82616608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8261660C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82616610: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82616614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82616618: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261661C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82616620: 392B83D8  addi r9, r11, -0x7c28
	ctx.r[9].s64 = ctx.r[11].s64 + -31784;
	// 82616624: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82616628: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8261662C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82616630: 40990040  ble cr6, 0x82616670
	if !ctx.cr[6].gt {
	pc = 0x82616670; continue 'dispatch;
	}
	// 82616634: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82616638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261663C: 419A0034  beq cr6, 0x82616670
	if ctx.cr[6].eq {
	pc = 0x82616670; continue 'dispatch;
	}
	// 82616640: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82616644: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82616648: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8261664C: 419A0020  beq cr6, 0x8261666c
	if ctx.cr[6].eq {
	pc = 0x8261666C; continue 'dispatch;
	}
	// 82616650: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82616654: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82616658: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8261665C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82616660: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82616664: 4E800421  bctrl
	ctx.lr = 0x82616668;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82616668: 48000008  b 0x82616670
	pc = 0x82616670; continue 'dispatch;
            }
            0x8261666C => {
    //   block [0x8261666C..0x82616670)
	// 8261666C: 4BC056CD  bl 0x8221bd38
	ctx.lr = 0x82616670;
	sub_8221BD38(ctx, base);
	pc = 0x82616670; continue 'dispatch;
            }
            0x82616670 => {
    //   block [0x82616670..0x826166A0)
	// 82616670: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82616674: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82616678: 392B9128  addi r9, r11, -0x6ed8
	ctx.r[9].s64 = ctx.r[11].s64 + -28376;
	// 8261667C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82616680: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82616684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82616688: 419A0018  beq cr6, 0x826166a0
	if ctx.cr[6].eq {
	pc = 0x826166A0; continue 'dispatch;
	}
	// 8261668C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82616690: 814BDAB4  lwz r10, -0x254c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82616694: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82616698: 4E800421  bctrl
	ctx.lr = 0x8261669C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261669C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            0x826166A0 => {
    //   block [0x826166A0..0x826166B8)
	// 826166A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826166A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826166A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826166AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826166B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826166B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826166B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826166B8 size=204
    let mut pc: u32 = 0x826166B8;
    'dispatch: loop {
        match pc {
            0x826166B8 => {
    //   block [0x826166B8..0x826166FC)
	// 826166B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826166BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826166C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826166C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826166C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826166CC: 548B07BC  rlwinm r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 826166D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826166D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826166D8: 419A0060  beq cr6, 0x82616738
	if ctx.cr[6].eq {
	pc = 0x82616738; continue 'dispatch;
	}
	// 826166DC: 815FFFFC  lwz r10, -4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 826166E0: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 826166E4: 1D6A001C  mulli r11, r10, 0x1c
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 826166E8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 826166EC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 826166F0: 41800020  blt 0x82616710
	if ctx.cr[0].lt {
	pc = 0x82616710; continue 'dispatch;
	}
	// 826166F4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 826166F8: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x826166FC; continue 'dispatch;
            }
            0x826166FC => {
    //   block [0x826166FC..0x82616710)
	// 826166FC: 396BFFE4  addi r11, r11, -0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + -28;
	// 82616700: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82616704: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82616708: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8261670C: 4080FFF0  bge 0x826166fc
	if !ctx.cr[0].lt {
	pc = 0x826166FC; continue 'dispatch;
	}
	pc = 0x82616710; continue 'dispatch;
            }
            0x82616710 => {
    //   block [0x82616710..0x82616730)
	// 82616710: 548B07FE  clrlwi r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82616714: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82616718: 419A0018  beq cr6, 0x82616730
	if ctx.cr[6].eq {
	pc = 0x82616730; continue 'dispatch;
	}
	// 8261671C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82616720: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82616724: 814BDAB4  lwz r10, -0x254c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82616728: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261672C: 4E800421  bctrl
	ctx.lr = 0x82616730;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82616730 => {
    //   block [0x82616730..0x82616738)
	// 82616730: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82616734: 48000038  b 0x8261676c
	pc = 0x8261676C; continue 'dispatch;
            }
            0x82616738 => {
    //   block [0x82616738..0x82616768)
	// 82616738: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261673C: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82616740: 392B9128  addi r9, r11, -0x6ed8
	ctx.r[9].s64 = ctx.r[11].s64 + -28376;
	// 82616744: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82616748: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8261674C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82616750: 419A0018  beq cr6, 0x82616768
	if ctx.cr[6].eq {
	pc = 0x82616768; continue 'dispatch;
	}
	// 82616754: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82616758: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261675C: 814BDAB4  lwz r10, -0x254c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82616760: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82616764: 4E800421  bctrl
	ctx.lr = 0x82616768;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82616768 => {
    //   block [0x82616768..0x8261676C)
	// 82616768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8261676C; continue 'dispatch;
            }
            0x8261676C => {
    //   block [0x8261676C..0x82616784)
	// 8261676C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82616770: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82616774: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82616778: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8261677C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82616780: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82616788 size=148
    let mut pc: u32 = 0x82616788;
    'dispatch: loop {
        match pc {
            0x82616788 => {
    //   block [0x82616788..0x826167D4)
	// 82616788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261678C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82616790: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82616794: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82616798: 3D00834C  lis r8, -0x7cb4
	ctx.r[8].s64 = -2092171264;
	// 8261679C: 81482074  lwz r10, 0x2074(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8308 as u32) ) } as u64;
	// 826167A0: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 826167A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826167A8: 409A0058  bne cr6, 0x82616800
	if !ctx.cr[6].eq {
	pc = 0x82616800; continue 'dispatch;
	}
	// 826167AC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 826167B0: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 826167B4: 3D20834C  lis r9, -0x7cb4
	ctx.r[9].s64 = -2092171264;
	// 826167B8: 91482074  stw r10, 0x2074(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8308 as u32), ctx.r[10].u32 ) };
	// 826167BC: 3BE91C70  addi r31, r9, 0x1c70
	ctx.r[31].s64 = ctx.r[9].s64 + 7280;
	// 826167C0: 894B0BA9  lbz r10, 0xba9(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2985 as u32) ) } as u64;
	// 826167C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826167C8: 419A000C  beq cr6, 0x826167d4
	if ctx.cr[6].eq {
	pc = 0x826167D4; continue 'dispatch;
	}
	// 826167CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826167D0: 915F0400  stw r10, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x826167D4; continue 'dispatch;
            }
            0x826167D4 => {
    //   block [0x826167D4..0x82616800)
	// 826167D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826167D8: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 826167DC: 994B0BA9  stb r10, 0xba9(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2985 as u32), ctx.r[10].u8 ) };
	// 826167E0: 3869B6A0  addi r3, r9, -0x4960
	ctx.r[3].s64 = ctx.r[9].s64 + -18784;
	// 826167E4: 4869373D  bl 0x82ca9f20
	ctx.lr = 0x826167E8;
	sub_82CA9F20(ctx, base);
	// 826167E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826167EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826167F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826167F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826167F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826167FC: 4E800020  blr
	return;
            }
            0x82616800 => {
    //   block [0x82616800..0x8261681C)
	// 82616800: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82616804: 386B1C70  addi r3, r11, 0x1c70
	ctx.r[3].s64 = ctx.r[11].s64 + 7280;
	// 82616808: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8261680C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82616810: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82616814: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82616818: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82616820 size=220
    let mut pc: u32 = 0x82616820;
    'dispatch: loop {
        match pc {
            0x82616820 => {
    //   block [0x82616820..0x82616850)
	// 82616820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82616824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82616828: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261682C: 4BFFFF5D  bl 0x82616788
	ctx.lr = 0x82616830;
	sub_82616788(ctx, base);
	// 82616830: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82616834: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82616838: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8261683C: 38ABA0F4  addi r5, r11, -0x5f0c
	ctx.r[5].s64 = ctx.r[11].s64 + -24332;
	// 82616840: 80870400  lwz r4, 0x400(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82616844: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82616848: 40990054  ble cr6, 0x8261689c
	if !ctx.cr[6].gt {
	pc = 0x8261689C; continue 'dispatch;
	}
	// 8261684C: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	pc = 0x82616850; continue 'dispatch;
            }
            0x82616850 => {
    //   block [0x82616850..0x8261685C)
	// 82616850: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82616854: 3945000C  addi r10, r5, 0xc
	ctx.r[10].s64 = ctx.r[5].s64 + 12;
	// 82616858: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x8261685C; continue 'dispatch;
            }
            0x8261685C => {
    //   block [0x8261685C..0x82616880)
	// 8261685C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82616860: 886A0000  lbz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82616864: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82616868: 7D234850  subf r9, r3, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 8261686C: 419A0014  beq cr6, 0x82616880
	if ctx.cr[6].eq {
	pc = 0x82616880; continue 'dispatch;
	}
	// 82616870: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82616874: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82616878: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8261687C: 419AFFE0  beq cr6, 0x8261685c
	if ctx.cr[6].eq {
	pc = 0x8261685C; continue 'dispatch;
	}
	pc = 0x82616880; continue 'dispatch;
            }
            0x82616880 => {
    //   block [0x82616880..0x8261689C)
	// 82616880: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82616884: 419A0034  beq cr6, 0x826168b8
	if ctx.cr[6].eq {
	pc = 0x826168B8; continue 'dispatch;
	}
	// 82616888: 81670400  lwz r11, 0x400(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(1024 as u32) ) } as u64;
	// 8261688C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82616890: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82616894: 7F065800  cmpw cr6, r6, r11
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82616898: 4198FFB8  blt cr6, 0x82616850
	if ctx.cr[6].lt {
	pc = 0x82616850; continue 'dispatch;
	}
	pc = 0x8261689C; continue 'dispatch;
            }
            0x8261689C => {
    //   block [0x8261689C..0x826168B8)
	// 8261689C: 2F040100  cmpwi cr6, r4, 0x100
	ctx.cr[6].compare_i32(ctx.r[4].s32, 256, &mut ctx.xer);
	// 826168A0: 409A0034  bne cr6, 0x826168d4
	if !ctx.cr[6].eq {
	pc = 0x826168D4; continue 'dispatch;
	}
	// 826168A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826168A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826168AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826168B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826168B4: 4E800020  blr
	return;
            }
            0x826168B8 => {
    //   block [0x826168B8..0x826168D4)
	// 826168B8: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826168BC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826168C0: 7CAB392E  stwx r5, r11, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), ctx.r[5].u32) };
	// 826168C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826168C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826168CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826168D0: 4E800020  blr
	return;
            }
            0x826168D4 => {
    //   block [0x826168D4..0x826168FC)
	// 826168D4: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826168D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826168DC: 7CAB392E  stwx r5, r11, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), ctx.r[5].u32) };
	// 826168E0: 81670400  lwz r11, 0x400(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(1024 as u32) ) } as u64;
	// 826168E4: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 826168E8: 91470400  stw r10, 0x400(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 826168EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826168F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826168F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826168F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82616900 size=24
    let mut pc: u32 = 0x82616900;
    'dispatch: loop {
        match pc {
            0x82616900 => {
    //   block [0x82616900..0x82616918)
	// 82616900: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82616904: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82616908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261690C: 419A000C  beq cr6, 0x82616918
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82616918);
		return;
	}
	// 82616910: C02B000C  lfs f1, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82616914: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82616928 size=124
    let mut pc: u32 = 0x82616928;
    'dispatch: loop {
        match pc {
            0x82616928 => {
    //   block [0x82616928..0x82616990)
	// 82616928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261692C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82616930: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82616934: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82616938: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 8261693C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82616940: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82616944: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82616948: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8261694C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82616950: 806BFEF0  lwz r3, -0x110(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82616954: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82616958: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 8261695C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82616960: 4E800421  bctrl
	ctx.lr = 0x82616964;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82616964: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82616968: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8261696C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82616970: 814BFEF4  lwz r10, -0x10c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-268 as u32) ) } as u64;
	// 82616974: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82616978: 419A0018  beq cr6, 0x82616990
	if ctx.cr[6].eq {
	pc = 0x82616990; continue 'dispatch;
	}
	// 8261697C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82616980: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82616984: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82616988: 4E800421  bctrl
	ctx.lr = 0x8261698C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261698C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
            }
            0x82616990 => {
    //   block [0x82616990..0x826169A4)
	// 82616990: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82616994: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82616998: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261699C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826169A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826169A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826169A8 size=100
    let mut pc: u32 = 0x826169A8;
    'dispatch: loop {
        match pc {
            0x826169A8 => {
    //   block [0x826169A8..0x826169F4)
	// 826169A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826169AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826169B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826169B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826169B8: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 826169BC: 4BFFFF6D  bl 0x82616928
	ctx.lr = 0x826169C0;
	sub_82616928(ctx, base);
	// 826169C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826169C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826169C8: 419A002C  beq cr6, 0x826169f4
	if ctx.cr[6].eq {
	pc = 0x826169F4; continue 'dispatch;
	}
	// 826169CC: 48858D45  bl 0x82e6f710
	ctx.lr = 0x826169D0;
	sub_82E6F710(ctx, base);
	// 826169D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 826169D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826169D8: 394B6AA0  addi r10, r11, 0x6aa0
	ctx.r[10].s64 = ctx.r[11].s64 + 27296;
	// 826169DC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826169E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826169E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826169E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826169EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826169F0: 4E800020  blr
	return;
            }
            0x826169F4 => {
    //   block [0x826169F4..0x82616A0C)
	// 826169F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826169F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826169FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82616A00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82616A04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82616A08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82616A10 size=560
    let mut pc: u32 = 0x82616A10;
    'dispatch: loop {
        match pc {
            0x82616A10 => {
    //   block [0x82616A10..0x82616A3C)
	// 82616A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82616A14: 486929F9  bl 0x82ca940c
	ctx.lr = 0x82616A18;
	sub_82CA93D0(ctx, base);
	// 82616A18: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82616A1C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82616A20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82616A24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82616A28: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82616A2C: 9BDF0010  stb r30, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 82616A30: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616A34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82616A38: 419A0018  beq cr6, 0x82616a50
	if ctx.cr[6].eq {
	pc = 0x82616A50; continue 'dispatch;
	}
	pc = 0x82616A3C; continue 'dispatch;
            }
            0x82616A3C => {
    //   block [0x82616A3C..0x82616A50)
	// 82616A3C: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82616A40: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82616A44: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82616A48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82616A4C: 409AFFF0  bne cr6, 0x82616a3c
	if !ctx.cr[6].eq {
	pc = 0x82616A3C; continue 'dispatch;
	}
	pc = 0x82616A50; continue 'dispatch;
            }
            0x82616A50 => {
    //   block [0x82616A50..0x82616A60)
	// 82616A50: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82616A54: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616A58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82616A5C: 419A0034  beq cr6, 0x82616a90
	if ctx.cr[6].eq {
	pc = 0x82616A90; continue 'dispatch;
	}
	pc = 0x82616A60; continue 'dispatch;
            }
            0x82616A60 => {
    //   block [0x82616A60..0x82616A90)
	// 82616A60: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616A64: 9BCA0018  stb r30, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82616A68: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82616A6C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616A70: 810A0014  lwz r8, 0x14(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82616A74: 5506003E  slwi r6, r8, 0
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82616A78: 912A0014  stw r9, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82616A7C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82616A80: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616A84: 90EB0010  stw r7, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 82616A88: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82616A8C: 409AFFD4  bne cr6, 0x82616a60
	if !ctx.cr[6].eq {
	pc = 0x82616A60; continue 'dispatch;
	}
	pc = 0x82616A90; continue 'dispatch;
            }
            0x82616A90 => {
    //   block [0x82616A90..0x82616AA8)
	// 82616A90: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82616A94: 93CB0014  stw r30, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82616A98: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82616A9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616AA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82616AA4: 419A0018  beq cr6, 0x82616abc
	if ctx.cr[6].eq {
	pc = 0x82616ABC; continue 'dispatch;
	}
	pc = 0x82616AA8; continue 'dispatch;
            }
            0x82616AA8 => {
    //   block [0x82616AA8..0x82616ABC)
	// 82616AA8: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82616AAC: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82616AB0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82616AB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82616AB8: 409AFFF0  bne cr6, 0x82616aa8
	if !ctx.cr[6].eq {
	pc = 0x82616AA8; continue 'dispatch;
	}
	pc = 0x82616ABC; continue 'dispatch;
            }
            0x82616ABC => {
    //   block [0x82616ABC..0x82616ACC)
	// 82616ABC: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82616AC0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616AC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82616AC8: 419A0034  beq cr6, 0x82616afc
	if ctx.cr[6].eq {
	pc = 0x82616AFC; continue 'dispatch;
	}
	pc = 0x82616ACC; continue 'dispatch;
            }
            0x82616ACC => {
    //   block [0x82616ACC..0x82616AFC)
	// 82616ACC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616AD0: 9BCA0018  stb r30, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82616AD4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616AD8: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82616ADC: 810A0014  lwz r8, 0x14(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82616AE0: 912A0014  stw r9, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82616AE4: 5506003E  slwi r6, r8, 0
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82616AE8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82616AEC: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616AF0: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82616AF4: 90EB0010  stw r7, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 82616AF8: 409AFFD4  bne cr6, 0x82616acc
	if !ctx.cr[6].eq {
	pc = 0x82616ACC; continue 'dispatch;
	}
	pc = 0x82616AFC; continue 'dispatch;
            }
            0x82616AFC => {
    //   block [0x82616AFC..0x82616B24)
	// 82616AFC: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82616B00: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82616B04: 93CB0014  stw r30, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82616B08: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82616B0C: C3EA0BEC  lfs f31, 0xbec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82616B10: 811F0030  lwz r8, 0x30(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82616B14: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82616B18: 4099004C  ble cr6, 0x82616b64
	if !ctx.cr[6].gt {
	pc = 0x82616B64; continue 'dispatch;
	}
	// 82616B1C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82616B20: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82616B24; continue 'dispatch;
            }
            0x82616B24 => {
    //   block [0x82616B24..0x82616B64)
	// 82616B24: 811F0038  lwz r8, 0x38(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82616B28: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82616B2C: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82616B30: 93C80004  stw r30, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82616B34: 811F0040  lwz r8, 0x40(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82616B38: 7CEB4214  add r7, r11, r8
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82616B3C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82616B40: 93C70004  stw r30, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82616B44: 80DF0048  lwz r6, 0x48(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82616B48: 7FEA352E  stfsx f31, r10, r6
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 82616B4C: 80BF0044  lwz r5, 0x44(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82616B50: 7FEA2D2E  stfsx f31, r10, r5
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 82616B54: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82616B58: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82616B5C: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82616B60: 4198FFC4  blt cr6, 0x82616b24
	if ctx.cr[6].lt {
	pc = 0x82616B24; continue 'dispatch;
	}
	pc = 0x82616B64; continue 'dispatch;
            }
            0x82616B64 => {
    //   block [0x82616B64..0x82616C14)
	// 82616B64: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82616B68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82616B6C: 419A00C0  beq cr6, 0x82616c2c
	if ctx.cr[6].eq {
	pc = 0x82616C2C; continue 'dispatch;
	}
	// 82616B70: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82616B74: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82616B78: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82616B7C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82616B80: 390A83E0  addi r8, r10, -0x7c20
	ctx.r[8].s64 = ctx.r[10].s64 + -31776;
	// 82616B84: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82616B88: 38E99128  addi r7, r9, -0x6ed8
	ctx.r[7].s64 = ctx.r[9].s64 + -28376;
	// 82616B8C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82616B90: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82616B94: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82616B98: 90E10068  stw r7, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u32 ) };
	// 82616B9C: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82616BA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82616BA4: 809F0034  lwz r4, 0x34(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82616BA8: 4BFFF959  bl 0x82616500
	ctx.lr = 0x82616BAC;
	sub_82616500(ctx, base);
	// 82616BAC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82616BB0: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82616BB4: 80C30004  lwz r6, 4(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82616BB8: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 82616BBC: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82616BC0: 38659128  addi r3, r5, -0x6ed8
	ctx.r[3].s64 = ctx.r[5].s64 + -28376;
	// 82616BC4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82616BC8: 90C40004  stw r6, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82616BCC: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82616BD0: 813F0044  lwz r9, 0x44(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82616BD4: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82616BD8: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82616BDC: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82616BE0: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82616BE4: 7C074D2E  stfsx f0, r7, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82616BE8: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82616BEC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82616BF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82616BF4: 419A0020  beq cr6, 0x82616c14
	if ctx.cr[6].eq {
	pc = 0x82616C14; continue 'dispatch;
	}
	// 82616BF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82616BFC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82616C00: 80BF0018  lwz r5, 0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82616C04: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82616C08: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82616C0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82616C10: 4E800421  bctrl
	ctx.lr = 0x82616C14;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82616C14 => {
    //   block [0x82616C14..0x82616C2C)
	// 82616C14: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82616C18: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82616C1C: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82616C20: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82616C24: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82616C28: 7C08552E  stfsx f0, r8, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	pc = 0x82616C2C; continue 'dispatch;
            }
            0x82616C2C => {
    //   block [0x82616C2C..0x82616C40)
	// 82616C2C: D3FF005C  stfs f31, 0x5c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82616C30: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82616C34: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82616C38: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82616C3C: 48692820  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82616C40 size=92
    let mut pc: u32 = 0x82616C40;
    'dispatch: loop {
        match pc {
            0x82616C40 => {
    //   block [0x82616C40..0x82616C80)
	// 82616C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82616C44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82616C48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82616C4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82616C50: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 82616C54: 807F6CA8  lwz r3, 0x6ca8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27816 as u32) ) } as u64;
	// 82616C58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82616C5C: 409A002C  bne cr6, 0x82616c88
	if !ctx.cr[6].eq {
	pc = 0x82616C88; continue 'dispatch;
	}
	// 82616C60: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82616C64: 4BFFFCC5  bl 0x82616928
	ctx.lr = 0x82616C68;
	sub_82616928(ctx, base);
	// 82616C68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82616C6C: 419A0014  beq cr6, 0x82616c80
	if ctx.cr[6].eq {
	pc = 0x82616C80; continue 'dispatch;
	}
	// 82616C70: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82616C74: 394B4D74  addi r10, r11, 0x4d74
	ctx.r[10].s64 = ctx.r[11].s64 + 19828;
	// 82616C78: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82616C7C: 48000008  b 0x82616c84
	pc = 0x82616C84; continue 'dispatch;
            }
            0x82616C80 => {
    //   block [0x82616C80..0x82616C84)
	// 82616C80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82616C84; continue 'dispatch;
            }
            0x82616C84 => {
    //   block [0x82616C84..0x82616C88)
	// 82616C84: 907F6CA8  stw r3, 0x6ca8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(27816 as u32), ctx.r[3].u32 ) };
	pc = 0x82616C88; continue 'dispatch;
            }
            0x82616C88 => {
    //   block [0x82616C88..0x82616C9C)
	// 82616C88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82616C8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82616C90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82616C94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82616C98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82616CA0 size=80
    let mut pc: u32 = 0x82616CA0;
    'dispatch: loop {
        match pc {
            0x82616CA0 => {
    //   block [0x82616CA0..0x82616CD4)
	// 82616CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82616CA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82616CA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82616CAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82616CB0: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 82616CB4: 807F6CA8  lwz r3, 0x6ca8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27816 as u32) ) } as u64;
	// 82616CB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82616CBC: 419A0018  beq cr6, 0x82616cd4
	if ctx.cr[6].eq {
	pc = 0x82616CD4; continue 'dispatch;
	}
	// 82616CC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82616CC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82616CC8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82616CCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82616CD0: 4E800421  bctrl
	ctx.lr = 0x82616CD4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82616CD4 => {
    //   block [0x82616CD4..0x82616CF0)
	// 82616CD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82616CD8: 917F6CA8  stw r11, 0x6ca8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(27816 as u32), ctx.r[11].u32 ) };
	// 82616CDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82616CE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82616CE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82616CE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82616CEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82616CF0 size=308
    let mut pc: u32 = 0x82616CF0;
    'dispatch: loop {
        match pc {
            0x82616CF0 => {
    //   block [0x82616CF0..0x82616E24)
	// 82616CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82616CF4: 486926ED  bl 0x82ca93e0
	ctx.lr = 0x82616CF8;
	sub_82CA93D0(ctx, base);
	// 82616CF8: 3D40822C  lis r10, -0x7dd4
	ctx.r[10].s64 = -2111045632;
	// 82616CFC: 3D208217  lis r9, -0x7de9
	ctx.r[9].s64 = -2112421888;
	// 82616D00: 394ADCB0  addi r10, r10, -0x2350
	ctx.r[10].s64 = ctx.r[10].s64 + -9040;
	// 82616D04: 3D00822F  lis r8, -0x7dd1
	ctx.r[8].s64 = -2110849024;
	// 82616D08: 3CE08290  lis r7, -0x7d70
	ctx.r[7].s64 = -2104492032;
	// 82616D0C: 91430028  stw r10, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82616D10: 3CC08284  lis r6, -0x7d7c
	ctx.r[6].s64 = -2105278464;
	// 82616D14: 3CA08290  lis r5, -0x7d70
	ctx.r[5].s64 = -2104492032;
	// 82616D18: 39291B10  addi r9, r9, 0x1b10
	ctx.r[9].s64 = ctx.r[9].s64 + 6928;
	// 82616D1C: 3908A1B8  addi r8, r8, -0x5e48
	ctx.r[8].s64 = ctx.r[8].s64 + -24136;
	// 82616D20: 38E7D4A0  addi r7, r7, -0x2b60
	ctx.r[7].s64 = ctx.r[7].s64 + -11104;
	// 82616D24: 9123002C  stw r9, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82616D28: 38C657B0  addi r6, r6, 0x57b0
	ctx.r[6].s64 = ctx.r[6].s64 + 22448;
	// 82616D2C: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82616D30: 38A5BE80  addi r5, r5, -0x4180
	ctx.r[5].s64 = ctx.r[5].s64 + -16768;
	// 82616D34: 90E30010  stw r7, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 82616D38: 3C808290  lis r4, -0x7d70
	ctx.r[4].s64 = -2104492032;
	// 82616D3C: 90C30014  stw r6, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 82616D40: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 82616D44: 90A30020  stw r5, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[5].u32 ) };
	// 82616D48: 3FE08290  lis r31, -0x7d70
	ctx.r[31].s64 = -2104492032;
	// 82616D4C: 3FC08290  lis r30, -0x7d70
	ctx.r[30].s64 = -2104492032;
	// 82616D50: 91430024  stw r10, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82616D54: 3FA08290  lis r29, -0x7d70
	ctx.r[29].s64 = -2104492032;
	// 82616D58: 3F808290  lis r28, -0x7d70
	ctx.r[28].s64 = -2104492032;
	// 82616D5C: 3F608290  lis r27, -0x7d70
	ctx.r[27].s64 = -2104492032;
	// 82616D60: 3F408290  lis r26, -0x7d70
	ctx.r[26].s64 = -2104492032;
	// 82616D64: 3924C388  addi r9, r4, -0x3c78
	ctx.r[9].s64 = ctx.r[4].s64 + -15480;
	// 82616D68: 391FC3E0  addi r8, r31, -0x3c20
	ctx.r[8].s64 = ctx.r[31].s64 + -15392;
	// 82616D6C: 38FEC448  addi r7, r30, -0x3bb8
	ctx.r[7].s64 = ctx.r[30].s64 + -15288;
	// 82616D70: 91230060  stw r9, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82616D74: 38DDBE88  addi r6, r29, -0x4178
	ctx.r[6].s64 = ctx.r[29].s64 + -16760;
	// 82616D78: 91030064  stw r8, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 82616D7C: 38BCC560  addi r5, r28, -0x3aa0
	ctx.r[5].s64 = ctx.r[28].s64 + -15008;
	// 82616D80: 90E30068  stw r7, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[7].u32 ) };
	// 82616D84: 389BC5F8  addi r4, r27, -0x3a08
	ctx.r[4].s64 = ctx.r[27].s64 + -14856;
	// 82616D88: 90C3005C  stw r6, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[6].u32 ) };
	// 82616D8C: 395AC510  addi r10, r26, -0x3af0
	ctx.r[10].s64 = ctx.r[26].s64 + -15088;
	// 82616D90: 90A30070  stw r5, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[5].u32 ) };
	// 82616D94: 3F2082C2  lis r25, -0x7d3e
	ctx.r[25].s64 = -2101215232;
	// 82616D98: 90830074  stw r4, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[4].u32 ) };
	// 82616D9C: 3F008228  lis r24, -0x7dd8
	ctx.r[24].s64 = -2111307776;
	// 82616DA0: 9143006C  stw r10, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82616DA4: 3EE08290  lis r23, -0x7d70
	ctx.r[23].s64 = -2104492032;
	// 82616DA8: 3EC08267  lis r22, -0x7d99
	ctx.r[22].s64 = -2107179008;
	// 82616DAC: 3EA08267  lis r21, -0x7d99
	ctx.r[21].s64 = -2107179008;
	// 82616DB0: 3E808261  lis r20, -0x7d9f
	ctx.r[20].s64 = -2107572224;
	// 82616DB4: 3E608261  lis r19, -0x7d9f
	ctx.r[19].s64 = -2107572224;
	// 82616DB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82616DBC: 3A4007D0  li r18, 0x7d0
	ctx.r[18].s64 = 2000;
	// 82616DC0: 3939BDA8  addi r9, r25, -0x4258
	ctx.r[9].s64 = ctx.r[25].s64 + -16984;
	// 82616DC4: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82616DC8: 3918E8D8  addi r8, r24, -0x1728
	ctx.r[8].s64 = ctx.r[24].s64 + -5928;
	// 82616DCC: 92430004  stw r18, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[18].u32 ) };
	// 82616DD0: 38F7C678  addi r7, r23, -0x3988
	ctx.r[7].s64 = ctx.r[23].s64 + -14728;
	// 82616DD4: 91230078  stw r9, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 82616DD8: 38D6D1E0  addi r6, r22, -0x2e20
	ctx.r[6].s64 = ctx.r[22].s64 + -11808;
	// 82616DDC: 91030030  stw r8, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[8].u32 ) };
	// 82616DE0: 38B5D5C8  addi r5, r21, -0x2a38
	ctx.r[5].s64 = ctx.r[21].s64 + -10808;
	// 82616DE4: 90E30034  stw r7, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[7].u32 ) };
	// 82616DE8: 38946C40  addi r4, r20, 0x6c40
	ctx.r[4].s64 = ctx.r[20].s64 + 27712;
	// 82616DEC: 90C30054  stw r6, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 82616DF0: 39536CA0  addi r10, r19, 0x6ca0
	ctx.r[10].s64 = ctx.r[19].s64 + 27808;
	// 82616DF4: 90A30058  stw r5, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 82616DF8: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82616DFC: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82616E00: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82616E04: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82616E08: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82616E0C: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82616E10: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82616E14: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82616E18: 9083007C  stw r4, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82616E1C: 91430080  stw r10, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82616E20: 48692610  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82616E28 size=140
    let mut pc: u32 = 0x82616E28;
    'dispatch: loop {
        match pc {
            0x82616E28 => {
    //   block [0x82616E28..0x82616E50)
	// 82616E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82616E2C: 486925DD  bl 0x82ca9408
	ctx.lr = 0x82616E30;
	sub_82CA93D0(ctx, base);
	// 82616E30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82616E34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82616E38: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82616E3C: 4BF68775  bl 0x8257f5b0
	ctx.lr = 0x82616E40;
	sub_8257F5B0(ctx, base);
	// 82616E40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82616E44: 419A0060  beq cr6, 0x82616ea4
	if ctx.cr[6].eq {
	pc = 0x82616EA4; continue 'dispatch;
	}
	// 82616E48: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82616E4C: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	pc = 0x82616E50; continue 'dispatch;
            }
            0x82616E50 => {
    //   block [0x82616E50..0x82616E70)
	// 82616E50: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82616E54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82616E58: 419A0018  beq cr6, 0x82616e70
	if ctx.cr[6].eq {
	pc = 0x82616E70; continue 'dispatch;
	}
	// 82616E5C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82616E60: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82616E64: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82616E68: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82616E6C: 41980008  blt cr6, 0x82616e74
	if ctx.cr[6].lt {
	pc = 0x82616E74; continue 'dispatch;
	}
	pc = 0x82616E70; continue 'dispatch;
            }
            0x82616E70 => {
    //   block [0x82616E70..0x82616E74)
	// 82616E70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82616E74; continue 'dispatch;
            }
            0x82616E74 => {
    //   block [0x82616E74..0x82616EA4)
	// 82616E74: 815C6AB8  lwz r10, 0x6ab8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82616E78: 7C9D5A14  add r4, r29, r11
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82616E7C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82616E80: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82616E84: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82616E88: 4BD39A39  bl 0x823508c0
	ctx.lr = 0x82616E8C;
	sub_823508C0(ctx, base);
	// 82616E8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82616E90: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82616E94: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82616E98: 4BF68719  bl 0x8257f5b0
	ctx.lr = 0x82616E9C;
	sub_8257F5B0(ctx, base);
	// 82616E9C: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82616EA0: 409AFFB0  bne cr6, 0x82616e50
	if !ctx.cr[6].eq {
	pc = 0x82616E50; continue 'dispatch;
	}
	pc = 0x82616EA4; continue 'dispatch;
            }
            0x82616EA4 => {
    //   block [0x82616EA4..0x82616EB4)
	// 82616EA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82616EA8: 4BF68731  bl 0x8257f5d8
	ctx.lr = 0x82616EAC;
	sub_8257F5D8(ctx, base);
	// 82616EAC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82616EB0: 486925A8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82616EB8 size=104
    let mut pc: u32 = 0x82616EB8;
    'dispatch: loop {
        match pc {
            0x82616EB8 => {
    //   block [0x82616EB8..0x82616F20)
	// 82616EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82616EBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82616EC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82616EC4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82616EC8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82616ECC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82616ED0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82616ED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82616ED8: 394B9490  addi r10, r11, -0x6b70
	ctx.r[10].s64 = ctx.r[11].s64 + -27504;
	// 82616EDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82616EE0: C00B9490  lfs f0, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82616EE4: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82616EE8: C1AAFFF4  lfs f13, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82616EEC: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82616EF0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82616EF4: 4BC7D575  bl 0x82294468
	ctx.lr = 0x82616EF8;
	sub_82294468(ctx, base);
	// 82616EF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82616EFC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82616F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82616F04: 4BC22E95  bl 0x82239d98
	ctx.lr = 0x82616F08;
	sub_82239D98(ctx, base);
	// 82616F08: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82616F0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82616F10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82616F14: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82616F18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82616F1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82616F20 size=120
    let mut pc: u32 = 0x82616F20;
    'dispatch: loop {
        match pc {
            0x82616F20 => {
    //   block [0x82616F20..0x82616F98)
	// 82616F20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82616F24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82616F28: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82616F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82616F98 size=264
    let mut pc: u32 = 0x82616F98;
    'dispatch: loop {
        match pc {
            0x82616F98 => {
    //   block [0x82616F98..0x826170A0)
	// 82616F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82616F9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82616FA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82616FA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82616FA8: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 82616FAC: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82616FB0: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82616FB4: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826170A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826170A0 size=364
    let mut pc: u32 = 0x826170A0;
    'dispatch: loop {
        match pc {
            0x826170A0 => {
    //   block [0x826170A0..0x8261720C)
	// 826170A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826170A4: 48692369  bl 0x82ca940c
	ctx.lr = 0x826170A8;
	sub_82CA93D0(ctx, base);
	// 826170A8: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82617210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82617210 size=244
    let mut pc: u32 = 0x82617210;
    'dispatch: loop {
        match pc {
            0x82617210 => {
    //   block [0x82617210..0x82617304)
	// 82617210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82617214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82617218: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261721C: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82617308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82617308 size=128
    let mut pc: u32 = 0x82617308;
    'dispatch: loop {
        match pc {
            0x82617308 => {
    //   block [0x82617308..0x82617324)
	// 82617308: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261730C: 419A0018  beq cr6, 0x82617324
	if ctx.cr[6].eq {
	pc = 0x82617324; continue 'dispatch;
	}
	// 82617310: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 82617314: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82617318: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261731C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82617320: 409A0008  bne cr6, 0x82617328
	if !ctx.cr[6].eq {
	pc = 0x82617328; continue 'dispatch;
	}
	pc = 0x82617324; continue 'dispatch;
            }
            0x82617324 => {
    //   block [0x82617324..0x82617328)
	// 82617324: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82617328; continue 'dispatch;
            }
            0x82617328 => {
    //   block [0x82617328..0x82617388)
	// 82617328: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261732C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82617330: 419A0058  beq cr6, 0x82617388
	if ctx.cr[6].eq {
		sub_82617388(ctx, base);
		return;
	}
	// 82617334: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82617338: 3D40828C  lis r10, -0x7d74
	ctx.r[10].s64 = -2104754176;
	// 8261733C: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82617340: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 82617344: 6147BFBF  ori r7, r10, 0xbfbf
	ctx.r[7].u64 = ctx.r[10].u64 | 49087;
	// 82617348: 7D664B78  or r6, r11, r9
	ctx.r[6].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 8261734C: 1D4624A1  mulli r10, r6, 0x24a1
	ctx.r[10].s32 = ((ctx.r[6].s32 as i64 * 9377 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82617350: 81689650  lwz r11, -0x69b0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 82617354: 38AA24DF  addi r5, r10, 0x24df
	ctx.r[5].s64 = ctx.r[10].s64 + 9439;
	// 82617358: 54A3983E  rotlwi r3, r5, 0x13
	ctx.r[3].u64 = ((ctx.r[5].u32).rotate_left(19)) as u64;
	// 8261735C: 7D433816  mulhwu r10, r3, r7
	ctx.r[10].u64 = ((ctx.r[3].u32 as u64 * ctx.r[7].u32 as u64) >> 32);
	// 82617360: 5549C9FE  srwi r9, r10, 7
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(7);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82617364: 1D0900FB  mulli r8, r9, 0xfb
	ctx.r[8].s32 = ((ctx.r[9].s32 as i64 * 251 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82617368: 7D481850  subf r10, r8, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[8].s64;
	// 8261736C: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82617370: 7CC723D6  divw r6, r7, r4
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[4].s32;
	// 82617374: 7CA621D6  mullw r5, r6, r4
	ctx.r[5].s32 = ((ctx.r[6].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82617378: 7C853850  subf r4, r5, r7
	ctx.r[4].s64 = ctx.r[7].s64 - ctx.r[5].s64;
	// 8261737C: 7C830034  cntlzw r3, r4
	ctx.r[3].u64 = if ctx.r[4].u32 == 0 { 32 } else { ctx.r[4].u32.leading_zeros() as u64 };
	// 82617380: 5463DFFE  rlwinm r3, r3, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x0000001Fu64;
	// 82617384: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82617388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82617388 size=8
    let mut pc: u32 = 0x82617388;
    'dispatch: loop {
        match pc {
            0x82617388 => {
    //   block [0x82617388..0x82617390)
	// 82617388: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8261738C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82617390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82617390 size=56
    let mut pc: u32 = 0x82617390;
    'dispatch: loop {
        match pc {
            0x82617390 => {
    //   block [0x82617390..0x826173B0)
	// 82617390: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82617394: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82617398: 419A0018  beq cr6, 0x826173b0
	if ctx.cr[6].eq {
	pc = 0x826173B0; continue 'dispatch;
	}
	// 8261739C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 826173A0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 826173A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826173A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826173AC: 409A0008  bne cr6, 0x826173b4
	if !ctx.cr[6].eq {
	pc = 0x826173B4; continue 'dispatch;
	}
	pc = 0x826173B0; continue 'dispatch;
            }
            0x826173B0 => {
    //   block [0x826173B0..0x826173B4)
	// 826173B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x826173B4; continue 'dispatch;
            }
            0x826173B4 => {
    //   block [0x826173B4..0x826173C8)
	// 826173B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 826173B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826173BC: 419A000C  beq cr6, 0x826173c8
	if ctx.cr[6].eq {
		sub_826173C8(ctx, base);
		return;
	}
	// 826173C0: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 826173C4: 4BBFAA34  b 0x82211df8
	sub_82211DF8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826173C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826173C8 size=8
    let mut pc: u32 = 0x826173C8;
    'dispatch: loop {
        match pc {
            0x826173C8 => {
    //   block [0x826173C8..0x826173D0)
	// 826173C8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826173CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826173D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826173D0 size=420
    let mut pc: u32 = 0x826173D0;
    'dispatch: loop {
        match pc {
            0x826173D0 => {
    //   block [0x826173D0..0x8261746C)
	// 826173D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826173D4: 48692039  bl 0x82ca940c
	ctx.lr = 0x826173D8;
	sub_82CA93D0(ctx, base);
	// 826173D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826173DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826173E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826173E4: 4BDB71DD  bl 0x823ce5c0
	ctx.lr = 0x826173E8;
	sub_823CE5C0(ctx, base);
	// 826173E8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826173EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826173F0: 419A007C  beq cr6, 0x8261746c
	if ctx.cr[6].eq {
	pc = 0x8261746C; continue 'dispatch;
	}
	// 826173F4: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826173F8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 826173FC: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82617400: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82617404: 4BC11D05  bl 0x82229108
	ctx.lr = 0x82617408;
	sub_82229108(ctx, base);
	// 82617408: 3D608261  lis r11, -0x7d9f
	ctx.r[11].s64 = -2107572224;
	// 8261740C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82617410: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82617414: 3BCB7308  addi r30, r11, 0x7308
	ctx.r[30].s64 = ctx.r[11].s64 + 29448;
	// 82617418: 4BC10469  bl 0x82227880
	ctx.lr = 0x8261741C;
	sub_82227880(ctx, base);
	// 8261741C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82617420: 3D408254  lis r10, -0x7dac
	ctx.r[10].s64 = -2108424192;
	// 82617424: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82617428: 388A6880  addi r4, r10, 0x6880
	ctx.r[4].s64 = ctx.r[10].s64 + 26752;
	// 8261742C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82617430: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82617434: 4BB8364D  bl 0x8219aa80
	ctx.lr = 0x82617438;
	sub_8219AA80(ctx, base);
	// 82617438: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8261743C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82617440: 3BC98400  addi r30, r9, -0x7c00
	ctx.r[30].s64 = ctx.r[9].s64 + -31744;
	// 82617444: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82617448: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8261744C: 4BDB6FD5  bl 0x823ce420
	ctx.lr = 0x82617450;
	sub_823CE420(ctx, base);
	// 82617450: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82617454: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82617458: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261745C: 4840D26D  bl 0x82a246c8
	ctx.lr = 0x82617460;
	sub_82A246C8(ctx, base);
	// 82617460: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82617464: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 82617468: 911D0008  stw r8, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x8261746C; continue 'dispatch;
            }
            0x8261746C => {
    //   block [0x8261746C..0x8261754C)
	// 8261746C: 3D608261  lis r11, -0x7d9f
	ctx.r[11].s64 = -2107572224;
	// 82617470: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82617474: 38AB70A0  addi r5, r11, 0x70a0
	ctx.r[5].s64 = ctx.r[11].s64 + 28832;
	// 82617478: 388A8420  addi r4, r10, -0x7be0
	ctx.r[4].s64 = ctx.r[10].s64 + -31712;
	// 8261747C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82617480: 48001679  bl 0x82618af8
	ctx.lr = 0x82617484;
	sub_82618AF8(ctx, base);
	// 82617484: 3D208261  lis r9, -0x7d9f
	ctx.r[9].s64 = -2107572224;
	// 82617488: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8261748C: 38A97210  addi r5, r9, 0x7210
	ctx.r[5].s64 = ctx.r[9].s64 + 29200;
	// 82617490: 38888438  addi r4, r8, -0x7bc8
	ctx.r[4].s64 = ctx.r[8].s64 + -31688;
	// 82617494: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82617498: 480016F9  bl 0x82618b90
	ctx.lr = 0x8261749C;
	sub_82618B90(ctx, base);
	// 8261749C: 3CE08261  lis r7, -0x7d9f
	ctx.r[7].s64 = -2107572224;
	// 826174A0: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 826174A4: 38A76F20  addi r5, r7, 0x6f20
	ctx.r[5].s64 = ctx.r[7].s64 + 28448;
	// 826174A8: 38868454  addi r4, r6, -0x7bac
	ctx.r[4].s64 = ctx.r[6].s64 + -31660;
	// 826174AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826174B0: 480016E1  bl 0x82618b90
	ctx.lr = 0x826174B4;
	sub_82618B90(ctx, base);
	// 826174B4: 3CA08261  lis r5, -0x7d9f
	ctx.r[5].s64 = -2107572224;
	// 826174B8: 3C80820D  lis r4, -0x7df3
	ctx.r[4].s64 = -2113077248;
	// 826174BC: 38A56F98  addi r5, r5, 0x6f98
	ctx.r[5].s64 = ctx.r[5].s64 + 28568;
	// 826174C0: 38848470  addi r4, r4, -0x7b90
	ctx.r[4].s64 = ctx.r[4].s64 + -31632;
	// 826174C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826174C8: 48001761  bl 0x82618c28
	ctx.lr = 0x826174CC;
	sub_82618C28(ctx, base);
	// 826174CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826174D0: 419A007C  beq cr6, 0x8261754c
	if ctx.cr[6].eq {
	pc = 0x8261754C; continue 'dispatch;
	}
	// 826174D4: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826174D8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 826174DC: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826174E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826174E4: 4BC11C25  bl 0x82229108
	ctx.lr = 0x826174E8;
	sub_82229108(ctx, base);
	// 826174E8: 3D608261  lis r11, -0x7d9f
	ctx.r[11].s64 = -2107572224;
	// 826174EC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 826174F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826174F4: 3BEB6EB8  addi r31, r11, 0x6eb8
	ctx.r[31].s64 = ctx.r[11].s64 + 28344;
	// 826174F8: 4BC10389  bl 0x82227880
	ctx.lr = 0x826174FC;
	sub_82227880(ctx, base);
	// 826174FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82617500: 3D408262  lis r10, -0x7d9e
	ctx.r[10].s64 = -2107506688;
	// 82617504: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82617508: 388A8E08  addi r4, r10, -0x71f8
	ctx.r[4].s64 = ctx.r[10].s64 + -29176;
	// 8261750C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82617510: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82617514: 4BB8356D  bl 0x8219aa80
	ctx.lr = 0x82617518;
	sub_8219AA80(ctx, base);
	// 82617518: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8261751C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82617520: 3BE9848C  addi r31, r9, -0x7b74
	ctx.r[31].s64 = ctx.r[9].s64 + -31604;
	// 82617524: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82617528: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8261752C: 4BDB6EF5  bl 0x823ce420
	ctx.lr = 0x82617530;
	sub_823CE420(ctx, base);
	// 82617530: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82617534: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82617538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261753C: 4840D18D  bl 0x82a246c8
	ctx.lr = 0x82617540;
	sub_82A246C8(ctx, base);
	// 82617540: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82617544: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 82617548: 911E0008  stw r8, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x8261754C; continue 'dispatch;
            }
            0x8261754C => {
    //   block [0x8261754C..0x82617574)
	// 8261754C: 3D608261  lis r11, -0x7d9f
	ctx.r[11].s64 = -2107572224;
	// 82617550: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82617554: 38AB7390  addi r5, r11, 0x7390
	ctx.r[5].s64 = ctx.r[11].s64 + 29584;
	// 82617558: 388A84B4  addi r4, r10, -0x7b4c
	ctx.r[4].s64 = ctx.r[10].s64 + -31564;
	// 8261755C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82617560: 48001599  bl 0x82618af8
	ctx.lr = 0x82617564;
	sub_82618AF8(ctx, base);
	// 82617564: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82617568: 4BBA05B1  bl 0x821b7b18
	ctx.lr = 0x8261756C;
	sub_821B7B18(ctx, base);
	// 8261756C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82617570: 48691EEC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82617578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82617578 size=780
    let mut pc: u32 = 0x82617578;
    'dispatch: loop {
        match pc {
            0x82617578 => {
    //   block [0x82617578..0x82617884)
	// 82617578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261757C: 48691E8D  bl 0x82ca9408
	ctx.lr = 0x82617580;
	sub_82CA93D0(ctx, base);
	// 82617580: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82617888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82617888 size=276
    let mut pc: u32 = 0x82617888;
    'dispatch: loop {
        match pc {
            0x82617888 => {
    //   block [0x82617888..0x826178F0)
	// 82617888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261788C: 48691B79  bl 0x82ca9404
	ctx.lr = 0x82617890;
	sub_82CA93D0(ctx, base);
	// 82617890: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82617894: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82617898: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8261789C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 826178A0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 826178A4: 392B6A70  addi r9, r11, 0x6a70
	ctx.r[9].s64 = ctx.r[11].s64 + 27248;
	// 826178A8: 390A4C64  addi r8, r10, 0x4c64
	ctx.r[8].s64 = ctx.r[10].s64 + 19556;
	// 826178AC: 913C0000  stw r9, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826178B0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826178B4: 80FB0004  lwz r7, 4(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826178B8: 3BFB0008  addi r31, r27, 8
	ctx.r[31].s64 = ctx.r[27].s64 + 8;
	// 826178BC: 90FC0004  stw r7, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 826178C0: 3BBC0008  addi r29, r28, 8
	ctx.r[29].s64 = ctx.r[28].s64 + 8;
	// 826178C4: 911C0000  stw r8, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 826178C8: 80DB0010  lwz r6, 0x10(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 826178CC: 80BB000C  lwz r5, 0xc(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 826178D0: 7C853050  subf r4, r5, r6
	ctx.r[4].s64 = ctx.r[6].s64 - ctx.r[5].s64;
	// 826178D4: 7C842E71  srawi. r4, r4, 5
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 5) as i64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 826178D8: 93DC000C  stw r30, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 826178DC: 93DC0010  stw r30, 0x10(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 826178E0: 93DC0014  stw r30, 0x14(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 826178E4: 4082000C  bne 0x826178f0
	if !ctx.cr[0].eq {
	pc = 0x826178F0; continue 'dispatch;
	}
	// 826178E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826178EC: 4800000C  b 0x826178f8
	pc = 0x826178F8; continue 'dispatch;
            }
            0x826178F0 => {
    //   block [0x826178F0..0x826178F8)
	// 826178F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826178F4: 483F95FD  bl 0x82a10ef0
	ctx.lr = 0x826178F8;
	sub_82A10EF0(ctx, base);
	pc = 0x826178F8; continue 'dispatch;
            }
            0x826178F8 => {
    //   block [0x826178F8..0x8261792C)
	// 826178F8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 826178FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82617900: 419A0068  beq cr6, 0x82617968
	if ctx.cr[6].eq {
	pc = 0x82617968; continue 'dispatch;
	}
	// 82617904: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82617908: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261790C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82617910: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82617914: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82617918: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8261791C: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82617920: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82617924: 419A0040  beq cr6, 0x82617964
	if ctx.cr[6].eq {
	pc = 0x82617964; continue 'dispatch;
	}
	// 82617928: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x8261792C; continue 'dispatch;
            }
            0x8261792C => {
    //   block [0x8261792C..0x82617954)
	// 8261792C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82617930: 419A0024  beq cr6, 0x82617954
	if ctx.cr[6].eq {
	pc = 0x82617954; continue 'dispatch;
	}
	// 82617934: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82617938: F90B0000  std r8, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 8261793C: E8EA0008  ld r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82617940: F8EB0008  std r7, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 82617944: E8CA0010  ld r6, 0x10(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	// 82617948: F8CB0010  std r6, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 8261794C: E8AA0018  ld r5, 0x18(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	// 82617950: F8AB0018  std r5, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[5].u64 ) };
	pc = 0x82617954; continue 'dispatch;
            }
            0x82617954 => {
    //   block [0x82617954..0x82617964)
	// 82617954: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82617958: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 8261795C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82617960: 409AFFCC  bne cr6, 0x8261792c
	if !ctx.cr[6].eq {
	pc = 0x8261792C; continue 'dispatch;
	}
	pc = 0x82617964; continue 'dispatch;
            }
            0x82617964 => {
    //   block [0x82617964..0x82617968)
	// 82617964: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82617968; continue 'dispatch;
            }
            0x82617968 => {
    //   block [0x82617968..0x8261799C)
	// 82617968: 897B0019  lbz r11, 0x19(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(25 as u32) ) } as u64;
	// 8261796C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82617970: 893B001B  lbz r9, 0x1b(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(27 as u32) ) } as u64;
	// 82617974: 891B0018  lbz r8, 0x18(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 82617978: 895B001A  lbz r10, 0x1a(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(26 as u32) ) } as u64;
	// 8261797C: 997C0019  stb r11, 0x19(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82617980: 993C001B  stb r9, 0x1b(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(27 as u32), ctx.r[9].u8 ) };
	// 82617984: 991C0018  stb r8, 0x18(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[8].u8 ) };
	// 82617988: 995C001A  stb r10, 0x1a(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(26 as u32), ctx.r[10].u8 ) };
	// 8261798C: 88FB001C  lbz r7, 0x1c(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 82617990: 98FC001C  stb r7, 0x1c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), ctx.r[7].u8 ) };
	// 82617994: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82617998: 48691ABC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826179A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826179A0 size=596
    let mut pc: u32 = 0x826179A0;
    'dispatch: loop {
        match pc {
            0x826179A0 => {
    //   block [0x826179A0..0x82617BF4)
	// 826179A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826179A4: 48691A69  bl 0x82ca940c
	ctx.lr = 0x826179A8;
	sub_82CA93D0(ctx, base);
	// 826179A8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826179AC: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82617BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82617BF8 size=612
    let mut pc: u32 = 0x82617BF8;
    'dispatch: loop {
        match pc {
            0x82617BF8 => {
    //   block [0x82617BF8..0x82617C8C)
	// 82617BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82617BFC: 486917DD  bl 0x82ca93d8
	ctx.lr = 0x82617C00;
	sub_82CA93D0(ctx, base);
	// 82617C00: DBE1FF70  stfd f31, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 82617C04: 9421FDD0  stwu r1, -0x230(r1)
	ea = ctx.r[1].u32.wrapping_add(-560 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82617C08: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 82617C0C: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82617C10: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82617C14: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82617C18: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 82617C1C: 92D20004  stw r22, 4(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	// 82617C20: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82617C24: 92D20008  stw r22, 8(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(8 as u32), ctx.r[22].u32 ) };
	// 82617C28: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82617C2C: 92D2000C  stw r22, 0xc(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(12 as u32), ctx.r[22].u32 ) };
	// 82617C30: 4BC07629  bl 0x8221f258
	ctx.lr = 0x82617C34;
	sub_8221F258(ctx, base);
	// 82617C34: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82617C38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82617C3C: 61710004  ori r17, r11, 4
	ctx.r[17].u64 = ctx.r[11].u64 | 4;
	// 82617C40: 419A004C  beq cr6, 0x82617c8c
	if ctx.cr[6].eq {
	pc = 0x82617C8C; continue 'dispatch;
	}
	// 82617C44: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82617C48: 92230004  stw r17, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[17].u32 ) };
	// 82617C4C: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 82617C50: 394B4C64  addi r10, r11, 0x4c64
	ctx.r[10].s64 = ctx.r[11].s64 + 19556;
	// 82617C54: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82617C58: 92C3000C  stw r22, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[22].u32 ) };
	// 82617C5C: 92C30010  stw r22, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[22].u32 ) };
	// 82617C60: 92C30014  stw r22, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[22].u32 ) };
	// 82617C64: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 82617C68: 891F0000  lbz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82617C6C: 88FF0001  lbz r7, 1(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 82617C70: 88DF0002  lbz r6, 2(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 82617C74: 9923001B  stb r9, 0x1b(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(27 as u32), ctx.r[9].u8 ) };
	// 82617C78: 99030018  stb r8, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[8].u8 ) };
	// 82617C7C: 98E30019  stb r7, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[7].u8 ) };
	// 82617C80: 98C3001A  stb r6, 0x1a(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(26 as u32), ctx.r[6].u8 ) };
	// 82617C84: 9AC3001C  stb r22, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[22].u8 ) };
	// 82617C88: 48000008  b 0x82617c90
	pc = 0x82617C90; continue 'dispatch;
            }
            0x82617C8C => {
    //   block [0x82617C8C..0x82617C90)
	// 82617C8C: 7ED5B378  mr r21, r22
	ctx.r[21].u64 = ctx.r[22].u64;
	pc = 0x82617C90; continue 'dispatch;
            }
            0x82617C90 => {
    //   block [0x82617C90..0x82617DAC)
	// 82617C90: 81770030  lwz r11, 0x30(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(48 as u32) ) } as u64;
	// 82617C94: 3B170028  addi r24, r23, 0x28
	ctx.r[24].s64 = ctx.r[23].s64 + 40;
	// 82617C98: 8157002C  lwz r10, 0x2c(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(44 as u32) ) } as u64;
	// 82617C9C: 7ED3B378  mr r19, r22
	ctx.r[19].u64 = ctx.r[22].u64;
	// 82617CA0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82617CA4: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82617CA8: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82617CAC: 419A0100  beq cr6, 0x82617dac
	if ctx.cr[6].eq {
	pc = 0x82617DAC; continue 'dispatch;
	}
	// 82617CB0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82617CB4: 7EDDB378  mr r29, r22
	ctx.r[29].u64 = ctx.r[22].u64;
	// 82617CB8: 7EDAB378  mr r26, r22
	ctx.r[26].u64 = ctx.r[22].u64;
	// 82617CBC: 3B600020  li r27, 0x20
	ctx.r[27].s64 = 32;
	// 82617CC0: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 82617CC4: C3EB92D8  lfs f31, -0x6d28(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27944 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82617CC8: 3E00834C  lis r16, -0x7cb4
	ctx.r[16].s64 = -2092171264;
	// 82617CCC: 83F40004  lwz r31, 4(r20)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 82617CD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82617CD4: 83D7002C  lwz r30, 0x2c(r23)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(44 as u32) ) } as u64;
	// 82617CD8: 7D7DFA14  add r11, r29, r31
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 82617CDC: 7C9DF82A  ldx r4, r29, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) };
	pc = 0x82617DAC; continue 'dispatch;
            }
            0x82617DAC => {
    //   block [0x82617DAC..0x82617E5C)
	// 82617DAC: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 82617DB0: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 82617DB4: 419A0038  beq cr6, 0x82617dec
	if ctx.cr[6].eq {
	pc = 0x82617DEC; continue 'dispatch;
	}
	// 82617DB8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82617DBC: 4BC07505  bl 0x8221f2c0
	ctx.lr = 0x82617DC0;
	sub_8221F2C0(ctx, base);
	// 82617DC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82617DC4: 409A0078  bne cr6, 0x82617e3c
	if !ctx.cr[6].eq {
	pc = 0x82617E3C; continue 'dispatch;
	}
	// 82617DC8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82617DCC: 814B6F6C  lwz r10, 0x6f6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82617DD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82617DD4: 419A0014  beq cr6, 0x82617de8
	if ctx.cr[6].eq {
	pc = 0x82617DE8; continue 'dispatch;
	}
	// 82617DD8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82617DDC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82617DE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82617DE4: 4E800421  bctrl
	ctx.lr = 0x82617DE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82617DE8: 486AA5C1  bl 0x82cc23a8
	ctx.lr = 0x82617DEC;
	sub_82CC23A8(ctx, base);
	// 82617DEC: 92C10054  stw r22, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[22].u32 ) };
	// 82617DF0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82617DF4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82617DF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82617DFC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82617E00: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82617E04: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 82617E08: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82617E0C: 4BD389D5  bl 0x823507e0
	ctx.lr = 0x82617E10;
	sub_823507E0(ctx, base);
	// 82617E10: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82617E14: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 82617E18: 48000879  bl 0x82618690
	ctx.lr = 0x82617E1C;
	sub_82618690(ctx, base);
	// 82617E1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82617E20: 4BB9FCF9  bl 0x821b7b18
	ctx.lr = 0x82617E24;
	sub_821B7B18(ctx, base);
	// 82617E24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82617E28: 4BB9FCF1  bl 0x821b7b18
	ctx.lr = 0x82617E2C;
	sub_821B7B18(ctx, base);
	// 82617E2C: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 82617E30: 38210230  addi r1, r1, 0x230
	ctx.r[1].s64 = ctx.r[1].s64 + 560;
	// 82617E34: CBE1FF70  lfd f31, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82617E38: 486915F0  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
	// 82617E3C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82617E40: 92A30008  stw r21, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[21].u32 ) };
	// 82617E44: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82617E48: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82617E4C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82617E50: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82617E54: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82617E58: 4BFFFF98  b 0x82617df0
	pc = 0x82617DF0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82617E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82617E60 size=164
    let mut pc: u32 = 0x82617E60;
    'dispatch: loop {
        match pc {
            0x82617E60 => {
    //   block [0x82617E60..0x82617F04)
	// 82617E60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82617E64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82617E68: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 82617E6C: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82617F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82617F08 size=444
    let mut pc: u32 = 0x82617F08;
    'dispatch: loop {
        match pc {
            0x82617F08 => {
    //   block [0x82617F08..0x826180C4)
	// 82617F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82617F0C: 486914FD  bl 0x82ca9408
	ctx.lr = 0x82617F10;
	sub_82CA93D0(ctx, base);
	// 82617F10: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82617F14: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82617F18: 489EEAB5  bl 0x830069cc
	ctx.lr = 0x82617F1C;
	sub_83006760(ctx, base);
	// 82617F1C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82617F20: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826180C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826180C8 size=384
    let mut pc: u32 = 0x826180C8;
    'dispatch: loop {
        match pc {
            0x826180C8 => {
    //   block [0x826180C8..0x82618248)
	// 826180C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826180CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826180D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826180D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826180D8: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 826180DC: 489EE8F9  bl 0x830069d4
	ctx.lr = 0x826180E0;
	sub_83006760(ctx, base);
	// 826180E0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826180E4: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 826180E8: C0040040  lfs f0, 0x40(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826180EC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826180F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 826180F4: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 826180F8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826180FC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82618100: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82618104: 3941006C  addi r10, r1, 0x6c
	ctx.r[10].s64 = ctx.r[1].s64 + 108;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82618248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82618248 size=1092
    let mut pc: u32 = 0x82618248;
    'dispatch: loop {
        match pc {
            0x82618248 => {
    //   block [0x82618248..0x8261868C)
	// 82618248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261824C: 486911AD  bl 0x82ca93f8
	ctx.lr = 0x82618250;
	sub_82CA93D0(ctx, base);
	// 82618250: DBA1FFA0  stfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[29].u64 ) };
	// 82618254: DBC1FFA8  stfd f30, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 82618258: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 8261825C: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82618690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82618690 size=220
    let mut pc: u32 = 0x82618690;
    'dispatch: loop {
        match pc {
            0x82618690 => {
    //   block [0x82618690..0x826186B4)
	// 82618690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82618694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82618698: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261869C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826186A0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 826186A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826186A8: 409A000C  bne cr6, 0x826186b4
	if !ctx.cr[6].eq {
	pc = 0x826186B4; continue 'dispatch;
	}
	// 826186AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 826186B0: 48000010  b 0x826186c0
	pc = 0x826186C0; continue 'dispatch;
            }
            0x826186B4 => {
    //   block [0x826186B4..0x826186C0)
	// 826186B4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 826186B8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 826186BC: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x826186C0; continue 'dispatch;
            }
            0x826186C0 => {
    //   block [0x826186C0..0x82618700)
	// 826186C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826186C4: 419A0070  beq cr6, 0x82618734
	if ctx.cr[6].eq {
	pc = 0x82618734; continue 'dispatch;
	}
	// 826186C8: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 826186CC: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 826186D0: 7D0A1E70  srawi r10, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 826186D4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 826186D8: 4098005C  bge cr6, 0x82618734
	if !ctx.cr[6].lt {
	pc = 0x82618734; continue 'dispatch;
	}
	// 826186DC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 826186E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826186E4: 419A0038  beq cr6, 0x8261871c
	if ctx.cr[6].eq {
	pc = 0x8261871C; continue 'dispatch;
	}
	// 826186E8: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 826186EC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826186F0: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 826186F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826186F8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826186FC: 419A0020  beq cr6, 0x8261871c
	if ctx.cr[6].eq {
	pc = 0x8261871C; continue 'dispatch;
	}
	pc = 0x82618700; continue 'dispatch;
            }
            0x82618700 => {
    //   block [0x82618700..0x8261871C)
	// 82618700: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82618704: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82618708: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8261870C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82618710: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82618714: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82618718: 4082FFE8  bne 0x82618700
	if !ctx.cr[0].eq {
	pc = 0x82618700; continue 'dispatch;
	}
	pc = 0x8261871C; continue 'dispatch;
            }
            0x8261871C => {
    //   block [0x8261871C..0x82618734)
	// 8261871C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82618720: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82618724: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82618728: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261872C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82618730: 4E800020  blr
	return;
            }
            0x82618734 => {
    //   block [0x82618734..0x82618744)
	// 82618734: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82618738: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261873C: 40990008  ble cr6, 0x82618744
	if !ctx.cr[6].gt {
	pc = 0x82618744; continue 'dispatch;
	}
	// 82618740: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82618744; continue 'dispatch;
            }
            0x82618744 => {
    //   block [0x82618744..0x8261876C)
	// 82618744: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82618748: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8261874C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82618750: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82618754: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82618758: 48000019  bl 0x82618770
	ctx.lr = 0x8261875C;
	sub_82618770(ctx, base);
	// 8261875C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82618760: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82618764: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82618768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82618770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82618770 size=220
    let mut pc: u32 = 0x82618770;
    'dispatch: loop {
        match pc {
            0x82618770 => {
    //   block [0x82618770..0x826187A8)
	// 82618770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82618774: 48690C99  bl 0x82ca940c
	ctx.lr = 0x82618778;
	sub_82CA93D0(ctx, base);
	// 82618778: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261877C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82618780: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82618784: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82618788: F88100A0  std r4, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u64 ) };
	// 8261878C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82618790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82618794: 419A0014  beq cr6, 0x826187a8
	if ctx.cr[6].eq {
	pc = 0x826187A8; continue 'dispatch;
	}
	// 82618798: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261879C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 826187A0: 7D291E71  srawi. r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826187A4: 4082000C  bne 0x826187b0
	if !ctx.cr[0].eq {
	pc = 0x826187B0; continue 'dispatch;
	}
	pc = 0x826187A8; continue 'dispatch;
            }
            0x826187A8 => {
    //   block [0x826187A8..0x826187B0)
	// 826187A8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826187AC: 48000034  b 0x826187e0
	pc = 0x826187E0; continue 'dispatch;
            }
            0x826187B0 => {
    //   block [0x826187B0..0x826187BC)
	// 826187B0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 826187B4: 40990008  ble cr6, 0x826187bc
	if !ctx.cr[6].gt {
	pc = 0x826187BC; continue 'dispatch;
	}
	// 826187B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826187BC; continue 'dispatch;
            }
            0x826187BC => {
    //   block [0x826187BC..0x826187D0)
	// 826187BC: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 826187C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826187C4: 419A000C  beq cr6, 0x826187d0
	if ctx.cr[6].eq {
	pc = 0x826187D0; continue 'dispatch;
	}
	// 826187C8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 826187CC: 419A0008  beq cr6, 0x826187d4
	if ctx.cr[6].eq {
	pc = 0x826187D4; continue 'dispatch;
	}
	pc = 0x826187D0; continue 'dispatch;
            }
            0x826187D0 => {
    //   block [0x826187D0..0x826187D4)
	// 826187D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x826187D4; continue 'dispatch;
            }
            0x826187D4 => {
    //   block [0x826187D4..0x826187E0)
	// 826187D4: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 826187D8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 826187DC: 7D3E1E70  srawi r30, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x826187E0; continue 'dispatch;
            }
            0x826187E0 => {
    //   block [0x826187E0..0x82618800)
	// 826187E0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826187E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826187E8: 48000069  bl 0x82618850
	ctx.lr = 0x826187EC;
	sub_82618850(ctx, base);
	// 826187EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826187F0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826187F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 826187F8: 40990008  ble cr6, 0x82618800
	if !ctx.cr[6].gt {
	pc = 0x82618800; continue 'dispatch;
	}
	// 826187FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82618800; continue 'dispatch;
            }
            0x82618800 => {
    //   block [0x82618800..0x82618830)
	// 82618800: 57CA1838  slwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82618804: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82618808: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8261880C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82618810: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82618814: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82618818: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8261881C: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82618820: 41990010  bgt cr6, 0x82618830
	if ctx.cr[6].gt {
	pc = 0x82618830; continue 'dispatch;
	}
	// 82618824: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82618828: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261882C: 40980008  bge cr6, 0x82618834
	if !ctx.cr[6].lt {
	pc = 0x82618834; continue 'dispatch;
	}
	pc = 0x82618830; continue 'dispatch;
            }
            0x82618830 => {
    //   block [0x82618830..0x82618834)
	// 82618830: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82618834; continue 'dispatch;
            }
            0x82618834 => {
    //   block [0x82618834..0x8261884C)
	// 82618834: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82618838: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261883C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82618840: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82618844: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82618848: 48690C14  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82618850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82618850 size=680
    let mut pc: u32 = 0x82618850;
    'dispatch: loop {
        match pc {
            0x82618850 => {
    //   block [0x82618850..0x8261887C)
	// 82618850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82618854: 48690BAD  bl 0x82ca9400
	ctx.lr = 0x82618858;
	sub_82CA93D0(ctx, base);
	// 82618858: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261885C: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82618860: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82618864: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82618868: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 8261886C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82618870: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82618874: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82618878: 419A0020  beq cr6, 0x82618898
	if ctx.cr[6].eq {
	pc = 0x82618898; continue 'dispatch;
	}
	pc = 0x8261887C; continue 'dispatch;
            }
            0x8261887C => {
    //   block [0x8261887C..0x82618898)
	// 8261887C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82618880: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82618884: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82618888: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8261888C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82618890: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82618894: 4082FFE8  bne 0x8261887c
	if !ctx.cr[0].eq {
	pc = 0x8261887C; continue 'dispatch;
	}
	pc = 0x82618898; continue 'dispatch;
            }
            0x82618898 => {
    //   block [0x82618898..0x826188AC)
	// 82618898: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261889C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826188A0: 409A000C  bne cr6, 0x826188ac
	if !ctx.cr[6].eq {
	pc = 0x826188AC; continue 'dispatch;
	}
	// 826188A4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 826188A8: 48000010  b 0x826188b8
	pc = 0x826188B8; continue 'dispatch;
            }
            0x826188AC => {
    //   block [0x826188AC..0x826188B8)
	// 826188AC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 826188B0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 826188B4: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x826188B8; continue 'dispatch;
            }
            0x826188B8 => {
    //   block [0x826188B8..0x826188C8)
	// 826188B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826188BC: 409A000C  bne cr6, 0x826188c8
	if !ctx.cr[6].eq {
	pc = 0x826188C8; continue 'dispatch;
	}
	// 826188C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826188C4: 48000010  b 0x826188d4
	pc = 0x826188D4; continue 'dispatch;
            }
            0x826188C8 => {
    //   block [0x826188C8..0x826188D4)
	// 826188C8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826188CC: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 826188D0: 7D0B1E70  srawi r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	pc = 0x826188D4; continue 'dispatch;
            }
            0x826188D4 => {
    //   block [0x826188D4..0x826188FC)
	// 826188D4: 3D001FFF  lis r8, 0x1fff
	ctx.r[8].s64 = 536805376;
	// 826188D8: 6108FFFF  ori r8, r8, 0xffff
	ctx.r[8].u64 = ctx.r[8].u64 | 65535;
	// 826188DC: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 826188E0: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 826188E4: 40980018  bge cr6, 0x826188fc
	if !ctx.cr[6].lt {
	pc = 0x826188FC; continue 'dispatch;
	}
	// 826188E8: 4BEDC1E9  bl 0x824f4ad0
	ctx.lr = 0x826188EC;
	sub_824F4AD0(ctx, base);
	// 826188EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826188F0: 4BB9F229  bl 0x821b7b18
	ctx.lr = 0x826188F4;
	sub_821B7B18(ctx, base);
	// 826188F4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826188F8: 48690B58  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x826188FC => {
    //   block [0x826188FC..0x8261890C)
	// 826188FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82618900: 409A000C  bne cr6, 0x8261890c
	if !ctx.cr[6].eq {
	pc = 0x8261890C; continue 'dispatch;
	}
	// 82618904: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82618908: 48000010  b 0x82618918
	pc = 0x82618918; continue 'dispatch;
            }
            0x8261890C => {
    //   block [0x8261890C..0x82618918)
	// 8261890C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82618910: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82618914: 7CEB1E70  srawi r11, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 3) as i64;
	pc = 0x82618918; continue 'dispatch;
            }
            0x82618918 => {
    //   block [0x82618918..0x8261893C)
	// 82618918: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8261891C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82618920: 40980138  bge cr6, 0x82618a58
	if !ctx.cr[6].lt {
	pc = 0x82618A58; continue 'dispatch;
	}
	// 82618924: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82618928: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8261892C: 7D0B4050  subf r8, r11, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82618930: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82618934: 41980008  blt cr6, 0x8261893c
	if ctx.cr[6].lt {
	pc = 0x8261893C; continue 'dispatch;
	}
	// 82618938: 7F4B4A14  add r26, r11, r9
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x8261893C; continue 'dispatch;
            }
            0x8261893C => {
    //   block [0x8261893C..0x8261894C)
	// 8261893C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82618940: 409A000C  bne cr6, 0x8261894c
	if !ctx.cr[6].eq {
	pc = 0x8261894C; continue 'dispatch;
	}
	// 82618944: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82618948: 48000010  b 0x82618958
	pc = 0x82618958; continue 'dispatch;
            }
            0x8261894C => {
    //   block [0x8261894C..0x82618958)
	// 8261894C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82618950: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82618954: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x82618958; continue 'dispatch;
            }
            0x82618958 => {
    //   block [0x82618958..0x82618974)
	// 82618958: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8261895C: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82618960: 40980024  bge cr6, 0x82618984
	if !ctx.cr[6].lt {
	pc = 0x82618984; continue 'dispatch;
	}
	// 82618964: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82618968: 409A000C  bne cr6, 0x82618974
	if !ctx.cr[6].eq {
	pc = 0x82618974; continue 'dispatch;
	}
	// 8261896C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82618970: 48000010  b 0x82618980
	pc = 0x82618980; continue 'dispatch;
            }
            0x82618974 => {
    //   block [0x82618974..0x82618980)
	// 82618974: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82618978: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8261897C: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x82618980; continue 'dispatch;
            }
            0x82618980 => {
    //   block [0x82618980..0x82618984)
	// 82618980: 3B4B0001  addi r26, r11, 1
	ctx.r[26].s64 = ctx.r[11].s64 + 1;
	pc = 0x82618984; continue 'dispatch;
            }
            0x82618984 => {
    //   block [0x82618984..0x826189E8)
	// 82618984: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82618988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261898C: 48497FCD  bl 0x82ab0958
	ctx.lr = 0x82618990;
	sub_82AB0958(ctx, base);
	// 82618990: 83C100AC  lwz r30, 0xac(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82618994: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82618998: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261899C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826189A0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 826189A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826189A8: 4BE68299  bl 0x82480c40
	ctx.lr = 0x826189AC;
	sub_82480C40(ctx, base);
	// 826189AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826189B0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826189B4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826189B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826189BC: 48043CF5  bl 0x8265c6b0
	ctx.lr = 0x826189C0;
	sub_8265C6B0(ctx, base);
	// 826189C0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826189C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826189C8: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826189CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826189D0: 4BE68271  bl 0x82480c40
	ctx.lr = 0x826189D4;
	sub_82480C40(ctx, base);
	// 826189D4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826189D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826189DC: 409A000C  bne cr6, 0x826189e8
	if !ctx.cr[6].eq {
	pc = 0x826189E8; continue 'dispatch;
	}
	// 826189E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826189E4: 48000010  b 0x826189f4
	pc = 0x826189F4; continue 'dispatch;
            }
            0x826189E8 => {
    //   block [0x826189E8..0x826189F4)
	// 826189E8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826189EC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 826189F0: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x826189F4; continue 'dispatch;
            }
            0x826189F4 => {
    //   block [0x826189F4..0x82618A10)
	// 826189F4: 3B6A0001  addi r27, r10, 1
	ctx.r[27].s64 = ctx.r[10].s64 + 1;
	// 826189F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826189FC: 419A0030  beq cr6, 0x82618a2c
	if ctx.cr[6].eq {
	pc = 0x82618A2C; continue 'dispatch;
	}
	// 82618A00: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82618A04: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82618A08: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82618A0C: 419A0018  beq cr6, 0x82618a24
	if ctx.cr[6].eq {
	pc = 0x82618A24; continue 'dispatch;
	}
	pc = 0x82618A10; continue 'dispatch;
            }
            0x82618A10 => {
    //   block [0x82618A10..0x82618A24)
	// 82618A10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82618A14: 4BB9F105  bl 0x821b7b18
	ctx.lr = 0x82618A18;
	sub_821B7B18(ctx, base);
	// 82618A18: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82618A1C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82618A20: 409AFFF0  bne cr6, 0x82618a10
	if !ctx.cr[6].eq {
	pc = 0x82618A10; continue 'dispatch;
	}
	pc = 0x82618A24; continue 'dispatch;
            }
            0x82618A24 => {
    //   block [0x82618A24..0x82618A2C)
	// 82618A24: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82618A28: 4BC03311  bl 0x8221bd38
	ctx.lr = 0x82618A2C;
	sub_8221BD38(ctx, base);
	pc = 0x82618A2C; continue 'dispatch;
            }
            0x82618A2C => {
    //   block [0x82618A2C..0x82618A58)
	// 82618A2C: 574B1838  slwi r11, r26, 3
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82618A30: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82618A34: 576A1838  slwi r10, r27, 3
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82618A38: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82618A3C: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82618A40: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82618A44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82618A48: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82618A4C: 4BB9F0CD  bl 0x821b7b18
	ctx.lr = 0x82618A50;
	sub_821B7B18(ctx, base);
	// 82618A50: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82618A54: 486909FC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82618A58 => {
    //   block [0x82618A58..0x82618AB4)
	// 82618A58: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82618A5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82618A60: 83C100AC  lwz r30, 0xac(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82618A64: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82618A68: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82618A6C: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82618A70: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82618A74: 40980040  bge cr6, 0x82618ab4
	if !ctx.cr[6].lt {
	pc = 0x82618AB4; continue 'dispatch;
	}
	// 82618A78: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82618A7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82618A80: 4BE681C1  bl 0x82480c40
	ctx.lr = 0x82618A84;
	sub_82480C40(ctx, base);
	// 82618A84: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82618A88: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82618A8C: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82618A90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82618A94: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82618A98: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 82618A9C: 48043C15  bl 0x8265c6b0
	ctx.lr = 0x82618AA0;
	sub_8265C6B0(ctx, base);
	// 82618AA0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82618AA4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82618AA8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82618AAC: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 82618AB0: 4800002C  b 0x82618adc
	pc = 0x82618ADC; continue 'dispatch;
            }
            0x82618AB4 => {
    //   block [0x82618AB4..0x82618ADC)
	// 82618AB4: 3B9DFFF8  addi r28, r29, -8
	ctx.r[28].s64 = ctx.r[29].s64 + -8;
	// 82618AB8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82618ABC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82618AC0: 4BE68181  bl 0x82480c40
	ctx.lr = 0x82618AC4;
	sub_82480C40(ctx, base);
	// 82618AC4: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82618AC8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82618ACC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82618AD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82618AD4: 4BD3E4E5  bl 0x82356fb8
	ctx.lr = 0x82618AD8;
	sub_82356FB8(ctx, base);
	// 82618AD8: 389E0008  addi r4, r30, 8
	ctx.r[4].s64 = ctx.r[30].s64 + 8;
	pc = 0x82618ADC; continue 'dispatch;
            }
            0x82618ADC => {
    //   block [0x82618ADC..0x82618AF8)
	// 82618ADC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82618AE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82618AE4: 480D7A3D  bl 0x826f0520
	ctx.lr = 0x82618AE8;
	sub_826F0520(ctx, base);
	// 82618AE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82618AEC: 4BB9F02D  bl 0x821b7b18
	ctx.lr = 0x82618AF0;
	sub_821B7B18(ctx, base);
	// 82618AF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82618AF4: 4869095C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82618AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82618AF8 size=148
    let mut pc: u32 = 0x82618AF8;
    'dispatch: loop {
        match pc {
            0x82618AF8 => {
    //   block [0x82618AF8..0x82618B84)
	// 82618AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82618AFC: 4869090D  bl 0x82ca9408
	ctx.lr = 0x82618B00;
	sub_82CA93D0(ctx, base);
	// 82618B00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82618B04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82618B08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82618B0C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82618B10: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82618B14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82618B18: 419A006C  beq cr6, 0x82618b84
	if ctx.cr[6].eq {
	pc = 0x82618B84; continue 'dispatch;
	}
	// 82618B1C: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82618B20: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82618B24: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82618B28: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82618B2C: 4BC105DD  bl 0x82229108
	ctx.lr = 0x82618B30;
	sub_82229108(ctx, base);
	// 82618B30: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82618B34: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82618B38: 4BC0ED49  bl 0x82227880
	ctx.lr = 0x82618B3C;
	sub_82227880(ctx, base);
	// 82618B3C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82618B40: 3D40822C  lis r10, -0x7dd4
	ctx.r[10].s64 = -2111045632;
	// 82618B44: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82618B48: 388AF600  addi r4, r10, -0xa00
	ctx.r[4].s64 = ctx.r[10].s64 + -2560;
	// 82618B4C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82618B50: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82618B54: 4BB81F2D  bl 0x8219aa80
	ctx.lr = 0x82618B58;
	sub_8219AA80(ctx, base);
	// 82618B58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82618B5C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82618B60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82618B64: 4BDB58BD  bl 0x823ce420
	ctx.lr = 0x82618B68;
	sub_823CE420(ctx, base);
	// 82618B68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82618B6C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82618B70: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82618B74: 4840BB55  bl 0x82a246c8
	ctx.lr = 0x82618B78;
	sub_82A246C8(ctx, base);
	// 82618B78: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82618B7C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82618B80: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82618B84; continue 'dispatch;
            }
            0x82618B84 => {
    //   block [0x82618B84..0x82618B8C)
	// 82618B84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82618B88: 486908D0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82618B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82618B90 size=148
    let mut pc: u32 = 0x82618B90;
    'dispatch: loop {
        match pc {
            0x82618B90 => {
    //   block [0x82618B90..0x82618C1C)
	// 82618B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82618B94: 48690875  bl 0x82ca9408
	ctx.lr = 0x82618B98;
	sub_82CA93D0(ctx, base);
	// 82618B98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82618B9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82618BA0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82618BA4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82618BA8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82618BAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82618BB0: 419A006C  beq cr6, 0x82618c1c
	if ctx.cr[6].eq {
	pc = 0x82618C1C; continue 'dispatch;
	}
	// 82618BB4: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82618BB8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82618BBC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82618BC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82618BC4: 4BC10545  bl 0x82229108
	ctx.lr = 0x82618BC8;
	sub_82229108(ctx, base);
	// 82618BC8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82618BCC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82618BD0: 4BC0ECB1  bl 0x82227880
	ctx.lr = 0x82618BD4;
	sub_82227880(ctx, base);
	// 82618BD4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82618BD8: 3D408262  lis r10, -0x7d9e
	ctx.r[10].s64 = -2107506688;
	// 82618BDC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82618BE0: 388A8CC0  addi r4, r10, -0x7340
	ctx.r[4].s64 = ctx.r[10].s64 + -29504;
	// 82618BE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82618BE8: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82618BEC: 4BB81E95  bl 0x8219aa80
	ctx.lr = 0x82618BF0;
	sub_8219AA80(ctx, base);
	// 82618BF0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82618BF4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82618BF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82618BFC: 4BDB5825  bl 0x823ce420
	ctx.lr = 0x82618C00;
	sub_823CE420(ctx, base);
	// 82618C00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82618C04: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82618C08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82618C0C: 4840BABD  bl 0x82a246c8
	ctx.lr = 0x82618C10;
	sub_82A246C8(ctx, base);
	// 82618C10: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82618C14: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82618C18: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82618C1C; continue 'dispatch;
            }
            0x82618C1C => {
    //   block [0x82618C1C..0x82618C24)
	// 82618C1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82618C20: 48690838  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82618C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82618C28 size=148
    let mut pc: u32 = 0x82618C28;
    'dispatch: loop {
        match pc {
            0x82618C28 => {
    //   block [0x82618C28..0x82618CB4)
	// 82618C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82618C2C: 486907DD  bl 0x82ca9408
	ctx.lr = 0x82618C30;
	sub_82CA93D0(ctx, base);
	// 82618C30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82618C34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82618C38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82618C3C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82618C40: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82618C44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82618C48: 419A006C  beq cr6, 0x82618cb4
	if ctx.cr[6].eq {
	pc = 0x82618CB4; continue 'dispatch;
	}
	// 82618C4C: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82618C50: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82618C54: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82618C58: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82618C5C: 4BC104AD  bl 0x82229108
	ctx.lr = 0x82618C60;
	sub_82229108(ctx, base);
	// 82618C60: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82618C64: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82618C68: 4BC0EC19  bl 0x82227880
	ctx.lr = 0x82618C6C;
	sub_82227880(ctx, base);
	// 82618C6C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82618C70: 3D408262  lis r10, -0x7d9e
	ctx.r[10].s64 = -2107506688;
	// 82618C74: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82618C78: 388A8D48  addi r4, r10, -0x72b8
	ctx.r[4].s64 = ctx.r[10].s64 + -29368;
	// 82618C7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82618C80: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82618C84: 4BB81DFD  bl 0x8219aa80
	ctx.lr = 0x82618C88;
	sub_8219AA80(ctx, base);
	// 82618C88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82618C8C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82618C90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82618C94: 4BDB578D  bl 0x823ce420
	ctx.lr = 0x82618C98;
	sub_823CE420(ctx, base);
	// 82618C98: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82618C9C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82618CA0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82618CA4: 4840BA25  bl 0x82a246c8
	ctx.lr = 0x82618CA8;
	sub_82A246C8(ctx, base);
	// 82618CA8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82618CAC: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82618CB0: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82618CB4; continue 'dispatch;
            }
            0x82618CB4 => {
    //   block [0x82618CB4..0x82618CBC)
	// 82618CB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82618CB8: 486907A0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82618CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82618CC0 size=132
    let mut pc: u32 = 0x82618CC0;
    'dispatch: loop {
        match pc {
            0x82618CC0 => {
    //   block [0x82618CC0..0x82618D44)
	// 82618CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82618CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82618CC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82618CCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82618CD0: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 82618CD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82618CD8: 4BC0F421  bl 0x822280f8
	ctx.lr = 0x82618CDC;
	sub_822280F8(ctx, base);
	// 82618CDC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82618CE0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82618CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82618CE8: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82618CEC: 4BC0F40D  bl 0x822280f8
	ctx.lr = 0x82618CF0;
	sub_822280F8(ctx, base);
	// 82618CF0: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82618D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82618D48 size=192
    let mut pc: u32 = 0x82618D48;
    'dispatch: loop {
        match pc {
            0x82618D48 => {
    //   block [0x82618D48..0x82618E08)
	// 82618D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82618D4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82618D50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82618D54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82618D58: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82618E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82618E08 size=152
    let mut pc: u32 = 0x82618E08;
    'dispatch: loop {
        match pc {
            0x82618E08 => {
    //   block [0x82618E08..0x82618EA0)
	// 82618E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82618E0C: 48690601  bl 0x82ca940c
	ctx.lr = 0x82618E10;
	sub_82CA93D0(ctx, base);
	// 82618E10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82618E14: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 82618E18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82618E1C: 4BC0F2DD  bl 0x822280f8
	ctx.lr = 0x82618E20;
	sub_822280F8(ctx, base);
	// 82618E20: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82618E24: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82618E28: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82618E2C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82618E30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82618E34: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 82618E38: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82618E3C: 4BC0F2BD  bl 0x822280f8
	ctx.lr = 0x82618E40;
	sub_822280F8(ctx, base);
	// 82618E40: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82618E44: 4BC0E71D  bl 0x82227560
	ctx.lr = 0x82618E48;
	sub_82227560(ctx, base);
	// 82618E48: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82618E4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82618E50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82618E54: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82618E58: 4BCE90A1  bl 0x82301ef8
	ctx.lr = 0x82618E5C;
	sub_82301EF8(ctx, base);
	// 82618E5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82618E60: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 82618E64: 4E800421  bctrl
	ctx.lr = 0x82618E68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82618E68: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82618E6C: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82618E70: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82618E74: 7D050034  cntlzw r5, r8
	ctx.r[5].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 82618E78: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82618E7C: 54A4DFFE  rlwinm r4, r5, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 82618E80: 90C70004  stw r6, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82618E84: 688B0001  xori r11, r4, 1
	ctx.r[11].u64 = ctx.r[4].u64 ^ 1;
	// 82618E88: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82618E8C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82618E90: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 82618E94: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82618E98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82618E9C: 486905C0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82618EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82618EA0 size=160
    let mut pc: u32 = 0x82618EA0;
    'dispatch: loop {
        match pc {
            0x82618EA0 => {
    //   block [0x82618EA0..0x82618F24)
	// 82618EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82618EA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82618EA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82618EAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82618EB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82618EB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82618EB8: 38600254  li r3, 0x254
	ctx.r[3].s64 = 596;
	// 82618EBC: 4BFFDA6D  bl 0x82616928
	ctx.lr = 0x82618EC0;
	sub_82616928(ctx, base);
	// 82618EC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82618EC4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82618EC8: 419A005C  beq cr6, 0x82618f24
	if ctx.cr[6].eq {
	pc = 0x82618F24; continue 'dispatch;
	}
	// 82618ECC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82618ED0: 48897149  bl 0x82eb0018
	ctx.lr = 0x82618ED4;
	sub_82EB0018(ctx, base);
	// 82618ED4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82618ED8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82618EDC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82618EE0: 390B6E70  addi r8, r11, 0x6e70
	ctx.r[8].s64 = ctx.r[11].s64 + 28272;
	// 82618EE4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82618EE8: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 82618EEC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82618EF0: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82618EF4: 397F01D0  addi r11, r31, 0x1d0
	ctx.r[11].s64 = ctx.r[31].s64 + 464;
	// 82618EF8: D01F01D0  stfs f0, 0x1d0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 82618EFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82618F00: D01F01D4  stfs f0, 0x1d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 82618F04: D01F01D8  stfs f0, 0x1d8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 82618F08: 98FF01E0  stb r7, 0x1e0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[7].u8 ) };
	// 82618F0C: C0090BEC  lfs f0, 0xbec(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82618F10: 90DF01DC  stw r6, 0x1dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[6].u32 ) };
	// 82618F14: D01F01D0  stfs f0, 0x1d0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 82618F18: D01F01D4  stfs f0, 0x1d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 82618F1C: D01F01D8  stfs f0, 0x1d8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 82618F20: 48000008  b 0x82618f28
	pc = 0x82618F28; continue 'dispatch;
            }
            0x82618F24 => {
    //   block [0x82618F24..0x82618F28)
	// 82618F24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82618F28; continue 'dispatch;
            }
            0x82618F28 => {
    //   block [0x82618F28..0x82618F40)
	// 82618F28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82618F2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82618F30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82618F34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82618F38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82618F3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82618F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82618F40 size=104
    let mut pc: u32 = 0x82618F40;
    'dispatch: loop {
        match pc {
            0x82618F40 => {
    //   block [0x82618F40..0x82618F90)
	// 82618F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82618F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82618F48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82618F4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82618F50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82618F54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82618F58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82618F5C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82618F60: 394B6E70  addi r10, r11, 0x6e70
	ctx.r[10].s64 = ctx.r[11].s64 + 28272;
	// 82618F64: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82618F68: 48898669  bl 0x82eb15d0
	ctx.lr = 0x82618F6C;
	sub_82EB15D0(ctx, base);
	// 82618F6C: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82618F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82618F74: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82618F78: 419A0018  beq cr6, 0x82618f90
	if ctx.cr[6].eq {
	pc = 0x82618F90; continue 'dispatch;
	}
	// 82618F7C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82618F80: 814BDAB4  lwz r10, -0x254c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82618F84: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82618F88: 4E800421  bctrl
	ctx.lr = 0x82618F8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82618F8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            0x82618F90 => {
    //   block [0x82618F90..0x82618FA8)
	// 82618F90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82618F94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82618F98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82618F9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82618FA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82618FA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82618FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82618FA8 size=120
    let mut pc: u32 = 0x82618FA8;
    'dispatch: loop {
        match pc {
            0x82618FA8 => {
    //   block [0x82618FA8..0x82618FE0)
	// 82618FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82618FAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82618FB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82618FB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82618FB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82618FBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82618FC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82618FC4: 48898195  bl 0x82eb1158
	ctx.lr = 0x82618FC8;
	sub_82EB1158(ctx, base);
	// 82618FC8: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82618FCC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82618FD0: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82618FD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82618FD8: 40990030  ble cr6, 0x82619008
	if !ctx.cr[6].gt {
	pc = 0x82619008; continue 'dispatch;
	}
	// 82618FDC: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x82618FE0; continue 'dispatch;
            }
            0x82618FE0 => {
    //   block [0x82618FE0..0x82618FF4)
	// 82618FE0: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82618FE4: 7CEB502E  lwzx r7, r11, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82618FE8: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82618FEC: 409A0008  bne cr6, 0x82618ff4
	if !ctx.cr[6].eq {
	pc = 0x82618FF4; continue 'dispatch;
	}
	// 82618FF0: 7D0B512E  stwx r8, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	pc = 0x82618FF4; continue 'dispatch;
            }
            0x82618FF4 => {
    //   block [0x82618FF4..0x82619008)
	// 82618FF4: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82618FF8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82618FFC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82619000: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82619004: 4198FFDC  blt cr6, 0x82618fe0
	if ctx.cr[6].lt {
	pc = 0x82618FE0; continue 'dispatch;
	}
	pc = 0x82619008; continue 'dispatch;
            }
            0x82619008 => {
    //   block [0x82619008..0x82619020)
	// 82619008: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261900C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82619010: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82619014: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82619018: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261901C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82619020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82619020 size=156
    let mut pc: u32 = 0x82619020;
    'dispatch: loop {
        match pc {
            0x82619020 => {
    //   block [0x82619020..0x82619098)
	// 82619020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82619024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82619028: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261902C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82619030: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82619034: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82619038: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261903C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82619040: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82619044: 4E800421  bctrl
	ctx.lr = 0x82619048;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82619048: 813F01DC  lwz r9, 0x1dc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 8261904C: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 82619050: 419A0048  beq cr6, 0x82619098
	if ctx.cr[6].eq {
	pc = 0x82619098; continue 'dispatch;
	}
	// 82619054: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82619058: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261905C: 4BC4C895  bl 0x822658f0
	ctx.lr = 0x82619060;
	sub_822658F0(ctx, base);
	// 82619060: 389F01D0  addi r4, r31, 0x1d0
	ctx.r[4].s64 = ctx.r[31].s64 + 464;
	// 82619064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619068: 488991D9  bl 0x82eb2240
	ctx.lr = 0x8261906C;
	sub_82EB2240(ctx, base);
	// 8261906C: 987F01E0  stb r3, 0x1e0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[3].u8 ) };
	// 82619070: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82619074: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619078: 48000049  bl 0x826190c0
	ctx.lr = 0x8261907C;
	sub_826190C0(ctx, base);
	// 8261907C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82619080: 917F01DC  stw r11, 0x1dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[11].u32 ) };
	// 82619084: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82619088: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261908C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82619090: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82619094: 4E800020  blr
	return;
            }
            0x82619098 => {
    //   block [0x82619098..0x826190BC)
	// 82619098: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8261909C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 826190A0: 997F01E0  stb r11, 0x1e0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[11].u8 ) };
	// 826190A4: 915F01DC  stw r10, 0x1dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[10].u32 ) };
	// 826190A8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826190AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826190B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826190B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826190B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826190C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826190C0 size=344
    let mut pc: u32 = 0x826190C0;
    'dispatch: loop {
        match pc {
            0x826190C0 => {
    //   block [0x826190C0..0x82619158)
	// 826190C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826190C4: 48690345  bl 0x82ca9408
	ctx.lr = 0x826190C8;
	sub_82CA93D0(ctx, base);
	// 826190C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826190CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826190D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826190D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826190D8: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826190DC: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 826190E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 826190E4: 4E800421  bctrl
	ctx.lr = 0x826190E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826190E8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826190EC: C05E0008  lfs f2, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826190F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826190F4: C03E0004  lfs f1, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826190F8: 81090030  lwz r8, 0x30(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 826190FC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82619100: 4E800421  bctrl
	ctx.lr = 0x82619104;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82619104: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82619108: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261910C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619110: 80C7003C  lwz r6, 0x3c(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(60 as u32) ) } as u64;
	// 82619114: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82619118: 4E800421  bctrl
	ctx.lr = 0x8261911C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261911C: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82619120: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82619124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619128: 81650060  lwz r11, 0x60(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(96 as u32) ) } as u64;
	// 8261912C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82619130: 4E800421  bctrl
	ctx.lr = 0x82619134;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82619134: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82619138: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 8261913C: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82619140: 419A0018  beq cr6, 0x82619158
	if ctx.cr[6].eq {
	pc = 0x82619158; continue 'dispatch;
	}
	// 82619144: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82619148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261914C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82619150: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82619154: 4E800421  bctrl
	ctx.lr = 0x82619158;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82619158 => {
    //   block [0x82619158..0x82619218)
	// 82619158: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 8261915C: C01E0018  lfs f0, 0x18(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82619160: 895E004C  lbz r10, 0x4c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 82619164: C1BE001C  lfs f13, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82619168: 893E004D  lbz r9, 0x4d(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(77 as u32) ) } as u64;
	// 8261916C: C19E0020  lfs f12, 0x20(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82619170: 811E0050  lwz r8, 0x50(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82619174: C17E0024  lfs f11, 0x24(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82619178: 80FE0054  lwz r7, 0x54(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261917C: C15E0028  lfs f10, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82619180: 80DE0058  lwz r6, 0x58(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82619184: C13E002C  lfs f9, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82619188: 80BE005C  lwz r5, 0x5c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 8261918C: C11E0030  lfs f8, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82619190: 809E0060  lwz r4, 0x60(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82619194: C0FE0034  lfs f7, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82619198: 807E0064  lwz r3, 0x64(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 8261919C: C0DE003C  lfs f6, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 826191A0: 83BE0068  lwz r29, 0x68(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 826191A4: C0BE0040  lfs f5, 0x40(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 826191A8: 839E006C  lwz r28, 0x6c(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 826191AC: C09E0044  lfs f4, 0x44(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 826191B0: C07E0048  lfs f3, 0x48(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826191B4: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826191B8: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 826191BC: 995F0068  stb r10, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[10].u8 ) };
	// 826191C0: D1BF0038  stfs f13, 0x38(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 826191C4: 993F0069  stb r9, 0x69(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(105 as u32), ctx.r[9].u8 ) };
	// 826191C8: D19F003C  stfs f12, 0x3c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 826191CC: 911F009C  stw r8, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[8].u32 ) };
	// 826191D0: D17F0040  stfs f11, 0x40(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 826191D4: 90FF00A0  stw r7, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[7].u32 ) };
	// 826191D8: D15F0044  stfs f10, 0x44(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 826191DC: 90DF00A4  stw r6, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[6].u32 ) };
	// 826191E0: D13F0048  stfs f9, 0x48(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 826191E4: 90BF00A8  stw r5, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[5].u32 ) };
	// 826191E8: D11F004C  stfs f8, 0x4c(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 826191EC: 909F00AC  stw r4, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 826191F0: D0FF0050  stfs f7, 0x50(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 826191F4: 907F00B0  stw r3, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
	// 826191F8: D0DF0058  stfs f6, 0x58(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 826191FC: 93BF00B4  stw r29, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[29].u32 ) };
	// 82619200: D0BF005C  stfs f5, 0x5c(r31)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82619204: 939F00B8  stw r28, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[28].u32 ) };
	// 82619208: D09F0060  stfs f4, 0x60(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8261920C: D07F0064  stfs f3, 0x64(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82619210: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82619214: 48690244  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82619218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82619218 size=84
    let mut pc: u32 = 0x82619218;
    'dispatch: loop {
        match pc {
            0x82619218 => {
    //   block [0x82619218..0x82619258)
	// 82619218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261921C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82619220: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82619224: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82619228: 4BFFD701  bl 0x82616928
	ctx.lr = 0x8261922C;
	sub_82616928(ctx, base);
	// 8261922C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82619230: 419A0028  beq cr6, 0x82619258
	if ctx.cr[6].eq {
	pc = 0x82619258; continue 'dispatch;
	}
	// 82619234: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82619238: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261923C: 392A1C84  addi r9, r10, 0x1c84
	ctx.r[9].s64 = ctx.r[10].s64 + 7300;
	// 82619240: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82619244: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82619248: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8261924C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82619250: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82619254: 4E800020  blr
	return;
            }
            0x82619258 => {
    //   block [0x82619258..0x8261926C)
	// 82619258: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8261925C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82619260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82619264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82619268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82619270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82619270 size=92
    let mut pc: u32 = 0x82619270;
    'dispatch: loop {
        match pc {
            0x82619270 => {
    //   block [0x82619270..0x826192B4)
	// 82619270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82619274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82619278: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8261927C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82619280: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82619284: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82619288: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8261928C: 48000045  bl 0x826192d0
	ctx.lr = 0x82619290;
	sub_826192D0(ctx, base);
	// 82619290: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82619294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261929C: 419A0018  beq cr6, 0x826192b4
	if ctx.cr[6].eq {
	pc = 0x826192B4; continue 'dispatch;
	}
	// 826192A0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 826192A4: 814BDAB4  lwz r10, -0x254c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 826192A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 826192AC: 4E800421  bctrl
	ctx.lr = 0x826192B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826192B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            0x826192B4 => {
    //   block [0x826192B4..0x826192CC)
	// 826192B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826192B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826192BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826192C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826192C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826192C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826192D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826192D0 size=212
    let mut pc: u32 = 0x826192D0;
    'dispatch: loop {
        match pc {
            0x826192D0 => {
    //   block [0x826192D0..0x82619314)
	// 826192D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826192D4: 48690131  bl 0x82ca9404
	ctx.lr = 0x826192D8;
	sub_82CA93D0(ctx, base);
	// 826192D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826192DC: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 826192E0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826192E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826192E8: 394B1C84  addi r10, r11, 0x1c84
	ctx.r[10].s64 = ctx.r[11].s64 + 7300;
	// 826192EC: 807F6CC0  lwz r3, 0x6cc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27840 as u32) ) } as u64;
	// 826192F0: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826192F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826192F8: 419A001C  beq cr6, 0x82619314
	if ctx.cr[6].eq {
	pc = 0x82619314; continue 'dispatch;
	}
	// 826192FC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82619300: 814BDAB4  lwz r10, -0x254c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82619304: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82619308: 4E800421  bctrl
	ctx.lr = 0x8261930C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261930C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82619310: 917F6CC0  stw r11, 0x6cc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(27840 as u32), ctx.r[11].u32 ) };
            }
            0x82619314 => {
    //   block [0x82619314..0x82619368)
	// 82619314: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 82619318: 817C6CB0  lwz r11, 0x6cb0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27824 as u32) ) } as u64;
	// 8261931C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82619320: 419A0070  beq cr6, 0x82619390
	if ctx.cr[6].eq {
	pc = 0x82619390; continue 'dispatch;
	}
	// 82619324: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82619328: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8261932C: 3BEB8D30  addi r31, r11, -0x72d0
	ctx.r[31].s64 = ctx.r[11].s64 + -29392;
	// 82619330: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82619334: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82619338: 4BBE7439  bl 0x82200770
	ctx.lr = 0x8261933C;
	sub_82200770(ctx, base);
	// 8261933C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82619340: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82619344: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82619348: 996A6CBC  stb r11, 0x6cbc(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(27836 as u32), ctx.r[11].u8 ) };
	// 8261934C: 80696CB4  lwz r3, 0x6cb4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27828 as u32) ) } as u64;
	// 82619350: 4BCB0039  bl 0x822c9388
	ctx.lr = 0x82619354;
	sub_822C9388(ctx, base);
	// 82619354: 88E10054  lbz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82619358: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261935C: 419A000C  beq cr6, 0x82619368
	if ctx.cr[6].eq {
	pc = 0x82619368; continue 'dispatch;
	}
	// 82619360: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82619364: 48CA05F1  bl 0x832b9954
	ctx.lr = 0x82619368;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x82619368; continue 'dispatch;
            }
            0x82619368 => {
    //   block [0x82619368..0x8261936C)
	// 82619368: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	pc = 0x8261936C; continue 'dispatch;
            }
            0x8261936C => {
    //   block [0x8261936C..0x82619390)
	// 8261936C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619370: 48CA05F5  bl 0x832b9964
	ctx.lr = 0x82619374;
	// extern call 0x832B9964  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82619374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619378: 8BDD6C9F  lbz r30, 0x6c9f(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(27807 as u32) ) } as u64;
	// 8261937C: 48CA05D9  bl 0x832b9954
	ctx.lr = 0x82619380;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82619380: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82619384: 419AFFE8  beq cr6, 0x8261936c
	if ctx.cr[6].eq {
	pc = 0x8261936C; continue 'dispatch;
	}
	// 82619388: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8261938C: 917C6CB0  stw r11, 0x6cb0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(27824 as u32), ctx.r[11].u32 ) };
	pc = 0x82619390; continue 'dispatch;
            }
            0x82619390 => {
    //   block [0x82619390..0x826193A4)
	// 82619390: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82619394: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82619398: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8261939C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826193A0: 486900B4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826193A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826193A8 size=160
    let mut pc: u32 = 0x826193A8;
    'dispatch: loop {
        match pc {
            0x826193A8 => {
    //   block [0x826193A8..0x826193C0)
	// 826193A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826193AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826193B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826193B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826193B8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 826193BC: 409A001C  bne cr6, 0x826193d8
	if !ctx.cr[6].eq {
	pc = 0x826193D8; continue 'dispatch;
	}
	pc = 0x826193C0; continue 'dispatch;
            }
            0x826193C0 => {
    //   block [0x826193C0..0x826193D8)
	// 826193C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826193C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826193C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826193CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826193D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826193D4: 4E800020  blr
	return;
            }
            0x826193D8 => {
    //   block [0x826193D8..0x8261941C)
	// 826193D8: 4886BFD1  bl 0x82e853a8
	ctx.lr = 0x826193DC;
	sub_82E853A8(ctx, base);
	// 826193DC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 826193E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826193E4: 419AFFDC  beq cr6, 0x826193c0
	if ctx.cr[6].eq {
	pc = 0x826193C0; continue 'dispatch;
	}
	// 826193E8: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 826193EC: 817F6CC0  lwz r11, 0x6cc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27840 as u32) ) } as u64;
	// 826193F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826193F4: 409AFFCC  bne cr6, 0x826193c0
	if !ctx.cr[6].eq {
	pc = 0x826193C0; continue 'dispatch;
	}
	// 826193F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 826193FC: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82619400: 6149FFFF  ori r9, r10, 0xffff
	ctx.r[9].u64 = ctx.r[10].u64 | 65535;
	// 82619404: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82619408: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8261940C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82619410: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82619414: 40990008  ble cr6, 0x8261941c
	if !ctx.cr[6].gt {
	pc = 0x8261941C; continue 'dispatch;
	}
	// 82619418: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x8261941C; continue 'dispatch;
            }
            0x8261941C => {
    //   block [0x8261941C..0x82619448)
	// 8261941C: 4BFFD50D  bl 0x82616928
	ctx.lr = 0x82619420;
	sub_82616928(ctx, base);
	// 82619420: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82619424: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82619428: 907F6CC0  stw r3, 0x6cc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(27840 as u32), ctx.r[3].u32 ) };
	// 8261942C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82619430: 916A6CC4  stw r11, 0x6cc4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(27844 as u32), ctx.r[11].u32 ) };
	// 82619434: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82619438: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261943C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82619440: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82619444: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82619448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82619448 size=132
    let mut pc: u32 = 0x82619448;
    'dispatch: loop {
        match pc {
            0x82619448 => {
    //   block [0x82619448..0x82619474)
	// 82619448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261944C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82619450: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82619454: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82619458: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261945C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82619460: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82619464: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82619468: 409A000C  bne cr6, 0x82619474
	if !ctx.cr[6].eq {
	pc = 0x82619474; continue 'dispatch;
	}
	// 8261946C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82619470: 48000044  b 0x826194b4
	pc = 0x826194B4; continue 'dispatch;
            }
            0x82619474 => {
    //   block [0x82619474..0x826194A8)
	// 82619474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619478: 48BA2BE9  bl 0x831bc060
	ctx.lr = 0x8261947C;
	sub_831BC060(ctx, base);
	// 8261947C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82619480: 419A0028  beq cr6, 0x826194a8
	if ctx.cr[6].eq {
	pc = 0x826194A8; continue 'dispatch;
	}
	// 82619484: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82619488: 388B8504  addi r4, r11, -0x7afc
	ctx.r[4].s64 = ctx.r[11].s64 + -31484;
	// 8261948C: 486936C5  bl 0x82cacb50
	ctx.lr = 0x82619490;
	sub_82CACB50(ctx, base);
	// 82619490: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82619494: 409A0014  bne cr6, 0x826194a8
	if !ctx.cr[6].eq {
	pc = 0x826194A8; continue 'dispatch;
	}
	// 82619498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261949C: 482F486D  bl 0x8290dd08
	ctx.lr = 0x826194A0;
	sub_8290DD08(ctx, base);
	// 826194A0: 48690F21  bl 0x82caa3c0
	ctx.lr = 0x826194A4;
	sub_82CAA3C0(ctx, base);
	// 826194A4: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	pc = 0x826194A8; continue 'dispatch;
            }
            0x826194A8 => {
    //   block [0x826194A8..0x826194B4)
	// 826194A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826194AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826194B0: 48000189  bl 0x82619638
	ctx.lr = 0x826194B4;
	sub_82619638(ctx, base);
	pc = 0x826194B4; continue 'dispatch;
            }
            0x826194B4 => {
    //   block [0x826194B4..0x826194CC)
	// 826194B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826194B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826194BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826194C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826194C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826194C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826194D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826194D0 size=156
    let mut pc: u32 = 0x826194D0;
    'dispatch: loop {
        match pc {
            0x826194D0 => {
    //   block [0x826194D0..0x826194F8)
	// 826194D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826194D4: 4868FF2D  bl 0x82ca9400
	ctx.lr = 0x826194D8;
	sub_82CA93D0(ctx, base);
	// 826194D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826194DC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 826194E0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 826194E4: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 826194E8: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 826194EC: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 826194F0: 3BEA8D30  addi r31, r10, -0x72d0
	ctx.r[31].s64 = ctx.r[10].s64 + -29392;
	// 826194F4: 3BAB6CB4  addi r29, r11, 0x6cb4
	ctx.r[29].s64 = ctx.r[11].s64 + 27828;
	pc = 0x826194F8; continue 'dispatch;
            }
            0x826194F8 => {
    //   block [0x826194F8..0x82619564)
	// 826194F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826194FC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82619500: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82619504: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82619508: 4BB60E09  bl 0x8217a310
	ctx.lr = 0x8261950C;
	sub_8217A310(ctx, base);
	// 8261950C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619510: 48CA0455  bl 0x832b9964
	ctx.lr = 0x82619514;
	// extern call 0x832B9964  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82619514: 4800005D  bl 0x82619570
	ctx.lr = 0x82619518;
	sub_82619570(ctx, base);
	// 82619518: 807B6CB8  lwz r3, 0x6cb8(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27832 as u32) ) } as u64;
	// 8261951C: 4BCAFE6D  bl 0x822c9388
	ctx.lr = 0x82619520;
	sub_822C9388(ctx, base);
	// 82619520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619524: 8BDC6CBC  lbz r30, 0x6cbc(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(27836 as u32) ) } as u64;
	// 82619528: 48CA042D  bl 0x832b9954
	ctx.lr = 0x8261952C;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 8261952C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82619530: 419AFFC8  beq cr6, 0x826194f8
	if ctx.cr[6].eq {
	pc = 0x826194F8; continue 'dispatch;
	}
	// 82619534: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82619538: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8261953C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82619540: 4BBE7231  bl 0x82200770
	ctx.lr = 0x82619544;
	sub_82200770(ctx, base);
	// 82619544: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82619548: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261954C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82619550: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82619554: 996A6C9F  stb r11, 0x6c9f(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(27807 as u32), ctx.r[11].u8 ) };
	// 82619558: 419A000C  beq cr6, 0x82619564
	if ctx.cr[6].eq {
	pc = 0x82619564; continue 'dispatch;
	}
	// 8261955C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82619560: 48CA03F5  bl 0x832b9954
	ctx.lr = 0x82619564;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x82619564; continue 'dispatch;
            }
            0x82619564 => {
    //   block [0x82619564..0x8261956C)
	// 82619564: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82619568: 486ADA19  bl 0x82cc6f80
	ctx.lr = 0x8261956C;
	sub_82CC6F80(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82619570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82619570 size=196
    let mut pc: u32 = 0x82619570;
    'dispatch: loop {
        match pc {
            0x82619570 => {
    //   block [0x82619570..0x8261959C)
	// 82619570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82619574: 4868FE91  bl 0x82ca9404
	ctx.lr = 0x82619578;
	sub_82CA93D0(ctx, base);
	// 82619578: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261957C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82619580: 3B6BDAC0  addi r27, r11, -0x2540
	ctx.r[27].s64 = ctx.r[11].s64 + -9536;
	// 82619584: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82619588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261958C: 419A0010  beq cr6, 0x8261959c
	if ctx.cr[6].eq {
	pc = 0x8261959C; continue 'dispatch;
	}
	// 82619590: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82619594: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82619598: 4E800421  bctrl
	ctx.lr = 0x8261959C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8261959C => {
    //   block [0x8261959C..0x826195B8)
	// 8261959C: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 826195A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826195A4: 817D6CC4  lwz r11, 0x6cc4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27844 as u32) ) } as u64;
	// 826195A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826195AC: 419A0038  beq cr6, 0x826195e4
	if ctx.cr[6].eq {
	pc = 0x826195E4; continue 'dispatch;
	}
	// 826195B0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826195B4: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	pc = 0x826195B8; continue 'dispatch;
            }
            0x826195B8 => {
    //   block [0x826195B8..0x826195E4)
	// 826195B8: 817C6CC0  lwz r11, 0x6cc0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27840 as u32) ) } as u64;
	// 826195BC: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826195C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826195C4: 814B0094  lwz r10, 0x94(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 826195C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 826195CC: 4E800421  bctrl
	ctx.lr = 0x826195D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826195D0: 817D6CC4  lwz r11, 0x6cc4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27844 as u32) ) } as u64;
	// 826195D4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 826195D8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 826195DC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826195E0: 4198FFD8  blt cr6, 0x826195b8
	if ctx.cr[6].lt {
	pc = 0x826195B8; continue 'dispatch;
	}
            }
            0x826195E4 => {
    //   block [0x826195E4..0x82619614)
	// 826195E4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 826195E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826195EC: 419A0028  beq cr6, 0x82619614
	if ctx.cr[6].eq {
	pc = 0x82619614; continue 'dispatch;
	}
	// 826195F0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826195F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826195F8: 4E800421  bctrl
	ctx.lr = 0x826195FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826195FC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82619600: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82619604: 917D6CC4  stw r11, 0x6cc4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(27844 as u32), ctx.r[11].u32 ) };
	// 82619608: D02A6CAC  stfs f1, 0x6cac(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(27820 as u32), tmp.u32 ) };
	// 8261960C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82619610: 4868FE44  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82619614 => {
    //   block [0x82619614..0x82619634)
	// 82619614: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82619618: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 8261961C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82619620: 917D6CC4  stw r11, 0x6cc4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(27844 as u32), ctx.r[11].u32 ) };
	// 82619624: C00A9484  lfs f0, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82619628: D0096CAC  stfs f0, 0x6cac(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(27820 as u32), tmp.u32 ) };
	// 8261962C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82619630: 4868FE24  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82619638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82619638 size=92
    let mut pc: u32 = 0x82619638;
    'dispatch: loop {
        match pc {
            0x82619638 => {
    //   block [0x82619638..0x8261967C)
	// 82619638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261963C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82619640: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82619644: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82619648: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8261964C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82619650: 419A002C  beq cr6, 0x8261967c
	if ctx.cr[6].eq {
	pc = 0x8261967C; continue 'dispatch;
	}
	// 82619654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619658: 48BA2A09  bl 0x831bc060
	ctx.lr = 0x8261965C;
	sub_831BC060(ctx, base);
	// 8261965C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82619660: 419A001C  beq cr6, 0x8261967c
	if ctx.cr[6].eq {
	pc = 0x8261967C; continue 'dispatch;
	}
	// 82619664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619668: 48BA29F9  bl 0x831bc060
	ctx.lr = 0x8261966C;
	sub_831BC060(ctx, base);
	// 8261966C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82619670: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82619674: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82619678: 419A0008  beq cr6, 0x82619680
	if ctx.cr[6].eq {
	pc = 0x82619680; continue 'dispatch;
	}
	pc = 0x8261967C; continue 'dispatch;
            }
            0x8261967C => {
    //   block [0x8261967C..0x82619680)
	// 8261967C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82619680; continue 'dispatch;
            }
            0x82619680 => {
    //   block [0x82619680..0x82619694)
	// 82619680: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82619684: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82619688: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261968C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82619690: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82619698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82619698 size=12
    let mut pc: u32 = 0x82619698;
    'dispatch: loop {
        match pc {
            0x82619698 => {
    //   block [0x82619698..0x826196A4)
	// 82619698: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261969C: 386B8F74  addi r3, r11, -0x708c
	ctx.r[3].s64 = ctx.r[11].s64 + -28812;
	// 826196A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826196A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826196A8 size=12
    let mut pc: u32 = 0x826196A8;
    'dispatch: loop {
        match pc {
            0x826196A8 => {
    //   block [0x826196A8..0x826196B4)
	// 826196A8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 826196AC: 386B9088  addi r3, r11, -0x6f78
	ctx.r[3].s64 = ctx.r[11].s64 + -28536;
	// 826196B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826196B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826196B8 size=88
    let mut pc: u32 = 0x826196B8;
    'dispatch: loop {
        match pc {
            0x826196B8 => {
    //   block [0x826196B8..0x826196F4)
	// 826196B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826196BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826196C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826196C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826196C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826196CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826196D0: 38600088  li r3, 0x88
	ctx.r[3].s64 = 136;
	// 826196D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826196D8: 4BFFD251  bl 0x82616928
	ctx.lr = 0x826196DC;
	sub_82616928(ctx, base);
	// 826196DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826196E0: 419A0014  beq cr6, 0x826196f4
	if ctx.cr[6].eq {
	pc = 0x826196F4; continue 'dispatch;
	}
	// 826196E4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826196E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826196EC: 4800007D  bl 0x82619768
	ctx.lr = 0x826196F0;
	sub_82619768(ctx, base);
	// 826196F0: 48000008  b 0x826196f8
	pc = 0x826196F8; continue 'dispatch;
            }
            0x826196F4 => {
    //   block [0x826196F4..0x826196F8)
	// 826196F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x826196F8; continue 'dispatch;
            }
            0x826196F8 => {
    //   block [0x826196F8..0x82619710)
	// 826196F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826196FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82619700: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82619704: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82619708: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261970C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82619710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82619710 size=88
    let mut pc: u32 = 0x82619710;
    'dispatch: loop {
        match pc {
            0x82619710 => {
    //   block [0x82619710..0x8261974C)
	// 82619710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82619714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82619718: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8261971C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82619720: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82619724: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82619728: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 8261972C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82619730: 4BFFD1F9  bl 0x82616928
	ctx.lr = 0x82619734;
	sub_82616928(ctx, base);
	// 82619734: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82619738: 419A0014  beq cr6, 0x8261974c
	if ctx.cr[6].eq {
	pc = 0x8261974C; continue 'dispatch;
	}
	// 8261973C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82619740: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82619744: 480002E5  bl 0x82619a28
	ctx.lr = 0x82619748;
	sub_82619A28(ctx, base);
	// 82619748: 48000008  b 0x82619750
	pc = 0x82619750; continue 'dispatch;
            }
            0x8261974C => {
    //   block [0x8261974C..0x82619750)
	// 8261974C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82619750; continue 'dispatch;
            }
            0x82619750 => {
    //   block [0x82619750..0x82619768)
	// 82619750: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82619754: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82619758: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261975C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82619760: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82619764: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82619768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82619768 size=612
    let mut pc: u32 = 0x82619768;
    'dispatch: loop {
        match pc {
            0x82619768 => {
    //   block [0x82619768..0x82619820)
	// 82619768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261976C: 4868FC9D  bl 0x82ca9408
	ctx.lr = 0x82619770;
	sub_82CA93D0(ctx, base);
	// 82619770: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82619774: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82619778: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8261977C: 48865AAD  bl 0x82e7f228
	ctx.lr = 0x82619780;
	sub_82E7F228(ctx, base);
	// 82619780: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82619784: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82619788: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8261978C: 392B8570  addi r9, r11, -0x7a90
	ctx.r[9].s64 = ctx.r[11].s64 + -31376;
	// 82619790: 390A0B7C  addi r8, r10, 0xb7c
	ctx.r[8].s64 = ctx.r[10].s64 + 2940;
	// 82619794: 9BBE0070  stb r29, 0x70(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[29].u8 ) };
	// 82619798: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8261979C: 3BFE0074  addi r31, r30, 0x74
	ctx.r[31].s64 = ctx.r[30].s64 + 116;
	// 826197A0: 911E0074  stw r8, 0x74(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), ctx.r[8].u32 ) };
	// 826197A4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826197A8: 93BE0078  stw r29, 0x78(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 826197AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826197B0: 4BBFB0E9  bl 0x82214898
	ctx.lr = 0x826197B4;
	sub_82214898(ctx, base);
	// 826197B4: 9BBE0084  stb r29, 0x84(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[29].u8 ) };
	// 826197B8: 3CE08334  lis r7, -0x7ccc
	ctx.r[7].s64 = -2093744128;
	// 826197BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826197C0: 3887C5C8  addi r4, r7, -0x3a38
	ctx.r[4].s64 = ctx.r[7].s64 + -14904;
	// 826197C4: 4886535D  bl 0x82e7eb20
	ctx.lr = 0x826197C8;
	sub_82E7EB20(ctx, base);
	// 826197C8: 907E007C  stw r3, 0x7c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 826197CC: 3CC08334  lis r6, -0x7ccc
	ctx.r[6].s64 = -2093744128;
	// 826197D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826197D4: 3886C178  addi r4, r6, -0x3e88
	ctx.r[4].s64 = ctx.r[6].s64 + -16008;
	// 826197D8: 48865349  bl 0x82e7eb20
	ctx.lr = 0x826197DC;
	sub_82E7EB20(ctx, base);
	// 826197DC: 907E0080  stw r3, 0x80(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 826197E0: 817E0078  lwz r11, 0x78(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) } as u64;
	// 826197E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826197E8: 419A0038  beq cr6, 0x82619820
	if ctx.cr[6].eq {
	pc = 0x82619820; continue 'dispatch;
	}
	// 826197EC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826197F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826197F4: 419A007C  beq cr6, 0x82619870
	if ctx.cr[6].eq {
	pc = 0x82619870; continue 'dispatch;
	}
	// 826197F8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826197FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82619800: 419A0020  beq cr6, 0x82619820
	if ctx.cr[6].eq {
	pc = 0x82619820; continue 'dispatch;
	}
	// 82619804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619808: 4BB5A631  bl 0x82173e38
	ctx.lr = 0x8261980C;
	sub_82173E38(ctx, base);
	// 8261980C: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 82619810: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82619814: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82619818: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261981C: 409A0008  bne cr6, 0x82619824
	if !ctx.cr[6].eq {
	pc = 0x82619824; continue 'dispatch;
	}
	pc = 0x82619820; continue 'dispatch;
            }
            0x82619820 => {
    //   block [0x82619820..0x82619824)
	// 82619820: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82619824; continue 'dispatch;
            }
            0x82619824 => {
    //   block [0x82619824..0x82619870)
	// 82619824: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82619828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261982C: 419A017C  beq cr6, 0x826199a8
	if ctx.cr[6].eq {
	pc = 0x826199A8; continue 'dispatch;
	}
	// 82619830: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619834: 4BB5A605  bl 0x82173e38
	ctx.lr = 0x82619838;
	sub_82173E38(ctx, base);
	// 82619838: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261983C: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 82619840: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82619844: 419A00F4  beq cr6, 0x82619938
	if ctx.cr[6].eq {
	pc = 0x82619938; continue 'dispatch;
	}
	// 82619848: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261984C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82619850: 419A002C  beq cr6, 0x8261987c
	if ctx.cr[6].eq {
	pc = 0x8261987C; continue 'dispatch;
	}
	// 82619854: 894B003B  lbz r10, 0x3b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(59 as u32) ) } as u64;
	// 82619858: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261985C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82619860: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82619864: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82619868: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261986C: 480000D4  b 0x82619940
	pc = 0x82619940; continue 'dispatch;
            }
            0x82619870 => {
    //   block [0x82619870..0x8261987C)
	// 82619870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619874: 4BB7A5C5  bl 0x82193e38
	ctx.lr = 0x82619878;
	sub_82193E38(ctx, base);
	// 82619878: 4BFFFFA8  b 0x82619820
	pc = 0x82619820; continue 'dispatch;
            }
            0x8261987C => {
    //   block [0x8261987C..0x82619898)
	// 8261987C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82619880: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 82619884: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82619888: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8261988C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82619890: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82619894: 40810054  ble 0x826198e8
	if !ctx.cr[0].gt {
	pc = 0x826198E8; continue 'dispatch;
	}
	pc = 0x82619898; continue 'dispatch;
            }
            0x82619898 => {
    //   block [0x82619898..0x826198B8)
	// 82619898: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261989C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 826198A0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 826198A4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 826198A8: 2F07003B  cmpwi cr6, r7, 0x3b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 59, &mut ctx.xer);
	// 826198AC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826198B0: 41980008  blt cr6, 0x826198b8
	if ctx.cr[6].lt {
	pc = 0x826198B8; continue 'dispatch;
	}
	// 826198B4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x826198B8; continue 'dispatch;
            }
            0x826198B8 => {
    //   block [0x826198B8..0x826198D4)
	// 826198B8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 826198BC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 826198C0: 419A0014  beq cr6, 0x826198d4
	if ctx.cr[6].eq {
	pc = 0x826198D4; continue 'dispatch;
	}
	// 826198C4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 826198C8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826198CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 826198D0: 4800000C  b 0x826198dc
	pc = 0x826198DC; continue 'dispatch;
            }
            0x826198D4 => {
    //   block [0x826198D4..0x826198DC)
	// 826198D4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 826198D8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x826198DC; continue 'dispatch;
            }
            0x826198DC => {
    //   block [0x826198DC..0x826198E8)
	// 826198DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826198E0: 4199FFB8  bgt cr6, 0x82619898
	if ctx.cr[6].gt {
	pc = 0x82619898; continue 'dispatch;
	}
	// 826198E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x826198E8; continue 'dispatch;
            }
            0x826198E8 => {
    //   block [0x826198E8..0x82619904)
	// 826198E8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 826198EC: 419A003C  beq cr6, 0x82619928
	if ctx.cr[6].eq {
	pc = 0x82619928; continue 'dispatch;
	}
	// 826198F0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 826198F4: 2F0B003B  cmpwi cr6, r11, 0x3b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 59, &mut ctx.xer);
	// 826198F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826198FC: 41990008  bgt cr6, 0x82619904
	if ctx.cr[6].gt {
	pc = 0x82619904; continue 'dispatch;
	}
	// 82619900: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82619904; continue 'dispatch;
            }
            0x82619904 => {
    //   block [0x82619904..0x82619928)
	// 82619904: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82619908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261990C: 409A001C  bne cr6, 0x82619928
	if !ctx.cr[6].eq {
	pc = 0x82619928; continue 'dispatch;
	}
	// 82619910: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82619914: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82619918: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8261991C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82619920: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82619924: 4800001C  b 0x82619940
	pc = 0x82619940; continue 'dispatch;
            }
            0x82619928 => {
    //   block [0x82619928..0x82619938)
	// 82619928: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8261992C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82619930: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82619934: 4800000C  b 0x82619940
	pc = 0x82619940; continue 'dispatch;
            }
            0x82619938 => {
    //   block [0x82619938..0x82619940)
	// 82619938: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261993C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x82619940; continue 'dispatch;
            }
            0x82619940 => {
    //   block [0x82619940..0x82619960)
	// 82619940: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82619944: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82619948: 419A0078  beq cr6, 0x826199c0
	if ctx.cr[6].eq {
	pc = 0x826199C0; continue 'dispatch;
	}
	// 8261994C: 815E007C  lwz r10, 0x7c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 82619950: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82619954: C1AB0014  lfs f13, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82619958: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8261995C: C1899484  lfs f12, -0x6b7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82619960; continue 'dispatch;
            }
            0x82619960 => {
    //   block [0x82619960..0x8261996C)
	// 82619960: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82619964: 41980008  blt cr6, 0x8261996c
	if ctx.cr[6].lt {
	pc = 0x8261996C; continue 'dispatch;
	}
	// 82619968: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x8261996C; continue 'dispatch;
            }
            0x8261996C => {
    //   block [0x8261996C..0x82619984)
	// 8261996C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82619970: 409AFFF0  bne cr6, 0x82619960
	if !ctx.cr[6].eq {
	pc = 0x82619960; continue 'dispatch;
	}
	// 82619974: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82619978: 815E0080  lwz r10, 0x80(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 8261997C: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82619980: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82619984; continue 'dispatch;
            }
            0x82619984 => {
    //   block [0x82619984..0x82619990)
	// 82619984: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82619988: 41980008  blt cr6, 0x82619990
	if ctx.cr[6].lt {
	pc = 0x82619990; continue 'dispatch;
	}
	// 8261998C: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82619990; continue 'dispatch;
            }
            0x82619990 => {
    //   block [0x82619990..0x826199A8)
	// 82619990: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82619994: 409AFFF0  bne cr6, 0x82619984
	if !ctx.cr[6].eq {
	pc = 0x82619984; continue 'dispatch;
	}
	// 82619998: D1AA0004  stfs f13, 4(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8261999C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826199A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826199A4: 4868FAB4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x826199A8 => {
    //   block [0x826199A8..0x826199C0)
	// 826199A8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 826199AC: 815E007C  lwz r10, 0x7c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 826199B0: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826199B4: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 826199B8: 813E0080  lwz r9, 0x80(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 826199BC: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x826199C0; continue 'dispatch;
            }
            0x826199C0 => {
    //   block [0x826199C0..0x826199CC)
	// 826199C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826199C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826199C8: 4868FA90  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826199D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826199D0 size=84
    let mut pc: u32 = 0x826199D0;
    'dispatch: loop {
        match pc {
            0x826199D0 => {
    //   block [0x826199D0..0x82619A0C)
	// 826199D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826199D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826199D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826199DC: 38630074  addi r3, r3, 0x74
	ctx.r[3].s64 = ctx.r[3].s64 + 116;
	// 826199E0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826199E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826199E8: 419A0028  beq cr6, 0x82619a10
	if ctx.cr[6].eq {
	pc = 0x82619A10; continue 'dispatch;
	}
	// 826199EC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826199F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826199F4: 419A0018  beq cr6, 0x82619a0c
	if ctx.cr[6].eq {
	pc = 0x82619A0C; continue 'dispatch;
	}
	// 826199F8: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 826199FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82619A00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82619A04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82619A08: 4E800020  blr
	return;
            }
            0x82619A0C => {
    //   block [0x82619A0C..0x82619A10)
	// 82619A0C: 4BB7A42D  bl 0x82193e38
	ctx.lr = 0x82619A10;
	sub_82193E38(ctx, base);
	pc = 0x82619A10; continue 'dispatch;
            }
            0x82619A10 => {
    //   block [0x82619A10..0x82619A24)
	// 82619A10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82619A14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82619A18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82619A1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82619A20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82619A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82619A28 size=648
    let mut pc: u32 = 0x82619A28;
    'dispatch: loop {
        match pc {
            0x82619A28 => {
    //   block [0x82619A28..0x82619CA8)
	// 82619A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82619A2C: 4868F9D9  bl 0x82ca9404
	ctx.lr = 0x82619A30;
	sub_82CA93D0(ctx, base);
	// 82619A30: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82619A34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82619A38: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82619A3C: 4BFFFD2D  bl 0x82619768
	ctx.lr = 0x82619A40;
	sub_82619768(ctx, base);
	// 82619A40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82619A44: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82619A48: 394B2230  addi r10, r11, 0x2230
	ctx.r[10].s64 = ctx.r[11].s64 + 8752;
	// 82619A4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82619A50: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82619A54: 419A0254  beq cr6, 0x82619ca8
	if ctx.cr[6].eq {
	pc = 0x82619CA8; continue 'dispatch;
	}
	// 82619A58: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82619A5C: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82619A60: 488650C1  bl 0x82e7eb20
	ctx.lr = 0x82619A64;
	sub_82E7EB20(ctx, base);
	// 82619A64: 3F80820A  lis r28, -0x7df6
	ctx.r[28].s64 = -2113273856;
	// 82619A68: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82619A6C: 3B7CB47C  addi r27, r28, -0x4b84
	ctx.r[27].s64 = ctx.r[28].s64 + -19332;
	// 82619A70: 915E0088  stw r10, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 82619A74: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82619A78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82619A7C: 3889C064  addi r4, r9, -0x3f9c
	ctx.r[4].s64 = ctx.r[9].s64 + -16284;
	// 82619A80: C01B07EC  lfs f0, 0x7ec(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(2028 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82619A84: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82619A88: 48865099  bl 0x82e7eb20
	ctx.lr = 0x82619A8C;
	sub_82E7EB20(ctx, base);
	// 82619A8C: 907E008C  stw r3, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 82619A90: 3BBE0074  addi r29, r30, 0x74
	ctx.r[29].s64 = ctx.r[30].s64 + 116;
	// 82619A94: 817E0080  lwz r11, 0x80(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 82619A98: C01BE008  lfs f0, -0x1ff8(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82619A9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82619AA0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82619AA4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82619AA8: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 82619AAC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82619AB0: 4BB5A389  bl 0x82173e38
	ctx.lr = 0x82619AB4;
	sub_82173E38(ctx, base);
	// 82619AB4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82619AB8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82619ABC: 8088007C  lwz r4, 0x7c(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(124 as u32) ) } as u64;
	// 82619AC0: 80E40000  lwz r7, 0(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82619AC4: 80C70040  lwz r6, 0x40(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(64 as u32) ) } as u64;
	// 82619AC8: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82619ACC: 4E800421  bctrl
	ctx.lr = 0x82619AD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82619AD0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82619AD4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
            }
            0x82619CA8 => {
    //   block [0x82619CA8..0x82619CB0)
	// 82619CA8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82619CAC: 4868F7A8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82619CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82619CB0 size=12
    let mut pc: u32 = 0x82619CB0;
    'dispatch: loop {
        match pc {
            0x82619CB0 => {
    //   block [0x82619CB0..0x82619CBC)
	// 82619CB0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82619CB4: 386B919C  addi r3, r11, -0x6e64
	ctx.r[3].s64 = ctx.r[11].s64 + -28260;
	// 82619CB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82619CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82619CC0 size=88
    let mut pc: u32 = 0x82619CC0;
    'dispatch: loop {
        match pc {
            0x82619CC0 => {
    //   block [0x82619CC0..0x82619CFC)
	// 82619CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82619CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82619CC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82619CCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82619CD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82619CD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82619CD8: 38600088  li r3, 0x88
	ctx.r[3].s64 = 136;
	// 82619CDC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82619CE0: 4BFFCC49  bl 0x82616928
	ctx.lr = 0x82619CE4;
	sub_82616928(ctx, base);
	// 82619CE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82619CE8: 419A0014  beq cr6, 0x82619cfc
	if ctx.cr[6].eq {
	pc = 0x82619CFC; continue 'dispatch;
	}
	// 82619CEC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82619CF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82619CF4: 48000025  bl 0x82619d18
	ctx.lr = 0x82619CF8;
	sub_82619D18(ctx, base);
	// 82619CF8: 48000008  b 0x82619d00
	pc = 0x82619D00; continue 'dispatch;
            }
            0x82619CFC => {
    //   block [0x82619CFC..0x82619D00)
	// 82619CFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82619D00; continue 'dispatch;
            }
            0x82619D00 => {
    //   block [0x82619D00..0x82619D18)
	// 82619D00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82619D04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82619D08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82619D0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82619D10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82619D14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82619D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82619D18 size=112
    let mut pc: u32 = 0x82619D18;
    'dispatch: loop {
        match pc {
            0x82619D18 => {
    //   block [0x82619D18..0x82619D68)
	// 82619D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82619D1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82619D20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82619D24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82619D28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82619D2C: 4BFFFA3D  bl 0x82619768
	ctx.lr = 0x82619D30;
	sub_82619768(ctx, base);
	// 82619D30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82619D34: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82619D38: 394B2034  addi r10, r11, 0x2034
	ctx.r[10].s64 = ctx.r[11].s64 + 8244;
	// 82619D3C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82619D40: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82619D44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82619D48: 419A0020  beq cr6, 0x82619d68
	if ctx.cr[6].eq {
	pc = 0x82619D68; continue 'dispatch;
	}
	// 82619D4C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82619D50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82619D54: 419A002C  beq cr6, 0x82619d80
	if ctx.cr[6].eq {
	pc = 0x82619D80; continue 'dispatch;
	}
	// 82619D58: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82619D5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82619D60: 419A0008  beq cr6, 0x82619d68
	if ctx.cr[6].eq {
	pc = 0x82619D68; continue 'dispatch;
	}
	// 82619D64: 4BB5A0D5  bl 0x82173e38
	ctx.lr = 0x82619D68;
	sub_82173E38(ctx, base);
	pc = 0x82619D68; continue 'dispatch;
            }
            0x82619D68 => {
    //   block [0x82619D68..0x82619D80)
	// 82619D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619D6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82619D70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82619D74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82619D78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82619D7C: 4E800020  blr
	return;
            }
            0x82619D80 => {
    //   block [0x82619D80..0x82619D88)
	// 82619D80: 4BB7A0B9  bl 0x82193e38
	ctx.lr = 0x82619D84;
	sub_82193E38(ctx, base);
	// 82619D84: 4BFFFFE4  b 0x82619d68
	pc = 0x82619D68; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82619D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82619D88 size=284
    let mut pc: u32 = 0x82619D88;
    'dispatch: loop {
        match pc {
            0x82619D88 => {
    //   block [0x82619D88..0x82619DC0)
	// 82619D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82619D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82619D90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82619D94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82619D98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82619D9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82619DA0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82619DA4: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82619DA8: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82619DAC: 39097088  addi r8, r9, 0x7088
	ctx.r[8].s64 = ctx.r[9].s64 + 28808;
	// 82619DB0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82619DB4: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82619DB8: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82619DBC: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	pc = 0x82619DC0; continue 'dispatch;
            }
            0x82619DC0 => {
    //   block [0x82619DC0..0x82619DEC)
	// 82619DC0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82619DC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82619DC8: 7D604028  lwarx r11, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82619DCC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82619DD0: 7D60412D  stwcx. r11, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82619DD4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82619DD8: 4082FFE8  bne 0x82619dc0
	if !ctx.cr[0].eq {
	pc = 0x82619DC0; continue 'dispatch;
	}
	// 82619DDC: 80FF0010  lwz r7, 0x10(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82619DE0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82619DE4: 419A0008  beq cr6, 0x82619dec
	if ctx.cr[6].eq {
	pc = 0x82619DEC; continue 'dispatch;
	}
	// 82619DE8: 4BBAC981  bl 0x821c6768
	ctx.lr = 0x82619DEC;
	sub_821C6768(ctx, base);
	pc = 0x82619DEC; continue 'dispatch;
            }
            0x82619DEC => {
    //   block [0x82619DEC..0x82619EA4)
	// 82619DEC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82619DF0: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82619DF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82619DF8: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82619DFC: 392B9484  addi r9, r11, -0x6b7c
	ctx.r[9].s64 = ctx.r[11].s64 + -27516;
	// 82619E00: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82619E04: 390A0B7C  addi r8, r10, 0xb7c
	ctx.r[8].s64 = ctx.r[10].s64 + 2940;
	// 82619E08: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82619E0C: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 82619E10: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82619E14: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82619E18: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 82619E1C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82619E20: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82619E24: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82619E28: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82619E2C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82619E30: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82619E34: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82619E38: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82619E3C: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82619E40: C1A9FE50  lfs f13, -0x1b0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-432 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82619E44: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82619E48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82619E4C: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82619E50: 911F0048  stw r8, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[8].u32 ) };
	// 82619E54: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 82619E58: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82619E5C: 911F0050  stw r8, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82619E60: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82619E64: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82619E68: 98FF0058  stb r7, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[7].u8 ) };
	// 82619E6C: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82619E70: 9BDF0059  stb r30, 0x59(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(89 as u32), ctx.r[30].u8 ) };
	// 82619E74: 9BDF005A  stb r30, 0x5a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(90 as u32), ctx.r[30].u8 ) };
	// 82619E78: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82619E7C: 90DF002C  stw r6, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[6].u32 ) };
	// 82619E80: 909F0028  stw r4, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[4].u32 ) };
	// 82619E84: 90BF0030  stw r5, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[5].u32 ) };
	// 82619E88: F97F0020  std r11, 0x20(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 82619E8C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82619E90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82619E94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82619E98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82619E9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82619EA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82619EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82619EA8 size=420
    let mut pc: u32 = 0x82619EA8;
    'dispatch: loop {
        match pc {
            0x82619EA8 => {
    //   block [0x82619EA8..0x82619EDC)
	// 82619EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82619EAC: 4868F55D  bl 0x82ca9408
	ctx.lr = 0x82619EB0;
	sub_82CA93D0(ctx, base);
	// 82619EB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82619EB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82619EB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82619EBC: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 82619EC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82619EC4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82619EC8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82619ECC: 38E87088  addi r7, r8, 0x7088
	ctx.r[7].s64 = ctx.r[8].s64 + 28808;
	// 82619ED0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82619ED4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82619ED8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82619EDC; continue 'dispatch;
            }
            0x82619EDC => {
    //   block [0x82619EDC..0x8261A014)
	// 82619EDC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82619EE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82619EE4: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82619EE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82619EEC: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82619EF0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82619EF4: 4082FFE8  bne 0x82619edc
	if !ctx.cr[0].eq {
	pc = 0x82619EDC; continue 'dispatch;
	}
	// 82619EF8: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82619EFC: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82619F00: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82619F04: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 82619F08: 38A60B7C  addi r5, r6, 0xb7c
	ctx.r[5].s64 = ctx.r[6].s64 + 2940;
	// 82619F0C: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82619F10: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82619F14: 3BBF0048  addi r29, r31, 0x48
	ctx.r[29].s64 = ctx.r[31].s64 + 72;
	// 82619F18: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82619F1C: 3B9F0050  addi r28, r31, 0x50
	ctx.r[28].s64 = ctx.r[31].s64 + 80;
	// 82619F20: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82619F24: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82619F28: 90BF0048  stw r5, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[5].u32 ) };
	// 82619F2C: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82619F30: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 82619F34: 90BF0050  stw r5, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 82619F38: 397F0038  addi r11, r31, 0x38
	ctx.r[11].s64 = ctx.r[31].s64 + 56;
	// 82619F3C: 397F0040  addi r11, r31, 0x40
	ctx.r[11].s64 = ctx.r[31].s64 + 64;
	// 82619F40: 4BC4B261  bl 0x822651a0
	ctx.lr = 0x82619F44;
	sub_822651A0(ctx, base);
	// 82619F44: 809E0028  lwz r4, 0x28(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82619F48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82619F4C: 909F0028  stw r4, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[4].u32 ) };
	// 82619F50: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82619F54: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82619F58: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82619F5C: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 82619F60: 809E0020  lwz r4, 0x20(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82619F64: 4BBC03E5  bl 0x821da348
	ctx.lr = 0x82619F68;
	sub_821DA348(ctx, base);
	// 82619F68: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82619F6C: 389E0048  addi r4, r30, 0x48
	ctx.r[4].s64 = ctx.r[30].s64 + 72;
	// 82619F70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82619F74: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82619F78: 911F0020  stw r8, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 82619F7C: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82619F80: 90FF0024  stw r7, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[7].u32 ) };
	// 82619F84: 80DE0014  lwz r6, 0x14(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82619F88: 90DF0014  stw r6, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 82619F8C: 80BE0018  lwz r5, 0x18(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82619F90: 90BF0018  stw r5, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[5].u32 ) };
	// 82619F94: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82619F98: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82619F9C: 815E0038  lwz r10, 0x38(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82619FA0: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82619FA4: 813E003C  lwz r9, 0x3c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 82619FA8: 913F003C  stw r9, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 82619FAC: 4BEB7F1D  bl 0x824d1ec8
	ctx.lr = 0x82619FB0;
	sub_824D1EC8(ctx, base);
	// 82619FB0: 811E0040  lwz r8, 0x40(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82619FB4: 389E0050  addi r4, r30, 0x50
	ctx.r[4].s64 = ctx.r[30].s64 + 80;
	// 82619FB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82619FBC: 911F0040  stw r8, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[8].u32 ) };
	// 82619FC0: 80FE0044  lwz r7, 0x44(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 82619FC4: 90FF0044  stw r7, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[7].u32 ) };
	// 82619FC8: 4BEB7F01  bl 0x824d1ec8
	ctx.lr = 0x82619FCC;
	sub_824D1EC8(ctx, base);
	// 82619FCC: 88DE0058  lbz r6, 0x58(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82619FD0: 98DF0058  stb r6, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[6].u8 ) };
	// 82619FD4: 88BE005A  lbz r5, 0x5a(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(90 as u32) ) } as u64;
	// 82619FD8: 98BF005A  stb r5, 0x5a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(90 as u32), ctx.r[5].u8 ) };
	// 82619FDC: C01E005C  lfs f0, 0x5c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82619FE0: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82619FE4: C1BE0060  lfs f13, 0x60(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82619FE8: D1BF0060  stfs f13, 0x60(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82619FEC: 809E001C  lwz r4, 0x1c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82619FF0: 909F001C  stw r4, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82619FF4: C19E0064  lfs f12, 0x64(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82619FF8: D19F0064  stfs f12, 0x64(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82619FFC: 887E0059  lbz r3, 0x59(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(89 as u32) ) } as u64;
	// 8261A000: 987F0059  stb r3, 0x59(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(89 as u32), ctx.r[3].u8 ) };
	// 8261A004: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261A008: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261A00C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261A010: 419A0030  beq cr6, 0x8261a040
	if ctx.cr[6].eq {
	pc = 0x8261A040; continue 'dispatch;
	}
	pc = 0x8261A014; continue 'dispatch;
            }
            0x8261A014 => {
    //   block [0x8261A014..0x8261A040)
	// 8261A014: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A018: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8261A01C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8261A020: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8261A024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A028: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8261A02C: 48228035  bl 0x82842060
	ctx.lr = 0x8261A030;
	sub_82842060(ctx, base);
	// 8261A030: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261A034: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 8261A038: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261A03C: 409AFFD8  bne cr6, 0x8261a014
	if !ctx.cr[6].eq {
	pc = 0x8261A014; continue 'dispatch;
	}
	pc = 0x8261A040; continue 'dispatch;
            }
            0x8261A040 => {
    //   block [0x8261A040..0x8261A04C)
	// 8261A040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A044: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8261A048: 4868F410  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261A050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8261A050 size=1480
    let mut pc: u32 = 0x8261A050;
    'dispatch: loop {
        match pc {
            0x8261A050 => {
    //   block [0x8261A050..0x8261A0C8)
	// 8261A050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261A054: 4868F3A5  bl 0x82ca93f8
	ctx.lr = 0x8261A058;
	sub_82CA93D0(ctx, base);
	// 8261A058: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 8261A05C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261A060: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8261A064: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261A068: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8261A06C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 8261A070: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A074: 388B2DF8  addi r4, r11, 0x2df8
	ctx.r[4].s64 = ctx.r[11].s64 + 11768;
	// 8261A078: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A07C: 4BC12E55  bl 0x8222ced0
	ctx.lr = 0x8261A080;
	sub_8222CED0(ctx, base);
	// 8261A080: 38BE0010  addi r5, r30, 0x10
	ctx.r[5].s64 = ctx.r[30].s64 + 16;
	// 8261A084: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261A088: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A08C: 48402E5D  bl 0x82a1cee8
	ctx.lr = 0x8261A090;
	sub_82A1CEE8(ctx, base);
	// 8261A090: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A094: 4BBFAD45  bl 0x82214dd8
	ctx.lr = 0x8261A098;
	sub_82214DD8(ctx, base);
	// 8261A098: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261A09C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A0A0: 388A85A4  addi r4, r10, -0x7a5c
	ctx.r[4].s64 = ctx.r[10].s64 + -31324;
	// 8261A0A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A0A8: 4BC12E29  bl 0x8222ced0
	ctx.lr = 0x8261A0AC;
	sub_8222CED0(ctx, base);
	// 8261A0AC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8261A0B0: 3B4BFFDF  addi r26, r11, -0x21
	ctx.r[26].s64 = ctx.r[11].s64 + -33;
	// 8261A0B4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8261A0B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261A0BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261A0C0: 419A0008  beq cr6, 0x8261a0c8
	if ctx.cr[6].eq {
	pc = 0x8261A0C8; continue 'dispatch;
	}
	// 8261A0C4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261A0C8; continue 'dispatch;
            }
            0x8261A0C8 => {
    //   block [0x8261A0C8..0x8261A104)
	// 8261A0C8: 38BE0014  addi r5, r30, 0x14
	ctx.r[5].s64 = ctx.r[30].s64 + 20;
	// 8261A0CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A0D0: 4BE666F9  bl 0x824807c8
	ctx.lr = 0x8261A0D4;
	sub_824807C8(ctx, base);
	// 8261A0D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A0D8: 4BBFAD01  bl 0x82214dd8
	ctx.lr = 0x8261A0DC;
	sub_82214DD8(ctx, base);
	// 8261A0DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261A0E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A0E4: 388B85B4  addi r4, r11, -0x7a4c
	ctx.r[4].s64 = ctx.r[11].s64 + -31308;
	// 8261A0E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A0EC: 4BC12DE5  bl 0x8222ced0
	ctx.lr = 0x8261A0F0;
	sub_8222CED0(ctx, base);
	// 8261A0F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261A0F4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8261A0F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261A0FC: 419A0008  beq cr6, 0x8261a104
	if ctx.cr[6].eq {
	pc = 0x8261A104; continue 'dispatch;
	}
	// 8261A100: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261A104; continue 'dispatch;
            }
            0x8261A104 => {
    //   block [0x8261A104..0x8261A140)
	// 8261A104: 38BE0018  addi r5, r30, 0x18
	ctx.r[5].s64 = ctx.r[30].s64 + 24;
	// 8261A108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A10C: 4BE666BD  bl 0x824807c8
	ctx.lr = 0x8261A110;
	sub_824807C8(ctx, base);
	// 8261A110: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A114: 4BBFACC5  bl 0x82214dd8
	ctx.lr = 0x8261A118;
	sub_82214DD8(ctx, base);
	// 8261A118: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261A11C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A120: 388B85C0  addi r4, r11, -0x7a40
	ctx.r[4].s64 = ctx.r[11].s64 + -31296;
	// 8261A124: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A128: 4BC12DA9  bl 0x8222ced0
	ctx.lr = 0x8261A12C;
	sub_8222CED0(ctx, base);
	// 8261A12C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261A130: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8261A134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261A138: 419A0008  beq cr6, 0x8261a140
	if ctx.cr[6].eq {
	pc = 0x8261A140; continue 'dispatch;
	}
	// 8261A13C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261A140; continue 'dispatch;
            }
            0x8261A140 => {
    //   block [0x8261A140..0x8261A1B0)
	// 8261A140: 38BE001C  addi r5, r30, 0x1c
	ctx.r[5].s64 = ctx.r[30].s64 + 28;
	// 8261A144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A148: 4BE66681  bl 0x824807c8
	ctx.lr = 0x8261A14C;
	sub_824807C8(ctx, base);
	// 8261A14C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A150: 4BBFAC89  bl 0x82214dd8
	ctx.lr = 0x8261A154;
	sub_82214DD8(ctx, base);
	// 8261A154: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8261A158: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A15C: 388B9A3C  addi r4, r11, -0x65c4
	ctx.r[4].s64 = ctx.r[11].s64 + -26052;
	// 8261A160: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A164: 4BC12D6D  bl 0x8222ced0
	ctx.lr = 0x8261A168;
	sub_8222CED0(ctx, base);
	// 8261A168: 38BE0028  addi r5, r30, 0x28
	ctx.r[5].s64 = ctx.r[30].s64 + 40;
	// 8261A16C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261A170: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A174: 48402F35  bl 0x82a1d0a8
	ctx.lr = 0x8261A178;
	sub_82A1D0A8(ctx, base);
	// 8261A178: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A17C: 4BBFAC5D  bl 0x82214dd8
	ctx.lr = 0x8261A180;
	sub_82214DD8(ctx, base);
	// 8261A180: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261A184: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A188: 388A85D0  addi r4, r10, -0x7a30
	ctx.r[4].s64 = ctx.r[10].s64 + -31280;
	// 8261A18C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A190: 4BC12D41  bl 0x8222ced0
	ctx.lr = 0x8261A194;
	sub_8222CED0(ctx, base);
	// 8261A194: 813E0034  lwz r9, 0x34(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 8261A198: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261A19C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8261A1A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261A1A4: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 8261A1A8: 419A0008  beq cr6, 0x8261a1b0
	if ctx.cr[6].eq {
	pc = 0x8261A1B0; continue 'dispatch;
	}
	// 8261A1AC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261A1B0; continue 'dispatch;
            }
            0x8261A1B0 => {
    //   block [0x8261A1B0..0x8261A280)
	// 8261A1B0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8261A1B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A1B8: 4BE66611  bl 0x824807c8
	ctx.lr = 0x8261A1BC;
	sub_824807C8(ctx, base);
	// 8261A1BC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261A1C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A1C4: 917E0034  stw r11, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 8261A1C8: 4BBFAC11  bl 0x82214dd8
	ctx.lr = 0x8261A1CC;
	sub_82214DD8(ctx, base);
	// 8261A1CC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 8261A1D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A1D4: 388A1060  addi r4, r10, 0x1060
	ctx.r[4].s64 = ctx.r[10].s64 + 4192;
	// 8261A1D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A1DC: 4BC12CF5  bl 0x8222ced0
	ctx.lr = 0x8261A1E0;
	sub_8222CED0(ctx, base);
	// 8261A1E0: 3BBE0038  addi r29, r30, 0x38
	ctx.r[29].s64 = ctx.r[30].s64 + 56;
	// 8261A1E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8261A1E8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8261A1EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261A1F0: 4BE985C9  bl 0x824b27b8
	ctx.lr = 0x8261A1F4;
	sub_824B27B8(ctx, base);
	// 8261A1F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A1F8: 4BBFABE1  bl 0x82214dd8
	ctx.lr = 0x8261A1FC;
	sub_82214DD8(ctx, base);
	// 8261A1FC: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 8261A200: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A204: 3889106C  addi r4, r9, 0x106c
	ctx.r[4].s64 = ctx.r[9].s64 + 4204;
	// 8261A208: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A20C: 4BC12CC5  bl 0x8222ced0
	ctx.lr = 0x8261A210;
	sub_8222CED0(ctx, base);
	// 8261A210: 3B9E0040  addi r28, r30, 0x40
	ctx.r[28].s64 = ctx.r[30].s64 + 64;
	// 8261A214: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8261A218: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8261A21C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8261A220: 4BE98599  bl 0x824b27b8
	ctx.lr = 0x8261A224;
	sub_824B27B8(ctx, base);
	// 8261A224: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A228: 4BBFABB1  bl 0x82214dd8
	ctx.lr = 0x8261A22C;
	sub_82214DD8(ctx, base);
	// 8261A22C: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8261A230: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A234: 388885DC  addi r4, r8, -0x7a24
	ctx.r[4].s64 = ctx.r[8].s64 + -31268;
	// 8261A238: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A23C: 4BC12C95  bl 0x8222ced0
	ctx.lr = 0x8261A240;
	sub_8222CED0(ctx, base);
	// 8261A240: 38BE0058  addi r5, r30, 0x58
	ctx.r[5].s64 = ctx.r[30].s64 + 88;
	// 8261A244: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261A248: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A24C: 48402BFD  bl 0x82a1ce48
	ctx.lr = 0x8261A250;
	sub_82A1CE48(ctx, base);
	// 8261A250: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A254: 4BBFAB85  bl 0x82214dd8
	ctx.lr = 0x8261A258;
	sub_82214DD8(ctx, base);
	// 8261A258: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 8261A25C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A260: 388785F0  addi r4, r7, -0x7a10
	ctx.r[4].s64 = ctx.r[7].s64 + -31248;
	// 8261A264: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A268: 4BC12C69  bl 0x8222ced0
	ctx.lr = 0x8261A26C;
	sub_8222CED0(ctx, base);
	// 8261A26C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261A270: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8261A274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261A278: 419A0008  beq cr6, 0x8261a280
	if ctx.cr[6].eq {
	pc = 0x8261A280; continue 'dispatch;
	}
	// 8261A27C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261A280; continue 'dispatch;
            }
            0x8261A280 => {
    //   block [0x8261A280..0x8261A2BC)
	// 8261A280: 38BE005C  addi r5, r30, 0x5c
	ctx.r[5].s64 = ctx.r[30].s64 + 92;
	// 8261A284: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A288: 4BE665C9  bl 0x82480850
	ctx.lr = 0x8261A28C;
	sub_82480850(ctx, base);
	// 8261A28C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A290: 4BBFAB49  bl 0x82214dd8
	ctx.lr = 0x8261A294;
	sub_82214DD8(ctx, base);
	// 8261A294: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261A298: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A29C: 388B8608  addi r4, r11, -0x79f8
	ctx.r[4].s64 = ctx.r[11].s64 + -31224;
	// 8261A2A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A2A4: 4BC12C2D  bl 0x8222ced0
	ctx.lr = 0x8261A2A8;
	sub_8222CED0(ctx, base);
	// 8261A2A8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261A2AC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8261A2B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261A2B4: 419A0008  beq cr6, 0x8261a2bc
	if ctx.cr[6].eq {
	pc = 0x8261A2BC; continue 'dispatch;
	}
	// 8261A2B8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261A2BC; continue 'dispatch;
            }
            0x8261A2BC => {
    //   block [0x8261A2BC..0x8261A2F8)
	// 8261A2BC: 38BE0060  addi r5, r30, 0x60
	ctx.r[5].s64 = ctx.r[30].s64 + 96;
	// 8261A2C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A2C4: 4BE6658D  bl 0x82480850
	ctx.lr = 0x8261A2C8;
	sub_82480850(ctx, base);
	// 8261A2C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A2CC: 4BBFAB0D  bl 0x82214dd8
	ctx.lr = 0x8261A2D0;
	sub_82214DD8(ctx, base);
	// 8261A2D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261A2D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A2D8: 388B8620  addi r4, r11, -0x79e0
	ctx.r[4].s64 = ctx.r[11].s64 + -31200;
	// 8261A2DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A2E0: 4BC12BF1  bl 0x8222ced0
	ctx.lr = 0x8261A2E4;
	sub_8222CED0(ctx, base);
	// 8261A2E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261A2E8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8261A2EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261A2F0: 419A0008  beq cr6, 0x8261a2f8
	if ctx.cr[6].eq {
	pc = 0x8261A2F8; continue 'dispatch;
	}
	// 8261A2F4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261A2F8; continue 'dispatch;
            }
            0x8261A2F8 => {
    //   block [0x8261A2F8..0x8261A3A0)
	// 8261A2F8: 38BE0064  addi r5, r30, 0x64
	ctx.r[5].s64 = ctx.r[30].s64 + 100;
	// 8261A2FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A300: 4BE66551  bl 0x82480850
	ctx.lr = 0x8261A304;
	sub_82480850(ctx, base);
	// 8261A304: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A308: 4BBFAAD1  bl 0x82214dd8
	ctx.lr = 0x8261A30C;
	sub_82214DD8(ctx, base);
	// 8261A30C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261A310: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A314: 388B8634  addi r4, r11, -0x79cc
	ctx.r[4].s64 = ctx.r[11].s64 + -31180;
	// 8261A318: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A31C: 4BC12BB5  bl 0x8222ced0
	ctx.lr = 0x8261A320;
	sub_8222CED0(ctx, base);
	// 8261A320: 38BE005A  addi r5, r30, 0x5a
	ctx.r[5].s64 = ctx.r[30].s64 + 90;
	// 8261A324: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261A328: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A32C: 48402B1D  bl 0x82a1ce48
	ctx.lr = 0x8261A330;
	sub_82A1CE48(ctx, base);
	// 8261A330: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A334: 4BBFAAA5  bl 0x82214dd8
	ctx.lr = 0x8261A338;
	sub_82214DD8(ctx, base);
	// 8261A338: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261A33C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A340: 388A864C  addi r4, r10, -0x79b4
	ctx.r[4].s64 = ctx.r[10].s64 + -31156;
	// 8261A344: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A348: 4BC12B89  bl 0x8222ced0
	ctx.lr = 0x8261A34C;
	sub_8222CED0(ctx, base);
	// 8261A34C: 38BE0059  addi r5, r30, 0x59
	ctx.r[5].s64 = ctx.r[30].s64 + 89;
	// 8261A350: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261A354: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A358: 48402AF1  bl 0x82a1ce48
	ctx.lr = 0x8261A35C;
	sub_82A1CE48(ctx, base);
	// 8261A35C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A360: 4BBFAA79  bl 0x82214dd8
	ctx.lr = 0x8261A364;
	sub_82214DD8(ctx, base);
	// 8261A364: 811E0020  lwz r8, 0x20(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 8261A368: 5769063E  clrlwi r9, r27, 0x18
	ctx.r[9].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 8261A36C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261A370: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 8261A374: 419A00D0  beq cr6, 0x8261a444
	if ctx.cr[6].eq {
	pc = 0x8261A444; continue 'dispatch;
	}
	// 8261A378: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8261A37C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A380: 388B02EC  addi r4, r11, 0x2ec
	ctx.r[4].s64 = ctx.r[11].s64 + 748;
	// 8261A384: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A388: 4BC12B49  bl 0x8222ced0
	ctx.lr = 0x8261A38C;
	sub_8222CED0(ctx, base);
	// 8261A38C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261A390: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8261A394: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261A398: 419A0008  beq cr6, 0x8261a3a0
	if ctx.cr[6].eq {
	pc = 0x8261A3A0; continue 'dispatch;
	}
	// 8261A39C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261A3A0; continue 'dispatch;
            }
            0x8261A3A0 => {
    //   block [0x8261A3A0..0x8261A3DC)
	// 8261A3A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8261A3A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A3A8: 4BD75CE1  bl 0x82390088
	ctx.lr = 0x8261A3AC;
	sub_82390088(ctx, base);
	// 8261A3AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A3B0: 4BBFAA29  bl 0x82214dd8
	ctx.lr = 0x8261A3B4;
	sub_82214DD8(ctx, base);
	// 8261A3B4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261A3B8: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261A3BC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261A3C0: 419A024C  beq cr6, 0x8261a60c
	if ctx.cr[6].eq {
	pc = 0x8261A60C; continue 'dispatch;
	}
	// 8261A3C4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8261A3C8: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8261A3CC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8261A3D0: 3B8BD838  addi r28, r11, -0x27c8
	ctx.r[28].s64 = ctx.r[11].s64 + -10184;
	// 8261A3D4: 3B6AD81C  addi r27, r10, -0x27e4
	ctx.r[27].s64 = ctx.r[10].s64 + -10212;
	// 8261A3D8: 3B498658  addi r26, r9, -0x79a8
	ctx.r[26].s64 = ctx.r[9].s64 + -31144;
	pc = 0x8261A3DC; continue 'dispatch;
            }
            0x8261A3DC => {
    //   block [0x8261A3DC..0x8261A444)
	// 8261A3DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A3E0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8261A3E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A3E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261A3EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261A3F0: 4E800421  bctrl
	ctx.lr = 0x8261A3F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261A3F4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8261A3F8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8261A3FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A400: 4BD75C89  bl 0x82390088
	ctx.lr = 0x8261A404;
	sub_82390088(ctx, base);
	// 8261A404: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8261A408: 38BD0004  addi r5, r29, 4
	ctx.r[5].s64 = ctx.r[29].s64 + 4;
	// 8261A40C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A410: 4BE66441  bl 0x82480850
	ctx.lr = 0x8261A414;
	sub_82480850(ctx, base);
	// 8261A414: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A418: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A41C: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261A420: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8261A424: 4E800421  bctrl
	ctx.lr = 0x8261A428;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261A428: 80FE0008  lwz r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261A42C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 8261A430: 7F1D3840  cmplw cr6, r29, r7
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[7].u32, &mut ctx.xer);
	// 8261A434: 409AFFA8  bne cr6, 0x8261a3dc
	if !ctx.cr[6].eq {
	pc = 0x8261A3DC; continue 'dispatch;
	}
	// 8261A438: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8261A43C: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8261A440: 4868F008  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261A444 => {
    //   block [0x8261A444..0x8261A508)
	// 8261A444: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8261A448: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261A44C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8261A450: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261A454: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261A458: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261A45C: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A460: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261A464: 4BC4A025  bl 0x82264488
	ctx.lr = 0x8261A468;
	sub_82264488(ctx, base);
	// 8261A468: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 8261A46C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8261A470: 3B270B7C  addi r25, r7, 0xb7c
	ctx.r[25].s64 = ctx.r[7].s64 + 2940;
	// 8261A474: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 8261A478: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8261A47C: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 8261A480: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8261A484: 4BBFA415  bl 0x82214898
	ctx.lr = 0x8261A488;
	sub_82214898(ctx, base);
	// 8261A488: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8261A48C: 387E0048  addi r3, r30, 0x48
	ctx.r[3].s64 = ctx.r[30].s64 + 72;
	// 8261A490: 4BEB7A39  bl 0x824d1ec8
	ctx.lr = 0x8261A494;
	sub_824D1EC8(ctx, base);
	// 8261A494: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 8261A498: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8261A49C: 3B060B7C  addi r24, r6, 0xb7c
	ctx.r[24].s64 = ctx.r[6].s64 + 2940;
	// 8261A4A0: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 8261A4A4: 4BB79995  bl 0x82193e38
	ctx.lr = 0x8261A4A8;
	sub_82193E38(ctx, base);
	// 8261A4A8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8261A4AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261A4B0: 4BC49FD9  bl 0x82264488
	ctx.lr = 0x8261A4B4;
	sub_82264488(ctx, base);
	// 8261A4B4: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 8261A4B8: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 8261A4BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8261A4C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8261A4C4: 4BBFA3D5  bl 0x82214898
	ctx.lr = 0x8261A4C8;
	sub_82214898(ctx, base);
	// 8261A4C8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8261A4CC: 387E0050  addi r3, r30, 0x50
	ctx.r[3].s64 = ctx.r[30].s64 + 80;
	// 8261A4D0: 4BEB79F9  bl 0x824d1ec8
	ctx.lr = 0x8261A4D4;
	sub_824D1EC8(ctx, base);
	// 8261A4D4: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 8261A4D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8261A4DC: 4BB7995D  bl 0x82193e38
	ctx.lr = 0x8261A4E0;
	sub_82193E38(ctx, base);
	// 8261A4E0: 3C80820B  lis r4, -0x7df5
	ctx.r[4].s64 = -2113208320;
	// 8261A4E4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A4E8: 388402EC  addi r4, r4, 0x2ec
	ctx.r[4].s64 = ctx.r[4].s64 + 748;
	// 8261A4EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A4F0: 4BC129E1  bl 0x8222ced0
	ctx.lr = 0x8261A4F4;
	sub_8222CED0(ctx, base);
	// 8261A4F4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261A4F8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8261A4FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261A500: 419A0008  beq cr6, 0x8261a508
	if ctx.cr[6].eq {
	pc = 0x8261A508; continue 'dispatch;
	}
	// 8261A504: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261A508; continue 'dispatch;
            }
            0x8261A508 => {
    //   block [0x8261A508..0x8261A588)
	// 8261A508: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8261A50C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A510: 4BD75B79  bl 0x82390088
	ctx.lr = 0x8261A514;
	sub_82390088(ctx, base);
	// 8261A514: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8261A518: 4BBFA8C1  bl 0x82214dd8
	ctx.lr = 0x8261A51C;
	sub_82214DD8(ctx, base);
	// 8261A51C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8261A520: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261A524: 4BBBFE25  bl 0x821da348
	ctx.lr = 0x8261A528;
	sub_821DA348(ctx, base);
	// 8261A528: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8261A52C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261A530: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A534: 915E0020  stw r10, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 8261A538: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261A53C: 913E0024  stw r9, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 8261A540: 4BEABA31  bl 0x824c5f70
	ctx.lr = 0x8261A544;
	sub_824C5F70(ctx, base);
	// 8261A544: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A548: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261A54C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A550: 3B4B8658  addi r26, r11, -0x79a8
	ctx.r[26].s64 = ctx.r[11].s64 + -31144;
	// 8261A554: 80E80008  lwz r7, 8(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261A558: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8261A55C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 8261A560: 4E800421  bctrl
	ctx.lr = 0x8261A564;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261A564: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261A568: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8261A56C: 419A00A0  beq cr6, 0x8261a60c
	if ctx.cr[6].eq {
	pc = 0x8261A60C; continue 'dispatch;
	}
	// 8261A570: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 8261A574: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8261A578: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8261A57C: 3BABD838  addi r29, r11, -0x27c8
	ctx.r[29].s64 = ctx.r[11].s64 + -10184;
	// 8261A580: 3B8AD81C  addi r28, r10, -0x27e4
	ctx.r[28].s64 = ctx.r[10].s64 + -10212;
	// 8261A584: C3E99484  lfs f31, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
            }
            0x8261A588 => {
    //   block [0x8261A588..0x8261A5D4)
	// 8261A588: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8261A58C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 8261A590: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8261A594: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8261A598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A59C: 4BD75AED  bl 0x82390088
	ctx.lr = 0x8261A5A0;
	sub_82390088(ctx, base);
	// 8261A5A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261A5A4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8261A5A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A5AC: 4BE662A5  bl 0x82480850
	ctx.lr = 0x8261A5B0;
	sub_82480850(ctx, base);
	// 8261A5B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261A5B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261A5B8: 419A001C  beq cr6, 0x8261a5d4
	if ctx.cr[6].eq {
	pc = 0x8261A5D4; continue 'dispatch;
	}
	// 8261A5BC: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8261A5C0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8261A5C4: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8261A5C8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8261A5CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261A5D0: 48227A91  bl 0x82842060
	ctx.lr = 0x8261A5D4;
	sub_82842060(ctx, base);
	pc = 0x8261A5D4; continue 'dispatch;
            }
            0x8261A5D4 => {
    //   block [0x8261A5D4..0x8261A60C)
	// 8261A5D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A5D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A5DC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261A5E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261A5E4: 4E800421  bctrl
	ctx.lr = 0x8261A5E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261A5E8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A5EC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8261A5F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A5F4: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261A5F8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8261A5FC: 4E800421  bctrl
	ctx.lr = 0x8261A600;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261A600: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261A604: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261A608: 409AFF80  bne cr6, 0x8261a588
	if !ctx.cr[6].eq {
	pc = 0x8261A588; continue 'dispatch;
	}
            }
            0x8261A60C => {
    //   block [0x8261A60C..0x8261A618)
	// 8261A60C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8261A610: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8261A614: 4868EE34  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261A618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261A618 size=216
    let mut pc: u32 = 0x8261A618;
    'dispatch: loop {
        match pc {
            0x8261A618 => {
    //   block [0x8261A618..0x8261A65C)
	// 8261A618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261A61C: 4868EDF1  bl 0x82ca940c
	ctx.lr = 0x8261A620;
	sub_82CA93D0(ctx, base);
	// 8261A620: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261A624: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261A628: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261A62C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8261A630: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A634: 388B85A4  addi r4, r11, -0x7a5c
	ctx.r[4].s64 = ctx.r[11].s64 + -31324;
	// 8261A638: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261A63C: 4BC12895  bl 0x8222ced0
	ctx.lr = 0x8261A640;
	sub_8222CED0(ctx, base);
	// 8261A640: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8261A644: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 8261A648: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261A64C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261A650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261A654: 419A0008  beq cr6, 0x8261a65c
	if ctx.cr[6].eq {
	pc = 0x8261A65C; continue 'dispatch;
	}
	// 8261A658: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261A65C; continue 'dispatch;
            }
            0x8261A65C => {
    //   block [0x8261A65C..0x8261A698)
	// 8261A65C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8261A660: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261A664: 4BE66165  bl 0x824807c8
	ctx.lr = 0x8261A668;
	sub_824807C8(ctx, base);
	// 8261A668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261A66C: 4BBFA76D  bl 0x82214dd8
	ctx.lr = 0x8261A670;
	sub_82214DD8(ctx, base);
	// 8261A670: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261A674: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A678: 388B85B4  addi r4, r11, -0x7a4c
	ctx.r[4].s64 = ctx.r[11].s64 + -31308;
	// 8261A67C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261A680: 4BC12851  bl 0x8222ced0
	ctx.lr = 0x8261A684;
	sub_8222CED0(ctx, base);
	// 8261A684: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261A688: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261A68C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261A690: 419A0008  beq cr6, 0x8261a698
	if ctx.cr[6].eq {
	pc = 0x8261A698; continue 'dispatch;
	}
	// 8261A694: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261A698; continue 'dispatch;
            }
            0x8261A698 => {
    //   block [0x8261A698..0x8261A6D4)
	// 8261A698: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 8261A69C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261A6A0: 4BE66129  bl 0x824807c8
	ctx.lr = 0x8261A6A4;
	sub_824807C8(ctx, base);
	// 8261A6A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261A6A8: 4BBFA731  bl 0x82214dd8
	ctx.lr = 0x8261A6AC;
	sub_82214DD8(ctx, base);
	// 8261A6AC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8261A6B0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261A6B4: 388B9998  addi r4, r11, -0x6668
	ctx.r[4].s64 = ctx.r[11].s64 + -26216;
	// 8261A6B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261A6BC: 4BC12815  bl 0x8222ced0
	ctx.lr = 0x8261A6C0;
	sub_8222CED0(ctx, base);
	// 8261A6C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261A6C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261A6C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261A6CC: 419A0008  beq cr6, 0x8261a6d4
	if ctx.cr[6].eq {
	pc = 0x8261A6D4; continue 'dispatch;
	}
	// 8261A6D0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261A6D4; continue 'dispatch;
            }
            0x8261A6D4 => {
    //   block [0x8261A6D4..0x8261A6F0)
	// 8261A6D4: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 8261A6D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261A6DC: 4BD759AD  bl 0x82390088
	ctx.lr = 0x8261A6E0;
	sub_82390088(ctx, base);
	// 8261A6E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261A6E4: 4BBFA6F5  bl 0x82214dd8
	ctx.lr = 0x8261A6E8;
	sub_82214DD8(ctx, base);
	// 8261A6E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8261A6EC: 4868ED70  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261A6F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8261A6F0 size=2704
    let mut pc: u32 = 0x8261A6F0;
    'dispatch: loop {
        match pc {
            0x8261A6F0 => {
    //   block [0x8261A6F0..0x8261A7FC)
	// 8261A6F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261A6F4: 4868ECF5  bl 0x82ca93e8
	ctx.lr = 0x8261A6F8;
	sub_82CA93D0(ctx, base);
	// 8261A6F8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261A6FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261A700: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8261A704: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8261A708: 3940000D  li r10, 0xd
	ctx.r[10].s64 = 13;
	// 8261A70C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261A710: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8261A714: 3B9F003C  addi r28, r31, 0x3c
	ctx.r[28].s64 = ctx.r[31].s64 + 60;
	// 8261A718: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8261A71C: 3B7F0040  addi r27, r31, 0x40
	ctx.r[27].s64 = ctx.r[31].s64 + 64;
	// 8261A720: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 8261A724: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8261A728: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 8261A72C: 3B5F0044  addi r26, r31, 0x44
	ctx.r[26].s64 = ctx.r[31].s64 + 68;
	// 8261A730: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 8261A734: 3B3F0048  addi r25, r31, 0x48
	ctx.r[25].s64 = ctx.r[31].s64 + 72;
	// 8261A738: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 8261A73C: 3B1F004C  addi r24, r31, 0x4c
	ctx.r[24].s64 = ctx.r[31].s64 + 76;
	// 8261A740: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 8261A744: 3AFF0050  addi r23, r31, 0x50
	ctx.r[23].s64 = ctx.r[31].s64 + 80;
	// 8261A748: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 8261A74C: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8261A750: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8261A754: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 8261A758: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8261A75C: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 8261A760: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8261A764: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 8261A768: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 8261A76C: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 8261A770: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8261A774: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 8261A778: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8261A77C: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 8261A780: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8261A784: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 8261A788: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8261A78C: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8261A790: 3ADF0054  addi r22, r31, 0x54
	ctx.r[22].s64 = ctx.r[31].s64 + 84;
	// 8261A794: 3ABF0058  addi r21, r31, 0x58
	ctx.r[21].s64 = ctx.r[31].s64 + 88;
	// 8261A798: 3A9F005C  addi r20, r31, 0x5c
	ctx.r[20].s64 = ctx.r[31].s64 + 92;
	// 8261A79C: 4BBBFBAD  bl 0x821da348
	ctx.lr = 0x8261A7A0;
	sub_821DA348(ctx, base);
	// 8261A7A0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A7A4: 5528003E  slwi r8, r9, 0
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261A7A8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8261A7AC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8261A7B0: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261A7B4: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 8261A7B8: 419A09BC  beq cr6, 0x8261b174
	if ctx.cr[6].eq {
	pc = 0x8261B174; continue 'dispatch;
	}
	// 8261A7BC: 3D60811C  lis r11, -0x7ee4
	ctx.r[11].s64 = -2128871424;
	// 8261A7C0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261A7C4: 617D9DC5  ori r29, r11, 0x9dc5
	ctx.r[29].u64 = ctx.r[11].u64 | 40389;
	// 8261A7C8: 386A8664  addi r3, r10, -0x799c
	ctx.r[3].s64 = ctx.r[10].s64 + -31132;
	// 8261A7CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261A7D0: 4BBD9589  bl 0x821f3d58
	ctx.lr = 0x8261A7D4;
	sub_821F3D58(ctx, base);
	// 8261A7D4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8261A7D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A7DC: 4BB97D1D  bl 0x821b24f8
	ctx.lr = 0x8261A7E0;
	sub_821B24F8(ctx, base);
	// 8261A7E0: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261A7E4: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 8261A7E8: 483E5EE1  bl 0x82a006c8
	ctx.lr = 0x8261A7EC;
	sub_82A006C8(ctx, base);
	// 8261A7EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261A7F0: 419A000C  beq cr6, 0x8261a7fc
	if ctx.cr[6].eq {
	pc = 0x8261A7FC; continue 'dispatch;
	}
	// 8261A7F4: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A7F8: 48000008  b 0x8261a800
	pc = 0x8261A800; continue 'dispatch;
            }
            0x8261A7FC => {
    //   block [0x8261A7FC..0x8261A800)
	// 8261A7FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x8261A800; continue 'dispatch;
            }
            0x8261A800 => {
    //   block [0x8261A800..0x8261A854)
	// 8261A800: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261A804: 4BBBFB45  bl 0x821da348
	ctx.lr = 0x8261A808;
	sub_821DA348(ctx, base);
	// 8261A808: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8261A80C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261A810: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261A814: 386A8678  addi r3, r10, -0x7988
	ctx.r[3].s64 = ctx.r[10].s64 + -31112;
	// 8261A818: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A81C: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8261A820: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261A824: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 8261A828: 4BBD9531  bl 0x821f3d58
	ctx.lr = 0x8261A82C;
	sub_821F3D58(ctx, base);
	// 8261A82C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8261A830: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A834: 4BB97CC5  bl 0x821b24f8
	ctx.lr = 0x8261A838;
	sub_821B24F8(ctx, base);
	// 8261A838: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261A83C: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 8261A840: 483E5E89  bl 0x82a006c8
	ctx.lr = 0x8261A844;
	sub_82A006C8(ctx, base);
	// 8261A844: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261A848: 419A000C  beq cr6, 0x8261a854
	if ctx.cr[6].eq {
	pc = 0x8261A854; continue 'dispatch;
	}
	// 8261A84C: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A850: 48000008  b 0x8261a858
	pc = 0x8261A858; continue 'dispatch;
            }
            0x8261A854 => {
    //   block [0x8261A854..0x8261A858)
	// 8261A854: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x8261A858; continue 'dispatch;
            }
            0x8261A858 => {
    //   block [0x8261A858..0x8261A8AC)
	// 8261A858: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8261A85C: 4BBBFAED  bl 0x821da348
	ctx.lr = 0x8261A860;
	sub_821DA348(ctx, base);
	// 8261A860: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8261A864: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261A868: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261A86C: 386A8688  addi r3, r10, -0x7978
	ctx.r[3].s64 = ctx.r[10].s64 + -31096;
	// 8261A870: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A874: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 8261A878: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261A87C: 911F0014  stw r8, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 8261A880: 4BBD94D9  bl 0x821f3d58
	ctx.lr = 0x8261A884;
	sub_821F3D58(ctx, base);
	// 8261A884: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8261A888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A88C: 4BB97C6D  bl 0x821b24f8
	ctx.lr = 0x8261A890;
	sub_821B24F8(ctx, base);
	// 8261A890: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261A894: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 8261A898: 483E5E31  bl 0x82a006c8
	ctx.lr = 0x8261A89C;
	sub_82A006C8(ctx, base);
	// 8261A89C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261A8A0: 419A000C  beq cr6, 0x8261a8ac
	if ctx.cr[6].eq {
	pc = 0x8261A8AC; continue 'dispatch;
	}
	// 8261A8A4: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A8A8: 48000008  b 0x8261a8b0
	pc = 0x8261A8B0; continue 'dispatch;
            }
            0x8261A8AC => {
    //   block [0x8261A8AC..0x8261A8B0)
	// 8261A8AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x8261A8B0; continue 'dispatch;
            }
            0x8261A8B0 => {
    //   block [0x8261A8B0..0x8261A908)
	// 8261A8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261A8B4: 4BBBFA95  bl 0x821da348
	ctx.lr = 0x8261A8B8;
	sub_821DA348(ctx, base);
	// 8261A8B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8261A8BC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261A8C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261A8C4: 386A86A0  addi r3, r10, -0x7960
	ctx.r[3].s64 = ctx.r[10].s64 + -31072;
	// 8261A8C8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A8CC: 913F0018  stw r9, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 8261A8D0: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261A8D4: 911F001C  stw r8, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 8261A8D8: 4BBD9481  bl 0x821f3d58
	ctx.lr = 0x8261A8DC;
	sub_821F3D58(ctx, base);
	// 8261A8DC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8261A8E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A8E4: 4BB97C15  bl 0x821b24f8
	ctx.lr = 0x8261A8E8;
	sub_821B24F8(ctx, base);
	// 8261A8E8: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261A8EC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 8261A8F0: 483E5DD9  bl 0x82a006c8
	ctx.lr = 0x8261A8F4;
	sub_82A006C8(ctx, base);
	// 8261A8F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261A8F8: 419A0010  beq cr6, 0x8261a908
	if ctx.cr[6].eq {
	pc = 0x8261A908; continue 'dispatch;
	}
	// 8261A8FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261A900: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 8261A904: 48000008  b 0x8261a90c
	pc = 0x8261A90C; continue 'dispatch;
            }
            0x8261A908 => {
    //   block [0x8261A908..0x8261A90C)
	// 8261A908: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8261A90C; continue 'dispatch;
            }
            0x8261A90C => {
    //   block [0x8261A90C..0x8261A91C)
	// 8261A90C: 57CA063E  clrlwi r10, r30, 0x18
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 8261A910: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261A914: 419A0008  beq cr6, 0x8261a91c
	if ctx.cr[6].eq {
	pc = 0x8261A91C; continue 'dispatch;
	}
	// 8261A918: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x8261A91C; continue 'dispatch;
            }
            0x8261A91C => {
    //   block [0x8261A91C..0x8261AA60)
	// 8261A91C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261A920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A924: 38EB86B0  addi r7, r11, -0x7950
	ctx.r[7].s64 = ctx.r[11].s64 + -31056;
	// 8261A928: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8261A92C: 4BB97BCD  bl 0x821b24f8
	ctx.lr = 0x8261A930;
	sub_821B24F8(ctx, base);
	// 8261A930: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261A934: 4BD92ABD  bl 0x823ad3f0
	ctx.lr = 0x8261A938;
	sub_823AD3F0(ctx, base);
	// 8261A938: 3CC0820B  lis r6, -0x7df5
	ctx.r[6].s64 = -2113208320;
	// 8261A93C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A940: 38E63FE0  addi r7, r6, 0x3fe0
	ctx.r[7].s64 = ctx.r[6].s64 + 16352;
	// 8261A944: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 8261A948: 4BB97BB1  bl 0x821b24f8
	ctx.lr = 0x8261A94C;
	sub_821B24F8(ctx, base);
	// 8261A94C: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261A950: 4BD92AA1  bl 0x823ad3f0
	ctx.lr = 0x8261A954;
	sub_823AD3F0(ctx, base);
	// 8261A954: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 8261A958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A95C: 38E686B8  addi r7, r6, -0x7948
	ctx.r[7].s64 = ctx.r[6].s64 + -31048;
	// 8261A960: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 8261A964: 4BB97B95  bl 0x821b24f8
	ctx.lr = 0x8261A968;
	sub_821B24F8(ctx, base);
	// 8261A968: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261A96C: 4BD92A85  bl 0x823ad3f0
	ctx.lr = 0x8261A970;
	sub_823AD3F0(ctx, base);
	// 8261A970: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 8261A974: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A978: 38E686C8  addi r7, r6, -0x7938
	ctx.r[7].s64 = ctx.r[6].s64 + -31032;
	// 8261A97C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 8261A980: 4BB97B79  bl 0x821b24f8
	ctx.lr = 0x8261A984;
	sub_821B24F8(ctx, base);
	// 8261A984: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261A988: 4BD92A69  bl 0x823ad3f0
	ctx.lr = 0x8261A98C;
	sub_823AD3F0(ctx, base);
	// 8261A98C: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 8261A990: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A994: 38E6ABAC  addi r7, r6, -0x5454
	ctx.r[7].s64 = ctx.r[6].s64 + -21588;
	// 8261A998: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 8261A99C: 4BB97B5D  bl 0x821b24f8
	ctx.lr = 0x8261A9A0;
	sub_821B24F8(ctx, base);
	// 8261A9A0: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261A9A4: 4BD92A4D  bl 0x823ad3f0
	ctx.lr = 0x8261A9A8;
	sub_823AD3F0(ctx, base);
	// 8261A9A8: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 8261A9AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A9B0: 38E686D8  addi r7, r6, -0x7928
	ctx.r[7].s64 = ctx.r[6].s64 + -31016;
	// 8261A9B4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 8261A9B8: 4BB97B41  bl 0x821b24f8
	ctx.lr = 0x8261A9BC;
	sub_821B24F8(ctx, base);
	// 8261A9BC: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261A9C0: 4BD92A31  bl 0x823ad3f0
	ctx.lr = 0x8261A9C4;
	sub_823AD3F0(ctx, base);
	// 8261A9C4: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 8261A9C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A9CC: 38E686E0  addi r7, r6, -0x7920
	ctx.r[7].s64 = ctx.r[6].s64 + -31008;
	// 8261A9D0: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 8261A9D4: 4BB97B25  bl 0x821b24f8
	ctx.lr = 0x8261A9D8;
	sub_821B24F8(ctx, base);
	// 8261A9D8: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261A9DC: 4BD92A15  bl 0x823ad3f0
	ctx.lr = 0x8261A9E0;
	sub_823AD3F0(ctx, base);
	// 8261A9E0: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 8261A9E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261A9E8: 38E69AC0  addi r7, r6, -0x6540
	ctx.r[7].s64 = ctx.r[6].s64 + -25920;
	// 8261A9EC: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 8261A9F0: 4BB97B09  bl 0x821b24f8
	ctx.lr = 0x8261A9F4;
	sub_821B24F8(ctx, base);
	// 8261A9F4: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261A9F8: 4BD929F9  bl 0x823ad3f0
	ctx.lr = 0x8261A9FC;
	sub_823AD3F0(ctx, base);
	// 8261A9FC: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 8261AA00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261AA04: 38E69AD4  addi r7, r6, -0x652c
	ctx.r[7].s64 = ctx.r[6].s64 + -25900;
	// 8261AA08: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 8261AA0C: 4BB97AED  bl 0x821b24f8
	ctx.lr = 0x8261AA10;
	sub_821B24F8(ctx, base);
	// 8261AA10: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261AA14: 4BD929DD  bl 0x823ad3f0
	ctx.lr = 0x8261AA18;
	sub_823AD3F0(ctx, base);
	// 8261AA18: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 8261AA1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261AA20: 38A68708  addi r5, r6, -0x78f8
	ctx.r[5].s64 = ctx.r[6].s64 + -30968;
	// 8261AA24: 4BB97AD5  bl 0x821b24f8
	ctx.lr = 0x8261AA28;
	sub_821B24F8(ctx, base);
	// 8261AA28: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 8261AA2C: 4BC8EFBD  bl 0x822a99e8
	ctx.lr = 0x8261AA30;
	sub_822A99E8(ctx, base);
	// 8261AA30: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261AA34: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261AA38: 419A0028  beq cr6, 0x8261aa60
	if ctx.cr[6].eq {
	pc = 0x8261AA60; continue 'dispatch;
	}
	// 8261AA3C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AA40: 388B8724  addi r4, r11, -0x78dc
	ctx.r[4].s64 = ctx.r[11].s64 + -30940;
	// 8261AA44: 4BDA4DDD  bl 0x823bf820
	ctx.lr = 0x8261AA48;
	sub_823BF820(ctx, base);
	// 8261AA48: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 8261AA4C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261AA50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AA54: 388A8734  addi r4, r10, -0x78cc
	ctx.r[4].s64 = ctx.r[10].s64 + -30924;
	// 8261AA58: 4BDA4DC9  bl 0x823bf820
	ctx.lr = 0x8261AA5C;
	sub_823BF820(ctx, base);
	// 8261AA5C: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	pc = 0x8261AA60; continue 'dispatch;
            }
            0x8261AA60 => {
    //   block [0x8261AA60..0x8261AAA8)
	// 8261AA60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AA64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261AA68: 38EB8744  addi r7, r11, -0x78bc
	ctx.r[7].s64 = ctx.r[11].s64 + -30908;
	// 8261AA6C: 4BB97A8D  bl 0x821b24f8
	ctx.lr = 0x8261AA70;
	sub_821B24F8(ctx, base);
	// 8261AA70: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261AA74: 4BC8EF75  bl 0x822a99e8
	ctx.lr = 0x8261AA78;
	sub_822A99E8(ctx, base);
	// 8261AA78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261AA7C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261AA80: 419A0230  beq cr6, 0x8261acb0
	if ctx.cr[6].eq {
	pc = 0x8261ACB0; continue 'dispatch;
	}
	// 8261AA84: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AA88: 388B8758  addi r4, r11, -0x78a8
	ctx.r[4].s64 = ctx.r[11].s64 + -30888;
	// 8261AA8C: 4BCF5805  bl 0x82310290
	ctx.lr = 0x8261AA90;
	sub_82310290(ctx, base);
	// 8261AA90: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AA94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AA98: 419A0010  beq cr6, 0x8261aaa8
	if ctx.cr[6].eq {
	pc = 0x8261AAA8; continue 'dispatch;
	}
	// 8261AA9C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261AAA0: 616A0001  ori r10, r11, 1
	ctx.r[10].u64 = ctx.r[11].u64 | 1;
	// 8261AAA4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AAA8; continue 'dispatch;
            }
            0x8261AAA8 => {
    //   block [0x8261AAA8..0x8261AAD0)
	// 8261AAA8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AAAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AAB0: 388B8760  addi r4, r11, -0x78a0
	ctx.r[4].s64 = ctx.r[11].s64 + -30880;
	// 8261AAB4: 4BCF57DD  bl 0x82310290
	ctx.lr = 0x8261AAB8;
	sub_82310290(ctx, base);
	// 8261AAB8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AABC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AAC0: 419A0010  beq cr6, 0x8261aad0
	if ctx.cr[6].eq {
	pc = 0x8261AAD0; continue 'dispatch;
	}
	// 8261AAC4: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261AAC8: 616A0002  ori r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u64 | 2;
	// 8261AACC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AAD0; continue 'dispatch;
            }
            0x8261AAD0 => {
    //   block [0x8261AAD0..0x8261AAF8)
	// 8261AAD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AAD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AAD8: 388B876C  addi r4, r11, -0x7894
	ctx.r[4].s64 = ctx.r[11].s64 + -30868;
	// 8261AADC: 4BCF57B5  bl 0x82310290
	ctx.lr = 0x8261AAE0;
	sub_82310290(ctx, base);
	// 8261AAE0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AAE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AAE8: 419A0010  beq cr6, 0x8261aaf8
	if ctx.cr[6].eq {
	pc = 0x8261AAF8; continue 'dispatch;
	}
	// 8261AAEC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261AAF0: 616A0004  ori r10, r11, 4
	ctx.r[10].u64 = ctx.r[11].u64 | 4;
	// 8261AAF4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AAF8; continue 'dispatch;
            }
            0x8261AAF8 => {
    //   block [0x8261AAF8..0x8261AB20)
	// 8261AAF8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AAFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AB00: 388B8778  addi r4, r11, -0x7888
	ctx.r[4].s64 = ctx.r[11].s64 + -30856;
	// 8261AB04: 4BCF578D  bl 0x82310290
	ctx.lr = 0x8261AB08;
	sub_82310290(ctx, base);
	// 8261AB08: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AB0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AB10: 419A0010  beq cr6, 0x8261ab20
	if ctx.cr[6].eq {
	pc = 0x8261AB20; continue 'dispatch;
	}
	// 8261AB14: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261AB18: 616A0008  ori r10, r11, 8
	ctx.r[10].u64 = ctx.r[11].u64 | 8;
	// 8261AB1C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AB20; continue 'dispatch;
            }
            0x8261AB20 => {
    //   block [0x8261AB20..0x8261AB48)
	// 8261AB20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AB24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AB28: 388B8784  addi r4, r11, -0x787c
	ctx.r[4].s64 = ctx.r[11].s64 + -30844;
	// 8261AB2C: 4BCF5765  bl 0x82310290
	ctx.lr = 0x8261AB30;
	sub_82310290(ctx, base);
	// 8261AB30: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AB34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AB38: 419A0010  beq cr6, 0x8261ab48
	if ctx.cr[6].eq {
	pc = 0x8261AB48; continue 'dispatch;
	}
	// 8261AB3C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261AB40: 616A0010  ori r10, r11, 0x10
	ctx.r[10].u64 = ctx.r[11].u64 | 16;
	// 8261AB44: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AB48; continue 'dispatch;
            }
            0x8261AB48 => {
    //   block [0x8261AB48..0x8261AB70)
	// 8261AB48: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AB4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AB50: 388B8790  addi r4, r11, -0x7870
	ctx.r[4].s64 = ctx.r[11].s64 + -30832;
	// 8261AB54: 4BCF573D  bl 0x82310290
	ctx.lr = 0x8261AB58;
	sub_82310290(ctx, base);
	// 8261AB58: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AB5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AB60: 419A0010  beq cr6, 0x8261ab70
	if ctx.cr[6].eq {
	pc = 0x8261AB70; continue 'dispatch;
	}
	// 8261AB64: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261AB68: 616A0020  ori r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 | 32;
	// 8261AB6C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AB70; continue 'dispatch;
            }
            0x8261AB70 => {
    //   block [0x8261AB70..0x8261AB98)
	// 8261AB70: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AB74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AB78: 388B879C  addi r4, r11, -0x7864
	ctx.r[4].s64 = ctx.r[11].s64 + -30820;
	// 8261AB7C: 4BCF5715  bl 0x82310290
	ctx.lr = 0x8261AB80;
	sub_82310290(ctx, base);
	// 8261AB80: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AB84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AB88: 419A0010  beq cr6, 0x8261ab98
	if ctx.cr[6].eq {
	pc = 0x8261AB98; continue 'dispatch;
	}
	// 8261AB8C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261AB90: 616A0040  ori r10, r11, 0x40
	ctx.r[10].u64 = ctx.r[11].u64 | 64;
	// 8261AB94: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AB98; continue 'dispatch;
            }
            0x8261AB98 => {
    //   block [0x8261AB98..0x8261ABC0)
	// 8261AB98: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AB9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261ABA0: 388B87B8  addi r4, r11, -0x7848
	ctx.r[4].s64 = ctx.r[11].s64 + -30792;
	// 8261ABA4: 4BCF56ED  bl 0x82310290
	ctx.lr = 0x8261ABA8;
	sub_82310290(ctx, base);
	// 8261ABA8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261ABAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261ABB0: 419A0010  beq cr6, 0x8261abc0
	if ctx.cr[6].eq {
	pc = 0x8261ABC0; continue 'dispatch;
	}
	// 8261ABB4: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261ABB8: 616A0080  ori r10, r11, 0x80
	ctx.r[10].u64 = ctx.r[11].u64 | 128;
	// 8261ABBC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	pc = 0x8261ABC0; continue 'dispatch;
            }
            0x8261ABC0 => {
    //   block [0x8261ABC0..0x8261ABE8)
	// 8261ABC0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261ABC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261ABC8: 388B87D4  addi r4, r11, -0x782c
	ctx.r[4].s64 = ctx.r[11].s64 + -30764;
	// 8261ABCC: 4BCF56C5  bl 0x82310290
	ctx.lr = 0x8261ABD0;
	sub_82310290(ctx, base);
	// 8261ABD0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261ABD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261ABD8: 419A0010  beq cr6, 0x8261abe8
	if ctx.cr[6].eq {
	pc = 0x8261ABE8; continue 'dispatch;
	}
	// 8261ABDC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261ABE0: 616A0100  ori r10, r11, 0x100
	ctx.r[10].u64 = ctx.r[11].u64 | 256;
	// 8261ABE4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	pc = 0x8261ABE8; continue 'dispatch;
            }
            0x8261ABE8 => {
    //   block [0x8261ABE8..0x8261AC10)
	// 8261ABE8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261ABEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261ABF0: 388B87E0  addi r4, r11, -0x7820
	ctx.r[4].s64 = ctx.r[11].s64 + -30752;
	// 8261ABF4: 4BCF569D  bl 0x82310290
	ctx.lr = 0x8261ABF8;
	sub_82310290(ctx, base);
	// 8261ABF8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261ABFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AC00: 419A0010  beq cr6, 0x8261ac10
	if ctx.cr[6].eq {
	pc = 0x8261AC10; continue 'dispatch;
	}
	// 8261AC04: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261AC08: 616A0200  ori r10, r11, 0x200
	ctx.r[10].u64 = ctx.r[11].u64 | 512;
	// 8261AC0C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AC10; continue 'dispatch;
            }
            0x8261AC10 => {
    //   block [0x8261AC10..0x8261AC38)
	// 8261AC10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AC14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AC18: 388B87F0  addi r4, r11, -0x7810
	ctx.r[4].s64 = ctx.r[11].s64 + -30736;
	// 8261AC1C: 4BCF5675  bl 0x82310290
	ctx.lr = 0x8261AC20;
	sub_82310290(ctx, base);
	// 8261AC20: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AC24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AC28: 419A0010  beq cr6, 0x8261ac38
	if ctx.cr[6].eq {
	pc = 0x8261AC38; continue 'dispatch;
	}
	// 8261AC2C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261AC30: 616A0400  ori r10, r11, 0x400
	ctx.r[10].u64 = ctx.r[11].u64 | 1024;
	// 8261AC34: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AC38; continue 'dispatch;
            }
            0x8261AC38 => {
    //   block [0x8261AC38..0x8261AC60)
	// 8261AC38: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AC3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AC40: 388B8808  addi r4, r11, -0x77f8
	ctx.r[4].s64 = ctx.r[11].s64 + -30712;
	// 8261AC44: 4BCF564D  bl 0x82310290
	ctx.lr = 0x8261AC48;
	sub_82310290(ctx, base);
	// 8261AC48: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AC4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AC50: 419A0010  beq cr6, 0x8261ac60
	if ctx.cr[6].eq {
	pc = 0x8261AC60; continue 'dispatch;
	}
	// 8261AC54: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261AC58: 616A0800  ori r10, r11, 0x800
	ctx.r[10].u64 = ctx.r[11].u64 | 2048;
	// 8261AC5C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AC60; continue 'dispatch;
            }
            0x8261AC60 => {
    //   block [0x8261AC60..0x8261AC88)
	// 8261AC60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AC64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AC68: 388B881C  addi r4, r11, -0x77e4
	ctx.r[4].s64 = ctx.r[11].s64 + -30692;
	// 8261AC6C: 4BCF5625  bl 0x82310290
	ctx.lr = 0x8261AC70;
	sub_82310290(ctx, base);
	// 8261AC70: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AC74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AC78: 419A0010  beq cr6, 0x8261ac88
	if ctx.cr[6].eq {
	pc = 0x8261AC88; continue 'dispatch;
	}
	// 8261AC7C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261AC80: 616A1000  ori r10, r11, 0x1000
	ctx.r[10].u64 = ctx.r[11].u64 | 4096;
	// 8261AC84: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AC88; continue 'dispatch;
            }
            0x8261AC88 => {
    //   block [0x8261AC88..0x8261ACB0)
	// 8261AC88: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AC8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AC90: 388B8828  addi r4, r11, -0x77d8
	ctx.r[4].s64 = ctx.r[11].s64 + -30680;
	// 8261AC94: 4BCF55FD  bl 0x82310290
	ctx.lr = 0x8261AC98;
	sub_82310290(ctx, base);
	// 8261AC98: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AC9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261ACA0: 419A0010  beq cr6, 0x8261acb0
	if ctx.cr[6].eq {
	pc = 0x8261ACB0; continue 'dispatch;
	}
	// 8261ACA4: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261ACA8: 616A2000  ori r10, r11, 0x2000
	ctx.r[10].u64 = ctx.r[11].u64 | 8192;
	// 8261ACAC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	pc = 0x8261ACB0; continue 'dispatch;
            }
            0x8261ACB0 => {
    //   block [0x8261ACB0..0x8261ACF8)
	// 8261ACB0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261ACB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261ACB8: 38EB8834  addi r7, r11, -0x77cc
	ctx.r[7].s64 = ctx.r[11].s64 + -30668;
	// 8261ACBC: 4BB9783D  bl 0x821b24f8
	ctx.lr = 0x8261ACC0;
	sub_821B24F8(ctx, base);
	// 8261ACC0: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261ACC4: 4BC8ED25  bl 0x822a99e8
	ctx.lr = 0x8261ACC8;
	sub_822A99E8(ctx, base);
	// 8261ACC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261ACCC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261ACD0: 419A00C8  beq cr6, 0x8261ad98
	if ctx.cr[6].eq {
	pc = 0x8261AD98; continue 'dispatch;
	}
	// 8261ACD4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261ACD8: 388B8844  addi r4, r11, -0x77bc
	ctx.r[4].s64 = ctx.r[11].s64 + -30652;
	// 8261ACDC: 4BCF55B5  bl 0x82310290
	ctx.lr = 0x8261ACE0;
	sub_82310290(ctx, base);
	// 8261ACE0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261ACE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261ACE8: 419A0010  beq cr6, 0x8261acf8
	if ctx.cr[6].eq {
	pc = 0x8261ACF8; continue 'dispatch;
	}
	// 8261ACEC: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 8261ACF0: 616A0001  ori r10, r11, 1
	ctx.r[10].u64 = ctx.r[11].u64 | 1;
	// 8261ACF4: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	pc = 0x8261ACF8; continue 'dispatch;
            }
            0x8261ACF8 => {
    //   block [0x8261ACF8..0x8261AD20)
	// 8261ACF8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261ACFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AD00: 388B8854  addi r4, r11, -0x77ac
	ctx.r[4].s64 = ctx.r[11].s64 + -30636;
	// 8261AD04: 4BCF558D  bl 0x82310290
	ctx.lr = 0x8261AD08;
	sub_82310290(ctx, base);
	// 8261AD08: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AD0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AD10: 419A0010  beq cr6, 0x8261ad20
	if ctx.cr[6].eq {
	pc = 0x8261AD20; continue 'dispatch;
	}
	// 8261AD14: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 8261AD18: 616A0002  ori r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u64 | 2;
	// 8261AD1C: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AD20; continue 'dispatch;
            }
            0x8261AD20 => {
    //   block [0x8261AD20..0x8261AD48)
	// 8261AD20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AD24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AD28: 388B886C  addi r4, r11, -0x7794
	ctx.r[4].s64 = ctx.r[11].s64 + -30612;
	// 8261AD2C: 4BCF5565  bl 0x82310290
	ctx.lr = 0x8261AD30;
	sub_82310290(ctx, base);
	// 8261AD30: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AD34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AD38: 419A0010  beq cr6, 0x8261ad48
	if ctx.cr[6].eq {
	pc = 0x8261AD48; continue 'dispatch;
	}
	// 8261AD3C: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 8261AD40: 616A0004  ori r10, r11, 4
	ctx.r[10].u64 = ctx.r[11].u64 | 4;
	// 8261AD44: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AD48; continue 'dispatch;
            }
            0x8261AD48 => {
    //   block [0x8261AD48..0x8261AD70)
	// 8261AD48: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AD4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AD50: 388B887C  addi r4, r11, -0x7784
	ctx.r[4].s64 = ctx.r[11].s64 + -30596;
	// 8261AD54: 4BCF553D  bl 0x82310290
	ctx.lr = 0x8261AD58;
	sub_82310290(ctx, base);
	// 8261AD58: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AD5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AD60: 419A0010  beq cr6, 0x8261ad70
	if ctx.cr[6].eq {
	pc = 0x8261AD70; continue 'dispatch;
	}
	// 8261AD64: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 8261AD68: 616A0008  ori r10, r11, 8
	ctx.r[10].u64 = ctx.r[11].u64 | 8;
	// 8261AD6C: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AD70; continue 'dispatch;
            }
            0x8261AD70 => {
    //   block [0x8261AD70..0x8261AD98)
	// 8261AD70: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AD74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AD78: 388B8890  addi r4, r11, -0x7770
	ctx.r[4].s64 = ctx.r[11].s64 + -30576;
	// 8261AD7C: 4BCF5515  bl 0x82310290
	ctx.lr = 0x8261AD80;
	sub_82310290(ctx, base);
	// 8261AD80: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AD84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AD88: 419A0010  beq cr6, 0x8261ad98
	if ctx.cr[6].eq {
	pc = 0x8261AD98; continue 'dispatch;
	}
	// 8261AD8C: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 8261AD90: 616A0010  ori r10, r11, 0x10
	ctx.r[10].u64 = ctx.r[11].u64 | 16;
	// 8261AD94: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AD98; continue 'dispatch;
            }
            0x8261AD98 => {
    //   block [0x8261AD98..0x8261ADE0)
	// 8261AD98: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AD9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261ADA0: 38EB889C  addi r7, r11, -0x7764
	ctx.r[7].s64 = ctx.r[11].s64 + -30564;
	// 8261ADA4: 4BB97755  bl 0x821b24f8
	ctx.lr = 0x8261ADA8;
	sub_821B24F8(ctx, base);
	// 8261ADA8: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261ADAC: 4BC8EC3D  bl 0x822a99e8
	ctx.lr = 0x8261ADB0;
	sub_822A99E8(ctx, base);
	// 8261ADB0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261ADB4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261ADB8: 419A0168  beq cr6, 0x8261af20
	if ctx.cr[6].eq {
	pc = 0x8261AF20; continue 'dispatch;
	}
	// 8261ADBC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261ADC0: 388B88AC  addi r4, r11, -0x7754
	ctx.r[4].s64 = ctx.r[11].s64 + -30548;
	// 8261ADC4: 4BCF54CD  bl 0x82310290
	ctx.lr = 0x8261ADC8;
	sub_82310290(ctx, base);
	// 8261ADC8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261ADCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261ADD0: 419A0010  beq cr6, 0x8261ade0
	if ctx.cr[6].eq {
	pc = 0x8261ADE0; continue 'dispatch;
	}
	// 8261ADD4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261ADD8: 616A0001  ori r10, r11, 1
	ctx.r[10].u64 = ctx.r[11].u64 | 1;
	// 8261ADDC: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	pc = 0x8261ADE0; continue 'dispatch;
            }
            0x8261ADE0 => {
    //   block [0x8261ADE0..0x8261AE08)
	// 8261ADE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261ADE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261ADE8: 388B88C8  addi r4, r11, -0x7738
	ctx.r[4].s64 = ctx.r[11].s64 + -30520;
	// 8261ADEC: 4BCF54A5  bl 0x82310290
	ctx.lr = 0x8261ADF0;
	sub_82310290(ctx, base);
	// 8261ADF0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261ADF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261ADF8: 419A0010  beq cr6, 0x8261ae08
	if ctx.cr[6].eq {
	pc = 0x8261AE08; continue 'dispatch;
	}
	// 8261ADFC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261AE00: 616A0002  ori r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u64 | 2;
	// 8261AE04: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AE08; continue 'dispatch;
            }
            0x8261AE08 => {
    //   block [0x8261AE08..0x8261AE30)
	// 8261AE08: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AE0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AE10: 388B88E8  addi r4, r11, -0x7718
	ctx.r[4].s64 = ctx.r[11].s64 + -30488;
	// 8261AE14: 4BCF547D  bl 0x82310290
	ctx.lr = 0x8261AE18;
	sub_82310290(ctx, base);
	// 8261AE18: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AE1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AE20: 419A0010  beq cr6, 0x8261ae30
	if ctx.cr[6].eq {
	pc = 0x8261AE30; continue 'dispatch;
	}
	// 8261AE24: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261AE28: 616A0004  ori r10, r11, 4
	ctx.r[10].u64 = ctx.r[11].u64 | 4;
	// 8261AE2C: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AE30; continue 'dispatch;
            }
            0x8261AE30 => {
    //   block [0x8261AE30..0x8261AE58)
	// 8261AE30: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AE34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AE38: 388B8904  addi r4, r11, -0x76fc
	ctx.r[4].s64 = ctx.r[11].s64 + -30460;
	// 8261AE3C: 4BCF5455  bl 0x82310290
	ctx.lr = 0x8261AE40;
	sub_82310290(ctx, base);
	// 8261AE40: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AE44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AE48: 419A0010  beq cr6, 0x8261ae58
	if ctx.cr[6].eq {
	pc = 0x8261AE58; continue 'dispatch;
	}
	// 8261AE4C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261AE50: 616A0008  ori r10, r11, 8
	ctx.r[10].u64 = ctx.r[11].u64 | 8;
	// 8261AE54: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AE58; continue 'dispatch;
            }
            0x8261AE58 => {
    //   block [0x8261AE58..0x8261AE80)
	// 8261AE58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AE5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AE60: 388B8914  addi r4, r11, -0x76ec
	ctx.r[4].s64 = ctx.r[11].s64 + -30444;
	// 8261AE64: 4BCF542D  bl 0x82310290
	ctx.lr = 0x8261AE68;
	sub_82310290(ctx, base);
	// 8261AE68: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AE6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AE70: 419A0010  beq cr6, 0x8261ae80
	if ctx.cr[6].eq {
	pc = 0x8261AE80; continue 'dispatch;
	}
	// 8261AE74: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261AE78: 616A0010  ori r10, r11, 0x10
	ctx.r[10].u64 = ctx.r[11].u64 | 16;
	// 8261AE7C: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AE80; continue 'dispatch;
            }
            0x8261AE80 => {
    //   block [0x8261AE80..0x8261AEA8)
	// 8261AE80: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AE84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AE88: 388B891C  addi r4, r11, -0x76e4
	ctx.r[4].s64 = ctx.r[11].s64 + -30436;
	// 8261AE8C: 4BCF5405  bl 0x82310290
	ctx.lr = 0x8261AE90;
	sub_82310290(ctx, base);
	// 8261AE90: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AE94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AE98: 419A0010  beq cr6, 0x8261aea8
	if ctx.cr[6].eq {
	pc = 0x8261AEA8; continue 'dispatch;
	}
	// 8261AE9C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261AEA0: 616A0020  ori r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 | 32;
	// 8261AEA4: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AEA8; continue 'dispatch;
            }
            0x8261AEA8 => {
    //   block [0x8261AEA8..0x8261AED0)
	// 8261AEA8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AEAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AEB0: 388B8924  addi r4, r11, -0x76dc
	ctx.r[4].s64 = ctx.r[11].s64 + -30428;
	// 8261AEB4: 4BCF53DD  bl 0x82310290
	ctx.lr = 0x8261AEB8;
	sub_82310290(ctx, base);
	// 8261AEB8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AEBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AEC0: 419A0010  beq cr6, 0x8261aed0
	if ctx.cr[6].eq {
	pc = 0x8261AED0; continue 'dispatch;
	}
	// 8261AEC4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261AEC8: 616A0040  ori r10, r11, 0x40
	ctx.r[10].u64 = ctx.r[11].u64 | 64;
	// 8261AECC: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AED0; continue 'dispatch;
            }
            0x8261AED0 => {
    //   block [0x8261AED0..0x8261AEF8)
	// 8261AED0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AED4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AED8: 388B8930  addi r4, r11, -0x76d0
	ctx.r[4].s64 = ctx.r[11].s64 + -30416;
	// 8261AEDC: 4BCF53B5  bl 0x82310290
	ctx.lr = 0x8261AEE0;
	sub_82310290(ctx, base);
	// 8261AEE0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AEE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AEE8: 419A0010  beq cr6, 0x8261aef8
	if ctx.cr[6].eq {
	pc = 0x8261AEF8; continue 'dispatch;
	}
	// 8261AEEC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261AEF0: 616A0080  ori r10, r11, 0x80
	ctx.r[10].u64 = ctx.r[11].u64 | 128;
	// 8261AEF4: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AEF8; continue 'dispatch;
            }
            0x8261AEF8 => {
    //   block [0x8261AEF8..0x8261AF20)
	// 8261AEF8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261AEFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AF00: 388B8940  addi r4, r11, -0x76c0
	ctx.r[4].s64 = ctx.r[11].s64 + -30400;
	// 8261AF04: 4BCF538D  bl 0x82310290
	ctx.lr = 0x8261AF08;
	sub_82310290(ctx, base);
	// 8261AF08: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AF0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AF10: 419A0010  beq cr6, 0x8261af20
	if ctx.cr[6].eq {
	pc = 0x8261AF20; continue 'dispatch;
	}
	// 8261AF14: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261AF18: 616A0100  ori r10, r11, 0x100
	ctx.r[10].u64 = ctx.r[11].u64 | 256;
	// 8261AF1C: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AF20; continue 'dispatch;
            }
            0x8261AF20 => {
    //   block [0x8261AF20..0x8261AF68)
	// 8261AF20: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8261AF24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261AF28: 38EB9B80  addi r7, r11, -0x6480
	ctx.r[7].s64 = ctx.r[11].s64 + -25728;
	// 8261AF2C: 4BB975CD  bl 0x821b24f8
	ctx.lr = 0x8261AF30;
	sub_821B24F8(ctx, base);
	// 8261AF30: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261AF34: 4BC8EAB5  bl 0x822a99e8
	ctx.lr = 0x8261AF38;
	sub_822A99E8(ctx, base);
	// 8261AF38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261AF3C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261AF40: 419A0118  beq cr6, 0x8261b058
	if ctx.cr[6].eq {
	pc = 0x8261B058; continue 'dispatch;
	}
	// 8261AF44: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8261AF48: 388B9B8C  addi r4, r11, -0x6474
	ctx.r[4].s64 = ctx.r[11].s64 + -25716;
	// 8261AF4C: 4BCF5345  bl 0x82310290
	ctx.lr = 0x8261AF50;
	sub_82310290(ctx, base);
	// 8261AF50: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AF54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AF58: 419A0010  beq cr6, 0x8261af68
	if ctx.cr[6].eq {
	pc = 0x8261AF68; continue 'dispatch;
	}
	// 8261AF5C: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 8261AF60: 616A0001  ori r10, r11, 1
	ctx.r[10].u64 = ctx.r[11].u64 | 1;
	// 8261AF64: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AF68; continue 'dispatch;
            }
            0x8261AF68 => {
    //   block [0x8261AF68..0x8261AF90)
	// 8261AF68: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8261AF6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AF70: 388B9B9C  addi r4, r11, -0x6464
	ctx.r[4].s64 = ctx.r[11].s64 + -25700;
	// 8261AF74: 4BCF531D  bl 0x82310290
	ctx.lr = 0x8261AF78;
	sub_82310290(ctx, base);
	// 8261AF78: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AF7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AF80: 419A0010  beq cr6, 0x8261af90
	if ctx.cr[6].eq {
	pc = 0x8261AF90; continue 'dispatch;
	}
	// 8261AF84: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 8261AF88: 616A0002  ori r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u64 | 2;
	// 8261AF8C: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AF90; continue 'dispatch;
            }
            0x8261AF90 => {
    //   block [0x8261AF90..0x8261AFB8)
	// 8261AF90: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8261AF94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AF98: 388B9BAC  addi r4, r11, -0x6454
	ctx.r[4].s64 = ctx.r[11].s64 + -25684;
	// 8261AF9C: 4BCF52F5  bl 0x82310290
	ctx.lr = 0x8261AFA0;
	sub_82310290(ctx, base);
	// 8261AFA0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AFA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AFA8: 419A0010  beq cr6, 0x8261afb8
	if ctx.cr[6].eq {
	pc = 0x8261AFB8; continue 'dispatch;
	}
	// 8261AFAC: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 8261AFB0: 616A0004  ori r10, r11, 4
	ctx.r[10].u64 = ctx.r[11].u64 | 4;
	// 8261AFB4: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AFB8; continue 'dispatch;
            }
            0x8261AFB8 => {
    //   block [0x8261AFB8..0x8261AFE0)
	// 8261AFB8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8261AFBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AFC0: 388B9BBC  addi r4, r11, -0x6444
	ctx.r[4].s64 = ctx.r[11].s64 + -25668;
	// 8261AFC4: 4BCF52CD  bl 0x82310290
	ctx.lr = 0x8261AFC8;
	sub_82310290(ctx, base);
	// 8261AFC8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AFCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AFD0: 419A0010  beq cr6, 0x8261afe0
	if ctx.cr[6].eq {
	pc = 0x8261AFE0; continue 'dispatch;
	}
	// 8261AFD4: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 8261AFD8: 616A0008  ori r10, r11, 8
	ctx.r[10].u64 = ctx.r[11].u64 | 8;
	// 8261AFDC: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	pc = 0x8261AFE0; continue 'dispatch;
            }
            0x8261AFE0 => {
    //   block [0x8261AFE0..0x8261B008)
	// 8261AFE0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8261AFE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261AFE8: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 8261AFEC: 4BCF52A5  bl 0x82310290
	ctx.lr = 0x8261AFF0;
	sub_82310290(ctx, base);
	// 8261AFF0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261AFF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261AFF8: 419A0010  beq cr6, 0x8261b008
	if ctx.cr[6].eq {
	pc = 0x8261B008; continue 'dispatch;
	}
	// 8261AFFC: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 8261B000: 616A0010  ori r10, r11, 0x10
	ctx.r[10].u64 = ctx.r[11].u64 | 16;
	// 8261B004: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	pc = 0x8261B008; continue 'dispatch;
            }
            0x8261B008 => {
    //   block [0x8261B008..0x8261B030)
	// 8261B008: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8261B00C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261B010: 388B9BD8  addi r4, r11, -0x6428
	ctx.r[4].s64 = ctx.r[11].s64 + -25640;
	// 8261B014: 4BCF527D  bl 0x82310290
	ctx.lr = 0x8261B018;
	sub_82310290(ctx, base);
	// 8261B018: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261B01C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261B020: 419A0010  beq cr6, 0x8261b030
	if ctx.cr[6].eq {
	pc = 0x8261B030; continue 'dispatch;
	}
	// 8261B024: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 8261B028: 616A0020  ori r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 | 32;
	// 8261B02C: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	pc = 0x8261B030; continue 'dispatch;
            }
            0x8261B030 => {
    //   block [0x8261B030..0x8261B058)
	// 8261B030: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8261B034: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261B038: 388B70AC  addi r4, r11, 0x70ac
	ctx.r[4].s64 = ctx.r[11].s64 + 28844;
	// 8261B03C: 4BCF5255  bl 0x82310290
	ctx.lr = 0x8261B040;
	sub_82310290(ctx, base);
	// 8261B040: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261B044: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261B048: 419A0010  beq cr6, 0x8261b058
	if ctx.cr[6].eq {
	pc = 0x8261B058; continue 'dispatch;
	}
	// 8261B04C: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 8261B050: 616A0040  ori r10, r11, 0x40
	ctx.r[10].u64 = ctx.r[11].u64 | 64;
	// 8261B054: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	pc = 0x8261B058; continue 'dispatch;
            }
            0x8261B058 => {
    //   block [0x8261B058..0x8261B0A0)
	// 8261B058: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261B05C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261B060: 38EB894C  addi r7, r11, -0x76b4
	ctx.r[7].s64 = ctx.r[11].s64 + -30388;
	// 8261B064: 4BB97495  bl 0x821b24f8
	ctx.lr = 0x8261B068;
	sub_821B24F8(ctx, base);
	// 8261B068: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8261B06C: 4BC8E97D  bl 0x822a99e8
	ctx.lr = 0x8261B070;
	sub_822A99E8(ctx, base);
	// 8261B070: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261B074: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261B078: 419A00FC  beq cr6, 0x8261b174
	if ctx.cr[6].eq {
	pc = 0x8261B174; continue 'dispatch;
	}
	// 8261B07C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261B080: 388B8960  addi r4, r11, -0x76a0
	ctx.r[4].s64 = ctx.r[11].s64 + -30368;
	// 8261B084: 4BCF520D  bl 0x82310290
	ctx.lr = 0x8261B088;
	sub_82310290(ctx, base);
	// 8261B088: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261B08C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261B090: 419A0010  beq cr6, 0x8261b0a0
	if ctx.cr[6].eq {
	pc = 0x8261B0A0; continue 'dispatch;
	}
	// 8261B094: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8261B098: 616A0001  ori r10, r11, 1
	ctx.r[10].u64 = ctx.r[11].u64 | 1;
	// 8261B09C: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	pc = 0x8261B0A0; continue 'dispatch;
            }
            0x8261B0A0 => {
    //   block [0x8261B0A0..0x8261B0C8)
	// 8261B0A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261B0A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261B0A8: 388B896C  addi r4, r11, -0x7694
	ctx.r[4].s64 = ctx.r[11].s64 + -30356;
	// 8261B0AC: 4BCF51E5  bl 0x82310290
	ctx.lr = 0x8261B0B0;
	sub_82310290(ctx, base);
	// 8261B0B0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261B0B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261B0B8: 419A0010  beq cr6, 0x8261b0c8
	if ctx.cr[6].eq {
	pc = 0x8261B0C8; continue 'dispatch;
	}
	// 8261B0BC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8261B0C0: 616A0002  ori r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u64 | 2;
	// 8261B0C4: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	pc = 0x8261B0C8; continue 'dispatch;
            }
            0x8261B0C8 => {
    //   block [0x8261B0C8..0x8261B0F0)
	// 8261B0C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261B0CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261B0D0: 388B897C  addi r4, r11, -0x7684
	ctx.r[4].s64 = ctx.r[11].s64 + -30340;
	// 8261B0D4: 4BCF51BD  bl 0x82310290
	ctx.lr = 0x8261B0D8;
	sub_82310290(ctx, base);
	// 8261B0D8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261B0DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261B0E0: 419A0010  beq cr6, 0x8261b0f0
	if ctx.cr[6].eq {
	pc = 0x8261B0F0; continue 'dispatch;
	}
	// 8261B0E4: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8261B0E8: 616A0004  ori r10, r11, 4
	ctx.r[10].u64 = ctx.r[11].u64 | 4;
	// 8261B0EC: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	pc = 0x8261B0F0; continue 'dispatch;
            }
            0x8261B0F0 => {
    //   block [0x8261B0F0..0x8261B118)
	// 8261B0F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261B0F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261B0F8: 388B8988  addi r4, r11, -0x7678
	ctx.r[4].s64 = ctx.r[11].s64 + -30328;
	// 8261B0FC: 4BCF5195  bl 0x82310290
	ctx.lr = 0x8261B100;
	sub_82310290(ctx, base);
	// 8261B100: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261B104: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261B108: 419A0010  beq cr6, 0x8261b118
	if ctx.cr[6].eq {
	pc = 0x8261B118; continue 'dispatch;
	}
	// 8261B10C: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8261B110: 616A0008  ori r10, r11, 8
	ctx.r[10].u64 = ctx.r[11].u64 | 8;
	// 8261B114: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	pc = 0x8261B118; continue 'dispatch;
            }
            0x8261B118 => {
    //   block [0x8261B118..0x8261B140)
	// 8261B118: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261B11C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261B120: 388B8998  addi r4, r11, -0x7668
	ctx.r[4].s64 = ctx.r[11].s64 + -30312;
	// 8261B124: 4BCF516D  bl 0x82310290
	ctx.lr = 0x8261B128;
	sub_82310290(ctx, base);
	// 8261B128: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261B12C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261B130: 419A0010  beq cr6, 0x8261b140
	if ctx.cr[6].eq {
	pc = 0x8261B140; continue 'dispatch;
	}
	// 8261B134: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8261B138: 616A0010  ori r10, r11, 0x10
	ctx.r[10].u64 = ctx.r[11].u64 | 16;
	// 8261B13C: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	pc = 0x8261B140; continue 'dispatch;
            }
            0x8261B140 => {
    //   block [0x8261B140..0x8261B174)
	// 8261B140: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261B144: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261B148: 388B89A8  addi r4, r11, -0x7658
	ctx.r[4].s64 = ctx.r[11].s64 + -30296;
	// 8261B14C: 4BCF5145  bl 0x82310290
	ctx.lr = 0x8261B150;
	sub_82310290(ctx, base);
	// 8261B150: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261B154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261B158: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261B15C: 419A001C  beq cr6, 0x8261b178
	if ctx.cr[6].eq {
	pc = 0x8261B178; continue 'dispatch;
	}
	// 8261B160: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8261B164: 616A0020  ori r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 | 32;
	// 8261B168: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 8261B16C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8261B170: 4868E2C8  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261B174 => {
    //   block [0x8261B174..0x8261B178)
	// 8261B174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8261B178; continue 'dispatch;
            }
            0x8261B178 => {
    //   block [0x8261B178..0x8261B180)
	// 8261B178: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8261B17C: 4868E2BC  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261B180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8261B180 size=676
    let mut pc: u32 = 0x8261B180;
    'dispatch: loop {
        match pc {
            0x8261B180 => {
    //   block [0x8261B180..0x8261B1AC)
	// 8261B180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261B184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261B188: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8261B18C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261B190: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261B194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261B198: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8261B19C: 4BC040BD  bl 0x8221f258
	ctx.lr = 0x8261B1A0;
	sub_8221F258(ctx, base);
	// 8261B1A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261B1A4: 419A0008  beq cr6, 0x8261b1ac
	if ctx.cr[6].eq {
	pc = 0x8261B1AC; continue 'dispatch;
	}
	// 8261B1A8: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x8261B1AC; continue 'dispatch;
            }
            0x8261B1AC => {
    //   block [0x8261B1AC..0x8261B1B8)
	// 8261B1AC: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261B1B0: 41820008  beq 0x8261b1b8
	if ctx.cr[0].eq {
	pc = 0x8261B1B8; continue 'dispatch;
	}
	// 8261B1B4: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x8261B1B8; continue 'dispatch;
            }
            0x8261B1B8 => {
    //   block [0x8261B1B8..0x8261B1D8)
	// 8261B1B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8261B1BC: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8261B1C0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8261B1C4: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 8261B1C8: 4BC04091  bl 0x8221f258
	ctx.lr = 0x8261B1CC;
	sub_8221F258(ctx, base);
	// 8261B1CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261B1D0: 419A0008  beq cr6, 0x8261b1d8
	if ctx.cr[6].eq {
	pc = 0x8261B1D8; continue 'dispatch;
	}
	// 8261B1D4: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x8261B1D8; continue 'dispatch;
            }
            0x8261B1D8 => {
    //   block [0x8261B1D8..0x8261B1E4)
	// 8261B1D8: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261B1DC: 41820008  beq 0x8261b1e4
	if ctx.cr[0].eq {
	pc = 0x8261B1E4; continue 'dispatch;
	}
	// 8261B1E0: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x8261B1E4; continue 'dispatch;
            }
            0x8261B1E4 => {
    //   block [0x8261B1E4..0x8261B200)
	// 8261B1E4: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 8261B1E8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8261B1EC: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 8261B1F0: 4BC04069  bl 0x8221f258
	ctx.lr = 0x8261B1F4;
	sub_8221F258(ctx, base);
	// 8261B1F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261B1F8: 419A0008  beq cr6, 0x8261b200
	if ctx.cr[6].eq {
	pc = 0x8261B200; continue 'dispatch;
	}
	// 8261B1FC: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x8261B200; continue 'dispatch;
            }
            0x8261B200 => {
    //   block [0x8261B200..0x8261B20C)
	// 8261B200: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261B204: 41820008  beq 0x8261b20c
	if ctx.cr[0].eq {
	pc = 0x8261B20C; continue 'dispatch;
	}
	// 8261B208: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x8261B20C; continue 'dispatch;
            }
            0x8261B20C => {
    //   block [0x8261B20C..0x8261B228)
	// 8261B20C: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 8261B210: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8261B214: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 8261B218: 4BC04041  bl 0x8221f258
	ctx.lr = 0x8261B21C;
	sub_8221F258(ctx, base);
	// 8261B21C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261B220: 419A0008  beq cr6, 0x8261b228
	if ctx.cr[6].eq {
	pc = 0x8261B228; continue 'dispatch;
	}
	// 8261B224: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x8261B228; continue 'dispatch;
            }
            0x8261B228 => {
    //   block [0x8261B228..0x8261B234)
	// 8261B228: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261B22C: 41820008  beq 0x8261b234
	if ctx.cr[0].eq {
	pc = 0x8261B234; continue 'dispatch;
	}
	// 8261B230: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x8261B234; continue 'dispatch;
            }
            0x8261B234 => {
    //   block [0x8261B234..0x8261B424)
	// 8261B234: 907F0028  stw r3, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 8261B238: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8261B23C: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 8261B240: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 8261B244: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 8261B248: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 8261B24C: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 8261B250: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 8261B254: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 8261B258: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 8261B25C: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8261B260: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 8261B264: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 8261B268: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 8261B26C: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 8261B270: 93DF0074  stw r30, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 8261B274: 93DF0078  stw r30, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 8261B278: 93DF007C  stw r30, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 8261B27C: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 8261B280: 93DF0088  stw r30, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 8261B284: 93DF008C  stw r30, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 8261B288: 93DF0094  stw r30, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 8261B28C: 93DF0098  stw r30, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 8261B290: 93DF009C  stw r30, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 8261B294: 93DF00A4  stw r30, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 8261B298: 93DF00A8  stw r30, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 8261B29C: 93DF00AC  stw r30, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 8261B2A0: 93DF00B4  stw r30, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	// 8261B2A4: 93DF00B8  stw r30, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[30].u32 ) };
	// 8261B2A8: 93DF00BC  stw r30, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[30].u32 ) };
	// 8261B2AC: 93DF00C4  stw r30, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	// 8261B2B0: 93DF00C8  stw r30, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[30].u32 ) };
	// 8261B2B4: 93DF00CC  stw r30, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[30].u32 ) };
	// 8261B2B8: 93DF00D4  stw r30, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[30].u32 ) };
	// 8261B2BC: 93DF00D8  stw r30, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 8261B2C0: 93DF00DC  stw r30, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[30].u32 ) };
	// 8261B2C4: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 8261B2C8: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 8261B2CC: 93DF00EC  stw r30, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[30].u32 ) };
	// 8261B2D0: 93DF00F4  stw r30, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[30].u32 ) };
	// 8261B2D4: 93DF00F8  stw r30, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[30].u32 ) };
	// 8261B2D8: 93DF00FC  stw r30, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[30].u32 ) };
	// 8261B2DC: 93DF0104  stw r30, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[30].u32 ) };
	// 8261B2E0: 93DF0108  stw r30, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[30].u32 ) };
	// 8261B2E4: 93DF010C  stw r30, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[30].u32 ) };
	// 8261B2E8: 93DF0114  stw r30, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[30].u32 ) };
	// 8261B2EC: 93DF0118  stw r30, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[30].u32 ) };
	// 8261B2F0: 93DF011C  stw r30, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[30].u32 ) };
	// 8261B2F4: 93DF0124  stw r30, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[30].u32 ) };
	// 8261B2F8: 93DF0128  stw r30, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[30].u32 ) };
	// 8261B2FC: 93DF012C  stw r30, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[30].u32 ) };
	// 8261B300: 93DF0134  stw r30, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[30].u32 ) };
	// 8261B304: 93DF0138  stw r30, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[30].u32 ) };
	// 8261B308: 93DF013C  stw r30, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[30].u32 ) };
	// 8261B30C: 93DF0144  stw r30, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[30].u32 ) };
	// 8261B310: 93DF0148  stw r30, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[30].u32 ) };
	// 8261B314: 93DF014C  stw r30, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[30].u32 ) };
	// 8261B318: 93DF0154  stw r30, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[30].u32 ) };
	// 8261B31C: 93DF0158  stw r30, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[30].u32 ) };
	// 8261B320: 93DF015C  stw r30, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[30].u32 ) };
	// 8261B324: 93DF0164  stw r30, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[30].u32 ) };
	// 8261B328: 93DF0168  stw r30, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[30].u32 ) };
	// 8261B32C: 93DF016C  stw r30, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[30].u32 ) };
	// 8261B330: 93DF0174  stw r30, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[30].u32 ) };
	// 8261B334: 93DF0178  stw r30, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[30].u32 ) };
	// 8261B338: 93DF017C  stw r30, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[30].u32 ) };
	// 8261B33C: 93DF0184  stw r30, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[30].u32 ) };
	// 8261B340: 93DF0188  stw r30, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[30].u32 ) };
	// 8261B344: 93DF018C  stw r30, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[30].u32 ) };
	// 8261B348: 93DF0194  stw r30, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[30].u32 ) };
	// 8261B34C: 93DF0198  stw r30, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[30].u32 ) };
	// 8261B350: 93DF019C  stw r30, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[30].u32 ) };
	// 8261B354: 93DF01A4  stw r30, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[30].u32 ) };
	// 8261B358: 93DF01A8  stw r30, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[30].u32 ) };
	// 8261B35C: 93DF01AC  stw r30, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[30].u32 ) };
	// 8261B360: 93DF01B4  stw r30, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[30].u32 ) };
	// 8261B364: 93DF01B8  stw r30, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[30].u32 ) };
	// 8261B368: 93DF01BC  stw r30, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[30].u32 ) };
	// 8261B36C: 93DF01C4  stw r30, 0x1c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), ctx.r[30].u32 ) };
	// 8261B370: 93DF01C8  stw r30, 0x1c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[30].u32 ) };
	// 8261B374: 93DF01CC  stw r30, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[30].u32 ) };
	// 8261B378: 394BB478  addi r10, r11, -0x4b88
	ctx.r[10].s64 = ctx.r[11].s64 + -19336;
	// 8261B37C: 93DF01D4  stw r30, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[30].u32 ) };
	// 8261B380: 93DF01D8  stw r30, 0x1d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), ctx.r[30].u32 ) };
	// 8261B384: C1ABB478  lfs f13, -0x4b88(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19336 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8261B388: 93DF01DC  stw r30, 0x1dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[30].u32 ) };
	// 8261B38C: 387F0260  addi r3, r31, 0x260
	ctx.r[3].s64 = ctx.r[31].s64 + 608;
	// 8261B390: 93DF01E4  stw r30, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[30].u32 ) };
	// 8261B394: 93DF01E8  stw r30, 0x1e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), ctx.r[30].u32 ) };
	// 8261B398: 93DF01EC  stw r30, 0x1ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[30].u32 ) };
	// 8261B39C: C00AE00C  lfs f0, -0x1ff4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8261B3A0: 93DF01F4  stw r30, 0x1f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), ctx.r[30].u32 ) };
	// 8261B3A4: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8261B3A8: 93DF01F8  stw r30, 0x1f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), ctx.r[30].u32 ) };
	// 8261B3AC: 93DF01FC  stw r30, 0x1fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), ctx.r[30].u32 ) };
	// 8261B3B0: 93DF0204  stw r30, 0x204(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), ctx.r[30].u32 ) };
	// 8261B3B4: 93DF0208  stw r30, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[30].u32 ) };
	// 8261B3B8: 93DF020C  stw r30, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[30].u32 ) };
	// 8261B3BC: 93DF0214  stw r30, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[30].u32 ) };
	// 8261B3C0: 93DF0218  stw r30, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[30].u32 ) };
	// 8261B3C4: 93DF021C  stw r30, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[30].u32 ) };
	// 8261B3C8: 93DF0224  stw r30, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[30].u32 ) };
	// 8261B3CC: 93DF0228  stw r30, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[30].u32 ) };
	// 8261B3D0: 93DF022C  stw r30, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[30].u32 ) };
	// 8261B3D4: 9BDF0230  stb r30, 0x230(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[30].u8 ) };
	// 8261B3D8: 93DF0234  stw r30, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[30].u32 ) };
	// 8261B3DC: 93DF0238  stw r30, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[30].u32 ) };
	// 8261B3E0: D19F023C  stfs f12, 0x23c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), tmp.u32 ) };
	// 8261B3E4: D01F0240  stfs f0, 0x240(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), tmp.u32 ) };
	// 8261B3E8: 93DF0250  stw r30, 0x250(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[30].u32 ) };
	// 8261B3EC: D01F0244  stfs f0, 0x244(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), tmp.u32 ) };
	// 8261B3F0: 93DF0254  stw r30, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[30].u32 ) };
	// 8261B3F4: D1BF0248  stfs f13, 0x248(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), tmp.u32 ) };
	// 8261B3F8: 93DF0258  stw r30, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[30].u32 ) };
	// 8261B3FC: D1BF024C  stfs f13, 0x24c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), tmp.u32 ) };
	// 8261B400: 93DF025C  stw r30, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[30].u32 ) };
	// 8261B404: 4BE64E35  bl 0x82480238
	ctx.lr = 0x8261B408;
	sub_82480238(ctx, base);
	// 8261B408: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261B40C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261B410: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261B414: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261B418: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8261B41C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261B420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261B428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261B428 size=240
    let mut pc: u32 = 0x8261B428;
    'dispatch: loop {
        match pc {
            0x8261B428 => {
    //   block [0x8261B428..0x8261B490)
	// 8261B428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261B42C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261B430: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8261B434: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261B438: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261B43C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8261B440: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261B444: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261B448: 419A00B4  beq cr6, 0x8261b4fc
	if ctx.cr[6].eq {
	pc = 0x8261B4FC; continue 'dispatch;
	}
	// 8261B44C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8261B450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261B454: 419A00A8  beq cr6, 0x8261b4fc
	if ctx.cr[6].eq {
	pc = 0x8261B4FC; continue 'dispatch;
	}
	// 8261B458: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8261B45C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8261B460: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261B464: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261B468: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261B46C: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261B470: 482CA609  bl 0x828e5a78
	ctx.lr = 0x8261B474;
	sub_828E5A78(ctx, base);
	// 8261B474: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261B478: 419A0018  beq cr6, 0x8261b490
	if ctx.cr[6].eq {
	pc = 0x8261B490; continue 'dispatch;
	}
	// 8261B47C: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8261B480: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8261B484: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261B488: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261B48C: 409A0008  bne cr6, 0x8261b494
	if !ctx.cr[6].eq {
	pc = 0x8261B494; continue 'dispatch;
	}
	pc = 0x8261B490; continue 'dispatch;
            }
            0x8261B490 => {
    //   block [0x8261B490..0x8261B494)
	// 8261B490: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8261B494; continue 'dispatch;
            }
            0x8261B494 => {
    //   block [0x8261B494..0x8261B4E8)
	// 8261B494: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261B498: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261B49C: 419A0060  beq cr6, 0x8261b4fc
	if ctx.cr[6].eq {
	pc = 0x8261B4FC; continue 'dispatch;
	}
	// 8261B4A0: 389F0048  addi r4, r31, 0x48
	ctx.r[4].s64 = ctx.r[31].s64 + 72;
	// 8261B4A4: 4BC1737D  bl 0x82232820
	ctx.lr = 0x8261B4A8;
	sub_82232820(ctx, base);
	// 8261B4A8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261B4AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261B4B0: 419A004C  beq cr6, 0x8261b4fc
	if ctx.cr[6].eq {
	pc = 0x8261B4FC; continue 'dispatch;
	}
	// 8261B4B4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8261B4B8: 3BFE0260  addi r31, r30, 0x260
	ctx.r[31].s64 = ctx.r[30].s64 + 608;
	// 8261B4BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8261B4C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261B4C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8261B4C8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8261B4CC: 4BD73A4D  bl 0x8238ef18
	ctx.lr = 0x8261B4D0;
	sub_8238EF18(ctx, base);
	// 8261B4D0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261B4D4: 815E0264  lwz r10, 0x264(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(612 as u32) ) } as u64;
	// 8261B4D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261B4DC: 419A000C  beq cr6, 0x8261b4e8
	if ctx.cr[6].eq {
	pc = 0x8261B4E8; continue 'dispatch;
	}
	// 8261B4E0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8261B4E4: 419A0008  beq cr6, 0x8261b4ec
	if ctx.cr[6].eq {
	pc = 0x8261B4EC; continue 'dispatch;
	}
	pc = 0x8261B4E8; continue 'dispatch;
            }
            0x8261B4E8 => {
    //   block [0x8261B4E8..0x8261B4EC)
	// 8261B4E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261B4EC; continue 'dispatch;
            }
            0x8261B4EC => {
    //   block [0x8261B4EC..0x8261B4FC)
	// 8261B4EC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8261B4F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8261B4F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261B4F8: 409A0008  bne cr6, 0x8261b500
	if !ctx.cr[6].eq {
	pc = 0x8261B500; continue 'dispatch;
	}
	pc = 0x8261B4FC; continue 'dispatch;
            }
            0x8261B4FC => {
    //   block [0x8261B4FC..0x8261B500)
	// 8261B4FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8261B500; continue 'dispatch;
            }
            0x8261B500 => {
    //   block [0x8261B500..0x8261B518)
	// 8261B500: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8261B504: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261B508: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261B50C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8261B510: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261B514: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261B518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261B518 size=528
    let mut pc: u32 = 0x8261B518;
    'dispatch: loop {
        match pc {
            0x8261B518 => {
    //   block [0x8261B518..0x8261B54C)
	// 8261B518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261B51C: 4868DED1  bl 0x82ca93ec
	ctx.lr = 0x8261B520;
	sub_82CA93D0(ctx, base);
	// 8261B520: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261B524: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 8261B528: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8261B52C: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 8261B530: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 8261B534: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261B538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261B53C: 409A0010  bne cr6, 0x8261b54c
	if !ctx.cr[6].eq {
	pc = 0x8261B54C; continue 'dispatch;
	}
	// 8261B540: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8261B544: 386BFFDF  addi r3, r11, -0x21
	ctx.r[3].s64 = ctx.r[11].s64 + -33;
	// 8261B548: 48000008  b 0x8261b550
	pc = 0x8261B550; continue 'dispatch;
            }
            0x8261B54C => {
    //   block [0x8261B54C..0x8261B550)
	// 8261B54C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261B550; continue 'dispatch;
            }
            0x8261B550 => {
    //   block [0x8261B550..0x8261B598)
	// 8261B550: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 8261B554: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 8261B558: 4BBD8801  bl 0x821f3d58
	ctx.lr = 0x8261B55C;
	sub_821F3D58(ctx, base);
	// 8261B55C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8261B560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261B564: 483E48F5  bl 0x829ffe58
	ctx.lr = 0x8261B568;
	sub_829FFE58(ctx, base);
	// 8261B568: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8261B56C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8261B570: 419A01A0  beq cr6, 0x8261b710
	if ctx.cr[6].eq {
	pc = 0x8261B710; continue 'dispatch;
	}
	// 8261B574: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261B578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261B57C: 419A001C  beq cr6, 0x8261b598
	if ctx.cr[6].eq {
	pc = 0x8261B598; continue 'dispatch;
	}
	// 8261B580: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261B584: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8261B588: 419A0010  beq cr6, 0x8261b598
	if ctx.cr[6].eq {
	pc = 0x8261B598; continue 'dispatch;
	}
	// 8261B58C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261B590: 4BC8E459  bl 0x822a99e8
	ctx.lr = 0x8261B594;
	sub_822A99E8(ctx, base);
	// 8261B594: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	pc = 0x8261B598; continue 'dispatch;
            }
            0x8261B598 => {
    //   block [0x8261B598..0x8261B5D4)
	// 8261B598: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8261B59C: 419A0174  beq cr6, 0x8261b710
	if ctx.cr[6].eq {
	pc = 0x8261B710; continue 'dispatch;
	}
	// 8261B5A0: 83FA0008  lwz r31, 8(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261B5A4: 3B200064  li r25, 0x64
	ctx.r[25].s64 = 100;
	// 8261B5A8: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261B5AC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8261B5B0: 419A0044  beq cr6, 0x8261b5f4
	if ctx.cr[6].eq {
	pc = 0x8261B5F4; continue 'dispatch;
	}
	// 8261B5B4: 7D5FF850  subf r10, r31, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[31].s64;
	// 8261B5B8: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 8261B5BC: 7D2ACBD6  divw r9, r10, r25
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[25].s32;
	// 8261B5C0: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8261B5C4: 1D490064  mulli r10, r9, 0x64
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * 100 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 8261B5C8: 7F8A5A14  add r28, r10, r11
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261B5CC: 419A0024  beq cr6, 0x8261b5f0
	if ctx.cr[6].eq {
	pc = 0x8261B5F0; continue 'dispatch;
	}
	// 8261B5D0: 7FBF5850  subf r29, r31, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	pc = 0x8261B5D4; continue 'dispatch;
            }
            0x8261B5D4 => {
    //   block [0x8261B5D4..0x8261B5F0)
	// 8261B5D4: 7C7DF214  add r3, r29, r30
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 8261B5D8: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 8261B5DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8261B5E0: 4868DEA1  bl 0x82ca9480
	ctx.lr = 0x8261B5E4;
	sub_82CA9480(ctx, base);
	// 8261B5E4: 3BDE0064  addi r30, r30, 0x64
	ctx.r[30].s64 = ctx.r[30].s64 + 100;
	// 8261B5E8: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8261B5EC: 409AFFE8  bne cr6, 0x8261b5d4
	if !ctx.cr[6].eq {
	pc = 0x8261B5D4; continue 'dispatch;
	}
	pc = 0x8261B5F0; continue 'dispatch;
            }
            0x8261B5F0 => {
    //   block [0x8261B5F0..0x8261B5F4)
	// 8261B5F0: 939A0008  stw r28, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x8261B5F4; continue 'dispatch;
            }
            0x8261B5F4 => {
    //   block [0x8261B5F4..0x8261B630)
	// 8261B5F4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8261B5F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261B5FC: 483E5395  bl 0x82a00990
	ctx.lr = 0x8261B600;
	sub_82A00990(ctx, base);
	// 8261B600: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8261B604: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261B608: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8261B60C: 4800237D  bl 0x8261d988
	ctx.lr = 0x8261B610;
	sub_8261D988(ctx, base);
	// 8261B610: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261B614: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261B618: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 8261B61C: 419A00EC  beq cr6, 0x8261b708
	if ctx.cr[6].eq {
	pc = 0x8261B708; continue 'dispatch;
	}
	// 8261B620: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261B624: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8261B628: 3EE0834A  lis r23, -0x7cb6
	ctx.r[23].s64 = -2092302336;
	// 8261B62C: 3B0BE460  addi r24, r11, -0x1ba0
	ctx.r[24].s64 = ctx.r[11].s64 + -7072;
	pc = 0x8261B630; continue 'dispatch;
            }
            0x8261B630 => {
    //   block [0x8261B630..0x8261B678)
	// 8261B630: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261B634: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 8261B638: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261B63C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 8261B640: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261B644: 2F0A0006  cmpwi cr6, r10, 6
	ctx.cr[6].compare_i32(ctx.r[10].s32, 6, &mut ctx.xer);
	// 8261B648: 409A00B4  bne cr6, 0x8261b6fc
	if !ctx.cr[6].eq {
	pc = 0x8261B6FC; continue 'dispatch;
	}
	// 8261B64C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261B650: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261B654: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8261B658: 419A0020  beq cr6, 0x8261b678
	if ctx.cr[6].eq {
	pc = 0x8261B678; continue 'dispatch;
	}
	// 8261B65C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8261B660: 409A0018  bne cr6, 0x8261b678
	if !ctx.cr[6].eq {
	pc = 0x8261B678; continue 'dispatch;
	}
	// 8261B664: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261B668: 8137E454  lwz r9, -0x1bac(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 8261B66C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8261B670: 409A0008  bne cr6, 0x8261b678
	if !ctx.cr[6].eq {
	pc = 0x8261B678; continue 'dispatch;
	}
	// 8261B674: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	pc = 0x8261B678; continue 'dispatch;
            }
            0x8261B678 => {
    //   block [0x8261B678..0x8261B6A4)
	// 8261B678: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261B67C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8261B680: 419A007C  beq cr6, 0x8261b6fc
	if ctx.cr[6].eq {
	pc = 0x8261B6FC; continue 'dispatch;
	}
	// 8261B684: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8261B688: 4BFFF069  bl 0x8261a6f0
	ctx.lr = 0x8261B68C;
	sub_8261A6F0(ctx, base);
	// 8261B68C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261B690: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8261B694: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261B698: 409A000C  bne cr6, 0x8261b6a4
	if !ctx.cr[6].eq {
	pc = 0x8261B6A4; continue 'dispatch;
	}
	// 8261B69C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 8261B6A0: 48000010  b 0x8261b6b0
	pc = 0x8261B6B0; continue 'dispatch;
            }
            0x8261B6A4 => {
    //   block [0x8261B6A4..0x8261B6B0)
	// 8261B6A4: 815A000C  lwz r10, 0xc(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261B6A8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8261B6AC: 7D49CBD6  divw r10, r9, r25
	ctx.r[10].s32 = ctx.r[9].s32 / ctx.r[25].s32;
	pc = 0x8261B6B0; continue 'dispatch;
            }
            0x8261B6B0 => {
    //   block [0x8261B6B0..0x8261B6D8)
	// 8261B6B0: 83FA0008  lwz r31, 8(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261B6B4: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 8261B6B8: 7D2BCBD6  divw r9, r11, r25
	ctx.r[9].s32 = ctx.r[11].s32 / ctx.r[25].s32;
	// 8261B6BC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261B6C0: 40980024  bge cr6, 0x8261b6e4
	if !ctx.cr[6].lt {
	pc = 0x8261B6E4; continue 'dispatch;
	}
	// 8261B6C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261B6C8: 419A0010  beq cr6, 0x8261b6d8
	if ctx.cr[6].eq {
	pc = 0x8261B6D8; continue 'dispatch;
	}
	// 8261B6CC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 8261B6D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261B6D4: 480028A5  bl 0x8261df78
	ctx.lr = 0x8261B6D8;
	sub_8261DF78(ctx, base);
	pc = 0x8261B6D8; continue 'dispatch;
            }
            0x8261B6D8 => {
    //   block [0x8261B6D8..0x8261B6E4)
	// 8261B6D8: 397F0064  addi r11, r31, 0x64
	ctx.r[11].s64 = ctx.r[31].s64 + 100;
	// 8261B6DC: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8261B6E0: 4800001C  b 0x8261b6fc
	pc = 0x8261B6FC; continue 'dispatch;
            }
            0x8261B6E4 => {
    //   block [0x8261B6E4..0x8261B6FC)
	// 8261B6E4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8261B6E8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8261B6EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8261B6F0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8261B6F4: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8261B6F8: 480025A1  bl 0x8261dc98
	ctx.lr = 0x8261B6FC;
	sub_8261DC98(ctx, base);
	pc = 0x8261B6FC; continue 'dispatch;
            }
            0x8261B6FC => {
    //   block [0x8261B6FC..0x8261B708)
	// 8261B6FC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8261B700: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 8261B704: 409AFF2C  bne cr6, 0x8261b630
	if !ctx.cr[6].eq {
	pc = 0x8261B630; continue 'dispatch;
	}
	pc = 0x8261B708; continue 'dispatch;
            }
            0x8261B708 => {
    //   block [0x8261B708..0x8261B710)
	// 8261B708: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8261B70C: 4BC0062D  bl 0x8221bd38
	ctx.lr = 0x8261B710;
	sub_8221BD38(ctx, base);
	pc = 0x8261B710; continue 'dispatch;
            }
            0x8261B710 => {
    //   block [0x8261B710..0x8261B728)
	// 8261B710: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 8261B714: 4BBF96C5  bl 0x82214dd8
	ctx.lr = 0x8261B718;
	sub_82214DD8(ctx, base);
	// 8261B718: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 8261B71C: 4BBF96BD  bl 0x82214dd8
	ctx.lr = 0x8261B720;
	sub_82214DD8(ctx, base);
	// 8261B720: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 8261B724: 4868DD18  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261B728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261B728 size=148
    let mut pc: u32 = 0x8261B728;
    'dispatch: loop {
        match pc {
            0x8261B728 => {
    //   block [0x8261B728..0x8261B76C)
	// 8261B728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261B72C: 4868DCE1  bl 0x82ca940c
	ctx.lr = 0x8261B730;
	sub_82CA93D0(ctx, base);
	// 8261B730: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261B734: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8261B738: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8261B73C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8261B740: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8261B744: 4BC03B15  bl 0x8221f258
	ctx.lr = 0x8261B748;
	sub_8221F258(ctx, base);
	// 8261B748: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261B74C: 419A0020  beq cr6, 0x8261b76c
	if ctx.cr[6].eq {
	pc = 0x8261B76C; continue 'dispatch;
	}
	// 8261B750: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8261B754: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8261B758: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8261B75C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8261B760: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 8261B764: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8261B768: 48000008  b 0x8261b770
	pc = 0x8261B770; continue 'dispatch;
            }
            0x8261B76C => {
    //   block [0x8261B76C..0x8261B770)
	// 8261B76C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8261B770; continue 'dispatch;
            }
            0x8261B770 => {
    //   block [0x8261B770..0x8261B788)
	// 8261B770: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8261B774: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261B778: 419A0010  beq cr6, 0x8261b788
	if ctx.cr[6].eq {
	pc = 0x8261B788; continue 'dispatch;
	}
	// 8261B77C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261B780: 4BE64521  bl 0x8247fca0
	ctx.lr = 0x8261B784;
	sub_8247FCA0(ctx, base);
	// 8261B784: 4800000C  b 0x8261b790
	pc = 0x8261B790; continue 'dispatch;
            }
            0x8261B788 => {
    //   block [0x8261B788..0x8261B790)
	// 8261B788: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8261B78C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x8261B790; continue 'dispatch;
            }
            0x8261B790 => {
    //   block [0x8261B790..0x8261B7BC)
	// 8261B790: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 8261B794: 387D000C  addi r3, r29, 0xc
	ctx.r[3].s64 = ctx.r[29].s64 + 12;
	// 8261B798: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8261B79C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 8261B7A0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8261B7A4: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261B7A8: 48002341  bl 0x8261dae8
	ctx.lr = 0x8261B7AC;
	sub_8261DAE8(ctx, base);
	// 8261B7AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261B7B0: 4BB9C369  bl 0x821b7b18
	ctx.lr = 0x8261B7B4;
	sub_821B7B18(ctx, base);
	// 8261B7B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8261B7B8: 4868DCA4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261B7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261B7C0 size=148
    let mut pc: u32 = 0x8261B7C0;
    'dispatch: loop {
        match pc {
            0x8261B7C0 => {
    //   block [0x8261B7C0..0x8261B804)
	// 8261B7C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261B7C4: 4868DC49  bl 0x82ca940c
	ctx.lr = 0x8261B7C8;
	sub_82CA93D0(ctx, base);
	// 8261B7C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261B7CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8261B7D0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8261B7D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8261B7D8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8261B7DC: 4BC03A7D  bl 0x8221f258
	ctx.lr = 0x8261B7E0;
	sub_8221F258(ctx, base);
	// 8261B7E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261B7E4: 419A0020  beq cr6, 0x8261b804
	if ctx.cr[6].eq {
	pc = 0x8261B804; continue 'dispatch;
	}
	// 8261B7E8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8261B7EC: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8261B7F0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8261B7F4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8261B7F8: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 8261B7FC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8261B800: 48000008  b 0x8261b808
	pc = 0x8261B808; continue 'dispatch;
            }
            0x8261B804 => {
    //   block [0x8261B804..0x8261B808)
	// 8261B804: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8261B808; continue 'dispatch;
            }
            0x8261B808 => {
    //   block [0x8261B808..0x8261B820)
	// 8261B808: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8261B80C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261B810: 419A0010  beq cr6, 0x8261b820
	if ctx.cr[6].eq {
	pc = 0x8261B820; continue 'dispatch;
	}
	// 8261B814: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261B818: 4BE64489  bl 0x8247fca0
	ctx.lr = 0x8261B81C;
	sub_8247FCA0(ctx, base);
	// 8261B81C: 4800000C  b 0x8261b828
	pc = 0x8261B828; continue 'dispatch;
            }
            0x8261B820 => {
    //   block [0x8261B820..0x8261B828)
	// 8261B820: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8261B824: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x8261B828; continue 'dispatch;
            }
            0x8261B828 => {
    //   block [0x8261B828..0x8261B854)
	// 8261B828: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 8261B82C: 387D0018  addi r3, r29, 0x18
	ctx.r[3].s64 = ctx.r[29].s64 + 24;
	// 8261B830: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8261B834: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 8261B838: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8261B83C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261B840: 480022A9  bl 0x8261dae8
	ctx.lr = 0x8261B844;
	sub_8261DAE8(ctx, base);
	// 8261B844: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261B848: 4BB9C2D1  bl 0x821b7b18
	ctx.lr = 0x8261B84C;
	sub_821B7B18(ctx, base);
	// 8261B84C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8261B850: 4868DC0C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261B858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8261B858 size=244
    let mut pc: u32 = 0x8261B858;
    'dispatch: loop {
        match pc {
            0x8261B858 => {
    //   block [0x8261B858..0x8261B87C)
	// 8261B858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261B85C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261B860: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 8261B864: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261B868: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8261B86C: 419A00C4  beq cr6, 0x8261b930
	if ctx.cr[6].eq {
	pc = 0x8261B930; continue 'dispatch;
	}
	// 8261B870: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 8261B874: 3923000C  addi r9, r3, 0xc
	ctx.r[9].s64 = ctx.r[3].s64 + 12;
	// 8261B878: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	pc = 0x8261B87C; continue 'dispatch;
            }
            0x8261B87C => {
    //   block [0x8261B87C..0x8261B88C)
	// 8261B87C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261B880: 7F094840  cmplw cr6, r9, r9
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8261B884: 419A0008  beq cr6, 0x8261b88c
	if ctx.cr[6].eq {
	pc = 0x8261B88C; continue 'dispatch;
	}
	// 8261B888: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261B88C; continue 'dispatch;
            }
            0x8261B88C => {
    //   block [0x8261B88C..0x8261B8A4)
	// 8261B88C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8261B890: 419A00A0  beq cr6, 0x8261b930
	if ctx.cr[6].eq {
	pc = 0x8261B930; continue 'dispatch;
	}
	// 8261B894: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261B898: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261B89C: 409A0008  bne cr6, 0x8261b8a4
	if !ctx.cr[6].eq {
	pc = 0x8261B8A4; continue 'dispatch;
	}
	// 8261B8A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261B8A4; continue 'dispatch;
            }
            0x8261B8A4 => {
    //   block [0x8261B8A4..0x8261B8C4)
	// 8261B8A4: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261B8A8: 80C70008  lwz r6, 8(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261B8AC: 7F062040  cmplw cr6, r6, r4
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[4].u32, &mut ctx.xer);
	// 8261B8B0: 419A0014  beq cr6, 0x8261b8c4
	if ctx.cr[6].eq {
	pc = 0x8261B8C4; continue 'dispatch;
	}
	// 8261B8B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261B8B8: 409AFFC4  bne cr6, 0x8261b87c
	if !ctx.cr[6].eq {
	pc = 0x8261B87C; continue 'dispatch;
	}
	// 8261B8BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8261B8C0: 4BFFFFBC  b 0x8261b87c
	pc = 0x8261B87C; continue 'dispatch;
            }
            0x8261B8C4 => {
    //   block [0x8261B8C4..0x8261B8D4)
	// 8261B8C4: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261B8C8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261B8CC: 409A0008  bne cr6, 0x8261b8d4
	if !ctx.cr[6].eq {
	pc = 0x8261B8D4; continue 'dispatch;
	}
	// 8261B8D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261B8D4; continue 'dispatch;
            }
            0x8261B8D4 => {
    //   block [0x8261B8D4..0x8261B8EC)
	// 8261B8D4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261B8D8: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261B8DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261B8E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8261B8E4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8261B8E8: 419A0020  beq cr6, 0x8261b908
	if ctx.cr[6].eq {
	pc = 0x8261B908; continue 'dispatch;
	}
	pc = 0x8261B8EC; continue 'dispatch;
            }
            0x8261B8EC => {
    //   block [0x8261B8EC..0x8261B908)
	// 8261B8EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8261B8F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261B8F4: 7D605028  lwarx r11, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8261B8F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8261B8FC: 7D60512D  stwcx. r11, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8261B900: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261B904: 4082FFE8  bne 0x8261b8ec
	if !ctx.cr[0].eq {
	pc = 0x8261B8EC; continue 'dispatch;
	}
	pc = 0x8261B908; continue 'dispatch;
            }
            0x8261B908 => {
    //   block [0x8261B908..0x8261B930)
	// 8261B908: 4BC4B8F9  bl 0x82267200
	ctx.lr = 0x8261B90C;
	sub_82267200(ctx, base);
	// 8261B90C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261B910: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8261B914: 4BB9C205  bl 0x821b7b18
	ctx.lr = 0x8261B918;
	sub_821B7B18(ctx, base);
	// 8261B918: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8261B91C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261B920: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261B924: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261B928: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261B92C: 4E800020  blr
	return;
            }
            0x8261B930 => {
    //   block [0x8261B930..0x8261B94C)
	// 8261B930: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8261B934: C02B9490  lfs f1, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8261B938: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261B93C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261B940: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261B944: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261B948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261B950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261B950 size=348
    let mut pc: u32 = 0x8261B950;
    'dispatch: loop {
        match pc {
            0x8261B950 => {
    //   block [0x8261B950..0x8261B994)
	// 8261B950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261B954: 4868DAB9  bl 0x82ca940c
	ctx.lr = 0x8261B958;
	sub_82CA93D0(ctx, base);
	// 8261B958: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261B95C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8261B960: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261B964: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8261B968: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261B96C: 388B02EC  addi r4, r11, 0x2ec
	ctx.r[4].s64 = ctx.r[11].s64 + 748;
	// 8261B970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261B974: 4BC1155D  bl 0x8222ced0
	ctx.lr = 0x8261B978;
	sub_8222CED0(ctx, base);
	// 8261B978: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8261B97C: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 8261B980: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261B984: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261B988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261B98C: 419A0008  beq cr6, 0x8261b994
	if ctx.cr[6].eq {
	pc = 0x8261B994; continue 'dispatch;
	}
	// 8261B990: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261B994; continue 'dispatch;
            }
            0x8261B994 => {
    //   block [0x8261B994..0x8261B9FC)
	// 8261B994: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8261B998: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261B99C: 4BD746ED  bl 0x82390088
	ctx.lr = 0x8261B9A0;
	sub_82390088(ctx, base);
	// 8261B9A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261B9A4: 4BBF9435  bl 0x82214dd8
	ctx.lr = 0x8261B9A8;
	sub_82214DD8(ctx, base);
	// 8261B9A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261B9AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261B9B0: 388B8BA0  addi r4, r11, -0x7460
	ctx.r[4].s64 = ctx.r[11].s64 + -29792;
	// 8261B9B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261B9B8: 4BC11519  bl 0x8222ced0
	ctx.lr = 0x8261B9BC;
	sub_8222CED0(ctx, base);
	// 8261B9BC: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 8261B9C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8261B9C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261B9C8: 48401481  bl 0x82a1ce48
	ctx.lr = 0x8261B9CC;
	sub_82A1CE48(ctx, base);
	// 8261B9CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261B9D0: 4BBF9409  bl 0x82214dd8
	ctx.lr = 0x8261B9D4;
	sub_82214DD8(ctx, base);
	// 8261B9D4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261B9D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261B9DC: 388A8BAC  addi r4, r10, -0x7454
	ctx.r[4].s64 = ctx.r[10].s64 + -29780;
	// 8261B9E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261B9E4: 4BC114ED  bl 0x8222ced0
	ctx.lr = 0x8261B9E8;
	sub_8222CED0(ctx, base);
	// 8261B9E8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261B9EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261B9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261B9F4: 419A0008  beq cr6, 0x8261b9fc
	if ctx.cr[6].eq {
	pc = 0x8261B9FC; continue 'dispatch;
	}
	// 8261B9F8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261B9FC; continue 'dispatch;
            }
            0x8261B9FC => {
    //   block [0x8261B9FC..0x8261BA38)
	// 8261B9FC: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 8261BA00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261BA04: 4BE64E4D  bl 0x82480850
	ctx.lr = 0x8261BA08;
	sub_82480850(ctx, base);
	// 8261BA08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261BA0C: 4BBF93CD  bl 0x82214dd8
	ctx.lr = 0x8261BA10;
	sub_82214DD8(ctx, base);
	// 8261BA10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261BA14: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261BA18: 388B8BB8  addi r4, r11, -0x7448
	ctx.r[4].s64 = ctx.r[11].s64 + -29768;
	// 8261BA1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261BA20: 4BC114B1  bl 0x8222ced0
	ctx.lr = 0x8261BA24;
	sub_8222CED0(ctx, base);
	// 8261BA24: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261BA28: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261BA2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261BA30: 419A0008  beq cr6, 0x8261ba38
	if ctx.cr[6].eq {
	pc = 0x8261BA38; continue 'dispatch;
	}
	// 8261BA34: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261BA38; continue 'dispatch;
            }
            0x8261BA38 => {
    //   block [0x8261BA38..0x8261BAAC)
	// 8261BA38: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 8261BA3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261BA40: 4BE64D89  bl 0x824807c8
	ctx.lr = 0x8261BA44;
	sub_824807C8(ctx, base);
	// 8261BA44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261BA48: 4BBF9391  bl 0x82214dd8
	ctx.lr = 0x8261BA4C;
	sub_82214DD8(ctx, base);
	// 8261BA4C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261BA50: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261BA54: 388B8BC8  addi r4, r11, -0x7438
	ctx.r[4].s64 = ctx.r[11].s64 + -29752;
	// 8261BA58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261BA5C: 4BC11475  bl 0x8222ced0
	ctx.lr = 0x8261BA60;
	sub_8222CED0(ctx, base);
	// 8261BA60: 38BF0005  addi r5, r31, 5
	ctx.r[5].s64 = ctx.r[31].s64 + 5;
	// 8261BA64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8261BA68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261BA6C: 484013DD  bl 0x82a1ce48
	ctx.lr = 0x8261BA70;
	sub_82A1CE48(ctx, base);
	// 8261BA70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261BA74: 4BBF9365  bl 0x82214dd8
	ctx.lr = 0x8261BA78;
	sub_82214DD8(ctx, base);
	// 8261BA78: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261BA7C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261BA80: 388A8BE0  addi r4, r10, -0x7420
	ctx.r[4].s64 = ctx.r[10].s64 + -29728;
	// 8261BA84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261BA88: 4BC11449  bl 0x8222ced0
	ctx.lr = 0x8261BA8C;
	sub_8222CED0(ctx, base);
	// 8261BA8C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8261BA90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8261BA94: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 8261BA98: 4BE96D21  bl 0x824b27b8
	ctx.lr = 0x8261BA9C;
	sub_824B27B8(ctx, base);
	// 8261BA9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261BAA0: 4BBF9339  bl 0x82214dd8
	ctx.lr = 0x8261BAA4;
	sub_82214DD8(ctx, base);
	// 8261BAA4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8261BAA8: 4868D9B4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261BAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8261BAB0 size=204
    let mut pc: u32 = 0x8261BAB0;
    'dispatch: loop {
        match pc {
            0x8261BAB0 => {
    //   block [0x8261BAB0..0x8261BB28)
	// 8261BAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261BAB4: 4868D94D  bl 0x82ca9400
	ctx.lr = 0x8261BAB8;
	sub_82CA93D0(ctx, base);
	// 8261BAB8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8261BABC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261BAC0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8261BAC4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8261BAC8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8261BACC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8261BAD0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8261BAD4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8261BAD8: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8261BADC: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 8261BAE0: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 8261BAE4: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 8261BAE8: 419A0088  beq cr6, 0x8261bb70
	if ctx.cr[6].eq {
	pc = 0x8261BB70; continue 'dispatch;
	}
	// 8261BAEC: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8261BAF0: 4BC03769  bl 0x8221f258
	ctx.lr = 0x8261BAF4;
	sub_8221F258(ctx, base);
	// 8261BAF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261BAF8: 419A0030  beq cr6, 0x8261bb28
	if ctx.cr[6].eq {
	pc = 0x8261BB28; continue 'dispatch;
	}
	// 8261BAFC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261BB00: D3E30008  stfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8261BB04: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261BB08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8261BB0C: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8261BB10: 9BA30004  stb r29, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u8 ) };
	// 8261BB14: 9B630005  stb r27, 5(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(5 as u32), ctx.r[27].u8 ) };
	// 8261BB18: 9383000C  stw r28, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 8261BB1C: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8261BB20: 91230014  stw r9, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8261BB24: 48000008  b 0x8261bb2c
	pc = 0x8261BB2C; continue 'dispatch;
            }
            0x8261BB28 => {
    //   block [0x8261BB28..0x8261BB2C)
	// 8261BB28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8261BB2C; continue 'dispatch;
            }
            0x8261BB2C => {
    //   block [0x8261BB2C..0x8261BB44)
	// 8261BB2C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8261BB30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261BB34: 419A0010  beq cr6, 0x8261bb44
	if ctx.cr[6].eq {
	pc = 0x8261BB44; continue 'dispatch;
	}
	// 8261BB38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261BB3C: 4BE64165  bl 0x8247fca0
	ctx.lr = 0x8261BB40;
	sub_8247FCA0(ctx, base);
	// 8261BB40: 4800000C  b 0x8261bb4c
	pc = 0x8261BB4C; continue 'dispatch;
            }
            0x8261BB44 => {
    //   block [0x8261BB44..0x8261BB4C)
	// 8261BB44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8261BB48: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x8261BB4C; continue 'dispatch;
            }
            0x8261BB4C => {
    //   block [0x8261BB4C..0x8261BB70)
	// 8261BB4C: 817A0028  lwz r11, 0x28(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261BB50: 387A0024  addi r3, r26, 0x24
	ctx.r[3].s64 = ctx.r[26].s64 + 36;
	// 8261BB54: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8261BB58: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 8261BB5C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8261BB60: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261BB64: 48001F85  bl 0x8261dae8
	ctx.lr = 0x8261BB68;
	sub_8261DAE8(ctx, base);
	// 8261BB68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261BB6C: 4BB9BFAD  bl 0x821b7b18
	ctx.lr = 0x8261BB70;
	sub_821B7B18(ctx, base);
	pc = 0x8261BB70; continue 'dispatch;
            }
            0x8261BB70 => {
    //   block [0x8261BB70..0x8261BB7C)
	// 8261BB70: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8261BB74: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8261BB78: 4868D8D8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261BB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8261BB80 size=568
    let mut pc: u32 = 0x8261BB80;
    'dispatch: loop {
        match pc {
            0x8261BB80 => {
    //   block [0x8261BB80..0x8261BBC0)
	// 8261BB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261BB84: 4868D87D  bl 0x82ca9400
	ctx.lr = 0x8261BB88;
	sub_82CA93D0(ctx, base);
	// 8261BB88: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8261BB8C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261BB90: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261BB94: 3B630024  addi r27, r3, 0x24
	ctx.r[27].s64 = ctx.r[3].s64 + 36;
	// 8261BB98: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8261BB9C: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 8261BBA0: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8261BBA4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8261BBA8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261BBAC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8261BBB0: E9210058  ld r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261BBB4: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 8261BBB8: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261BBBC: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x8261BBC0; continue 'dispatch;
            }
            0x8261BBC0 => {
    //   block [0x8261BBC0..0x8261BBD4)
	// 8261BBC0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261BBC4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261BBC8: 419A000C  beq cr6, 0x8261bbd4
	if ctx.cr[6].eq {
	pc = 0x8261BBD4; continue 'dispatch;
	}
	// 8261BBCC: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 8261BBD0: 419A0008  beq cr6, 0x8261bbd8
	if ctx.cr[6].eq {
	pc = 0x8261BBD8; continue 'dispatch;
	}
	pc = 0x8261BBD4; continue 'dispatch;
            }
            0x8261BBD4 => {
    //   block [0x8261BBD4..0x8261BBD8)
	// 8261BBD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261BBD8; continue 'dispatch;
            }
            0x8261BBD8 => {
    //   block [0x8261BBD8..0x8261BBEC)
	// 8261BBD8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261BBDC: 419A01D0  beq cr6, 0x8261bdac
	if ctx.cr[6].eq {
	pc = 0x8261BDAC; continue 'dispatch;
	}
	// 8261BBE0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261BBE4: 409A0008  bne cr6, 0x8261bbec
	if !ctx.cr[6].eq {
	pc = 0x8261BBEC; continue 'dispatch;
	}
	// 8261BBE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261BBEC; continue 'dispatch;
            }
            0x8261BBEC => {
    //   block [0x8261BBEC..0x8261BBFC)
	// 8261BBEC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261BBF0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261BBF4: 409A0008  bne cr6, 0x8261bbfc
	if !ctx.cr[6].eq {
	pc = 0x8261BBFC; continue 'dispatch;
	}
	// 8261BBF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261BBFC; continue 'dispatch;
            }
            0x8261BBFC => {
    //   block [0x8261BBFC..0x8261BC14)
	// 8261BBFC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261BC00: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261BC04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261BC08: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8261BC0C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8261BC10: 419A0020  beq cr6, 0x8261bc30
	if ctx.cr[6].eq {
	pc = 0x8261BC30; continue 'dispatch;
	}
	pc = 0x8261BC14; continue 'dispatch;
            }
            0x8261BC14 => {
    //   block [0x8261BC14..0x8261BC30)
	// 8261BC14: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8261BC18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261BC1C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8261BC20: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8261BC24: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8261BC28: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261BC2C: 4082FFE8  bne 0x8261bc14
	if !ctx.cr[0].eq {
	pc = 0x8261BC14; continue 'dispatch;
	}
	pc = 0x8261BC30; continue 'dispatch;
            }
            0x8261BC30 => {
    //   block [0x8261BC30..0x8261BC78)
	// 8261BC30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261BC34: 419A0054  beq cr6, 0x8261bc88
	if ctx.cr[6].eq {
	pc = 0x8261BC88; continue 'dispatch;
	}
	// 8261BC38: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261BC3C: 7F0BD000  cmpw cr6, r11, r26
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[26].s32, &mut ctx.xer);
	// 8261BC40: 409A0048  bne cr6, 0x8261bc88
	if !ctx.cr[6].eq {
	pc = 0x8261BC88; continue 'dispatch;
	}
	// 8261BC44: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261BC48: 813D0020  lwz r9, 0x20(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 8261BC4C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8261BC50: 409A0038  bne cr6, 0x8261bc88
	if !ctx.cr[6].eq {
	pc = 0x8261BC88; continue 'dispatch;
	}
	// 8261BC54: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261BC58: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8261BC5C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261BC60: 409A0018  bne cr6, 0x8261bc78
	if !ctx.cr[6].eq {
	pc = 0x8261BC78; continue 'dispatch;
	}
	// 8261BC64: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 8261BC68: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261BC6C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8261BC70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261BC74: 419A0008  beq cr6, 0x8261bc7c
	if ctx.cr[6].eq {
	pc = 0x8261BC7C; continue 'dispatch;
	}
	pc = 0x8261BC78; continue 'dispatch;
            }
            0x8261BC78 => {
    //   block [0x8261BC78..0x8261BC7C)
	// 8261BC78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8261BC7C; continue 'dispatch;
            }
            0x8261BC7C => {
    //   block [0x8261BC7C..0x8261BC88)
	// 8261BC7C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261BC80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261BC84: 409A0028  bne cr6, 0x8261bcac
	if !ctx.cr[6].eq {
	pc = 0x8261BCAC; continue 'dispatch;
	}
	pc = 0x8261BC88; continue 'dispatch;
            }
            0x8261BC88 => {
    //   block [0x8261BC88..0x8261BCA0)
	// 8261BC88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8261BC8C: 4BB9BE8D  bl 0x821b7b18
	ctx.lr = 0x8261BC90;
	sub_821B7B18(ctx, base);
	// 8261BC90: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261BC94: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261BC98: 409A0008  bne cr6, 0x8261bca0
	if !ctx.cr[6].eq {
	pc = 0x8261BCA0; continue 'dispatch;
	}
	// 8261BC9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261BCA0; continue 'dispatch;
            }
            0x8261BCA0 => {
    //   block [0x8261BCA0..0x8261BCAC)
	// 8261BCA0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261BCA4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8261BCA8: 4BFFFF18  b 0x8261bbc0
	pc = 0x8261BBC0; continue 'dispatch;
            }
            0x8261BCAC => {
    //   block [0x8261BCAC..0x8261BCFC)
	// 8261BCAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8261BCB0: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 8261BCB4: 4BB9BE65  bl 0x821b7b18
	ctx.lr = 0x8261BCB8;
	sub_821B7B18(ctx, base);
	// 8261BCB8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261BCBC: 419A00F0  beq cr6, 0x8261bdac
	if ctx.cr[6].eq {
	pc = 0x8261BDAC; continue 'dispatch;
	}
	// 8261BCC0: 387D0020  addi r3, r29, 0x20
	ctx.r[3].s64 = ctx.r[29].s64 + 32;
	// 8261BCC4: 4BB96835  bl 0x821b24f8
	ctx.lr = 0x8261BCC8;
	sub_821B24F8(ctx, base);
	// 8261BCC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261BCCC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261BCD0: 419A00CC  beq cr6, 0x8261bd9c
	if ctx.cr[6].eq {
	pc = 0x8261BD9C; continue 'dispatch;
	}
	// 8261BCD4: 897E0004  lbz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261BCD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261BCDC: 409A0050  bne cr6, 0x8261bd2c
	if !ctx.cr[6].eq {
	pc = 0x8261BD2C; continue 'dispatch;
	}
	// 8261BCE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261BCE4: 388B8BF0  addi r4, r11, -0x7410
	ctx.r[4].s64 = ctx.r[11].s64 + -29712;
	// 8261BCE8: 4BC8DD01  bl 0x822a99e8
	ctx.lr = 0x8261BCEC;
	sub_822A99E8(ctx, base);
	// 8261BCEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261BCF0: 419A000C  beq cr6, 0x8261bcfc
	if ctx.cr[6].eq {
	pc = 0x8261BCFC; continue 'dispatch;
	}
	// 8261BCF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261BCF8: 4BBD3339  bl 0x821ef030
	ctx.lr = 0x8261BCFC;
	sub_821EF030(ctx, base);
	pc = 0x8261BCFC; continue 'dispatch;
            }
            0x8261BCFC => {
    //   block [0x8261BCFC..0x8261BD2C)
	// 8261BCFC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261BD00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261BD04: 388B8C00  addi r4, r11, -0x7400
	ctx.r[4].s64 = ctx.r[11].s64 + -29696;
	// 8261BD08: 4BB7AE79  bl 0x82196b80
	ctx.lr = 0x8261BD0C;
	sub_82196B80(ctx, base);
	// 8261BD0C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261BD10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261BD14: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8261BD18: 388A8C14  addi r4, r10, -0x73ec
	ctx.r[4].s64 = ctx.r[10].s64 + -29676;
	// 8261BD1C: 4BB7AE65  bl 0x82196b80
	ctx.lr = 0x8261BD20;
	sub_82196B80(ctx, base);
	// 8261BD20: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8261BD24: 993D0058  stb r9, 0x58(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 8261BD28: 4800003C  b 0x8261bd64
	pc = 0x8261BD64; continue 'dispatch;
            }
            0x8261BD2C => {
    //   block [0x8261BD2C..0x8261BD64)
	// 8261BD2C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261BD30: 388B8C28  addi r4, r11, -0x73d8
	ctx.r[4].s64 = ctx.r[11].s64 + -29656;
	// 8261BD34: 4BB7AE4D  bl 0x82196b80
	ctx.lr = 0x8261BD38;
	sub_82196B80(ctx, base);
	// 8261BD38: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261BD3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261BD40: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8261BD44: 388A8C3C  addi r4, r10, -0x73c4
	ctx.r[4].s64 = ctx.r[10].s64 + -29636;
	// 8261BD48: 4BB7AE39  bl 0x82196b80
	ctx.lr = 0x8261BD4C;
	sub_82196B80(ctx, base);
	// 8261BD4C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8261BD50: C01E0008  lfs f0, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8261BD54: D01D0064  stfs f0, 0x64(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8261BD58: 993D0059  stb r9, 0x59(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(89 as u32), ctx.r[9].u8 ) };
	// 8261BD5C: 891E0005  lbz r8, 5(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(5 as u32) ) } as u64;
	// 8261BD60: 991D0058  stb r8, 0x58(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(88 as u32), ctx.r[8].u8 ) };
	pc = 0x8261BD64; continue 'dispatch;
            }
            0x8261BD64 => {
    //   block [0x8261BD64..0x8261BD80)
	// 8261BD64: EC01F828  fsubs f0, f1, f31
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[31].f64) as f32) as f64);
	// 8261BD68: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261BD6C: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261BD70: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8261BD74: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261BD78: EC00FB7A  fmadds f0, f0, f13, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64);
	// 8261BD7C: 419A0020  beq cr6, 0x8261bd9c
	if ctx.cr[6].eq {
	pc = 0x8261BD9C; continue 'dispatch;
	}
	pc = 0x8261BD80; continue 'dispatch;
            }
            0x8261BD80 => {
    //   block [0x8261BD80..0x8261BD9C)
	// 8261BD80: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8261BD84: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8261BD88: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8261BD8C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8261BD90: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261BD94: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261BD98: 409AFFE8  bne cr6, 0x8261bd80
	if !ctx.cr[6].eq {
	pc = 0x8261BD80; continue 'dispatch;
	}
	pc = 0x8261BD9C; continue 'dispatch;
            }
            0x8261BD9C => {
    //   block [0x8261BD9C..0x8261BDAC)
	// 8261BD9C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8261BDA0: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8261BDA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8261BDA8: 4822C261  bl 0x82848008
	ctx.lr = 0x8261BDAC;
	sub_82848008(ctx, base);
	pc = 0x8261BDAC; continue 'dispatch;
            }
            0x8261BDAC => {
    //   block [0x8261BDAC..0x8261BDB8)
	// 8261BDAC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8261BDB0: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8261BDB4: 4868D69C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261BDB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8261BDB8 size=184
    let mut pc: u32 = 0x8261BDB8;
    'dispatch: loop {
        match pc {
            0x8261BDB8 => {
    //   block [0x8261BDB8..0x8261BDF4)
	// 8261BDB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261BDBC: 4868D649  bl 0x82ca9404
	ctx.lr = 0x8261BDC0;
	sub_82CA93D0(ctx, base);
	// 8261BDC0: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 8261BDC4: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8261BDC8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261BDCC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8261BDD0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8261BDD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261BDD8: 483E4579  bl 0x82a00350
	ctx.lr = 0x8261BDDC;
	sub_82A00350(ctx, base);
	// 8261BDDC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8261BDE0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8261BDE4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8261BDE8: 419A0078  beq cr6, 0x8261be60
	if ctx.cr[6].eq {
	pc = 0x8261BE60; continue 'dispatch;
	}
	// 8261BDEC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8261BDF0: C3CB9484  lfs f30, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x8261BDF4; continue 'dispatch;
            }
            0x8261BDF4 => {
    //   block [0x8261BDF4..0x8261BE24)
	// 8261BDF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8261BDF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261BDFC: 483E4AFD  bl 0x82a008f8
	ctx.lr = 0x8261BE00;
	sub_82A008F8(ctx, base);
	// 8261BE00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261BE04: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8261BE08: FFE0F090  fmr f31, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[30].f64;
	// 8261BE0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261BE10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261BE14: 4BBC9BF5  bl 0x821e5a08
	ctx.lr = 0x8261BE18;
	sub_821E5A08(ctx, base);
	// 8261BE18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261BE1C: 419A0008  beq cr6, 0x8261be24
	if ctx.cr[6].eq {
	pc = 0x8261BE24; continue 'dispatch;
	}
	// 8261BE20: C3E30000  lfs f31, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x8261BE24; continue 'dispatch;
            }
            0x8261BE24 => {
    //   block [0x8261BE24..0x8261BE34)
	// 8261BE24: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261BE28: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261BE2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261BE30: 419A0024  beq cr6, 0x8261be54
	if ctx.cr[6].eq {
	pc = 0x8261BE54; continue 'dispatch;
	}
	pc = 0x8261BE34; continue 'dispatch;
            }
            0x8261BE34 => {
    //   block [0x8261BE34..0x8261BE50)
	// 8261BE34: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261BE38: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8261BE3C: 419A0014  beq cr6, 0x8261be50
	if ctx.cr[6].eq {
	pc = 0x8261BE50; continue 'dispatch;
	}
	// 8261BE40: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8261BE44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261BE48: 409AFFEC  bne cr6, 0x8261be34
	if !ctx.cr[6].eq {
	pc = 0x8261BE34; continue 'dispatch;
	}
	// 8261BE4C: 48000008  b 0x8261be54
	pc = 0x8261BE54; continue 'dispatch;
            }
            0x8261BE50 => {
    //   block [0x8261BE50..0x8261BE54)
	// 8261BE50: D3EB0004  stfs f31, 4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x8261BE54; continue 'dispatch;
            }
            0x8261BE54 => {
    //   block [0x8261BE54..0x8261BE60)
	// 8261BE54: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8261BE58: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 8261BE5C: 4198FF98  blt cr6, 0x8261bdf4
	if ctx.cr[6].lt {
	pc = 0x8261BDF4; continue 'dispatch;
	}
	pc = 0x8261BE60; continue 'dispatch;
            }
            0x8261BE60 => {
    //   block [0x8261BE60..0x8261BE70)
	// 8261BE60: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8261BE64: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8261BE68: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8261BE6C: 4868D5E8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261BE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261BE70 size=832
    let mut pc: u32 = 0x8261BE70;
    'dispatch: loop {
        match pc {
            0x8261BE70 => {
    //   block [0x8261BE70..0x8261BEA4)
	// 8261BE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261BE74: 4868D599  bl 0x82ca940c
	ctx.lr = 0x8261BE78;
	sub_82CA93D0(ctx, base);
	// 8261BE78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261BE7C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8261BE80: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8261BE84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8261BE88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261BE8C: 388B8E7C  addi r4, r11, -0x7184
	ctx.r[4].s64 = ctx.r[11].s64 + -29060;
	// 8261BE90: 4BC8DB59  bl 0x822a99e8
	ctx.lr = 0x8261BE94;
	sub_822A99E8(ctx, base);
	// 8261BE94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261BE98: 419A000C  beq cr6, 0x8261bea4
	if ctx.cr[6].eq {
	pc = 0x8261BEA4; continue 'dispatch;
	}
	// 8261BE9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8261BEA0: 4BBD3191  bl 0x821ef030
	ctx.lr = 0x8261BEA4;
	sub_821EF030(ctx, base);
	pc = 0x8261BEA4; continue 'dispatch;
            }
            0x8261BEA4 => {
    //   block [0x8261BEA4..0x8261BEFC)
	// 8261BEA4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8261BEA8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8261BEAC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8261BEB0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261BEB4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261BEB8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261BEBC: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261BEC0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8261BEC4: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 8261BEC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261BECC: 419A00B4  beq cr6, 0x8261bf80
	if ctx.cr[6].eq {
	pc = 0x8261BF80; continue 'dispatch;
	}
	// 8261BED0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261BED4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261BED8: 419A00A4  beq cr6, 0x8261bf7c
	if ctx.cr[6].eq {
	pc = 0x8261BF7C; continue 'dispatch;
	}
	// 8261BEDC: 5546003E  slwi r6, r10, 0
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8261BEE0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8261BEE4: 419A0018  beq cr6, 0x8261befc
	if ctx.cr[6].eq {
	pc = 0x8261BEFC; continue 'dispatch;
	}
	// 8261BEE8: 89660090  lbz r11, 0x90(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(144 as u32) ) } as u64;
	// 8261BEEC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8261BEF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261BEF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261BEF8: 409A0008  bne cr6, 0x8261bf00
	if !ctx.cr[6].eq {
	pc = 0x8261BF00; continue 'dispatch;
	}
	pc = 0x8261BEFC; continue 'dispatch;
            }
            0x8261BEFC => {
    //   block [0x8261BEFC..0x8261BF00)
	// 8261BEFC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8261BF00; continue 'dispatch;
            }
            0x8261BF00 => {
    //   block [0x8261BF00..0x8261BF30)
	// 8261BF00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261BF04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261BF08: 419A02A0  beq cr6, 0x8261c1a8
	if ctx.cr[6].eq {
	pc = 0x8261C1A8; continue 'dispatch;
	}
	// 8261BF0C: 81660014  lwz r11, 0x14(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 8261BF10: 815E0038  lwz r10, 0x38(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 8261BF14: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261BF18: 409A0018  bne cr6, 0x8261bf30
	if !ctx.cr[6].eq {
	pc = 0x8261BF30; continue 'dispatch;
	}
	// 8261BF1C: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 8261BF20: 81460018  lwz r10, 0x18(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 8261BF24: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261BF28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261BF2C: 419A0008  beq cr6, 0x8261bf34
	if ctx.cr[6].eq {
	pc = 0x8261BF34; continue 'dispatch;
	}
	pc = 0x8261BF30; continue 'dispatch;
            }
            0x8261BF30 => {
    //   block [0x8261BF30..0x8261BF34)
	// 8261BF30: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8261BF34; continue 'dispatch;
            }
            0x8261BF34 => {
    //   block [0x8261BF34..0x8261BF7C)
	// 8261BF34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261BF38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261BF3C: 419A026C  beq cr6, 0x8261c1a8
	if ctx.cr[6].eq {
	pc = 0x8261C1A8; continue 'dispatch;
	}
	// 8261BF40: 81460030  lwz r10, 0x30(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261BF44: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 8261BF48: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 8261BF4C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261BF50: 419A00F4  beq cr6, 0x8261c044
	if ctx.cr[6].eq {
	pc = 0x8261C044; continue 'dispatch;
	}
	// 8261BF54: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261BF58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261BF5C: 419A002C  beq cr6, 0x8261bf88
	if ctx.cr[6].eq {
	pc = 0x8261BF88; continue 'dispatch;
	}
	// 8261BF60: 894B007A  lbz r10, 0x7a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(122 as u32) ) } as u64;
	// 8261BF64: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261BF68: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8261BF6C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261BF70: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261BF74: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261BF78: 480000D0  b 0x8261c048
	pc = 0x8261C048; continue 'dispatch;
            }
            0x8261BF7C => {
    //   block [0x8261BF7C..0x8261BF80)
	// 8261BF7C: 4BB77EBD  bl 0x82193e38
	ctx.lr = 0x8261BF80;
	sub_82193E38(ctx, base);
	pc = 0x8261BF80; continue 'dispatch;
            }
            0x8261BF80 => {
    //   block [0x8261BF80..0x8261BF88)
	// 8261BF80: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 8261BF84: 4BFFFF78  b 0x8261befc
	pc = 0x8261BEFC; continue 'dispatch;
            }
            0x8261BF88 => {
    //   block [0x8261BF88..0x8261BFA4)
	// 8261BF88: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261BF8C: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261BF90: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8261BF94: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 8261BF98: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8261BF9C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261BFA0: 40810054  ble 0x8261bff4
	if !ctx.cr[0].gt {
	pc = 0x8261BFF4; continue 'dispatch;
	}
	pc = 0x8261BFA4; continue 'dispatch;
            }
            0x8261BFA4 => {
    //   block [0x8261BFA4..0x8261BFC4)
	// 8261BFA4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261BFA8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261BFAC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8261BFB0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261BFB4: 2F07007A  cmpwi cr6, r7, 0x7a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 122, &mut ctx.xer);
	// 8261BFB8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8261BFBC: 41980008  blt cr6, 0x8261bfc4
	if ctx.cr[6].lt {
	pc = 0x8261BFC4; continue 'dispatch;
	}
	// 8261BFC0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x8261BFC4; continue 'dispatch;
            }
            0x8261BFC4 => {
    //   block [0x8261BFC4..0x8261BFE0)
	// 8261BFC4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8261BFC8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261BFCC: 419A0014  beq cr6, 0x8261bfe0
	if ctx.cr[6].eq {
	pc = 0x8261BFE0; continue 'dispatch;
	}
	// 8261BFD0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261BFD4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8261BFD8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8261BFDC: 4800000C  b 0x8261bfe8
	pc = 0x8261BFE8; continue 'dispatch;
            }
            0x8261BFE0 => {
    //   block [0x8261BFE0..0x8261BFE8)
	// 8261BFE0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261BFE4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8261BFE8; continue 'dispatch;
            }
            0x8261BFE8 => {
    //   block [0x8261BFE8..0x8261BFF4)
	// 8261BFE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261BFEC: 4199FFB8  bgt cr6, 0x8261bfa4
	if ctx.cr[6].gt {
	pc = 0x8261BFA4; continue 'dispatch;
	}
	// 8261BFF0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8261BFF4; continue 'dispatch;
            }
            0x8261BFF4 => {
    //   block [0x8261BFF4..0x8261C010)
	// 8261BFF4: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 8261BFF8: 419A003C  beq cr6, 0x8261c034
	if ctx.cr[6].eq {
	pc = 0x8261C034; continue 'dispatch;
	}
	// 8261BFFC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C000: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 8261C004: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261C008: 41990008  bgt cr6, 0x8261c010
	if ctx.cr[6].gt {
	pc = 0x8261C010; continue 'dispatch;
	}
	// 8261C00C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8261C010; continue 'dispatch;
            }
            0x8261C010 => {
    //   block [0x8261C010..0x8261C034)
	// 8261C010: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261C014: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261C018: 409A001C  bne cr6, 0x8261c034
	if !ctx.cr[6].eq {
	pc = 0x8261C034; continue 'dispatch;
	}
	// 8261C01C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8261C020: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261C024: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8261C028: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261C02C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C030: 48000018  b 0x8261c048
	pc = 0x8261C048; continue 'dispatch;
            }
            0x8261C034 => {
    //   block [0x8261C034..0x8261C044)
	// 8261C034: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8261C038: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261C03C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C040: 48000008  b 0x8261c048
	pc = 0x8261C048; continue 'dispatch;
            }
            0x8261C044 => {
    //   block [0x8261C044..0x8261C048)
	// 8261C044: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x8261C048; continue 'dispatch;
            }
            0x8261C048 => {
    //   block [0x8261C048..0x8261C070)
	// 8261C048: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8261C04C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261C050: 419A0158  beq cr6, 0x8261c1a8
	if ctx.cr[6].eq {
	pc = 0x8261C1A8; continue 'dispatch;
	}
	// 8261C054: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8261C058: 4BBA69C1  bl 0x821c2a18
	ctx.lr = 0x8261C05C;
	sub_821C2A18(ctx, base);
	// 8261C05C: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 8261C060: 409A0010  bne cr6, 0x8261c070
	if !ctx.cr[6].eq {
	pc = 0x8261C070; continue 'dispatch;
	}
	// 8261C064: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261C068: 388B8C50  addi r4, r11, -0x73b0
	ctx.r[4].s64 = ctx.r[11].s64 + -29616;
	// 8261C06C: 48000120  b 0x8261c18c
	pc = 0x8261C18C; continue 'dispatch;
            }
            0x8261C070 => {
    //   block [0x8261C070..0x8261C0AC)
	// 8261C070: 81460024  lwz r10, 0x24(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 8261C074: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 8261C078: 5549A7FE  rlwinm r9, r10, 0x14, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000FFFu64;
	// 8261C07C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261C080: 419A00E8  beq cr6, 0x8261c168
	if ctx.cr[6].eq {
	pc = 0x8261C168; continue 'dispatch;
	}
	// 8261C084: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261C088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261C08C: 419A0020  beq cr6, 0x8261c0ac
	if ctx.cr[6].eq {
	pc = 0x8261C0AC; continue 'dispatch;
	}
	// 8261C090: 894B000C  lbz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261C094: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261C098: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8261C09C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261C0A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261C0A4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C0A8: 480000C4  b 0x8261c16c
	pc = 0x8261C16C; continue 'dispatch;
            }
            0x8261C0AC => {
    //   block [0x8261C0AC..0x8261C0C8)
	// 8261C0AC: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261C0B0: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261C0B4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8261C0B8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8261C0BC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8261C0C0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261C0C4: 40810054  ble 0x8261c118
	if !ctx.cr[0].gt {
	pc = 0x8261C118; continue 'dispatch;
	}
	pc = 0x8261C0C8; continue 'dispatch;
            }
            0x8261C0C8 => {
    //   block [0x8261C0C8..0x8261C0E8)
	// 8261C0C8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261C0CC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261C0D0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8261C0D4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C0D8: 2F07000C  cmpwi cr6, r7, 0xc
	ctx.cr[6].compare_i32(ctx.r[7].s32, 12, &mut ctx.xer);
	// 8261C0DC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8261C0E0: 41980008  blt cr6, 0x8261c0e8
	if ctx.cr[6].lt {
	pc = 0x8261C0E8; continue 'dispatch;
	}
	// 8261C0E4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x8261C0E8; continue 'dispatch;
            }
            0x8261C0E8 => {
    //   block [0x8261C0E8..0x8261C104)
	// 8261C0E8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8261C0EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261C0F0: 419A0014  beq cr6, 0x8261c104
	if ctx.cr[6].eq {
	pc = 0x8261C104; continue 'dispatch;
	}
	// 8261C0F4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261C0F8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8261C0FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8261C100: 4800000C  b 0x8261c10c
	pc = 0x8261C10C; continue 'dispatch;
            }
            0x8261C104 => {
    //   block [0x8261C104..0x8261C10C)
	// 8261C104: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261C108: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8261C10C; continue 'dispatch;
            }
            0x8261C10C => {
    //   block [0x8261C10C..0x8261C118)
	// 8261C10C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261C110: 4199FFB8  bgt cr6, 0x8261c0c8
	if ctx.cr[6].gt {
	pc = 0x8261C0C8; continue 'dispatch;
	}
	// 8261C114: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8261C118; continue 'dispatch;
            }
            0x8261C118 => {
    //   block [0x8261C118..0x8261C134)
	// 8261C118: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8261C11C: 419A003C  beq cr6, 0x8261c158
	if ctx.cr[6].eq {
	pc = 0x8261C158; continue 'dispatch;
	}
	// 8261C120: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C124: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 8261C128: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261C12C: 41990008  bgt cr6, 0x8261c134
	if ctx.cr[6].gt {
	pc = 0x8261C134; continue 'dispatch;
	}
	// 8261C130: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8261C134; continue 'dispatch;
            }
            0x8261C134 => {
    //   block [0x8261C134..0x8261C158)
	// 8261C134: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261C138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261C13C: 409A001C  bne cr6, 0x8261c158
	if !ctx.cr[6].eq {
	pc = 0x8261C158; continue 'dispatch;
	}
	// 8261C140: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8261C144: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261C148: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8261C14C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261C150: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C154: 48000018  b 0x8261c16c
	pc = 0x8261C16C; continue 'dispatch;
            }
            0x8261C158 => {
    //   block [0x8261C158..0x8261C168)
	// 8261C158: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8261C15C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261C160: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C164: 48000008  b 0x8261c16c
	pc = 0x8261C16C; continue 'dispatch;
            }
            0x8261C168 => {
    //   block [0x8261C168..0x8261C16C)
	// 8261C168: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x8261C16C; continue 'dispatch;
            }
            0x8261C16C => {
    //   block [0x8261C16C..0x8261C18C)
	// 8261C16C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8261C170: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261C174: 419A0034  beq cr6, 0x8261c1a8
	if ctx.cr[6].eq {
	pc = 0x8261C1A8; continue 'dispatch;
	}
	// 8261C178: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261C17C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8261C180: 409A0028  bne cr6, 0x8261c1a8
	if !ctx.cr[6].eq {
	pc = 0x8261C1A8; continue 'dispatch;
	}
	// 8261C184: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8261C188: 388B8E64  addi r4, r11, -0x719c
	ctx.r[4].s64 = ctx.r[11].s64 + -29084;
	pc = 0x8261C18C; continue 'dispatch;
            }
            0x8261C18C => {
    //   block [0x8261C18C..0x8261C1A8)
	// 8261C18C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261C190: 4BC8D859  bl 0x822a99e8
	ctx.lr = 0x8261C194;
	sub_822A99E8(ctx, base);
	// 8261C194: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8261C198: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8261C19C: 419A000C  beq cr6, 0x8261c1a8
	if ctx.cr[6].eq {
	pc = 0x8261C1A8; continue 'dispatch;
	}
	// 8261C1A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261C1A4: 4BFFFC15  bl 0x8261bdb8
	ctx.lr = 0x8261C1A8;
	sub_8261BDB8(ctx, base);
	pc = 0x8261C1A8; continue 'dispatch;
            }
            0x8261C1A8 => {
    //   block [0x8261C1A8..0x8261C1B0)
	// 8261C1A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8261C1AC: 4868D2B0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261C1B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8261C1B0 size=1088
    let mut pc: u32 = 0x8261C1B0;
    'dispatch: loop {
        match pc {
            0x8261C1B0 => {
    //   block [0x8261C1B0..0x8261C1F8)
	// 8261C1B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261C1B4: 4868D24D  bl 0x82ca9400
	ctx.lr = 0x8261C1B8;
	sub_82CA93D0(ctx, base);
	// 8261C1B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261C1BC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8261C1C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8261C1C4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 8261C1C8: 4BBBE181  bl 0x821da348
	ctx.lr = 0x8261C1CC;
	sub_821DA348(ctx, base);
	// 8261C1CC: 4BB9632D  bl 0x821b24f8
	ctx.lr = 0x8261C1D0;
	sub_821B24F8(ctx, base);
	// 8261C1D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8261C1D4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8261C1D8: 419A0400  beq cr6, 0x8261c5d8
	if ctx.cr[6].eq {
	pc = 0x8261C5D8; continue 'dispatch;
	}
	// 8261C1DC: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 8261C1E0: 4BC03079  bl 0x8221f258
	ctx.lr = 0x8261C1E4;
	sub_8221F258(ctx, base);
	// 8261C1E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8261C1E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261C1EC: 419A000C  beq cr6, 0x8261c1f8
	if ctx.cr[6].eq {
	pc = 0x8261C1F8; continue 'dispatch;
	}
	// 8261C1F0: 4BFFDB99  bl 0x82619d88
	ctx.lr = 0x8261C1F4;
	sub_82619D88(ctx, base);
	// 8261C1F4: 48000008  b 0x8261c1fc
	pc = 0x8261C1FC; continue 'dispatch;
            }
            0x8261C1F8 => {
    //   block [0x8261C1F8..0x8261C1FC)
	// 8261C1F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8261C1FC; continue 'dispatch;
            }
            0x8261C1FC => {
    //   block [0x8261C1FC..0x8261C220)
	// 8261C1FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261C200: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261C204: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8261C208: 419A0018  beq cr6, 0x8261c220
	if ctx.cr[6].eq {
	pc = 0x8261C220; continue 'dispatch;
	}
	// 8261C20C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261C210: 48001871  bl 0x8261da80
	ctx.lr = 0x8261C214;
	sub_8261DA80(ctx, base);
	// 8261C214: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261C218: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261C21C: 4800000C  b 0x8261c228
	pc = 0x8261C228; continue 'dispatch;
            }
            0x8261C220 => {
    //   block [0x8261C220..0x8261C228)
	// 8261C220: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8261C224: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	pc = 0x8261C228; continue 'dispatch;
            }
            0x8261C228 => {
    //   block [0x8261C228..0x8261C260)
	// 8261C228: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8261C22C: 38BE0010  addi r5, r30, 0x10
	ctx.r[5].s64 = ctx.r[30].s64 + 16;
	// 8261C230: 388BA1C4  addi r4, r11, -0x5e3c
	ctx.r[4].s64 = ctx.r[11].s64 + -24124;
	// 8261C234: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261C238: 4BD91161  bl 0x823ad398
	ctx.lr = 0x8261C23C;
	sub_823AD398(ctx, base);
	// 8261C23C: 93FE0034  stw r31, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[31].u32 ) };
	// 8261C240: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8261C244: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261C248: 388A8E7C  addi r4, r10, -0x7184
	ctx.r[4].s64 = ctx.r[10].s64 + -29060;
	// 8261C24C: 4BC8D79D  bl 0x822a99e8
	ctx.lr = 0x8261C250;
	sub_822A99E8(ctx, base);
	// 8261C250: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261C254: 419A000C  beq cr6, 0x8261c260
	if ctx.cr[6].eq {
	pc = 0x8261C260; continue 'dispatch;
	}
	// 8261C258: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8261C25C: 4BBD2DD5  bl 0x821ef030
	ctx.lr = 0x8261C260;
	sub_821EF030(ctx, base);
	pc = 0x8261C260; continue 'dispatch;
            }
            0x8261C260 => {
    //   block [0x8261C260..0x8261C29C)
	// 8261C260: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8261C264: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8261C268: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261C26C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261C270: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C274: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C278: 4BC0FF41  bl 0x8222c1b8
	ctx.lr = 0x8261C27C;
	sub_8222C1B8(ctx, base);
	// 8261C27C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8261C280: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8261C284: 419A0018  beq cr6, 0x8261c29c
	if ctx.cr[6].eq {
	pc = 0x8261C29C; continue 'dispatch;
	}
	// 8261C288: 89660090  lbz r11, 0x90(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(144 as u32) ) } as u64;
	// 8261C28C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8261C290: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261C294: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261C298: 409A0008  bne cr6, 0x8261c2a0
	if !ctx.cr[6].eq {
	pc = 0x8261C2A0; continue 'dispatch;
	}
	pc = 0x8261C29C; continue 'dispatch;
            }
            0x8261C29C => {
    //   block [0x8261C29C..0x8261C2A0)
	// 8261C29C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8261C2A0; continue 'dispatch;
            }
            0x8261C2A0 => {
    //   block [0x8261C2A0..0x8261C2D0)
	// 8261C2A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261C2A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261C2A8: 419A0294  beq cr6, 0x8261c53c
	if ctx.cr[6].eq {
	pc = 0x8261C53C; continue 'dispatch;
	}
	// 8261C2AC: 81660014  lwz r11, 0x14(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 8261C2B0: 815E0038  lwz r10, 0x38(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 8261C2B4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261C2B8: 409A0018  bne cr6, 0x8261c2d0
	if !ctx.cr[6].eq {
	pc = 0x8261C2D0; continue 'dispatch;
	}
	// 8261C2BC: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 8261C2C0: 81460018  lwz r10, 0x18(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 8261C2C4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261C2C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261C2CC: 419A0008  beq cr6, 0x8261c2d4
	if ctx.cr[6].eq {
	pc = 0x8261C2D4; continue 'dispatch;
	}
	pc = 0x8261C2D0; continue 'dispatch;
            }
            0x8261C2D0 => {
    //   block [0x8261C2D0..0x8261C2D4)
	// 8261C2D0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8261C2D4; continue 'dispatch;
            }
            0x8261C2D4 => {
    //   block [0x8261C2D4..0x8261C31C)
	// 8261C2D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261C2D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261C2DC: 419A0260  beq cr6, 0x8261c53c
	if ctx.cr[6].eq {
	pc = 0x8261C53C; continue 'dispatch;
	}
	// 8261C2E0: 81460030  lwz r10, 0x30(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261C2E4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 8261C2E8: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 8261C2EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261C2F0: 419A00E8  beq cr6, 0x8261c3d8
	if ctx.cr[6].eq {
	pc = 0x8261C3D8; continue 'dispatch;
	}
	// 8261C2F4: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261C2F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261C2FC: 419A0020  beq cr6, 0x8261c31c
	if ctx.cr[6].eq {
	pc = 0x8261C31C; continue 'dispatch;
	}
	// 8261C300: 894B007A  lbz r10, 0x7a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(122 as u32) ) } as u64;
	// 8261C304: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261C308: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8261C30C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261C310: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261C314: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C318: 480000C4  b 0x8261c3dc
	pc = 0x8261C3DC; continue 'dispatch;
            }
            0x8261C31C => {
    //   block [0x8261C31C..0x8261C338)
	// 8261C31C: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261C320: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261C324: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8261C328: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 8261C32C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8261C330: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261C334: 40810054  ble 0x8261c388
	if !ctx.cr[0].gt {
	pc = 0x8261C388; continue 'dispatch;
	}
	pc = 0x8261C338; continue 'dispatch;
            }
            0x8261C338 => {
    //   block [0x8261C338..0x8261C358)
	// 8261C338: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261C33C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261C340: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8261C344: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C348: 2F07007A  cmpwi cr6, r7, 0x7a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 122, &mut ctx.xer);
	// 8261C34C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8261C350: 41980008  blt cr6, 0x8261c358
	if ctx.cr[6].lt {
	pc = 0x8261C358; continue 'dispatch;
	}
	// 8261C354: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x8261C358; continue 'dispatch;
            }
            0x8261C358 => {
    //   block [0x8261C358..0x8261C374)
	// 8261C358: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8261C35C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261C360: 419A0014  beq cr6, 0x8261c374
	if ctx.cr[6].eq {
	pc = 0x8261C374; continue 'dispatch;
	}
	// 8261C364: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261C368: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8261C36C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8261C370: 4800000C  b 0x8261c37c
	pc = 0x8261C37C; continue 'dispatch;
            }
            0x8261C374 => {
    //   block [0x8261C374..0x8261C37C)
	// 8261C374: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261C378: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8261C37C; continue 'dispatch;
            }
            0x8261C37C => {
    //   block [0x8261C37C..0x8261C388)
	// 8261C37C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261C380: 4199FFB8  bgt cr6, 0x8261c338
	if ctx.cr[6].gt {
	pc = 0x8261C338; continue 'dispatch;
	}
	// 8261C384: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8261C388; continue 'dispatch;
            }
            0x8261C388 => {
    //   block [0x8261C388..0x8261C3A4)
	// 8261C388: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 8261C38C: 419A003C  beq cr6, 0x8261c3c8
	if ctx.cr[6].eq {
	pc = 0x8261C3C8; continue 'dispatch;
	}
	// 8261C390: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C394: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 8261C398: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261C39C: 41990008  bgt cr6, 0x8261c3a4
	if ctx.cr[6].gt {
	pc = 0x8261C3A4; continue 'dispatch;
	}
	// 8261C3A0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8261C3A4; continue 'dispatch;
            }
            0x8261C3A4 => {
    //   block [0x8261C3A4..0x8261C3C8)
	// 8261C3A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261C3A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261C3AC: 409A001C  bne cr6, 0x8261c3c8
	if !ctx.cr[6].eq {
	pc = 0x8261C3C8; continue 'dispatch;
	}
	// 8261C3B0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261C3B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261C3B8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8261C3BC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8261C3C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C3C4: 48000018  b 0x8261c3dc
	pc = 0x8261C3DC; continue 'dispatch;
            }
            0x8261C3C8 => {
    //   block [0x8261C3C8..0x8261C3D8)
	// 8261C3C8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8261C3CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261C3D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C3D4: 48000008  b 0x8261c3dc
	pc = 0x8261C3DC; continue 'dispatch;
            }
            0x8261C3D8 => {
    //   block [0x8261C3D8..0x8261C3DC)
	// 8261C3D8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x8261C3DC; continue 'dispatch;
            }
            0x8261C3DC => {
    //   block [0x8261C3DC..0x8261C404)
	// 8261C3DC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8261C3E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261C3E4: 419A0158  beq cr6, 0x8261c53c
	if ctx.cr[6].eq {
	pc = 0x8261C53C; continue 'dispatch;
	}
	// 8261C3E8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8261C3EC: 4BBA662D  bl 0x821c2a18
	ctx.lr = 0x8261C3F0;
	sub_821C2A18(ctx, base);
	// 8261C3F0: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 8261C3F4: 409A0010  bne cr6, 0x8261c404
	if !ctx.cr[6].eq {
	pc = 0x8261C404; continue 'dispatch;
	}
	// 8261C3F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261C3FC: 388B8C50  addi r4, r11, -0x73b0
	ctx.r[4].s64 = ctx.r[11].s64 + -29616;
	// 8261C400: 48000120  b 0x8261c520
	pc = 0x8261C520; continue 'dispatch;
            }
            0x8261C404 => {
    //   block [0x8261C404..0x8261C440)
	// 8261C404: 81460024  lwz r10, 0x24(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 8261C408: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 8261C40C: 5549A7FE  rlwinm r9, r10, 0x14, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000FFFu64;
	// 8261C410: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261C414: 419A00E8  beq cr6, 0x8261c4fc
	if ctx.cr[6].eq {
	pc = 0x8261C4FC; continue 'dispatch;
	}
	// 8261C418: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261C41C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261C420: 419A0020  beq cr6, 0x8261c440
	if ctx.cr[6].eq {
	pc = 0x8261C440; continue 'dispatch;
	}
	// 8261C424: 894B000C  lbz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261C428: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261C42C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8261C430: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261C434: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261C438: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C43C: 480000C4  b 0x8261c500
	pc = 0x8261C500; continue 'dispatch;
            }
            0x8261C440 => {
    //   block [0x8261C440..0x8261C45C)
	// 8261C440: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261C444: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261C448: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8261C44C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8261C450: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8261C454: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261C458: 40810054  ble 0x8261c4ac
	if !ctx.cr[0].gt {
	pc = 0x8261C4AC; continue 'dispatch;
	}
	pc = 0x8261C45C; continue 'dispatch;
            }
            0x8261C45C => {
    //   block [0x8261C45C..0x8261C47C)
	// 8261C45C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261C460: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261C464: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8261C468: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C46C: 2F07000C  cmpwi cr6, r7, 0xc
	ctx.cr[6].compare_i32(ctx.r[7].s32, 12, &mut ctx.xer);
	// 8261C470: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8261C474: 41980008  blt cr6, 0x8261c47c
	if ctx.cr[6].lt {
	pc = 0x8261C47C; continue 'dispatch;
	}
	// 8261C478: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x8261C47C; continue 'dispatch;
            }
            0x8261C47C => {
    //   block [0x8261C47C..0x8261C498)
	// 8261C47C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8261C480: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261C484: 419A0014  beq cr6, 0x8261c498
	if ctx.cr[6].eq {
	pc = 0x8261C498; continue 'dispatch;
	}
	// 8261C488: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261C48C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8261C490: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8261C494: 4800000C  b 0x8261c4a0
	pc = 0x8261C4A0; continue 'dispatch;
            }
            0x8261C498 => {
    //   block [0x8261C498..0x8261C4A0)
	// 8261C498: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261C49C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8261C4A0; continue 'dispatch;
            }
            0x8261C4A0 => {
    //   block [0x8261C4A0..0x8261C4AC)
	// 8261C4A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261C4A4: 4199FFB8  bgt cr6, 0x8261c45c
	if ctx.cr[6].gt {
	pc = 0x8261C45C; continue 'dispatch;
	}
	// 8261C4A8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8261C4AC; continue 'dispatch;
            }
            0x8261C4AC => {
    //   block [0x8261C4AC..0x8261C4C8)
	// 8261C4AC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8261C4B0: 419A003C  beq cr6, 0x8261c4ec
	if ctx.cr[6].eq {
	pc = 0x8261C4EC; continue 'dispatch;
	}
	// 8261C4B4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C4B8: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 8261C4BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261C4C0: 41990008  bgt cr6, 0x8261c4c8
	if ctx.cr[6].gt {
	pc = 0x8261C4C8; continue 'dispatch;
	}
	// 8261C4C4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8261C4C8; continue 'dispatch;
            }
            0x8261C4C8 => {
    //   block [0x8261C4C8..0x8261C4EC)
	// 8261C4C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261C4CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261C4D0: 409A001C  bne cr6, 0x8261c4ec
	if !ctx.cr[6].eq {
	pc = 0x8261C4EC; continue 'dispatch;
	}
	// 8261C4D4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261C4D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261C4DC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8261C4E0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8261C4E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C4E8: 48000018  b 0x8261c500
	pc = 0x8261C500; continue 'dispatch;
            }
            0x8261C4EC => {
    //   block [0x8261C4EC..0x8261C4FC)
	// 8261C4EC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8261C4F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261C4F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C4F8: 48000008  b 0x8261c500
	pc = 0x8261C500; continue 'dispatch;
            }
            0x8261C4FC => {
    //   block [0x8261C4FC..0x8261C500)
	// 8261C4FC: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x8261C500; continue 'dispatch;
            }
            0x8261C500 => {
    //   block [0x8261C500..0x8261C520)
	// 8261C500: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8261C504: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261C508: 419A0034  beq cr6, 0x8261c53c
	if ctx.cr[6].eq {
	pc = 0x8261C53C; continue 'dispatch;
	}
	// 8261C50C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261C510: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8261C514: 409A0028  bne cr6, 0x8261c53c
	if !ctx.cr[6].eq {
	pc = 0x8261C53C; continue 'dispatch;
	}
	// 8261C518: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8261C51C: 388B8E64  addi r4, r11, -0x719c
	ctx.r[4].s64 = ctx.r[11].s64 + -29084;
	pc = 0x8261C520; continue 'dispatch;
            }
            0x8261C520 => {
    //   block [0x8261C520..0x8261C53C)
	// 8261C520: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261C524: 4BC8D4C5  bl 0x822a99e8
	ctx.lr = 0x8261C528;
	sub_822A99E8(ctx, base);
	// 8261C528: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8261C52C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8261C530: 419A000C  beq cr6, 0x8261c53c
	if ctx.cr[6].eq {
	pc = 0x8261C53C; continue 'dispatch;
	}
	// 8261C534: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261C538: 4BFFF881  bl 0x8261bdb8
	ctx.lr = 0x8261C53C;
	sub_8261BDB8(ctx, base);
	pc = 0x8261C53C; continue 'dispatch;
            }
            0x8261C53C => {
    //   block [0x8261C53C..0x8261C5A8)
	// 8261C53C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8261C540: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8261C544: 4BBBDE05  bl 0x821da348
	ctx.lr = 0x8261C548;
	sub_821DA348(ctx, base);
	// 8261C548: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8261C54C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261C550: 38BE001C  addi r5, r30, 0x1c
	ctx.r[5].s64 = ctx.r[30].s64 + 28;
	// 8261C554: 388A8B34  addi r4, r10, -0x74cc
	ctx.r[4].s64 = ctx.r[10].s64 + -29900;
	// 8261C558: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261C55C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C560: 913E0020  stw r9, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 8261C564: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C568: 911E0024  stw r8, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[8].u32 ) };
	// 8261C56C: 4BD90EFD  bl 0x823ad468
	ctx.lr = 0x8261C570;
	sub_823AD468(ctx, base);
	// 8261C570: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 8261C574: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261C578: 38878B44  addi r4, r7, -0x74bc
	ctx.r[4].s64 = ctx.r[7].s64 + -29884;
	// 8261C57C: 4BB7A605  bl 0x82196b80
	ctx.lr = 0x8261C580;
	sub_82196B80(ctx, base);
	// 8261C580: D03E005C  stfs f1, 0x5c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8261C584: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 8261C588: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261C58C: 38868B60  addi r4, r6, -0x74a0
	ctx.r[4].s64 = ctx.r[6].s64 + -29856;
	// 8261C590: 4BB7A5F1  bl 0x82196b80
	ctx.lr = 0x8261C594;
	sub_82196B80(ctx, base);
	// 8261C594: D03E0060  stfs f1, 0x60(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8261C598: 93DB0000  stw r30, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8261C59C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8261C5A0: 939B0004  stw r28, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 8261C5A4: 419A0020  beq cr6, 0x8261c5c4
	if ctx.cr[6].eq {
	pc = 0x8261C5C4; continue 'dispatch;
	}
	pc = 0x8261C5A8; continue 'dispatch;
            }
            0x8261C5A8 => {
    //   block [0x8261C5A8..0x8261C5C4)
	// 8261C5A8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8261C5AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261C5B0: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8261C5B4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8261C5B8: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8261C5BC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261C5C0: 4082FFE8  bne 0x8261c5a8
	if !ctx.cr[0].eq {
	pc = 0x8261C5A8; continue 'dispatch;
	}
	pc = 0x8261C5C4; continue 'dispatch;
            }
            0x8261C5C4 => {
    //   block [0x8261C5C4..0x8261C5D8)
	// 8261C5C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261C5C8: 4BB9B551  bl 0x821b7b18
	ctx.lr = 0x8261C5CC;
	sub_821B7B18(ctx, base);
	// 8261C5CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8261C5D0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8261C5D4: 4868CE7C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261C5D8 => {
    //   block [0x8261C5D8..0x8261C5F0)
	// 8261C5D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8261C5DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8261C5E0: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8261C5E4: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8261C5E8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8261C5EC: 4868CE64  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261C5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8261C5F0 size=1200
    let mut pc: u32 = 0x8261C5F0;
    'dispatch: loop {
        match pc {
            0x8261C5F0 => {
    //   block [0x8261C5F0..0x8261C63C)
	// 8261C5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261C5F4: 4868CE05  bl 0x82ca93f8
	ctx.lr = 0x8261C5F8;
	sub_82CA93D0(ctx, base);
	// 8261C5F8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261C5FC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8261C600: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8261C604: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 8261C608: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8261C60C: 4BBBDD3D  bl 0x821da348
	ctx.lr = 0x8261C610;
	sub_821DA348(ctx, base);
	// 8261C610: 4BB95EE9  bl 0x821b24f8
	ctx.lr = 0x8261C614;
	sub_821B24F8(ctx, base);
	// 8261C614: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8261C618: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8261C61C: 419A046C  beq cr6, 0x8261ca88
	if ctx.cr[6].eq {
	pc = 0x8261CA88; continue 'dispatch;
	}
	// 8261C620: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 8261C624: 4BC02C35  bl 0x8221f258
	ctx.lr = 0x8261C628;
	sub_8221F258(ctx, base);
	// 8261C628: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8261C62C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261C630: 419A000C  beq cr6, 0x8261c63c
	if ctx.cr[6].eq {
	pc = 0x8261C63C; continue 'dispatch;
	}
	// 8261C634: 4BFFD755  bl 0x82619d88
	ctx.lr = 0x8261C638;
	sub_82619D88(ctx, base);
	// 8261C638: 48000008  b 0x8261c640
	pc = 0x8261C640; continue 'dispatch;
            }
            0x8261C63C => {
    //   block [0x8261C63C..0x8261C640)
	// 8261C63C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x8261C640; continue 'dispatch;
            }
            0x8261C640 => {
    //   block [0x8261C640..0x8261C664)
	// 8261C640: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8261C644: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261C648: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8261C64C: 419A0018  beq cr6, 0x8261c664
	if ctx.cr[6].eq {
	pc = 0x8261C664; continue 'dispatch;
	}
	// 8261C650: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8261C654: 4800142D  bl 0x8261da80
	ctx.lr = 0x8261C658;
	sub_8261DA80(ctx, base);
	// 8261C658: 8341005C  lwz r26, 0x5c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8261C65C: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261C660: 4800000C  b 0x8261c66c
	pc = 0x8261C66C; continue 'dispatch;
            }
            0x8261C664 => {
    //   block [0x8261C664..0x8261C66C)
	// 8261C664: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 8261C668: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	pc = 0x8261C66C; continue 'dispatch;
            }
            0x8261C66C => {
    //   block [0x8261C66C..0x8261C714)
	// 8261C66C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8261C670: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 8261C674: 917C0034  stw r11, 0x34(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 8261C678: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261C67C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C680: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C684: 792807E6  rldicr r8, r9, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[9].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 8261C688: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8261C68C: 7D075378  or r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 | ctx.r[10].u64;
	// 8261C690: 78E50022  rldicl r5, r7, 0x20, 0x20
	ctx.r[5].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 8261C694: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 8261C698: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 8261C69C: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8261C6A0: F87C0038  std r3, 0x38(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(56 as u32), ctx.r[3].u64 ) };
	// 8261C6A4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261C6A8: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261C6AC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C6B0: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C6B4: 4BC47DD5  bl 0x82264488
	ctx.lr = 0x8261C6B8;
	sub_82264488(ctx, base);
	// 8261C6B8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8261C6BC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8261C6C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8261C6C4: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 8261C6C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261C6CC: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 8261C6D0: 4BBF81C9  bl 0x82214898
	ctx.lr = 0x8261C6D4;
	sub_82214898(ctx, base);
	// 8261C6D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8261C6D8: 387C0048  addi r3, r28, 0x48
	ctx.r[3].s64 = ctx.r[28].s64 + 72;
	// 8261C6DC: 4BEB57ED  bl 0x824d1ec8
	ctx.lr = 0x8261C6E0;
	sub_824D1EC8(ctx, base);
	// 8261C6E0: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 8261C6E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261C6E8: 38A60B7C  addi r5, r6, 0xb7c
	ctx.r[5].s64 = ctx.r[6].s64 + 2940;
	// 8261C6EC: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 8261C6F0: 4BB77749  bl 0x82193e38
	ctx.lr = 0x8261C6F4;
	sub_82193E38(ctx, base);
	// 8261C6F4: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 8261C6F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8261C6FC: 38848E7C  addi r4, r4, -0x7184
	ctx.r[4].s64 = ctx.r[4].s64 + -29060;
	// 8261C700: 4BC8D2E9  bl 0x822a99e8
	ctx.lr = 0x8261C704;
	sub_822A99E8(ctx, base);
	// 8261C704: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261C708: 419A000C  beq cr6, 0x8261c714
	if ctx.cr[6].eq {
	pc = 0x8261C714; continue 'dispatch;
	}
	// 8261C70C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8261C710: 4BBD2921  bl 0x821ef030
	ctx.lr = 0x8261C714;
	sub_821EF030(ctx, base);
	pc = 0x8261C714; continue 'dispatch;
            }
            0x8261C714 => {
    //   block [0x8261C714..0x8261C754)
	// 8261C714: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8261C718: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261C71C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261C720: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C724: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C728: 4BC0FA91  bl 0x8222c1b8
	ctx.lr = 0x8261C72C;
	sub_8222C1B8(ctx, base);
	// 8261C72C: 39630014  addi r11, r3, 0x14
	ctx.r[11].s64 = ctx.r[3].s64 + 20;
	// 8261C730: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C734: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C738: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 8261C73C: 409A0018  bne cr6, 0x8261c754
	if !ctx.cr[6].eq {
	pc = 0x8261C754; continue 'dispatch;
	}
	// 8261C740: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C744: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261C748: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C74C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8261C750: 419A0008  beq cr6, 0x8261c758
	if ctx.cr[6].eq {
	pc = 0x8261C758; continue 'dispatch;
	}
	pc = 0x8261C754; continue 'dispatch;
            }
            0x8261C754 => {
    //   block [0x8261C754..0x8261C758)
	// 8261C754: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8261C758; continue 'dispatch;
            }
            0x8261C758 => {
    //   block [0x8261C758..0x8261C7C4)
	// 8261C758: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261C75C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261C760: 419A028C  beq cr6, 0x8261c9ec
	if ctx.cr[6].eq {
	pc = 0x8261C9EC; continue 'dispatch;
	}
	// 8261C764: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8261C768: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261C76C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 8261C770: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261C774: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261C778: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C77C: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C780: 4BC47D09  bl 0x82264488
	ctx.lr = 0x8261C784;
	sub_82264488(ctx, base);
	// 8261C784: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8261C788: 81060030  lwz r8, 0x30(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261C78C: 550737FE  rlwinm r7, r8, 6, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x03FFFFFFu64;
	// 8261C790: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261C794: 419A00F4  beq cr6, 0x8261c888
	if ctx.cr[6].eq {
	pc = 0x8261C888; continue 'dispatch;
	}
	// 8261C798: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261C79C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261C7A0: 419A0024  beq cr6, 0x8261c7c4
	if ctx.cr[6].eq {
	pc = 0x8261C7C4; continue 'dispatch;
	}
	// 8261C7A4: 894B007A  lbz r10, 0x7a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(122 as u32) ) } as u64;
	// 8261C7A8: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261C7AC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8261C7B0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261C7B4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C7B8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8261C7BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261C7C0: 480000CC  b 0x8261c88c
	pc = 0x8261C88C; continue 'dispatch;
            }
            0x8261C7C4 => {
    //   block [0x8261C7C4..0x8261C7E0)
	// 8261C7C4: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261C7C8: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261C7CC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8261C7D0: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 8261C7D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8261C7D8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261C7DC: 40810054  ble 0x8261c830
	if !ctx.cr[0].gt {
	pc = 0x8261C830; continue 'dispatch;
	}
	pc = 0x8261C7E0; continue 'dispatch;
            }
            0x8261C7E0 => {
    //   block [0x8261C7E0..0x8261C800)
	// 8261C7E0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261C7E4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261C7E8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8261C7EC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C7F0: 2F07007A  cmpwi cr6, r7, 0x7a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 122, &mut ctx.xer);
	// 8261C7F4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8261C7F8: 41980008  blt cr6, 0x8261c800
	if ctx.cr[6].lt {
	pc = 0x8261C800; continue 'dispatch;
	}
	// 8261C7FC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x8261C800; continue 'dispatch;
            }
            0x8261C800 => {
    //   block [0x8261C800..0x8261C81C)
	// 8261C800: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8261C804: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261C808: 419A0014  beq cr6, 0x8261c81c
	if ctx.cr[6].eq {
	pc = 0x8261C81C; continue 'dispatch;
	}
	// 8261C80C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261C810: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8261C814: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8261C818: 4800000C  b 0x8261c824
	pc = 0x8261C824; continue 'dispatch;
            }
            0x8261C81C => {
    //   block [0x8261C81C..0x8261C824)
	// 8261C81C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261C820: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8261C824; continue 'dispatch;
            }
            0x8261C824 => {
    //   block [0x8261C824..0x8261C830)
	// 8261C824: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261C828: 4199FFB8  bgt cr6, 0x8261c7e0
	if ctx.cr[6].gt {
	pc = 0x8261C7E0; continue 'dispatch;
	}
	// 8261C82C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8261C830; continue 'dispatch;
            }
            0x8261C830 => {
    //   block [0x8261C830..0x8261C84C)
	// 8261C830: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 8261C834: 419A0040  beq cr6, 0x8261c874
	if ctx.cr[6].eq {
	pc = 0x8261C874; continue 'dispatch;
	}
	// 8261C838: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C83C: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 8261C840: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261C844: 41990008  bgt cr6, 0x8261c84c
	if ctx.cr[6].gt {
	pc = 0x8261C84C; continue 'dispatch;
	}
	// 8261C848: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8261C84C; continue 'dispatch;
            }
            0x8261C84C => {
    //   block [0x8261C84C..0x8261C874)
	// 8261C84C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261C850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261C854: 409A0020  bne cr6, 0x8261c874
	if !ctx.cr[6].eq {
	pc = 0x8261C874; continue 'dispatch;
	}
	// 8261C858: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8261C85C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8261C860: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261C864: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C868: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8261C86C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261C870: 4800001C  b 0x8261c88c
	pc = 0x8261C88C; continue 'dispatch;
            }
            0x8261C874 => {
    //   block [0x8261C874..0x8261C888)
	// 8261C874: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8261C878: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C87C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8261C880: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261C884: 48000008  b 0x8261c88c
	pc = 0x8261C88C; continue 'dispatch;
            }
            0x8261C888 => {
    //   block [0x8261C888..0x8261C88C)
	// 8261C888: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8261C88C; continue 'dispatch;
            }
            0x8261C88C => {
    //   block [0x8261C88C..0x8261C8B4)
	// 8261C88C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261C890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261C894: 419A0158  beq cr6, 0x8261c9ec
	if ctx.cr[6].eq {
	pc = 0x8261C9EC; continue 'dispatch;
	}
	// 8261C898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261C89C: 4BBA617D  bl 0x821c2a18
	ctx.lr = 0x8261C8A0;
	sub_821C2A18(ctx, base);
	// 8261C8A0: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 8261C8A4: 409A0010  bne cr6, 0x8261c8b4
	if !ctx.cr[6].eq {
	pc = 0x8261C8B4; continue 'dispatch;
	}
	// 8261C8A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261C8AC: 388B8C50  addi r4, r11, -0x73b0
	ctx.r[4].s64 = ctx.r[11].s64 + -29616;
	// 8261C8B0: 48000120  b 0x8261c9d0
	pc = 0x8261C9D0; continue 'dispatch;
            }
            0x8261C8B4 => {
    //   block [0x8261C8B4..0x8261C8F0)
	// 8261C8B4: 81460024  lwz r10, 0x24(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 8261C8B8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 8261C8BC: 5549A7FE  rlwinm r9, r10, 0x14, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000FFFu64;
	// 8261C8C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261C8C4: 419A00E8  beq cr6, 0x8261c9ac
	if ctx.cr[6].eq {
	pc = 0x8261C9AC; continue 'dispatch;
	}
	// 8261C8C8: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261C8CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261C8D0: 419A0020  beq cr6, 0x8261c8f0
	if ctx.cr[6].eq {
	pc = 0x8261C8F0; continue 'dispatch;
	}
	// 8261C8D4: 894B000C  lbz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261C8D8: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261C8DC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8261C8E0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261C8E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261C8E8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C8EC: 480000C4  b 0x8261c9b0
	pc = 0x8261C9B0; continue 'dispatch;
            }
            0x8261C8F0 => {
    //   block [0x8261C8F0..0x8261C90C)
	// 8261C8F0: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261C8F4: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261C8F8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8261C8FC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8261C900: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8261C904: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261C908: 40810054  ble 0x8261c95c
	if !ctx.cr[0].gt {
	pc = 0x8261C95C; continue 'dispatch;
	}
	pc = 0x8261C90C; continue 'dispatch;
            }
            0x8261C90C => {
    //   block [0x8261C90C..0x8261C92C)
	// 8261C90C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261C910: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261C914: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8261C918: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C91C: 2F07000C  cmpwi cr6, r7, 0xc
	ctx.cr[6].compare_i32(ctx.r[7].s32, 12, &mut ctx.xer);
	// 8261C920: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8261C924: 41980008  blt cr6, 0x8261c92c
	if ctx.cr[6].lt {
	pc = 0x8261C92C; continue 'dispatch;
	}
	// 8261C928: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x8261C92C; continue 'dispatch;
            }
            0x8261C92C => {
    //   block [0x8261C92C..0x8261C948)
	// 8261C92C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8261C930: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261C934: 419A0014  beq cr6, 0x8261c948
	if ctx.cr[6].eq {
	pc = 0x8261C948; continue 'dispatch;
	}
	// 8261C938: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261C93C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8261C940: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8261C944: 4800000C  b 0x8261c950
	pc = 0x8261C950; continue 'dispatch;
            }
            0x8261C948 => {
    //   block [0x8261C948..0x8261C950)
	// 8261C948: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261C94C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8261C950; continue 'dispatch;
            }
            0x8261C950 => {
    //   block [0x8261C950..0x8261C95C)
	// 8261C950: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261C954: 4199FFB8  bgt cr6, 0x8261c90c
	if ctx.cr[6].gt {
	pc = 0x8261C90C; continue 'dispatch;
	}
	// 8261C958: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8261C95C; continue 'dispatch;
            }
            0x8261C95C => {
    //   block [0x8261C95C..0x8261C978)
	// 8261C95C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8261C960: 419A003C  beq cr6, 0x8261c99c
	if ctx.cr[6].eq {
	pc = 0x8261C99C; continue 'dispatch;
	}
	// 8261C964: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261C968: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 8261C96C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261C970: 41990008  bgt cr6, 0x8261c978
	if ctx.cr[6].gt {
	pc = 0x8261C978; continue 'dispatch;
	}
	// 8261C974: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8261C978; continue 'dispatch;
            }
            0x8261C978 => {
    //   block [0x8261C978..0x8261C99C)
	// 8261C978: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261C97C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261C980: 409A001C  bne cr6, 0x8261c99c
	if !ctx.cr[6].eq {
	pc = 0x8261C99C; continue 'dispatch;
	}
	// 8261C984: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8261C988: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261C98C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8261C990: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261C994: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C998: 48000018  b 0x8261c9b0
	pc = 0x8261C9B0; continue 'dispatch;
            }
            0x8261C99C => {
    //   block [0x8261C99C..0x8261C9AC)
	// 8261C99C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8261C9A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261C9A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261C9A8: 48000008  b 0x8261c9b0
	pc = 0x8261C9B0; continue 'dispatch;
            }
            0x8261C9AC => {
    //   block [0x8261C9AC..0x8261C9B0)
	// 8261C9AC: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x8261C9B0; continue 'dispatch;
            }
            0x8261C9B0 => {
    //   block [0x8261C9B0..0x8261C9D0)
	// 8261C9B0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8261C9B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261C9B8: 419A0034  beq cr6, 0x8261c9ec
	if ctx.cr[6].eq {
	pc = 0x8261C9EC; continue 'dispatch;
	}
	// 8261C9BC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261C9C0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8261C9C4: 409A0028  bne cr6, 0x8261c9ec
	if !ctx.cr[6].eq {
	pc = 0x8261C9EC; continue 'dispatch;
	}
	// 8261C9C8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8261C9CC: 388B8E64  addi r4, r11, -0x719c
	ctx.r[4].s64 = ctx.r[11].s64 + -29084;
	pc = 0x8261C9D0; continue 'dispatch;
            }
            0x8261C9D0 => {
    //   block [0x8261C9D0..0x8261C9EC)
	// 8261C9D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8261C9D4: 4BC8D015  bl 0x822a99e8
	ctx.lr = 0x8261C9D8;
	sub_822A99E8(ctx, base);
	// 8261C9D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8261C9DC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8261C9E0: 419A000C  beq cr6, 0x8261c9ec
	if ctx.cr[6].eq {
	pc = 0x8261C9EC; continue 'dispatch;
	}
	// 8261C9E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8261C9E8: 4BFFF3D1  bl 0x8261bdb8
	ctx.lr = 0x8261C9EC;
	sub_8261BDB8(ctx, base);
	pc = 0x8261C9EC; continue 'dispatch;
            }
            0x8261C9EC => {
    //   block [0x8261C9EC..0x8261CA58)
	// 8261C9EC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8261C9F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261C9F4: 4BBBD955  bl 0x821da348
	ctx.lr = 0x8261C9F8;
	sub_821DA348(ctx, base);
	// 8261C9F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8261C9FC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261CA00: 38BC001C  addi r5, r28, 0x1c
	ctx.r[5].s64 = ctx.r[28].s64 + 28;
	// 8261CA04: 388A8B34  addi r4, r10, -0x74cc
	ctx.r[4].s64 = ctx.r[10].s64 + -29900;
	// 8261CA08: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8261CA0C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CA10: 913C0020  stw r9, 0x20(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 8261CA14: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CA18: 911C0024  stw r8, 0x24(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), ctx.r[8].u32 ) };
	// 8261CA1C: 4BD90A4D  bl 0x823ad468
	ctx.lr = 0x8261CA20;
	sub_823AD468(ctx, base);
	// 8261CA20: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 8261CA24: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8261CA28: 38878B44  addi r4, r7, -0x74bc
	ctx.r[4].s64 = ctx.r[7].s64 + -29884;
	// 8261CA2C: 4BB7A155  bl 0x82196b80
	ctx.lr = 0x8261CA30;
	sub_82196B80(ctx, base);
	// 8261CA30: D03C005C  stfs f1, 0x5c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8261CA34: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 8261CA38: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8261CA3C: 38868B60  addi r4, r6, -0x74a0
	ctx.r[4].s64 = ctx.r[6].s64 + -29856;
	// 8261CA40: 4BB7A141  bl 0x82196b80
	ctx.lr = 0x8261CA44;
	sub_82196B80(ctx, base);
	// 8261CA44: D03C0060  stfs f1, 0x60(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8261CA48: 93990000  stw r28, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8261CA4C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8261CA50: 93590004  stw r26, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 8261CA54: 419A0020  beq cr6, 0x8261ca74
	if ctx.cr[6].eq {
	pc = 0x8261CA74; continue 'dispatch;
	}
	pc = 0x8261CA58; continue 'dispatch;
            }
            0x8261CA58 => {
    //   block [0x8261CA58..0x8261CA74)
	// 8261CA58: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8261CA5C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261CA60: 7D60D028  lwarx r11, 0, r26
	// lwarx
	let ea = ctx.r[26].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8261CA64: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8261CA68: 7D60D12D  stwcx. r11, 0, r26
	// stwcx.
	let addr = ctx.r[26].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8261CA6C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261CA70: 4082FFE8  bne 0x8261ca58
	if !ctx.cr[0].eq {
	pc = 0x8261CA58; continue 'dispatch;
	}
	pc = 0x8261CA74; continue 'dispatch;
            }
            0x8261CA74 => {
    //   block [0x8261CA74..0x8261CA88)
	// 8261CA74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8261CA78: 4BB9B0A1  bl 0x821b7b18
	ctx.lr = 0x8261CA7C;
	sub_821B7B18(ctx, base);
	// 8261CA7C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8261CA80: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8261CA84: 4868C9C4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261CA88 => {
    //   block [0x8261CA88..0x8261CAA0)
	// 8261CA88: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8261CA8C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8261CA90: 93B90000  stw r29, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8261CA94: 93B90004  stw r29, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8261CA98: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8261CA9C: 4868C9AC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261CAA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8261CAA0 size=204
    let mut pc: u32 = 0x8261CAA0;
    'dispatch: loop {
        match pc {
            0x8261CAA0 => {
    //   block [0x8261CAA0..0x8261CACC)
	// 8261CAA0: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CAA4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261CAA8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261CAAC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8261CAB0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8261CAB4: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 8261CAB8: 390A9490  addi r8, r10, -0x6b70
	ctx.r[8].s64 = ctx.r[10].s64 + -27504;
	// 8261CABC: 38EB0E68  addi r7, r11, 0xe68
	ctx.r[7].s64 = ctx.r[11].s64 + 3688;
	// 8261CAC0: C18A9490  lfs f12, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8261CAC4: C0084138  lfs f0, 0x4138(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8261CAC8: C1A8FFF4  lfs f13, -0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x8261CACC; continue 'dispatch;
            }
            0x8261CACC => {
    //   block [0x8261CACC..0x8261CAE0)
	// 8261CACC: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CAD0: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261CAD4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261CAD8: 419A0080  beq cr6, 0x8261cb58
	if ctx.cr[6].eq {
	pc = 0x8261CB58; continue 'dispatch;
	}
	// 8261CADC: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261CAE0; continue 'dispatch;
            }
            0x8261CAE0 => {
    //   block [0x8261CAE0..0x8261CAFC)
	// 8261CAE0: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CAE4: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8261CAE8: 419A0014  beq cr6, 0x8261cafc
	if ctx.cr[6].eq {
	pc = 0x8261CAFC; continue 'dispatch;
	}
	// 8261CAEC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8261CAF0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261CAF4: 409AFFEC  bne cr6, 0x8261cae0
	if !ctx.cr[6].eq {
	pc = 0x8261CAE0; continue 'dispatch;
	}
	// 8261CAF8: 48000060  b 0x8261cb58
	pc = 0x8261CB58; continue 'dispatch;
            }
            0x8261CAFC => {
    //   block [0x8261CAFC..0x8261CB58)
	// 8261CAFC: C1690004  lfs f11, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8261CB00: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 8261CB04: C14B0004  lfs f10, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8261CB08: ED2B507A  fmadds f9, f11, f1, f10
	ctx.f[9].f64 = (((ctx.f[11].f64 * ctx.f[1].f64 + ctx.f[10].f64) as f32) as f64);
	// 8261CB0C: D12B0004  stfs f9, 4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8261CB10: FD004890  fmr f8, f9
	ctx.f[8].f64 = ctx.f[9].f64;
	// 8261CB14: ECE80028  fsubs f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 8261CB18: FF076800  fcmpu cr6, f7, f13
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[13].f64);
	// 8261CB1C: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 8261CB20: 5548DF7A  rlwinm r8, r10, 0x1b, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 8261CB24: 5546F77A  rlwinm r6, r10, 0x1e, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 8261CB28: 7D053378  or r5, r8, r6
	ctx.r[5].u64 = ctx.r[8].u64 | ctx.r[6].u64;
	// 8261CB2C: 7CC72C2E  lfsx f6, r7, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 8261CB30: FCA6022E  fsel f5, f6, f8, f0
	ctx.f[5].f64 = if ctx.f[6].f64 >= 0.0 { ctx.f[8].f64 } else { ctx.f[0].f64 };
	// 8261CB34: EC856028  fsubs f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 - ctx.f[12].f64) as f32) as f64);
	// 8261CB38: FF046800  fcmpu cr6, f4, f13
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[13].f64);
	// 8261CB3C: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 8261CB40: 5548DF7A  rlwinm r8, r10, 0x1b, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 8261CB44: 5546F77A  rlwinm r6, r10, 0x1e, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 8261CB48: 7D053378  or r5, r8, r6
	ctx.r[5].u64 = ctx.r[8].u64 | ctx.r[6].u64;
	// 8261CB4C: 7C672C2E  lfsx f3, r7, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8261CB50: FC432B2E  fsel f2, f3, f12, f5
	ctx.f[2].f64 = if ctx.f[3].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[5].f64 };
	// 8261CB54: D04B0004  stfs f2, 4(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x8261CB58; continue 'dispatch;
            }
            0x8261CB58 => {
    //   block [0x8261CB58..0x8261CB6C)
	// 8261CB58: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261CB5C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 8261CB60: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261CB64: 409AFF68  bne cr6, 0x8261cacc
	if !ctx.cr[6].eq {
	pc = 0x8261CACC; continue 'dispatch;
	}
	// 8261CB68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261CB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8261CB70 size=2336
    let mut pc: u32 = 0x8261CB70;
    'dispatch: loop {
        match pc {
            0x8261CB70 => {
    //   block [0x8261CB70..0x8261CBD4)
	// 8261CB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261CB74: 4868C87D  bl 0x82ca93f0
	ctx.lr = 0x8261CB78;
	sub_82CA93D0(ctx, base);
	// 8261CB78: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 8261CB7C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261CB80: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8261CB84: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261CB88: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 8261CB8C: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 8261CB90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261CB94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CB98: 388A8C68  addi r4, r10, -0x7398
	ctx.r[4].s64 = ctx.r[10].s64 + -29592;
	// 8261CB9C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CBA0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8261CBA4: 4E800421  bctrl
	ctx.lr = 0x8261CBA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261CBA8: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8261CBAC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8261CBB0: 38888C7C  addi r4, r8, -0x7384
	ctx.r[4].s64 = ctx.r[8].s64 + -29572;
	// 8261CBB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261CBB8: 4BC10319  bl 0x8222ced0
	ctx.lr = 0x8261CBBC;
	sub_8222CED0(ctx, base);
	// 8261CBBC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261CBC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261CBC4: 409A0010  bne cr6, 0x8261cbd4
	if !ctx.cr[6].eq {
	pc = 0x8261CBD4; continue 'dispatch;
	}
	// 8261CBC8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8261CBCC: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 8261CBD0: 48000008  b 0x8261cbd8
	pc = 0x8261CBD8; continue 'dispatch;
            }
            0x8261CBD4 => {
    //   block [0x8261CBD4..0x8261CBD8)
	// 8261CBD4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261CBD8; continue 'dispatch;
            }
            0x8261CBD8 => {
    //   block [0x8261CBD8..0x8261CC08)
	// 8261CBD8: 38B70258  addi r5, r23, 0x258
	ctx.r[5].s64 = ctx.r[23].s64 + 600;
	// 8261CBDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261CBE0: 4BE63BE9  bl 0x824807c8
	ctx.lr = 0x8261CBE4;
	sub_824807C8(ctx, base);
	// 8261CBE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261CBE8: 4BBF81F1  bl 0x82214dd8
	ctx.lr = 0x8261CBEC;
	sub_82214DD8(ctx, base);
	// 8261CBEC: 56CB063E  clrlwi r11, r22, 0x18
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	// 8261CBF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261CBF4: 419A0330  beq cr6, 0x8261cf24
	if ctx.cr[6].eq {
	pc = 0x8261CF24; continue 'dispatch;
	}
	// 8261CBF8: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CBFC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261CC00: 3B8A8C88  addi r28, r10, -0x7378
	ctx.r[28].s64 = ctx.r[10].s64 + -29560;
	// 8261CC04: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261CC08; continue 'dispatch;
            }
            0x8261CC08 => {
    //   block [0x8261CC08..0x8261CC28)
	// 8261CC08: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261CC0C: 419A009C  beq cr6, 0x8261cca8
	if ctx.cr[6].eq {
	pc = 0x8261CCA8; continue 'dispatch;
	}
	// 8261CC10: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261CC14: 83BE0008  lwz r29, 8(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261CC18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261CC1C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8261CC20: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8261CC24: 419A0020  beq cr6, 0x8261cc44
	if ctx.cr[6].eq {
	pc = 0x8261CC44; continue 'dispatch;
	}
	pc = 0x8261CC28; continue 'dispatch;
            }
            0x8261CC28 => {
    //   block [0x8261CC28..0x8261CC44)
	// 8261CC28: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8261CC2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261CC30: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8261CC34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8261CC38: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8261CC3C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261CC40: 4082FFE8  bne 0x8261cc28
	if !ctx.cr[0].eq {
	pc = 0x8261CC28; continue 'dispatch;
	}
	pc = 0x8261CC44; continue 'dispatch;
            }
            0x8261CC44 => {
    //   block [0x8261CC44..0x8261CC88)
	// 8261CC44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8261CC48: 419A0040  beq cr6, 0x8261cc88
	if ctx.cr[6].eq {
	pc = 0x8261CC88; continue 'dispatch;
	}
	// 8261CC4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CC50: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8261CC54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261CC58: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CC5C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261CC60: 4E800421  bctrl
	ctx.lr = 0x8261CC64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261CC64: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 8261CC68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261CC6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261CC70: 4BFFD3E1  bl 0x8261a050
	ctx.lr = 0x8261CC74;
	sub_8261A050(ctx, base);
	// 8261CC74: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CC78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261CC7C: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261CC80: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8261CC84: 4E800421  bctrl
	ctx.lr = 0x8261CC88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8261CC88 => {
    //   block [0x8261CC88..0x8261CCA0)
	// 8261CC88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261CC8C: 4BB9AE8D  bl 0x821b7b18
	ctx.lr = 0x8261CC90;
	sub_821B7B18(ctx, base);
	// 8261CC90: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CC94: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261CC98: 409A0008  bne cr6, 0x8261cca0
	if !ctx.cr[6].eq {
	pc = 0x8261CCA0; continue 'dispatch;
	}
	// 8261CC9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261CCA0; continue 'dispatch;
            }
            0x8261CCA0 => {
    //   block [0x8261CCA0..0x8261CCA8)
	// 8261CCA0: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CCA4: 4BFFFF64  b 0x8261cc08
	pc = 0x8261CC08; continue 'dispatch;
            }
            0x8261CCA8 => {
    //   block [0x8261CCA8..0x8261CCBC)
	// 8261CCA8: 81770010  lwz r11, 0x10(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(16 as u32) ) } as u64;
	// 8261CCAC: 3B97000C  addi r28, r23, 0xc
	ctx.r[28].s64 = ctx.r[23].s64 + 12;
	// 8261CCB0: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CCB4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261CCB8: 3B6B8C90  addi r27, r11, -0x7370
	ctx.r[27].s64 = ctx.r[11].s64 + -29552;
	pc = 0x8261CCBC; continue 'dispatch;
            }
            0x8261CCBC => {
    //   block [0x8261CCBC..0x8261CCCC)
	// 8261CCBC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CCC0: 7F1CE040  cmplw cr6, r28, r28
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8261CCC4: 419A0008  beq cr6, 0x8261cccc
	if ctx.cr[6].eq {
	pc = 0x8261CCCC; continue 'dispatch;
	}
	// 8261CCC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261CCCC; continue 'dispatch;
            }
            0x8261CCCC => {
    //   block [0x8261CCCC..0x8261CCE4)
	// 8261CCCC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261CCD0: 419A00AC  beq cr6, 0x8261cd7c
	if ctx.cr[6].eq {
	pc = 0x8261CD7C; continue 'dispatch;
	}
	// 8261CCD4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CCD8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261CCDC: 409A0008  bne cr6, 0x8261cce4
	if !ctx.cr[6].eq {
	pc = 0x8261CCE4; continue 'dispatch;
	}
	// 8261CCE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261CCE4; continue 'dispatch;
            }
            0x8261CCE4 => {
    //   block [0x8261CCE4..0x8261CCFC)
	// 8261CCE4: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261CCE8: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261CCEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261CCF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8261CCF4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8261CCF8: 419A0020  beq cr6, 0x8261cd18
	if ctx.cr[6].eq {
	pc = 0x8261CD18; continue 'dispatch;
	}
	pc = 0x8261CCFC; continue 'dispatch;
            }
            0x8261CCFC => {
    //   block [0x8261CCFC..0x8261CD18)
	// 8261CCFC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8261CD00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261CD04: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8261CD08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8261CD0C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8261CD10: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261CD14: 4082FFE8  bne 0x8261ccfc
	if !ctx.cr[0].eq {
	pc = 0x8261CCFC; continue 'dispatch;
	}
	pc = 0x8261CD18; continue 'dispatch;
            }
            0x8261CD18 => {
    //   block [0x8261CD18..0x8261CD5C)
	// 8261CD18: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261CD1C: 419A0040  beq cr6, 0x8261cd5c
	if ctx.cr[6].eq {
	pc = 0x8261CD5C; continue 'dispatch;
	}
	// 8261CD20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CD24: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8261CD28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261CD2C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CD30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261CD34: 4E800421  bctrl
	ctx.lr = 0x8261CD38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261CD38: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 8261CD3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261CD40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261CD44: 4BFFD8D5  bl 0x8261a618
	ctx.lr = 0x8261CD48;
	sub_8261A618(ctx, base);
	// 8261CD48: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CD4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261CD50: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261CD54: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8261CD58: 4E800421  bctrl
	ctx.lr = 0x8261CD5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8261CD5C => {
    //   block [0x8261CD5C..0x8261CD74)
	// 8261CD5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261CD60: 4BB9ADB9  bl 0x821b7b18
	ctx.lr = 0x8261CD64;
	sub_821B7B18(ctx, base);
	// 8261CD64: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CD68: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261CD6C: 409A0008  bne cr6, 0x8261cd74
	if !ctx.cr[6].eq {
	pc = 0x8261CD74; continue 'dispatch;
	}
	// 8261CD70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261CD74; continue 'dispatch;
            }
            0x8261CD74 => {
    //   block [0x8261CD74..0x8261CD7C)
	// 8261CD74: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CD78: 4BFFFF44  b 0x8261ccbc
	pc = 0x8261CCBC; continue 'dispatch;
            }
            0x8261CD7C => {
    //   block [0x8261CD7C..0x8261CD90)
	// 8261CD7C: 8177001C  lwz r11, 0x1c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(28 as u32) ) } as u64;
	// 8261CD80: 3B970018  addi r28, r23, 0x18
	ctx.r[28].s64 = ctx.r[23].s64 + 24;
	// 8261CD84: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CD88: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261CD8C: 3B6B8CA0  addi r27, r11, -0x7360
	ctx.r[27].s64 = ctx.r[11].s64 + -29536;
	pc = 0x8261CD90; continue 'dispatch;
            }
            0x8261CD90 => {
    //   block [0x8261CD90..0x8261CDA0)
	// 8261CD90: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CD94: 7F1CE040  cmplw cr6, r28, r28
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8261CD98: 419A0008  beq cr6, 0x8261cda0
	if ctx.cr[6].eq {
	pc = 0x8261CDA0; continue 'dispatch;
	}
	// 8261CD9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261CDA0; continue 'dispatch;
            }
            0x8261CDA0 => {
    //   block [0x8261CDA0..0x8261CDB8)
	// 8261CDA0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261CDA4: 419A00AC  beq cr6, 0x8261ce50
	if ctx.cr[6].eq {
	pc = 0x8261CE50; continue 'dispatch;
	}
	// 8261CDA8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CDAC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261CDB0: 409A0008  bne cr6, 0x8261cdb8
	if !ctx.cr[6].eq {
	pc = 0x8261CDB8; continue 'dispatch;
	}
	// 8261CDB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261CDB8; continue 'dispatch;
            }
            0x8261CDB8 => {
    //   block [0x8261CDB8..0x8261CDD0)
	// 8261CDB8: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261CDBC: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261CDC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261CDC4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8261CDC8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8261CDCC: 419A0020  beq cr6, 0x8261cdec
	if ctx.cr[6].eq {
	pc = 0x8261CDEC; continue 'dispatch;
	}
	pc = 0x8261CDD0; continue 'dispatch;
            }
            0x8261CDD0 => {
    //   block [0x8261CDD0..0x8261CDEC)
	// 8261CDD0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8261CDD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261CDD8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8261CDDC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8261CDE0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8261CDE4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261CDE8: 4082FFE8  bne 0x8261cdd0
	if !ctx.cr[0].eq {
	pc = 0x8261CDD0; continue 'dispatch;
	}
	pc = 0x8261CDEC; continue 'dispatch;
            }
            0x8261CDEC => {
    //   block [0x8261CDEC..0x8261CE30)
	// 8261CDEC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261CDF0: 419A0040  beq cr6, 0x8261ce30
	if ctx.cr[6].eq {
	pc = 0x8261CE30; continue 'dispatch;
	}
	// 8261CDF4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CDF8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8261CDFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261CE00: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CE04: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261CE08: 4E800421  bctrl
	ctx.lr = 0x8261CE0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261CE0C: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 8261CE10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261CE14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261CE18: 4BFFD801  bl 0x8261a618
	ctx.lr = 0x8261CE1C;
	sub_8261A618(ctx, base);
	// 8261CE1C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CE20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261CE24: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261CE28: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8261CE2C: 4E800421  bctrl
	ctx.lr = 0x8261CE30;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8261CE30 => {
    //   block [0x8261CE30..0x8261CE48)
	// 8261CE30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261CE34: 4BB9ACE5  bl 0x821b7b18
	ctx.lr = 0x8261CE38;
	sub_821B7B18(ctx, base);
	// 8261CE38: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CE3C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261CE40: 409A0008  bne cr6, 0x8261ce48
	if !ctx.cr[6].eq {
	pc = 0x8261CE48; continue 'dispatch;
	}
	// 8261CE44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261CE48; continue 'dispatch;
            }
            0x8261CE48 => {
    //   block [0x8261CE48..0x8261CE50)
	// 8261CE48: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CE4C: 4BFFFF44  b 0x8261cd90
	pc = 0x8261CD90; continue 'dispatch;
            }
            0x8261CE50 => {
    //   block [0x8261CE50..0x8261CE64)
	// 8261CE50: 81770028  lwz r11, 0x28(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261CE54: 3B970024  addi r28, r23, 0x24
	ctx.r[28].s64 = ctx.r[23].s64 + 36;
	// 8261CE58: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CE5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261CE60: 3B6B8CB4  addi r27, r11, -0x734c
	ctx.r[27].s64 = ctx.r[11].s64 + -29516;
	pc = 0x8261CE64; continue 'dispatch;
            }
            0x8261CE64 => {
    //   block [0x8261CE64..0x8261CE74)
	// 8261CE64: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CE68: 7F1CE040  cmplw cr6, r28, r28
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8261CE6C: 419A0008  beq cr6, 0x8261ce74
	if ctx.cr[6].eq {
	pc = 0x8261CE74; continue 'dispatch;
	}
	// 8261CE70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261CE74; continue 'dispatch;
            }
            0x8261CE74 => {
    //   block [0x8261CE74..0x8261CE8C)
	// 8261CE74: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261CE78: 419A052C  beq cr6, 0x8261d3a4
	if ctx.cr[6].eq {
	pc = 0x8261D3A4; continue 'dispatch;
	}
	// 8261CE7C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CE80: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261CE84: 409A0008  bne cr6, 0x8261ce8c
	if !ctx.cr[6].eq {
	pc = 0x8261CE8C; continue 'dispatch;
	}
	// 8261CE88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261CE8C; continue 'dispatch;
            }
            0x8261CE8C => {
    //   block [0x8261CE8C..0x8261CEA4)
	// 8261CE8C: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261CE90: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261CE94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261CE98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8261CE9C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8261CEA0: 419A0020  beq cr6, 0x8261cec0
	if ctx.cr[6].eq {
	pc = 0x8261CEC0; continue 'dispatch;
	}
	pc = 0x8261CEA4; continue 'dispatch;
            }
            0x8261CEA4 => {
    //   block [0x8261CEA4..0x8261CEC0)
	// 8261CEA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8261CEA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261CEAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8261CEB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8261CEB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8261CEB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261CEBC: 4082FFE8  bne 0x8261cea4
	if !ctx.cr[0].eq {
	pc = 0x8261CEA4; continue 'dispatch;
	}
	pc = 0x8261CEC0; continue 'dispatch;
            }
            0x8261CEC0 => {
    //   block [0x8261CEC0..0x8261CF04)
	// 8261CEC0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261CEC4: 419A0040  beq cr6, 0x8261cf04
	if ctx.cr[6].eq {
	pc = 0x8261CF04; continue 'dispatch;
	}
	// 8261CEC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CECC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8261CED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261CED4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CED8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261CEDC: 4E800421  bctrl
	ctx.lr = 0x8261CEE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261CEE0: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 8261CEE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261CEE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261CEEC: 4BFFEA65  bl 0x8261b950
	ctx.lr = 0x8261CEF0;
	sub_8261B950(ctx, base);
	// 8261CEF0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CEF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261CEF8: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261CEFC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8261CF00: 4E800421  bctrl
	ctx.lr = 0x8261CF04;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8261CF04 => {
    //   block [0x8261CF04..0x8261CF1C)
	// 8261CF04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261CF08: 4BB9AC11  bl 0x821b7b18
	ctx.lr = 0x8261CF0C;
	sub_821B7B18(ctx, base);
	// 8261CF0C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261CF10: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261CF14: 409A0008  bne cr6, 0x8261cf1c
	if !ctx.cr[6].eq {
	pc = 0x8261CF1C; continue 'dispatch;
	}
	// 8261CF18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261CF1C; continue 'dispatch;
            }
            0x8261CF1C => {
    //   block [0x8261CF1C..0x8261CF24)
	// 8261CF1C: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CF20: 4BFFFF44  b 0x8261ce64
	pc = 0x8261CE64; continue 'dispatch;
            }
            0x8261CF24 => {
    //   block [0x8261CF24..0x8261CF68)
	// 8261CF24: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 8261CF28: 48183EF1  bl 0x827a0e18
	ctx.lr = 0x8261CF2C;
	sub_827A0E18(ctx, base);
	// 8261CF2C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261CF30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261CF34: 3BAB8C88  addi r29, r11, -0x7378
	ctx.r[29].s64 = ctx.r[11].s64 + -29560;
	// 8261CF38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261CF3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CF40: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261CF44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261CF48: 4E800421  bctrl
	ctx.lr = 0x8261CF4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261CF4C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261CF50: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8261CF54: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 8261CF58: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 8261CF5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261CF60: 419A00E4  beq cr6, 0x8261d044
	if ctx.cr[6].eq {
	pc = 0x8261D044; continue 'dispatch;
	}
	// 8261CF64: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
            }
            0x8261CF68 => {
    //   block [0x8261CF68..0x8261CF94)
	// 8261CF68: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 8261CF6C: 4BC02355  bl 0x8221f2c0
	ctx.lr = 0x8261CF70;
	sub_8221F2C0(ctx, base);
	// 8261CF70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261CF74: 409A0450  bne cr6, 0x8261d3c4
	if !ctx.cr[6].eq {
	pc = 0x8261D3C4; continue 'dispatch;
	}
	// 8261CF78: 81796F6C  lwz r11, 0x6f6c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28524 as u32) ) } as u64;
	// 8261CF7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261CF80: 419A0014  beq cr6, 0x8261cf94
	if ctx.cr[6].eq {
	pc = 0x8261CF94; continue 'dispatch;
	}
	// 8261CF84: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261CF88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8261CF8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8261CF90: 4E800421  bctrl
	ctx.lr = 0x8261CF94;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8261CF94 => {
    //   block [0x8261CF94..0x8261CF9C)
	// 8261CF94: 486A5415  bl 0x82cc23a8
	ctx.lr = 0x8261CF98;
	sub_82CC23A8(ctx, base);
	// 8261CF98: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x8261CF9C; continue 'dispatch;
            }
            0x8261CF9C => {
    //   block [0x8261CF9C..0x8261CFD4)
	// 8261CF9C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8261CFA0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261CFA4: 419A0034  beq cr6, 0x8261cfd8
	if ctx.cr[6].eq {
	pc = 0x8261CFD8; continue 'dispatch;
	}
	// 8261CFA8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8261CFAC: 4BC02315  bl 0x8221f2c0
	ctx.lr = 0x8261CFB0;
	sub_8221F2C0(ctx, base);
	// 8261CFB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261CFB4: 409A041C  bne cr6, 0x8261d3d0
	if !ctx.cr[6].eq {
	pc = 0x8261D3D0; continue 'dispatch;
	}
	// 8261CFB8: 81796F6C  lwz r11, 0x6f6c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28524 as u32) ) } as u64;
	// 8261CFBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261CFC0: 419A0014  beq cr6, 0x8261cfd4
	if ctx.cr[6].eq {
	pc = 0x8261CFD4; continue 'dispatch;
	}
	// 8261CFC4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261CFC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8261CFCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8261CFD0: 4E800421  bctrl
	ctx.lr = 0x8261CFD4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8261CFD4 => {
    //   block [0x8261CFD4..0x8261CFD8)
	// 8261CFD4: 486A53D5  bl 0x82cc23a8
	ctx.lr = 0x8261CFD8;
	sub_82CC23A8(ctx, base);
	pc = 0x8261CFD8; continue 'dispatch;
            }
            0x8261CFD8 => {
    //   block [0x8261CFD8..0x8261CFDC)
	// 8261CFD8: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	pc = 0x8261CFDC; continue 'dispatch;
            }
            0x8261CFDC => {
    //   block [0x8261CFDC..0x8261D044)
	// 8261CFDC: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 8261CFE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261CFE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261CFE8: 4BFFD069  bl 0x8261a050
	ctx.lr = 0x8261CFEC;
	sub_8261A050(ctx, base);
	// 8261CFEC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261CFF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261CFF4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261CFF8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261CFFC: 4E800421  bctrl
	ctx.lr = 0x8261D000;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261D000: 81370004  lwz r9, 4(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D004: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8261D008: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 8261D00C: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 8261D010: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261D014: 48000AD5  bl 0x8261dae8
	ctx.lr = 0x8261D018;
	sub_8261DAE8(ctx, base);
	// 8261D018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261D01C: 4BB9AAFD  bl 0x821b7b18
	ctx.lr = 0x8261D020;
	sub_821B7B18(ctx, base);
	// 8261D020: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D024: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261D028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261D02C: 80E80008  lwz r7, 8(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261D030: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 8261D034: 4E800421  bctrl
	ctx.lr = 0x8261D038;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261D038: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261D03C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8261D040: 409AFF28  bne cr6, 0x8261cf68
	if !ctx.cr[6].eq {
	pc = 0x8261CF68; continue 'dispatch;
	}
            }
            0x8261D044 => {
    //   block [0x8261D044..0x8261D084)
	// 8261D044: 3BB7000C  addi r29, r23, 0xc
	ctx.r[29].s64 = ctx.r[23].s64 + 12;
	// 8261D048: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261D04C: 48183DCD  bl 0x827a0e18
	ctx.lr = 0x8261D050;
	sub_827A0E18(ctx, base);
	// 8261D050: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261D054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261D058: 3B8B8C90  addi r28, r11, -0x7370
	ctx.r[28].s64 = ctx.r[11].s64 + -29552;
	// 8261D05C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8261D060: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D064: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261D068: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261D06C: 4E800421  bctrl
	ctx.lr = 0x8261D070;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261D070: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261D074: 3F608332  lis r27, -0x7cce
	ctx.r[27].s64 = -2093875200;
	// 8261D078: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261D07C: 419A00E4  beq cr6, 0x8261d160
	if ctx.cr[6].eq {
	pc = 0x8261D160; continue 'dispatch;
	}
	// 8261D080: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
            }
            0x8261D084 => {
    //   block [0x8261D084..0x8261D0B0)
	// 8261D084: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8261D088: 4BC02239  bl 0x8221f2c0
	ctx.lr = 0x8261D08C;
	sub_8221F2C0(ctx, base);
	// 8261D08C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261D090: 409A035C  bne cr6, 0x8261d3ec
	if !ctx.cr[6].eq {
	pc = 0x8261D3EC; continue 'dispatch;
	}
	// 8261D094: 81796F6C  lwz r11, 0x6f6c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28524 as u32) ) } as u64;
	// 8261D098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261D09C: 419A0014  beq cr6, 0x8261d0b0
	if ctx.cr[6].eq {
	pc = 0x8261D0B0; continue 'dispatch;
	}
	// 8261D0A0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261D0A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8261D0A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8261D0AC: 4E800421  bctrl
	ctx.lr = 0x8261D0B0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8261D0B0 => {
    //   block [0x8261D0B0..0x8261D0B8)
	// 8261D0B0: 486A52F9  bl 0x82cc23a8
	ctx.lr = 0x8261D0B4;
	sub_82CC23A8(ctx, base);
	// 8261D0B4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x8261D0B8; continue 'dispatch;
            }
            0x8261D0B8 => {
    //   block [0x8261D0B8..0x8261D0F0)
	// 8261D0B8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8261D0BC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261D0C0: 419A0034  beq cr6, 0x8261d0f4
	if ctx.cr[6].eq {
	pc = 0x8261D0F4; continue 'dispatch;
	}
	// 8261D0C4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8261D0C8: 4BC021F9  bl 0x8221f2c0
	ctx.lr = 0x8261D0CC;
	sub_8221F2C0(ctx, base);
	// 8261D0CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261D0D0: 409A0334  bne cr6, 0x8261d404
	if !ctx.cr[6].eq {
	pc = 0x8261D404; continue 'dispatch;
	}
	// 8261D0D4: 81796F6C  lwz r11, 0x6f6c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28524 as u32) ) } as u64;
	// 8261D0D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261D0DC: 419A0014  beq cr6, 0x8261d0f0
	if ctx.cr[6].eq {
	pc = 0x8261D0F0; continue 'dispatch;
	}
	// 8261D0E0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261D0E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8261D0E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8261D0EC: 4E800421  bctrl
	ctx.lr = 0x8261D0F0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8261D0F0 => {
    //   block [0x8261D0F0..0x8261D0F4)
	// 8261D0F0: 486A52B9  bl 0x82cc23a8
	ctx.lr = 0x8261D0F4;
	sub_82CC23A8(ctx, base);
	pc = 0x8261D0F4; continue 'dispatch;
            }
            0x8261D0F4 => {
    //   block [0x8261D0F4..0x8261D0F8)
	// 8261D0F4: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	pc = 0x8261D0F8; continue 'dispatch;
            }
            0x8261D0F8 => {
    //   block [0x8261D0F8..0x8261D160)
	// 8261D0F8: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 8261D0FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261D100: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261D104: 4BFFD515  bl 0x8261a618
	ctx.lr = 0x8261D108;
	sub_8261A618(ctx, base);
	// 8261D108: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D10C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261D110: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261D114: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261D118: 4E800421  bctrl
	ctx.lr = 0x8261D11C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261D11C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D120: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8261D124: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261D128: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 8261D12C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261D130: 480009B9  bl 0x8261dae8
	ctx.lr = 0x8261D134;
	sub_8261DAE8(ctx, base);
	// 8261D134: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261D138: 4BB9A9E1  bl 0x821b7b18
	ctx.lr = 0x8261D13C;
	sub_821B7B18(ctx, base);
	// 8261D13C: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D140: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8261D144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261D148: 80E80008  lwz r7, 8(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261D14C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 8261D150: 4E800421  bctrl
	ctx.lr = 0x8261D154;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261D154: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261D158: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8261D15C: 409AFF28  bne cr6, 0x8261d084
	if !ctx.cr[6].eq {
	pc = 0x8261D084; continue 'dispatch;
	}
            }
            0x8261D160 => {
    //   block [0x8261D160..0x8261D19C)
	// 8261D160: 3BB70018  addi r29, r23, 0x18
	ctx.r[29].s64 = ctx.r[23].s64 + 24;
	// 8261D164: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261D168: 48183CB1  bl 0x827a0e18
	ctx.lr = 0x8261D16C;
	sub_827A0E18(ctx, base);
	// 8261D16C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261D170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261D174: 3B8B8CA0  addi r28, r11, -0x7360
	ctx.r[28].s64 = ctx.r[11].s64 + -29536;
	// 8261D178: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8261D17C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D180: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261D184: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261D188: 4E800421  bctrl
	ctx.lr = 0x8261D18C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261D18C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261D190: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261D194: 419A00E4  beq cr6, 0x8261d278
	if ctx.cr[6].eq {
	pc = 0x8261D278; continue 'dispatch;
	}
	// 8261D198: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
            }
            0x8261D19C => {
    //   block [0x8261D19C..0x8261D1C8)
	// 8261D19C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8261D1A0: 4BC02121  bl 0x8221f2c0
	ctx.lr = 0x8261D1A4;
	sub_8221F2C0(ctx, base);
	// 8261D1A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261D1A8: 409A0278  bne cr6, 0x8261d420
	if !ctx.cr[6].eq {
	pc = 0x8261D420; continue 'dispatch;
	}
	// 8261D1AC: 81796F6C  lwz r11, 0x6f6c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28524 as u32) ) } as u64;
	// 8261D1B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261D1B4: 419A0014  beq cr6, 0x8261d1c8
	if ctx.cr[6].eq {
	pc = 0x8261D1C8; continue 'dispatch;
	}
	// 8261D1B8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261D1BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8261D1C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8261D1C4: 4E800421  bctrl
	ctx.lr = 0x8261D1C8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8261D1C8 => {
    //   block [0x8261D1C8..0x8261D1D0)
	// 8261D1C8: 486A51E1  bl 0x82cc23a8
	ctx.lr = 0x8261D1CC;
	sub_82CC23A8(ctx, base);
	// 8261D1CC: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x8261D1D0; continue 'dispatch;
            }
            0x8261D1D0 => {
    //   block [0x8261D1D0..0x8261D208)
	// 8261D1D0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8261D1D4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261D1D8: 419A0034  beq cr6, 0x8261d20c
	if ctx.cr[6].eq {
	pc = 0x8261D20C; continue 'dispatch;
	}
	// 8261D1DC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8261D1E0: 4BC020E1  bl 0x8221f2c0
	ctx.lr = 0x8261D1E4;
	sub_8221F2C0(ctx, base);
	// 8261D1E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261D1E8: 409A0250  bne cr6, 0x8261d438
	if !ctx.cr[6].eq {
	pc = 0x8261D438; continue 'dispatch;
	}
	// 8261D1EC: 81796F6C  lwz r11, 0x6f6c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28524 as u32) ) } as u64;
	// 8261D1F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261D1F4: 419A0014  beq cr6, 0x8261d208
	if ctx.cr[6].eq {
	pc = 0x8261D208; continue 'dispatch;
	}
	// 8261D1F8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261D1FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8261D200: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8261D204: 4E800421  bctrl
	ctx.lr = 0x8261D208;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8261D208 => {
    //   block [0x8261D208..0x8261D20C)
	// 8261D208: 486A51A1  bl 0x82cc23a8
	ctx.lr = 0x8261D20C;
	sub_82CC23A8(ctx, base);
	pc = 0x8261D20C; continue 'dispatch;
            }
            0x8261D20C => {
    //   block [0x8261D20C..0x8261D210)
	// 8261D20C: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	pc = 0x8261D210; continue 'dispatch;
            }
            0x8261D210 => {
    //   block [0x8261D210..0x8261D278)
	// 8261D210: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 8261D214: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261D218: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261D21C: 4BFFD3FD  bl 0x8261a618
	ctx.lr = 0x8261D220;
	sub_8261A618(ctx, base);
	// 8261D220: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261D228: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261D22C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261D230: 4E800421  bctrl
	ctx.lr = 0x8261D234;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261D234: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D238: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8261D23C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261D240: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 8261D244: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261D248: 480008A1  bl 0x8261dae8
	ctx.lr = 0x8261D24C;
	sub_8261DAE8(ctx, base);
	// 8261D24C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261D250: 4BB9A8C9  bl 0x821b7b18
	ctx.lr = 0x8261D254;
	sub_821B7B18(ctx, base);
	// 8261D254: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D258: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8261D25C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261D260: 80E80008  lwz r7, 8(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261D264: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 8261D268: 4E800421  bctrl
	ctx.lr = 0x8261D26C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261D26C: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261D270: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8261D274: 409AFF28  bne cr6, 0x8261d19c
	if !ctx.cr[6].eq {
	pc = 0x8261D19C; continue 'dispatch;
	}
            }
            0x8261D278 => {
    //   block [0x8261D278..0x8261D2C8)
	// 8261D278: 3BB70024  addi r29, r23, 0x24
	ctx.r[29].s64 = ctx.r[23].s64 + 36;
	// 8261D27C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261D280: 48183B99  bl 0x827a0e18
	ctx.lr = 0x8261D284;
	sub_827A0E18(ctx, base);
	// 8261D284: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261D288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261D28C: 3B8B8CB4  addi r28, r11, -0x734c
	ctx.r[28].s64 = ctx.r[11].s64 + -29516;
	// 8261D290: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8261D294: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D298: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261D29C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261D2A0: 4E800421  bctrl
	ctx.lr = 0x8261D2A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261D2A4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261D2A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261D2AC: 419A00F8  beq cr6, 0x8261d3a4
	if ctx.cr[6].eq {
	pc = 0x8261D3A4; continue 'dispatch;
	}
	// 8261D2B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8261D2B4: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 8261D2B8: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 8261D2BC: EB610058  ld r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261D2C0: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 8261D2C4: C3EB9484  lfs f31, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
            }
            0x8261D2C8 => {
    //   block [0x8261D2C8..0x8261D2F4)
	// 8261D2C8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8261D2CC: 4BC01FF5  bl 0x8221f2c0
	ctx.lr = 0x8261D2D0;
	sub_8221F2C0(ctx, base);
	// 8261D2D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261D2D4: 409A0180  bne cr6, 0x8261d454
	if !ctx.cr[6].eq {
	pc = 0x8261D454; continue 'dispatch;
	}
	// 8261D2D8: 81796F6C  lwz r11, 0x6f6c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28524 as u32) ) } as u64;
	// 8261D2DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261D2E0: 419A0014  beq cr6, 0x8261d2f4
	if ctx.cr[6].eq {
	pc = 0x8261D2F4; continue 'dispatch;
	}
	// 8261D2E4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261D2E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8261D2EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8261D2F0: 4E800421  bctrl
	ctx.lr = 0x8261D2F4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8261D2F4 => {
    //   block [0x8261D2F4..0x8261D2FC)
	// 8261D2F4: 486A50B5  bl 0x82cc23a8
	ctx.lr = 0x8261D2F8;
	sub_82CC23A8(ctx, base);
	// 8261D2F8: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x8261D2FC; continue 'dispatch;
            }
            0x8261D2FC => {
    //   block [0x8261D2FC..0x8261D334)
	// 8261D2FC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8261D300: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261D304: 419A0034  beq cr6, 0x8261d338
	if ctx.cr[6].eq {
	pc = 0x8261D338; continue 'dispatch;
	}
	// 8261D308: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8261D30C: 4BC01FB5  bl 0x8221f2c0
	ctx.lr = 0x8261D310;
	sub_8221F2C0(ctx, base);
	// 8261D310: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261D314: 409A0160  bne cr6, 0x8261d474
	if !ctx.cr[6].eq {
	pc = 0x8261D474; continue 'dispatch;
	}
	// 8261D318: 81796F6C  lwz r11, 0x6f6c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28524 as u32) ) } as u64;
	// 8261D31C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261D320: 419A0014  beq cr6, 0x8261d334
	if ctx.cr[6].eq {
	pc = 0x8261D334; continue 'dispatch;
	}
	// 8261D324: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261D328: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8261D32C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8261D330: 4E800421  bctrl
	ctx.lr = 0x8261D334;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8261D334 => {
    //   block [0x8261D334..0x8261D338)
	// 8261D334: 486A5075  bl 0x82cc23a8
	ctx.lr = 0x8261D338;
	sub_82CC23A8(ctx, base);
	pc = 0x8261D338; continue 'dispatch;
            }
            0x8261D338 => {
    //   block [0x8261D338..0x8261D33C)
	// 8261D338: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	pc = 0x8261D33C; continue 'dispatch;
            }
            0x8261D33C => {
    //   block [0x8261D33C..0x8261D3A4)
	// 8261D33C: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 8261D340: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261D344: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261D348: 4BFFE609  bl 0x8261b950
	ctx.lr = 0x8261D34C;
	sub_8261B950(ctx, base);
	// 8261D34C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261D354: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261D358: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261D35C: 4E800421  bctrl
	ctx.lr = 0x8261D360;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261D360: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D364: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8261D368: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261D36C: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 8261D370: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8261D374: 48000775  bl 0x8261dae8
	ctx.lr = 0x8261D378;
	sub_8261DAE8(ctx, base);
	// 8261D378: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261D37C: 4BB9A79D  bl 0x821b7b18
	ctx.lr = 0x8261D380;
	sub_821B7B18(ctx, base);
	// 8261D380: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D384: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8261D388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261D38C: 80E80008  lwz r7, 8(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261D390: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 8261D394: 4E800421  bctrl
	ctx.lr = 0x8261D398;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261D398: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261D39C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8261D3A0: 409AFF28  bne cr6, 0x8261d2c8
	if !ctx.cr[6].eq {
	pc = 0x8261D2C8; continue 'dispatch;
	}
            }
            0x8261D3A4 => {
    //   block [0x8261D3A4..0x8261D3C4)
	// 8261D3A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D3A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261D3AC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261D3B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261D3B4: 4E800421  bctrl
	ctx.lr = 0x8261D3B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261D3B8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8261D3BC: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 8261D3C0: 4868C080  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261D3C4 => {
    //   block [0x8261D3C4..0x8261D3D0)
	// 8261D3C4: 4BFFC9C5  bl 0x82619d88
	ctx.lr = 0x8261D3C8;
	sub_82619D88(ctx, base);
	// 8261D3C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261D3CC: 4BFFFBD0  b 0x8261cf9c
	pc = 0x8261CF9C; continue 'dispatch;
            }
            0x8261D3D0 => {
    //   block [0x8261D3D0..0x8261D3EC)
	// 8261D3D0: 3D608262  lis r11, -0x7d9e
	ctx.r[11].s64 = -2107506688;
	// 8261D3D4: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 8261D3D8: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 8261D3DC: 394BDC58  addi r10, r11, -0x23a8
	ctx.r[10].s64 = ctx.r[11].s64 + -9128;
	// 8261D3E0: 93030000  stw r24, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 8261D3E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8261D3E8: 4BFFFBF4  b 0x8261cfdc
	pc = 0x8261CFDC; continue 'dispatch;
            }
            0x8261D3EC => {
    //   block [0x8261D3EC..0x8261D404)
	// 8261D3EC: 93430004  stw r26, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 8261D3F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261D3F4: 93430008  stw r26, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 8261D3F8: 817B9650  lwz r11, -0x69b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 8261D3FC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8261D400: 4BFFFCB8  b 0x8261d0b8
	pc = 0x8261D0B8; continue 'dispatch;
            }
            0x8261D404 => {
    //   block [0x8261D404..0x8261D420)
	// 8261D404: 3D608284  lis r11, -0x7d7c
	ctx.r[11].s64 = -2105278464;
	// 8261D408: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 8261D40C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 8261D410: 394B57B0  addi r10, r11, 0x57b0
	ctx.r[10].s64 = ctx.r[11].s64 + 22448;
	// 8261D414: 93030000  stw r24, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 8261D418: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8261D41C: 4BFFFCDC  b 0x8261d0f8
	pc = 0x8261D0F8; continue 'dispatch;
            }
            0x8261D420 => {
    //   block [0x8261D420..0x8261D438)
	// 8261D420: 93430008  stw r26, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 8261D424: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261D428: 93430004  stw r26, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 8261D42C: 817B9650  lwz r11, -0x69b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 8261D430: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8261D434: 4BFFFD9C  b 0x8261d1d0
	pc = 0x8261D1D0; continue 'dispatch;
            }
            0x8261D438 => {
    //   block [0x8261D438..0x8261D454)
	// 8261D438: 3D608284  lis r11, -0x7d7c
	ctx.r[11].s64 = -2105278464;
	// 8261D43C: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 8261D440: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 8261D444: 394B57B0  addi r10, r11, 0x57b0
	ctx.r[10].s64 = ctx.r[11].s64 + 22448;
	// 8261D448: 93030000  stw r24, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 8261D44C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8261D450: 4BFFFDC0  b 0x8261d210
	pc = 0x8261D210; continue 'dispatch;
            }
            0x8261D454 => {
    //   block [0x8261D454..0x8261D474)
	// 8261D454: D3E30008  stfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8261D458: FB630010  std r27, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[27].u64 ) };
	// 8261D45C: 93430000  stw r26, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 8261D460: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261D464: 9B430004  stb r26, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[26].u8 ) };
	// 8261D468: 9B430005  stb r26, 5(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(5 as u32), ctx.r[26].u8 ) };
	// 8261D46C: 9343000C  stw r26, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 8261D470: 4BFFFE8C  b 0x8261d2fc
	pc = 0x8261D2FC; continue 'dispatch;
            }
            0x8261D474 => {
    //   block [0x8261D474..0x8261D490)
	// 8261D474: 3D608284  lis r11, -0x7d7c
	ctx.r[11].s64 = -2105278464;
	// 8261D478: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 8261D47C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 8261D480: 394B57B0  addi r10, r11, 0x57b0
	ctx.r[10].s64 = ctx.r[11].s64 + 22448;
	// 8261D484: 93030000  stw r24, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 8261D488: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8261D48C: 4BFFFEB0  b 0x8261d33c
	pc = 0x8261D33C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261D490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8261D490 size=1272
    let mut pc: u32 = 0x8261D490;
    'dispatch: loop {
        match pc {
            0x8261D490 => {
    //   block [0x8261D490..0x8261D4D8)
	// 8261D490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261D494: 4868BF69  bl 0x82ca93fc
	ctx.lr = 0x8261D498;
	sub_82CA93D0(ctx, base);
	// 8261D498: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261D49C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8261D4A0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8261D4A4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8261D4A8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8261D4AC: 3B3C0234  addi r25, r28, 0x234
	ctx.r[25].s64 = ctx.r[28].s64 + 564;
	// 8261D4B0: 817C0234  lwz r11, 0x234(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(564 as u32) ) } as u64;
	// 8261D4B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261D4B8: 419A042C  beq cr6, 0x8261d8e4
	if ctx.cr[6].eq {
	pc = 0x8261D8E4; continue 'dispatch;
	}
	// 8261D4BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D4C0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8261D4C4: 409A04BC  bne cr6, 0x8261d980
	if !ctx.cr[6].eq {
	pc = 0x8261D980; continue 'dispatch;
	}
	// 8261D4C8: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261D4CC: 3BDC0024  addi r30, r28, 0x24
	ctx.r[30].s64 = ctx.r[28].s64 + 36;
	// 8261D4D0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8261D4D4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8261D4D8; continue 'dispatch;
            }
            0x8261D4D8 => {
    //   block [0x8261D4D8..0x8261D4E8)
	// 8261D4D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D4DC: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8261D4E0: 419A0008  beq cr6, 0x8261d4e8
	if ctx.cr[6].eq {
	pc = 0x8261D4E8; continue 'dispatch;
	}
	// 8261D4E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261D4E8; continue 'dispatch;
            }
            0x8261D4E8 => {
    //   block [0x8261D4E8..0x8261D500)
	// 8261D4E8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261D4EC: 419A00F8  beq cr6, 0x8261d5e4
	if ctx.cr[6].eq {
	pc = 0x8261D5E4; continue 'dispatch;
	}
	// 8261D4F0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D4F4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261D4F8: 409A0008  bne cr6, 0x8261d500
	if !ctx.cr[6].eq {
	pc = 0x8261D500; continue 'dispatch;
	}
	// 8261D4FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261D500; continue 'dispatch;
            }
            0x8261D500 => {
    //   block [0x8261D500..0x8261D518)
	// 8261D500: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261D504: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261D508: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261D50C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8261D510: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8261D514: 419A0020  beq cr6, 0x8261d534
	if ctx.cr[6].eq {
	pc = 0x8261D534; continue 'dispatch;
	}
	pc = 0x8261D518; continue 'dispatch;
            }
            0x8261D518 => {
    //   block [0x8261D518..0x8261D534)
	// 8261D518: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8261D51C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261D520: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8261D524: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8261D528: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8261D52C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261D530: 4082FFE8  bne 0x8261d518
	if !ctx.cr[0].eq {
	pc = 0x8261D518; continue 'dispatch;
	}
	pc = 0x8261D534; continue 'dispatch;
            }
            0x8261D534 => {
    //   block [0x8261D534..0x8261D570)
	// 8261D534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261D538: 419A008C  beq cr6, 0x8261d5c4
	if ctx.cr[6].eq {
	pc = 0x8261D5C4; continue 'dispatch;
	}
	// 8261D53C: 894B0004  lbz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D540: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261D544: 419A0080  beq cr6, 0x8261d5c4
	if ctx.cr[6].eq {
	pc = 0x8261D5C4; continue 'dispatch;
	}
	// 8261D548: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D54C: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8261D550: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D554: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8261D558: 409A0018  bne cr6, 0x8261d570
	if !ctx.cr[6].eq {
	pc = 0x8261D570; continue 'dispatch;
	}
	// 8261D55C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261D560: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8261D564: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8261D568: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261D56C: 419A0008  beq cr6, 0x8261d574
	if ctx.cr[6].eq {
	pc = 0x8261D574; continue 'dispatch;
	}
	pc = 0x8261D570; continue 'dispatch;
            }
            0x8261D570 => {
    //   block [0x8261D570..0x8261D574)
	// 8261D570: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x8261D574; continue 'dispatch;
            }
            0x8261D574 => {
    //   block [0x8261D574..0x8261D5A4)
	// 8261D574: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8261D578: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261D57C: 409A0038  bne cr6, 0x8261d5b4
	if !ctx.cr[6].eq {
	pc = 0x8261D5B4; continue 'dispatch;
	}
	// 8261D580: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8261D584: 813B0014  lwz r9, 0x14(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 8261D588: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261D58C: 409A0018  bne cr6, 0x8261d5a4
	if !ctx.cr[6].eq {
	pc = 0x8261D5A4; continue 'dispatch;
	}
	// 8261D590: 815B0018  lwz r10, 0x18(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 8261D594: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8261D598: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8261D59C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261D5A0: 419A0008  beq cr6, 0x8261d5a8
	if ctx.cr[6].eq {
	pc = 0x8261D5A8; continue 'dispatch;
	}
	pc = 0x8261D5A4; continue 'dispatch;
            }
            0x8261D5A4 => {
    //   block [0x8261D5A4..0x8261D5A8)
	// 8261D5A4: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x8261D5A8; continue 'dispatch;
            }
            0x8261D5A8 => {
    //   block [0x8261D5A8..0x8261D5B4)
	// 8261D5A8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8261D5AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261D5B0: 419A0014  beq cr6, 0x8261d5c4
	if ctx.cr[6].eq {
	pc = 0x8261D5C4; continue 'dispatch;
	}
	pc = 0x8261D5B4; continue 'dispatch;
            }
            0x8261D5B4 => {
    //   block [0x8261D5B4..0x8261D5C4)
	// 8261D5B4: C01C023C  lfs f0, 0x23c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8261D5B8: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8261D5BC: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8261D5C0: D18B0008  stfs f12, 8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x8261D5C4; continue 'dispatch;
            }
            0x8261D5C4 => {
    //   block [0x8261D5C4..0x8261D5DC)
	// 8261D5C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261D5C8: 4BB9A551  bl 0x821b7b18
	ctx.lr = 0x8261D5CC;
	sub_821B7B18(ctx, base);
	// 8261D5CC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D5D0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8261D5D4: 409A0008  bne cr6, 0x8261d5dc
	if !ctx.cr[6].eq {
	pc = 0x8261D5DC; continue 'dispatch;
	}
	// 8261D5D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8261D5DC; continue 'dispatch;
            }
            0x8261D5DC => {
    //   block [0x8261D5DC..0x8261D5E4)
	// 8261D5DC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D5E0: 4BFFFEF8  b 0x8261d4d8
	pc = 0x8261D4D8; continue 'dispatch;
            }
            0x8261D5E4 => {
    //   block [0x8261D5E4..0x8261D700)
	// 8261D5E4: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 8261D5E8: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D5EC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8261D5F0: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8261D5F4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261D5F8: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261D5FC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D600: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D604: 4BC46E85  bl 0x82264488
	ctx.lr = 0x8261D608;
	sub_82264488(ctx, base);
	// 8261D608: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8261D60C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261D610: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D614: 388A000C  addi r4, r10, 0xc
	ctx.r[4].s64 = ctx.r[10].s64 + 12;
	// 8261D618: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261D61C: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261D620: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D624: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D628: 4BC46E61  bl 0x82264488
	ctx.lr = 0x8261D62C;
	sub_82264488(ctx, base);
	// 8261D62C: 809B007C  lwz r4, 0x7c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(124 as u32) ) } as u64;
	// 8261D630: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8261D634: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8261D638: 80A40000  lwz r5, 0(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D63C: 81650040  lwz r11, 0x40(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(64 as u32) ) } as u64;
	// 8261D640: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8261D644: 4E800421  bctrl
	ctx.lr = 0x8261D648;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261D648: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8261D64C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8261D650: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 8261D654: 39000065  li r8, 0x65
	ctx.r[8].s64 = 101;
	// 8261D658: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8261D65C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261D660: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8261D664: 3880001E  li r4, 0x1e
	ctx.r[4].s64 = 30;
	// 8261D668: 806A0058  lwz r3, 0x58(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261D66C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D670: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8261D674: 4BC5C50D  bl 0x82279b80
	ctx.lr = 0x8261D678;
	sub_82279B80(ctx, base);
	// 8261D678: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 8261D67C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8261D680: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D684: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8261D688: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8261D68C: 4E800421  bctrl
	ctx.lr = 0x8261D690;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261D690: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8261D694: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 8261D698: 39000065  li r8, 0x65
	ctx.r[8].s64 = 101;
	// 8261D69C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8261D6A0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 8261D6A4: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261D6A8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8261D6AC: 3880001E  li r4, 0x1e
	ctx.r[4].s64 = 30;
	// 8261D6B0: 81630058  lwz r11, 0x58(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 8261D6B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D6B8: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8261D6BC: 4BC5C4C5  bl 0x82279b80
	ctx.lr = 0x8261D6C0;
	sub_82279B80(ctx, base);
	// 8261D6C0: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261D6C4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 8261D6C8: 55283FFE  rlwinm r8, r9, 7, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x01FFFFFFu64;
	// 8261D6CC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8261D6D0: 419A00F4  beq cr6, 0x8261d7c4
	if ctx.cr[6].eq {
	pc = 0x8261D7C4; continue 'dispatch;
	}
	// 8261D6D4: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261D6D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261D6DC: 419A0024  beq cr6, 0x8261d700
	if ctx.cr[6].eq {
	pc = 0x8261D700; continue 'dispatch;
	}
	// 8261D6E0: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 8261D6E4: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261D6E8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8261D6EC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261D6F0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D6F4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8261D6F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261D6FC: 480000CC  b 0x8261d7c8
	pc = 0x8261D7C8; continue 'dispatch;
            }
            0x8261D700 => {
    //   block [0x8261D700..0x8261D71C)
	// 8261D700: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261D704: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261D708: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 8261D70C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8261D710: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8261D714: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261D718: 40810054  ble 0x8261d76c
	if !ctx.cr[0].gt {
	pc = 0x8261D76C; continue 'dispatch;
	}
	pc = 0x8261D71C; continue 'dispatch;
            }
            0x8261D71C => {
    //   block [0x8261D71C..0x8261D73C)
	// 8261D71C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261D720: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261D724: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8261D728: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D72C: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 8261D730: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8261D734: 41980008  blt cr6, 0x8261d73c
	if ctx.cr[6].lt {
	pc = 0x8261D73C; continue 'dispatch;
	}
	// 8261D738: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x8261D73C; continue 'dispatch;
            }
            0x8261D73C => {
    //   block [0x8261D73C..0x8261D758)
	// 8261D73C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8261D740: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261D744: 419A0014  beq cr6, 0x8261d758
	if ctx.cr[6].eq {
	pc = 0x8261D758; continue 'dispatch;
	}
	// 8261D748: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261D74C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8261D750: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8261D754: 4800000C  b 0x8261d760
	pc = 0x8261D760; continue 'dispatch;
            }
            0x8261D758 => {
    //   block [0x8261D758..0x8261D760)
	// 8261D758: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261D75C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8261D760; continue 'dispatch;
            }
            0x8261D760 => {
    //   block [0x8261D760..0x8261D76C)
	// 8261D760: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261D764: 4199FFB8  bgt cr6, 0x8261d71c
	if ctx.cr[6].gt {
	pc = 0x8261D71C; continue 'dispatch;
	}
	// 8261D768: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8261D76C; continue 'dispatch;
            }
            0x8261D76C => {
    //   block [0x8261D76C..0x8261D788)
	// 8261D76C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8261D770: 419A0040  beq cr6, 0x8261d7b0
	if ctx.cr[6].eq {
	pc = 0x8261D7B0; continue 'dispatch;
	}
	// 8261D774: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D778: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 8261D77C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261D780: 41990008  bgt cr6, 0x8261d788
	if ctx.cr[6].gt {
	pc = 0x8261D788; continue 'dispatch;
	}
	// 8261D784: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x8261D788; continue 'dispatch;
            }
            0x8261D788 => {
    //   block [0x8261D788..0x8261D7B0)
	// 8261D788: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261D78C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261D790: 409A0020  bne cr6, 0x8261d7b0
	if !ctx.cr[6].eq {
	pc = 0x8261D7B0; continue 'dispatch;
	}
	// 8261D794: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8261D798: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8261D79C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261D7A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D7A4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8261D7A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261D7AC: 4800001C  b 0x8261d7c8
	pc = 0x8261D7C8; continue 'dispatch;
            }
            0x8261D7B0 => {
    //   block [0x8261D7B0..0x8261D7C4)
	// 8261D7B0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8261D7B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D7B8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8261D7BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261D7C0: 48000008  b 0x8261d7c8
	pc = 0x8261D7C8; continue 'dispatch;
            }
            0x8261D7C4 => {
    //   block [0x8261D7C4..0x8261D7C8)
	// 8261D7C4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x8261D7C8; continue 'dispatch;
            }
            0x8261D7C8 => {
    //   block [0x8261D7C8..0x8261D808)
	// 8261D7C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261D7CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261D7D0: 419A0038  beq cr6, 0x8261d808
	if ctx.cr[6].eq {
	pc = 0x8261D808; continue 'dispatch;
	}
	// 8261D7D4: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 8261D7D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261D7DC: 4BEBB7AD  bl 0x824d8f88
	ctx.lr = 0x8261D7E0;
	sub_824D8F88(ctx, base);
	// 8261D7E0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8261D7E4: 38800043  li r4, 0x43
	ctx.r[4].s64 = 67;
	// 8261D7E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261D7EC: 4BCBB61D  bl 0x822d8e08
	ctx.lr = 0x8261D7F0;
	sub_822D8E08(ctx, base);
	// 8261D7F0: 817E04E0  lwz r11, 0x4e0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1248 as u32) ) } as u64;
	// 8261D7F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8261D7F8: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 8261D7FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261D800: 90BE04E0  stw r5, 0x4e0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1248 as u32), ctx.r[5].u32 ) };
	// 8261D804: 4BEBB6B5  bl 0x824d8eb8
	ctx.lr = 0x8261D808;
	sub_824D8EB8(ctx, base);
	pc = 0x8261D808; continue 'dispatch;
            }
            0x8261D808 => {
    //   block [0x8261D808..0x8261D838)
	// 8261D808: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261D80C: 556A3FFE  rlwinm r10, r11, 7, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x01FFFFFFu64;
	// 8261D810: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261D814: 419A0078  beq cr6, 0x8261d88c
	if ctx.cr[6].eq {
	pc = 0x8261D88C; continue 'dispatch;
	}
	// 8261D818: 817B008C  lwz r11, 0x8c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261D81C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261D820: 409A0064  bne cr6, 0x8261d884
	if !ctx.cr[6].eq {
	pc = 0x8261D884; continue 'dispatch;
	}
	// 8261D824: 817B004C  lwz r11, 0x4c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261D828: 815B0048  lwz r10, 0x48(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261D82C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8261D830: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261D834: 40810050  ble 0x8261d884
	if !ctx.cr[0].gt {
	pc = 0x8261D884; continue 'dispatch;
	}
	pc = 0x8261D838; continue 'dispatch;
            }
            0x8261D838 => {
    //   block [0x8261D838..0x8261D858)
	// 8261D838: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261D83C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261D840: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8261D844: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261D848: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 8261D84C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8261D850: 41980008  blt cr6, 0x8261d858
	if ctx.cr[6].lt {
	pc = 0x8261D858; continue 'dispatch;
	}
	// 8261D854: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x8261D858; continue 'dispatch;
            }
            0x8261D858 => {
    //   block [0x8261D858..0x8261D874)
	// 8261D858: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8261D85C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261D860: 419A0014  beq cr6, 0x8261d874
	if ctx.cr[6].eq {
	pc = 0x8261D874; continue 'dispatch;
	}
	// 8261D864: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261D868: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8261D86C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8261D870: 4800000C  b 0x8261d87c
	pc = 0x8261D87C; continue 'dispatch;
            }
            0x8261D874 => {
    //   block [0x8261D874..0x8261D87C)
	// 8261D874: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261D878: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8261D87C; continue 'dispatch;
            }
            0x8261D87C => {
    //   block [0x8261D87C..0x8261D884)
	// 8261D87C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261D880: 4199FFB8  bgt cr6, 0x8261d838
	if ctx.cr[6].gt {
	pc = 0x8261D838; continue 'dispatch;
	}
	pc = 0x8261D884; continue 'dispatch;
            }
            0x8261D884 => {
    //   block [0x8261D884..0x8261D88C)
	// 8261D884: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261D888: 48000008  b 0x8261d890
	pc = 0x8261D890; continue 'dispatch;
            }
            0x8261D88C => {
    //   block [0x8261D88C..0x8261D890)
	// 8261D88C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x8261D890; continue 'dispatch;
            }
            0x8261D890 => {
    //   block [0x8261D890..0x8261D8D0)
	// 8261D890: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261D894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261D898: 419A0038  beq cr6, 0x8261d8d0
	if ctx.cr[6].eq {
	pc = 0x8261D8D0; continue 'dispatch;
	}
	// 8261D89C: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 8261D8A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261D8A4: 4BEBB6E5  bl 0x824d8f88
	ctx.lr = 0x8261D8A8;
	sub_824D8F88(ctx, base);
	// 8261D8A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8261D8AC: 38800043  li r4, 0x43
	ctx.r[4].s64 = 67;
	// 8261D8B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261D8B4: 4BCBB555  bl 0x822d8e08
	ctx.lr = 0x8261D8B8;
	sub_822D8E08(ctx, base);
	// 8261D8B8: 817E04E0  lwz r11, 0x4e0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1248 as u32) ) } as u64;
	// 8261D8BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8261D8C0: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 8261D8C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261D8C8: 90BE04E0  stw r5, 0x4e0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1248 as u32), ctx.r[5].u32 ) };
	// 8261D8CC: 4BEBB5ED  bl 0x824d8eb8
	ctx.lr = 0x8261D8D0;
	sub_824D8EB8(ctx, base);
	pc = 0x8261D8D0; continue 'dispatch;
            }
            0x8261D8D0 => {
    //   block [0x8261D8D0..0x8261D8E4)
	// 8261D8D0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8261D8D4: 4BB9A245  bl 0x821b7b18
	ctx.lr = 0x8261D8D8;
	sub_821B7B18(ctx, base);
	// 8261D8D8: 93590000  stw r26, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 8261D8DC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8261D8E0: 4868BB6C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261D8E4 => {
    //   block [0x8261D8E4..0x8261D940)
	// 8261D8E4: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8261D8E8: 4BC01971  bl 0x8221f258
	ctx.lr = 0x8261D8EC;
	sub_8221F258(ctx, base);
	// 8261D8EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261D8F0: 419A0084  beq cr6, 0x8261d974
	if ctx.cr[6].eq {
	pc = 0x8261D974; continue 'dispatch;
	}
	// 8261D8F4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8261D8F8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8261D8FC: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 8261D900: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261D904: 814A9650  lwz r10, -0x69b0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 8261D908: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8261D90C: 813B0014  lwz r9, 0x14(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 8261D910: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8261D914: 811B0018  lwz r8, 0x18(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 8261D918: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 8261D91C: 9343000C  stw r26, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 8261D920: 93430010  stw r26, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 8261D924: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 8261D928: 419A0018  beq cr6, 0x8261d940
	if ctx.cr[6].eq {
	pc = 0x8261D940; continue 'dispatch;
	}
	// 8261D92C: 895F0090  lbz r10, 0x90(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 8261D930: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8261D934: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261D938: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261D93C: 409A0008  bne cr6, 0x8261d944
	if !ctx.cr[6].eq {
	pc = 0x8261D944; continue 'dispatch;
	}
	pc = 0x8261D940; continue 'dispatch;
            }
            0x8261D940 => {
    //   block [0x8261D940..0x8261D944)
	// 8261D940: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x8261D944; continue 'dispatch;
            }
            0x8261D944 => {
    //   block [0x8261D944..0x8261D960)
	// 8261D944: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8261D948: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261D94C: 419A0014  beq cr6, 0x8261d960
	if ctx.cr[6].eq {
	pc = 0x8261D960; continue 'dispatch;
	}
	// 8261D950: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8261D954: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8261D958: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8261D95C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x8261D960; continue 'dispatch;
            }
            0x8261D960 => {
    //   block [0x8261D960..0x8261D974)
	// 8261D960: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8261D964: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8261D968: 480F47A1  bl 0x82712108
	ctx.lr = 0x8261D96C;
	sub_82712108(ctx, base);
	// 8261D96C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8261D970: 4868BADC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261D974 => {
    //   block [0x8261D974..0x8261D980)
	// 8261D974: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8261D978: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8261D97C: 480F478D  bl 0x82712108
	ctx.lr = 0x8261D980;
	sub_82712108(ctx, base);
	pc = 0x8261D980; continue 'dispatch;
            }
            0x8261D980 => {
    //   block [0x8261D980..0x8261D988)
	// 8261D980: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8261D984: 4868BAC8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261D988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261D988 size=244
    let mut pc: u32 = 0x8261D988;
    'dispatch: loop {
        match pc {
            0x8261D988 => {
    //   block [0x8261D988..0x8261D9B8)
	// 8261D988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261D98C: 4868BA71  bl 0x82ca93fc
	ctx.lr = 0x8261D990;
	sub_82CA93D0(ctx, base);
	// 8261D990: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261D994: 3D60028F  lis r11, 0x28f
	ctx.r[11].s64 = 42926080;
	// 8261D998: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 8261D99C: 616A5C28  ori r10, r11, 0x5c28
	ctx.r[10].u64 = ctx.r[11].u64 | 23592;
	// 8261D9A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261D9A4: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261D9A8: 40990010  ble cr6, 0x8261d9b8
	if !ctx.cr[6].gt {
	pc = 0x8261D9B8; continue 'dispatch;
	}
	// 8261D9AC: 48429B1D  bl 0x82a474c8
	ctx.lr = 0x8261D9B0;
	sub_82A474C8(ctx, base);
	// 8261D9B0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8261D9B4: 4868BA98  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261D9B8 => {
    //   block [0x8261D9B8..0x8261D9D4)
	// 8261D9B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D9BC: 3B200064  li r25, 0x64
	ctx.r[25].s64 = 100;
	// 8261D9C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261D9C4: 419A0010  beq cr6, 0x8261d9d4
	if ctx.cr[6].eq {
	pc = 0x8261D9D4; continue 'dispatch;
	}
	// 8261D9C8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261D9CC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8261D9D0: 7D69CBD6  divw r11, r9, r25
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[25].s32;
	pc = 0x8261D9D4; continue 'dispatch;
            }
            0x8261D9D4 => {
    //   block [0x8261D9D4..0x8261DA18)
	// 8261D9D4: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8261D9D8: 4098009C  bge cr6, 0x8261da74
	if !ctx.cr[6].lt {
	pc = 0x8261DA74; continue 'dispatch;
	}
	// 8261D9DC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8261D9E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261D9E4: 48000205  bl 0x8261dbe8
	ctx.lr = 0x8261D9E8;
	sub_8261DBE8(ctx, base);
	// 8261D9E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261D9EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8261D9F0: 837F0008  lwz r27, 8(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261D9F4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8261D9F8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8261D9FC: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 8261DA00: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 8261DA04: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8261DA08: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8261DA0C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 8261DA10: 419A002C  beq cr6, 0x8261da3c
	if ctx.cr[6].eq {
	pc = 0x8261DA3C; continue 'dispatch;
	}
	// 8261DA14: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x8261DA18; continue 'dispatch;
            }
            0x8261DA18 => {
    //   block [0x8261DA18..0x8261DA2C)
	// 8261DA18: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261DA1C: 419A0010  beq cr6, 0x8261da2c
	if ctx.cr[6].eq {
	pc = 0x8261DA2C; continue 'dispatch;
	}
	// 8261DA20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8261DA24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261DA28: 48000551  bl 0x8261df78
	ctx.lr = 0x8261DA2C;
	sub_8261DF78(ctx, base);
	pc = 0x8261DA2C; continue 'dispatch;
            }
            0x8261DA2C => {
    //   block [0x8261DA2C..0x8261DA3C)
	// 8261DA2C: 3BBD0064  addi r29, r29, 0x64
	ctx.r[29].s64 = ctx.r[29].s64 + 100;
	// 8261DA30: 3BDE0064  addi r30, r30, 0x64
	ctx.r[30].s64 = ctx.r[30].s64 + 100;
	// 8261DA34: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 8261DA38: 409AFFE0  bne cr6, 0x8261da18
	if !ctx.cr[6].eq {
	pc = 0x8261DA18; continue 'dispatch;
	}
	pc = 0x8261DA3C; continue 'dispatch;
            }
            0x8261DA3C => {
    //   block [0x8261DA3C..0x8261DA58)
	// 8261DA3C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261DA40: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261DA44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261DA48: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 8261DA4C: 7FCACBD6  divw r30, r10, r25
	ctx.r[30].s32 = ctx.r[10].s32 / ctx.r[25].s32;
	// 8261DA50: 419A0008  beq cr6, 0x8261da58
	if ctx.cr[6].eq {
	pc = 0x8261DA58; continue 'dispatch;
	}
	// 8261DA54: 4BBFE2E5  bl 0x8221bd38
	ctx.lr = 0x8261DA58;
	sub_8221BD38(ctx, base);
	pc = 0x8261DA58; continue 'dispatch;
            }
            0x8261DA58 => {
    //   block [0x8261DA58..0x8261DA74)
	// 8261DA58: 1D5A0064  mulli r10, r26, 0x64
	ctx.r[10].s32 = ((ctx.r[26].s32 as i64 * 100 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 8261DA5C: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 8261DA60: 1D7E0064  mulli r11, r30, 0x64
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 100 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8261DA64: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 8261DA68: 7D2BE214  add r9, r11, r28
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 8261DA6C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8261DA70: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x8261DA74; continue 'dispatch;
            }
            0x8261DA74 => {
    //   block [0x8261DA74..0x8261DA7C)
	// 8261DA74: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8261DA78: 4868B9D4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261DA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261DA80 size=104
    let mut pc: u32 = 0x8261DA80;
    'dispatch: loop {
        match pc {
            0x8261DA80 => {
    //   block [0x8261DA80..0x8261DACC)
	// 8261DA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261DA84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261DA88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261DA8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261DA90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261DA94: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8261DA98: 4BC017C1  bl 0x8221f258
	ctx.lr = 0x8261DA9C;
	sub_8221F258(ctx, base);
	// 8261DA9C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8261DAA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261DAA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261DAA8: 419A0024  beq cr6, 0x8261dacc
	if ctx.cr[6].eq {
	pc = 0x8261DACC; continue 'dispatch;
	}
	// 8261DAAC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261DAB0: 3D208262  lis r9, -0x7d9e
	ctx.r[9].s64 = -2107506688;
	// 8261DAB4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8261DAB8: 38E9DC58  addi r7, r9, -0x23a8
	ctx.r[7].s64 = ctx.r[9].s64 + -9128;
	// 8261DABC: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8261DAC0: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 8261DAC4: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8261DAC8: 48000008  b 0x8261dad0
	pc = 0x8261DAD0; continue 'dispatch;
            }
            0x8261DACC => {
    //   block [0x8261DACC..0x8261DAD0)
	// 8261DACC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8261DAD0; continue 'dispatch;
            }
            0x8261DAD0 => {
    //   block [0x8261DAD0..0x8261DAE8)
	// 8261DAD0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8261DAD4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8261DAD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261DADC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261DAE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261DAE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261DAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261DAE8 size=256
    let mut pc: u32 = 0x8261DAE8;
    'dispatch: loop {
        match pc {
            0x8261DAE8 => {
    //   block [0x8261DAE8..0x8261DB20)
	// 8261DAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261DAEC: 4868B915  bl 0x82ca9400
	ctx.lr = 0x8261DAF0;
	sub_82CA93D0(ctx, base);
	// 8261DAF0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261DAF4: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 8261DAF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8261DAFC: 834100EC  lwz r26, 0xec(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 8261DB00: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8261DB04: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8261DB08: 837A0004  lwz r27, 4(r26)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261DB0C: 4BC0174D  bl 0x8221f258
	ctx.lr = 0x8261DB10;
	sub_8221F258(ctx, base);
	// 8261DB10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261DB14: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261DB18: 419A0008  beq cr6, 0x8261db20
	if ctx.cr[6].eq {
	pc = 0x8261DB20; continue 'dispatch;
	}
	// 8261DB1C: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x8261DB20; continue 'dispatch;
            }
            0x8261DB20 => {
    //   block [0x8261DB20..0x8261DB30)
	// 8261DB20: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 8261DB24: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261DB28: 419A0008  beq cr6, 0x8261db30
	if ctx.cr[6].eq {
	pc = 0x8261DB30; continue 'dispatch;
	}
	// 8261DB2C: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x8261DB30; continue 'dispatch;
            }
            0x8261DB30 => {
    //   block [0x8261DB30..0x8261DB50)
	// 8261DB30: 355F0008  addic. r10, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[10].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8261DB34: 41820038  beq 0x8261db6c
	if ctx.cr[0].eq {
	pc = 0x8261DB6C; continue 'dispatch;
	}
	// 8261DB38: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261DB3C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8261DB40: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261DB44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261DB48: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8261DB4C: 419A0020  beq cr6, 0x8261db6c
	if ctx.cr[6].eq {
	pc = 0x8261DB6C; continue 'dispatch;
	}
	pc = 0x8261DB50; continue 'dispatch;
            }
            0x8261DB50 => {
    //   block [0x8261DB50..0x8261DB6C)
	// 8261DB50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8261DB54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261DB58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8261DB5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8261DB60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8261DB64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8261DB68: 4082FFE8  bne 0x8261db50
	if !ctx.cr[0].eq {
	pc = 0x8261DB50; continue 'dispatch;
	}
	pc = 0x8261DB6C; continue 'dispatch;
            }
            0x8261DB6C => {
    //   block [0x8261DB6C..0x8261DBC8)
	// 8261DB6C: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 8261DB70: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261DB74: 6169FFFF  ori r9, r11, 0xffff
	ctx.r[9].u64 = ctx.r[11].u64 | 65535;
	// 8261DB78: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 8261DB7C: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 8261DB80: 40980048  bge cr6, 0x8261dbc8
	if !ctx.cr[6].lt {
	pc = 0x8261DBC8; continue 'dispatch;
	}
	// 8261DB84: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8261DB88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261DB8C: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 8261DB90: 4BCD43B1  bl 0x822f1f40
	ctx.lr = 0x8261DB94;
	sub_822F1F40(ctx, base);
	// 8261DB94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8261DB98: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8261DB9C: 4BCD4215  bl 0x822f1db0
	ctx.lr = 0x8261DBA0;
	sub_822F1DB0(ctx, base);
	// 8261DBA0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8261DBA4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8261DBA8: 3B8A1720  addi r28, r10, 0x1720
	ctx.r[28].s64 = ctx.r[10].s64 + 5920;
	// 8261DBAC: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 8261DBB0: 4BCD4271  bl 0x822f1e20
	ctx.lr = 0x8261DBB4;
	sub_822F1E20(ctx, base);
	// 8261DBB4: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 8261DBB8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8261DBBC: 4805DC25  bl 0x8267b7e0
	ctx.lr = 0x8261DBC0;
	sub_8267B7E0(ctx, base);
	// 8261DBC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261DBC4: 4BB53C4D  bl 0x82171810
	ctx.lr = 0x8261DBC8;
	sub_82171810(ctx, base);
	pc = 0x8261DBC8; continue 'dispatch;
            }
            0x8261DBC8 => {
    //   block [0x8261DBC8..0x8261DBE8)
	// 8261DBC8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261DBCC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8261DBD0: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8261DBD4: 93FA0004  stw r31, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8261DBD8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261DBDC: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8261DBE0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8261DBE4: 4868B86C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261DBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261DBE8 size=112
    let mut pc: u32 = 0x8261DBE8;
    'dispatch: loop {
        match pc {
            0x8261DBE8 => {
    //   block [0x8261DBE8..0x8261DC3C)
	// 8261DBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261DBEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261DBF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261DBF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261DBF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8261DBFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261DC00: 419A003C  beq cr6, 0x8261dc3c
	if ctx.cr[6].eq {
	pc = 0x8261DC3C; continue 'dispatch;
	}
	// 8261DC04: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8261DC08: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 8261DC0C: 2B0A0064  cmplwi cr6, r10, 0x64
	ctx.cr[6].compare_u32(ctx.r[10].u32, 100 as u32, &mut ctx.xer);
	// 8261DC10: 4098002C  bge cr6, 0x8261dc3c
	if !ctx.cr[6].lt {
	pc = 0x8261DC3C; continue 'dispatch;
	}
	// 8261DC14: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8261DC18: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8261DC1C: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 8261DC20: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8261DC24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261DC28: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8261DC2C: 4BCD41F5  bl 0x822f1e20
	ctx.lr = 0x8261DC30;
	sub_822F1E20(ctx, base);
	// 8261DC30: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 8261DC34: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 8261DC38: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x8261DC3C; continue 'dispatch;
            }
            0x8261DC3C => {
    //   block [0x8261DC3C..0x8261DC58)
	// 8261DC3C: 1C7F0064  mulli r3, r31, 0x64
	ctx.r[3].s32 = ((ctx.r[31].s32 as i64 * 100 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 8261DC40: 4BC01619  bl 0x8221f258
	ctx.lr = 0x8261DC44;
	sub_8221F258(ctx, base);
	// 8261DC44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261DC48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261DC4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261DC50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261DC54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261DC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261DC58 size=60
    let mut pc: u32 = 0x8261DC58;
    'dispatch: loop {
        match pc {
            0x8261DC58 => {
    //   block [0x8261DC58..0x8261DC80)
	// 8261DC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261DC5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261DC60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261DC64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261DC68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261DC6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261DC70: 419A0010  beq cr6, 0x8261dc80
	if ctx.cr[6].eq {
	pc = 0x8261DC80; continue 'dispatch;
	}
	// 8261DC74: 4BE698C5  bl 0x82487538
	ctx.lr = 0x8261DC78;
	sub_82487538(ctx, base);
	// 8261DC78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261DC7C: 4BBFE0BD  bl 0x8221bd38
	ctx.lr = 0x8261DC80;
	sub_8221BD38(ctx, base);
	pc = 0x8261DC80; continue 'dispatch;
            }
            0x8261DC80 => {
    //   block [0x8261DC80..0x8261DC94)
	// 8261DC80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8261DC84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261DC88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261DC8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261DC90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261DC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261DC98 size=732
    let mut pc: u32 = 0x8261DC98;
    'dispatch: loop {
        match pc {
            0x8261DC98 => {
    //   block [0x8261DC98..0x8261DCD0)
	// 8261DC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261DC9C: 4868B75D  bl 0x82ca93f8
	ctx.lr = 0x8261DCA0;
	sub_82CA93D0(ctx, base);
	// 8261DCA0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261DCA4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8261DCA8: F8810118  std r4, 0x118(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[4].u64 ) };
	// 8261DCAC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 8261DCB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261DCB4: 480002C5  bl 0x8261df78
	ctx.lr = 0x8261DCB8;
	sub_8261DF78(ctx, base);
	// 8261DCB8: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261DCBC: 3B000064  li r24, 0x64
	ctx.r[24].s64 = 100;
	// 8261DCC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261DCC4: 409A000C  bne cr6, 0x8261dcd0
	if !ctx.cr[6].eq {
	pc = 0x8261DCD0; continue 'dispatch;
	}
	// 8261DCC8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8261DCCC: 48000010  b 0x8261dcdc
	pc = 0x8261DCDC; continue 'dispatch;
            }
            0x8261DCD0 => {
    //   block [0x8261DCD0..0x8261DCDC)
	// 8261DCD0: 815A000C  lwz r10, 0xc(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261DCD4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8261DCD8: 7D29C3D6  divw r9, r9, r24
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	pc = 0x8261DCDC; continue 'dispatch;
            }
            0x8261DCDC => {
    //   block [0x8261DCDC..0x8261DD08)
	// 8261DCDC: 83BA0008  lwz r29, 8(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261DCE0: 3D40028F  lis r10, 0x28f
	ctx.r[10].s64 = 42926080;
	// 8261DCE4: 7D0BE850  subf r8, r11, r29
	ctx.r[8].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 8261DCE8: 614A5C28  ori r10, r10, 0x5c28
	ctx.r[10].u64 = ctx.r[10].u64 | 23592;
	// 8261DCEC: 7D68C3D6  divw r11, r8, r24
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[24].s32;
	// 8261DCF0: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8261DCF4: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 8261DCF8: 40980010  bge cr6, 0x8261dd08
	if !ctx.cr[6].lt {
	pc = 0x8261DD08; continue 'dispatch;
	}
	// 8261DCFC: 484297CD  bl 0x82a474c8
	ctx.lr = 0x8261DD00;
	sub_82A474C8(ctx, base);
	// 8261DD00: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 8261DD04: 4868B744  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261DD08 => {
    //   block [0x8261DD08..0x8261DD2C)
	// 8261DD08: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 8261DD0C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8261DD10: 40980108  bge cr6, 0x8261de18
	if !ctx.cr[6].lt {
	pc = 0x8261DE18; continue 'dispatch;
	}
	// 8261DD14: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261DD18: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 8261DD1C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8261DD20: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8261DD24: 41980008  blt cr6, 0x8261dd2c
	if ctx.cr[6].lt {
	pc = 0x8261DD2C; continue 'dispatch;
	}
	// 8261DD28: 7F2B4A14  add r25, r11, r9
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x8261DD2C; continue 'dispatch;
            }
            0x8261DD2C => {
    //   block [0x8261DD2C..0x8261DD38)
	// 8261DD2C: 7F194040  cmplw cr6, r25, r8
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8261DD30: 40980008  bge cr6, 0x8261dd38
	if !ctx.cr[6].lt {
	pc = 0x8261DD38; continue 'dispatch;
	}
	// 8261DD34: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	pc = 0x8261DD38; continue 'dispatch;
            }
            0x8261DD38 => {
    //   block [0x8261DD38..0x8261DD5C)
	// 8261DD38: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8261DD3C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8261DD40: 4BFFFEA9  bl 0x8261dbe8
	ctx.lr = 0x8261DD44;
	sub_8261DBE8(ctx, base);
	// 8261DD44: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261DD48: 83A1011C  lwz r29, 0x11c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 8261DD4C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8261DD50: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8261DD54: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8261DD58: 419A0028  beq cr6, 0x8261dd80
	if ctx.cr[6].eq {
	pc = 0x8261DD80; continue 'dispatch;
	}
	pc = 0x8261DD5C; continue 'dispatch;
            }
            0x8261DD5C => {
    //   block [0x8261DD5C..0x8261DD70)
	// 8261DD5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261DD60: 419A0010  beq cr6, 0x8261dd70
	if ctx.cr[6].eq {
	pc = 0x8261DD70; continue 'dispatch;
	}
	// 8261DD64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8261DD68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261DD6C: 4800020D  bl 0x8261df78
	ctx.lr = 0x8261DD70;
	sub_8261DF78(ctx, base);
	pc = 0x8261DD70; continue 'dispatch;
            }
            0x8261DD70 => {
    //   block [0x8261DD70..0x8261DD80)
	// 8261DD70: 3BDE0064  addi r30, r30, 0x64
	ctx.r[30].s64 = ctx.r[30].s64 + 100;
	// 8261DD74: 3BFF0064  addi r31, r31, 0x64
	ctx.r[31].s64 = ctx.r[31].s64 + 100;
	// 8261DD78: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8261DD7C: 409AFFE0  bne cr6, 0x8261dd5c
	if !ctx.cr[6].eq {
	pc = 0x8261DD5C; continue 'dispatch;
	}
	pc = 0x8261DD80; continue 'dispatch;
            }
            0x8261DD80 => {
    //   block [0x8261DD80..0x8261DD94)
	// 8261DD80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261DD84: 419A0010  beq cr6, 0x8261dd94
	if ctx.cr[6].eq {
	pc = 0x8261DD94; continue 'dispatch;
	}
	// 8261DD88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8261DD8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261DD90: 480001E9  bl 0x8261df78
	ctx.lr = 0x8261DD94;
	sub_8261DF78(ctx, base);
	pc = 0x8261DD94; continue 'dispatch;
            }
            0x8261DD94 => {
    //   block [0x8261DD94..0x8261DDB0)
	// 8261DD94: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261DD98: 3BDF0064  addi r30, r31, 0x64
	ctx.r[30].s64 = ctx.r[31].s64 + 100;
	// 8261DD9C: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8261DDA0: 419A0034  beq cr6, 0x8261ddd4
	if ctx.cr[6].eq {
	pc = 0x8261DDD4; continue 'dispatch;
	}
	// 8261DDA4: 7D7FF050  subf r11, r31, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 8261DDA8: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8261DDAC: 3BEBFF9C  addi r31, r11, -0x64
	ctx.r[31].s64 = ctx.r[11].s64 + -100;
	pc = 0x8261DDB0; continue 'dispatch;
            }
            0x8261DDB0 => {
    //   block [0x8261DDB0..0x8261DDC4)
	// 8261DDB0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261DDB4: 419A0010  beq cr6, 0x8261ddc4
	if ctx.cr[6].eq {
	pc = 0x8261DDC4; continue 'dispatch;
	}
	// 8261DDB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261DDBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261DDC0: 480001B9  bl 0x8261df78
	ctx.lr = 0x8261DDC4;
	sub_8261DF78(ctx, base);
	pc = 0x8261DDC4; continue 'dispatch;
            }
            0x8261DDC4 => {
    //   block [0x8261DDC4..0x8261DDD4)
	// 8261DDC4: 3BFF0064  addi r31, r31, 0x64
	ctx.r[31].s64 = ctx.r[31].s64 + 100;
	// 8261DDC8: 3BDE0064  addi r30, r30, 0x64
	ctx.r[30].s64 = ctx.r[30].s64 + 100;
	// 8261DDCC: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8261DDD0: 409AFFE0  bne cr6, 0x8261ddb0
	if !ctx.cr[6].eq {
	pc = 0x8261DDB0; continue 'dispatch;
	}
	pc = 0x8261DDD4; continue 'dispatch;
            }
            0x8261DDD4 => {
    //   block [0x8261DDD4..0x8261DDF4)
	// 8261DDD4: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261DDD8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261DDDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261DDE0: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 8261DDE4: 7D6AC3D6  divw r11, r10, r24
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[24].s32;
	// 8261DDE8: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 8261DDEC: 419A0008  beq cr6, 0x8261ddf4
	if ctx.cr[6].eq {
	pc = 0x8261DDF4; continue 'dispatch;
	}
	// 8261DDF0: 4BBFDF49  bl 0x8221bd38
	ctx.lr = 0x8261DDF4;
	sub_8221BD38(ctx, base);
	pc = 0x8261DDF4; continue 'dispatch;
            }
            0x8261DDF4 => {
    //   block [0x8261DDF4..0x8261DE18)
	// 8261DDF4: 1D590064  mulli r10, r25, 0x64
	ctx.r[10].s32 = ((ctx.r[25].s32 as i64 * 100 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 8261DDF8: 937A0004  stw r27, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 8261DDFC: 1D7F0064  mulli r11, r31, 0x64
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 100 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8261DE00: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 8261DE04: 7D2BDA14  add r9, r11, r27
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 8261DE08: 915A000C  stw r10, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8261DE0C: 913A0008  stw r9, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8261DE10: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 8261DE14: 4868B634  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261DE18 => {
    //   block [0x8261DE18..0x8261DE3C)
	// 8261DE18: 8361011C  lwz r27, 0x11c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 8261DE1C: 7D7BE850  subf r11, r27, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[27].s64;
	// 8261DE20: 7D4BC3D6  divw r10, r11, r24
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[24].s32;
	// 8261DE24: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 8261DE28: 409800B0  bge cr6, 0x8261ded8
	if !ctx.cr[6].lt {
	pc = 0x8261DED8; continue 'dispatch;
	}
	// 8261DE2C: 3BFB0064  addi r31, r27, 0x64
	ctx.r[31].s64 = ctx.r[27].s64 + 100;
	// 8261DE30: 7F1BE840  cmplw cr6, r27, r29
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8261DE34: 419A002C  beq cr6, 0x8261de60
	if ctx.cr[6].eq {
	pc = 0x8261DE60; continue 'dispatch;
	}
	// 8261DE38: 3BDFFF9C  addi r30, r31, -0x64
	ctx.r[30].s64 = ctx.r[31].s64 + -100;
	pc = 0x8261DE3C; continue 'dispatch;
            }
            0x8261DE3C => {
    //   block [0x8261DE3C..0x8261DE50)
	// 8261DE3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261DE40: 419A0010  beq cr6, 0x8261de50
	if ctx.cr[6].eq {
	pc = 0x8261DE50; continue 'dispatch;
	}
	// 8261DE44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8261DE48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261DE4C: 4800012D  bl 0x8261df78
	ctx.lr = 0x8261DE50;
	sub_8261DF78(ctx, base);
	pc = 0x8261DE50; continue 'dispatch;
            }
            0x8261DE50 => {
    //   block [0x8261DE50..0x8261DE60)
	// 8261DE50: 3BDE0064  addi r30, r30, 0x64
	ctx.r[30].s64 = ctx.r[30].s64 + 100;
	// 8261DE54: 3BFF0064  addi r31, r31, 0x64
	ctx.r[31].s64 = ctx.r[31].s64 + 100;
	// 8261DE58: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8261DE5C: 409AFFE0  bne cr6, 0x8261de3c
	if !ctx.cr[6].eq {
	pc = 0x8261DE3C; continue 'dispatch;
	}
	pc = 0x8261DE60; continue 'dispatch;
            }
            0x8261DE60 => {
    //   block [0x8261DE60..0x8261DE78)
	// 8261DE60: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261DE64: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 8261DE68: 7D4BC3D6  divw r10, r11, r24
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[24].s32;
	// 8261DE6C: 23EA0001  subfic r31, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[31].s64 = (1 as i64) - ctx.r[10].s64;
	// 8261DE70: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261DE74: 419A0024  beq cr6, 0x8261de98
	if ctx.cr[6].eq {
	pc = 0x8261DE98; continue 'dispatch;
	}
	pc = 0x8261DE78; continue 'dispatch;
            }
            0x8261DE78 => {
    //   block [0x8261DE78..0x8261DE8C)
	// 8261DE78: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261DE7C: 419A0010  beq cr6, 0x8261de8c
	if ctx.cr[6].eq {
	pc = 0x8261DE8C; continue 'dispatch;
	}
	// 8261DE80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8261DE84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261DE88: 480000F1  bl 0x8261df78
	ctx.lr = 0x8261DE8C;
	sub_8261DF78(ctx, base);
	pc = 0x8261DE8C; continue 'dispatch;
            }
            0x8261DE8C => {
    //   block [0x8261DE8C..0x8261DE98)
	// 8261DE8C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8261DE90: 3BDE0064  addi r30, r30, 0x64
	ctx.r[30].s64 = ctx.r[30].s64 + 100;
	// 8261DE94: 4082FFE4  bne 0x8261de78
	if !ctx.cr[0].eq {
	pc = 0x8261DE78; continue 'dispatch;
	}
	pc = 0x8261DE98; continue 'dispatch;
            }
            0x8261DE98 => {
    //   block [0x8261DE98..0x8261DEB4)
	// 8261DE98: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261DE9C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8261DEA0: 396B0064  addi r11, r11, 0x64
	ctx.r[11].s64 = ctx.r[11].s64 + 100;
	// 8261DEA4: 3BCBFF9C  addi r30, r11, -0x64
	ctx.r[30].s64 = ctx.r[11].s64 + -100;
	// 8261DEA8: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8261DEAC: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8261DEB0: 419A00BC  beq cr6, 0x8261df6c
	if ctx.cr[6].eq {
	pc = 0x8261DF6C; continue 'dispatch;
	}
	pc = 0x8261DEB4; continue 'dispatch;
            }
            0x8261DEB4 => {
    //   block [0x8261DEB4..0x8261DED8)
	// 8261DEB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8261DEB8: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 8261DEBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261DEC0: 4868B5C1  bl 0x82ca9480
	ctx.lr = 0x8261DEC4;
	sub_82CA9480(ctx, base);
	// 8261DEC4: 3BFF0064  addi r31, r31, 0x64
	ctx.r[31].s64 = ctx.r[31].s64 + 100;
	// 8261DEC8: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8261DECC: 409AFFE8  bne cr6, 0x8261deb4
	if !ctx.cr[6].eq {
	pc = 0x8261DEB4; continue 'dispatch;
	}
	// 8261DED0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 8261DED4: 4868B574  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261DED8 => {
    //   block [0x8261DED8..0x8261DEEC)
	// 8261DED8: 3BFDFF9C  addi r31, r29, -0x64
	ctx.r[31].s64 = ctx.r[29].s64 + -100;
	// 8261DEDC: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 8261DEE0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8261DEE4: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8261DEE8: 419A0028  beq cr6, 0x8261df10
	if ctx.cr[6].eq {
	pc = 0x8261DF10; continue 'dispatch;
	}
	pc = 0x8261DEEC; continue 'dispatch;
            }
            0x8261DEEC => {
    //   block [0x8261DEEC..0x8261DF00)
	// 8261DEEC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261DEF0: 419A0010  beq cr6, 0x8261df00
	if ctx.cr[6].eq {
	pc = 0x8261DF00; continue 'dispatch;
	}
	// 8261DEF4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8261DEF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261DEFC: 4800007D  bl 0x8261df78
	ctx.lr = 0x8261DF00;
	sub_8261DF78(ctx, base);
	pc = 0x8261DF00; continue 'dispatch;
            }
            0x8261DF00 => {
    //   block [0x8261DF00..0x8261DF10)
	// 8261DF00: 3B9C0064  addi r28, r28, 0x64
	ctx.r[28].s64 = ctx.r[28].s64 + 100;
	// 8261DF04: 3BDE0064  addi r30, r30, 0x64
	ctx.r[30].s64 = ctx.r[30].s64 + 100;
	// 8261DF08: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8261DF0C: 409AFFE0  bne cr6, 0x8261deec
	if !ctx.cr[6].eq {
	pc = 0x8261DEEC; continue 'dispatch;
	}
	pc = 0x8261DF10; continue 'dispatch;
            }
            0x8261DF10 => {
    //   block [0x8261DF10..0x8261DF20)
	// 8261DF10: 93DA0008  stw r30, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 8261DF14: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8261DF18: 419A0028  beq cr6, 0x8261df40
	if ctx.cr[6].eq {
	pc = 0x8261DF40; continue 'dispatch;
	}
	// 8261DF1C: 3BDF0064  addi r30, r31, 0x64
	ctx.r[30].s64 = ctx.r[31].s64 + 100;
	pc = 0x8261DF20; continue 'dispatch;
            }
            0x8261DF20 => {
    //   block [0x8261DF20..0x8261DF40)
	// 8261DF20: 3BFFFF9C  addi r31, r31, -0x64
	ctx.r[31].s64 = ctx.r[31].s64 + -100;
	// 8261DF24: 3BDEFF9C  addi r30, r30, -0x64
	ctx.r[30].s64 = ctx.r[30].s64 + -100;
	// 8261DF28: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 8261DF2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261DF30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261DF34: 4868B54D  bl 0x82ca9480
	ctx.lr = 0x8261DF38;
	sub_82CA9480(ctx, base);
	// 8261DF38: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 8261DF3C: 409AFFE4  bne cr6, 0x8261df20
	if !ctx.cr[6].eq {
	pc = 0x8261DF20; continue 'dispatch;
	}
	pc = 0x8261DF40; continue 'dispatch;
            }
            0x8261DF40 => {
    //   block [0x8261DF40..0x8261DF50)
	// 8261DF40: 3BDB0064  addi r30, r27, 0x64
	ctx.r[30].s64 = ctx.r[27].s64 + 100;
	// 8261DF44: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8261DF48: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8261DF4C: 419A0020  beq cr6, 0x8261df6c
	if ctx.cr[6].eq {
	pc = 0x8261DF6C; continue 'dispatch;
	}
	pc = 0x8261DF50; continue 'dispatch;
            }
            0x8261DF50 => {
    //   block [0x8261DF50..0x8261DF6C)
	// 8261DF50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8261DF54: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 8261DF58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261DF5C: 4868B525  bl 0x82ca9480
	ctx.lr = 0x8261DF60;
	sub_82CA9480(ctx, base);
	// 8261DF60: 3BFF0064  addi r31, r31, 0x64
	ctx.r[31].s64 = ctx.r[31].s64 + 100;
	// 8261DF64: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8261DF68: 409AFFE8  bne cr6, 0x8261df50
	if !ctx.cr[6].eq {
	pc = 0x8261DF50; continue 'dispatch;
	}
	pc = 0x8261DF6C; continue 'dispatch;
            }
            0x8261DF6C => {
    //   block [0x8261DF6C..0x8261DF74)
	// 8261DF6C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 8261DF70: 4868B4D8  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261DF78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8261DF78 size=204
    let mut pc: u32 = 0x8261DF78;
    'dispatch: loop {
        match pc {
            0x8261DF78 => {
    //   block [0x8261DF78..0x8261E044)
	// 8261DF78: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261DF7C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8261DF80: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261DF84: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8261DF88: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261DF8C: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8261DF90: 8104000C  lwz r8, 0xc(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261DF94: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 8261DF98: 80E40010  lwz r7, 0x10(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 8261DF9C: 90E30010  stw r7, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 8261DFA0: 80C40014  lwz r6, 0x14(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 8261DFA4: 90C30014  stw r6, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 8261DFA8: 80A40018  lwz r5, 0x18(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 8261DFAC: 90A30018  stw r5, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[5].u32 ) };
	// 8261DFB0: 8164001C  lwz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 8261DFB4: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8261DFB8: 81440020  lwz r10, 0x20(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 8261DFBC: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 8261DFC0: 81240024  lwz r9, 0x24(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 8261DFC4: 91230024  stw r9, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 8261DFC8: 81040028  lwz r8, 0x28(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261DFCC: 91030028  stw r8, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 8261DFD0: 80E4002C  lwz r7, 0x2c(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 8261DFD4: 90E3002C  stw r7, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[7].u32 ) };
	// 8261DFD8: 80C40030  lwz r6, 0x30(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261DFDC: 90C30030  stw r6, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[6].u32 ) };
	// 8261DFE0: 80A40034  lwz r5, 0x34(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 8261DFE4: 90A30034  stw r5, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[5].u32 ) };
	// 8261DFE8: 81640038  lwz r11, 0x38(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 8261DFEC: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 8261DFF0: C004003C  lfs f0, 0x3c(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8261DFF4: D003003C  stfs f0, 0x3c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8261DFF8: C1A40040  lfs f13, 0x40(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8261DFFC: D1A30040  stfs f13, 0x40(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8261E000: C1840044  lfs f12, 0x44(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8261E004: D1830044  stfs f12, 0x44(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8261E008: C1640048  lfs f11, 0x48(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8261E00C: D1630048  stfs f11, 0x48(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8261E010: C144004C  lfs f10, 0x4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8261E014: D143004C  stfs f10, 0x4c(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 8261E018: C1240050  lfs f9, 0x50(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(80 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8261E01C: D1230050  stfs f9, 0x50(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8261E020: C1040054  lfs f8, 0x54(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8261E024: D1030054  stfs f8, 0x54(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8261E028: C0E40058  lfs f7, 0x58(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8261E02C: D0E30058  stfs f7, 0x58(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8261E030: C0C4005C  lfs f6, 0x5c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(92 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 8261E034: D0C3005C  stfs f6, 0x5c(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8261E038: 81440060  lwz r10, 0x60(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(96 as u32) ) } as u64;
	// 8261E03C: 91430060  stw r10, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8261E040: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8261E048 size=12
    let mut pc: u32 = 0x8261E048;
    'dispatch: loop {
        match pc {
            0x8261E048 => {
    //   block [0x8261E048..0x8261E054)
	// 8261E048: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261E04C: 386B92BC  addi r3, r11, -0x6d44
	ctx.r[3].s64 = ctx.r[11].s64 + -27972;
	// 8261E050: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261E058 size=88
    let mut pc: u32 = 0x8261E058;
    'dispatch: loop {
        match pc {
            0x8261E058 => {
    //   block [0x8261E058..0x8261E094)
	// 8261E058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261E05C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261E060: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8261E064: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261E068: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261E06C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261E070: 38600088  li r3, 0x88
	ctx.r[3].s64 = 136;
	// 8261E074: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8261E078: 4BFF88B1  bl 0x82616928
	ctx.lr = 0x8261E07C;
	sub_82616928(ctx, base);
	// 8261E07C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261E080: 419A0014  beq cr6, 0x8261e094
	if ctx.cr[6].eq {
	pc = 0x8261E094; continue 'dispatch;
	}
	// 8261E084: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8261E088: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261E08C: 48000025  bl 0x8261e0b0
	ctx.lr = 0x8261E090;
	sub_8261E0B0(ctx, base);
	// 8261E090: 48000008  b 0x8261e098
	pc = 0x8261E098; continue 'dispatch;
            }
            0x8261E094 => {
    //   block [0x8261E094..0x8261E098)
	// 8261E094: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8261E098; continue 'dispatch;
            }
            0x8261E098 => {
    //   block [0x8261E098..0x8261E0B0)
	// 8261E098: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261E09C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261E0A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261E0A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8261E0A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261E0AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E0B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261E0B0 size=112
    let mut pc: u32 = 0x8261E0B0;
    'dispatch: loop {
        match pc {
            0x8261E0B0 => {
    //   block [0x8261E0B0..0x8261E100)
	// 8261E0B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261E0B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261E0B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261E0BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261E0C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261E0C4: 4BFFB6A5  bl 0x82619768
	ctx.lr = 0x8261E0C8;
	sub_82619768(ctx, base);
	// 8261E0C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8261E0CC: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 8261E0D0: 394B213C  addi r10, r11, 0x213c
	ctx.r[10].s64 = ctx.r[11].s64 + 8508;
	// 8261E0D4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8261E0D8: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 8261E0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261E0E0: 419A0020  beq cr6, 0x8261e100
	if ctx.cr[6].eq {
	pc = 0x8261E100; continue 'dispatch;
	}
	// 8261E0E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261E0E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261E0EC: 419A002C  beq cr6, 0x8261e118
	if ctx.cr[6].eq {
	pc = 0x8261E118; continue 'dispatch;
	}
	// 8261E0F0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261E0F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261E0F8: 419A0008  beq cr6, 0x8261e100
	if ctx.cr[6].eq {
	pc = 0x8261E100; continue 'dispatch;
	}
	// 8261E0FC: 4BB55D3D  bl 0x82173e38
	ctx.lr = 0x8261E100;
	sub_82173E38(ctx, base);
	pc = 0x8261E100; continue 'dispatch;
            }
            0x8261E100 => {
    //   block [0x8261E100..0x8261E118)
	// 8261E100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261E104: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8261E108: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261E10C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261E110: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261E114: 4E800020  blr
	return;
            }
            0x8261E118 => {
    //   block [0x8261E118..0x8261E120)
	// 8261E118: 4BB75D21  bl 0x82193e38
	ctx.lr = 0x8261E11C;
	sub_82193E38(ctx, base);
	// 8261E11C: 4BFFFFE4  b 0x8261e100
	pc = 0x8261E100; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261E120 size=124
    let mut pc: u32 = 0x8261E120;
    'dispatch: loop {
        match pc {
            0x8261E120 => {
    //   block [0x8261E120..0x8261E184)
	// 8261E120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261E124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261E128: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8261E12C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261E130: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261E134: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261E138: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8261E13C: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 8261E140: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 8261E144: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8261E148: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 8261E14C: 4BB75CED  bl 0x82193e38
	ctx.lr = 0x8261E150;
	sub_82193E38(ctx, base);
	// 8261E150: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8261E154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261E158: 913F0078  stw r9, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 8261E15C: 48860AC5  bl 0x82e7ec20
	ctx.lr = 0x8261E160;
	sub_82E7EC20(ctx, base);
	// 8261E160: 57C807FE  clrlwi r8, r30, 0x1f
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8261E164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261E168: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8261E16C: 419A0018  beq cr6, 0x8261e184
	if ctx.cr[6].eq {
	pc = 0x8261E184; continue 'dispatch;
	}
	// 8261E170: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 8261E174: 814BDAB4  lwz r10, -0x254c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 8261E178: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261E17C: 4E800421  bctrl
	ctx.lr = 0x8261E180;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261E180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            0x8261E184 => {
    //   block [0x8261E184..0x8261E19C)
	// 8261E184: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261E188: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261E18C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261E190: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8261E194: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261E198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261E1A8 size=68
    let mut pc: u32 = 0x8261E1A8;
    'dispatch: loop {
        match pc {
            0x8261E1A8 => {
    //   block [0x8261E1A8..0x8261E1D8)
	// 8261E1A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261E1AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261E1B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261E1B4: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 8261E1B8: 4BFF8771  bl 0x82616928
	ctx.lr = 0x8261E1BC;
	sub_82616928(ctx, base);
	// 8261E1BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261E1C0: 419A0018  beq cr6, 0x8261e1d8
	if ctx.cr[6].eq {
	pc = 0x8261E1D8; continue 'dispatch;
	}
	// 8261E1C4: 4800002D  bl 0x8261e1f0
	ctx.lr = 0x8261E1C8;
	sub_8261E1F0(ctx, base);
	// 8261E1C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8261E1CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261E1D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261E1D4: 4E800020  blr
	return;
            }
            0x8261E1D8 => {
    //   block [0x8261E1D8..0x8261E1EC)
	// 8261E1D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8261E1DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8261E1E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261E1E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261E1E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261E1F0 size=100
    let mut pc: u32 = 0x8261E1F0;
    'dispatch: loop {
        match pc {
            0x8261E1F0 => {
    //   block [0x8261E1F0..0x8261E254)
	// 8261E1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261E1F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261E1F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261E1FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261E200: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261E204: 4885F87D  bl 0x82e7da80
	ctx.lr = 0x8261E208;
	sub_82E7DA80(ctx, base);
	// 8261E208: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8261E20C: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 8261E210: 392B1AD8  addi r9, r11, 0x1ad8
	ctx.r[9].s64 = ctx.r[11].s64 + 6872;
	// 8261E214: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261E218: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8261E21C: 388AC6DC  addi r4, r10, -0x3924
	ctx.r[4].s64 = ctx.r[10].s64 + -14628;
	// 8261E220: 4885F571  bl 0x82e7d790
	ctx.lr = 0x8261E224;
	sub_82E7D790(ctx, base);
	// 8261E224: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 8261E228: 3D008334  lis r8, -0x7ccc
	ctx.r[8].s64 = -2093744128;
	// 8261E22C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261E230: 3888C7F0  addi r4, r8, -0x3810
	ctx.r[4].s64 = ctx.r[8].s64 + -14352;
	// 8261E234: 4885F55D  bl 0x82e7d790
	ctx.lr = 0x8261E238;
	sub_82E7D790(ctx, base);
	// 8261E238: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 8261E23C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261E240: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8261E244: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261E248: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261E24C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261E250: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261E258 size=92
    let mut pc: u32 = 0x8261E258;
    'dispatch: loop {
        match pc {
            0x8261E258 => {
    //   block [0x8261E258..0x8261E29C)
	// 8261E258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261E25C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261E260: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8261E264: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261E268: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261E26C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261E270: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8261E274: 4885F34D  bl 0x82e7d5c0
	ctx.lr = 0x8261E278;
	sub_82E7D5C0(ctx, base);
	// 8261E278: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8261E27C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261E280: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261E284: 419A0018  beq cr6, 0x8261e29c
	if ctx.cr[6].eq {
	pc = 0x8261E29C; continue 'dispatch;
	}
	// 8261E288: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 8261E28C: 814BDAB4  lwz r10, -0x254c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 8261E290: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261E294: 4E800421  bctrl
	ctx.lr = 0x8261E298;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261E298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            0x8261E29C => {
    //   block [0x8261E29C..0x8261E2B4)
	// 8261E29C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261E2A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261E2A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261E2A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8261E2AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261E2B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261E2B8 size=140
    let mut pc: u32 = 0x8261E2B8;
    'dispatch: loop {
        match pc {
            0x8261E2B8 => {
    //   block [0x8261E2B8..0x8261E344)
	// 8261E2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261E2BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261E2C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8261E2C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261E2C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261E2CC: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261E2D0: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 8261E2D4: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261E2D8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261E2DC: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261E2E0: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 8261E2E4: 83EB0038  lwz r31, 0x38(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 8261E2E8: 80CB0018  lwz r6, 0x18(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8261E2EC: 83C9000C  lwz r30, 0xc(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 8261E2F0: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 8261E2F4: 7D6A402E  lwzx r11, r10, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8261E2F8: 7D5F402E  lwzx r10, r31, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8261E2FC: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8261E300: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261E304: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8261E308: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8261E30C: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261E310: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8261E314: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 8261E318: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 8261E31C: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 8261E320: 38AA0004  addi r5, r10, 4
	ctx.r[5].s64 = ctx.r[10].s64 + 4;
	// 8261E324: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 8261E328: 4E800421  bctrl
	ctx.lr = 0x8261E32C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261E32C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261E330: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261E334: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261E338: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8261E33C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261E340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8261E348 size=12
    let mut pc: u32 = 0x8261E348;
    'dispatch: loop {
        match pc {
            0x8261E348 => {
    //   block [0x8261E348..0x8261E354)
	// 8261E348: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261E34C: 386BA0D0  addi r3, r11, -0x5f30
	ctx.r[3].s64 = ctx.r[11].s64 + -24368;
	// 8261E350: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8261E358 size=12
    let mut pc: u32 = 0x8261E358;
    'dispatch: loop {
        match pc {
            0x8261E358 => {
    //   block [0x8261E358..0x8261E364)
	// 8261E358: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8261E35C: 986B6CBD  stb r3, 0x6cbd(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(27837 as u32), ctx.r[3].u8 ) };
	// 8261E360: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8261E368 size=12
    let mut pc: u32 = 0x8261E368;
    'dispatch: loop {
        match pc {
            0x8261E368 => {
    //   block [0x8261E368..0x8261E374)
	// 8261E368: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8261E36C: 986B6CBE  stb r3, 0x6cbe(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(27838 as u32), ctx.r[3].u8 ) };
	// 8261E370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8261E378 size=12
    let mut pc: u32 = 0x8261E378;
    'dispatch: loop {
        match pc {
            0x8261E378 => {
    //   block [0x8261E378..0x8261E384)
	// 8261E378: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261E37C: 386B94E4  addi r3, r11, -0x6b1c
	ctx.r[3].s64 = ctx.r[11].s64 + -27420;
	// 8261E380: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8261E388 size=20
    let mut pc: u32 = 0x8261E388;
    'dispatch: loop {
        match pc {
            0x8261E388 => {
    //   block [0x8261E388..0x8261E39C)
	// 8261E388: 816300AC  lwz r11, 0xac(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(172 as u32) ) } as u64;
	// 8261E38C: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 8261E390: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8261E394: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 8261E398: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261E3A0 size=88
    let mut pc: u32 = 0x8261E3A0;
    'dispatch: loop {
        match pc {
            0x8261E3A0 => {
    //   block [0x8261E3A0..0x8261E3DC)
	// 8261E3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261E3A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261E3A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8261E3AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261E3B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261E3B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261E3B8: 3860005C  li r3, 0x5c
	ctx.r[3].s64 = 92;
	// 8261E3BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8261E3C0: 4BFF8569  bl 0x82616928
	ctx.lr = 0x8261E3C4;
	sub_82616928(ctx, base);
	// 8261E3C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261E3C8: 419A0014  beq cr6, 0x8261e3dc
	if ctx.cr[6].eq {
	pc = 0x8261E3DC; continue 'dispatch;
	}
	// 8261E3CC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8261E3D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8261E3D4: 48000025  bl 0x8261e3f8
	ctx.lr = 0x8261E3D8;
	sub_8261E3F8(ctx, base);
	// 8261E3D8: 48000008  b 0x8261e3e0
	pc = 0x8261E3E0; continue 'dispatch;
            }
            0x8261E3DC => {
    //   block [0x8261E3DC..0x8261E3E0)
	// 8261E3DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8261E3E0; continue 'dispatch;
            }
            0x8261E3E0 => {
    //   block [0x8261E3E0..0x8261E3F8)
	// 8261E3E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261E3E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261E3E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261E3EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8261E3F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261E3F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261E3F8 size=148
    let mut pc: u32 = 0x8261E3F8;
    'dispatch: loop {
        match pc {
            0x8261E3F8 => {
    //   block [0x8261E3F8..0x8261E48C)
	// 8261E3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261E3FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261E400: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261E404: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261E408: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261E40C: 4886043D  bl 0x82e7e848
	ctx.lr = 0x8261E410;
	sub_82E7E848(ctx, base);
	// 8261E410: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 8261E414: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8261E418: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8261E41C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8261E420: 38E92598  addi r7, r9, 0x2598
	ctx.r[7].s64 = ctx.r[9].s64 + 9624;
	// 8261E424: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 8261E428: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8261E42C: 38A88D10  addi r5, r8, -0x72f0
	ctx.r[5].s64 = ctx.r[8].s64 + -29424;
	// 8261E430: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 8261E434: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 8261E438: 38861BBC  addi r4, r6, 0x1bbc
	ctx.r[4].s64 = ctx.r[6].s64 + 7100;
	// 8261E43C: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 8261E440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261E444: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8261E448: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 8261E44C: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 8261E450: 90BF0034  stw r5, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[5].u32 ) };
	// 8261E454: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 8261E458: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 8261E45C: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 8261E460: 909F004C  stw r4, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[4].u32 ) };
	// 8261E464: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8261E468: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8261E46C: 894AEAF9  lbz r10, -0x1507(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-5383 as u32) ) } as u64;
	// 8261E470: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8261E474: 995F003C  stb r10, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[10].u8 ) };
	// 8261E478: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8261E47C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261E480: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261E484: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261E488: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261E490 size=108
    let mut pc: u32 = 0x8261E490;
    'dispatch: loop {
        match pc {
            0x8261E490 => {
    //   block [0x8261E490..0x8261E4E4)
	// 8261E490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261E494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261E498: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8261E49C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261E4A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261E4A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261E4A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8261E4AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8261E4B0: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 8261E4B4: 915F004C  stw r10, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 8261E4B8: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 8261E4BC: 4885F895  bl 0x82e7dd50
	ctx.lr = 0x8261E4C0;
	sub_82E7DD50(ctx, base);
	// 8261E4C0: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8261E4C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261E4C8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261E4CC: 419A0018  beq cr6, 0x8261e4e4
	if ctx.cr[6].eq {
	pc = 0x8261E4E4; continue 'dispatch;
	}
	// 8261E4D0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 8261E4D4: 814BDAB4  lwz r10, -0x254c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 8261E4D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261E4DC: 4E800421  bctrl
	ctx.lr = 0x8261E4E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261E4E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            0x8261E4E4 => {
    //   block [0x8261E4E4..0x8261E4FC)
	// 8261E4E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261E4E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261E4EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261E4F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8261E4F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261E4F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261E500 size=724
    let mut pc: u32 = 0x8261E500;
    'dispatch: loop {
        match pc {
            0x8261E500 => {
    //   block [0x8261E500..0x8261E528)
	// 8261E500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261E504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261E508: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8261E50C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261E510: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261E514: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261E518: 4885FFA1  bl 0x82e7e4b8
	ctx.lr = 0x8261E51C;
	sub_82E7E4B8(ctx, base);
	// 8261E51C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261E520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261E524: 409A000C  bne cr6, 0x8261e530
	if !ctx.cr[6].eq {
	pc = 0x8261E530; continue 'dispatch;
	}
	pc = 0x8261E528; continue 'dispatch;
            }
            0x8261E528 => {
    //   block [0x8261E528..0x8261E530)
	// 8261E528: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8261E52C: 48000290  b 0x8261e7bc
	pc = 0x8261E7BC; continue 'dispatch;
            }
            0x8261E530 => {
    //   block [0x8261E530..0x8261E60C)
	// 8261E530: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 8261E534: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261E538: 388BBAFC  addi r4, r11, -0x4504
	ctx.r[4].s64 = ctx.r[11].s64 + -17668;
	// 8261E53C: 4885FB75  bl 0x82e7e0b0
	ctx.lr = 0x8261E540;
	sub_82E7E0B0(ctx, base);
	// 8261E540: 907E0020  stw r3, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 8261E544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261E548: 419AFFE0  beq cr6, 0x8261e528
	if ctx.cr[6].eq {
	pc = 0x8261E528; continue 'dispatch;
	}
	// 8261E54C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 8261E550: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261E554: 388BB7C0  addi r4, r11, -0x4840
	ctx.r[4].s64 = ctx.r[11].s64 + -18496;
	// 8261E558: 4885FB59  bl 0x82e7e0b0
	ctx.lr = 0x8261E55C;
	sub_82E7E0B0(ctx, base);
	// 8261E55C: 907E0024  stw r3, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 8261E560: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261E564: 419AFFC4  beq cr6, 0x8261e528
	if ctx.cr[6].eq {
	pc = 0x8261E528; continue 'dispatch;
	}
	// 8261E568: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 8261E56C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261E570: 388BB9E8  addi r4, r11, -0x4618
	ctx.r[4].s64 = ctx.r[11].s64 + -17944;
	// 8261E574: 4885FB3D  bl 0x82e7e0b0
	ctx.lr = 0x8261E578;
	sub_82E7E0B0(ctx, base);
	// 8261E578: 907E0028  stw r3, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 8261E57C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261E580: 419AFFA8  beq cr6, 0x8261e528
	if ctx.cr[6].eq {
	pc = 0x8261E528; continue 'dispatch;
	}
	// 8261E584: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 8261E588: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261E58C: 388BBC10  addi r4, r11, -0x43f0
	ctx.r[4].s64 = ctx.r[11].s64 + -17392;
	// 8261E590: 4885FB21  bl 0x82e7e0b0
	ctx.lr = 0x8261E594;
	sub_82E7E0B0(ctx, base);
	// 8261E594: 907E002C  stw r3, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 8261E598: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261E59C: 419AFF8C  beq cr6, 0x8261e528
	if ctx.cr[6].eq {
	pc = 0x8261E528; continue 'dispatch;
	}
	// 8261E5A0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 8261E5A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261E5A8: 388BB8D4  addi r4, r11, -0x472c
	ctx.r[4].s64 = ctx.r[11].s64 + -18220;
	// 8261E5AC: 4885FB05  bl 0x82e7e0b0
	ctx.lr = 0x8261E5B0;
	sub_82E7E0B0(ctx, base);
	// 8261E5B0: 907E0030  stw r3, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 8261E5B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261E5B8: 419AFF70  beq cr6, 0x8261e528
	if ctx.cr[6].eq {
	pc = 0x8261E528; continue 'dispatch;
	}
	// 8261E5BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8261E5C0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8261E5C4: 48852BFD  bl 0x82e711c0
	ctx.lr = 0x8261E5C8;
	sub_82E711C0(ctx, base);
	// 8261E5C8: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8261E5CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8261E5D0: 90BE0040  stw r5, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[5].u32 ) };
	// 8261E5D4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8261E5D8: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261E5DC: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 8261E5E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261E5E4: 419A00D8  beq cr6, 0x8261e6bc
	if ctx.cr[6].eq {
	pc = 0x8261E6BC; continue 'dispatch;
	}
	// 8261E5E8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261E5EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261E5F0: 419A001C  beq cr6, 0x8261e60c
	if ctx.cr[6].eq {
	pc = 0x8261E60C; continue 'dispatch;
	}
	// 8261E5F4: 894A003C  lbz r10, 0x3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 8261E5F8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261E5FC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8261E600: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261E604: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261E608: 480000B0  b 0x8261e6b8
	pc = 0x8261E6B8; continue 'dispatch;
            }
            0x8261E60C => {
    //   block [0x8261E60C..0x8261E628)
	// 8261E60C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261E610: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261E614: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 8261E618: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8261E61C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8261E620: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261E624: 40810054  ble 0x8261e678
	if !ctx.cr[0].gt {
	pc = 0x8261E678; continue 'dispatch;
	}
	pc = 0x8261E628; continue 'dispatch;
            }
            0x8261E628 => {
    //   block [0x8261E628..0x8261E648)
	// 8261E628: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261E62C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261E630: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8261E634: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261E638: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 8261E63C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8261E640: 41980008  blt cr6, 0x8261e648
	if ctx.cr[6].lt {
	pc = 0x8261E648; continue 'dispatch;
	}
	// 8261E644: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	pc = 0x8261E648; continue 'dispatch;
            }
            0x8261E648 => {
    //   block [0x8261E648..0x8261E664)
	// 8261E648: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8261E64C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261E650: 419A0014  beq cr6, 0x8261e664
	if ctx.cr[6].eq {
	pc = 0x8261E664; continue 'dispatch;
	}
	// 8261E654: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261E658: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8261E65C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8261E660: 4800000C  b 0x8261e66c
	pc = 0x8261E66C; continue 'dispatch;
            }
            0x8261E664 => {
    //   block [0x8261E664..0x8261E66C)
	// 8261E664: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261E668: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8261E66C; continue 'dispatch;
            }
            0x8261E66C => {
    //   block [0x8261E66C..0x8261E678)
	// 8261E66C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261E670: 4199FFB8  bgt cr6, 0x8261e628
	if ctx.cr[6].gt {
	pc = 0x8261E628; continue 'dispatch;
	}
	// 8261E674: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8261E678; continue 'dispatch;
            }
            0x8261E678 => {
    //   block [0x8261E678..0x8261E694)
	// 8261E678: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8261E67C: 419A0034  beq cr6, 0x8261e6b0
	if ctx.cr[6].eq {
	pc = 0x8261E6B0; continue 'dispatch;
	}
	// 8261E680: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261E684: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 8261E688: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261E68C: 41990008  bgt cr6, 0x8261e694
	if ctx.cr[6].gt {
	pc = 0x8261E694; continue 'dispatch;
	}
	// 8261E690: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x8261E694; continue 'dispatch;
            }
            0x8261E694 => {
    //   block [0x8261E694..0x8261E6B0)
	// 8261E694: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261E698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261E69C: 409A0014  bne cr6, 0x8261e6b0
	if !ctx.cr[6].eq {
	pc = 0x8261E6B0; continue 'dispatch;
	}
	// 8261E6A0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8261E6A4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8261E6A8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261E6AC: 48000008  b 0x8261e6b4
	pc = 0x8261E6B4; continue 'dispatch;
            }
            0x8261E6B0 => {
    //   block [0x8261E6B0..0x8261E6B4)
	// 8261E6B0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x8261E6B4; continue 'dispatch;
            }
            0x8261E6B4 => {
    //   block [0x8261E6B4..0x8261E6B8)
	// 8261E6B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x8261E6B8; continue 'dispatch;
            }
            0x8261E6B8 => {
    //   block [0x8261E6B8..0x8261E6BC)
	// 8261E6B8: 917E0040  stw r11, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	pc = 0x8261E6BC; continue 'dispatch;
            }
            0x8261E6BC => {
    //   block [0x8261E6BC..0x8261E7A8)
	// 8261E6BC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261E6C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8261E6C4: 388B8D4C  addi r4, r11, -0x72b4
	ctx.r[4].s64 = ctx.r[11].s64 + -29364;
	// 8261E6C8: 4BC48E49  bl 0x82267510
	ctx.lr = 0x8261E6CC;
	sub_82267510(ctx, base);
	// 8261E6CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261E6D0: 907E001C  stw r3, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 8261E6D4: 419AFE54  beq cr6, 0x8261e528
	if ctx.cr[6].eq {
	pc = 0x8261E528; continue 'dispatch;
	}
	// 8261E6D8: 3D608262  lis r11, -0x7d9e
	ctx.r[11].s64 = -2107506688;
	// 8261E6DC: 3D408262  lis r10, -0x7d9e
	ctx.r[10].s64 = -2107506688;
	// 8261E6E0: 392B70F8  addi r9, r11, 0x70f8
	ctx.r[9].s64 = ctx.r[11].s64 + 28920;
	// 8261E6E4: 390A72D8  addi r8, r10, 0x72d8
	ctx.r[8].s64 = ctx.r[10].s64 + 29400;
	// 8261E6E8: 9123009C  stw r9, 0x9c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), ctx.r[9].u32 ) };
	// 8261E6EC: 3CE08263  lis r7, -0x7d9d
	ctx.r[7].s64 = -2107441152;
	// 8261E6F0: 80DE001C  lwz r6, 0x1c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8261E6F4: 3CA08262  lis r5, -0x7d9e
	ctx.r[5].s64 = -2107506688;
	// 8261E6F8: 910600B4  stw r8, 0xb4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(180 as u32), ctx.r[8].u32 ) };
	// 8261E6FC: 386787A8  addi r3, r7, -0x7858
	ctx.r[3].s64 = ctx.r[7].s64 + -30808;
	// 8261E700: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8261E704: 38857DF8  addi r4, r5, 0x7df8
	ctx.r[4].s64 = ctx.r[5].s64 + 32248;
	// 8261E708: 906B00A4  stw r3, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 8261E70C: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8261E710: 806A01B0  lwz r3, 0x1b0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(432 as u32) ) } as u64;
	// 8261E714: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261E718: 8109001C  lwz r8, 0x1c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 8261E71C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8261E720: 4E800421  bctrl
	ctx.lr = 0x8261E724;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261E724: 3CE08334  lis r7, -0x7ccc
	ctx.r[7].s64 = -2093744128;
	// 8261E728: 809E001C  lwz r4, 0x1c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8261E72C: 3CC08263  lis r6, -0x7d9d
	ctx.r[6].s64 = -2107441152;
	// 8261E730: 38A69A10  addi r5, r6, -0x65f0
	ctx.r[5].s64 = ctx.r[6].s64 + -26096;
	// 8261E734: 80670718  lwz r3, 0x718(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(1816 as u32) ) } as u64;
	// 8261E738: 90A400AC  stw r5, 0xac(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(172 as u32), ctx.r[5].u32 ) };
	// 8261E73C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261E740: 419A0068  beq cr6, 0x8261e7a8
	if ctx.cr[6].eq {
	pc = 0x8261E7A8; continue 'dispatch;
	}
	// 8261E744: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 8261E748: 388B2E38  addi r4, r11, 0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + 11832;
	// 8261E74C: 4BC494D5  bl 0x82267c20
	ctx.lr = 0x8261E750;
	sub_82267C20(ctx, base);
	// 8261E750: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261E754: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261E758: 419A0050  beq cr6, 0x8261e7a8
	if ctx.cr[6].eq {
	pc = 0x8261E7A8; continue 'dispatch;
	}
	// 8261E75C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8261E760: 388B6B44  addi r4, r11, 0x6b44
	ctx.r[4].s64 = ctx.r[11].s64 + 27460;
	// 8261E764: 4885DB65  bl 0x82e7c2c8
	ctx.lr = 0x8261E768;
	sub_82E7C2C8(ctx, base);
	// 8261E768: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8261E76C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8261E770: 419A0038  beq cr6, 0x8261e7a8
	if ctx.cr[6].eq {
	pc = 0x8261E7A8; continue 'dispatch;
	}
	// 8261E774: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261E778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261E77C: 38ABC918  addi r5, r11, -0x36e8
	ctx.r[5].s64 = ctx.r[11].s64 + -14056;
	// 8261E780: 4886E911  bl 0x82e8d090
	ctx.lr = 0x8261E784;
	sub_82E8D090(ctx, base);
	// 8261E784: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261E788: 419A0020  beq cr6, 0x8261e7a8
	if ctx.cr[6].eq {
	pc = 0x8261E7A8; continue 'dispatch;
	}
	// 8261E78C: 907E0054  stw r3, 0x54(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 8261E790: 389E004C  addi r4, r30, 0x4c
	ctx.r[4].s64 = ctx.r[30].s64 + 76;
	// 8261E794: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8261E798: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261E79C: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 8261E7A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261E7A4: 4E800421  bctrl
	ctx.lr = 0x8261E7A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8261E7A8 => {
    //   block [0x8261E7A8..0x8261E7BC)
	// 8261E7A8: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8261E7AC: 3D408263  lis r10, -0x7d9d
	ctx.r[10].s64 = -2107441152;
	// 8261E7B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8261E7B4: 392AA4F8  addi r9, r10, -0x5b08
	ctx.r[9].s64 = ctx.r[10].s64 + -23304;
	// 8261E7B8: 912B00A0  stw r9, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	pc = 0x8261E7BC; continue 'dispatch;
            }
            0x8261E7BC => {
    //   block [0x8261E7BC..0x8261E7D4)
	// 8261E7BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261E7C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261E7C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261E7C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8261E7CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261E7D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E7D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261E7D8 size=204
    let mut pc: u32 = 0x8261E7D8;
    'dispatch: loop {
        match pc {
            0x8261E7D8 => {
    //   block [0x8261E7D8..0x8261E838)
	// 8261E7D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261E7DC: 4868AC31  bl 0x82ca940c
	ctx.lr = 0x8261E7E0;
	sub_82CA93D0(ctx, base);
	// 8261E7E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261E7E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261E7E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8261E7EC: 4BE8FE75  bl 0x824ae660
	ctx.lr = 0x8261E7F0;
	sub_824AE660(ctx, base);
	// 8261E7F0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261E7F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261E7F8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261E7FC: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261E800: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8261E804: 4BB78C6D  bl 0x82197470
	ctx.lr = 0x8261E808;
	sub_82197470(ctx, base);
	// 8261E808: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8261E80C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261E810: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261E814: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8261E818: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261E81C: 890A0015  lbz r8, 0x15(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 8261E820: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8261E824: 409A0068  bne cr6, 0x8261e88c
	if !ctx.cr[6].eq {
	pc = 0x8261E88C; continue 'dispatch;
	}
	// 8261E828: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261E82C: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8261E830: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8261E834: 409A0018  bne cr6, 0x8261e84c
	if !ctx.cr[6].eq {
	pc = 0x8261E84C; continue 'dispatch;
	}
	pc = 0x8261E838; continue 'dispatch;
            }
            0x8261E838 => {
    //   block [0x8261E838..0x8261E84C)
	// 8261E838: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8261E83C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261E840: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8261E844: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8261E848: 419AFFF0  beq cr6, 0x8261e838
	if ctx.cr[6].eq {
	pc = 0x8261E838; continue 'dispatch;
	}
	pc = 0x8261E84C; continue 'dispatch;
            }
            0x8261E84C => {
    //   block [0x8261E84C..0x8261E868)
	// 8261E84C: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8261E850: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261E854: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261E858: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261E85C: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8261E860: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8261E864: 409A0018  bne cr6, 0x8261e87c
	if !ctx.cr[6].eq {
	pc = 0x8261E87C; continue 'dispatch;
	}
	pc = 0x8261E868; continue 'dispatch;
            }
            0x8261E868 => {
    //   block [0x8261E868..0x8261E87C)
	// 8261E868: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8261E86C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8261E870: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8261E874: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8261E878: 419AFFF0  beq cr6, 0x8261e868
	if ctx.cr[6].eq {
	pc = 0x8261E868; continue 'dispatch;
	}
	pc = 0x8261E87C; continue 'dispatch;
            }
            0x8261E87C => {
    //   block [0x8261E87C..0x8261E88C)
	// 8261E87C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8261E880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261E884: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261E888: 4868ABD4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261E88C => {
    //   block [0x8261E88C..0x8261E8A4)
	// 8261E88C: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8261E890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261E894: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261E898: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8261E89C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261E8A0: 4868ABBC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E8A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8261E8A8 size=28
    let mut pc: u32 = 0x8261E8A8;
    'dispatch: loop {
        match pc {
            0x8261E8A8 => {
    //   block [0x8261E8A8..0x8261E8C4)
	// 8261E8A8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8261E8AC: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 8261E8B0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8261E8B4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261E8B8: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8261E8BC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8261E8C0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8261E8C8 size=20
    let mut pc: u32 = 0x8261E8C8;
    'dispatch: loop {
        match pc {
            0x8261E8C8 => {
    //   block [0x8261E8C8..0x8261E8DC)
	// 8261E8C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261E8CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8261E8D0: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8261E8D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261E8D8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8261E8E0 size=12
    let mut pc: u32 = 0x8261E8E0;
    'dispatch: loop {
        match pc {
            0x8261E8E0 => {
    //   block [0x8261E8E0..0x8261E8EC)
	// 8261E8E0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261E8E4: 386B95F8  addi r3, r11, -0x6a08
	ctx.r[3].s64 = ctx.r[11].s64 + -27144;
	// 8261E8E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261E8F0 size=88
    let mut pc: u32 = 0x8261E8F0;
    'dispatch: loop {
        match pc {
            0x8261E8F0 => {
    //   block [0x8261E8F0..0x8261E93C)
	// 8261E8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261E8F4: 4868AB19  bl 0x82ca940c
	ctx.lr = 0x8261E8F8;
	sub_82CA93D0(ctx, base);
	// 8261E8F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261E8FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261E900: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 8261E904: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8261E908: 4BFF8021  bl 0x82616928
	ctx.lr = 0x8261E90C;
	sub_82616928(ctx, base);
	// 8261E90C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261E910: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261E914: 419A0028  beq cr6, 0x8261e93c
	if ctx.cr[6].eq {
	pc = 0x8261E93C; continue 'dispatch;
	}
	// 8261E918: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8261E91C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8261E920: 48010E89  bl 0x8262f7a8
	ctx.lr = 0x8261E924;
	sub_8262F7A8(ctx, base);
	// 8261E924: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8261E928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261E92C: 394B62D0  addi r10, r11, 0x62d0
	ctx.r[10].s64 = ctx.r[11].s64 + 25296;
	// 8261E930: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8261E934: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261E938: 4868AB24  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261E93C => {
    //   block [0x8261E93C..0x8261E948)
	// 8261E93C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8261E940: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261E944: 4868AB18  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261E948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261E948 size=1360
    let mut pc: u32 = 0x8261E948;
    'dispatch: loop {
        match pc {
            0x8261E948 => {
    //   block [0x8261E948..0x8261E9A8)
	// 8261E948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261E94C: 4868AAAD  bl 0x82ca93f8
	ctx.lr = 0x8261E950;
	sub_82CA93D0(ctx, base);
	// 8261E950: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261E954: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261E958: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261E95C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8261E960: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 8261E964: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8261E968: 388B8D14  addi r4, r11, -0x72ec
	ctx.r[4].s64 = ctx.r[11].s64 + -29420;
	// 8261E96C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261E970: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 8261E974: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 8261E978: 4BBE1DF9  bl 0x82200770
	ctx.lr = 0x8261E97C;
	sub_82200770(ctx, base);
	// 8261E97C: 817B0078  lwz r11, 0x78(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(120 as u32) ) } as u64;
	// 8261E980: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8261E984: 387B0074  addi r3, r27, 0x74
	ctx.r[3].s64 = ctx.r[27].s64 + 116;
	// 8261E988: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 8261E98C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261E990: 419A001C  beq cr6, 0x8261e9ac
	if ctx.cr[6].eq {
	pc = 0x8261E9AC; continue 'dispatch;
	}
	// 8261E994: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261E998: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261E99C: 419A000C  beq cr6, 0x8261e9a8
	if ctx.cr[6].eq {
	pc = 0x8261E9A8; continue 'dispatch;
	}
	// 8261E9A0: 555E003E  slwi r30, r10, 0
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 8261E9A4: 4800000C  b 0x8261e9b0
	pc = 0x8261E9B0; continue 'dispatch;
            }
            0x8261E9A8 => {
    //   block [0x8261E9A8..0x8261E9AC)
	// 8261E9A8: 4BB75491  bl 0x82193e38
	ctx.lr = 0x8261E9AC;
	sub_82193E38(ctx, base);
	pc = 0x8261E9AC; continue 'dispatch;
            }
            0x8261E9AC => {
    //   block [0x8261E9AC..0x8261E9B0)
	// 8261E9AC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x8261E9B0; continue 'dispatch;
            }
            0x8261E9B0 => {
    //   block [0x8261E9B0..0x8261E9F4)
	// 8261E9B0: 3BFF0088  addi r31, r31, 0x88
	ctx.r[31].s64 = ctx.r[31].s64 + 136;
	// 8261E9B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261E9B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261E9BC: 419A0038  beq cr6, 0x8261e9f4
	if ctx.cr[6].eq {
	pc = 0x8261E9F4; continue 'dispatch;
	}
	// 8261E9C0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261E9C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261E9C8: 419A00AC  beq cr6, 0x8261ea74
	if ctx.cr[6].eq {
	pc = 0x8261EA74; continue 'dispatch;
	}
	// 8261E9CC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261E9D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261E9D4: 419A0020  beq cr6, 0x8261e9f4
	if ctx.cr[6].eq {
	pc = 0x8261E9F4; continue 'dispatch;
	}
	// 8261E9D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261E9DC: 4BB5545D  bl 0x82173e38
	ctx.lr = 0x8261E9E0;
	sub_82173E38(ctx, base);
	// 8261E9E0: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8261E9E4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8261E9E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261E9EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261E9F0: 409A0008  bne cr6, 0x8261e9f8
	if !ctx.cr[6].eq {
	pc = 0x8261E9F8; continue 'dispatch;
	}
	pc = 0x8261E9F4; continue 'dispatch;
            }
            0x8261E9F4 => {
    //   block [0x8261E9F4..0x8261E9F8)
	// 8261E9F4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8261E9F8; continue 'dispatch;
            }
            0x8261E9F8 => {
    //   block [0x8261E9F8..0x8261EA20)
	// 8261E9F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261E9FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EA00: 419A0478  beq cr6, 0x8261ee78
	if ctx.cr[6].eq {
	pc = 0x8261EE78; continue 'dispatch;
	}
	// 8261EA04: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261EA08: 419A0018  beq cr6, 0x8261ea20
	if ctx.cr[6].eq {
	pc = 0x8261EA20; continue 'dispatch;
	}
	// 8261EA0C: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 8261EA10: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8261EA14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261EA18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261EA1C: 409A0008  bne cr6, 0x8261ea24
	if !ctx.cr[6].eq {
	pc = 0x8261EA24; continue 'dispatch;
	}
	pc = 0x8261EA20; continue 'dispatch;
            }
            0x8261EA20 => {
    //   block [0x8261EA20..0x8261EA24)
	// 8261EA20: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8261EA24; continue 'dispatch;
            }
            0x8261EA24 => {
    //   block [0x8261EA24..0x8261EA74)
	// 8261EA24: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261EA28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EA2C: 419A044C  beq cr6, 0x8261ee78
	if ctx.cr[6].eq {
	pc = 0x8261EE78; continue 'dispatch;
	}
	// 8261EA30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261EA34: 4BB55405  bl 0x82173e38
	ctx.lr = 0x8261EA38;
	sub_82173E38(ctx, base);
	// 8261EA38: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 8261EA3C: 556AA7FE  rlwinm r10, r11, 0x14, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 8261EA40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261EA44: 419A0100  beq cr6, 0x8261eb44
	if ctx.cr[6].eq {
	pc = 0x8261EB44; continue 'dispatch;
	}
	// 8261EA48: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261EA4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EA50: 419A0030  beq cr6, 0x8261ea80
	if ctx.cr[6].eq {
	pc = 0x8261EA80; continue 'dispatch;
	}
	// 8261EA54: 894B004C  lbz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261EA58: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261EA5C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8261EA60: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261EA64: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261EA68: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8261EA6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261EA70: 480000D8  b 0x8261eb48
	pc = 0x8261EB48; continue 'dispatch;
            }
            0x8261EA74 => {
    //   block [0x8261EA74..0x8261EA80)
	// 8261EA74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261EA78: 4BB753C1  bl 0x82193e38
	ctx.lr = 0x8261EA7C;
	sub_82193E38(ctx, base);
	// 8261EA7C: 4BFFFF78  b 0x8261e9f4
	pc = 0x8261E9F4; continue 'dispatch;
            }
            0x8261EA80 => {
    //   block [0x8261EA80..0x8261EA9C)
	// 8261EA80: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261EA84: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261EA88: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8261EA8C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8261EA90: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8261EA94: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261EA98: 40810054  ble 0x8261eaec
	if !ctx.cr[0].gt {
	pc = 0x8261EAEC; continue 'dispatch;
	}
	pc = 0x8261EA9C; continue 'dispatch;
            }
            0x8261EA9C => {
    //   block [0x8261EA9C..0x8261EABC)
	// 8261EA9C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261EAA0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261EAA4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8261EAA8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261EAAC: 2F07004C  cmpwi cr6, r7, 0x4c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 76, &mut ctx.xer);
	// 8261EAB0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8261EAB4: 41980008  blt cr6, 0x8261eabc
	if ctx.cr[6].lt {
	pc = 0x8261EABC; continue 'dispatch;
	}
	// 8261EAB8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8261EABC; continue 'dispatch;
            }
            0x8261EABC => {
    //   block [0x8261EABC..0x8261EAD8)
	// 8261EABC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8261EAC0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261EAC4: 419A0014  beq cr6, 0x8261ead8
	if ctx.cr[6].eq {
	pc = 0x8261EAD8; continue 'dispatch;
	}
	// 8261EAC8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261EACC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8261EAD0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8261EAD4: 4800000C  b 0x8261eae0
	pc = 0x8261EAE0; continue 'dispatch;
            }
            0x8261EAD8 => {
    //   block [0x8261EAD8..0x8261EAE0)
	// 8261EAD8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261EADC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8261EAE0; continue 'dispatch;
            }
            0x8261EAE0 => {
    //   block [0x8261EAE0..0x8261EAEC)
	// 8261EAE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261EAE4: 4199FFB8  bgt cr6, 0x8261ea9c
	if ctx.cr[6].gt {
	pc = 0x8261EA9C; continue 'dispatch;
	}
	// 8261EAE8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8261EAEC; continue 'dispatch;
            }
            0x8261EAEC => {
    //   block [0x8261EAEC..0x8261EB08)
	// 8261EAEC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8261EAF0: 419A0040  beq cr6, 0x8261eb30
	if ctx.cr[6].eq {
	pc = 0x8261EB30; continue 'dispatch;
	}
	// 8261EAF4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261EAF8: 2F0B004C  cmpwi cr6, r11, 0x4c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 76, &mut ctx.xer);
	// 8261EAFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261EB00: 41990008  bgt cr6, 0x8261eb08
	if ctx.cr[6].gt {
	pc = 0x8261EB08; continue 'dispatch;
	}
	// 8261EB04: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8261EB08; continue 'dispatch;
            }
            0x8261EB08 => {
    //   block [0x8261EB08..0x8261EB30)
	// 8261EB08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261EB0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EB10: 409A0020  bne cr6, 0x8261eb30
	if !ctx.cr[6].eq {
	pc = 0x8261EB30; continue 'dispatch;
	}
	// 8261EB14: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261EB18: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8261EB1C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8261EB20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261EB24: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8261EB28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261EB2C: 4800001C  b 0x8261eb48
	pc = 0x8261EB48; continue 'dispatch;
            }
            0x8261EB30 => {
    //   block [0x8261EB30..0x8261EB44)
	// 8261EB30: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8261EB34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261EB38: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8261EB3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261EB40: 48000008  b 0x8261eb48
	pc = 0x8261EB48; continue 'dispatch;
            }
            0x8261EB44 => {
    //   block [0x8261EB44..0x8261EB48)
	// 8261EB44: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8261EB48; continue 'dispatch;
            }
            0x8261EB48 => {
    //   block [0x8261EB48..0x8261EB74)
	// 8261EB48: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261EB4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EB50: 419A0328  beq cr6, 0x8261ee78
	if ctx.cr[6].eq {
	pc = 0x8261EE78; continue 'dispatch;
	}
	// 8261EB54: 897D0021  lbz r11, 0x21(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(33 as u32) ) } as u64;
	// 8261EB58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EB5C: 419A0018  beq cr6, 0x8261eb74
	if ctx.cr[6].eq {
	pc = 0x8261EB74; continue 'dispatch;
	}
	// 8261EB60: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 8261EB64: 895D0020  lbz r10, 0x20(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 8261EB68: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8261EB6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261EB70: 419A0008  beq cr6, 0x8261eb78
	if ctx.cr[6].eq {
	pc = 0x8261EB78; continue 'dispatch;
	}
	pc = 0x8261EB74; continue 'dispatch;
            }
            0x8261EB74 => {
    //   block [0x8261EB74..0x8261EB78)
	// 8261EB74: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8261EB78; continue 'dispatch;
            }
            0x8261EB78 => {
    //   block [0x8261EB78..0x8261EB9C)
	// 8261EB78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261EB7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EB80: 419A001C  beq cr6, 0x8261eb9c
	if ctx.cr[6].eq {
	pc = 0x8261EB9C; continue 'dispatch;
	}
	// 8261EB84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8261EB88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261EB8C: 4BF635D5  bl 0x82582160
	ctx.lr = 0x8261EB90;
	sub_82582160(ctx, base);
	// 8261EB90: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261EB94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EB98: 419A02E0  beq cr6, 0x8261ee78
	if ctx.cr[6].eq {
	pc = 0x8261EE78; continue 'dispatch;
	}
	pc = 0x8261EB9C; continue 'dispatch;
            }
            0x8261EB9C => {
    //   block [0x8261EB9C..0x8261EBDC)
	// 8261EB9C: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 8261EBA0: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 8261EBA4: 556AF7FE  rlwinm r10, r11, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 8261EBA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261EBAC: 419A00F4  beq cr6, 0x8261eca0
	if ctx.cr[6].eq {
	pc = 0x8261ECA0; continue 'dispatch;
	}
	// 8261EBB0: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261EBB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EBB8: 419A0024  beq cr6, 0x8261ebdc
	if ctx.cr[6].eq {
	pc = 0x8261EBDC; continue 'dispatch;
	}
	// 8261EBBC: 894B00A2  lbz r10, 0xa2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(162 as u32) ) } as u64;
	// 8261EBC0: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261EBC4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8261EBC8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261EBCC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261EBD0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8261EBD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261EBD8: 480000CC  b 0x8261eca4
	pc = 0x8261ECA4; continue 'dispatch;
            }
            0x8261EBDC => {
    //   block [0x8261EBDC..0x8261EBF8)
	// 8261EBDC: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261EBE0: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261EBE4: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8261EBE8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8261EBEC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8261EBF0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261EBF4: 40810054  ble 0x8261ec48
	if !ctx.cr[0].gt {
	pc = 0x8261EC48; continue 'dispatch;
	}
	pc = 0x8261EBF8; continue 'dispatch;
            }
            0x8261EBF8 => {
    //   block [0x8261EBF8..0x8261EC18)
	// 8261EBF8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261EBFC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261EC00: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8261EC04: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261EC08: 2F0700A2  cmpwi cr6, r7, 0xa2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 162, &mut ctx.xer);
	// 8261EC0C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8261EC10: 41980008  blt cr6, 0x8261ec18
	if ctx.cr[6].lt {
	pc = 0x8261EC18; continue 'dispatch;
	}
	// 8261EC14: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8261EC18; continue 'dispatch;
            }
            0x8261EC18 => {
    //   block [0x8261EC18..0x8261EC34)
	// 8261EC18: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8261EC1C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261EC20: 419A0014  beq cr6, 0x8261ec34
	if ctx.cr[6].eq {
	pc = 0x8261EC34; continue 'dispatch;
	}
	// 8261EC24: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261EC28: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8261EC2C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8261EC30: 4800000C  b 0x8261ec3c
	pc = 0x8261EC3C; continue 'dispatch;
            }
            0x8261EC34 => {
    //   block [0x8261EC34..0x8261EC3C)
	// 8261EC34: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261EC38: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8261EC3C; continue 'dispatch;
            }
            0x8261EC3C => {
    //   block [0x8261EC3C..0x8261EC48)
	// 8261EC3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261EC40: 4199FFB8  bgt cr6, 0x8261ebf8
	if ctx.cr[6].gt {
	pc = 0x8261EBF8; continue 'dispatch;
	}
	// 8261EC44: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8261EC48; continue 'dispatch;
            }
            0x8261EC48 => {
    //   block [0x8261EC48..0x8261EC64)
	// 8261EC48: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8261EC4C: 419A0040  beq cr6, 0x8261ec8c
	if ctx.cr[6].eq {
	pc = 0x8261EC8C; continue 'dispatch;
	}
	// 8261EC50: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261EC54: 2F0B00A2  cmpwi cr6, r11, 0xa2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 162, &mut ctx.xer);
	// 8261EC58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261EC5C: 41990008  bgt cr6, 0x8261ec64
	if ctx.cr[6].gt {
	pc = 0x8261EC64; continue 'dispatch;
	}
	// 8261EC60: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8261EC64; continue 'dispatch;
            }
            0x8261EC64 => {
    //   block [0x8261EC64..0x8261EC8C)
	// 8261EC64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261EC68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EC6C: 409A0020  bne cr6, 0x8261ec8c
	if !ctx.cr[6].eq {
	pc = 0x8261EC8C; continue 'dispatch;
	}
	// 8261EC70: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261EC74: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8261EC78: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8261EC7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261EC80: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8261EC84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261EC88: 4800001C  b 0x8261eca4
	pc = 0x8261ECA4; continue 'dispatch;
            }
            0x8261EC8C => {
    //   block [0x8261EC8C..0x8261ECA0)
	// 8261EC8C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8261EC90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261EC94: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8261EC98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261EC9C: 48000008  b 0x8261eca4
	pc = 0x8261ECA4; continue 'dispatch;
            }
            0x8261ECA0 => {
    //   block [0x8261ECA0..0x8261ECA4)
	// 8261ECA0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8261ECA4; continue 'dispatch;
            }
            0x8261ECA4 => {
    //   block [0x8261ECA4..0x8261ECCC)
	// 8261ECA4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261ECA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261ECAC: 419A0038  beq cr6, 0x8261ece4
	if ctx.cr[6].eq {
	pc = 0x8261ECE4; continue 'dispatch;
	}
	// 8261ECB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261ECB4: 4BF6404D  bl 0x82582d00
	ctx.lr = 0x8261ECB8;
	sub_82582D00(ctx, base);
	// 8261ECB8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261ECBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261ECC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261ECC4: 419A0008  beq cr6, 0x8261eccc
	if ctx.cr[6].eq {
	pc = 0x8261ECCC; continue 'dispatch;
	}
	// 8261ECC8: 897D0022  lbz r11, 0x22(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(34 as u32) ) } as u64;
	pc = 0x8261ECCC; continue 'dispatch;
            }
            0x8261ECCC => {
    //   block [0x8261ECCC..0x8261ECE4)
	// 8261ECCC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261ECD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261ECD4: 419A0010  beq cr6, 0x8261ece4
	if ctx.cr[6].eq {
	pc = 0x8261ECE4; continue 'dispatch;
	}
	// 8261ECD8: 897F0154  lbz r11, 0x154(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 8261ECDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261ECE0: 419A0198  beq cr6, 0x8261ee78
	if ctx.cr[6].eq {
	pc = 0x8261EE78; continue 'dispatch;
	}
	pc = 0x8261ECE4; continue 'dispatch;
            }
            0x8261ECE4 => {
    //   block [0x8261ECE4..0x8261ED0C)
	// 8261ECE4: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8261ECE8: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8261ECEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261ECF0: 419A001C  beq cr6, 0x8261ed0c
	if ctx.cr[6].eq {
	pc = 0x8261ED0C; continue 'dispatch;
	}
	// 8261ECF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8261ECF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261ECFC: 4BF63465  bl 0x82582160
	ctx.lr = 0x8261ED00;
	sub_82582160(ctx, base);
	// 8261ED00: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261ED04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261ED08: 419A0170  beq cr6, 0x8261ee78
	if ctx.cr[6].eq {
	pc = 0x8261EE78; continue 'dispatch;
	}
	pc = 0x8261ED0C; continue 'dispatch;
            }
            0x8261ED0C => {
    //   block [0x8261ED0C..0x8261ED48)
	// 8261ED0C: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 8261ED10: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 8261ED14: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 8261ED18: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261ED1C: 419A00E4  beq cr6, 0x8261ee00
	if ctx.cr[6].eq {
	pc = 0x8261EE00; continue 'dispatch;
	}
	// 8261ED20: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261ED24: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261ED28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261ED2C: 419A001C  beq cr6, 0x8261ed48
	if ctx.cr[6].eq {
	pc = 0x8261ED48; continue 'dispatch;
	}
	// 8261ED30: 896B003C  lbz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 8261ED34: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8261ED38: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8261ED3C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261ED40: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261ED44: 480000C0  b 0x8261ee04
	pc = 0x8261EE04; continue 'dispatch;
            }
            0x8261ED48 => {
    //   block [0x8261ED48..0x8261ED60)
	// 8261ED48: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261ED4C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8261ED50: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8261ED54: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8261ED58: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261ED5C: 40810054  ble 0x8261edb0
	if !ctx.cr[0].gt {
	pc = 0x8261EDB0; continue 'dispatch;
	}
	pc = 0x8261ED60; continue 'dispatch;
            }
            0x8261ED60 => {
    //   block [0x8261ED60..0x8261ED80)
	// 8261ED60: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261ED64: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261ED68: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8261ED6C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261ED70: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 8261ED74: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8261ED78: 41980008  blt cr6, 0x8261ed80
	if ctx.cr[6].lt {
	pc = 0x8261ED80; continue 'dispatch;
	}
	// 8261ED7C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8261ED80; continue 'dispatch;
            }
            0x8261ED80 => {
    //   block [0x8261ED80..0x8261ED9C)
	// 8261ED80: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8261ED84: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261ED88: 419A0014  beq cr6, 0x8261ed9c
	if ctx.cr[6].eq {
	pc = 0x8261ED9C; continue 'dispatch;
	}
	// 8261ED8C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261ED90: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8261ED94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8261ED98: 4800000C  b 0x8261eda4
	pc = 0x8261EDA4; continue 'dispatch;
            }
            0x8261ED9C => {
    //   block [0x8261ED9C..0x8261EDA4)
	// 8261ED9C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261EDA0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8261EDA4; continue 'dispatch;
            }
            0x8261EDA4 => {
    //   block [0x8261EDA4..0x8261EDB0)
	// 8261EDA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261EDA8: 4199FFB8  bgt cr6, 0x8261ed60
	if ctx.cr[6].gt {
	pc = 0x8261ED60; continue 'dispatch;
	}
	// 8261EDAC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8261EDB0; continue 'dispatch;
            }
            0x8261EDB0 => {
    //   block [0x8261EDB0..0x8261EDCC)
	// 8261EDB0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8261EDB4: 419A003C  beq cr6, 0x8261edf0
	if ctx.cr[6].eq {
	pc = 0x8261EDF0; continue 'dispatch;
	}
	// 8261EDB8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261EDBC: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 8261EDC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261EDC4: 41990008  bgt cr6, 0x8261edcc
	if ctx.cr[6].gt {
	pc = 0x8261EDCC; continue 'dispatch;
	}
	// 8261EDC8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8261EDCC; continue 'dispatch;
            }
            0x8261EDCC => {
    //   block [0x8261EDCC..0x8261EDF0)
	// 8261EDCC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261EDD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EDD4: 409A001C  bne cr6, 0x8261edf0
	if !ctx.cr[6].eq {
	pc = 0x8261EDF0; continue 'dispatch;
	}
	// 8261EDD8: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261EDDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261EDE0: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8261EDE4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8261EDE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261EDEC: 48000018  b 0x8261ee04
	pc = 0x8261EE04; continue 'dispatch;
            }
            0x8261EDF0 => {
    //   block [0x8261EDF0..0x8261EE00)
	// 8261EDF0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8261EDF4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8261EDF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261EDFC: 48000008  b 0x8261ee04
	pc = 0x8261EE04; continue 'dispatch;
            }
            0x8261EE00 => {
    //   block [0x8261EE00..0x8261EE04)
	// 8261EE00: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x8261EE04; continue 'dispatch;
            }
            0x8261EE04 => {
    //   block [0x8261EE04..0x8261EE34)
	// 8261EE04: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8261EE08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261EE0C: 419A0028  beq cr6, 0x8261ee34
	if ctx.cr[6].eq {
	pc = 0x8261EE34; continue 'dispatch;
	}
	// 8261EE10: 896B0284  lbz r11, 0x284(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(644 as u32) ) } as u64;
	// 8261EE14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EE18: 409A001C  bne cr6, 0x8261ee34
	if !ctx.cr[6].eq {
	pc = 0x8261EE34; continue 'dispatch;
	}
	// 8261EE1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8261EE20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261EE24: 4BF6333D  bl 0x82582160
	ctx.lr = 0x8261EE28;
	sub_82582160(ctx, base);
	// 8261EE28: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261EE2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EE30: 419A0048  beq cr6, 0x8261ee78
	if ctx.cr[6].eq {
	pc = 0x8261EE78; continue 'dispatch;
	}
	pc = 0x8261EE34; continue 'dispatch;
            }
            0x8261EE34 => {
    //   block [0x8261EE34..0x8261EE6C)
	// 8261EE34: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261EE38: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 8261EE3C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 8261EE40: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8261EE44: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8261EE48: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8261EE4C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8261EE50: 4E800421  bctrl
	ctx.lr = 0x8261EE54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8261EE54: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261EE58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261EE5C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8261EE60: 419A000C  beq cr6, 0x8261ee6c
	if ctx.cr[6].eq {
	pc = 0x8261EE6C; continue 'dispatch;
	}
	// 8261EE64: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261EE68: 48C9AAED  bl 0x832b9954
	ctx.lr = 0x8261EE6C;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
            }
            0x8261EE6C => {
    //   block [0x8261EE6C..0x8261EE78)
	// 8261EE6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261EE70: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8261EE74: 4868A5D4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261EE78 => {
    //   block [0x8261EE78..0x8261EE8C)
	// 8261EE78: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261EE7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261EE80: 419A000C  beq cr6, 0x8261ee8c
	if ctx.cr[6].eq {
	pc = 0x8261EE8C; continue 'dispatch;
	}
	// 8261EE84: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261EE88: 48C9AACD  bl 0x832b9954
	ctx.lr = 0x8261EE8C;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x8261EE8C; continue 'dispatch;
            }
            0x8261EE8C => {
    //   block [0x8261EE8C..0x8261EE98)
	// 8261EE8C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8261EE90: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8261EE94: 4868A5B4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261EE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8261EE98 size=440
    let mut pc: u32 = 0x8261EE98;
    'dispatch: loop {
        match pc {
            0x8261EE98 => {
    //   block [0x8261EE98..0x8261EF0C)
	// 8261EE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261EE9C: 4868A569  bl 0x82ca9404
	ctx.lr = 0x8261EEA0;
	sub_82CA93D0(ctx, base);
	// 8261EEA0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8261EEA4: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261EEA8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261EEAC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8261EEB0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8261EEB4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8261EEB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8261EEBC: 388B8D14  addi r4, r11, -0x72ec
	ctx.r[4].s64 = ctx.r[11].s64 + -29420;
	// 8261EEC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261EEC4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 8261EEC8: 4BBE18A9  bl 0x82200770
	ctx.lr = 0x8261EECC;
	sub_82200770(ctx, base);
	// 8261EECC: 817B0078  lwz r11, 0x78(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(120 as u32) ) } as u64;
	// 8261EED0: 387B0074  addi r3, r27, 0x74
	ctx.r[3].s64 = ctx.r[27].s64 + 116;
	// 8261EED4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8261EED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EEDC: 419A0068  beq cr6, 0x8261ef44
	if ctx.cr[6].eq {
	pc = 0x8261EF44; continue 'dispatch;
	}
	// 8261EEE0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261EEE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261EEE8: 419A0058  beq cr6, 0x8261ef40
	if ctx.cr[6].eq {
	pc = 0x8261EF40; continue 'dispatch;
	}
	// 8261EEEC: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8261EEF0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8261EEF4: 419A0018  beq cr6, 0x8261ef0c
	if ctx.cr[6].eq {
	pc = 0x8261EF0C; continue 'dispatch;
	}
	// 8261EEF8: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 8261EEFC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8261EF00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261EF04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261EF08: 409A0008  bne cr6, 0x8261ef10
	if !ctx.cr[6].eq {
	pc = 0x8261EF10; continue 'dispatch;
	}
	pc = 0x8261EF0C; continue 'dispatch;
            }
            0x8261EF0C => {
    //   block [0x8261EF0C..0x8261EF10)
	// 8261EF0C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8261EF10; continue 'dispatch;
            }
            0x8261EF10 => {
    //   block [0x8261EF10..0x8261EF1C)
	// 8261EF10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261EF14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EF18: 409A0034  bne cr6, 0x8261ef4c
	if !ctx.cr[6].eq {
	pc = 0x8261EF4C; continue 'dispatch;
	}
	pc = 0x8261EF1C; continue 'dispatch;
            }
            0x8261EF1C => {
    //   block [0x8261EF1C..0x8261EF30)
	// 8261EF1C: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261EF20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261EF24: 419A000C  beq cr6, 0x8261ef30
	if ctx.cr[6].eq {
	pc = 0x8261EF30; continue 'dispatch;
	}
	// 8261EF28: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261EF2C: 48C9AA29  bl 0x832b9954
	ctx.lr = 0x8261EF30;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x8261EF30; continue 'dispatch;
            }
            0x8261EF30 => {
    //   block [0x8261EF30..0x8261EF40)
	// 8261EF30: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8261EF34: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 8261EF38: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8261EF3C: 4868A518  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261EF40 => {
    //   block [0x8261EF40..0x8261EF44)
	// 8261EF40: 4BB74EF9  bl 0x82193e38
	ctx.lr = 0x8261EF44;
	sub_82193E38(ctx, base);
	pc = 0x8261EF44; continue 'dispatch;
            }
            0x8261EF44 => {
    //   block [0x8261EF44..0x8261EF4C)
	// 8261EF44: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8261EF48: 4BFFFFC4  b 0x8261ef0c
	pc = 0x8261EF0C; continue 'dispatch;
            }
            0x8261EF4C => {
    //   block [0x8261EF4C..0x8261EF88)
	// 8261EF4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261EF50: 48000AB1  bl 0x8261fa00
	ctx.lr = 0x8261EF54;
	sub_8261FA00(ctx, base);
	// 8261EF54: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261EF58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261EF5C: 419AFFC0  beq cr6, 0x8261ef1c
	if ctx.cr[6].eq {
	pc = 0x8261EF1C; continue 'dispatch;
	}
	// 8261EF60: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8261EF64: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 8261EF68: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8261EF6C: 388AC5C8  addi r4, r10, -0x3a38
	ctx.r[4].s64 = ctx.r[10].s64 + -14904;
	// 8261EF70: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8261EF74: C3EB9484  lfs f31, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8261EF78: 4BBC9701  bl 0x821e8678
	ctx.lr = 0x8261EF7C;
	sub_821E8678(ctx, base);
	// 8261EF7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261EF80: 419A0008  beq cr6, 0x8261ef88
	if ctx.cr[6].eq {
	pc = 0x8261EF88; continue 'dispatch;
	}
	// 8261EF84: C3E30004  lfs f31, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x8261EF88; continue 'dispatch;
            }
            0x8261EF88 => {
    //   block [0x8261EF88..0x8261EFBC)
	// 8261EF88: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8261EF8C: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8261EF90: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8261EF94: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 8261EF98: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 8261EF9C: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8261EFA0: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8261EFA4: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 8261EFA8: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8261EFAC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8261EFB0: D181006C  stfs f12, 0x6c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8261EFB4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8261EFB8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8261EFBC; continue 'dispatch;
            }
            0x8261EFBC => {
    //   block [0x8261EFBC..0x8261EFF8)
	// 8261EFBC: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8261EFC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8261EFC4: 4200FFF8  bdnz 0x8261efbc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8261EFBC; continue 'dispatch;
	}
	// 8261EFC8: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8261EFCC: 914100C0  stw r10, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[10].u32 ) };
	// 8261EFD0: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8261EFD4: 9B8100B8  stb r28, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[28].u8 ) };
	// 8261EFD8: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8261EFDC: 396100D0  addi r11, r1, 0xd0
	ctx.r[11].s64 = ctx.r[1].s64 + 208;
	// 8261EFE0: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8261EFE4: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 8261EFE8: D1A100C8  stfs f13, 0xc8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8261EFEC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 8261EFF0: D18100CC  stfs f12, 0xcc(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 8261EFF4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x8261EFF8; continue 'dispatch;
            }
            0x8261EFF8 => {
    //   block [0x8261EFF8..0x8261F040)
	// 8261EFF8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8261EFFC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8261F000: 4200FFF8  bdnz 0x8261eff8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8261EFF8; continue 'dispatch;
	}
	// 8261F004: 9B810118  stb r28, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[28].u8 ) };
	// 8261F008: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8261F00C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 8261F010: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8261F014: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8261F018: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8261F01C: 4BC5F8BD  bl 0x8227e8d8
	ctx.lr = 0x8261F020;
	sub_8227E8D8(ctx, base);
	// 8261F020: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261F024: 89210054  lbz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261F028: 7D480034  cntlzw r8, r10
	ctx.r[8].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 8261F02C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8261F030: 551FDFFE  rlwinm r31, r8, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 8261F034: 419A000C  beq cr6, 0x8261f040
	if ctx.cr[6].eq {
	pc = 0x8261F040; continue 'dispatch;
	}
	// 8261F038: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261F03C: 48C9A919  bl 0x832b9954
	ctx.lr = 0x8261F040;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x8261F040; continue 'dispatch;
            }
            0x8261F040 => {
    //   block [0x8261F040..0x8261F050)
	// 8261F040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261F044: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 8261F048: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8261F04C: 4868A408  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261F050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261F050 size=2480
    let mut pc: u32 = 0x8261F050;
    'dispatch: loop {
        match pc {
            0x8261F050 => {
    //   block [0x8261F050..0x8261F0DC)
	// 8261F050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261F054: 4868A391  bl 0x82ca93e4
	ctx.lr = 0x8261F058;
	sub_82CA93D0(ctx, base);
	// 8261F058: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 8261F05C: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 8261F060: 489E7975  bl 0x830069d4
	ctx.lr = 0x8261F064;
	sub_83006760(ctx, base);
	// 8261F064: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261F068: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261F06C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8261F070: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 8261F074: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8261F078: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8261F07C: 388B8D14  addi r4, r11, -0x72ec
	ctx.r[4].s64 = ctx.r[11].s64 + -29420;
	// 8261F080: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8261F084: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
	// 8261F088: 7D134378  mr r19, r8
	ctx.r[19].u64 = ctx.r[8].u64;
	// 8261F08C: 4BBE16E5  bl 0x82200770
	ctx.lr = 0x8261F090;
	sub_82200770(ctx, base);
	// 8261F090: 8179008C  lwz r11, 0x8c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261F094: 3AB90088  addi r21, r25, 0x88
	ctx.r[21].s64 = ctx.r[25].s64 + 136;
	// 8261F098: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 8261F09C: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 8261F0A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261F0A4: 419A0038  beq cr6, 0x8261f0dc
	if ctx.cr[6].eq {
	pc = 0x8261F0DC; continue 'dispatch;
	}
	// 8261F0A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261F0AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261F0B0: 419A0084  beq cr6, 0x8261f134
	if ctx.cr[6].eq {
	pc = 0x8261F134; continue 'dispatch;
	}
	// 8261F0B4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261F0B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261F0BC: 419A0020  beq cr6, 0x8261f0dc
	if ctx.cr[6].eq {
	pc = 0x8261F0DC; continue 'dispatch;
	}
	// 8261F0C0: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 8261F0C4: 4BB54D75  bl 0x82173e38
	ctx.lr = 0x8261F0C8;
	sub_82173E38(ctx, base);
	// 8261F0C8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8261F0CC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8261F0D0: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 8261F0D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261F0D8: 409A0008  bne cr6, 0x8261f0e0
	if !ctx.cr[6].eq {
	pc = 0x8261F0E0; continue 'dispatch;
	}
	pc = 0x8261F0DC; continue 'dispatch;
            }
            0x8261F0DC => {
    //   block [0x8261F0DC..0x8261F0E0)
	// 8261F0DC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x8261F0E0; continue 'dispatch;
            }
            0x8261F0E0 => {
    //   block [0x8261F0E0..0x8261F134)
	// 8261F0E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261F0E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261F0E8: 419A08EC  beq cr6, 0x8261f9d4
	if ctx.cr[6].eq {
	pc = 0x8261F9D4; continue 'dispatch;
	}
	// 8261F0EC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 8261F0F0: 7F1AC378  mr r26, r24
	ctx.r[26].u64 = ctx.r[24].u64;
	// 8261F0F4: 4BB54D45  bl 0x82173e38
	ctx.lr = 0x8261F0F8;
	sub_82173E38(ctx, base);
	// 8261F0F8: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 8261F0FC: 556AA7FE  rlwinm r10, r11, 0x14, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 8261F100: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261F104: 419A0100  beq cr6, 0x8261f204
	if ctx.cr[6].eq {
	pc = 0x8261F204; continue 'dispatch;
	}
	// 8261F108: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261F10C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261F110: 419A0030  beq cr6, 0x8261f140
	if ctx.cr[6].eq {
	pc = 0x8261F140; continue 'dispatch;
	}
	// 8261F114: 894B004C  lbz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261F118: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261F11C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8261F120: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261F124: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261F128: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 8261F12C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 8261F130: 480000D8  b 0x8261f208
	pc = 0x8261F208; continue 'dispatch;
            }
            0x8261F134 => {
    //   block [0x8261F134..0x8261F140)
	// 8261F134: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 8261F138: 4BB74D01  bl 0x82193e38
	ctx.lr = 0x8261F13C;
	sub_82193E38(ctx, base);
	// 8261F13C: 4BFFFFA0  b 0x8261f0dc
	pc = 0x8261F0DC; continue 'dispatch;
            }
            0x8261F140 => {
    //   block [0x8261F140..0x8261F15C)
	// 8261F140: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261F144: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261F148: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 8261F14C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8261F150: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 8261F154: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261F158: 40810054  ble 0x8261f1ac
	if !ctx.cr[0].gt {
	pc = 0x8261F1AC; continue 'dispatch;
	}
	pc = 0x8261F15C; continue 'dispatch;
            }
            0x8261F15C => {
    //   block [0x8261F15C..0x8261F17C)
	// 8261F15C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261F160: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261F164: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8261F168: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261F16C: 2F07004C  cmpwi cr6, r7, 0x4c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 76, &mut ctx.xer);
	// 8261F170: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 8261F174: 41980008  blt cr6, 0x8261f17c
	if ctx.cr[6].lt {
	pc = 0x8261F17C; continue 'dispatch;
	}
	// 8261F178: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	pc = 0x8261F17C; continue 'dispatch;
            }
            0x8261F17C => {
    //   block [0x8261F17C..0x8261F198)
	// 8261F17C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8261F180: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261F184: 419A0014  beq cr6, 0x8261f198
	if ctx.cr[6].eq {
	pc = 0x8261F198; continue 'dispatch;
	}
	// 8261F188: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261F18C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8261F190: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8261F194: 4800000C  b 0x8261f1a0
	pc = 0x8261F1A0; continue 'dispatch;
            }
            0x8261F198 => {
    //   block [0x8261F198..0x8261F1A0)
	// 8261F198: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261F19C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8261F1A0; continue 'dispatch;
            }
            0x8261F1A0 => {
    //   block [0x8261F1A0..0x8261F1AC)
	// 8261F1A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261F1A4: 4199FFB8  bgt cr6, 0x8261f15c
	if ctx.cr[6].gt {
	pc = 0x8261F15C; continue 'dispatch;
	}
	// 8261F1A8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x8261F1AC; continue 'dispatch;
            }
            0x8261F1AC => {
    //   block [0x8261F1AC..0x8261F1C8)
	// 8261F1AC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8261F1B0: 419A0040  beq cr6, 0x8261f1f0
	if ctx.cr[6].eq {
	pc = 0x8261F1F0; continue 'dispatch;
	}
	// 8261F1B4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261F1B8: 2F0B004C  cmpwi cr6, r11, 0x4c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 76, &mut ctx.xer);
	// 8261F1BC: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 8261F1C0: 41990008  bgt cr6, 0x8261f1c8
	if ctx.cr[6].gt {
	pc = 0x8261F1C8; continue 'dispatch;
	}
	// 8261F1C4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x8261F1C8; continue 'dispatch;
            }
            0x8261F1C8 => {
    //   block [0x8261F1C8..0x8261F1F0)
	// 8261F1C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261F1CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261F1D0: 409A0020  bne cr6, 0x8261f1f0
	if !ctx.cr[6].eq {
	pc = 0x8261F1F0; continue 'dispatch;
	}
	// 8261F1D4: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8261F1D8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 8261F1DC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8261F1E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261F1E4: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 8261F1E8: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 8261F1EC: 4800001C  b 0x8261f208
	pc = 0x8261F208; continue 'dispatch;
            }
            0x8261F1F0 => {
    //   block [0x8261F1F0..0x8261F204)
	// 8261F1F0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8261F1F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261F1F8: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 8261F1FC: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 8261F200: 48000008  b 0x8261f208
	pc = 0x8261F208; continue 'dispatch;
            }
            0x8261F204 => {
    //   block [0x8261F204..0x8261F208)
	// 8261F204: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x8261F208; continue 'dispatch;
            }
            0x8261F208 => {
    //   block [0x8261F208..0x8261F700)
	// 8261F208: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261F20C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261F210: 419A04F0  beq cr6, 0x8261f700
	if ctx.cr[6].eq {
	pc = 0x8261F700; continue 'dispatch;
	}
	// 8261F214: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	pc = 0x8261F700; continue 'dispatch;
            }
            0x8261F700 => {
    //   block [0x8261F700..0x8261F9D4)
	// 8261F700: 89410074  lbz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8261F704: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261F708: 419A000C  beq cr6, 0x8261f714
	if ctx.cr[6].eq {
	pc = 0x8261F714; continue 'dispatch;
	}
	// 8261F70C: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8261F710: 48C9A245  bl 0x832b9954
	ctx.lr = 0x8261F714;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 8261F714: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8261F718: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 8261F71C: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 8261F720: 489E754D  bl 0x83006c6c
	ctx.lr = 0x8261F724;
	sub_830069F8(ctx, base);
	// 8261F724: CBE1FF88  lfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 8261F728: 48689D0C  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
	// 8261F72C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            0x8261F9D4 => {
    //   block [0x8261F9D4..0x8261FA00)
	// 8261F9D4: 89410074  lbz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8261F9D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261F9DC: 419A000C  beq cr6, 0x8261f9e8
	if ctx.cr[6].eq {
	pc = 0x8261F9E8; continue 'dispatch;
	}
	// 8261F9E0: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8261F9E4: 48C99F71  bl 0x832b9954
	ctx.lr = 0x8261F9E8;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 8261F9E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8261F9EC: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 8261F9F0: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 8261F9F4: 489E7279  bl 0x83006c6c
	ctx.lr = 0x8261F9F8;
	sub_830069F8(ctx, base);
	// 8261F9F8: CBE1FF88  lfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 8261F9FC: 48689A38  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261FA00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261FA00 size=528
    let mut pc: u32 = 0x8261FA00;
    'dispatch: loop {
        match pc {
            0x8261FA00 => {
    //   block [0x8261FA00..0x8261FA74)
	// 8261FA00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261FA04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261FA08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8261FA0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261FA10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261FA14: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261FA18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261FA1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8261FA20: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8261FA24: 388B8D14  addi r4, r11, -0x72ec
	ctx.r[4].s64 = ctx.r[11].s64 + -29420;
	// 8261FA28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261FA2C: 4BBE0D45  bl 0x82200770
	ctx.lr = 0x8261FA30;
	sub_82200770(ctx, base);
	// 8261FA30: 3BFF0088  addi r31, r31, 0x88
	ctx.r[31].s64 = ctx.r[31].s64 + 136;
	// 8261FA34: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261FA38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FA3C: 419A0038  beq cr6, 0x8261fa74
	if ctx.cr[6].eq {
	pc = 0x8261FA74; continue 'dispatch;
	}
	// 8261FA40: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261FA44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261FA48: 419A00A4  beq cr6, 0x8261faec
	if ctx.cr[6].eq {
	pc = 0x8261FAEC; continue 'dispatch;
	}
	// 8261FA4C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261FA50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FA54: 419A0020  beq cr6, 0x8261fa74
	if ctx.cr[6].eq {
	pc = 0x8261FA74; continue 'dispatch;
	}
	// 8261FA58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261FA5C: 4BB543DD  bl 0x82173e38
	ctx.lr = 0x8261FA60;
	sub_82173E38(ctx, base);
	// 8261FA60: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8261FA64: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8261FA68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261FA6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261FA70: 409A0008  bne cr6, 0x8261fa78
	if !ctx.cr[6].eq {
	pc = 0x8261FA78; continue 'dispatch;
	}
	pc = 0x8261FA74; continue 'dispatch;
            }
            0x8261FA74 => {
    //   block [0x8261FA74..0x8261FA78)
	// 8261FA74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8261FA78; continue 'dispatch;
            }
            0x8261FA78 => {
    //   block [0x8261FA78..0x8261FAA0)
	// 8261FA78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261FA7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FA80: 419A0160  beq cr6, 0x8261fbe0
	if ctx.cr[6].eq {
	pc = 0x8261FBE0; continue 'dispatch;
	}
	// 8261FA84: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8261FA88: 419A0018  beq cr6, 0x8261faa0
	if ctx.cr[6].eq {
	pc = 0x8261FAA0; continue 'dispatch;
	}
	// 8261FA8C: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 8261FA90: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8261FA94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261FA98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261FA9C: 409A0008  bne cr6, 0x8261faa4
	if !ctx.cr[6].eq {
	pc = 0x8261FAA4; continue 'dispatch;
	}
	pc = 0x8261FAA0; continue 'dispatch;
            }
            0x8261FAA0 => {
    //   block [0x8261FAA0..0x8261FAA4)
	// 8261FAA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8261FAA4; continue 'dispatch;
            }
            0x8261FAA4 => {
    //   block [0x8261FAA4..0x8261FAEC)
	// 8261FAA4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261FAA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FAAC: 419A0134  beq cr6, 0x8261fbe0
	if ctx.cr[6].eq {
	pc = 0x8261FBE0; continue 'dispatch;
	}
	// 8261FAB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261FAB4: 4BB54385  bl 0x82173e38
	ctx.lr = 0x8261FAB8;
	sub_82173E38(ctx, base);
	// 8261FAB8: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 8261FABC: 556AA7FE  rlwinm r10, r11, 0x14, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 8261FAC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261FAC4: 419A011C  beq cr6, 0x8261fbe0
	if ctx.cr[6].eq {
	pc = 0x8261FBE0; continue 'dispatch;
	}
	// 8261FAC8: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261FACC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FAD0: 419A0028  beq cr6, 0x8261faf8
	if ctx.cr[6].eq {
	pc = 0x8261FAF8; continue 'dispatch;
	}
	// 8261FAD4: 894B004C  lbz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261FAD8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261FADC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8261FAE0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261FAE4: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261FAE8: 480000C0  b 0x8261fba8
	pc = 0x8261FBA8; continue 'dispatch;
            }
            0x8261FAEC => {
    //   block [0x8261FAEC..0x8261FAF8)
	// 8261FAEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261FAF0: 4BB74349  bl 0x82193e38
	ctx.lr = 0x8261FAF4;
	sub_82193E38(ctx, base);
	// 8261FAF4: 4BFFFF80  b 0x8261fa74
	pc = 0x8261FA74; continue 'dispatch;
            }
            0x8261FAF8 => {
    //   block [0x8261FAF8..0x8261FB18)
	// 8261FAF8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261FAFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8261FB00: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261FB04: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8261FB08: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8261FB0C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8261FB10: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261FB14: 40810054  ble 0x8261fb68
	if !ctx.cr[0].gt {
	pc = 0x8261FB68; continue 'dispatch;
	}
	pc = 0x8261FB18; continue 'dispatch;
            }
            0x8261FB18 => {
    //   block [0x8261FB18..0x8261FB38)
	// 8261FB18: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261FB1C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261FB20: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8261FB24: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261FB28: 2F07004C  cmpwi cr6, r7, 0x4c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 76, &mut ctx.xer);
	// 8261FB2C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8261FB30: 41980008  blt cr6, 0x8261fb38
	if ctx.cr[6].lt {
	pc = 0x8261FB38; continue 'dispatch;
	}
	// 8261FB34: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8261FB38; continue 'dispatch;
            }
            0x8261FB38 => {
    //   block [0x8261FB38..0x8261FB54)
	// 8261FB38: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8261FB3C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261FB40: 419A0014  beq cr6, 0x8261fb54
	if ctx.cr[6].eq {
	pc = 0x8261FB54; continue 'dispatch;
	}
	// 8261FB44: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261FB48: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8261FB4C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8261FB50: 4800000C  b 0x8261fb5c
	pc = 0x8261FB5C; continue 'dispatch;
            }
            0x8261FB54 => {
    //   block [0x8261FB54..0x8261FB5C)
	// 8261FB54: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261FB58: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8261FB5C; continue 'dispatch;
            }
            0x8261FB5C => {
    //   block [0x8261FB5C..0x8261FB68)
	// 8261FB5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261FB60: 4199FFB8  bgt cr6, 0x8261fb18
	if ctx.cr[6].gt {
	pc = 0x8261FB18; continue 'dispatch;
	}
	// 8261FB64: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8261FB68; continue 'dispatch;
            }
            0x8261FB68 => {
    //   block [0x8261FB68..0x8261FB84)
	// 8261FB68: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8261FB6C: 419A0034  beq cr6, 0x8261fba0
	if ctx.cr[6].eq {
	pc = 0x8261FBA0; continue 'dispatch;
	}
	// 8261FB70: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261FB74: 2F0B004C  cmpwi cr6, r11, 0x4c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 76, &mut ctx.xer);
	// 8261FB78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261FB7C: 41990008  bgt cr6, 0x8261fb84
	if ctx.cr[6].gt {
	pc = 0x8261FB84; continue 'dispatch;
	}
	// 8261FB80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8261FB84; continue 'dispatch;
            }
            0x8261FB84 => {
    //   block [0x8261FB84..0x8261FBA0)
	// 8261FB84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261FB88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FB8C: 409A0014  bne cr6, 0x8261fba0
	if !ctx.cr[6].eq {
	pc = 0x8261FBA0; continue 'dispatch;
	}
	// 8261FB90: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261FB94: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8261FB98: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8261FB9C: 48000008  b 0x8261fba4
	pc = 0x8261FBA4; continue 'dispatch;
            }
            0x8261FBA0 => {
    //   block [0x8261FBA0..0x8261FBA4)
	// 8261FBA0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x8261FBA4; continue 'dispatch;
            }
            0x8261FBA4 => {
    //   block [0x8261FBA4..0x8261FBA8)
	// 8261FBA4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x8261FBA8; continue 'dispatch;
            }
            0x8261FBA8 => {
    //   block [0x8261FBA8..0x8261FBD8)
	// 8261FBA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261FBAC: 419A0034  beq cr6, 0x8261fbe0
	if ctx.cr[6].eq {
	pc = 0x8261FBE0; continue 'dispatch;
	}
	// 8261FBB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8261FBB4: 4BF625AD  bl 0x82582160
	ctx.lr = 0x8261FBB8;
	sub_82582160(ctx, base);
	// 8261FBB8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261FBBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FBC0: 419A0020  beq cr6, 0x8261fbe0
	if ctx.cr[6].eq {
	pc = 0x8261FBE0; continue 'dispatch;
	}
	// 8261FBC4: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261FBC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261FBCC: 419A000C  beq cr6, 0x8261fbd8
	if ctx.cr[6].eq {
	pc = 0x8261FBD8; continue 'dispatch;
	}
	// 8261FBD0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261FBD4: 48C99D81  bl 0x832b9954
	ctx.lr = 0x8261FBD8;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x8261FBD8; continue 'dispatch;
            }
            0x8261FBD8 => {
    //   block [0x8261FBD8..0x8261FBE0)
	// 8261FBD8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8261FBDC: 4800001C  b 0x8261fbf8
	pc = 0x8261FBF8; continue 'dispatch;
            }
            0x8261FBE0 => {
    //   block [0x8261FBE0..0x8261FBF4)
	// 8261FBE0: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261FBE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261FBE8: 419A000C  beq cr6, 0x8261fbf4
	if ctx.cr[6].eq {
	pc = 0x8261FBF4; continue 'dispatch;
	}
	// 8261FBEC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261FBF0: 48C99D65  bl 0x832b9954
	ctx.lr = 0x8261FBF4;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x8261FBF4; continue 'dispatch;
            }
            0x8261FBF4 => {
    //   block [0x8261FBF4..0x8261FBF8)
	// 8261FBF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8261FBF8; continue 'dispatch;
            }
            0x8261FBF8 => {
    //   block [0x8261FBF8..0x8261FC10)
	// 8261FBF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8261FBFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261FC00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261FC04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8261FC08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261FC0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261FC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261FC10 size=48
    let mut pc: u32 = 0x8261FC10;
    'dispatch: loop {
        match pc {
            0x8261FC10 => {
    //   block [0x8261FC10..0x8261FC40)
	// 8261FC10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261FC14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261FC18: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261FC1C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8261FC20: 4BFFFDE1  bl 0x8261fa00
	ctx.lr = 0x8261FC24;
	sub_8261FA00(ctx, base);
	// 8261FC24: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261FC28: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8261FC2C: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 8261FC30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8261FC34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261FC38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261FC3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261FC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261FC40 size=596
    let mut pc: u32 = 0x8261FC40;
    'dispatch: loop {
        match pc {
            0x8261FC40 => {
    //   block [0x8261FC40..0x8261FC90)
	// 8261FC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261FC44: 486897C5  bl 0x82ca9408
	ctx.lr = 0x8261FC48;
	sub_82CA93D0(ctx, base);
	// 8261FC48: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261FC4C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261FC50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261FC54: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8261FC58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8261FC5C: 388B8D14  addi r4, r11, -0x72ec
	ctx.r[4].s64 = ctx.r[11].s64 + -29420;
	// 8261FC60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8261FC64: 4BBE0B0D  bl 0x82200770
	ctx.lr = 0x8261FC68;
	sub_82200770(ctx, base);
	// 8261FC68: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 8261FC6C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8261FC70: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 8261FC74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FC78: 419A001C  beq cr6, 0x8261fc94
	if ctx.cr[6].eq {
	pc = 0x8261FC94; continue 'dispatch;
	}
	// 8261FC7C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261FC80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261FC84: 419A000C  beq cr6, 0x8261fc90
	if ctx.cr[6].eq {
	pc = 0x8261FC90; continue 'dispatch;
	}
	// 8261FC88: 555C003E  slwi r28, r10, 0
	ctx.r[28].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 8261FC8C: 4800000C  b 0x8261fc98
	pc = 0x8261FC98; continue 'dispatch;
            }
            0x8261FC90 => {
    //   block [0x8261FC90..0x8261FC94)
	// 8261FC90: 4BB741A9  bl 0x82193e38
	ctx.lr = 0x8261FC94;
	sub_82193E38(ctx, base);
	pc = 0x8261FC94; continue 'dispatch;
            }
            0x8261FC94 => {
    //   block [0x8261FC94..0x8261FC98)
	// 8261FC94: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	pc = 0x8261FC98; continue 'dispatch;
            }
            0x8261FC98 => {
    //   block [0x8261FC98..0x8261FCDC)
	// 8261FC98: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261FC9C: 3BFE0088  addi r31, r30, 0x88
	ctx.r[31].s64 = ctx.r[30].s64 + 136;
	// 8261FCA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FCA4: 419A0038  beq cr6, 0x8261fcdc
	if ctx.cr[6].eq {
	pc = 0x8261FCDC; continue 'dispatch;
	}
	// 8261FCA8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261FCAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261FCB0: 419A00AC  beq cr6, 0x8261fd5c
	if ctx.cr[6].eq {
	pc = 0x8261FD5C; continue 'dispatch;
	}
	// 8261FCB4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8261FCB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FCBC: 419A0020  beq cr6, 0x8261fcdc
	if ctx.cr[6].eq {
	pc = 0x8261FCDC; continue 'dispatch;
	}
	// 8261FCC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261FCC4: 4BB54175  bl 0x82173e38
	ctx.lr = 0x8261FCC8;
	sub_82173E38(ctx, base);
	// 8261FCC8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8261FCCC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8261FCD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261FCD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261FCD8: 409A0008  bne cr6, 0x8261fce0
	if !ctx.cr[6].eq {
	pc = 0x8261FCE0; continue 'dispatch;
	}
	pc = 0x8261FCDC; continue 'dispatch;
            }
            0x8261FCDC => {
    //   block [0x8261FCDC..0x8261FCE0)
	// 8261FCDC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8261FCE0; continue 'dispatch;
            }
            0x8261FCE0 => {
    //   block [0x8261FCE0..0x8261FD08)
	// 8261FCE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261FCE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FCE8: 419A018C  beq cr6, 0x8261fe74
	if ctx.cr[6].eq {
	pc = 0x8261FE74; continue 'dispatch;
	}
	// 8261FCEC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8261FCF0: 419A0018  beq cr6, 0x8261fd08
	if ctx.cr[6].eq {
	pc = 0x8261FD08; continue 'dispatch;
	}
	// 8261FCF4: 897C0090  lbz r11, 0x90(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(144 as u32) ) } as u64;
	// 8261FCF8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8261FCFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261FD00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261FD04: 409A0008  bne cr6, 0x8261fd0c
	if !ctx.cr[6].eq {
	pc = 0x8261FD0C; continue 'dispatch;
	}
	pc = 0x8261FD08; continue 'dispatch;
            }
            0x8261FD08 => {
    //   block [0x8261FD08..0x8261FD0C)
	// 8261FD08: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8261FD0C; continue 'dispatch;
            }
            0x8261FD0C => {
    //   block [0x8261FD0C..0x8261FD5C)
	// 8261FD0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261FD10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FD14: 419A0160  beq cr6, 0x8261fe74
	if ctx.cr[6].eq {
	pc = 0x8261FE74; continue 'dispatch;
	}
	// 8261FD18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261FD1C: 4BB5411D  bl 0x82173e38
	ctx.lr = 0x8261FD20;
	sub_82173E38(ctx, base);
	// 8261FD20: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 8261FD24: 556AA7FE  rlwinm r10, r11, 0x14, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 8261FD28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261FD2C: 419A0100  beq cr6, 0x8261fe2c
	if ctx.cr[6].eq {
	pc = 0x8261FE2C; continue 'dispatch;
	}
	// 8261FD30: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8261FD34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FD38: 419A0030  beq cr6, 0x8261fd68
	if ctx.cr[6].eq {
	pc = 0x8261FD68; continue 'dispatch;
	}
	// 8261FD3C: 894B004C  lbz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261FD40: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261FD44: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8261FD48: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8261FD4C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261FD50: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8261FD54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261FD58: 480000D8  b 0x8261fe30
	pc = 0x8261FE30; continue 'dispatch;
            }
            0x8261FD5C => {
    //   block [0x8261FD5C..0x8261FD68)
	// 8261FD5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261FD60: 4BB740D9  bl 0x82193e38
	ctx.lr = 0x8261FD64;
	sub_82193E38(ctx, base);
	// 8261FD64: 4BFFFF78  b 0x8261fcdc
	pc = 0x8261FCDC; continue 'dispatch;
            }
            0x8261FD68 => {
    //   block [0x8261FD68..0x8261FD84)
	// 8261FD68: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8261FD6C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 8261FD70: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 8261FD74: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8261FD78: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8261FD7C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261FD80: 40810054  ble 0x8261fdd4
	if !ctx.cr[0].gt {
	pc = 0x8261FDD4; continue 'dispatch;
	}
	pc = 0x8261FD84; continue 'dispatch;
            }
            0x8261FD84 => {
    //   block [0x8261FD84..0x8261FDA4)
	// 8261FD84: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8261FD88: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8261FD8C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8261FD90: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261FD94: 2F07004C  cmpwi cr6, r7, 0x4c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 76, &mut ctx.xer);
	// 8261FD98: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8261FD9C: 41980008  blt cr6, 0x8261fda4
	if ctx.cr[6].lt {
	pc = 0x8261FDA4; continue 'dispatch;
	}
	// 8261FDA0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x8261FDA4; continue 'dispatch;
            }
            0x8261FDA4 => {
    //   block [0x8261FDA4..0x8261FDC0)
	// 8261FDA4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8261FDA8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8261FDAC: 419A0014  beq cr6, 0x8261fdc0
	if ctx.cr[6].eq {
	pc = 0x8261FDC0; continue 'dispatch;
	}
	// 8261FDB0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8261FDB4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8261FDB8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8261FDBC: 4800000C  b 0x8261fdc8
	pc = 0x8261FDC8; continue 'dispatch;
            }
            0x8261FDC0 => {
    //   block [0x8261FDC0..0x8261FDC8)
	// 8261FDC0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8261FDC4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8261FDC8; continue 'dispatch;
            }
            0x8261FDC8 => {
    //   block [0x8261FDC8..0x8261FDD4)
	// 8261FDC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8261FDCC: 4199FFB8  bgt cr6, 0x8261fd84
	if ctx.cr[6].gt {
	pc = 0x8261FD84; continue 'dispatch;
	}
	// 8261FDD0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8261FDD4; continue 'dispatch;
            }
            0x8261FDD4 => {
    //   block [0x8261FDD4..0x8261FDF0)
	// 8261FDD4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8261FDD8: 419A0040  beq cr6, 0x8261fe18
	if ctx.cr[6].eq {
	pc = 0x8261FE18; continue 'dispatch;
	}
	// 8261FDDC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8261FDE0: 2F0B004C  cmpwi cr6, r11, 0x4c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 76, &mut ctx.xer);
	// 8261FDE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261FDE8: 41990008  bgt cr6, 0x8261fdf0
	if ctx.cr[6].gt {
	pc = 0x8261FDF0; continue 'dispatch;
	}
	// 8261FDEC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8261FDF0; continue 'dispatch;
            }
            0x8261FDF0 => {
    //   block [0x8261FDF0..0x8261FE18)
	// 8261FDF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261FDF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FDF8: 409A0020  bne cr6, 0x8261fe18
	if !ctx.cr[6].eq {
	pc = 0x8261FE18; continue 'dispatch;
	}
	// 8261FDFC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8261FE00: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8261FE04: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8261FE08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261FE0C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8261FE10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261FE14: 4800001C  b 0x8261fe30
	pc = 0x8261FE30; continue 'dispatch;
            }
            0x8261FE18 => {
    //   block [0x8261FE18..0x8261FE2C)
	// 8261FE18: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8261FE1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8261FE20: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8261FE24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261FE28: 48000008  b 0x8261fe30
	pc = 0x8261FE30; continue 'dispatch;
            }
            0x8261FE2C => {
    //   block [0x8261FE2C..0x8261FE30)
	// 8261FE2C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8261FE30; continue 'dispatch;
            }
            0x8261FE30 => {
    //   block [0x8261FE30..0x8261FE68)
	// 8261FE30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261FE34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FE38: 419A003C  beq cr6, 0x8261fe74
	if ctx.cr[6].eq {
	pc = 0x8261FE74; continue 'dispatch;
	}
	// 8261FE3C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8261FE40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261FE44: 482AD2ED  bl 0x828cd130
	ctx.lr = 0x8261FE48;
	sub_828CD130(ctx, base);
	// 8261FE48: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8261FE4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FE50: 419A0024  beq cr6, 0x8261fe74
	if ctx.cr[6].eq {
	pc = 0x8261FE74; continue 'dispatch;
	}
	// 8261FE54: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261FE58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261FE5C: 419A000C  beq cr6, 0x8261fe68
	if ctx.cr[6].eq {
	pc = 0x8261FE68; continue 'dispatch;
	}
	// 8261FE60: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261FE64: 48C99AF1  bl 0x832b9954
	ctx.lr = 0x8261FE68;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x8261FE68; continue 'dispatch;
            }
            0x8261FE68 => {
    //   block [0x8261FE68..0x8261FE74)
	// 8261FE68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8261FE6C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8261FE70: 486895E8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x8261FE74 => {
    //   block [0x8261FE74..0x8261FE88)
	// 8261FE74: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8261FE78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261FE7C: 419A000C  beq cr6, 0x8261fe88
	if ctx.cr[6].eq {
	pc = 0x8261FE88; continue 'dispatch;
	}
	// 8261FE80: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8261FE84: 48C99AD1  bl 0x832b9954
	ctx.lr = 0x8261FE88;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x8261FE88; continue 'dispatch;
            }
            0x8261FE88 => {
    //   block [0x8261FE88..0x8261FE94)
	// 8261FE88: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8261FE8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8261FE90: 486895C8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261FE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8261FE98 size=12
    let mut pc: u32 = 0x8261FE98;
    'dispatch: loop {
        match pc {
            0x8261FE98 => {
    //   block [0x8261FE98..0x8261FEA4)
	// 8261FE98: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261FE9C: 386B970C  addi r3, r11, -0x68f4
	ctx.r[3].s64 = ctx.r[11].s64 + -26868;
	// 8261FEA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261FEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261FEA8 size=92
    let mut pc: u32 = 0x8261FEA8;
    'dispatch: loop {
        match pc {
            0x8261FEA8 => {
    //   block [0x8261FEA8..0x8261FF04)
	// 8261FEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261FEAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8261FEB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8261FEB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261FEB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261FEBC: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 8261FEC0: 4BB97C59  bl 0x821b7b18
	ctx.lr = 0x8261FEC4;
	sub_821B7B18(ctx, base);
	// 8261FEC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8261FEC8: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 8261FECC: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 8261FED0: 915F006C  stw r10, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 8261FED4: 4BB73F65  bl 0x82193e38
	ctx.lr = 0x8261FED8;
	sub_82193E38(ctx, base);
	// 8261FED8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8261FEDC: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 8261FEE0: 913F0070  stw r9, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 8261FEE4: 4BBF4EF5  bl 0x82214dd8
	ctx.lr = 0x8261FEE8;
	sub_82214DD8(ctx, base);
	// 8261FEE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8261FEEC: 4BB8CC45  bl 0x821acb30
	ctx.lr = 0x8261FEF0;
	sub_821ACB30(ctx, base);
	// 8261FEF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8261FEF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8261FEF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8261FEFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8261FF00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261FF08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8261FF08 size=116
    let mut pc: u32 = 0x8261FF08;
    'dispatch: loop {
        match pc {
            0x8261FF08 => {
    //   block [0x8261FF08..0x8261FF70)
	// 8261FF08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261FF0C: 48689501  bl 0x82ca940c
	ctx.lr = 0x8261FF10;
	sub_82CA93D0(ctx, base);
	// 8261FF10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261FF14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8261FF18: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 8261FF1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8261FF20: 4BFF6A09  bl 0x82616928
	ctx.lr = 0x8261FF24;
	sub_82616928(ctx, base);
	// 8261FF24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261FF28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8261FF2C: 419A0044  beq cr6, 0x8261ff70
	if ctx.cr[6].eq {
	pc = 0x8261FF70; continue 'dispatch;
	}
	// 8261FF30: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8261FF34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8261FF38: 4800F871  bl 0x8262f7a8
	ctx.lr = 0x8261FF3C;
	sub_8262F7A8(ctx, base);
	// 8261FF3C: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8261FF40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8261FF44: 394000F0  li r10, 0xf0
	ctx.r[10].s64 = 240;
	// 8261FF48: 392B61A0  addi r9, r11, 0x61a0
	ctx.r[9].s64 = ctx.r[11].s64 + 24992;
	// 8261FF4C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8261FF50: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8261FF54: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8261FF58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8261FF70; continue 'dispatch;
            }
            0x8261FF70 => {
    //   block [0x8261FF70..0x8261FF7C)
	// 8261FF70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8261FF74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8261FF78: 486894E4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8261FF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8261FF80 size=848
    let mut pc: u32 = 0x8261FF80;
    'dispatch: loop {
        match pc {
            0x8261FF80 => {
    //   block [0x8261FF80..0x8261FFEC)
	// 8261FF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8261FF84: 4868946D  bl 0x82ca93f0
	ctx.lr = 0x8261FF88;
	sub_82CA93D0(ctx, base);
	// 8261FF88: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8261FF8C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8261FF90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8261FF94: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8261FF98: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8261FF9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8261FFA0: 388B8D14  addi r4, r11, -0x72ec
	ctx.r[4].s64 = ctx.r[11].s64 + -29420;
	// 8261FFA4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8261FFA8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8261FFAC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 8261FFB0: 4BBE07C1  bl 0x82200770
	ctx.lr = 0x8261FFB4;
	sub_82200770(ctx, base);
	// 8261FFB4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8261FFB8: 419A02F8  beq cr6, 0x826202b0
	if ctx.cr[6].eq {
	pc = 0x826202B0; continue 'dispatch;
	}
	// 8261FFBC: 897F0101  lbz r11, 0x101(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(257 as u32) ) } as u64;
	// 8261FFC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FFC4: 419A02EC  beq cr6, 0x826202b0
	if ctx.cr[6].eq {
	pc = 0x826202B0; continue 'dispatch;
	}
	// 8261FFC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8261FFCC: 4BFF9A05  bl 0x826199d0
	ctx.lr = 0x8261FFD0;
	sub_826199D0(ctx, base);
	// 8261FFD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8261FFD4: 419A0018  beq cr6, 0x8261ffec
	if ctx.cr[6].eq {
	pc = 0x8261FFEC; continue 'dispatch;
	}
	// 8261FFD8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8261FFDC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8261FFE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8261FFE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8261FFE8: 409A0008  bne cr6, 0x8261fff0
	if !ctx.cr[6].eq {
	pc = 0x8261FFF0; continue 'dispatch;
	}
	pc = 0x8261FFEC; continue 'dispatch;
            }
            0x8261FFEC => {
    //   block [0x8261FFEC..0x8261FFF0)
	// 8261FFEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8261FFF0; continue 'dispatch;
            }
            0x8261FFF0 => {
    //   block [0x8261FFF0..0x8262000C)
	// 8261FFF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8261FFF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8261FFF8: 419A0014  beq cr6, 0x8262000c
	if ctx.cr[6].eq {
	pc = 0x8262000C; continue 'dispatch;
	}
	// 8261FFFC: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82620000: 556ACFFE  rlwinm r10, r11, 0x19, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 82620004: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82620008: 409A02A8  bne cr6, 0x826202b0
	if !ctx.cr[6].eq {
	pc = 0x826202B0; continue 'dispatch;
	}
	pc = 0x8262000C; continue 'dispatch;
            }
            0x8262000C => {
    //   block [0x8262000C..0x826202B0)
	// 8262000C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82620010: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82620014: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82620018: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8262001C: 390A92D4  addi r8, r10, -0x6d2c
	ctx.r[8].s64 = ctx.r[10].s64 + -27948;
	// 82620020: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82620024: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 82620028: 808B003C  lwz r4, 0x3c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 8262002C: C00A92D4  lfs f0, -0x6d2c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82620030: 830B0038  lwz r24, 0x38(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82620034: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82620038: 80EB0018  lwz r7, 0x18(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8262003C: C00801B0  lfs f0, 0x1b0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82620040: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82620044: 3B210058  addi r25, r1, 0x58
	ctx.r[25].s64 = ctx.r[1].s64 + 88;
	// 82620048: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 8262004C: 7D64482E  lwzx r11, r4, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82620050: 3AE10054  addi r23, r1, 0x54
	ctx.r[23].s64 = ctx.r[1].s64 + 84;
	// 82620054: 7D58482E  lwzx r10, r24, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82620058: 3AC10050  addi r22, r1, 0x50
	ctx.r[22].s64 = ctx.r[1].s64 + 80;
	// 8262005C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82620060: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82620064: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82620068: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8262006C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82620070: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82620074: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82620078: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 8262007C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82620080: 388000D0  li r4, 0xd0
	ctx.r[4].s64 = 208;
	// 82620084: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82620088: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8262008C: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 82620090: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82620094: 38E990F0  addi r7, r9, -0x6f10
	ctx.r[7].s64 = ctx.r[9].s64 + -28432;
	// 82620098: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8262009C: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 826200A0: C14A0004  lfs f10, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 826200A4: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 826200A8: C12A000C  lfs f9, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 826200AC: ED0A582A  fadds f8, f10, f11
	ctx.f[8].f64 = ((ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64;
	// 826200B0: C0EB000C  lfs f7, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 826200B4: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 826200B8: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 826200BC: ECC9382A  fadds f6, f9, f7
	ctx.f[6].f64 = ((ctx.f[9].f64 + ctx.f[7].f64) as f32) as f64;
	pc = 0x826202B0; continue 'dispatch;
            }
            0x826202B0 => {
    //   block [0x826202B0..0x826202D0)
	// 826202B0: 89410074  lbz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826202B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826202B8: 419A000C  beq cr6, 0x826202c4
	if ctx.cr[6].eq {
	pc = 0x826202C4; continue 'dispatch;
	}
	// 826202BC: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 826202C0: 48C99695  bl 0x832b9954
	ctx.lr = 0x826202C4;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 826202C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826202C8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826202CC: 48689174  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


