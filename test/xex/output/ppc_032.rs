pub fn sub_823A8E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823A8E88 size=24
    let mut pc: u32 = 0x823A8E88;
    'dispatch: loop {
        match pc {
            0x823A8E88 => {
    //   block [0x823A8E88..0x823A8E98)
	// 823A8E88: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823A8E8C: 419A000C  beq cr6, 0x823a8e98
	if ctx.cr[6].eq {
	pc = 0x823A8E98; continue 'dispatch;
	}
	// 823A8E90: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A8E94: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823A8E98; continue 'dispatch;
            }
            0x823A8E98 => {
    //   block [0x823A8E98..0x823A8EA0)
	// 823A8E98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823A8E9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A8EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823A8EA0 size=40
    let mut pc: u32 = 0x823A8EA0;
    'dispatch: loop {
        match pc {
            0x823A8EA0 => {
    //   block [0x823A8EA0..0x823A8EB0)
	// 823A8EA0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823A8EA4: 419A000C  beq cr6, 0x823a8eb0
	if ctx.cr[6].eq {
	pc = 0x823A8EB0; continue 'dispatch;
	}
	// 823A8EA8: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823A8EAC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823A8EB0; continue 'dispatch;
            }
            0x823A8EB0 => {
    //   block [0x823A8EB0..0x823A8EC0)
	// 823A8EB0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 823A8EB4: 419A000C  beq cr6, 0x823a8ec0
	if ctx.cr[6].eq {
	pc = 0x823A8EC0; continue 'dispatch;
	}
	// 823A8EB8: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823A8EBC: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823A8EC0; continue 'dispatch;
            }
            0x823A8EC0 => {
    //   block [0x823A8EC0..0x823A8EC8)
	// 823A8EC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823A8EC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A8EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823A8EC8 size=36
    let mut pc: u32 = 0x823A8EC8;
    'dispatch: loop {
        match pc {
            0x823A8EC8 => {
    //   block [0x823A8EC8..0x823A8EEC)
	// 823A8EC8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 823A8ECC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A8ED0: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 823A8ED4: 419A0018  beq cr6, 0x823a8eec
	if ctx.cr[6].eq {
		sub_823A8EEC(ctx, base);
		return;
	}
	// 823A8ED8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823A8EDC: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823A8EE0: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 823A8EE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823A8EE8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A8EEC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823A8EEC size=20
    let mut pc: u32 = 0x823A8EEC;
    'dispatch: loop {
        match pc {
            0x823A8EEC => {
    //   block [0x823A8EEC..0x823A8F00)
	// 823A8EEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823A8EF0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 823A8EF4: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 823A8EF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823A8EFC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A8F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A8F00 size=464
    let mut pc: u32 = 0x823A8F00;
    'dispatch: loop {
        match pc {
            0x823A8F00 => {
    //   block [0x823A8F00..0x823A8F80)
	// 823A8F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A8F04: 4818C1A1  bl 0x825350a4
	ctx.lr = 0x823A8F08;
	sub_82535080(ctx, base);
	// 823A8F08: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A8F0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823A8F10: 3960FFF0  li r11, -0x10
	ctx.r[11].s64 = -16;
	// 823A8F14: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 823A8F18: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 823A8F1C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 823A8F20: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 823A8F24: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 823A8F28: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 823A8F2C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823A8F30: 40980124  bge cr6, 0x823a9054
	if !ctx.cr[6].lt {
	pc = 0x823A9054; continue 'dispatch;
	}
	// 823A8F34: 48364329  bl 0x8270d25c
	ctx.lr = 0x823A8F38;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823A8F38: 81790024  lwz r11, 0x24(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 823A8F3C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 823A8F40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823A8F44: 91790024  stw r11, 0x24(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 823A8F48: 83F9002C  lwz r31, 0x2c(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 823A8F4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A8F50: 9179002C  stw r11, 0x2c(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 823A8F54: 48364319  bl 0x8270d26c
	ctx.lr = 0x823A8F58;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823A8F58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823A8F5C: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 823A8F60: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 823A8F64: 409A0068  bne cr6, 0x823a8fcc
	if !ctx.cr[6].eq {
	pc = 0x823A8FCC; continue 'dispatch;
	}
	// 823A8F68: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A8F6C: 2B180001  cmplwi cr6, r24, 1
	ctx.cr[6].compare_u32(ctx.r[24].u32, 1 as u32, &mut ctx.xer);
	// 823A8F70: 396B04A4  addi r11, r11, 0x4a4
	ctx.r[11].s64 = ctx.r[11].s64 + 1188;
	// 823A8F74: 38FF0004  addi r7, r31, 4
	ctx.r[7].s64 = ctx.r[31].s64 + 4;
	// 823A8F78: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823A8F7C: 409A0028  bne cr6, 0x823a8fa4
	if !ctx.cr[6].eq {
	pc = 0x823A8FA4; continue 'dispatch;
	}
	pc = 0x823A8F80; continue 'dispatch;
            }
            0x823A8F80 => {
    //   block [0x823A8F80..0x823A8FA4)
	// 823A8F80: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 823A8F84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A8F88: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 823A8F8C: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823A8F90: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A8F94: 4082FFEC  bne 0x823a8f80
	if !ctx.cr[0].eq {
	pc = 0x823A8F80; continue 'dispatch;
	}
	// 823A8F98: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A8F9C: 396B1910  addi r11, r11, 0x1910
	ctx.r[11].s64 = ctx.r[11].s64 + 6416;
	// 823A8FA0: 48000064  b 0x823a9004
	pc = 0x823A9004; continue 'dispatch;
            }
            0x823A8FA4 => {
    //   block [0x823A8FA4..0x823A8FCC)
	// 823A8FA4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 823A8FA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A8FAC: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 823A8FB0: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823A8FB4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A8FB8: 4082FFEC  bne 0x823a8fa4
	if !ctx.cr[0].eq {
	pc = 0x823A8FA4; continue 'dispatch;
	}
	// 823A8FBC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A8FC0: 931F0054  stw r24, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 823A8FC4: 396B1898  addi r11, r11, 0x1898
	ctx.r[11].s64 = ctx.r[11].s64 + 6296;
	// 823A8FC8: 4800003C  b 0x823a9004
	pc = 0x823A9004; continue 'dispatch;
            }
            0x823A8FCC => {
    //   block [0x823A8FCC..0x823A8FE4)
	// 823A8FCC: 2B180001  cmplwi cr6, r24, 1
	ctx.cr[6].compare_u32(ctx.r[24].u32, 1 as u32, &mut ctx.xer);
	// 823A8FD0: 409A0058  bne cr6, 0x823a9028
	if !ctx.cr[6].eq {
	pc = 0x823A9028; continue 'dispatch;
	}
	// 823A8FD4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A8FD8: 38FF0004  addi r7, r31, 4
	ctx.r[7].s64 = ctx.r[31].s64 + 4;
	// 823A8FDC: 396B04A4  addi r11, r11, 0x4a4
	ctx.r[11].s64 = ctx.r[11].s64 + 1188;
	// 823A8FE0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823A8FE4; continue 'dispatch;
            }
            0x823A8FE4 => {
    //   block [0x823A8FE4..0x823A9004)
	// 823A8FE4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 823A8FE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A8FEC: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 823A8FF0: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823A8FF4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A8FF8: 4082FFEC  bne 0x823a8fe4
	if !ctx.cr[0].eq {
	pc = 0x823A8FE4; continue 'dispatch;
	}
	// 823A8FFC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A9000: 396B18D4  addi r11, r11, 0x18d4
	ctx.r[11].s64 = ctx.r[11].s64 + 6356;
	pc = 0x823A9004; continue 'dispatch;
            }
            0x823A9004 => {
    //   block [0x823A9004..0x823A9028)
	// 823A9004: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 823A9008: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823A900C: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 823A9010: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 823A9014: 935F0010  stw r26, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 823A9018: 939F0014  stw r28, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 823A901C: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 823A9020: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823A9024: 913F0050  stw r9, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	pc = 0x823A9028; continue 'dispatch;
            }
            0x823A9028 => {
    //   block [0x823A9028..0x823A9054)
	// 823A9028: 83F9003C  lwz r31, 0x3c(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(60 as u32) ) } as u64;
	// 823A902C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823A9030: 4836422D  bl 0x8270d25c
	ctx.lr = 0x823A9034;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823A9034: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823A9038: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823A903C: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 823A9040: 48003B81  bl 0x823acbc0
	ctx.lr = 0x823A9044;
	sub_823ACBC0(ctx, base);
	// 823A9044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823A9048: 48364225  bl 0x8270d26c
	ctx.lr = 0x823A904C;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823A904C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823A9050: 48000078  b 0x823a90c8
	pc = 0x823A90C8; continue 'dispatch;
            }
            0x823A9054 => {
    //   block [0x823A9054..0x823A907C)
	// 823A9054: 57CB073E  clrlwi r11, r30, 0x1c
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x0000000Fu64;
	// 823A9058: 81590038  lwz r10, 0x38(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(56 as u32) ) } as u64;
	// 823A905C: 1D6B0120  mulli r11, r11, 0x120
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 288 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823A9060: 7D6B5215  add. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823A9064: 41820060  beq 0x823a90c4
	if ctx.cr[0].eq {
	pc = 0x823A90C4; continue 'dispatch;
	}
	// 823A9068: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823A906C: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 823A9070: 392A04A4  addi r9, r10, 0x4a4
	ctx.r[9].s64 = ctx.r[10].s64 + 1188;
	// 823A9074: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823A9078: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x823A907C; continue 'dispatch;
            }
            0x823A907C => {
    //   block [0x823A907C..0x823A90C4)
	// 823A907C: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 823A9080: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A9084: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 823A9088: 7D40312D  stwcx. r10, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823A908C: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A9090: 4082FFEC  bne 0x823a907c
	if !ctx.cr[0].eq {
	pc = 0x823A907C; continue 'dispatch;
	}
	// 823A9094: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823A9098: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823A909C: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 823A90A0: 936B000C  stw r27, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 823A90A4: 39291910  addi r9, r9, 0x1910
	ctx.r[9].s64 = ctx.r[9].s64 + 6416;
	// 823A90A8: 934B0010  stw r26, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 823A90AC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 823A90B0: 938B0014  stw r28, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 823A90B4: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 823A90B8: 910B0050  stw r8, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 823A90BC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823A90C0: 48000008  b 0x823a90c8
	pc = 0x823A90C8; continue 'dispatch;
            }
            0x823A90C4 => {
    //   block [0x823A90C4..0x823A90C8)
	// 823A90C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823A90C8; continue 'dispatch;
            }
            0x823A90C8 => {
    //   block [0x823A90C8..0x823A90D0)
	// 823A90C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823A90CC: 4818C028  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A90D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A90D0 size=320
    let mut pc: u32 = 0x823A90D0;
    'dispatch: loop {
        match pc {
            0x823A90D0 => {
    //   block [0x823A90D0..0x823A913C)
	// 823A90D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A90D4: 4818BFD9  bl 0x825350ac
	ctx.lr = 0x823A90D8;
	sub_82535080(ctx, base);
	// 823A90D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A90DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823A90E0: 3960FFF0  li r11, -0x10
	ctx.r[11].s64 = -16;
	// 823A90E4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823A90E8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823A90EC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 823A90F0: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 823A90F4: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 823A90F8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823A90FC: 409800F0  bge cr6, 0x823a91ec
	if !ctx.cr[6].lt {
	pc = 0x823A91EC; continue 'dispatch;
	}
	// 823A9100: 8063003C  lwz r3, 0x3c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 823A9104: 4BFFF9BD  bl 0x823a8ac0
	ctx.lr = 0x823A9108;
	sub_823A8AC0(ctx, base);
	// 823A9108: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823A910C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9110: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823A9114: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823A9118: 4E800421  bctrl
	ctx.lr = 0x823A911C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823A911C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 823A9120: 409A0068  bne cr6, 0x823a9188
	if !ctx.cr[6].eq {
	pc = 0x823A9188; continue 'dispatch;
	}
	// 823A9124: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A9128: 2B1A0001  cmplwi cr6, r26, 1
	ctx.cr[6].compare_u32(ctx.r[26].u32, 1 as u32, &mut ctx.xer);
	// 823A912C: 396B04A4  addi r11, r11, 0x4a4
	ctx.r[11].s64 = ctx.r[11].s64 + 1188;
	// 823A9130: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 823A9134: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823A9138: 409A0028  bne cr6, 0x823a9160
	if !ctx.cr[6].eq {
	pc = 0x823A9160; continue 'dispatch;
	}
            }
            0x823A913C => {
    //   block [0x823A913C..0x823A9160)
	// 823A913C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 823A9140: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A9144: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 823A9148: 7C60512D  stwcx. r3, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[3].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823A914C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A9150: 4082FFEC  bne 0x823a913c
	if !ctx.cr[0].eq {
	pc = 0x823A913C; continue 'dispatch;
	}
	// 823A9154: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A9158: 396B1910  addi r11, r11, 0x1910
	ctx.r[11].s64 = ctx.r[11].s64 + 6416;
	// 823A915C: 48000064  b 0x823a91c0
	pc = 0x823A91C0; continue 'dispatch;
            }
            0x823A9160 => {
    //   block [0x823A9160..0x823A9188)
	// 823A9160: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 823A9164: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A9168: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 823A916C: 7C60512D  stwcx. r3, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[3].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823A9170: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A9174: 4082FFEC  bne 0x823a9160
	if !ctx.cr[0].eq {
	pc = 0x823A9160; continue 'dispatch;
	}
	// 823A9178: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A917C: 935F0054  stw r26, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 823A9180: 396B1898  addi r11, r11, 0x1898
	ctx.r[11].s64 = ctx.r[11].s64 + 6296;
	// 823A9184: 4800003C  b 0x823a91c0
	pc = 0x823A91C0; continue 'dispatch;
            }
            0x823A9188 => {
    //   block [0x823A9188..0x823A91A0)
	// 823A9188: 2B1A0001  cmplwi cr6, r26, 1
	ctx.cr[6].compare_u32(ctx.r[26].u32, 1 as u32, &mut ctx.xer);
	// 823A918C: 409A0058  bne cr6, 0x823a91e4
	if !ctx.cr[6].eq {
	pc = 0x823A91E4; continue 'dispatch;
	}
	// 823A9190: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A9194: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 823A9198: 396B04A4  addi r11, r11, 0x4a4
	ctx.r[11].s64 = ctx.r[11].s64 + 1188;
	// 823A919C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823A91A0; continue 'dispatch;
            }
            0x823A91A0 => {
    //   block [0x823A91A0..0x823A91C0)
	// 823A91A0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 823A91A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A91A8: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 823A91AC: 7C60512D  stwcx. r3, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[3].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823A91B0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A91B4: 4082FFEC  bne 0x823a91a0
	if !ctx.cr[0].eq {
	pc = 0x823A91A0; continue 'dispatch;
	}
	// 823A91B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A91BC: 396B18D4  addi r11, r11, 0x18d4
	ctx.r[11].s64 = ctx.r[11].s64 + 6356;
	pc = 0x823A91C0; continue 'dispatch;
            }
            0x823A91C0 => {
    //   block [0x823A91C0..0x823A91E4)
	// 823A91C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823A91C4: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823A91C8: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 823A91CC: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 823A91D0: 937F0010  stw r27, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[27].u32 ) };
	// 823A91D4: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 823A91D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823A91DC: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 823A91E0: 913F0050  stw r9, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	pc = 0x823A91E4; continue 'dispatch;
            }
            0x823A91E4 => {
    //   block [0x823A91E4..0x823A91EC)
	// 823A91E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823A91E8: 48000020  b 0x823a9208
	pc = 0x823A9208; continue 'dispatch;
            }
            0x823A91EC => {
    //   block [0x823A91EC..0x823A9208)
	// 823A91EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823A91F0: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 823A91F4: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 823A91F8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823A91FC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 823A9200: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823A9204: 4BFFFCFD  bl 0x823a8f00
	ctx.lr = 0x823A9208;
	sub_823A8F00(ctx, base);
	pc = 0x823A9208; continue 'dispatch;
            }
            0x823A9208 => {
    //   block [0x823A9208..0x823A9210)
	// 823A9208: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823A920C: 4818BEF0  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823A9210 size=212
    let mut pc: u32 = 0x823A9210;
    'dispatch: loop {
        match pc {
            0x823A9210 => {
    //   block [0x823A9210..0x823A9230)
	// 823A9210: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823A9214: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823A9218: 394A04E0  addi r10, r10, 0x4e0
	ctx.r[10].s64 = ctx.r[10].s64 + 1248;
	// 823A921C: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 823A9220: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 823A9224: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823A9228: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 823A922C: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	pc = 0x823A9230; continue 'dispatch;
            }
            0x823A9230 => {
    //   block [0x823A9230..0x823A9258)
	// 823A9230: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 823A9234: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A9238: 7D005028  lwarx r8, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 823A923C: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823A9240: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A9244: 4082FFEC  bne 0x823a9230
	if !ctx.cr[0].eq {
	pc = 0x823A9230; continue 'dispatch;
	}
	// 823A9248: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 823A924C: 394001FF  li r10, 0x1ff
	ctx.r[10].s64 = 511;
	// 823A9250: 390B0020  addi r8, r11, 0x20
	ctx.r[8].s64 = ctx.r[11].s64 + 32;
	// 823A9254: 912B001C  stw r9, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	pc = 0x823A9258; continue 'dispatch;
            }
            0x823A9258 => {
    //   block [0x823A9258..0x823A92E4)
	// 823A9258: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823A925C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823A9260: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 823A9264: 4080FFF4  bge 0x823a9258
	if !ctx.cr[0].lt {
	pc = 0x823A9258; continue 'dispatch;
	}
	// 823A9268: 396B1020  addi r11, r11, 0x1020
	ctx.r[11].s64 = ctx.r[11].s64 + 4128;
	// 823A926C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823A9270: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 823A9274: 390A04F4  addi r8, r10, 0x4f4
	ctx.r[8].s64 = ctx.r[10].s64 + 1268;
	// 823A9278: 394B0020  addi r10, r11, 0x20
	ctx.r[10].s64 = ctx.r[11].s64 + 32;
	// 823A927C: 80CB0010  lwz r6, 0x10(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823A9280: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 823A9284: 38AA0004  addi r5, r10, 4
	ctx.r[5].s64 = ctx.r[10].s64 + 4;
	// 823A9288: 54C604BE  clrlwi r6, r6, 0x12
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x00003FFFu64;
	// 823A928C: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 823A9290: 90CB0010  stw r6, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 823A9294: 90EB0018  stw r7, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 823A9298: 916B001C  stw r11, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 823A929C: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 823A92A0: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823A92A4: 80EB0018  lwz r7, 0x18(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823A92A8: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823A92AC: 80EA0010  lwz r7, 0x10(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 823A92B0: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 823A92B4: 54E704BE  clrlwi r7, r7, 0x12
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x00003FFFu64;
	// 823A92B8: 912A000C  stw r9, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 823A92BC: 90EA0010  stw r7, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 823A92C0: 90AA0018  stw r5, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[5].u32 ) };
	// 823A92C4: 914A001C  stw r10, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 823A92C8: 912A0014  stw r9, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 823A92CC: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823A92D0: 80EA0018  lwz r7, 0x18(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 823A92D4: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823A92D8: 912B0040  stw r9, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[9].u32 ) };
	// 823A92DC: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823A92E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A92E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823A92E8 size=24
    let mut pc: u32 = 0x823A92E8;
    'dispatch: loop {
        match pc {
            0x823A92E8 => {
    //   block [0x823A92E8..0x823A9300)
	// 823A92E8: 548B013E  clrlwi r11, r4, 4
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x0FFFFFFFu64;
	// 823A92EC: 1D450180  mulli r10, r5, 0x180
	ctx.r[10].s32 = ((ctx.r[5].s32 as i64 * 384 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823A92F0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823A92F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823A92F8: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823A92FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823A9300 size=8
    let mut pc: u32 = 0x823A9300;
    'dispatch: loop {
        match pc {
            0x823A9300 => {
    //   block [0x823A9300..0x823A9308)
	// 823A9300: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 823A9304: 4BFF5684  b 0x8239e988
	sub_8239E988(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A9308 size=168
    let mut pc: u32 = 0x823A9308;
    'dispatch: loop {
        match pc {
            0x823A9308 => {
    //   block [0x823A9308..0x823A9324)
	// 823A9308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A930C: 4818BDB1  bl 0x825350bc
	ctx.lr = 0x823A9310;
	sub_82535080(ctx, base);
	// 823A9310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A9314: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823A9318: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823A931C: 397D0010  addi r11, r29, 0x10
	ctx.r[11].s64 = ctx.r[29].s64 + 16;
	// 823A9320: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x823A9324; continue 'dispatch;
            }
            0x823A9324 => {
    //   block [0x823A9324..0x823A93B0)
	// 823A9324: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 823A9328: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A932C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 823A9330: 7FC0412D  stwcx. r30, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[30].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823A9334: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A9338: 4082FFEC  bne 0x823a9324
	if !ctx.cr[0].eq {
	pc = 0x823A9324; continue 'dispatch;
	}
	// 823A933C: 3BEB000C  addi r31, r11, 0xc
	ctx.r[31].s64 = ctx.r[11].s64 + 12;
	// 823A9340: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823A9344: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823A9348: 48003229  bl 0x823ac570
	ctx.lr = 0x823A934C;
	sub_823AC570(ctx, base);
	// 823A934C: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823A9350: 39400140  li r10, 0x140
	ctx.r[10].s64 = 320;
	// 823A9354: 93DF1068  stw r30, 0x1068(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4200 as u32), ctx.r[30].u32 ) };
	// 823A9358: 396BF080  addi r11, r11, -0xf80
	ctx.r[11].s64 = ctx.r[11].s64 + -3968;
	// 823A935C: 93DF1064  stw r30, 0x1064(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4196 as u32), ctx.r[30].u32 ) };
	// 823A9360: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 823A9364: 914B0034  stw r10, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 823A9368: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 823A936C: 914B0038  stw r10, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 823A9370: 914B002C  stw r10, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 823A9374: 914B0024  stw r10, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 823A9378: 914B0028  stw r10, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 823A937C: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 823A9380: 914B0100  stw r10, 0x100(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), ctx.r[10].u32 ) };
	// 823A9384: 914B0108  stw r10, 0x108(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), ctx.r[10].u32 ) };
	// 823A9388: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 823A938C: 914B009C  stw r10, 0x9c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 823A9390: 914B1680  stw r10, 0x1680(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5760 as u32), ctx.r[10].u32 ) };
	// 823A9394: 914B1688  stw r10, 0x1688(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5768 as u32), ctx.r[10].u32 ) };
	// 823A9398: 93CB161C  stw r30, 0x161c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5660 as u32), ctx.r[30].u32 ) };
	// 823A939C: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823A93A0: 4BFF1D01  bl 0x8239b0a0
	ctx.lr = 0x823A93A4;
	sub_8239B0A0(ctx, base);
	// 823A93A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823A93A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823A93AC: 4818BD60  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A93B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A93B0 size=192
    let mut pc: u32 = 0x823A93B0;
    'dispatch: loop {
        match pc {
            0x823A93B0 => {
    //   block [0x823A93B0..0x823A93EC)
	// 823A93B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A93B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823A93B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823A93BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823A93C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A93C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823A93C8: 3960FFF0  li r11, -0x10
	ctx.r[11].s64 = -16;
	// 823A93CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823A93D0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823A93D4: 41980018  blt cr6, 0x823a93ec
	if ctx.cr[6].lt {
	pc = 0x823A93EC; continue 'dispatch;
	}
	// 823A93D8: 57EB073E  clrlwi r11, r31, 0x1c
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x0000000Fu64;
	// 823A93DC: 815E0300  lwz r10, 0x300(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(768 as u32) ) } as u64;
	// 823A93E0: 1D6B0218  mulli r11, r11, 0x218
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 536 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823A93E4: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823A93E8: 48000070  b 0x823a9458
	pc = 0x823A9458; continue 'dispatch;
            }
            0x823A93EC => {
    //   block [0x823A93EC..0x823A941C)
	// 823A93EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823A93F0: 48363E6D  bl 0x8270d25c
	ctx.lr = 0x823A93F4;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823A93F4: 39600065  li r11, 0x65
	ctx.r[11].s64 = 101;
	// 823A93F8: 393E0080  addi r9, r30, 0x80
	ctx.r[9].s64 = ctx.r[30].s64 + 128;
	// 823A93FC: 7D7F5B96  divwu r11, r31, r11
	ctx.r[11].u32 = ctx.r[31].u32 / ctx.r[11].u32;
	// 823A9400: 1D6B0065  mulli r11, r11, 0x65
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 101 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823A9404: 93E90018  stw r31, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 823A9408: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 823A940C: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 823A9410: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823A9414: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 823A9418: 48000014  b 0x823a942c
	pc = 0x823A942C; continue 'dispatch;
            }
            0x823A941C => {
    //   block [0x823A941C..0x823A9428)
	// 823A941C: 4099000C  ble cr6, 0x823a9428
	if !ctx.cr[6].gt {
	pc = 0x823A9428; continue 'dispatch;
	}
	// 823A9420: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9424: 48000008  b 0x823a942c
	pc = 0x823A942C; continue 'dispatch;
            }
            0x823A9428 => {
    //   block [0x823A9428..0x823A942C)
	// 823A9428: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823A942C; continue 'dispatch;
            }
            0x823A942C => {
    //   block [0x823A942C..0x823A944C)
	// 823A942C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823A9430: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823A9434: 409AFFE8  bne cr6, 0x823a941c
	if !ctx.cr[6].eq {
	pc = 0x823A941C; continue 'dispatch;
	}
	// 823A9438: 39490010  addi r10, r9, 0x10
	ctx.r[10].s64 = ctx.r[9].s64 + 16;
	// 823A943C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823A9440: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823A9444: 419A0008  beq cr6, 0x823a944c
	if ctx.cr[6].eq {
	pc = 0x823A944C; continue 'dispatch;
	}
	// 823A9448: 83EB000C  lwz r31, 0xc(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x823A944C; continue 'dispatch;
            }
            0x823A944C => {
    //   block [0x823A944C..0x823A9458)
	// 823A944C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823A9450: 48363E1D  bl 0x8270d26c
	ctx.lr = 0x823A9454;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823A9454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x823A9458; continue 'dispatch;
            }
            0x823A9458 => {
    //   block [0x823A9458..0x823A9470)
	// 823A9458: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823A945C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823A9460: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823A9464: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823A9468: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823A946C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A9470 size=272
    let mut pc: u32 = 0x823A9470;
    'dispatch: loop {
        match pc {
            0x823A9470 => {
    //   block [0x823A9470..0x823A94BC)
	// 823A9470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A9474: 4818BC45  bl 0x825350b8
	ctx.lr = 0x823A9478;
	sub_82535080(ctx, base);
	// 823A9478: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A947C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823A9480: 3B80FFF0  li r28, -0x10
	ctx.r[28].s64 = -16;
	// 823A9484: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823A9488: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 823A948C: 40980030  bge cr6, 0x823a94bc
	if !ctx.cr[6].lt {
	pc = 0x823A94BC; continue 'dispatch;
	}
	// 823A9490: 48363DCD  bl 0x8270d25c
	ctx.lr = 0x823A9494;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823A9494: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 823A9498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823A949C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823A94A0: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 823A94A4: 83BF002C  lwz r29, 0x2c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823A94A8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A94AC: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 823A94B0: 48363DBD  bl 0x8270d26c
	ctx.lr = 0x823A94B4;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823A94B4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823A94B8: 48000014  b 0x823a94cc
	pc = 0x823A94CC; continue 'dispatch;
            }
            0x823A94BC => {
    //   block [0x823A94BC..0x823A94CC)
	// 823A94BC: 57CB073E  clrlwi r11, r30, 0x1c
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x0000000Fu64;
	// 823A94C0: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 823A94C4: 1D6B0218  mulli r11, r11, 0x218
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 536 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823A94C8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x823A94CC; continue 'dispatch;
            }
            0x823A94CC => {
    //   block [0x823A94CC..0x823A94E8)
	// 823A94CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823A94D0: 419A0074  beq cr6, 0x823a9544
	if ctx.cr[6].eq {
	pc = 0x823A9544; continue 'dispatch;
	}
	// 823A94D4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823A94D8: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 823A94DC: 392A053C  addi r9, r10, 0x53c
	ctx.r[9].s64 = ctx.r[10].s64 + 1340;
	// 823A94E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823A94E4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x823A94E8; continue 'dispatch;
            }
            0x823A94E8 => {
    //   block [0x823A94E8..0x823A9544)
	// 823A94E8: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 823A94EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A94F0: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 823A94F4: 7D40312D  stwcx. r10, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823A94F8: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823A94FC: 4082FFEC  bne 0x823a94e8
	if !ctx.cr[0].eq {
	pc = 0x823A94E8; continue 'dispatch;
	}
	// 823A9500: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823A9504: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823A9508: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 823A950C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 823A9510: 3929194C  addi r9, r9, 0x194c
	ctx.r[9].s64 = ctx.r[9].s64 + 6476;
	// 823A9514: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 823A9518: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 823A951C: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 823A9520: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 823A9524: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 823A9528: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823A952C: 914B0024  stw r10, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 823A9530: B14B0030  sth r10, 0x30(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u16 ) };
	// 823A9534: 914B0028  stw r10, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 823A9538: 914B002C  stw r10, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 823A953C: 914B0030  stw r10, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 823A9540: 48000008  b 0x823a9548
	pc = 0x823A9548; continue 'dispatch;
            }
            0x823A9544 => {
    //   block [0x823A9544..0x823A9548)
	// 823A9544: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x823A9548; continue 'dispatch;
            }
            0x823A9548 => {
    //   block [0x823A9548..0x823A9574)
	// 823A9548: 83FF003C  lwz r31, 0x3c(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 823A954C: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 823A9550: 40980024  bge cr6, 0x823a9574
	if !ctx.cr[6].lt {
	pc = 0x823A9574; continue 'dispatch;
	}
	// 823A9554: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823A9558: 48363D05  bl 0x8270d25c
	ctx.lr = 0x823A955C;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823A955C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823A9560: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823A9564: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 823A9568: 48003659  bl 0x823acbc0
	ctx.lr = 0x823A956C;
	sub_823ACBC0(ctx, base);
	// 823A956C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823A9570: 48363CFD  bl 0x8270d26c
	ctx.lr = 0x823A9574;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x823A9574; continue 'dispatch;
            }
            0x823A9574 => {
    //   block [0x823A9574..0x823A9580)
	// 823A9574: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823A9578: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823A957C: 4818BB8C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A9580 size=100
    let mut pc: u32 = 0x823A9580;
    'dispatch: loop {
        match pc {
            0x823A9580 => {
    //   block [0x823A9580..0x823A95B8)
	// 823A9580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A9584: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823A9588: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823A958C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823A9590: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A9594: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823A9598: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823A959C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 823A95A0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A95A4: 48017F75  bl 0x823c1518
	ctx.lr = 0x823A95A8;
	sub_823C1518(ctx, base);
	// 823A95A8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A95AC: FBDF0010  std r30, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u64 ) };
	// 823A95B0: 4819D3A1  bl 0x82546950
	ctx.lr = 0x823A95B4;
	sub_82546950(ctx, base);
	// 823A95B4: 48000008  b 0x823a95bc
	pc = 0x823A95BC; continue 'dispatch;
            }
            0x823A95B8 => {
    //   block [0x823A95B8..0x823A95BC)
	// 823A95B8: 7FFFFB78  mr r31, r31
	ctx.r[31].u64 = ctx.r[31].u64;
	pc = 0x823A95BC; continue 'dispatch;
            }
            0x823A95BC => {
    //   block [0x823A95BC..0x823A95E4)
	// 823A95BC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823A95C0: 48017F61  bl 0x823c1520
	ctx.lr = 0x823A95C4;
	sub_823C1520(ctx, base);
	// 823A95C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823A95C8: 4182FFF0  beq 0x823a95b8
	if ctx.cr[0].eq {
	pc = 0x823A95B8; continue 'dispatch;
	}
	// 823A95CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823A95D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823A95D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823A95D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823A95DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823A95E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A95E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A95E8 size=76
    let mut pc: u32 = 0x823A95E8;
    'dispatch: loop {
        match pc {
            0x823A95E8 => {
    //   block [0x823A95E8..0x823A9600)
	// 823A95E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A95EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823A95F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823A95F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A95F8: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823A95FC: 48000018  b 0x823a9614
	pc = 0x823A9614; continue 'dispatch;
            }
            0x823A9600 => {
    //   block [0x823A9600..0x823A9614)
	// 823A9600: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9604: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A9608: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823A960C: 4E800421  bctrl
	ctx.lr = 0x823A9610;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823A9610: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
            }
            0x823A9614 => {
    //   block [0x823A9614..0x823A9634)
	// 823A9614: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9618: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823A961C: 4082FFE4  bne 0x823a9600
	if !ctx.cr[0].eq {
	pc = 0x823A9600; continue 'dispatch;
	}
	// 823A9620: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823A9624: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823A9628: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823A962C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823A9630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823A9638 size=320
    let mut pc: u32 = 0x823A9638;
    'dispatch: loop {
        match pc {
            0x823A9638 => {
    //   block [0x823A9638..0x823A96B4)
	// 823A9638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A963C: 4818BA71  bl 0x825350ac
	ctx.lr = 0x823A9640;
	sub_82535080(ctx, base);
	// 823A9640: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A9644: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 823A9648: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 823A964C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823A9650: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823A9654: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 823A9658: 7F1FC800  cmpw cr6, r31, r25
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[25].s32, &mut ctx.xer);
	// 823A965C: 40980114  bge cr6, 0x823a9770
	if !ctx.cr[6].lt {
	pc = 0x823A9770; continue 'dispatch;
	}
	// 823A9660: 7D7FCA14  add r11, r31, r25
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[25].u64;
	// 823A9664: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 823A9668: 7FCB0194  addze r30, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[30].s64 = tmp.s64;
	// 823A966C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 823A9670: 4BFFFFC9  bl 0x823a9638
	ctx.lr = 0x823A9674;
	sub_823A9638(ctx, base);
	// 823A9674: 3B5E0001  addi r26, r30, 1
	ctx.r[26].s64 = ctx.r[30].s64 + 1;
	// 823A9678: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 823A967C: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 823A9680: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823A9684: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823A9688: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 823A968C: 4BFFFFAD  bl 0x823a9638
	ctx.lr = 0x823A9690;
	sub_823A9638(ctx, base);
	// 823A9690: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823A9694: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823A9698: 41990034  bgt cr6, 0x823a96cc
	if ctx.cr[6].gt {
	pc = 0x823A96CC; continue 'dispatch;
	}
	// 823A969C: 7D7FF050  subf r11, r31, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 823A96A0: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823A96A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823A96A8: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 823A96AC: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 823A96B0: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	pc = 0x823A96B4; continue 'dispatch;
            }
            0x823A96B4 => {
    //   block [0x823A96B4..0x823A96CC)
	// 823A96B4: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 823A96B8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823A96BC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 823A96C0: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 823A96C4: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 823A96C8: 4082FFEC  bne 0x823a96b4
	if !ctx.cr[0].eq {
	pc = 0x823A96B4; continue 'dispatch;
	}
	pc = 0x823A96CC; continue 'dispatch;
            }
            0x823A96CC => {
    //   block [0x823A96CC..0x823A96F4)
	// 823A96CC: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 823A96D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823A96D4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 823A96D8: 7F0AC800  cmpw cr6, r10, r25
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[25].s32, &mut ctx.xer);
	// 823A96DC: 41990060  bgt cr6, 0x823a973c
	if ctx.cr[6].gt {
	pc = 0x823A973C; continue 'dispatch;
	}
	// 823A96E0: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823A96E4: 55481838  slwi r8, r10, 3
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823A96E8: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 823A96EC: 7D08EA14  add r8, r8, r29
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[29].u64;
	// 823A96F0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	pc = 0x823A96F4; continue 'dispatch;
            }
            0x823A96F4 => {
    //   block [0x823A96F4..0x823A9720)
	// 823A96F4: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 823A96F8: 40980078  bge cr6, 0x823a9770
	if !ctx.cr[6].lt {
	pc = 0x823A9770; continue 'dispatch;
	}
	// 823A96FC: C0060004  lfs f0, 4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823A9700: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 823A9704: C1A80004  lfs f13, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823A9708: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823A970C: 41990014  bgt cr6, 0x823a9720
	if ctx.cr[6].gt {
	pc = 0x823A9720; continue 'dispatch;
	}
	// 823A9710: E8860000  ld r4, 0(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 823A9714: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823A9718: 38C60008  addi r6, r6, 8
	ctx.r[6].s64 = ctx.r[6].s64 + 8;
	// 823A971C: 48000010  b 0x823a972c
	pc = 0x823A972C; continue 'dispatch;
            }
            0x823A9720 => {
    //   block [0x823A9720..0x823A972C)
	// 823A9720: E8880000  ld r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 823A9724: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823A9728: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	pc = 0x823A972C; continue 'dispatch;
            }
            0x823A972C => {
    //   block [0x823A972C..0x823A973C)
	// 823A972C: F88B0000  std r4, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 823A9730: 7F0AC800  cmpw cr6, r10, r25
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[25].s32, &mut ctx.xer);
	// 823A9734: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 823A9738: 4099FFBC  ble cr6, 0x823a96f4
	if !ctx.cr[6].gt {
	pc = 0x823A96F4; continue 'dispatch;
	}
	pc = 0x823A973C; continue 'dispatch;
            }
            0x823A973C => {
    //   block [0x823A973C..0x823A9758)
	// 823A973C: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 823A9740: 40980030  bge cr6, 0x823a9770
	if !ctx.cr[6].lt {
	pc = 0x823A9770; continue 'dispatch;
	}
	// 823A9744: 54EA1838  slwi r10, r7, 3
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823A9748: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823A974C: 7D0AEA14  add r8, r10, r29
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 823A9750: 7D4BE214  add r10, r11, r28
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 823A9754: 7D692850  subf r11, r9, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[9].s64;
	pc = 0x823A9758; continue 'dispatch;
            }
            0x823A9758 => {
    //   block [0x823A9758..0x823A9770)
	// 823A9758: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 823A975C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823A9760: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 823A9764: F9280000  std r9, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 823A9768: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 823A976C: 4082FFEC  bne 0x823a9758
	if !ctx.cr[0].eq {
	pc = 0x823A9758; continue 'dispatch;
	}
	pc = 0x823A9770; continue 'dispatch;
            }
            0x823A9770 => {
    //   block [0x823A9770..0x823A9778)
	// 823A9770: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823A9774: 4818B988  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A9778 size=76
    let mut pc: u32 = 0x823A9778;
    'dispatch: loop {
        match pc {
            0x823A9778 => {
    //   block [0x823A9778..0x823A97C4)
	// 823A9778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A977C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823A9780: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823A9784: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823A9788: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A978C: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823A9790: EBC30008  ld r30, 8(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 823A9794: 3BEB1E80  addi r31, r11, 0x1e80
	ctx.r[31].s64 = ctx.r[11].s64 + 7808;
	// 823A9798: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 823A979C: 48363AC1  bl 0x8270d25c
	ctx.lr = 0x823A97A0;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823A97A0: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 823A97A4: FBDF0010  std r30, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u64 ) };
	// 823A97A8: 48363AC5  bl 0x8270d26c
	ctx.lr = 0x823A97AC;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823A97AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823A97B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823A97B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823A97B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823A97BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823A97C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A97C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A97C8 size=336
    let mut pc: u32 = 0x823A97C8;
    'dispatch: loop {
        match pc {
            0x823A97C8 => {
    //   block [0x823A97C8..0x823A97EC)
	// 823A97C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A97CC: 4818B8F1  bl 0x825350bc
	ctx.lr = 0x823A97D0;
	sub_82535080(ctx, base);
	// 823A97D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A97D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823A97D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823A97DC: 3BDF58DC  addi r30, r31, 0x58dc
	ctx.r[30].s64 = ctx.r[31].s64 + 22748;
	// 823A97E0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823A97E4: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 823A97E8: 48000024  b 0x823a980c
	pc = 0x823A980C; continue 'dispatch;
            }
            0x823A97EC => {
    //   block [0x823A97EC..0x823A980C)
	// 823A97EC: 817F5900  lwz r11, 0x5900(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(22784 as u32) ) } as u64;
	// 823A97F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823A97F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823A97F8: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823A97FC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823A9800: 396B00A8  addi r11, r11, 0xa8
	ctx.r[11].s64 = ctx.r[11].s64 + 168;
	// 823A9804: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823A9808: 48000401  bl 0x823a9c08
	ctx.lr = 0x823A980C;
	sub_823A9C08(ctx, base);
	pc = 0x823A980C; continue 'dispatch;
            }
            0x823A980C => {
    //   block [0x823A980C..0x823A9834)
	// 823A980C: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 823A9810: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 823A9814: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823A9818: 409AFFD4  bne cr6, 0x823a97ec
	if !ctx.cr[6].eq {
	pc = 0x823A97EC; continue 'dispatch;
	}
	// 823A981C: 3BBF0018  addi r29, r31, 0x18
	ctx.r[29].s64 = ctx.r[31].s64 + 24;
	// 823A9820: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 823A9824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823A9828: 409A000C  bne cr6, 0x823a9834
	if !ctx.cr[6].eq {
	pc = 0x823A9834; continue 'dispatch;
	}
	// 823A982C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823A9830: 48363A5D  bl 0x8270d28c
	ctx.lr = 0x823A9834;
	// extern call 0x8270D28C → crate::xboxkrnl::RtlInitializeCriticalSection
	crate::xboxkrnl::RtlInitializeCriticalSection(ctx, base);
	pc = 0x823A9834; continue 'dispatch;
            }
            0x823A9834 => {
    //   block [0x823A9834..0x823A9918)
	// 823A9834: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 823A9838: 3CA07FFF  lis r5, 0x7fff
	ctx.r[5].s64 = 2147418112;
	// 823A983C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823A9840: 60A5FFFF  ori r5, r5, 0xffff
	ctx.r[5].u64 = ctx.r[5].u64 | 65535;
	// 823A9844: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823A9848: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823A984C: 93DD001C  stw r30, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 823A9850: 4819CFC1  bl 0x82546810
	ctx.lr = 0x823A9854;
	sub_82546810(ctx, base);
	// 823A9854: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823A9858: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823A985C: 93DF009C  stw r30, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 823A9860: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823A9864: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823A9868: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823A986C: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 823A9870: 48017C09  bl 0x823c1478
	ctx.lr = 0x823A9874;
	sub_823C1478(ctx, base);
	// 823A9874: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A9878: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 823A987C: 907F00A0  stw r3, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[3].u32 ) };
	// 823A9880: 392B06B8  addi r9, r11, 0x6b8
	ctx.r[9].s64 = ctx.r[11].s64 + 1720;
	// 823A9884: 93DF00A4  stw r30, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 823A9888: 3D60823B  lis r11, -0x7dc5
	ctx.r[11].s64 = -2110062592;
	// 823A988C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823A9890: 38E02000  li r7, 0x2000
	ctx.r[7].s64 = 8192;
	// 823A9894: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 823A9898: 915F0088  stw r10, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 823A989C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823A98A0: 388B9918  addi r4, r11, -0x66e8
	ctx.r[4].s64 = ctx.r[11].s64 + -26344;
	// 823A98A4: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 823A98A8: 4BFF4141  bl 0x8239d9e8
	ctx.lr = 0x823A98AC;
	sub_8239D9E8(ctx, base);
	// 823A98AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A98B0: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 823A98B4: 392B06E0  addi r9, r11, 0x6e0
	ctx.r[9].s64 = ctx.r[11].s64 + 1760;
	// 823A98B8: 3D60823B  lis r11, -0x7dc5
	ctx.r[11].s64 = -2110062592;
	// 823A98BC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823A98C0: 38E02000  li r7, 0x2000
	ctx.r[7].s64 = 8192;
	// 823A98C4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 823A98C8: 915F0068  stw r10, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 823A98CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823A98D0: 388B9918  addi r4, r11, -0x66e8
	ctx.r[4].s64 = ctx.r[11].s64 + -26344;
	// 823A98D4: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 823A98D8: 4BFF4111  bl 0x8239d9e8
	ctx.lr = 0x823A98DC;
	sub_8239D9E8(ctx, base);
	// 823A98DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A98E0: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 823A98E4: 392B0708  addi r9, r11, 0x708
	ctx.r[9].s64 = ctx.r[11].s64 + 1800;
	// 823A98E8: 3D60823B  lis r11, -0x7dc5
	ctx.r[11].s64 = -2110062592;
	// 823A98EC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823A98F0: 38E02000  li r7, 0x2000
	ctx.r[7].s64 = 8192;
	// 823A98F4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 823A98F8: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 823A98FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823A9900: 388B9918  addi r4, r11, -0x66e8
	ctx.r[4].s64 = ctx.r[11].s64 + -26344;
	// 823A9904: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 823A9908: 4BFF40E1  bl 0x8239d9e8
	ctx.lr = 0x823A990C;
	sub_8239D9E8(ctx, base);
	// 823A990C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823A9910: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823A9914: 4818B7F8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A9920 size=436
    let mut pc: u32 = 0x823A9920;
    'dispatch: loop {
        match pc {
            0x823A9920 => {
    //   block [0x823A9920..0x823A9934)
	// 823A9920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A9924: 4818B799  bl 0x825350bc
	ctx.lr = 0x823A9928;
	sub_82535080(ctx, base);
	// 823A9928: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A992C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823A9930: 3BBF0018  addi r29, r31, 0x18
	ctx.r[29].s64 = ctx.r[31].s64 + 24;
	pc = 0x823A9934; continue 'dispatch;
            }
            0x823A9934 => {
    //   block [0x823A9934..0x823A9954)
	// 823A9934: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 823A9938: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 823A993C: 48017BDD  bl 0x823c1518
	ctx.lr = 0x823A9940;
	sub_823C1518(ctx, base);
	// 823A9940: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823A9944: 48363919  bl 0x8270d25c
	ctx.lr = 0x823A9948;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823A9948: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823A994C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823A9950: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x823A9954; continue 'dispatch;
            }
            0x823A9954 => {
    //   block [0x823A9954..0x823A99C0)
	// 823A9954: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823A9958: 48363915  bl 0x8270d26c
	ctx.lr = 0x823A995C;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823A995C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823A9960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823A9964: 409A0164  bne cr6, 0x823a9ac8
	if !ctx.cr[6].eq {
	pc = 0x823A9AC8; continue 'dispatch;
	}
	// 823A9968: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823A996C: 483638F1  bl 0x8270d25c
	ctx.lr = 0x823A9970;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823A9970: 817F40CC  lwz r11, 0x40cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16588 as u32) ) } as u64;
	// 823A9974: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823A9978: 419A0130  beq cr6, 0x823a9aa8
	if ctx.cr[6].eq {
	pc = 0x823A9AA8; continue 'dispatch;
	}
	// 823A997C: 817F40D0  lwz r11, 0x40d0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16592 as u32) ) } as u64;
	// 823A9980: 393F40A8  addi r9, r31, 0x40a8
	ctx.r[9].s64 = ctx.r[31].s64 + 16552;
	// 823A9984: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9988: 39690018  addi r11, r9, 0x18
	ctx.r[11].s64 = ctx.r[9].s64 + 24;
	// 823A998C: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823A9990: 83CA0008  lwz r30, 8(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823A9994: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9998: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 823A999C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 823A99A0: 409A0020  bne cr6, 0x823a99c0
	if !ctx.cr[6].eq {
	pc = 0x823A99C0; continue 'dispatch;
	}
	// 823A99A4: 54E7003E  slwi r7, r7, 0
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 823A99A8: 80E70004  lwz r7, 4(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 823A99AC: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 823A99B0: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823A99B4: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A99B8: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823A99BC: 48000048  b 0x823a9a04
	pc = 0x823A9A04; continue 'dispatch;
            }
            0x823A99C0 => {
    //   block [0x823A99C0..0x823A99EC)
	// 823A99C0: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A99C4: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A99C8: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 823A99CC: 409A0020  bne cr6, 0x823a99ec
	if !ctx.cr[6].eq {
	pc = 0x823A99EC; continue 'dispatch;
	}
	// 823A99D0: 54E7003E  slwi r7, r7, 0
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 823A99D4: 80E70000  lwz r7, 0(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A99D8: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 823A99DC: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A99E0: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A99E4: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823A99E8: 4800001C  b 0x823a9a04
	pc = 0x823A9A04; continue 'dispatch;
            }
            0x823A99EC => {
    //   block [0x823A99EC..0x823A9A04)
	// 823A99EC: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A99F0: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823A99F4: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 823A99F8: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823A99FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9A00: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	pc = 0x823A9A04; continue 'dispatch;
            }
            0x823A9A04 => {
    //   block [0x823A9A04..0x823A9A2C)
	// 823A9A04: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823A9A08: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 823A9A0C: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 823A9A10: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 823A9A14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823A9A18: 409A0014  bne cr6, 0x823a9a2c
	if !ctx.cr[6].eq {
	pc = 0x823A9A2C; continue 'dispatch;
	}
	// 823A9A1C: 81690010  lwz r11, 0x10(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 823A9A20: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823A9A24: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823A9A28: 4800001C  b 0x823a9a44
	pc = 0x823A9A44; continue 'dispatch;
            }
            0x823A9A2C => {
    //   block [0x823A9A2C..0x823A9A44)
	// 823A9A2C: 81690014  lwz r11, 0x14(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A9A30: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9A34: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823A9A38: 81690014  lwz r11, 0x14(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A9A3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9A40: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823A9A44; continue 'dispatch;
            }
            0x823A9A44 => {
    //   block [0x823A9A44..0x823A9AA8)
	// 823A9A44: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823A9A48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823A9A4C: 81690014  lwz r11, 0x14(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A9A50: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823A9A54: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 823A9A58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823A9A5C: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823A9A60: 4836380D  bl 0x8270d26c
	ctx.lr = 0x823A9A64;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823A9A64: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9A68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823A9A6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823A9A70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823A9A74: 4E800421  bctrl
	ctx.lr = 0x823A9A78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823A9A78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823A9A7C: 483637E1  bl 0x8270d25c
	ctx.lr = 0x823A9A80;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823A9A80: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9A84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823A9A88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823A9A8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9A90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823A9A94: 4E800421  bctrl
	ctx.lr = 0x823A9A98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823A9A98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823A9A9C: 387F58DC  addi r3, r31, 0x58dc
	ctx.r[3].s64 = ctx.r[31].s64 + 22748;
	// 823A9AA0: 48000169  bl 0x823a9c08
	ctx.lr = 0x823A9AA4;
	sub_823A9C08(ctx, base);
	// 823A9AA4: 4BFFFEB0  b 0x823a9954
	pc = 0x823A9954; continue 'dispatch;
            }
            0x823A9AA8 => {
    //   block [0x823A9AA8..0x823A9AC8)
	// 823A9AA8: 807F00A0  lwz r3, 0xa0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 823A9AAC: 48017A75  bl 0x823c1520
	ctx.lr = 0x823A9AB0;
	sub_823C1520(ctx, base);
	// 823A9AB0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823A9AB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823A9AB8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823A9ABC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823A9AC0: 483637AD  bl 0x8270d26c
	ctx.lr = 0x823A9AC4;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823A9AC4: 4BFFFE70  b 0x823a9934
	pc = 0x823A9934; continue 'dispatch;
            }
            0x823A9AC8 => {
    //   block [0x823A9AC8..0x823A9AD4)
	// 823A9AC8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823A9ACC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823A9AD0: 4818B63C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A9AD8 size=200
    let mut pc: u32 = 0x823A9AD8;
    'dispatch: loop {
        match pc {
            0x823A9AD8 => {
    //   block [0x823A9AD8..0x823A9B5C)
	// 823A9AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A9ADC: 4818B5E1  bl 0x825350bc
	ctx.lr = 0x823A9AE0;
	sub_82535080(ctx, base);
	// 823A9AE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A9AE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823A9AE8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823A9AEC: 3BBF0018  addi r29, r31, 0x18
	ctx.r[29].s64 = ctx.r[31].s64 + 24;
	// 823A9AF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823A9AF4: 48363769  bl 0x8270d25c
	ctx.lr = 0x823A9AF8;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823A9AF8: 817F5900  lwz r11, 0x5900(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(22784 as u32) ) } as u64;
	// 823A9AFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823A9B00: 419A008C  beq cr6, 0x823a9b8c
	if ctx.cr[6].eq {
	pc = 0x823A9B8C; continue 'dispatch;
	}
	// 823A9B04: 817F5904  lwz r11, 0x5904(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(22788 as u32) ) } as u64;
	// 823A9B08: 395F58DC  addi r10, r31, 0x58dc
	ctx.r[10].s64 = ctx.r[31].s64 + 22748;
	// 823A9B0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9B10: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823A9B14: 396A0018  addi r11, r10, 0x18
	ctx.r[11].s64 = ctx.r[10].s64 + 24;
	// 823A9B18: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823A9B1C: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9B20: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 823A9B24: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 823A9B28: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823A9B2C: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9B30: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823A9B34: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823A9B38: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 823A9B3C: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 823A9B40: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823A9B44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823A9B48: 409A0014  bne cr6, 0x823a9b5c
	if !ctx.cr[6].eq {
	pc = 0x823A9B5C; continue 'dispatch;
	}
	// 823A9B4C: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 823A9B50: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823A9B54: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823A9B58: 4800001C  b 0x823a9b74
	pc = 0x823A9B74; continue 'dispatch;
            }
            0x823A9B5C => {
    //   block [0x823A9B5C..0x823A9B74)
	// 823A9B5C: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A9B60: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9B64: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823A9B68: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A9B6C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9B70: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823A9B74; continue 'dispatch;
            }
            0x823A9B74 => {
    //   block [0x823A9B74..0x823A9B8C)
	// 823A9B74: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823A9B78: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A9B7C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823A9B80: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823A9B84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823A9B88: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x823A9B8C; continue 'dispatch;
            }
            0x823A9B8C => {
    //   block [0x823A9B8C..0x823A9BA0)
	// 823A9B8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823A9B90: 483636DD  bl 0x8270d26c
	ctx.lr = 0x823A9B94;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823A9B94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823A9B98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823A9B9C: 4818B570  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A9BA0 size=104
    let mut pc: u32 = 0x823A9BA0;
    'dispatch: loop {
        match pc {
            0x823A9BA0 => {
    //   block [0x823A9BA0..0x823A9C08)
	// 823A9BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A9BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823A9BA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823A9BAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823A9BB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A9BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823A9BB8: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 823A9BBC: 3BDF0018  addi r30, r31, 0x18
	ctx.r[30].s64 = ctx.r[31].s64 + 24;
	// 823A9BC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823A9BC4: 48363699  bl 0x8270d25c
	ctx.lr = 0x823A9BC8;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823A9BC8: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 823A9BCC: 387F40A8  addi r3, r31, 0x40a8
	ctx.r[3].s64 = ctx.r[31].s64 + 16552;
	// 823A9BD0: 48000039  bl 0x823a9c08
	ctx.lr = 0x823A9BD4;
	sub_823A9C08(ctx, base);
	// 823A9BD4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823A9BD8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823A9BDC: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 823A9BE0: 4819CCC9  bl 0x825468a8
	ctx.lr = 0x823A9BE4;
	sub_825468A8(ctx, base);
	// 823A9BE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823A9BE8: 48363685  bl 0x8270d26c
	ctx.lr = 0x823A9BEC;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823A9BEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823A9BF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823A9BF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823A9BF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823A9BFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823A9C00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823A9C04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823A9C08 size=132
    let mut pc: u32 = 0x823A9C08;
    'dispatch: loop {
        match pc {
            0x823A9C08 => {
    //   block [0x823A9C08..0x823A9C58)
	// 823A9C08: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A9C0C: 39630018  addi r11, r3, 0x18
	ctx.r[11].s64 = ctx.r[3].s64 + 24;
	// 823A9C10: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9C14: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9C18: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823A9C1C: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A9C20: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9C24: 90690004  stw r3, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 823A9C28: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823A9C2C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823A9C30: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 823A9C34: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9C38: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 823A9C3C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823A9C40: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823A9C44: 409A0014  bne cr6, 0x823a9c58
	if !ctx.cr[6].eq {
	pc = 0x823A9C58; continue 'dispatch;
	}
	// 823A9C48: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823A9C4C: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823A9C50: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823A9C54: 4800001C  b 0x823a9c70
	pc = 0x823A9C70; continue 'dispatch;
            }
            0x823A9C58 => {
    //   block [0x823A9C58..0x823A9C70)
	// 823A9C58: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A9C5C: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9C60: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823A9C64: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A9C68: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9C6C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x823A9C70; continue 'dispatch;
            }
            0x823A9C70 => {
    //   block [0x823A9C70..0x823A9C8C)
	// 823A9C70: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823A9C74: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A9C78: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823A9C7C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823A9C80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823A9C84: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 823A9C88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A9C90 size=148
    let mut pc: u32 = 0x823A9C90;
    'dispatch: loop {
        match pc {
            0x823A9C90 => {
    //   block [0x823A9C90..0x823A9D14)
	// 823A9C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A9C94: 4818B429  bl 0x825350bc
	ctx.lr = 0x823A9C98;
	sub_82535080(ctx, base);
	// 823A9C98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A9C9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823A9CA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9CA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823A9CA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823A9CAC: 4E800421  bctrl
	ctx.lr = 0x823A9CB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823A9CB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823A9CB4: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 823A9CB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823A9CBC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 823A9CC0: 4836359D  bl 0x8270d25c
	ctx.lr = 0x823A9CC4;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823A9CC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823A9CC8: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 823A9CCC: 483635A1  bl 0x8270d26c
	ctx.lr = 0x823A9CD0;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823A9CD0: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823A9CD4: 396BD180  addi r11, r11, -0x2e80
	ctx.r[11].s64 = ctx.r[11].s64 + -11904;
	// 823A9CD8: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823A9CDC: 7C0057EC  dcbz 0, r10
	ea.u32 = ctx.r[10].u32;
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823A9CE0: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823A9CE4: 392A0080  addi r9, r10, 0x80
	ctx.r[9].s64 = ctx.r[10].s64 + 128;
	// 823A9CE8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823A9CEC: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 823A9CF0: 41820024  beq 0x823a9d14
	if ctx.cr[0].eq {
	pc = 0x823A9D14; continue 'dispatch;
	}
	// 823A9CF4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A9CF8: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823A9CFC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823A9D00: 396B073C  addi r11, r11, 0x73c
	ctx.r[11].s64 = ctx.r[11].s64 + 1852;
	// 823A9D04: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 823A9D08: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823A9D0C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823A9D10: 48000008  b 0x823a9d18
	pc = 0x823A9D18; continue 'dispatch;
            }
            0x823A9D14 => {
    //   block [0x823A9D14..0x823A9D18)
	// 823A9D14: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x823A9D18; continue 'dispatch;
            }
            0x823A9D18 => {
    //   block [0x823A9D18..0x823A9D24)
	// 823A9D18: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 823A9D1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823A9D20: 4818B3EC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A9D28 size=124
    let mut pc: u32 = 0x823A9D28;
    'dispatch: loop {
        match pc {
            0x823A9D28 => {
    //   block [0x823A9D28..0x823A9D94)
	// 823A9D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A9D2C: 4818B391  bl 0x825350bc
	ctx.lr = 0x823A9D30;
	sub_82535080(ctx, base);
	// 823A9D30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A9D34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823A9D38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9D3C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823A9D40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823A9D44: 4E800421  bctrl
	ctx.lr = 0x823A9D48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823A9D48: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 823A9D4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823A9D50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823A9D54: 48363509  bl 0x8270d25c
	ctx.lr = 0x823A9D58;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823A9D58: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823A9D5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823A9D60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9D64: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823A9D68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823A9D6C: 4E800421  bctrl
	ctx.lr = 0x823A9D70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823A9D70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823A9D74: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 823A9D78: 483634F5  bl 0x8270d26c
	ctx.lr = 0x823A9D7C;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823A9D7C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823A9D80: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823A9D84: 41820010  beq 0x823a9d94
	if ctx.cr[0].eq {
	pc = 0x823A9D94; continue 'dispatch;
	}
	// 823A9D88: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823A9D8C: 386BD180  addi r3, r11, -0x2e80
	ctx.r[3].s64 = ctx.r[11].s64 + -11904;
	// 823A9D90: 4BFF5FA1  bl 0x8239fd30
	ctx.lr = 0x823A9D94;
	sub_8239FD30(ctx, base);
            }
            0x823A9D94 => {
    //   block [0x823A9D94..0x823A9DA4)
	// 823A9D94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823A9D98: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823A9D9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823A9DA0: 4818B36C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A9DA8 size=100
    let mut pc: u32 = 0x823A9DA8;
    'dispatch: loop {
        match pc {
            0x823A9DA8 => {
    //   block [0x823A9DA8..0x823A9DC4)
	// 823A9DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A9DAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823A9DB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823A9DB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A9DB8: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823A9DBC: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823A9DC0: 41820034  beq 0x823a9df4
	if ctx.cr[0].eq {
	pc = 0x823A9DF4; continue 'dispatch;
	}
	pc = 0x823A9DC4; continue 'dispatch;
            }
            0x823A9DC4 => {
    //   block [0x823A9DC4..0x823A9DF4)
	// 823A9DC4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823A9DCC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823A9DD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823A9DD4: 4E800421  bctrl
	ctx.lr = 0x823A9DD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823A9DD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823A9DE0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823A9DE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823A9DE8: 4E800421  bctrl
	ctx.lr = 0x823A9DEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823A9DEC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823A9DF0: 4082FFD4  bne 0x823a9dc4
	if !ctx.cr[0].eq {
	pc = 0x823A9DC4; continue 'dispatch;
	}
            }
            0x823A9DF4 => {
    //   block [0x823A9DF4..0x823A9E0C)
	// 823A9DF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823A9DF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823A9DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823A9E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823A9E04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823A9E08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A9E10 size=64
    let mut pc: u32 = 0x823A9E10;
    'dispatch: loop {
        match pc {
            0x823A9E10 => {
    //   block [0x823A9E10..0x823A9E50)
	// 823A9E10: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823A9E14: 396BD180  addi r11, r11, -0x2e80
	ctx.r[11].s64 = ctx.r[11].s64 + -11904;
	// 823A9E18: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823A9E1C: 7C0057EC  dcbz 0, r10
	ea.u32 = ctx.r[10].u32;
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823A9E20: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823A9E24: 392A0080  addi r9, r10, 0x80
	ctx.r[9].s64 = ctx.r[10].s64 + 128;
	// 823A9E28: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823A9E2C: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 823A9E30: 41820020  beq 0x823a9e50
	if ctx.cr[0].eq {
		sub_823A9E50(ctx, base);
		return;
	}
	// 823A9E34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A9E38: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823A9E3C: 396B19A4  addi r11, r11, 0x19a4
	ctx.r[11].s64 = ctx.r[11].s64 + 6564;
	// 823A9E40: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 823A9E44: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823A9E48: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823A9E4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823A9E50 size=8
    let mut pc: u32 = 0x823A9E50;
    'dispatch: loop {
        match pc {
            0x823A9E50 => {
    //   block [0x823A9E50..0x823A9E58)
	// 823A9E50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823A9E54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823A9E58 size=272
    let mut pc: u32 = 0x823A9E58;
    'dispatch: loop {
        match pc {
            0x823A9E58 => {
    //   block [0x823A9E58..0x823A9E90)
	// 823A9E58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823A9E5C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823A9E60: 396B0758  addi r11, r11, 0x758
	ctx.r[11].s64 = ctx.r[11].s64 + 1880;
	// 823A9E64: 35030008  addic. r8, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[8].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823A9E68: 38A3000C  addi r5, r3, 0xc
	ctx.r[5].s64 = ctx.r[3].s64 + 12;
	// 823A9E6C: 38C3001C  addi r6, r3, 0x1c
	ctx.r[6].s64 = ctx.r[3].s64 + 28;
	// 823A9E70: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823A9E74: 38E30018  addi r7, r3, 0x18
	ctx.r[7].s64 = ctx.r[3].s64 + 24;
	// 823A9E78: 39230014  addi r9, r3, 0x14
	ctx.r[9].s64 = ctx.r[3].s64 + 20;
	// 823A9E7C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823A9E80: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 823A9E84: 4182000C  beq 0x823a9e90
	if ctx.cr[0].eq {
	pc = 0x823A9E90; continue 'dispatch;
	}
	// 823A9E88: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823A9E8C: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823A9E90; continue 'dispatch;
            }
            0x823A9E90 => {
    //   block [0x823A9E90..0x823A9EA0)
	// 823A9E90: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 823A9E94: 419A000C  beq cr6, 0x823a9ea0
	if ctx.cr[6].eq {
	pc = 0x823A9EA0; continue 'dispatch;
	}
	// 823A9E98: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823A9E9C: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823A9EA0; continue 'dispatch;
            }
            0x823A9EA0 => {
    //   block [0x823A9EA0..0x823A9EB0)
	// 823A9EA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823A9EA4: 419A000C  beq cr6, 0x823a9eb0
	if ctx.cr[6].eq {
	pc = 0x823A9EB0; continue 'dispatch;
	}
	// 823A9EA8: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823A9EAC: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823A9EB0; continue 'dispatch;
            }
            0x823A9EB0 => {
    //   block [0x823A9EB0..0x823A9EC0)
	// 823A9EB0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823A9EB4: 419A000C  beq cr6, 0x823a9ec0
	if ctx.cr[6].eq {
	pc = 0x823A9EC0; continue 'dispatch;
	}
	// 823A9EB8: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823A9EBC: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823A9EC0; continue 'dispatch;
            }
            0x823A9EC0 => {
    //   block [0x823A9EC0..0x823A9ED0)
	// 823A9EC0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 823A9EC4: 419A000C  beq cr6, 0x823a9ed0
	if ctx.cr[6].eq {
	pc = 0x823A9ED0; continue 'dispatch;
	}
	// 823A9EC8: C0040010  lfs f0, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823A9ECC: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823A9ED0; continue 'dispatch;
            }
            0x823A9ED0 => {
    //   block [0x823A9ED0..0x823A9EE0)
	// 823A9ED0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 823A9ED4: 419A000C  beq cr6, 0x823a9ee0
	if ctx.cr[6].eq {
	pc = 0x823A9EE0; continue 'dispatch;
	}
	// 823A9ED8: C0040014  lfs f0, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823A9EDC: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823A9EE0; continue 'dispatch;
            }
            0x823A9EE0 => {
    //   block [0x823A9EE0..0x823A9EFC)
	// 823A9EE0: 35630020  addic. r11, r3, 0x20
	ctx.xer.ca = (ctx.r[3].u32 > (!(32 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823A9EE4: 39430024  addi r10, r3, 0x24
	ctx.r[10].s64 = ctx.r[3].s64 + 36;
	// 823A9EE8: 38E3002C  addi r7, r3, 0x2c
	ctx.r[7].s64 = ctx.r[3].s64 + 44;
	// 823A9EEC: 39230028  addi r9, r3, 0x28
	ctx.r[9].s64 = ctx.r[3].s64 + 40;
	// 823A9EF0: 4182000C  beq 0x823a9efc
	if ctx.cr[0].eq {
	pc = 0x823A9EFC; continue 'dispatch;
	}
	// 823A9EF4: C0040018  lfs f0, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823A9EF8: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823A9EFC; continue 'dispatch;
            }
            0x823A9EFC => {
    //   block [0x823A9EFC..0x823A9F0C)
	// 823A9EFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823A9F00: 419A000C  beq cr6, 0x823a9f0c
	if ctx.cr[6].eq {
	pc = 0x823A9F0C; continue 'dispatch;
	}
	// 823A9F04: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823A9F08: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823A9F0C; continue 'dispatch;
            }
            0x823A9F0C => {
    //   block [0x823A9F0C..0x823A9F1C)
	// 823A9F0C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823A9F10: 419A000C  beq cr6, 0x823a9f1c
	if ctx.cr[6].eq {
	pc = 0x823A9F1C; continue 'dispatch;
	}
	// 823A9F14: C0040020  lfs f0, 0x20(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823A9F18: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823A9F1C; continue 'dispatch;
            }
            0x823A9F1C => {
    //   block [0x823A9F1C..0x823A9F2C)
	// 823A9F1C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 823A9F20: 419A000C  beq cr6, 0x823a9f2c
	if ctx.cr[6].eq {
	pc = 0x823A9F2C; continue 'dispatch;
	}
	// 823A9F24: C0040024  lfs f0, 0x24(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823A9F28: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823A9F2C; continue 'dispatch;
            }
            0x823A9F2C => {
    //   block [0x823A9F2C..0x823A9F68)
	// 823A9F2C: C0040038  lfs f0, 0x38(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823A9F30: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823A9F34: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823A9F38: ED80602A  fadds f12, f0, f12
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 823A9F3C: C1A4003C  lfs f13, 0x3c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823A9F40: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 823A9F44: C1650000  lfs f11, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823A9F48: C12A0000  lfs f9, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823A9F4C: D1880000  stfs f12, 0(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823A9F50: ED8B682A  fadds f12, f11, f13
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 823A9F54: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823A9F58: EC0D482A  fadds f0, f13, f9
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64;
	// 823A9F5C: D1850000  stfs f12, 0(r5)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823A9F60: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823A9F64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823A9F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823A9F68 size=160
    let mut pc: u32 = 0x823A9F68;
    'dispatch: loop {
        match pc {
            0x823A9F68 => {
    //   block [0x823A9F68..0x823A9FB0)
	// 823A9F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823A9F6C: 4818B14D  bl 0x825350b8
	ctx.lr = 0x823A9F70;
	sub_82535080(ctx, base);
	// 823A9F70: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823A9F74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823A9F78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823A9F7C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823A9F80: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823A9F84: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823A9F88: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9F8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823A9F90: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 823A9F94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823A9F98: 4E800421  bctrl
	ctx.lr = 0x823A9F9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823A9F9C: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823A9FA0: 40820010  bne 0x823a9fb0
	if !ctx.cr[0].eq {
	pc = 0x823A9FB0; continue 'dispatch;
	}
	// 823A9FA4: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823A9FA8: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 823A9FAC: 48000054  b 0x823aa000
	pc = 0x823AA000; continue 'dispatch;
            }
            0x823A9FB0 => {
    //   block [0x823A9FB0..0x823AA000)
	// 823A9FB0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823A9FB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823A9FB8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823A9FBC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 823A9FC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823A9FC4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823A9FC8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 823A9FCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823A9FD0: 4E800421  bctrl
	ctx.lr = 0x823A9FD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823A9FD4: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 823A9FD8: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 823A9FDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823A9FE0: 8121007C  lwz r9, 0x7c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 823A9FE4: 81010078  lwz r8, 0x78(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 823A9FE8: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 823A9FEC: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 823A9FF0: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 823A9FF4: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 823A9FF8: 913F001C  stw r9, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 823A9FFC: 911F0018  stw r8, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
            }
            0x823AA000 => {
    //   block [0x823AA000..0x823AA008)
	// 823AA000: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823AA004: 4818B104  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AA008 size=184
    let mut pc: u32 = 0x823AA008;
    'dispatch: loop {
        match pc {
            0x823AA008 => {
    //   block [0x823AA008..0x823AA050)
	// 823AA008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AA00C: 4818B0A9  bl 0x825350b4
	ctx.lr = 0x823AA010;
	sub_82535080(ctx, base);
	// 823AA010: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AA014: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823AA018: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AA01C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 823AA020: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 823AA024: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AA028: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AA02C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AA030: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 823AA034: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AA038: 4E800421  bctrl
	ctx.lr = 0x823AA03C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AA03C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823AA040: 40820010  bne 0x823aa050
	if !ctx.cr[0].eq {
	pc = 0x823AA050; continue 'dispatch;
	}
	// 823AA044: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823AA048: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 823AA04C: 4800006C  b 0x823aa0b8
	pc = 0x823AA0B8; continue 'dispatch;
            }
            0x823AA050 => {
    //   block [0x823AA050..0x823AA0B8)
	// 823AA050: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AA054: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823AA058: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823AA05C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 823AA060: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823AA064: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AA068: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AA06C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 823AA070: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AA074: 4E800421  bctrl
	ctx.lr = 0x823AA078;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AA078: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AA07C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823AA080: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AA084: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AA088: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AA08C: 4E800421  bctrl
	ctx.lr = 0x823AA090;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AA090: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 823AA094: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 823AA098: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 823AA09C: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 823AA0A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AA0A4: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 823AA0A8: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 823AA0AC: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 823AA0B0: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 823AA0B4: 913F0018  stw r9, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
            }
            0x823AA0B8 => {
    //   block [0x823AA0B8..0x823AA0C0)
	// 823AA0B8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823AA0BC: 4818B048  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823AA0C0 size=376
    let mut pc: u32 = 0x823AA0C0;
    'dispatch: loop {
        match pc {
            0x823AA0C0 => {
    //   block [0x823AA0C0..0x823AA138)
	// 823AA0C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AA0C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AA0C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823AA0CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AA0D0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AA0D4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 823AA0D8: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AA0DC: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 823AA0E0: 396B0700  addi r11, r11, 0x700
	ctx.r[11].s64 = ctx.r[11].s64 + 1792;
	// 823AA0E4: 81480014  lwz r10, 0x14(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AA0E8: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 823AA0EC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AA0F0: 409A00A0  bne cr6, 0x823aa190
	if !ctx.cr[6].eq {
	pc = 0x823AA190; continue 'dispatch;
	}
	// 823AA0F4: 83E8001C  lwz r31, 0x1c(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AA0F8: 80C80018  lwz r6, 0x18(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AA0FC: 2B1F0004  cmplwi cr6, r31, 4
	ctx.cr[6].compare_u32(ctx.r[31].u32, 4 as u32, &mut ctx.xer);
	// 823AA100: 409A0038  bne cr6, 0x823aa138
	if !ctx.cr[6].eq {
	pc = 0x823AA138; continue 'dispatch;
	}
	// 823AA104: 81680010  lwz r11, 0x10(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AA108: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823AA10C: 7D2B3214  add r9, r11, r6
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 823AA110: 7948FFE6  rldicr r8, r10, 0x3f, 0x3f
	ctx.r[8].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 823AA114: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823AA118: 556AF0BE  srwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AA11C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 823AA120: 552BF0BE  srwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823AA124: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 823AA128: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 823AA12C: 7D0B5E34  srad r11, r8, r11
	tmp.u64 = (ctx.r[11].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[8].s64 < 0) && ((ctx.r[8].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[11].s64 = ctx.r[8].s64 >> tmp.u64;
	// 823AA130: 7D675436  srd r7, r11, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[11].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 823AA134: 480000E8  b 0x823aa21c
	pc = 0x823AA21C; continue 'dispatch;
            }
            0x823AA138 => {
    //   block [0x823AA138..0x823AA14C)
	// 823AA138: 28060000  cmplwi r6, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA13C: 4182004C  beq 0x823aa188
	if ctx.cr[0].eq {
	pc = 0x823AA188; continue 'dispatch;
	}
	// 823AA140: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823AA144: 57FE103A  slwi r30, r31, 2
	ctx.r[30].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 823AA148: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	pc = 0x823AA14C; continue 'dispatch;
            }
            0x823AA14C => {
    //   block [0x823AA14C..0x823AA160)
	// 823AA14C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823AA150: 419A0028  beq cr6, 0x823aa178
	if ctx.cr[6].eq {
	pc = 0x823AA178; continue 'dispatch;
	}
	// 823AA154: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 823AA158: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 823AA15C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x823AA160; continue 'dispatch;
            }
            0x823AA160 => {
    //   block [0x823AA160..0x823AA178)
	// 823AA160: C0090000  lfs f0, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AA164: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AA168: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823AA16C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823AA170: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823AA174: 4082FFEC  bne 0x823aa160
	if !ctx.cr[0].eq {
	pc = 0x823AA160; continue 'dispatch;
	}
	pc = 0x823AA178; continue 'dispatch;
            }
            0x823AA178 => {
    //   block [0x823AA178..0x823AA188)
	// 823AA178: 3484FFFF  addic. r4, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823AA17C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 823AA180: 7CBE2A14  add r5, r30, r5
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[5].u64;
	// 823AA184: 4082FFC8  bne 0x823aa14c
	if !ctx.cr[0].eq {
	pc = 0x823AA14C; continue 'dispatch;
	}
	pc = 0x823AA188; continue 'dispatch;
            }
            0x823AA188 => {
    //   block [0x823AA188..0x823AA190)
	// 823AA188: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823AA18C: 48000064  b 0x823aa1f0
	pc = 0x823AA1F0; continue 'dispatch;
            }
            0x823AA190 => {
    //   block [0x823AA190..0x823AA1A8)
	// 823AA190: 80880018  lwz r4, 0x18(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AA194: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA198: 41820050  beq 0x823aa1e8
	if ctx.cr[0].eq {
	pc = 0x823AA1E8; continue 'dispatch;
	}
	// 823AA19C: 83E8001C  lwz r31, 0x1c(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AA1A0: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 823AA1A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	pc = 0x823AA1A8; continue 'dispatch;
            }
            0x823AA1A8 => {
    //   block [0x823AA1A8..0x823AA1C0)
	// 823AA1A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823AA1AC: 419A002C  beq cr6, 0x823aa1d8
	if ctx.cr[6].eq {
	pc = 0x823AA1D8; continue 'dispatch;
	}
	// 823AA1B0: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 823AA1B4: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 823AA1B8: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 823AA1BC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x823AA1C0; continue 'dispatch;
            }
            0x823AA1C0 => {
    //   block [0x823AA1C0..0x823AA1D8)
	// 823AA1C0: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AA1C4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AA1C8: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823AA1CC: 7D465214  add r10, r6, r10
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 823AA1D0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823AA1D4: 4082FFEC  bne 0x823aa1c0
	if !ctx.cr[0].eq {
	pc = 0x823AA1C0; continue 'dispatch;
	}
	pc = 0x823AA1D8; continue 'dispatch;
            }
            0x823AA1D8 => {
    //   block [0x823AA1D8..0x823AA1E8)
	// 823AA1D8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823AA1DC: 38E70010  addi r7, r7, 0x10
	ctx.r[7].s64 = ctx.r[7].s64 + 16;
	// 823AA1E0: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 823AA1E4: 4082FFC4  bne 0x823aa1a8
	if !ctx.cr[0].eq {
	pc = 0x823AA1A8; continue 'dispatch;
	}
	pc = 0x823AA1E8; continue 'dispatch;
            }
            0x823AA1E8 => {
    //   block [0x823AA1E8..0x823AA1F0)
	// 823AA1E8: 80C8001C  lwz r6, 0x1c(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AA1EC: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	pc = 0x823AA1F0; continue 'dispatch;
            }
            0x823AA1F0 => {
    //   block [0x823AA1F0..0x823AA21C)
	// 823AA1F0: 80880010  lwz r4, 0x10(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AA1F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823AA1F8: 7D443214  add r10, r4, r6
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[6].u64;
	// 823AA1FC: 7969FFE6  rldicr r9, r11, 0x3f, 0x3f
	ctx.r[9].u64 = (ctx.r[11].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 823AA200: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823AA204: 548BF0BE  srwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823AA208: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AA20C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823AA210: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 823AA214: 7D2A5634  srad r10, r9, r10
	tmp.u64 = (ctx.r[10].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[9].s64 < 0) && ((ctx.r[9].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[10].s64 = ctx.r[9].s64 >> tmp.u64;
	// 823AA218: 7D475C36  srd r7, r10, r11
	if (ctx.r[11].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[10].u64) >> ((ctx.r[11].u8 & 0x3F) as u32);
	}
	pc = 0x823AA21C; continue 'dispatch;
            }
            0x823AA21C => {
    //   block [0x823AA21C..0x823AA238)
	// 823AA21C: 4802CFA5  bl 0x823d71c0
	ctx.lr = 0x823AA220;
	sub_823D71C0(ctx, base);
	// 823AA220: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 823AA224: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AA228: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AA22C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823AA230: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AA234: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823AA238 size=376
    let mut pc: u32 = 0x823AA238;
    'dispatch: loop {
        match pc {
            0x823AA238 => {
    //   block [0x823AA238..0x823AA2B0)
	// 823AA238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AA23C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AA240: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823AA244: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AA248: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AA24C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 823AA250: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AA254: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 823AA258: 396B0700  addi r11, r11, 0x700
	ctx.r[11].s64 = ctx.r[11].s64 + 1792;
	// 823AA25C: 81480014  lwz r10, 0x14(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AA260: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 823AA264: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AA268: 409A00A0  bne cr6, 0x823aa308
	if !ctx.cr[6].eq {
	pc = 0x823AA308; continue 'dispatch;
	}
	// 823AA26C: 83E8001C  lwz r31, 0x1c(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AA270: 80C80018  lwz r6, 0x18(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AA274: 2B1F0004  cmplwi cr6, r31, 4
	ctx.cr[6].compare_u32(ctx.r[31].u32, 4 as u32, &mut ctx.xer);
	// 823AA278: 409A0038  bne cr6, 0x823aa2b0
	if !ctx.cr[6].eq {
	pc = 0x823AA2B0; continue 'dispatch;
	}
	// 823AA27C: 81680010  lwz r11, 0x10(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AA280: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823AA284: 7D2B3214  add r9, r11, r6
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 823AA288: 7948FFE6  rldicr r8, r10, 0x3f, 0x3f
	ctx.r[8].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 823AA28C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823AA290: 556AF0BE  srwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AA294: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 823AA298: 552BF0BE  srwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823AA29C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 823AA2A0: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 823AA2A4: 7D0B5E34  srad r11, r8, r11
	tmp.u64 = (ctx.r[11].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[8].s64 < 0) && ((ctx.r[8].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[11].s64 = ctx.r[8].s64 >> tmp.u64;
	// 823AA2A8: 7D675436  srd r7, r11, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[11].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 823AA2AC: 480000E8  b 0x823aa394
	pc = 0x823AA394; continue 'dispatch;
            }
            0x823AA2B0 => {
    //   block [0x823AA2B0..0x823AA2C4)
	// 823AA2B0: 28060000  cmplwi r6, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA2B4: 4182004C  beq 0x823aa300
	if ctx.cr[0].eq {
	pc = 0x823AA300; continue 'dispatch;
	}
	// 823AA2B8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823AA2BC: 57FE103A  slwi r30, r31, 2
	ctx.r[30].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 823AA2C0: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	pc = 0x823AA2C4; continue 'dispatch;
            }
            0x823AA2C4 => {
    //   block [0x823AA2C4..0x823AA2D8)
	// 823AA2C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823AA2C8: 419A0028  beq cr6, 0x823aa2f0
	if ctx.cr[6].eq {
	pc = 0x823AA2F0; continue 'dispatch;
	}
	// 823AA2CC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 823AA2D0: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 823AA2D4: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x823AA2D8; continue 'dispatch;
            }
            0x823AA2D8 => {
    //   block [0x823AA2D8..0x823AA2F0)
	// 823AA2D8: C0090000  lfs f0, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AA2DC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AA2E0: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823AA2E4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823AA2E8: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823AA2EC: 4082FFEC  bne 0x823aa2d8
	if !ctx.cr[0].eq {
	pc = 0x823AA2D8; continue 'dispatch;
	}
	pc = 0x823AA2F0; continue 'dispatch;
            }
            0x823AA2F0 => {
    //   block [0x823AA2F0..0x823AA300)
	// 823AA2F0: 3484FFFF  addic. r4, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823AA2F4: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 823AA2F8: 7CBE2A14  add r5, r30, r5
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[5].u64;
	// 823AA2FC: 4082FFC8  bne 0x823aa2c4
	if !ctx.cr[0].eq {
	pc = 0x823AA2C4; continue 'dispatch;
	}
	pc = 0x823AA300; continue 'dispatch;
            }
            0x823AA300 => {
    //   block [0x823AA300..0x823AA308)
	// 823AA300: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823AA304: 48000064  b 0x823aa368
	pc = 0x823AA368; continue 'dispatch;
            }
            0x823AA308 => {
    //   block [0x823AA308..0x823AA320)
	// 823AA308: 80880018  lwz r4, 0x18(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AA30C: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA310: 41820050  beq 0x823aa360
	if ctx.cr[0].eq {
	pc = 0x823AA360; continue 'dispatch;
	}
	// 823AA314: 83E8001C  lwz r31, 0x1c(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AA318: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 823AA31C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	pc = 0x823AA320; continue 'dispatch;
            }
            0x823AA320 => {
    //   block [0x823AA320..0x823AA338)
	// 823AA320: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823AA324: 419A002C  beq cr6, 0x823aa350
	if ctx.cr[6].eq {
	pc = 0x823AA350; continue 'dispatch;
	}
	// 823AA328: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 823AA32C: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 823AA330: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 823AA334: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x823AA338; continue 'dispatch;
            }
            0x823AA338 => {
    //   block [0x823AA338..0x823AA350)
	// 823AA338: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AA33C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AA340: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823AA344: 7D465214  add r10, r6, r10
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 823AA348: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823AA34C: 4082FFEC  bne 0x823aa338
	if !ctx.cr[0].eq {
	pc = 0x823AA338; continue 'dispatch;
	}
	pc = 0x823AA350; continue 'dispatch;
            }
            0x823AA350 => {
    //   block [0x823AA350..0x823AA360)
	// 823AA350: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823AA354: 38E70010  addi r7, r7, 0x10
	ctx.r[7].s64 = ctx.r[7].s64 + 16;
	// 823AA358: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 823AA35C: 4082FFC4  bne 0x823aa320
	if !ctx.cr[0].eq {
	pc = 0x823AA320; continue 'dispatch;
	}
	pc = 0x823AA360; continue 'dispatch;
            }
            0x823AA360 => {
    //   block [0x823AA360..0x823AA368)
	// 823AA360: 80C8001C  lwz r6, 0x1c(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AA364: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	pc = 0x823AA368; continue 'dispatch;
            }
            0x823AA368 => {
    //   block [0x823AA368..0x823AA394)
	// 823AA368: 80880010  lwz r4, 0x10(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AA36C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823AA370: 7D443214  add r10, r4, r6
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[6].u64;
	// 823AA374: 7969FFE6  rldicr r9, r11, 0x3f, 0x3f
	ctx.r[9].u64 = (ctx.r[11].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 823AA378: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823AA37C: 548BF0BE  srwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823AA380: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AA384: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823AA388: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 823AA38C: 7D2A5634  srad r10, r9, r10
	tmp.u64 = (ctx.r[10].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[9].s64 < 0) && ((ctx.r[9].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[10].s64 = ctx.r[9].s64 >> tmp.u64;
	// 823AA390: 7D475C36  srd r7, r10, r11
	if (ctx.r[11].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[10].u64) >> ((ctx.r[11].u8 & 0x3F) as u32);
	}
	pc = 0x823AA394; continue 'dispatch;
            }
            0x823AA394 => {
    //   block [0x823AA394..0x823AA3B0)
	// 823AA394: 4802CF0D  bl 0x823d72a0
	ctx.lr = 0x823AA398;
	sub_823D72A0(ctx, base);
	// 823AA398: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 823AA39C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AA3A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AA3A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823AA3A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AA3AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823AA3B0 size=320
    let mut pc: u32 = 0x823AA3B0;
    'dispatch: loop {
        match pc {
            0x823AA3B0 => {
    //   block [0x823AA3B0..0x823AA4F0)
	// 823AA3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AA3B4: 4818ACF5  bl 0x825350a8
	ctx.lr = 0x823AA3B8;
	sub_82535080(ctx, base);
	// 823AA3B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AA3BC: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823AA3C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AA3C4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 823AA3C8: 78A9E102  rldicl r9, r5, 0x3c, 4
	ctx.r[9].u64 = ctx.r[5].u64 & 0x000000000000000Fu64;
	// 823AA3CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AA3D0: 78A7C202  rldicl r7, r5, 0x38, 8
	ctx.r[7].u64 = ctx.r[5].u64 & 0x00000000000000FFu64;
	// 823AA3D4: 396B0814  addi r11, r11, 0x814
	ctx.r[11].s64 = ctx.r[11].s64 + 2068;
	// 823AA3D8: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AA3DC: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AA3E0: 5529073E  clrlwi r9, r9, 0x1c
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000000Fu64;
	// 823AA3E4: 78A66502  rldicl r6, r5, 0x2c, 0x14
	ctx.r[6].u64 = ctx.r[5].u64 & 0x00000000000FFFFFu64;
	// 823AA3E8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823AA3EC: 78BEA302  rldicl r30, r5, 0x34, 0xc
	ctx.r[30].u64 = ctx.r[5].u64 & 0x0000000000000FFFu64;
	// 823AA3F0: 54BD073E  clrlwi r29, r5, 0x1c
	ctx.r[29].u64 = ctx.r[5].u32 as u64 & 0x0000000Fu64;
	// 823AA3F4: 8348002C  lwz r26, 0x2c(r8)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(44 as u32) ) } as u64;
	// 823AA3F8: 78A88402  rldicl r8, r5, 0x30, 0x10
	ctx.r[8].u64 = ctx.r[5].u64 & 0x000000000000FFFFu64;
	// 823AA3FC: 54E7073E  clrlwi r7, r7, 0x1c
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0000000Fu64;
	// 823AA400: 7F8958AE  lbzx r28, r9, r11
	ctx.r[28].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823AA404: 394A0790  addi r10, r10, 0x790
	ctx.r[10].s64 = ctx.r[10].s64 + 1936;
	// 823AA408: 54C6073E  clrlwi r6, r6, 0x1c
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x0000000Fu64;
	// 823AA40C: 5519073E  clrlwi r25, r8, 0x1c
	ctx.r[25].u64 = ctx.r[8].u32 as u64 & 0x0000000Fu64;
	// 823AA410: 7FBD58AE  lbzx r29, r29, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823AA414: 57D8073E  clrlwi r24, r30, 0x1c
	ctx.r[24].u64 = ctx.r[30].u32 as u64 & 0x0000000Fu64;
	// 823AA418: 78A54602  rldicl r5, r5, 0x28, 0x18
	ctx.r[5].u64 = ctx.r[5].u64 & 0x0000000000FFFFFFu64;
	// 823AA41C: 7F6758AE  lbzx r27, r7, r11
	ctx.r[27].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823AA420: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 823AA424: 54AB073E  clrlwi r11, r5, 0x1c
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x0000000Fu64;
	// 823AA428: 7D0650AE  lbzx r8, r6, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823AA42C: 3BC90700  addi r30, r9, 0x700
	ctx.r[30].s64 = ctx.r[9].s64 + 1792;
	// 823AA430: 7CF950AE  lbzx r7, r25, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823AA434: 7CD850AE  lbzx r6, r24, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823AA438: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 823AA43C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823AA440: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823AA444: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 823AA448: 4E800421  bctrl
	ctx.lr = 0x823AA44C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AA44C: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AA450: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823AA454: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AA458: 39090030  addi r8, r9, 0x30
	ctx.r[8].s64 = ctx.r[9].s64 + 48;
	// 823AA45C: 38E90020  addi r7, r9, 0x20
	ctx.r[7].s64 = ctx.r[9].s64 + 32;
	// 823AA460: 1D280018  mulli r9, r8, 0x18
	ctx.r[9].s32 = ((ctx.r[8].s32 as i64 * 24 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823AA464: 78E80020  clrldi r8, r7, 0x20
	ctx.r[8].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 823AA468: 794AFFE6  rldicr r10, r10, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 823AA46C: 7CE9582E  lwzx r7, r9, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823AA470: 53A754EA  rlwimi r7, r29, 0xa, 0x13, 0x15
	ctx.r[7].u64 = (((ctx.r[29].u32).rotate_left(10) as u64) & 0x0000000000001C00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFFE3FF);
	// 823AA474: 7CE9592E  stwx r7, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 823AA478: E92B0018  ld r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 823AA47C: 7D484436  srd r8, r10, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = (ctx.r[10].u64) >> ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 823AA480: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 823AA484: F92B0018  std r9, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u64 ) };
	// 823AA488: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AA48C: 39090030  addi r8, r9, 0x30
	ctx.r[8].s64 = ctx.r[9].s64 + 48;
	// 823AA490: 38E90020  addi r7, r9, 0x20
	ctx.r[7].s64 = ctx.r[9].s64 + 32;
	// 823AA494: 1D280018  mulli r9, r8, 0x18
	ctx.r[9].s32 = ((ctx.r[8].s32 as i64 * 24 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823AA498: 78E80020  clrldi r8, r7, 0x20
	ctx.r[8].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 823AA49C: 7CE9582E  lwzx r7, r9, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823AA4A0: 53876C24  rlwimi r7, r28, 0xd, 0x10, 0x12
	ctx.r[7].u64 = (((ctx.r[28].u32).rotate_left(13) as u64) & 0x000000000000E000) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF1FFF);
	// 823AA4A4: 7CE9592E  stwx r7, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 823AA4A8: E92B0018  ld r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 823AA4AC: 7D484436  srd r8, r10, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = (ctx.r[10].u64) >> ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 823AA4B0: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 823AA4B4: F92B0018  std r9, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u64 ) };
	// 823AA4B8: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AA4BC: 39090030  addi r8, r9, 0x30
	ctx.r[8].s64 = ctx.r[9].s64 + 48;
	// 823AA4C0: 39290020  addi r9, r9, 0x20
	ctx.r[9].s64 = ctx.r[9].s64 + 32;
	// 823AA4C4: 1D080018  mulli r8, r8, 0x18
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * 24 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 823AA4C8: 7CE8582E  lwzx r7, r8, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823AA4CC: 79290020  clrldi r9, r9, 0x20
	ctx.r[9].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 823AA4D0: 5367835E  rlwimi r7, r27, 0x10, 0xd, 0xf
	ctx.r[7].u64 = (((ctx.r[27].u32).rotate_left(16) as u64) & 0x0000000000070000) | (ctx.r[7].u64 & 0xFFFFFFFFFFF8FFFF);
	// 823AA4D4: 7CE8592E  stwx r7, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 823AA4D8: E90B0018  ld r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 823AA4DC: 7D4A4C36  srd r10, r10, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = (ctx.r[10].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 823AA4E0: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 823AA4E4: F94B0018  std r10, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u64 ) };
	// 823AA4E8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823AA4EC: 4818AC0C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA4F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AA4F0 size=132
    let mut pc: u32 = 0x823AA4F0;
    'dispatch: loop {
        match pc {
            0x823AA4F0 => {
    //   block [0x823AA4F0..0x823AA50C)
	// 823AA4F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AA4F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AA4F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823AA4FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AA500: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AA504: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AA508: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x823AA50C; continue 'dispatch;
            }
            0x823AA50C => {
    //   block [0x823AA50C..0x823AA558)
	// 823AA50C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 823AA510: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823AA514: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 823AA518: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823AA51C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823AA520: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823AA524: 4082FFE8  bne 0x823aa50c
	if !ctx.cr[0].eq {
	pc = 0x823AA50C; continue 'dispatch;
	}
	// 823AA528: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 823AA52C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823AA530: 409A0028  bne cr6, 0x823aa558
	if !ctx.cr[6].eq {
	pc = 0x823AA558; continue 'dispatch;
	}
	// 823AA534: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AA538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AA53C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AA540: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AA544: 4E800421  bctrl
	ctx.lr = 0x823AA548;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AA548: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823AA54C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823AA550: 386B9180  addi r3, r11, -0x6e80
	ctx.r[3].s64 = ctx.r[11].s64 + -28288;
	// 823AA554: 4BFF4A8D  bl 0x8239efe0
	ctx.lr = 0x823AA558;
	sub_8239EFE0(ctx, base);
            }
            0x823AA558 => {
    //   block [0x823AA558..0x823AA574)
	// 823AA558: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AA55C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823AA560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AA564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AA568: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823AA56C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AA570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AA578 size=112
    let mut pc: u32 = 0x823AA578;
    'dispatch: loop {
        match pc {
            0x823AA578 => {
    //   block [0x823AA578..0x823AA594)
	// 823AA578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AA57C: 4818AB41  bl 0x825350bc
	ctx.lr = 0x823AA580;
	sub_82535080(ctx, base);
	// 823AA580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AA584: 83E30010  lwz r31, 0x10(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AA588: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823AA58C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823AA590: 48000020  b 0x823aa5b0
	pc = 0x823AA5B0; continue 'dispatch;
            }
            0x823AA594 => {
    //   block [0x823AA594..0x823AA5B0)
	// 823AA594: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823AA598: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AA59C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823AA5A0: 48188BF1  bl 0x82533190
	ctx.lr = 0x823AA5A4;
	sub_82533190(ctx, base);
	// 823AA5A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823AA5A8: 41820020  beq 0x823aa5c8
	if ctx.cr[0].eq {
	pc = 0x823AA5C8; continue 'dispatch;
	}
	// 823AA5AC: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823AA5B0; continue 'dispatch;
            }
            0x823AA5B0 => {
    //   block [0x823AA5B0..0x823AA5C0)
	// 823AA5B0: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA5B4: 4082FFE0  bne 0x823aa594
	if !ctx.cr[0].eq {
	pc = 0x823AA594; continue 'dispatch;
	}
	// 823AA5B8: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823AA5BC: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	pc = 0x823AA5C0; continue 'dispatch;
            }
            0x823AA5C0 => {
    //   block [0x823AA5C0..0x823AA5C8)
	// 823AA5C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823AA5C4: 4818AB48  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x823AA5C8 => {
    //   block [0x823AA5C8..0x823AA5E8)
	// 823AA5C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AA5CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823AA5D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AA5D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AA5D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AA5DC: 4E800421  bctrl
	ctx.lr = 0x823AA5E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AA5E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AA5E4: 4BFFFFDC  b 0x823aa5c0
	pc = 0x823AA5C0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AA5E8 size=112
    let mut pc: u32 = 0x823AA5E8;
    'dispatch: loop {
        match pc {
            0x823AA5E8 => {
    //   block [0x823AA5E8..0x823AA604)
	// 823AA5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AA5EC: 4818AAD1  bl 0x825350bc
	ctx.lr = 0x823AA5F0;
	sub_82535080(ctx, base);
	// 823AA5F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AA5F4: 83E30014  lwz r31, 0x14(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AA5F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823AA5FC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823AA600: 48000020  b 0x823aa620
	pc = 0x823AA620; continue 'dispatch;
            }
            0x823AA604 => {
    //   block [0x823AA604..0x823AA620)
	// 823AA604: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823AA608: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AA60C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823AA610: 48188B81  bl 0x82533190
	ctx.lr = 0x823AA614;
	sub_82533190(ctx, base);
	// 823AA614: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823AA618: 41820020  beq 0x823aa638
	if ctx.cr[0].eq {
	pc = 0x823AA638; continue 'dispatch;
	}
	// 823AA61C: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823AA620; continue 'dispatch;
            }
            0x823AA620 => {
    //   block [0x823AA620..0x823AA630)
	// 823AA620: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA624: 4082FFE0  bne 0x823aa604
	if !ctx.cr[0].eq {
	pc = 0x823AA604; continue 'dispatch;
	}
	// 823AA628: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823AA62C: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	pc = 0x823AA630; continue 'dispatch;
            }
            0x823AA630 => {
    //   block [0x823AA630..0x823AA638)
	// 823AA630: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823AA634: 4818AAD8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x823AA638 => {
    //   block [0x823AA638..0x823AA658)
	// 823AA638: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AA63C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823AA640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AA644: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AA648: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AA64C: 4E800421  bctrl
	ctx.lr = 0x823AA650;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AA650: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AA654: 4BFFFFDC  b 0x823aa630
	pc = 0x823AA630; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AA658 size=136
    let mut pc: u32 = 0x823AA658;
    'dispatch: loop {
        match pc {
            0x823AA658 => {
    //   block [0x823AA658..0x823AA680)
	// 823AA658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AA65C: 4818AA5D  bl 0x825350b8
	ctx.lr = 0x823AA660;
	sub_82535080(ctx, base);
	// 823AA660: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 823AA664: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AA668: 83E30014  lwz r31, 0x14(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AA66C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823AA670: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823AA674: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 823AA678: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823AA67C: 48000020  b 0x823aa69c
	pc = 0x823AA69C; continue 'dispatch;
            }
            0x823AA680 => {
    //   block [0x823AA680..0x823AA69C)
	// 823AA680: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823AA684: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AA688: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823AA68C: 48188B05  bl 0x82533190
	ctx.lr = 0x823AA690;
	sub_82533190(ctx, base);
	// 823AA690: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823AA694: 41820024  beq 0x823aa6b8
	if ctx.cr[0].eq {
	pc = 0x823AA6B8; continue 'dispatch;
	}
	// 823AA698: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823AA69C; continue 'dispatch;
            }
            0x823AA69C => {
    //   block [0x823AA69C..0x823AA6AC)
	// 823AA69C: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA6A0: 4082FFE0  bne 0x823aa680
	if !ctx.cr[0].eq {
	pc = 0x823AA680; continue 'dispatch;
	}
	// 823AA6A4: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823AA6A8: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	pc = 0x823AA6AC; continue 'dispatch;
            }
            0x823AA6AC => {
    //   block [0x823AA6AC..0x823AA6B8)
	// 823AA6AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823AA6B0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 823AA6B4: 4818AA54  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x823AA6B8 => {
    //   block [0x823AA6B8..0x823AA6E0)
	// 823AA6B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AA6BC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823AA6C0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823AA6C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823AA6C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AA6CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AA6D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AA6D4: 4E800421  bctrl
	ctx.lr = 0x823AA6D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AA6D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AA6DC: 4BFFFFD0  b 0x823aa6ac
	pc = 0x823AA6AC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AA6E0 size=140
    let mut pc: u32 = 0x823AA6E0;
    'dispatch: loop {
        match pc {
            0x823AA6E0 => {
    //   block [0x823AA6E0..0x823AA700)
	// 823AA6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AA6E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AA6E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823AA6EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AA6F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AA6F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823AA6F8: 83FE0010  lwz r31, 0x10(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AA6FC: 48000020  b 0x823aa71c
	pc = 0x823AA71C; continue 'dispatch;
            }
            0x823AA700 => {
    //   block [0x823AA700..0x823AA71C)
	// 823AA700: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AA704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AA708: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AA70C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AA710: 4E800421  bctrl
	ctx.lr = 0x823AA714;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AA714: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AA718: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
            }
            0x823AA71C => {
    //   block [0x823AA71C..0x823AA72C)
	// 823AA71C: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA720: 4082FFE0  bne 0x823aa700
	if !ctx.cr[0].eq {
	pc = 0x823AA700; continue 'dispatch;
	}
	// 823AA724: 83FE0014  lwz r31, 0x14(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AA728: 48000020  b 0x823aa748
	pc = 0x823AA748; continue 'dispatch;
            }
            0x823AA72C => {
    //   block [0x823AA72C..0x823AA748)
	// 823AA72C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AA730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AA734: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AA738: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AA73C: 4E800421  bctrl
	ctx.lr = 0x823AA740;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AA740: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AA744: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
            }
            0x823AA748 => {
    //   block [0x823AA748..0x823AA76C)
	// 823AA748: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA74C: 4082FFE0  bne 0x823aa72c
	if !ctx.cr[0].eq {
	pc = 0x823AA72C; continue 'dispatch;
	}
	// 823AA750: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 823AA754: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823AA758: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AA75C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AA760: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823AA764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AA768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AA770 size=144
    let mut pc: u32 = 0x823AA770;
    'dispatch: loop {
        match pc {
            0x823AA770 => {
    //   block [0x823AA770..0x823AA794)
	// 823AA770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AA774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AA778: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823AA77C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AA780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AA784: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823AA788: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 823AA78C: 83FE0010  lwz r31, 0x10(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AA790: 48000020  b 0x823aa7b0
	pc = 0x823AA7B0; continue 'dispatch;
            }
            0x823AA794 => {
    //   block [0x823AA794..0x823AA7B0)
	// 823AA794: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AA798: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 823AA79C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AA7A0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AA7A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AA7A8: 4E800421  bctrl
	ctx.lr = 0x823AA7AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AA7AC: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
            }
            0x823AA7B0 => {
    //   block [0x823AA7B0..0x823AA7C0)
	// 823AA7B0: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA7B4: 4082FFE0  bne 0x823aa794
	if !ctx.cr[0].eq {
	pc = 0x823AA794; continue 'dispatch;
	}
	// 823AA7B8: 83FE0014  lwz r31, 0x14(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AA7BC: 48000020  b 0x823aa7dc
	pc = 0x823AA7DC; continue 'dispatch;
            }
            0x823AA7C0 => {
    //   block [0x823AA7C0..0x823AA7DC)
	// 823AA7C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AA7C4: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 823AA7C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AA7CC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AA7D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AA7D4: 4E800421  bctrl
	ctx.lr = 0x823AA7D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AA7D8: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
            }
            0x823AA7DC => {
    //   block [0x823AA7DC..0x823AA800)
	// 823AA7DC: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA7E0: 4082FFE0  bne 0x823aa7c0
	if !ctx.cr[0].eq {
	pc = 0x823AA7C0; continue 'dispatch;
	}
	// 823AA7E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AA7E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823AA7EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AA7F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AA7F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823AA7F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AA7FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AA800 size=156
    let mut pc: u32 = 0x823AA800;
    'dispatch: loop {
        match pc {
            0x823AA800 => {
    //   block [0x823AA800..0x823AA828)
	// 823AA800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AA804: 4818A8B1  bl 0x825350b4
	ctx.lr = 0x823AA808;
	sub_82535080(ctx, base);
	// 823AA808: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AA80C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823AA810: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823AA814: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823AA818: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823AA81C: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823AA820: 83FD0010  lwz r31, 0x10(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AA824: 48000024  b 0x823aa848
	pc = 0x823AA848; continue 'dispatch;
            }
            0x823AA828 => {
    //   block [0x823AA828..0x823AA848)
	// 823AA828: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823AA82C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AA830: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823AA834: 4818895D  bl 0x82533190
	ctx.lr = 0x823AA838;
	sub_82533190(ctx, base);
	// 823AA838: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823AA83C: 4182001C  beq 0x823aa858
	if ctx.cr[0].eq {
	pc = 0x823AA858; continue 'dispatch;
	}
	// 823AA840: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823AA844: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823AA848; continue 'dispatch;
            }
            0x823AA848 => {
    //   block [0x823AA848..0x823AA858)
	// 823AA848: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA84C: 4082FFDC  bne 0x823aa828
	if !ctx.cr[0].eq {
	pc = 0x823AA828; continue 'dispatch;
	}
	// 823AA850: 83FD0014  lwz r31, 0x14(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AA854: 48000030  b 0x823aa884
	pc = 0x823AA884; continue 'dispatch;
            }
            0x823AA858 => {
    //   block [0x823AA858..0x823AA864)
	// 823AA858: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AA85C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823AA860: 48000034  b 0x823aa894
	pc = 0x823AA894; continue 'dispatch;
            }
            0x823AA864 => {
    //   block [0x823AA864..0x823AA884)
	// 823AA864: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823AA868: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AA86C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823AA870: 48188921  bl 0x82533190
	ctx.lr = 0x823AA874;
	sub_82533190(ctx, base);
	// 823AA874: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823AA878: 4182FFE0  beq 0x823aa858
	if ctx.cr[0].eq {
	pc = 0x823AA858; continue 'dispatch;
	}
	// 823AA87C: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823AA880: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823AA884; continue 'dispatch;
            }
            0x823AA884 => {
    //   block [0x823AA884..0x823AA894)
	// 823AA884: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA888: 4082FFDC  bne 0x823aa864
	if !ctx.cr[0].eq {
	pc = 0x823AA864; continue 'dispatch;
	}
	// 823AA88C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823AA890: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	pc = 0x823AA894; continue 'dispatch;
            }
            0x823AA894 => {
    //   block [0x823AA894..0x823AA89C)
	// 823AA894: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823AA898: 4818A86C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AA8A0 size=92
    let mut pc: u32 = 0x823AA8A0;
    'dispatch: loop {
        match pc {
            0x823AA8A0 => {
    //   block [0x823AA8A0..0x823AA8C4)
	// 823AA8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AA8A4: 4818A819  bl 0x825350bc
	ctx.lr = 0x823AA8A8;
	sub_82535080(ctx, base);
	// 823AA8A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AA8AC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823AA8B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823AA8B4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823AA8B8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AA8BC: 83E30010  lwz r31, 0x10(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AA8C0: 48000020  b 0x823aa8e0
	pc = 0x823AA8E0; continue 'dispatch;
            }
            0x823AA8C4 => {
    //   block [0x823AA8C4..0x823AA8E0)
	// 823AA8C4: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823AA8C8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AA8CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823AA8D0: 481888C1  bl 0x82533190
	ctx.lr = 0x823AA8D4;
	sub_82533190(ctx, base);
	// 823AA8D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823AA8D8: 41820014  beq 0x823aa8ec
	if ctx.cr[0].eq {
	pc = 0x823AA8EC; continue 'dispatch;
	}
	// 823AA8DC: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823AA8E0; continue 'dispatch;
            }
            0x823AA8E0 => {
    //   block [0x823AA8E0..0x823AA8EC)
	// 823AA8E0: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA8E4: 4082FFE0  bne 0x823aa8c4
	if !ctx.cr[0].eq {
	pc = 0x823AA8C4; continue 'dispatch;
	}
	// 823AA8E8: 48000008  b 0x823aa8f0
	pc = 0x823AA8F0; continue 'dispatch;
            }
            0x823AA8EC => {
    //   block [0x823AA8EC..0x823AA8F0)
	// 823AA8EC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x823AA8F0; continue 'dispatch;
            }
            0x823AA8F0 => {
    //   block [0x823AA8F0..0x823AA8FC)
	// 823AA8F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AA8F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823AA8F8: 4818A814  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AA900 size=92
    let mut pc: u32 = 0x823AA900;
    'dispatch: loop {
        match pc {
            0x823AA900 => {
    //   block [0x823AA900..0x823AA924)
	// 823AA900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AA904: 4818A7B9  bl 0x825350bc
	ctx.lr = 0x823AA908;
	sub_82535080(ctx, base);
	// 823AA908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AA90C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823AA910: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823AA914: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823AA918: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AA91C: 83E30014  lwz r31, 0x14(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AA920: 48000020  b 0x823aa940
	pc = 0x823AA940; continue 'dispatch;
            }
            0x823AA924 => {
    //   block [0x823AA924..0x823AA940)
	// 823AA924: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823AA928: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AA92C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823AA930: 48188861  bl 0x82533190
	ctx.lr = 0x823AA934;
	sub_82533190(ctx, base);
	// 823AA934: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823AA938: 41820014  beq 0x823aa94c
	if ctx.cr[0].eq {
	pc = 0x823AA94C; continue 'dispatch;
	}
	// 823AA93C: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823AA940; continue 'dispatch;
            }
            0x823AA940 => {
    //   block [0x823AA940..0x823AA94C)
	// 823AA940: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA944: 4082FFE0  bne 0x823aa924
	if !ctx.cr[0].eq {
	pc = 0x823AA924; continue 'dispatch;
	}
	// 823AA948: 48000008  b 0x823aa950
	pc = 0x823AA950; continue 'dispatch;
            }
            0x823AA94C => {
    //   block [0x823AA94C..0x823AA950)
	// 823AA94C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x823AA950; continue 'dispatch;
            }
            0x823AA950 => {
    //   block [0x823AA950..0x823AA95C)
	// 823AA950: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AA954: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823AA958: 4818A7B4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AA960 size=8
    let mut pc: u32 = 0x823AA960;
    'dispatch: loop {
        match pc {
            0x823AA960 => {
    //   block [0x823AA960..0x823AA968)
	// 823AA960: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 823AA964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AA968 size=16
    let mut pc: u32 = 0x823AA968;
    'dispatch: loop {
        match pc {
            0x823AA968 => {
    //   block [0x823AA968..0x823AA978)
	// 823AA968: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823AA96C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AA970: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 823AA974: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AA978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AA978 size=308
    let mut pc: u32 = 0x823AA978;
    'dispatch: loop {
        match pc {
            0x823AA978 => {
    //   block [0x823AA978..0x823AA9BC)
	// 823AA978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AA97C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AA980: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AA984: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AA988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AA98C: 483628D1  bl 0x8270d25c
	ctx.lr = 0x823AA990;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823AA990: 80FF0864  lwz r7, 0x864(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2148 as u32) ) } as u64;
	// 823AA994: 397F0820  addi r11, r31, 0x820
	ctx.r[11].s64 = ctx.r[31].s64 + 2080;
	// 823AA998: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823AA99C: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AA9A0: 418200A0  beq 0x823aaa40
	if ctx.cr[0].eq {
	pc = 0x823AAA40; continue 'dispatch;
	}
	// 823AA9A4: 815F0868  lwz r10, 0x868(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2152 as u32) ) } as u64;
	// 823AA9A8: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 823AA9AC: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823AA9B0: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 823AA9B4: 40810028  ble 0x823aa9dc
	if !ctx.cr[0].gt {
	pc = 0x823AA9DC; continue 'dispatch;
	}
	// 823AA9B8: 39470014  addi r10, r7, 0x14
	ctx.r[10].s64 = ctx.r[7].s64 + 20;
	pc = 0x823AA9BC; continue 'dispatch;
            }
            0x823AA9BC => {
    //   block [0x823AA9BC..0x823AA9DC)
	// 823AA9BC: 38CAFFD8  addi r6, r10, -0x28
	ctx.r[6].s64 = ctx.r[10].s64 + -40;
	// 823AA9C0: 914AFFF0  stw r10, -0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16 as u32), ctx.r[10].u32 ) };
	// 823AA9C4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823AA9C8: 90CAFFEC  stw r6, -0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-20 as u32), ctx.r[6].u32 ) };
	// 823AA9CC: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 823AA9D0: 80CB0040  lwz r6, 0x40(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 823AA9D4: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823AA9D8: 4198FFE4  blt cr6, 0x823aa9bc
	if ctx.cr[6].lt {
	pc = 0x823AA9BC; continue 'dispatch;
	}
	pc = 0x823AA9DC; continue 'dispatch;
            }
            0x823AA9DC => {
    //   block [0x823AA9DC..0x823AAA40)
	// 823AA9DC: 394B0020  addi r10, r11, 0x20
	ctx.r[10].s64 = ctx.r[11].s64 + 32;
	// 823AA9E0: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AA9E4: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 823AA9E8: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AA9EC: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AA9F0: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AA9F4: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 823AA9F8: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AA9FC: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 823AAA00: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 823AAA04: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AAA08: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAA0C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AAA10: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AAA14: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AAA18: 80EB001C  lwz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AAA1C: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823AAA20: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAA24: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823AAA28: 394AFFEC  addi r10, r10, -0x14
	ctx.r[10].s64 = ctx.r[10].s64 + -20;
	// 823AAA2C: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AAA30: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AAA34: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAA38: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AAA3C: 48000034  b 0x823aaa70
	pc = 0x823AAA70; continue 'dispatch;
            }
            0x823AAA40 => {
    //   block [0x823AAA40..0x823AAA70)
	// 823AAA40: 394B0020  addi r10, r11, 0x20
	ctx.r[10].s64 = ctx.r[11].s64 + 32;
	// 823AAA44: 910B0040  stw r8, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[8].u32 ) };
	// 823AAA48: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AAA4C: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 823AAA50: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AAA54: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AAA58: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AAA5C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AAA60: 910B0014  stw r8, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 823AAA64: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AAA68: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AAA6C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823AAA70; continue 'dispatch;
            }
            0x823AAA70 => {
    //   block [0x823AAA70..0x823AAA7C)
	// 823AAA70: 393F0840  addi r9, r31, 0x840
	ctx.r[9].s64 = ctx.r[31].s64 + 2112;
	// 823AAA74: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 823AAA78: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	pc = 0x823AAA7C; continue 'dispatch;
            }
            0x823AAA7C => {
    //   block [0x823AAA7C..0x823AAAAC)
	// 823AAA7C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 823AAA80: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AAA84: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823AAA88: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 823AAA8C: 4082FFF0  bne 0x823aaa7c
	if !ctx.cr[0].eq {
	pc = 0x823AAA7C; continue 'dispatch;
	}
	// 823AAA90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AAA94: 483627D9  bl 0x8270d26c
	ctx.lr = 0x823AAA98;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823AAA98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823AAA9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AAAA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AAAA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AAAA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AAAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AAAB0 size=272
    let mut pc: u32 = 0x823AAAB0;
    'dispatch: loop {
        match pc {
            0x823AAAB0 => {
    //   block [0x823AAAB0..0x823AAB64)
	// 823AAAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AAAB4: 4818A605  bl 0x825350b8
	ctx.lr = 0x823AAAB8;
	sub_82535080(ctx, base);
	// 823AAAB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AAABC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AAAC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823AAAC4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823AAAC8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823AAACC: 48362791  bl 0x8270d25c
	ctx.lr = 0x823AAAD0;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823AAAD0: 57CA1838  slwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AAAD4: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823AAAD8: 397F0820  addi r11, r31, 0x820
	ctx.r[11].s64 = ctx.r[31].s64 + 2080;
	// 823AAADC: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 823AAAE0: 393E0004  addi r9, r30, 4
	ctx.r[9].s64 = ctx.r[30].s64 + 4;
	// 823AAAE4: 53C8C00E  rlwimi r8, r30, 0x18, 0, 7
	ctx.r[8].u64 = (((ctx.r[30].u32).rotate_left(24) as u64) & 0x00000000FF000000) | (ctx.r[8].u64 & 0xFFFFFFFF00FFFFFF);
	// 823AAAE8: 55251838  slwi r5, r9, 3
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823AAAEC: 392B0020  addi r9, r11, 0x20
	ctx.r[9].s64 = ctx.r[11].s64 + 32;
	// 823AAAF0: 80EA0024  lwz r7, 0x24(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 823AAAF4: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 823AAAF8: 7CC5F82E  lwzx r6, r5, r31
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823AAAFC: 90EA0024  stw r7, 0x24(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[7].u32 ) };
	// 823AAB00: 80EB001C  lwz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AAB04: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAB08: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAB0C: 90870000  stw r4, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 823AAB10: 80EB001C  lwz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AAB14: 80E70000  lwz r7, 0(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAB18: 91670004  stw r11, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AAB1C: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AAB20: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 823AAB24: 90EB0014  stw r7, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 823AAB28: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	// 823AAB2C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823AAB30: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 823AAB34: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 823AAB38: 81690018  lwz r11, 0x18(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AAB3C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAB40: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823AAB44: 409A0044  bne cr6, 0x823aab88
	if !ctx.cr[6].eq {
	pc = 0x823AAB88; continue 'dispatch;
	}
	// 823AAB48: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AAB4C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823AAB50: 409A0014  bne cr6, 0x823aab64
	if !ctx.cr[6].eq {
	pc = 0x823AAB64; continue 'dispatch;
	}
	// 823AAB54: 8169001C  lwz r11, 0x1c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AAB58: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AAB5C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823AAB60: 48000018  b 0x823aab78
	pc = 0x823AAB78; continue 'dispatch;
            }
            0x823AAB64 => {
    //   block [0x823AAB64..0x823AAB78)
	// 823AAB64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAB68: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AAB6C: 81690018  lwz r11, 0x18(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AAB70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAB74: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x823AAB78; continue 'dispatch;
            }
            0x823AAB78 => {
    //   block [0x823AAB78..0x823AAB88)
	// 823AAB78: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823AAB7C: 81690018  lwz r11, 0x18(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AAB80: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AAB84: 48000018  b 0x823aab9c
	pc = 0x823AAB9C; continue 'dispatch;
            }
            0x823AAB88 => {
    //   block [0x823AAB88..0x823AAB9C)
	// 823AAB88: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAB8C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AAB90: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823AAB94: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 823AAB98: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x823AAB9C; continue 'dispatch;
            }
            0x823AAB9C => {
    //   block [0x823AAB9C..0x823AABC0)
	// 823AAB9C: 81690014  lwz r11, 0x14(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AABA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AABA4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823AABA8: 91690014  stw r11, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 823AABAC: 7D45F92E  stwx r10, r5, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	// 823AABB0: 483626BD  bl 0x8270d26c
	ctx.lr = 0x823AABB4;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823AABB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823AABB8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823AABBC: 4818A54C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AABC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AABC0 size=348
    let mut pc: u32 = 0x823AABC0;
    'dispatch: loop {
        match pc {
            0x823AABC0 => {
    //   block [0x823AABC0..0x823AAC34)
	// 823AABC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AABC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AABC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823AABCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AABD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AABD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AABD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823AABDC: 48362681  bl 0x8270d25c
	ctx.lr = 0x823AABE0;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823AABE0: 88FE0008  lbz r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AABE4: 393F0820  addi r9, r31, 0x820
	ctx.r[9].s64 = ctx.r[31].s64 + 2080;
	// 823AABE8: 397EFFF8  addi r11, r30, -8
	ctx.r[11].s64 = ctx.r[30].s64 + -8;
	// 823AABEC: 54E8183E  rotlwi r8, r7, 3
	ctx.r[8].u64 = ((ctx.r[7].u32).rotate_left(3)) as u64;
	// 823AABF0: 39490020  addi r10, r9, 0x20
	ctx.r[10].s64 = ctx.r[9].s64 + 32;
	// 823AABF4: 7CC8FA14  add r6, r8, r31
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[31].u64;
	// 823AABF8: 81060024  lwz r8, 0x24(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 823AABFC: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 823AAC00: 91060024  stw r8, 0x24(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(36 as u32), ctx.r[8].u32 ) };
	// 823AAC04: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AAC08: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AAC0C: 80880000  lwz r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAC10: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 823AAC14: 409A0020  bne cr6, 0x823aac34
	if !ctx.cr[6].eq {
	pc = 0x823AAC34; continue 'dispatch;
	}
	// 823AAC18: 5484003E  slwi r4, r4, 0
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 823AAC1C: 80840004  lwz r4, 4(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AAC20: 90880000  stw r4, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 823AAC24: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AAC28: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAC2C: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AAC30: 48000048  b 0x823aac78
	pc = 0x823AAC78; continue 'dispatch;
            }
            0x823AAC34 => {
    //   block [0x823AAC34..0x823AAC60)
	// 823AAC34: 810A001C  lwz r8, 0x1c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AAC38: 80880000  lwz r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAC3C: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 823AAC40: 409A0020  bne cr6, 0x823aac60
	if !ctx.cr[6].eq {
	pc = 0x823AAC60; continue 'dispatch;
	}
	// 823AAC44: 5484003E  slwi r4, r4, 0
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 823AAC48: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAC4C: 90880000  stw r4, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 823AAC50: 810A001C  lwz r8, 0x1c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AAC54: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAC58: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823AAC5C: 4800001C  b 0x823aac78
	pc = 0x823AAC78; continue 'dispatch;
            }
            0x823AAC60 => {
    //   block [0x823AAC60..0x823AAC78)
	// 823AAC60: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAC64: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AAC68: 90880004  stw r4, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 823AAC6C: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AAC70: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAC74: 90880000  stw r4, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	pc = 0x823AAC78; continue 'dispatch;
            }
            0x823AAC78 => {
    //   block [0x823AAC78..0x823AACA0)
	// 823AAC78: 810A0014  lwz r8, 0x14(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AAC7C: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 823AAC80: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 823AAC84: 81490014  lwz r10, 0x14(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AAC88: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AAC8C: 409A0014  bne cr6, 0x823aaca0
	if !ctx.cr[6].eq {
	pc = 0x823AACA0; continue 'dispatch;
	}
	// 823AAC90: 81490018  lwz r10, 0x18(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AAC94: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AAC98: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823AAC9C: 4800001C  b 0x823aacb8
	pc = 0x823AACB8; continue 'dispatch;
            }
            0x823AACA0 => {
    //   block [0x823AACA0..0x823AACB8)
	// 823AACA0: 8149001C  lwz r10, 0x1c(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AACA4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AACA8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AACAC: 8149001C  lwz r10, 0x1c(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AACB0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AACB4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x823AACB8; continue 'dispatch;
            }
            0x823AACB8 => {
    //   block [0x823AACB8..0x823AACE8)
	// 823AACB8: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823AACBC: 39470004  addi r10, r7, 4
	ctx.r[10].s64 = ctx.r[7].s64 + 4;
	// 823AACC0: 8109001C  lwz r8, 0x1c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AACC4: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AACC8: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AACCC: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AACD0: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823AACD4: 91090014  stw r8, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 823AACD8: 7D2AF82E  lwzx r9, r10, r31
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823AACDC: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AACE0: 409A0008  bne cr6, 0x823aace8
	if !ctx.cr[6].eq {
	pc = 0x823AACE8; continue 'dispatch;
	}
	// 823AACE4: 7CAAF92E  stwx r5, r10, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[5].u32) };
	pc = 0x823AACE8; continue 'dispatch;
            }
            0x823AACE8 => {
    //   block [0x823AACE8..0x823AACFC)
	// 823AACE8: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 823AACEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823AACF0: 409A000C  bne cr6, 0x823aacfc
	if !ctx.cr[6].eq {
	pc = 0x823AACFC; continue 'dispatch;
	}
	// 823AACF4: 397F0840  addi r11, r31, 0x840
	ctx.r[11].s64 = ctx.r[31].s64 + 2112;
	// 823AACF8: 7D6AF92E  stwx r11, r10, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u32) };
	pc = 0x823AACFC; continue 'dispatch;
            }
            0x823AACFC => {
    //   block [0x823AACFC..0x823AAD1C)
	// 823AACFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AAD00: 4836256D  bl 0x8270d26c
	ctx.lr = 0x823AAD04;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823AAD04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823AAD08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AAD0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AAD10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823AAD14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AAD18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AAD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AAD20 size=448
    let mut pc: u32 = 0x823AAD20;
    'dispatch: loop {
        match pc {
            0x823AAD20 => {
    //   block [0x823AAD20..0x823AAD68)
	// 823AAD20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AAD24: 4818A391  bl 0x825350b4
	ctx.lr = 0x823AAD28;
	sub_82535080(ctx, base);
	// 823AAD28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AAD2C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823AAD30: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823AAD34: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823AAD38: 419A00C0  beq cr6, 0x823aadf8
	if ctx.cr[6].eq {
	pc = 0x823AADF8; continue 'dispatch;
	}
	// 823AAD3C: 3960FFBE  li r11, -0x42
	ctx.r[11].s64 = -66;
	// 823AAD40: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AAD44: 409800B4  bge cr6, 0x823aadf8
	if !ctx.cr[6].lt {
	pc = 0x823AADF8; continue 'dispatch;
	}
	// 823AAD48: 3964003F  addi r11, r4, 0x3f
	ctx.r[11].s64 = ctx.r[4].s64 + 63;
	// 823AAD4C: 2B1E0040  cmplwi cr6, r30, 0x40
	ctx.cr[6].compare_u32(ctx.r[30].u32, 64 as u32, &mut ctx.xer);
	// 823AAD50: 557C0032  rlwinm r28, r11, 0, 0, 0x19
	ctx.r[28].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823AAD54: 40990014  ble cr6, 0x823aad68
	if !ctx.cr[6].gt {
	pc = 0x823AAD68; continue 'dispatch;
	}
	// 823AAD58: 7D7CF214  add r11, r28, r30
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 823AAD5C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823AAD60: 7D6BF396  divwu r11, r11, r30
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[30].u32;
	// 823AAD64: 7F8BF1D6  mullw r28, r11, r30
	ctx.r[28].s32 = ((ctx.r[11].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	pc = 0x823AAD68; continue 'dispatch;
            }
            0x823AAD68 => {
    //   block [0x823AAD68..0x823AAD74)
	// 823AAD68: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823AAD6C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 823AAD70: 48000074  b 0x823aade4
	pc = 0x823AADE4; continue 'dispatch;
            }
            0x823AAD74 => {
    //   block [0x823AAD74..0x823AADC0)
	// 823AAD74: 397F0040  addi r11, r31, 0x40
	ctx.r[11].s64 = ctx.r[31].s64 + 64;
	// 823AAD78: 2B1E0040  cmplwi cr6, r30, 0x40
	ctx.cr[6].compare_u32(ctx.r[30].u32, 64 as u32, &mut ctx.xer);
	// 823AAD7C: 409900E8  ble cr6, 0x823aae64
	if !ctx.cr[6].gt {
	pc = 0x823AAE64; continue 'dispatch;
	}
	// 823AAD80: 7D4BF396  divwu r10, r11, r30
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[30].u32;
	// 823AAD84: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823AAD88: 7D4A5851  subf. r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AAD8C: 418200D8  beq 0x823aae64
	if ctx.cr[0].eq {
	pc = 0x823AAE64; continue 'dispatch;
	}
	// 823AAD90: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823AAD94: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823AAD98: 7D4AF396  divwu r10, r10, r30
	ctx.r[10].u32 = ctx.r[10].u32 / ctx.r[30].u32;
	// 823AAD9C: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823AADA0: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823AADA4: 2B0A0080  cmplwi cr6, r10, 0x80
	ctx.cr[6].compare_u32(ctx.r[10].u32, 128 as u32, &mut ctx.xer);
	// 823AADA8: 40980018  bge cr6, 0x823aadc0
	if !ctx.cr[6].lt {
	pc = 0x823AADC0; continue 'dispatch;
	}
	// 823AADAC: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823AADB0: 394A007F  addi r10, r10, 0x7f
	ctx.r[10].s64 = ctx.r[10].s64 + 127;
	// 823AADB4: 7D4AF396  divwu r10, r10, r30
	ctx.r[10].u32 = ctx.r[10].u32 / ctx.r[30].u32;
	// 823AADB8: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823AADBC: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	pc = 0x823AADC0; continue 'dispatch;
            }
            0x823AADC0 => {
    //   block [0x823AADC0..0x823AADE4)
	// 823AADC0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AADC4: 7D2AE214  add r9, r10, r28
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 823AADC8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823AADCC: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AADD0: 40990034  ble cr6, 0x823aae04
	if !ctx.cr[6].gt {
	pc = 0x823AAE04; continue 'dispatch;
	}
	// 823AADD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823AADD8: 48000211  bl 0x823aafe8
	ctx.lr = 0x823AADDC;
	sub_823AAFE8(ctx, base);
	// 823AADDC: 7FBDF214  add r29, r29, r30
	ctx.r[29].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 823AADE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x823AADE4; continue 'dispatch;
            }
            0x823AADE4 => {
    //   block [0x823AADE4..0x823AADF8)
	// 823AADE4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823AADE8: 48000389  bl 0x823ab170
	ctx.lr = 0x823AADEC;
	sub_823AB170(ctx, base);
	// 823AADEC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823AADF0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 823AADF4: 4082FF80  bne 0x823aad74
	if !ctx.cr[0].eq {
	pc = 0x823AAD74; continue 'dispatch;
	}
	pc = 0x823AADF8; continue 'dispatch;
            }
            0x823AADF8 => {
    //   block [0x823AADF8..0x823AADFC)
	// 823AADF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823AADFC; continue 'dispatch;
            }
            0x823AADFC => {
    //   block [0x823AADFC..0x823AAE04)
	// 823AADFC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823AAE00: 4818A304  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x823AAE04 => {
    //   block [0x823AAE04..0x823AAE40)
	// 823AAE04: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 823AAE08: 38CAFFC0  addi r6, r10, -0x40
	ctx.r[6].s64 = ctx.r[10].s64 + -64;
	// 823AAE0C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 823AAE10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823AAE14: 480004AD  bl 0x823ab2c0
	ctx.lr = 0x823AAE18;
	sub_823AB2C0(ctx, base);
	// 823AAE18: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823AAE1C: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AAE20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823AAE24: 409A0034  bne cr6, 0x823aae58
	if !ctx.cr[6].eq {
	pc = 0x823AAE58; continue 'dispatch;
	}
	// 823AAE28: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAE2C: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AAE30: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AAE34: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AAE38: 41820008  beq 0x823aae40
	if ctx.cr[0].eq {
	pc = 0x823AAE40; continue 'dispatch;
	}
	// 823AAE3C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x823AAE40; continue 'dispatch;
            }
            0x823AAE40 => {
    //   block [0x823AAE40..0x823AAE58)
	// 823AAE40: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AAE44: 81240010  lwz r9, 0x10(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AAE48: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823AAE4C: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	// 823AAE50: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 823AAE54: 4800000C  b 0x823aae60
	pc = 0x823AAE60; continue 'dispatch;
            }
            0x823AAE58 => {
    //   block [0x823AAE58..0x823AAE60)
	// 823AAE58: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823AAE5C: 4800018D  bl 0x823aafe8
	ctx.lr = 0x823AAE60;
	sub_823AAFE8(ctx, base);
	pc = 0x823AAE60; continue 'dispatch;
            }
            0x823AAE60 => {
    //   block [0x823AAE60..0x823AAE64)
	// 823AAE60: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823AAE64; continue 'dispatch;
            }
            0x823AAE64 => {
    //   block [0x823AAE64..0x823AAE98)
	// 823AAE64: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AAE68: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823AAE6C: 7D7C4850  subf r11, r28, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[28].s64;
	// 823AAE70: 2B0B0080  cmplwi cr6, r11, 0x80
	ctx.cr[6].compare_u32(ctx.r[11].u32, 128 as u32, &mut ctx.xer);
	// 823AAE74: 41980054  blt cr6, 0x823aaec8
	if ctx.cr[6].lt {
	pc = 0x823AAEC8; continue 'dispatch;
	}
	// 823AAE78: 396BFFC0  addi r11, r11, -0x40
	ctx.r[11].s64 = ctx.r[11].s64 + -64;
	// 823AAE7C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAE80: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 823AAE84: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AAE88: 7C89FA14  add r4, r9, r31
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 823AAE8C: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AAE90: 41820008  beq 0x823aae98
	if ctx.cr[0].eq {
	pc = 0x823AAE98; continue 'dispatch;
	}
	// 823AAE94: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x823AAE98; continue 'dispatch;
            }
            0x823AAE98 => {
    //   block [0x823AAE98..0x823AAEC8)
	// 823AAE98: 91640010  stw r11, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 823AAE9C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823AAEA0: 93E40004  stw r31, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823AAEA4: 93C40008  stw r30, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823AAEA8: 93C4000C  stw r30, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 823AAEAC: 93C40014  stw r30, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 823AAEB0: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 823AAEB4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AAEB8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823AAEBC: 396BFFC0  addi r11, r11, -0x40
	ctx.r[11].s64 = ctx.r[11].s64 + -64;
	// 823AAEC0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 823AAEC4: 48000125  bl 0x823aafe8
	ctx.lr = 0x823AAEC8;
	sub_823AAFE8(ctx, base);
	pc = 0x823AAEC8; continue 'dispatch;
            }
            0x823AAEC8 => {
    //   block [0x823AAEC8..0x823AAEE0)
	// 823AAEC8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823AAECC: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 823AAED0: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 823AAED4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 823AAED8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823AAEDC: 4BFFFF20  b 0x823aadfc
	pc = 0x823AADFC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AAEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AAEE0 size=264
    let mut pc: u32 = 0x823AAEE0;
    'dispatch: loop {
        match pc {
            0x823AAEE0 => {
    //   block [0x823AAEE0..0x823AAF54)
	// 823AAEE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AAEE4: 4818A1D5  bl 0x825350b8
	ctx.lr = 0x823AAEE8;
	sub_82535080(ctx, base);
	// 823AAEE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AAEEC: 3BE4FFC0  addi r31, r4, -0x40
	ctx.r[31].s64 = ctx.r[4].s64 + -64;
	// 823AAEF0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823AAEF4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AAEF8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 823AAEFC: 409A00E4  bne cr6, 0x823aafe0
	if !ctx.cr[6].eq {
	pc = 0x823AAFE0; continue 'dispatch;
	}
	// 823AAF00: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AAF04: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 823AAF08: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AAF0C: 41820060  beq 0x823aaf6c
	if ctx.cr[0].eq {
	pc = 0x823AAF6C; continue 'dispatch;
	}
	// 823AAF10: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AAF14: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823AAF18: 409A0054  bne cr6, 0x823aaf6c
	if !ctx.cr[6].eq {
	pc = 0x823AAF6C; continue 'dispatch;
	}
	// 823AAF1C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AAF20: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823AAF24: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 823AAF28: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 823AAF2C: 409A0040  bne cr6, 0x823aaf6c
	if !ctx.cr[6].eq {
	pc = 0x823AAF6C; continue 'dispatch;
	}
	// 823AAF30: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823AAF34: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823AAF38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823AAF3C: 48000155  bl 0x823ab090
	ctx.lr = 0x823AAF40;
	sub_823AB090(ctx, base);
	// 823AAF40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAF44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AAF48: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AAF4C: 41820008  beq 0x823aaf54
	if ctx.cr[0].eq {
	pc = 0x823AAF54; continue 'dispatch;
	}
	// 823AAF50: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x823AAF54; continue 'dispatch;
            }
            0x823AAF54 => {
    //   block [0x823AAF54..0x823AAF6C)
	// 823AAF54: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AAF58: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 823AAF5C: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AAF60: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823AAF64: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 823AAF68: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x823AAF6C; continue 'dispatch;
            }
            0x823AAF6C => {
    //   block [0x823AAF6C..0x823AAFC0)
	// 823AAF6C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAF70: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AAF74: 41820060  beq 0x823aafd4
	if ctx.cr[0].eq {
	pc = 0x823AAFD4; continue 'dispatch;
	}
	// 823AAF78: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AAF7C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823AAF80: 409A0054  bne cr6, 0x823aafd4
	if !ctx.cr[6].eq {
	pc = 0x823AAFD4; continue 'dispatch;
	}
	// 823AAF84: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AAF88: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823AAF8C: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 823AAF90: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 823AAF94: 409A0040  bne cr6, 0x823aafd4
	if !ctx.cr[6].eq {
	pc = 0x823AAFD4; continue 'dispatch;
	}
	// 823AAF98: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823AAF9C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823AAFA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823AAFA4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823AAFA8: 480000E9  bl 0x823ab090
	ctx.lr = 0x823AAFAC;
	sub_823AB090(ctx, base);
	// 823AAFAC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AAFB0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AAFB4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AAFB8: 41820008  beq 0x823aafc0
	if ctx.cr[0].eq {
	pc = 0x823AAFC0; continue 'dispatch;
	}
	// 823AAFBC: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x823AAFC0; continue 'dispatch;
            }
            0x823AAFC0 => {
    //   block [0x823AAFC0..0x823AAFD4)
	// 823AAFC0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AAFC4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AAFC8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823AAFCC: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 823AAFD0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x823AAFD4; continue 'dispatch;
            }
            0x823AAFD4 => {
    //   block [0x823AAFD4..0x823AAFE0)
	// 823AAFD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823AAFD8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823AAFDC: 4800000D  bl 0x823aafe8
	ctx.lr = 0x823AAFE0;
	sub_823AAFE8(ctx, base);
	pc = 0x823AAFE0; continue 'dispatch;
            }
            0x823AAFE0 => {
    //   block [0x823AAFE0..0x823AAFE8)
	// 823AAFE0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823AAFE4: 4818A124  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AAFE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AAFE8 size=168
    let mut pc: u32 = 0x823AAFE8;
    'dispatch: loop {
        match pc {
            0x823AAFE8 => {
    //   block [0x823AAFE8..0x823AB004)
	// 823AAFE8: 81240010  lwz r9, 0x10(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AAFEC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AAFF0: 41820014  beq 0x823ab004
	if ctx.cr[0].eq {
	pc = 0x823AB004; continue 'dispatch;
	}
	// 823AAFF4: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 823AAFF8: 216B001F  subfic r11, r11, 0x1f
	ctx.xer.ca = ctx.r[11].u32 <= 31 as u32;
	ctx.r[11].s64 = (31 as i64) - ctx.r[11].s64;
	// 823AAFFC: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 823AB000: 4098000C  bge cr6, 0x823ab00c
	if !ctx.cr[6].lt {
	pc = 0x823AB00C; continue 'dispatch;
	}
	pc = 0x823AB004; continue 'dispatch;
            }
            0x823AB004 => {
    //   block [0x823AB004..0x823AB00C)
	// 823AB004: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823AB008: 48000008  b 0x823ab010
	pc = 0x823AB010; continue 'dispatch;
            }
            0x823AB00C => {
    //   block [0x823AB00C..0x823AB010)
	// 823AB00C: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	pc = 0x823AB010; continue 'dispatch;
            }
            0x823AB010 => {
    //   block [0x823AB010..0x823AB048)
	// 823AB010: 7D295C30  srw r9, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) >> ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823AB014: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AB018: 552906FE  clrlwi r9, r9, 0x1b
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 823AB01C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823AB020: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823AB024: 394A0003  addi r10, r10, 3
	ctx.r[10].s64 = ctx.r[10].s64 + 3;
	// 823AB028: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AB02C: 9104000C  stw r8, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 823AB030: 7D0A182E  lwzx r8, r10, r3
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AB034: 91040008  stw r8, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 823AB038: 7D0A182E  lwzx r8, r10, r3
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AB03C: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AB040: 41820008  beq 0x823ab048
	if ctx.cr[0].eq {
	pc = 0x823AB048; continue 'dispatch;
	}
	// 823AB044: 9088000C  stw r4, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	pc = 0x823AB048; continue 'dispatch;
            }
            0x823AB048 => {
    //   block [0x823AB048..0x823AB090)
	// 823AB048: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 823AB04C: 7C8A192E  stwx r4, r10, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32), ctx.r[4].u32) };
	// 823AB050: 81430D8C  lwz r10, 0xd8c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(3468 as u32) ) } as u64;
	// 823AB054: 390B0364  addi r8, r11, 0x364
	ctx.r[8].s64 = ctx.r[11].s64 + 868;
	// 823AB058: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823AB05C: 7CEB5830  slw r11, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823AB060: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 823AB064: 7CEA4830  slw r10, r7, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[7].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 823AB068: 91630D8C  stw r11, 0xd8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(3468 as u32), ctx.r[11].u32 ) };
	// 823AB06C: 7D68182E  lwzx r11, r8, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AB070: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 823AB074: 7D68192E  stwx r11, r8, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32), ctx.r[11].u32) };
	// 823AB078: 90E40014  stw r7, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 823AB07C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AB080: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB084: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823AB088: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823AB08C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AB090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AB090 size=220
    let mut pc: u32 = 0x823AB090;
    'dispatch: loop {
        match pc {
            0x823AB090 => {
    //   block [0x823AB090..0x823AB0B8)
	// 823AB090: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823AB094: 2F05FFFF  cmpwi cr6, r5, -1
	ctx.cr[6].compare_i32(ctx.r[5].s32, -1, &mut ctx.xer);
	// 823AB098: 409A0034  bne cr6, 0x823ab0cc
	if !ctx.cr[6].eq {
	pc = 0x823AB0CC; continue 'dispatch;
	}
	// 823AB09C: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB0A0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AB0A4: 41820014  beq 0x823ab0b8
	if ctx.cr[0].eq {
	pc = 0x823AB0B8; continue 'dispatch;
	}
	// 823AB0A8: 7D4B0034  cntlzw r11, r10
	ctx.r[11].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 823AB0AC: 216B001F  subfic r11, r11, 0x1f
	ctx.xer.ca = ctx.r[11].u32 <= 31 as u32;
	ctx.r[11].s64 = (31 as i64) - ctx.r[11].s64;
	// 823AB0B0: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 823AB0B4: 4098000C  bge cr6, 0x823ab0c0
	if !ctx.cr[6].lt {
	pc = 0x823AB0C0; continue 'dispatch;
	}
	pc = 0x823AB0B8; continue 'dispatch;
            }
            0x823AB0B8 => {
    //   block [0x823AB0B8..0x823AB0C0)
	// 823AB0B8: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 823AB0BC: 48000008  b 0x823ab0c4
	pc = 0x823AB0C4; continue 'dispatch;
            }
            0x823AB0C0 => {
    //   block [0x823AB0C0..0x823AB0C4)
	// 823AB0C0: 38ABFFFC  addi r5, r11, -4
	ctx.r[5].s64 = ctx.r[11].s64 + -4;
	pc = 0x823AB0C4; continue 'dispatch;
            }
            0x823AB0C4 => {
    //   block [0x823AB0C4..0x823AB0CC)
	// 823AB0C4: 7D4B2C30  srw r11, r10, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) >> ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 823AB0C8: 556606FE  clrlwi r6, r11, 0x1b
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	pc = 0x823AB0CC; continue 'dispatch;
            }
            0x823AB0CC => {
    //   block [0x823AB0CC..0x823AB100)
	// 823AB0CC: 54AB2834  slwi r11, r5, 5
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823AB0D0: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 823AB0D4: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 823AB0D8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AB0DC: 7D6A182E  lwzx r11, r10, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AB0E0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AB0E4: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AB0E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AB0EC: 409A0014  bne cr6, 0x823ab100
	if !ctx.cr[6].eq {
	pc = 0x823AB100; continue 'dispatch;
	}
	// 823AB0F0: 7D6A192E  stwx r11, r10, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32), ctx.r[11].u32) };
	// 823AB0F4: 41820028  beq 0x823ab11c
	if ctx.cr[0].eq {
	pc = 0x823AB11C; continue 'dispatch;
	}
	// 823AB0F8: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 823AB0FC: 48000014  b 0x823ab110
	pc = 0x823AB110; continue 'dispatch;
            }
            0x823AB100 => {
    //   block [0x823AB100..0x823AB110)
	// 823AB100: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AB104: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823AB108: 41820008  beq 0x823ab110
	if ctx.cr[0].eq {
	pc = 0x823AB110; continue 'dispatch;
	}
	// 823AB10C: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	pc = 0x823AB110; continue 'dispatch;
            }
            0x823AB110 => {
    //   block [0x823AB110..0x823AB11C)
	// 823AB110: 7D6A182E  lwzx r11, r10, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AB114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823AB118: 409A0034  bne cr6, 0x823ab14c
	if !ctx.cr[6].eq {
	pc = 0x823AB14C; continue 'dispatch;
	}
	pc = 0x823AB11C; continue 'dispatch;
            }
            0x823AB11C => {
    //   block [0x823AB11C..0x823AB14C)
	// 823AB11C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823AB120: 39650364  addi r11, r5, 0x364
	ctx.r[11].s64 = ctx.r[5].s64 + 868;
	// 823AB124: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AB128: 7CEA182E  lwzx r7, r10, r3
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AB12C: 7D2B3030  slw r11, r9, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[9].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 823AB130: 7CEB5879  andc. r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 & !ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AB134: 7D6A192E  stwx r11, r10, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32), ctx.r[11].u32) };
	// 823AB138: 40820014  bne 0x823ab14c
	if !ctx.cr[0].eq {
	pc = 0x823AB14C; continue 'dispatch;
	}
	// 823AB13C: 81630D8C  lwz r11, 0xd8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(3468 as u32) ) } as u64;
	// 823AB140: 7D2A2830  slw r10, r9, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[9].u32) << ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 823AB144: 7D6B5078  andc r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & !ctx.r[10].u64;
	// 823AB148: 91630D8C  stw r11, 0xd8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(3468 as u32), ctx.r[11].u32 ) };
	pc = 0x823AB14C; continue 'dispatch;
            }
            0x823AB14C => {
    //   block [0x823AB14C..0x823AB16C)
	// 823AB14C: 9104000C  stw r8, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 823AB150: 91040008  stw r8, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 823AB154: 91040014  stw r8, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 823AB158: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB15C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AB160: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823AB164: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823AB168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AB170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AB170 size=336
    let mut pc: u32 = 0x823AB170;
    'dispatch: loop {
        match pc {
            0x823AB170 => {
    //   block [0x823AB170..0x823AB198)
	// 823AB170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AB174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AB178: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AB17C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AB180: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823AB184: 419A0014  beq cr6, 0x823ab198
	if ctx.cr[6].eq {
	pc = 0x823AB198; continue 'dispatch;
	}
	// 823AB188: 7C8B0034  cntlzw r11, r4
	ctx.r[11].u64 = if ctx.r[4].u32 == 0 { 32 } else { ctx.r[4].u32.leading_zeros() as u64 };
	// 823AB18C: 216B001F  subfic r11, r11, 0x1f
	ctx.xer.ca = ctx.r[11].u32 <= 31 as u32;
	ctx.r[11].s64 = (31 as i64) - ctx.r[11].s64;
	// 823AB190: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 823AB194: 4098000C  bge cr6, 0x823ab1a0
	if !ctx.cr[6].lt {
	pc = 0x823AB1A0; continue 'dispatch;
	}
	pc = 0x823AB198; continue 'dispatch;
            }
            0x823AB198 => {
    //   block [0x823AB198..0x823AB1A0)
	// 823AB198: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823AB19C: 48000008  b 0x823ab1a4
	pc = 0x823AB1A4; continue 'dispatch;
            }
            0x823AB1A0 => {
    //   block [0x823AB1A0..0x823AB1A4)
	// 823AB1A0: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	pc = 0x823AB1A4; continue 'dispatch;
            }
            0x823AB1A4 => {
    //   block [0x823AB1A4..0x823AB1D4)
	// 823AB1A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 823AB1A8: 7C895C30  srw r9, r4, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[4].u32) >> ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823AB1AC: 552606FE  clrlwi r6, r9, 0x1b
	ctx.r[6].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 823AB1B0: 7CEA5830  slw r10, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823AB1B4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823AB1B8: 7D4A2039  and. r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[4].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AB1BC: 41820018  beq 0x823ab1d4
	if ctx.cr[0].eq {
	pc = 0x823AB1D4; continue 'dispatch;
	}
	// 823AB1C0: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 823AB1C4: 2B060020  cmplwi cr6, r6, 0x20
	ctx.cr[6].compare_u32(ctx.r[6].u32, 32 as u32, &mut ctx.xer);
	// 823AB1C8: 4198000C  blt cr6, 0x823ab1d4
	if ctx.cr[6].lt {
	pc = 0x823AB1D4; continue 'dispatch;
	}
	// 823AB1CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823AB1D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	pc = 0x823AB1D4; continue 'dispatch;
            }
            0x823AB1D4 => {
    //   block [0x823AB1D4..0x823AB1E0)
	// 823AB1D4: 81030D8C  lwz r8, 0xd8c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(3468 as u32) ) } as u64;
	// 823AB1D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823AB1DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x823AB1E0; continue 'dispatch;
            }
            0x823AB1E0 => {
    //   block [0x823AB1E0..0x823AB204)
	// 823AB1E0: 7CE95830  slw r9, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823AB1E4: 394B0364  addi r10, r11, 0x364
	ctx.r[10].s64 = ctx.r[11].s64 + 868;
	// 823AB1E8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AB1EC: 7D4A182E  lwzx r10, r10, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AB1F0: 7D294039  and. r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823AB1F4: 41820010  beq 0x823ab204
	if ctx.cr[0].eq {
	pc = 0x823AB204; continue 'dispatch;
	}
	// 823AB1F8: 7CE93030  slw r9, r7, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[7].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 823AB1FC: 7D295039  and. r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823AB200: 40820074  bne 0x823ab274
	if !ctx.cr[0].eq {
	pc = 0x823AB274; continue 'dispatch;
	}
	pc = 0x823AB204; continue 'dispatch;
            }
            0x823AB204 => {
    //   block [0x823AB204..0x823AB240)
	// 823AB204: 7CE93030  slw r9, r7, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[7].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 823AB208: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823AB20C: 7D4A4879  andc. r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & !ctx.r[9].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AB210: 40820048  bne 0x823ab258
	if !ctx.cr[0].eq {
	pc = 0x823AB258; continue 'dispatch;
	}
	// 823AB214: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 823AB218: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823AB21C: 7CEA5030  slw r10, r7, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[7].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 823AB220: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823AB224: 7D0A5079  andc. r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 & !ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AB228: 41820050  beq 0x823ab278
	if ctx.cr[0].eq {
	pc = 0x823AB278; continue 'dispatch;
	}
	// 823AB22C: 7D6A00D0  neg r11, r10
	ctx.r[11].s64 = -ctx.r[10].s64;
	// 823AB230: 7D6B5039  and. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AB234: 4082000C  bne 0x823ab240
	if !ctx.cr[0].eq {
	pc = 0x823AB240; continue 'dispatch;
	}
	// 823AB238: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823AB23C: 4800000C  b 0x823ab248
	pc = 0x823AB248; continue 'dispatch;
            }
            0x823AB240 => {
    //   block [0x823AB240..0x823AB248)
	// 823AB240: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823AB244: 216B001F  subfic r11, r11, 0x1f
	ctx.xer.ca = ctx.r[11].u32 <= 31 as u32;
	ctx.r[11].s64 = (31 as i64) - ctx.r[11].s64;
	pc = 0x823AB248; continue 'dispatch;
            }
            0x823AB248 => {
    //   block [0x823AB248..0x823AB258)
	// 823AB248: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 823AB24C: 2F040002  cmpwi cr6, r4, 2
	ctx.cr[6].compare_i32(ctx.r[4].s32, 2, &mut ctx.xer);
	// 823AB250: 4198FF90  blt cr6, 0x823ab1e0
	if ctx.cr[6].lt {
	pc = 0x823AB1E0; continue 'dispatch;
	}
	// 823AB254: 48000024  b 0x823ab278
	pc = 0x823AB278; continue 'dispatch;
            }
            0x823AB258 => {
    //   block [0x823AB258..0x823AB26C)
	// 823AB258: 7D2A00D0  neg r9, r10
	ctx.r[9].s64 = -ctx.r[10].s64;
	// 823AB25C: 7D2A5039  and. r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AB260: 4082000C  bne 0x823ab26c
	if !ctx.cr[0].eq {
	pc = 0x823AB26C; continue 'dispatch;
	}
	// 823AB264: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823AB268: 4800000C  b 0x823ab274
	pc = 0x823AB274; continue 'dispatch;
            }
            0x823AB26C => {
    //   block [0x823AB26C..0x823AB274)
	// 823AB26C: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 823AB270: 20CA001F  subfic r6, r10, 0x1f
	ctx.xer.ca = ctx.r[10].u32 <= 31 as u32;
	ctx.r[6].s64 = (31 as i64) - ctx.r[10].s64;
	pc = 0x823AB274; continue 'dispatch;
            }
            0x823AB274 => {
    //   block [0x823AB274..0x823AB278)
	// 823AB274: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	pc = 0x823AB278; continue 'dispatch;
            }
            0x823AB278 => {
    //   block [0x823AB278..0x823AB288)
	// 823AB278: 54AA063F  clrlwi. r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AB27C: 4082000C  bne 0x823ab288
	if !ctx.cr[0].eq {
	pc = 0x823AB288; continue 'dispatch;
	}
	// 823AB280: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AB284: 48000028  b 0x823ab2ac
	pc = 0x823AB2AC; continue 'dispatch;
            }
            0x823AB288 => {
    //   block [0x823AB288..0x823AB2AC)
	// 823AB288: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AB28C: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 823AB290: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 823AB294: 396A0003  addi r11, r10, 3
	ctx.r[11].s64 = ctx.r[10].s64 + 3;
	// 823AB298: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823AB29C: 7FEB182E  lwzx r31, r11, r3
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AB2A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823AB2A4: 4BFFFDED  bl 0x823ab090
	ctx.lr = 0x823AB2A8;
	sub_823AB090(ctx, base);
	// 823AB2A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x823AB2AC; continue 'dispatch;
            }
            0x823AB2AC => {
    //   block [0x823AB2AC..0x823AB2C0)
	// 823AB2AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823AB2B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AB2B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AB2B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AB2BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AB2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AB2C0 size=344
    let mut pc: u32 = 0x823AB2C0;
    'dispatch: loop {
        match pc {
            0x823AB2C0 => {
    //   block [0x823AB2C0..0x823AB358)
	// 823AB2C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AB2C4: 48189DF5  bl 0x825350b8
	ctx.lr = 0x823AB2C8;
	sub_82535080(ctx, base);
	// 823AB2C8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AB2CC: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 823AB2D0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823AB2D4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 823AB2D8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823AB2DC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 823AB2E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AB2E4: 419A00B8  beq cr6, 0x823ab39c
	if ctx.cr[6].eq {
	pc = 0x823AB39C; continue 'dispatch;
	}
	// 823AB2E8: 7D2BEA14  add r9, r11, r29
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 823AB2EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AB2F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823AB2F4: 3BC90040  addi r30, r9, 0x40
	ctx.r[30].s64 = ctx.r[9].s64 + 64;
	// 823AB2F8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AB2FC: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 823AB300: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AB304: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 823AB308: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB30C: 93CA0000  stw r30, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823AB310: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 823AB314: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AB318: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 823AB31C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AB320: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 823AB324: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB328: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AB32C: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 823AB330: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 823AB334: 4818981D  bl 0x82534b50
	ctx.lr = 0x823AB338;
	sub_82534B50(ctx, base);
	// 823AB338: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AB33C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823AB340: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB344: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AB348: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823AB34C: 4082000C  bne 0x823ab358
	if !ctx.cr[0].eq {
	pc = 0x823AB358; continue 'dispatch;
	}
	// 823AB350: 917C0E00  stw r11, 0xe00(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(3584 as u32), ctx.r[11].u32 ) };
	// 823AB354: 48000008  b 0x823ab35c
	pc = 0x823AB35C; continue 'dispatch;
            }
            0x823AB358 => {
    //   block [0x823AB358..0x823AB35C)
	// 823AB358: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823AB35C; continue 'dispatch;
            }
            0x823AB35C => {
    //   block [0x823AB35C..0x823AB39C)
	// 823AB35C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823AB360: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 823AB364: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 823AB368: 93AB0010  stw r29, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 823AB36C: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 823AB370: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AB374: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB378: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AB37C: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 823AB380: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823AB384: 396BFFC0  addi r11, r11, -0x40
	ctx.r[11].s64 = ctx.r[11].s64 + -64;
	// 823AB388: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 823AB38C: 419A0084  beq cr6, 0x823ab410
	if ctx.cr[6].eq {
	pc = 0x823AB410; continue 'dispatch;
	}
	// 823AB390: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823AB394: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823AB398: 48000078  b 0x823ab410
	pc = 0x823AB410; continue 'dispatch;
            }
            0x823AB39C => {
    //   block [0x823AB39C..0x823AB3CC)
	// 823AB39C: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB3A0: 7D5D5850  subf r10, r29, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 823AB3A4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AB3A8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823AB3AC: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823AB3B0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AB3B4: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AB3B8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AB3BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823AB3C0: 419A000C  beq cr6, 0x823ab3cc
	if ctx.cr[6].eq {
	pc = 0x823AB3CC; continue 'dispatch;
	}
	// 823AB3C4: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823AB3C8: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x823AB3CC; continue 'dispatch;
            }
            0x823AB3CC => {
    //   block [0x823AB3CC..0x823AB410)
	// 823AB3CC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AB3D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823AB3D4: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 823AB3D8: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 823AB3DC: 7D264B78  mr r6, r9
	ctx.r[6].u64 = ctx.r[9].u64;
	// 823AB3E0: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 823AB3E4: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AB3E8: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 823AB3EC: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 823AB3F0: 9147000C  stw r10, 0xc(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 823AB3F4: 93A60010  stw r29, 0x10(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 823AB3F8: 91450014  stw r10, 0x14(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 823AB3FC: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 823AB400: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB404: 7D5D5050  subf r10, r29, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[29].s64;
	// 823AB408: 394AFFC0  addi r10, r10, -0x40
	ctx.r[10].s64 = ctx.r[10].s64 + -64;
	// 823AB40C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x823AB410; continue 'dispatch;
            }
            0x823AB410 => {
    //   block [0x823AB410..0x823AB418)
	// 823AB410: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823AB414: 48189CF4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AB418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AB418 size=440
    let mut pc: u32 = 0x823AB418;
    'dispatch: loop {
        match pc {
            0x823AB418 => {
    //   block [0x823AB418..0x823AB534)
	// 823AB418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AB41C: 48189C99  bl 0x825350b4
	ctx.lr = 0x823AB420;
	sub_82535080(ctx, base);
	// 823AB420: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AB424: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AB428: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823AB42C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823AB430: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823AB434: 38A00D80  li r5, 0xd80
	ctx.r[5].s64 = 3456;
	// 823AB438: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AB43C: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 823AB440: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823AB444: 48189D8D  bl 0x825351d0
	ctx.lr = 0x823AB448;
	sub_825351D0(ctx, base);
	// 823AB448: 38A0006C  li r5, 0x6c
	ctx.r[5].s64 = 108;
	// 823AB44C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AB450: 93DF0D98  stw r30, 0xd98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3480 as u32), ctx.r[30].u32 ) };
	// 823AB454: 387F0D9C  addi r3, r31, 0xd9c
	ctx.r[3].s64 = ctx.r[31].s64 + 3484;
	// 823AB458: 48189D79  bl 0x825351d0
	ctx.lr = 0x823AB45C;
	sub_825351D0(ctx, base);
	// 823AB45C: 3D6082BA  lis r11, -0x7d46
	ctx.r[11].s64 = -2101739520;
	// 823AB460: 3D008311  lis r8, -0x7cef
	ctx.r[8].s64 = -2096037888;
	// 823AB464: 93DF0E08  stw r30, 0xe08(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3592 as u32), ctx.r[30].u32 ) };
	// 823AB468: 396BC480  addi r11, r11, -0x3b80
	ctx.r[11].s64 = ctx.r[11].s64 + -15232;
	// 823AB46C: 93DF0E0C  stw r30, 0xe0c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3596 as u32), ctx.r[30].u32 ) };
	// 823AB470: 3CE08311  lis r7, -0x7cef
	ctx.r[7].s64 = -2096037888;
	// 823AB474: 93DF0E1C  stw r30, 0xe1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3612 as u32), ctx.r[30].u32 ) };
	// 823AB478: 3D400004  lis r10, 4
	ctx.r[10].s64 = 262144;
	// 823AB47C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823AB480: 37BF0E10  addic. r29, r31, 0xe10
	ctx.xer.ca = (ctx.r[31].u32 > (!(3600 as u32)));
	ctx.r[29].s64 = ctx.r[31].s64 + 3600;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823AB484: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 823AB488: 6149E000  ori r9, r10, 0xe000
	ctx.r[9].u64 = ctx.r[10].u64 | 57344;
	// 823AB48C: 91683B58  stw r11, 0x3b58(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(15192 as u32), ctx.r[11].u32 ) };
	// 823AB490: 3D000002  lis r8, 2
	ctx.r[8].s64 = 131072;
	// 823AB494: 3D4B0003  addis r10, r11, 3
	ctx.r[10].s64 = ctx.r[11].s64 + 196608;
	// 823AB498: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823AB49C: 6108A000  ori r8, r8, 0xa000
	ctx.r[8].u64 = ctx.r[8].u64 | 40960;
	// 823AB4A0: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 823AB4A4: 3D2B0003  addis r9, r11, 3
	ctx.r[9].s64 = ctx.r[11].s64 + 196608;
	// 823AB4A8: 91073B54  stw r8, 0x3b54(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(15188 as u32), ctx.r[8].u32 ) };
	// 823AB4AC: 3D008311  lis r8, -0x7cef
	ctx.r[8].s64 = -2096037888;
	// 823AB4B0: 91683B60  stw r11, 0x3b60(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(15200 as u32), ctx.r[11].u32 ) };
	// 823AB4B4: 3D600002  lis r11, 2
	ctx.r[11].s64 = 131072;
	// 823AB4B8: 3D008311  lis r8, -0x7cef
	ctx.r[8].s64 = -2096037888;
	// 823AB4BC: 616BA000  ori r11, r11, 0xa000
	ctx.r[11].u64 = ctx.r[11].u64 | 40960;
	// 823AB4C0: 91683B4C  stw r11, 0x3b4c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(15180 as u32), ctx.r[11].u32 ) };
	// 823AB4C4: 3D008311  lis r8, -0x7cef
	ctx.r[8].s64 = -2096037888;
	// 823AB4C8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 823AB4CC: 91683B50  stw r11, 0x3b50(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(15184 as u32), ctx.r[11].u32 ) };
	// 823AB4D0: 396AA000  addi r11, r10, -0x6000
	ctx.r[11].s64 = ctx.r[10].s64 + -24576;
	// 823AB4D4: 3D008311  lis r8, -0x7cef
	ctx.r[8].s64 = -2096037888;
	// 823AB4D8: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 823AB4DC: 91683B3C  stw r11, 0x3b3c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(15164 as u32), ctx.r[11].u32 ) };
	// 823AB4E0: 3D600002  lis r11, 2
	ctx.r[11].s64 = 131072;
	// 823AB4E4: 616B4000  ori r11, r11, 0x4000
	ctx.r[11].u64 = ctx.r[11].u64 | 16384;
	// 823AB4E8: 916A3B40  stw r11, 0x3b40(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15168 as u32), ctx.r[11].u32 ) };
	// 823AB4EC: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 823AB4F0: 3969A000  addi r11, r9, -0x6000
	ctx.r[11].s64 = ctx.r[9].s64 + -24576;
	// 823AB4F4: 916A3B5C  stw r11, 0x3b5c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15196 as u32), ctx.r[11].u32 ) };
	// 823AB4F8: 3D600002  lis r11, 2
	ctx.r[11].s64 = 131072;
	// 823AB4FC: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 823AB500: 616B4000  ori r11, r11, 0x4000
	ctx.r[11].u64 = ctx.r[11].u64 | 16384;
	// 823AB504: 916A3B48  stw r11, 0x3b48(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15176 as u32), ctx.r[11].u32 ) };
	// 823AB508: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 823AB50C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 823AB510: 916A3B44  stw r11, 0x3b44(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15172 as u32), ctx.r[11].u32 ) };
	// 823AB514: 41820070  beq 0x823ab584
	if ctx.cr[0].eq {
	pc = 0x823AB584; continue 'dispatch;
	}
	// 823AB518: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823AB51C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823AB520: 387D0001  addi r3, r29, 1
	ctx.r[3].s64 = ctx.r[29].s64 + 1;
	// 823AB524: 48000C25  bl 0x823ac148
	ctx.lr = 0x823AB528;
	sub_823AC148(ctx, base);
	// 823AB528: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AB52C: 41820008  beq 0x823ab534
	if ctx.cr[0].eq {
	pc = 0x823AB534; continue 'dispatch;
	}
	// 823AB530: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x823AB534; continue 'dispatch;
            }
            0x823AB534 => {
    //   block [0x823AB534..0x823AB540)
	// 823AB534: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AB538: 41820008  beq 0x823ab540
	if ctx.cr[0].eq {
	pc = 0x823AB540; continue 'dispatch;
	}
	// 823AB53C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x823AB540; continue 'dispatch;
            }
            0x823AB540 => {
    //   block [0x823AB540..0x823AB54C)
	// 823AB540: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AB544: 41820008  beq 0x823ab54c
	if ctx.cr[0].eq {
	pc = 0x823AB54C; continue 'dispatch;
	}
	// 823AB548: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x823AB54C; continue 'dispatch;
            }
            0x823AB54C => {
    //   block [0x823AB54C..0x823AB584)
	// 823AB54C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823AB550: 9BC30015  stb r30, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[30].u8 ) };
	// 823AB554: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 823AB558: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 823AB55C: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 823AB560: 99630015  stb r11, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 823AB564: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB568: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AB56C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB570: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AB574: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB578: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823AB57C: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823AB580: 48000008  b 0x823ab588
	pc = 0x823AB588; continue 'dispatch;
            }
            0x823AB584 => {
    //   block [0x823AB584..0x823AB588)
	// 823AB584: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x823AB588; continue 'dispatch;
            }
            0x823AB588 => {
    //   block [0x823AB588..0x823AB5D0)
	// 823AB588: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 823AB58C: 915F0E0C  stw r10, 0xe0c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3596 as u32), ctx.r[10].u32 ) };
	// 823AB590: 48000519  bl 0x823abaa8
	ctx.lr = 0x823AB594;
	sub_823ABAA8(ctx, base);
	// 823AB594: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AB598: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823AB59C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AB5A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823AB5A4: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823AB5A8: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823AB5AC: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823AB5B0: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 823AB5B4: 937D0014  stw r27, 0x14(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[27].u32 ) };
	// 823AB5B8: 917D0010  stw r11, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 823AB5BC: 93DD0018  stw r30, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 823AB5C0: 48000C29  bl 0x823ac1e8
	ctx.lr = 0x823AB5C4;
	sub_823AC1E8(ctx, base);
	// 823AB5C4: 93BF0E1C  stw r29, 0xe1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3612 as u32), ctx.r[29].u32 ) };
	// 823AB5C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823AB5CC: 48189B38  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AB5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AB5D0 size=460
    let mut pc: u32 = 0x823AB5D0;
    'dispatch: loop {
        match pc {
            0x823AB5D0 => {
    //   block [0x823AB5D0..0x823AB618)
	// 823AB5D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AB5D4: 48189AD9  bl 0x825350ac
	ctx.lr = 0x823AB5D8;
	sub_82535080(ctx, base);
	// 823AB5D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AB5DC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823AB5E0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823AB5E4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823AB5E8: 419A00A4  beq cr6, 0x823ab68c
	if ctx.cr[6].eq {
	pc = 0x823AB68C; continue 'dispatch;
	}
	// 823AB5EC: 3960FFBE  li r11, -0x42
	ctx.r[11].s64 = -66;
	// 823AB5F0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AB5F4: 40980098  bge cr6, 0x823ab68c
	if !ctx.cr[6].lt {
	pc = 0x823AB68C; continue 'dispatch;
	}
	// 823AB5F8: 3964003F  addi r11, r4, 0x3f
	ctx.r[11].s64 = ctx.r[4].s64 + 63;
	// 823AB5FC: 2B1E0040  cmplwi cr6, r30, 0x40
	ctx.cr[6].compare_u32(ctx.r[30].u32, 64 as u32, &mut ctx.xer);
	// 823AB600: 55790032  rlwinm r25, r11, 0, 0, 0x19
	ctx.r[25].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823AB604: 40990014  ble cr6, 0x823ab618
	if !ctx.cr[6].gt {
	pc = 0x823AB618; continue 'dispatch;
	}
	// 823AB608: 7D79F214  add r11, r25, r30
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[30].u64;
	// 823AB60C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823AB610: 7D6BF396  divwu r11, r11, r30
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[30].u32;
	// 823AB614: 7F2BF1D6  mullw r25, r11, r30
	ctx.r[25].s32 = ((ctx.r[11].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[25].s64 = ctx.r[25].s32 as i64;
	pc = 0x823AB618; continue 'dispatch;
            }
            0x823AB618 => {
    //   block [0x823AB618..0x823AB624)
	// 823AB618: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 823AB61C: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 823AB620: 4800005C  b 0x823ab67c
	pc = 0x823AB67C; continue 'dispatch;
            }
            0x823AB624 => {
    //   block [0x823AB624..0x823AB67C)
	// 823AB624: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823AB628: 2B1E0040  cmplwi cr6, r30, 0x40
	ctx.cr[6].compare_u32(ctx.r[30].u32, 64 as u32, &mut ctx.xer);
	// 823AB62C: 409900D4  ble cr6, 0x823ab700
	if !ctx.cr[6].gt {
	pc = 0x823AB700; continue 'dispatch;
	}
	// 823AB630: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB634: 7D4BF396  divwu r10, r11, r30
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[30].u32;
	// 823AB638: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823AB63C: 7D4A5851  subf. r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AB640: 418200C0  beq 0x823ab700
	if ctx.cr[0].eq {
	pc = 0x823AB700; continue 'dispatch;
	}
	// 823AB644: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823AB648: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AB64C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823AB650: 7D4AF396  divwu r10, r10, r30
	ctx.r[10].u32 = ctx.r[10].u32 / ctx.r[30].u32;
	// 823AB654: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823AB658: 7FAB5050  subf r29, r11, r10
	ctx.r[29].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823AB65C: 7D7DCA14  add r11, r29, r25
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[25].u64;
	// 823AB660: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823AB664: 40990034  ble cr6, 0x823ab698
	if !ctx.cr[6].gt {
	pc = 0x823AB698; continue 'dispatch;
	}
	// 823AB668: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823AB66C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823AB670: 48000B79  bl 0x823ac1e8
	ctx.lr = 0x823AB674;
	sub_823AC1E8(ctx, base);
	// 823AB674: 7F5AF214  add r26, r26, r30
	ctx.r[26].u64 = ctx.r[26].u64 + ctx.r[30].u64;
	// 823AB678: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	pc = 0x823AB67C; continue 'dispatch;
            }
            0x823AB67C => {
    //   block [0x823AB67C..0x823AB68C)
	// 823AB67C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823AB680: 48000CF1  bl 0x823ac370
	ctx.lr = 0x823AB684;
	sub_823AC370(ctx, base);
	// 823AB684: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823AB688: 4082FF9C  bne 0x823ab624
	if !ctx.cr[0].eq {
	pc = 0x823AB624; continue 'dispatch;
	}
	pc = 0x823AB68C; continue 'dispatch;
            }
            0x823AB68C => {
    //   block [0x823AB68C..0x823AB690)
	// 823AB68C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x823AB690; continue 'dispatch;
            }
            0x823AB690 => {
    //   block [0x823AB690..0x823AB698)
	// 823AB690: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823AB694: 48189A68  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x823AB698 => {
    //   block [0x823AB698..0x823AB6C0)
	// 823AB698: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 823AB69C: 4800040D  bl 0x823abaa8
	ctx.lr = 0x823AB6A0;
	sub_823ABAA8(ctx, base);
	// 823AB6A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 823AB6A4: 93E40000  stw r31, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823AB6A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB6AC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AB6B0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AB6B4: 4082000C  bne 0x823ab6c0
	if !ctx.cr[0].eq {
	pc = 0x823AB6C0; continue 'dispatch;
	}
	// 823AB6B8: 909B0E1C  stw r4, 0xe1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(3612 as u32), ctx.r[4].u32 ) };
	// 823AB6BC: 48000008  b 0x823ab6c4
	pc = 0x823AB6C4; continue 'dispatch;
            }
            0x823AB6C0 => {
    //   block [0x823AB6C0..0x823AB6C4)
	// 823AB6C0: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	pc = 0x823AB6C4; continue 'dispatch;
            }
            0x823AB6C4 => {
    //   block [0x823AB6C4..0x823AB700)
	// 823AB6C4: 93840008  stw r28, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 823AB6C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823AB6CC: 9384000C  stw r28, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 823AB6D0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB6D4: 93A40014  stw r29, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 823AB6D8: 93840018  stw r28, 0x18(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	// 823AB6DC: 91640010  stw r11, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 823AB6E0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB6E4: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AB6E8: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 823AB6EC: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 823AB6F0: 7D5D5050  subf r10, r29, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[29].s64;
	// 823AB6F4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 823AB6F8: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 823AB6FC: 48000AED  bl 0x823ac1e8
	ctx.lr = 0x823AB700;
	sub_823AC1E8(ctx, base);
	pc = 0x823AB700; continue 'dispatch;
            }
            0x823AB700 => {
    //   block [0x823AB700..0x823AB72C)
	// 823AB700: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AB704: 7FD95851  subf. r30, r25, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[25].s64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823AB708: 41820064  beq 0x823ab76c
	if ctx.cr[0].eq {
	pc = 0x823AB76C; continue 'dispatch;
	}
	// 823AB70C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 823AB710: 48000399  bl 0x823abaa8
	ctx.lr = 0x823AB714;
	sub_823ABAA8(ctx, base);
	// 823AB714: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AB718: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 823AB71C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AB720: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AB724: 41820008  beq 0x823ab72c
	if ctx.cr[0].eq {
	pc = 0x823AB72C; continue 'dispatch;
	}
	// 823AB728: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x823AB72C; continue 'dispatch;
            }
            0x823AB72C => {
    //   block [0x823AB72C..0x823AB76C)
	// 823AB72C: 93E40004  stw r31, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823AB730: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823AB734: 93840008  stw r28, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 823AB738: 9384000C  stw r28, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 823AB73C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB740: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AB744: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 823AB748: 93C40014  stw r30, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 823AB74C: 93840018  stw r28, 0x18(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	// 823AB750: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823AB754: 91640010  stw r11, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 823AB758: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AB75C: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 823AB760: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 823AB764: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 823AB768: 48000A81  bl 0x823ac1e8
	ctx.lr = 0x823AB76C;
	sub_823AC1E8(ctx, base);
	pc = 0x823AB76C; continue 'dispatch;
            }
            0x823AB76C => {
    //   block [0x823AB76C..0x823AB790)
	// 823AB76C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823AB770: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 823AB774: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 823AB778: 817B0E08  lwz r11, 0xe08(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(3592 as u32) ) } as u64;
	// 823AB77C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823AB780: 817B0E08  lwz r11, 0xe08(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(3592 as u32) ) } as u64;
	// 823AB784: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AB788: 41820008  beq 0x823ab790
	if ctx.cr[0].eq {
	pc = 0x823AB790; continue 'dispatch;
	}
	// 823AB78C: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	pc = 0x823AB790; continue 'dispatch;
            }
            0x823AB790 => {
    //   block [0x823AB790..0x823AB79C)
	// 823AB790: 93FB0E08  stw r31, 0xe08(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(3592 as u32), ctx.r[31].u32 ) };
	// 823AB794: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB798: 4BFFFEF8  b 0x823ab690
	pc = 0x823AB690; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AB7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AB7A0 size=252
    let mut pc: u32 = 0x823AB7A0;
    'dispatch: loop {
        match pc {
            0x823AB7A0 => {
    //   block [0x823AB7A0..0x823AB7C0)
	// 823AB7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AB7A4: 48189919  bl 0x825350bc
	ctx.lr = 0x823AB7A8;
	sub_82535080(ctx, base);
	// 823AB7A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AB7AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823AB7B0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823AB7B4: 83FD0E08  lwz r31, 0xe08(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3592 as u32) ) } as u64;
	// 823AB7B8: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AB7BC: 418200D4  beq 0x823ab890
	if ctx.cr[0].eq {
	pc = 0x823AB890; continue 'dispatch;
	}
	pc = 0x823AB7C0; continue 'dispatch;
            }
            0x823AB7C0 => {
    //   block [0x823AB7C0..0x823AB7DC)
	// 823AB7C0: 809D0E0C  lwz r4, 0xe0c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3596 as u32) ) } as u64;
	// 823AB7C4: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB7C8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB7CC: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 823AB7D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823AB7D4: 409A0030  bne cr6, 0x823ab804
	if !ctx.cr[6].eq {
	pc = 0x823AB804; continue 'dispatch;
	}
	// 823AB7D8: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	pc = 0x823AB7DC; continue 'dispatch;
            }
            0x823AB7DC => {
    //   block [0x823AB7DC..0x823AB7F0)
	// 823AB7DC: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AB7E0: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823AB7E4: 4098000C  bge cr6, 0x823ab7f0
	if !ctx.cr[6].lt {
	pc = 0x823AB7F0; continue 'dispatch;
	}
	// 823AB7E8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AB7EC: 4800000C  b 0x823ab7f8
	pc = 0x823AB7F8; continue 'dispatch;
            }
            0x823AB7F0 => {
    //   block [0x823AB7F0..0x823AB7F8)
	// 823AB7F0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 823AB7F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x823AB7F8; continue 'dispatch;
            }
            0x823AB7F8 => {
    //   block [0x823AB7F8..0x823AB804)
	// 823AB7F8: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 823AB7FC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823AB800: 419AFFDC  beq cr6, 0x823ab7dc
	if ctx.cr[6].eq {
	pc = 0x823AB7DC; continue 'dispatch;
	}
	pc = 0x823AB804; continue 'dispatch;
            }
            0x823AB804 => {
    //   block [0x823AB804..0x823AB82C)
	// 823AB804: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 823AB808: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB80C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 823AB810: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AB814: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 823AB818: 419A0014  beq cr6, 0x823ab82c
	if ctx.cr[6].eq {
	pc = 0x823AB82C; continue 'dispatch;
	}
	// 823AB81C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB820: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AB824: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823AB828: 40980030  bge cr6, 0x823ab858
	if !ctx.cr[6].lt {
	pc = 0x823AB858; continue 'dispatch;
	}
	pc = 0x823AB82C; continue 'dispatch;
            }
            0x823AB82C => {
    //   block [0x823AB82C..0x823AB858)
	// 823AB82C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB830: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 823AB834: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823AB838: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823AB83C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 823AB840: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 823AB844: 4800032D  bl 0x823abb70
	ctx.lr = 0x823AB848;
	sub_823ABB70(ctx, base);
	// 823AB848: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 823AB84C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823AB850: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823AB854: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823AB858; continue 'dispatch;
            }
            0x823AB858 => {
    //   block [0x823AB858..0x823AB864)
	// 823AB858: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823AB85C: 409A0008  bne cr6, 0x823ab864
	if !ctx.cr[6].eq {
	pc = 0x823AB864; continue 'dispatch;
	}
	// 823AB860: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x823AB864; continue 'dispatch;
            }
            0x823AB864 => {
    //   block [0x823AB864..0x823AB874)
	// 823AB864: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB868: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AB86C: 409A0008  bne cr6, 0x823ab874
	if !ctx.cr[6].eq {
	pc = 0x823AB874; continue 'dispatch;
	}
	// 823AB870: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x823AB874; continue 'dispatch;
            }
            0x823AB874 => {
    //   block [0x823AB874..0x823AB890)
	// 823AB874: 93EA0010  stw r31, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 823AB878: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AB87C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823AB880: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 823AB884: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AB888: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 823AB88C: 4082FF34  bne 0x823ab7c0
	if !ctx.cr[0].eq {
	pc = 0x823AB7C0; continue 'dispatch;
	}
	pc = 0x823AB890; continue 'dispatch;
            }
            0x823AB890 => {
    //   block [0x823AB890..0x823AB89C)
	// 823AB890: 93DD0E08  stw r30, 0xe08(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3592 as u32), ctx.r[30].u32 ) };
	// 823AB894: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823AB898: 48189874  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AB8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AB8A0 size=516
    let mut pc: u32 = 0x823AB8A0;
    'dispatch: loop {
        match pc {
            0x823AB8A0 => {
    //   block [0x823AB8A0..0x823AB8C4)
	// 823AB8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AB8A4: 48189815  bl 0x825350b8
	ctx.lr = 0x823AB8A8;
	sub_82535080(ctx, base);
	// 823AB8A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AB8AC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823AB8B0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823AB8B4: 813C0E0C  lwz r9, 0xe0c(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(3596 as u32) ) } as u64;
	// 823AB8B8: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB8BC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB8C0: 48000020  b 0x823ab8e0
	pc = 0x823AB8E0; continue 'dispatch;
            }
            0x823AB8C4 => {
    //   block [0x823AB8C4..0x823AB8D8)
	// 823AB8C4: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AB8C8: 7F082040  cmplw cr6, r8, r4
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[4].u32, &mut ctx.xer);
	// 823AB8CC: 4098000C  bge cr6, 0x823ab8d8
	if !ctx.cr[6].lt {
	pc = 0x823AB8D8; continue 'dispatch;
	}
	// 823AB8D0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AB8D4: 4800000C  b 0x823ab8e0
	pc = 0x823AB8E0; continue 'dispatch;
            }
            0x823AB8D8 => {
    //   block [0x823AB8D8..0x823AB8E0)
	// 823AB8D8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 823AB8DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x823AB8E0; continue 'dispatch;
            }
            0x823AB8E0 => {
    //   block [0x823AB8E0..0x823AB914)
	// 823AB8E0: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 823AB8E4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823AB8E8: 419AFFDC  beq cr6, 0x823ab8c4
	if ctx.cr[6].eq {
	pc = 0x823AB8C4; continue 'dispatch;
	}
	// 823AB8EC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB8F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 823AB8F4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 823AB8F8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AB8FC: 419A0018  beq cr6, 0x823ab914
	if ctx.cr[6].eq {
	pc = 0x823AB914; continue 'dispatch;
	}
	// 823AB900: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AB904: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823AB908: 4198000C  blt cr6, 0x823ab914
	if ctx.cr[6].lt {
	pc = 0x823AB914; continue 'dispatch;
	}
	// 823AB90C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 823AB910: 48000010  b 0x823ab920
	pc = 0x823AB920; continue 'dispatch;
            }
            0x823AB914 => {
    //   block [0x823AB914..0x823AB920)
	// 823AB914: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823AB918: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 823AB91C: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	pc = 0x823AB920; continue 'dispatch;
            }
            0x823AB920 => {
    //   block [0x823AB920..0x823AB940)
	// 823AB920: E9680000  ld r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 823AB924: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB928: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 823AB92C: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 823AB930: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823AB934: 419A000C  beq cr6, 0x823ab940
	if ctx.cr[6].eq {
	pc = 0x823AB940; continue 'dispatch;
	}
	// 823AB938: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823AB93C: 419A0008  beq cr6, 0x823ab944
	if ctx.cr[6].eq {
	pc = 0x823AB944; continue 'dispatch;
	}
	pc = 0x823AB940; continue 'dispatch;
            }
            0x823AB940 => {
    //   block [0x823AB940..0x823AB944)
	// 823AB940: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x823AB944; continue 'dispatch;
            }
            0x823AB944 => {
    //   block [0x823AB944..0x823AB95C)
	// 823AB944: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 823AB948: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 823AB94C: 419A0038  beq cr6, 0x823ab984
	if ctx.cr[6].eq {
	pc = 0x823AB984; continue 'dispatch;
	}
	// 823AB950: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823AB954: 409A0008  bne cr6, 0x823ab95c
	if !ctx.cr[6].eq {
	pc = 0x823AB95C; continue 'dispatch;
	}
	// 823AB958: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x823AB95C; continue 'dispatch;
            }
            0x823AB95C => {
    //   block [0x823AB95C..0x823AB96C)
	// 823AB95C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB960: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823AB964: 409A0008  bne cr6, 0x823ab96c
	if !ctx.cr[6].eq {
	pc = 0x823AB96C; continue 'dispatch;
	}
	// 823AB968: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x823AB96C; continue 'dispatch;
            }
            0x823AB96C => {
    //   block [0x823AB96C..0x823AB984)
	// 823AB96C: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 823AB970: 83CB0010  lwz r30, 0x10(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB974: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823AB978: E8A80000  ld r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 823AB97C: 4BFF52AD  bl 0x823a0c28
	ctx.lr = 0x823AB980;
	sub_823A0C28(ctx, base);
	// 823AB980: 48000060  b 0x823ab9e0
	pc = 0x823AB9E0; continue 'dispatch;
            }
            0x823AB984 => {
    //   block [0x823AB984..0x823AB98C)
	// 823AB984: 817C0E08  lwz r11, 0xe08(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(3592 as u32) ) } as u64;
	// 823AB988: 48000014  b 0x823ab99c
	pc = 0x823AB99C; continue 'dispatch;
            }
            0x823AB98C => {
    //   block [0x823AB98C..0x823AB99C)
	// 823AB98C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AB990: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 823AB994: 419A0014  beq cr6, 0x823ab9a8
	if ctx.cr[6].eq {
	pc = 0x823AB9A8; continue 'dispatch;
	}
	// 823AB998: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x823AB99C; continue 'dispatch;
            }
            0x823AB99C => {
    //   block [0x823AB99C..0x823AB9A8)
	// 823AB99C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AB9A0: 4082FFEC  bne 0x823ab98c
	if !ctx.cr[0].eq {
	pc = 0x823AB98C; continue 'dispatch;
	}
	// 823AB9A4: 4800003C  b 0x823ab9e0
	pc = 0x823AB9E0; continue 'dispatch;
            }
            0x823AB9A8 => {
    //   block [0x823AB9A8..0x823AB9D0)
	// 823AB9A8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AB9AC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 823AB9B0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AB9B4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AB9B8: 40820018  bne 0x823ab9d0
	if !ctx.cr[0].eq {
	pc = 0x823AB9D0; continue 'dispatch;
	}
	// 823AB9BC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AB9C0: 917C0E08  stw r11, 0xe08(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(3592 as u32), ctx.r[11].u32 ) };
	// 823AB9C4: 4182001C  beq 0x823ab9e0
	if ctx.cr[0].eq {
	pc = 0x823AB9E0; continue 'dispatch;
	}
	// 823AB9C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823AB9CC: 48000010  b 0x823ab9dc
	pc = 0x823AB9DC; continue 'dispatch;
            }
            0x823AB9D0 => {
    //   block [0x823AB9D0..0x823AB9DC)
	// 823AB9D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AB9D4: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823AB9D8: 41820008  beq 0x823ab9e0
	if ctx.cr[0].eq {
	pc = 0x823AB9E0; continue 'dispatch;
	}
	pc = 0x823AB9DC; continue 'dispatch;
            }
            0x823AB9DC => {
    //   block [0x823AB9DC..0x823AB9E0)
	// 823AB9DC: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x823AB9E0; continue 'dispatch;
            }
            0x823AB9E0 => {
    //   block [0x823AB9E0..0x823ABA3C)
	// 823AB9E0: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AB9E4: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 823AB9E8: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AB9EC: 41820050  beq 0x823aba3c
	if ctx.cr[0].eq {
	pc = 0x823ABA3C; continue 'dispatch;
	}
	// 823AB9F0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AB9F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823AB9F8: 409A0044  bne cr6, 0x823aba3c
	if !ctx.cr[6].eq {
	pc = 0x823ABA3C; continue 'dispatch;
	}
	// 823AB9FC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823ABA00: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823ABA04: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823ABA08: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823ABA0C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823ABA10: 409A002C  bne cr6, 0x823aba3c
	if !ctx.cr[6].eq {
	pc = 0x823ABA3C; continue 'dispatch;
	}
	// 823ABA14: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823ABA18: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823ABA1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823ABA20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823ABA24: 4800086D  bl 0x823ac290
	ctx.lr = 0x823ABA28;
	sub_823AC290(ctx, base);
	// 823ABA28: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823ABA2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823ABA30: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823ABA34: 48000A8D  bl 0x823ac4c0
	ctx.lr = 0x823ABA38;
	sub_823AC4C0(ctx, base);
	// 823ABA38: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	pc = 0x823ABA3C; continue 'dispatch;
            }
            0x823ABA3C => {
    //   block [0x823ABA3C..0x823ABA90)
	// 823ABA3C: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABA40: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823ABA44: 4182004C  beq 0x823aba90
	if ctx.cr[0].eq {
	pc = 0x823ABA90; continue 'dispatch;
	}
	// 823ABA48: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823ABA4C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823ABA50: 409A0040  bne cr6, 0x823aba90
	if !ctx.cr[6].eq {
	pc = 0x823ABA90; continue 'dispatch;
	}
	// 823ABA54: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823ABA58: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823ABA5C: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823ABA60: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823ABA64: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823ABA68: 409A0028  bne cr6, 0x823aba90
	if !ctx.cr[6].eq {
	pc = 0x823ABA90; continue 'dispatch;
	}
	// 823ABA6C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823ABA70: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823ABA74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823ABA78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823ABA7C: 48000815  bl 0x823ac290
	ctx.lr = 0x823ABA80;
	sub_823AC290(ctx, base);
	// 823ABA80: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823ABA84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823ABA88: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823ABA8C: 48000A35  bl 0x823ac4c0
	ctx.lr = 0x823ABA90;
	sub_823AC4C0(ctx, base);
	pc = 0x823ABA90; continue 'dispatch;
            }
            0x823ABA90 => {
    //   block [0x823ABA90..0x823ABAA4)
	// 823ABA90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823ABA94: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823ABA98: 48000751  bl 0x823ac1e8
	ctx.lr = 0x823ABA9C;
	sub_823AC1E8(ctx, base);
	// 823ABA9C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823ABAA0: 48189668  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ABAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823ABAA8 size=196
    let mut pc: u32 = 0x823ABAA8;
    'dispatch: loop {
        match pc {
            0x823ABAA8 => {
    //   block [0x823ABAA8..0x823ABAE0)
	// 823ABAA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823ABAAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823ABAB0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823ABAB4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 823ABAB8: 2B06001C  cmplwi cr6, r6, 0x1c
	ctx.cr[6].compare_u32(ctx.r[6].u32, 28 as u32, &mut ctx.xer);
	// 823ABABC: 40990024  ble cr6, 0x823abae0
	if !ctx.cr[6].gt {
	pc = 0x823ABAE0; continue 'dispatch;
	}
	// 823ABAC0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823ABAC4: 3CA0ACA4  lis r5, -0x535c
	ctx.r[5].s64 = -1398538240;
	// 823ABAC8: 386B0794  addi r3, r11, 0x794
	ctx.r[3].s64 = ctx.r[11].s64 + 1940;
	// 823ABACC: 60A5829A  ori r5, r5, 0x829a
	ctx.r[5].u64 = ctx.r[5].u64 | 33434;
	// 823ABAD0: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 823ABAD4: 481887D5  bl 0x825342a8
	ctx.lr = 0x823ABAD8;
	sub_825342A8(ctx, base);
	// 823ABAD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823ABADC: 48000080  b 0x823abb5c
	pc = 0x823ABB5C; continue 'dispatch;
            }
            0x823ABAE0 => {
    //   block [0x823ABAE0..0x823ABAFC)
	// 823ABAE0: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 823ABAE4: 81693B50  lwz r11, 0x3b50(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(15184 as u32) ) } as u64;
	// 823ABAE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823ABAEC: 419A0010  beq cr6, 0x823abafc
	if ctx.cr[6].eq {
	pc = 0x823ABAFC; continue 'dispatch;
	}
	// 823ABAF0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABAF4: 91493B50  stw r10, 0x3b50(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(15184 as u32), ctx.r[10].u32 ) };
	// 823ABAF8: 48000050  b 0x823abb48
	pc = 0x823ABB48; continue 'dispatch;
            }
            0x823ABAFC => {
    //   block [0x823ABAFC..0x823ABB44)
	// 823ABAFC: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 823ABB00: 3D008311  lis r8, -0x7cef
	ctx.r[8].s64 = -2096037888;
	// 823ABB04: 3CE08311  lis r7, -0x7cef
	ctx.r[7].s64 = -2096037888;
	// 823ABB08: 81693B60  lwz r11, 0x3b60(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(15200 as u32) ) } as u64;
	// 823ABB0C: 81083B54  lwz r8, 0x3b54(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(15188 as u32) ) } as u64;
	// 823ABB10: 80E73B58  lwz r7, 0x3b58(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(15192 as u32) ) } as u64;
	// 823ABB14: 394B001C  addi r10, r11, 0x1c
	ctx.r[10].s64 = ctx.r[11].s64 + 28;
	// 823ABB18: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 823ABB1C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823ABB20: 40990024  ble cr6, 0x823abb44
	if !ctx.cr[6].gt {
	pc = 0x823ABB44; continue 'dispatch;
	}
	// 823ABB24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823ABB28: 3CA0ACA4  lis r5, -0x535c
	ctx.r[5].s64 = -1398538240;
	// 823ABB2C: 386B07C8  addi r3, r11, 0x7c8
	ctx.r[3].s64 = ctx.r[11].s64 + 1992;
	// 823ABB30: 60A5829A  ori r5, r5, 0x829a
	ctx.r[5].u64 = ctx.r[5].u64 | 33434;
	// 823ABB34: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 823ABB38: 48188771  bl 0x825342a8
	ctx.lr = 0x823ABB3C;
	sub_825342A8(ctx, base);
	// 823ABB3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823ABB40: 48000018  b 0x823abb58
	pc = 0x823ABB58; continue 'dispatch;
            }
            0x823ABB44 => {
    //   block [0x823ABB44..0x823ABB48)
	// 823ABB44: 91493B60  stw r10, 0x3b60(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(15200 as u32), ctx.r[10].u32 ) };
	pc = 0x823ABB48; continue 'dispatch;
            }
            0x823ABB48 => {
    //   block [0x823ABB48..0x823ABB58)
	// 823ABB48: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 823ABB4C: 812A3B4C  lwz r9, 0x3b4c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15180 as u32) ) } as u64;
	// 823ABB50: 3929FFE4  addi r9, r9, -0x1c
	ctx.r[9].s64 = ctx.r[9].s64 + -28;
	// 823ABB54: 912A3B4C  stw r9, 0x3b4c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15180 as u32), ctx.r[9].u32 ) };
	pc = 0x823ABB58; continue 'dispatch;
            }
            0x823ABB58 => {
    //   block [0x823ABB58..0x823ABB5C)
	// 823ABB58: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	pc = 0x823ABB5C; continue 'dispatch;
            }
            0x823ABB5C => {
    //   block [0x823ABB5C..0x823ABB6C)
	// 823ABB5C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823ABB60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823ABB64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823ABB68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ABB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823ABB70 size=472
    let mut pc: u32 = 0x823ABB70;
    'dispatch: loop {
        match pc {
            0x823ABB70 => {
    //   block [0x823ABB70..0x823ABBAC)
	// 823ABB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823ABB74: 4818953D  bl 0x825350b0
	ctx.lr = 0x823ABB78;
	sub_82535080(ctx, base);
	// 823ABB78: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823ABB7C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823ABB80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823ABB84: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 823ABB88: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823ABB8C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823ABB90: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ABB94: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823ABB98: FB4100C0  std r26, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[26].u64 ) };
	// 823ABB9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823ABBA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823ABBA4: 409A0020  bne cr6, 0x823abbc4
	if !ctx.cr[6].eq {
	pc = 0x823ABBC4; continue 'dispatch;
	}
	// 823ABBA8: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823ABBAC; continue 'dispatch;
            }
            0x823ABBAC => {
    //   block [0x823ABBAC..0x823ABBB0)
	// 823ABBAC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	pc = 0x823ABBB0; continue 'dispatch;
            }
            0x823ABBB0 => {
    //   block [0x823ABBB0..0x823ABBBC)
	// 823ABBB0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 823ABBB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823ABBB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x823ABBBC; continue 'dispatch;
            }
            0x823ABBBC => {
    //   block [0x823ABBBC..0x823ABBC4)
	// 823ABBBC: 4800028D  bl 0x823abe48
	ctx.lr = 0x823ABBC0;
	sub_823ABE48(ctx, base);
	// 823ABBC0: 4800017C  b 0x823abd3c
	pc = 0x823ABD3C; continue 'dispatch;
            }
            0x823ABBC4 => {
    //   block [0x823ABBC4..0x823ABBE0)
	// 823ABBC4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABBC8: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 823ABBCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823ABBD0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABBD4: 419A000C  beq cr6, 0x823abbe0
	if ctx.cr[6].eq {
	pc = 0x823ABBE0; continue 'dispatch;
	}
	// 823ABBD8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 823ABBDC: 419A0008  beq cr6, 0x823abbe4
	if ctx.cr[6].eq {
	pc = 0x823ABBE4; continue 'dispatch;
	}
	pc = 0x823ABBE0; continue 'dispatch;
            }
            0x823ABBE0 => {
    //   block [0x823ABBE0..0x823ABBE4)
	// 823ABBE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x823ABBE4; continue 'dispatch;
            }
            0x823ABBE4 => {
    //   block [0x823ABBE4..0x823ABC08)
	// 823ABBE4: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 823ABBE8: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823ABBEC: 409A001C  bne cr6, 0x823abc08
	if !ctx.cr[6].eq {
	pc = 0x823ABC08; continue 'dispatch;
	}
	// 823ABBF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABBF4: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 823ABBF8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823ABBFC: 4098011C  bge cr6, 0x823abd18
	if !ctx.cr[6].lt {
	pc = 0x823ABD18; continue 'dispatch;
	}
	// 823ABC00: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 823ABC04: 4BFFFFA8  b 0x823abbac
	pc = 0x823ABBAC; continue 'dispatch;
            }
            0x823ABC08 => {
    //   block [0x823ABC08..0x823ABC18)
	// 823ABC08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823ABC0C: 419A000C  beq cr6, 0x823abc18
	if ctx.cr[6].eq {
	pc = 0x823ABC18; continue 'dispatch;
	}
	// 823ABC10: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 823ABC14: 419A0008  beq cr6, 0x823abc1c
	if ctx.cr[6].eq {
	pc = 0x823ABC1C; continue 'dispatch;
	}
	pc = 0x823ABC18; continue 'dispatch;
            }
            0x823ABC18 => {
    //   block [0x823ABC18..0x823ABC1C)
	// 823ABC18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x823ABC1C; continue 'dispatch;
            }
            0x823ABC1C => {
    //   block [0x823ABC1C..0x823ABC40)
	// 823ABC1C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABC20: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823ABC24: 409A001C  bne cr6, 0x823abc40
	if !ctx.cr[6].eq {
	pc = 0x823ABC40; continue 'dispatch;
	}
	// 823ABC28: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ABC2C: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 823ABC30: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823ABC34: 409800E4  bge cr6, 0x823abd18
	if !ctx.cr[6].lt {
	pc = 0x823ABD18; continue 'dispatch;
	}
	// 823ABC38: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823ABC3C: 4BFFFF74  b 0x823abbb0
	pc = 0x823ABBB0; continue 'dispatch;
            }
            0x823ABC40 => {
    //   block [0x823ABC40..0x823ABC8C)
	// 823ABC40: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 823ABC44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823ABC48: 40980058  bge cr6, 0x823abca0
	if !ctx.cr[6].lt {
	pc = 0x823ABCA0; continue 'dispatch;
	}
	// 823ABC4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823ABC50: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 823ABC54: 48000445  bl 0x823ac098
	ctx.lr = 0x823ABC58;
	sub_823AC098(ctx, base);
	// 823ABC58: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABC5C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABC60: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823ABC64: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823ABC68: 40980038  bge cr6, 0x823abca0
	if !ctx.cr[6].lt {
	pc = 0x823ABCA0; continue 'dispatch;
	}
	// 823ABC6C: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823ABC70: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 823ABC74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823ABC78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823ABC7C: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ABC80: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 823ABC84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823ABC88: 419A000C  beq cr6, 0x823abc94
	if ctx.cr[6].eq {
	pc = 0x823ABC94; continue 'dispatch;
	}
	pc = 0x823ABC8C; continue 'dispatch;
            }
            0x823ABC8C => {
    //   block [0x823ABC8C..0x823ABC94)
	// 823ABC8C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823ABC90: 4BFFFF2C  b 0x823abbbc
	pc = 0x823ABBBC; continue 'dispatch;
            }
            0x823ABC94 => {
    //   block [0x823ABC94..0x823ABC98)
	// 823ABC94: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x823ABC98; continue 'dispatch;
            }
            0x823ABC98 => {
    //   block [0x823ABC98..0x823ABCA0)
	// 823ABC98: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 823ABC9C: 4BFFFF20  b 0x823abbbc
	pc = 0x823ABBBC; continue 'dispatch;
            }
            0x823ABCA0 => {
    //   block [0x823ABCA0..0x823ABCD0)
	// 823ABCA0: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 823ABCA4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823ABCA8: 40980070  bge cr6, 0x823abd18
	if !ctx.cr[6].lt {
	pc = 0x823ABD18; continue 'dispatch;
	}
	// 823ABCAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823ABCB0: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABCB4: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 823ABCB8: 4BFF5499  bl 0x823a1150
	ctx.lr = 0x823ABCBC;
	sub_823A1150(ctx, base);
	// 823ABCBC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABCC0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823ABCC4: 4182000C  beq 0x823abcd0
	if ctx.cr[0].eq {
	pc = 0x823ABCD0; continue 'dispatch;
	}
	// 823ABCC8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 823ABCCC: 419A0008  beq cr6, 0x823abcd4
	if ctx.cr[6].eq {
	pc = 0x823ABCD4; continue 'dispatch;
	}
	pc = 0x823ABCD0; continue 'dispatch;
            }
            0x823ABCD0 => {
    //   block [0x823ABCD0..0x823ABCD4)
	// 823ABCD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x823ABCD4; continue 'dispatch;
            }
            0x823ABCD4 => {
    //   block [0x823ABCD4..0x823ABCF4)
	// 823ABCD4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABCD8: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823ABCDC: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 823ABCE0: 419A0014  beq cr6, 0x823abcf4
	if ctx.cr[6].eq {
	pc = 0x823ABCF4; continue 'dispatch;
	}
	// 823ABCE4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABCE8: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 823ABCEC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823ABCF0: 40980028  bge cr6, 0x823abd18
	if !ctx.cr[6].lt {
	pc = 0x823ABD18; continue 'dispatch;
	}
	pc = 0x823ABCF4; continue 'dispatch;
            }
            0x823ABCF4 => {
    //   block [0x823ABCF4..0x823ABD18)
	// 823ABCF4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ABCF8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 823ABCFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823ABD00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823ABD04: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 823ABD08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823ABD0C: 419AFF8C  beq cr6, 0x823abc98
	if ctx.cr[6].eq {
	pc = 0x823ABC98; continue 'dispatch;
	}
	// 823ABD10: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 823ABD14: 4BFFFF78  b 0x823abc8c
	pc = 0x823ABC8C; continue 'dispatch;
            }
            0x823ABD18 => {
    //   block [0x823ABD18..0x823ABD3C)
	// 823ABD18: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823ABD1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823ABD20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 823ABD24: 48000025  bl 0x823abd48
	ctx.lr = 0x823ABD28;
	sub_823ABD48(ctx, base);
	// 823ABD28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823ABD2C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABD30: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823ABD34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABD38: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x823ABD3C; continue 'dispatch;
            }
            0x823ABD3C => {
    //   block [0x823ABD3C..0x823ABD48)
	// 823ABD3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823ABD40: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823ABD44: 481893BC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ABD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823ABD48 size=252
    let mut pc: u32 = 0x823ABD48;
    'dispatch: loop {
        match pc {
            0x823ABD48 => {
    //   block [0x823ABD48..0x823ABD80)
	// 823ABD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823ABD4C: 48189365  bl 0x825350b0
	ctx.lr = 0x823ABD50;
	sub_82535080(ctx, base);
	// 823ABD50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823ABD54: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823ABD58: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 823ABD5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823ABD60: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823ABD64: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 823ABD68: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABD6C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABD70: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 823ABD74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823ABD78: 409A0038  bne cr6, 0x823abdb0
	if !ctx.cr[6].eq {
	pc = 0x823ABDB0; continue 'dispatch;
	}
	// 823ABD7C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x823ABD80; continue 'dispatch;
            }
            0x823ABD80 => {
    //   block [0x823ABD80..0x823ABDA0)
	// 823ABD80: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823ABD84: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 823ABD88: 7D295010  subfc r9, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 823ABD8C: 7D294910  subfe r9, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 823ABD90: 553C07FF  clrlwi. r28, r9, 0x1f
	ctx.r[28].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823ABD94: 4182000C  beq 0x823abda0
	if ctx.cr[0].eq {
	pc = 0x823ABDA0; continue 'dispatch;
	}
	// 823ABD98: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABD9C: 48000008  b 0x823abda4
	pc = 0x823ABDA4; continue 'dispatch;
            }
            0x823ABDA0 => {
    //   block [0x823ABDA0..0x823ABDA4)
	// 823ABDA0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x823ABDA4; continue 'dispatch;
            }
            0x823ABDA4 => {
    //   block [0x823ABDA4..0x823ABDB0)
	// 823ABDA4: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 823ABDA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823ABDAC: 419AFFD4  beq cr6, 0x823abd80
	if ctx.cr[6].eq {
	pc = 0x823ABD80; continue 'dispatch;
	}
	pc = 0x823ABDB0; continue 'dispatch;
            }
            0x823ABDB0 => {
    //   block [0x823ABDB0..0x823ABDD8)
	// 823ABDB0: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823ABDB4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 823ABDB8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 823ABDBC: 4182004C  beq 0x823abe08
	if ctx.cr[0].eq {
	pc = 0x823ABE08; continue 'dispatch;
	}
	// 823ABDC0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABDC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823ABDC8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABDCC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823ABDD0: 409A0034  bne cr6, 0x823abe04
	if !ctx.cr[6].eq {
	pc = 0x823ABE04; continue 'dispatch;
	}
	// 823ABDD4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	pc = 0x823ABDD8; continue 'dispatch;
            }
            0x823ABDD8 => {
    //   block [0x823ABDD8..0x823ABE04)
	// 823ABDD8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823ABDDC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 823ABDE0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823ABDE4: 48000065  bl 0x823abe48
	ctx.lr = 0x823ABDE8;
	sub_823ABE48(ctx, base);
	// 823ABDE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823ABDEC: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 823ABDF0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABDF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABDF8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823ABDFC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823ABE00: 48000038  b 0x823abe38
	pc = 0x823ABE38; continue 'dispatch;
            }
            0x823ABE04 => {
    //   block [0x823ABE04..0x823ABE08)
	// 823ABE04: 48000295  bl 0x823ac098
	ctx.lr = 0x823ABE08;
	sub_823AC098(ctx, base);
	pc = 0x823ABE08; continue 'dispatch;
            }
            0x823ABE08 => {
    //   block [0x823ABE08..0x823ABE28)
	// 823ABE08: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823ABE0C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABE10: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823ABE14: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823ABE18: 40980010  bge cr6, 0x823abe28
	if !ctx.cr[6].lt {
	pc = 0x823ABE28; continue 'dispatch;
	}
	// 823ABE1C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823ABE20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823ABE24: 4BFFFFB4  b 0x823abdd8
	pc = 0x823ABDD8; continue 'dispatch;
            }
            0x823ABE28 => {
    //   block [0x823ABE28..0x823ABE38)
	// 823ABE28: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823ABE2C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823ABE30: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 823ABE34: 995F0008  stb r10, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	pc = 0x823ABE38; continue 'dispatch;
            }
            0x823ABE38 => {
    //   block [0x823ABE38..0x823ABE44)
	// 823ABE38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823ABE3C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823ABE40: 481892C0  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ABE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823ABE48 size=592
    let mut pc: u32 = 0x823ABE48;
    'dispatch: loop {
        match pc {
            0x823ABE48 => {
    //   block [0x823ABE48..0x823ABEC4)
	// 823ABE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823ABE4C: 4818925D  bl 0x825350a8
	ctx.lr = 0x823ABE50;
	sub_82535080(ctx, base);
	// 823ABE50: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823ABE54: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823ABE58: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823ABE5C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 823ABE60: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 823ABE64: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 823ABE68: 816B3B48  lwz r11, 0x3b48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15176 as u32) ) } as u64;
	// 823ABE6C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 823ABE70: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ABE74: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823ABE78: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823ABE7C: 41990048  bgt cr6, 0x823abec4
	if ctx.cr[6].gt {
	pc = 0x823ABEC4; continue 'dispatch;
	}
	// 823ABE80: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823ABE84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823ABE88: 388B0800  addi r4, r11, 0x800
	ctx.r[4].s64 = ctx.r[11].s64 + 2048;
	// 823ABE8C: 4BF5B46D  bl 0x823072f8
	ctx.lr = 0x823ABE90;
	sub_823072F8(ctx, base);
	// 823ABE90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823ABE94: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823ABE98: 4BF5AEC1  bl 0x82306d58
	ctx.lr = 0x823ABE9C;
	sub_82306D58(ctx, base);
	// 823ABE9C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823ABEA0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823ABEA4: 3BCBCD70  addi r30, r11, -0x3290
	ctx.r[30].s64 = ctx.r[11].s64 + -12944;
	// 823ABEA8: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 823ABEAC: 4BF5AE4D  bl 0x82306cf8
	ctx.lr = 0x823ABEB0;
	sub_82306CF8(ctx, base);
	// 823ABEB0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823ABEB4: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 823ABEB8: 4BF5AF09  bl 0x82306dc0
	ctx.lr = 0x823ABEBC;
	sub_82306DC0(ctx, base);
	// 823ABEBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823ABEC0: 4BF5B0A9  bl 0x82306f68
	ctx.lr = 0x823ABEC4;
	sub_82306F68(ctx, base);
	pc = 0x823ABEC4; continue 'dispatch;
            }
            0x823ABEC4 => {
    //   block [0x823ABEC4..0x823ABF0C)
	// 823ABEC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823ABEC8: 839D0004  lwz r28, 4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABECC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823ABED0: 387D0001  addi r3, r29, 1
	ctx.r[3].s64 = ctx.r[29].s64 + 1;
	// 823ABED4: 48000275  bl 0x823ac148
	ctx.lr = 0x823ABED8;
	sub_823AC148(ctx, base);
	// 823ABED8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 823ABEDC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823ABEE0: 4182002C  beq 0x823abf0c
	if ctx.cr[0].eq {
	pc = 0x823ABF0C; continue 'dispatch;
	}
	// 823ABEE4: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823ABEE8: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 823ABEEC: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823ABEF0: 939E0008  stw r28, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 823ABEF4: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABEF8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823ABEFC: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABF00: 9B3E0014  stb r25, 0x14(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 823ABF04: 9B3E0015  stb r25, 0x15(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(21 as u32), ctx.r[25].u8 ) };
	// 823ABF08: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x823ABF0C; continue 'dispatch;
            }
            0x823ABF0C => {
    //   block [0x823ABF0C..0x823ABF38)
	// 823ABF0C: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ABF10: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABF14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823ABF18: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823ABF1C: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 823ABF20: 409A0018  bne cr6, 0x823abf38
	if !ctx.cr[6].eq {
	pc = 0x823ABF38; continue 'dispatch;
	}
	// 823ABF24: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823ABF28: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABF2C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823ABF30: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABF34: 4800003C  b 0x823abf70
	pc = 0x823ABF70; continue 'dispatch;
            }
            0x823ABF38 => {
    //   block [0x823ABF38..0x823ABF5C)
	// 823ABF38: 574B063F  clrlwi. r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823ABF3C: 41820020  beq 0x823abf5c
	if ctx.cr[0].eq {
	pc = 0x823ABF5C; continue 'dispatch;
	}
	// 823ABF40: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823ABF44: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABF48: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABF4C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823ABF50: 409A0024  bne cr6, 0x823abf74
	if !ctx.cr[6].eq {
	pc = 0x823ABF74; continue 'dispatch;
	}
	// 823ABF54: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823ABF58: 4800001C  b 0x823abf74
	pc = 0x823ABF74; continue 'dispatch;
            }
            0x823ABF5C => {
    //   block [0x823ABF5C..0x823ABF70)
	// 823ABF5C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823ABF60: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABF64: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ABF68: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823ABF6C: 409A0008  bne cr6, 0x823abf74
	if !ctx.cr[6].eq {
	pc = 0x823ABF74; continue 'dispatch;
	}
	pc = 0x823ABF70; continue 'dispatch;
            }
            0x823ABF70 => {
    //   block [0x823ABF70..0x823ABF74)
	// 823ABF70: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x823ABF74; continue 'dispatch;
            }
            0x823ABF74 => {
    //   block [0x823ABF74..0x823ABF88)
	// 823ABF74: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABF78: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 823ABF7C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 823ABF80: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 823ABF84: 480000E8  b 0x823ac06c
	pc = 0x823AC06C; continue 'dispatch;
            }
            0x823ABF88 => {
    //   block [0x823ABF88..0x823ABFC8)
	// 823ABF88: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABF8C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABF90: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABF94: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823ABF98: 409A0058  bne cr6, 0x823abff0
	if !ctx.cr[6].eq {
	pc = 0x823ABFF0; continue 'dispatch;
	}
	// 823ABF9C: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ABFA0: 89090014  lbz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 823ABFA4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823ABFA8: 419A0058  beq cr6, 0x823ac000
	if ctx.cr[6].eq {
	pc = 0x823AC000; continue 'dispatch;
	}
	// 823ABFAC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ABFB0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823ABFB4: 409A0014  bne cr6, 0x823abfc8
	if !ctx.cr[6].eq {
	pc = 0x823ABFC8; continue 'dispatch;
	}
	// 823ABFB8: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 823ABFBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823ABFC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823ABFC4: 4BFF50BD  bl 0x823a1080
	ctx.lr = 0x823ABFC8;
	sub_823A1080(ctx, base);
	pc = 0x823ABFC8; continue 'dispatch;
            }
            0x823ABFC8 => {
    //   block [0x823ABFC8..0x823ABFF0)
	// 823ABFC8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABFCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823ABFD0: 9B8B0014  stb r28, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[28].u8 ) };
	// 823ABFD4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABFD8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABFDC: 9B2B0014  stb r25, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 823ABFE0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABFE4: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ABFE8: 4BFF5101  bl 0x823a10e8
	ctx.lr = 0x823ABFEC;
	sub_823A10E8(ctx, base);
	// 823ABFEC: 48000078  b 0x823ac064
	pc = 0x823AC064; continue 'dispatch;
            }
            0x823ABFF0 => {
    //   block [0x823ABFF0..0x823AC000)
	// 823ABFF0: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ABFF4: 89090014  lbz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 823ABFF8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823ABFFC: 409A0028  bne cr6, 0x823ac024
	if !ctx.cr[6].eq {
	pc = 0x823AC024; continue 'dispatch;
	}
	pc = 0x823AC000; continue 'dispatch;
            }
            0x823AC000 => {
    //   block [0x823AC000..0x823AC024)
	// 823AC000: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC004: 9B8A0014  stb r28, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[28].u8 ) };
	// 823AC008: 9B890014  stb r28, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[28].u8 ) };
	// 823AC00C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC010: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC014: 9B2A0014  stb r25, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 823AC018: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC01C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC020: 48000044  b 0x823ac064
	pc = 0x823AC064; continue 'dispatch;
            }
            0x823AC024 => {
    //   block [0x823AC024..0x823AC040)
	// 823AC024: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC028: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AC02C: 409A0014  bne cr6, 0x823ac040
	if !ctx.cr[6].eq {
	pc = 0x823AC040; continue 'dispatch;
	}
	// 823AC030: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 823AC034: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823AC038: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823AC03C: 4BFF50AD  bl 0x823a10e8
	ctx.lr = 0x823AC040;
	sub_823A10E8(ctx, base);
	pc = 0x823AC040; continue 'dispatch;
            }
            0x823AC040 => {
    //   block [0x823AC040..0x823AC064)
	// 823AC040: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC044: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823AC048: 9B8B0014  stb r28, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[28].u8 ) };
	// 823AC04C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC050: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC054: 9B2B0014  stb r25, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 823AC058: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC05C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC060: 4BFF5021  bl 0x823a1080
	ctx.lr = 0x823AC064;
	sub_823A1080(ctx, base);
	pc = 0x823AC064; continue 'dispatch;
            }
            0x823AC064 => {
    //   block [0x823AC064..0x823AC06C)
	// 823AC064: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC068: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x823AC06C; continue 'dispatch;
            }
            0x823AC06C => {
    //   block [0x823AC06C..0x823AC098)
	// 823AC06C: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AC070: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823AC074: 419AFF14  beq cr6, 0x823abf88
	if ctx.cr[6].eq {
	pc = 0x823ABF88; continue 'dispatch;
	}
	// 823AC078: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC07C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 823AC080: 93D80004  stw r30, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823AC084: 93B80000  stw r29, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 823AC088: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC08C: 9B8B0014  stb r28, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[28].u8 ) };
	// 823AC090: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 823AC094: 48189064  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AC098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AC098 size=172
    let mut pc: u32 = 0x823AC098;
    'dispatch: loop {
        match pc {
            0x823AC098 => {
    //   block [0x823AC098..0x823AC0A8)
	// 823AC098: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC09C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823AC0A0: 409A0008  bne cr6, 0x823ac0a8
	if !ctx.cr[6].eq {
	pc = 0x823AC0A8; continue 'dispatch;
	}
	// 823AC0A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x823AC0A8; continue 'dispatch;
            }
            0x823AC0A8 => {
    //   block [0x823AC0A8..0x823AC0D0)
	// 823AC0A8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC0AC: 896A0015  lbz r11, 0x15(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 823AC0B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823AC0B4: 419A001C  beq cr6, 0x823ac0d0
	if ctx.cr[6].eq {
	pc = 0x823AC0D0; continue 'dispatch;
	}
	// 823AC0B8: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AC0BC: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AC0C0: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 823AC0C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823AC0C8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 823AC0CC: 48000070  b 0x823ac13c
	pc = 0x823AC13C; continue 'dispatch;
            }
            0x823AC0D0 => {
    //   block [0x823AC0D0..0x823AC0E8)
	// 823AC0D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC0D4: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 823AC0D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823AC0DC: 419A0010  beq cr6, 0x823ac0ec
	if ctx.cr[6].eq {
	pc = 0x823AC0EC; continue 'dispatch;
	}
	// 823AC0E0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC0E4: 4800003C  b 0x823ac120
	pc = 0x823AC120; continue 'dispatch;
            }
            0x823AC0E8 => {
    //   block [0x823AC0E8..0x823AC0EC)
	// 823AC0E8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x823AC0EC; continue 'dispatch;
            }
            0x823AC0EC => {
    //   block [0x823AC0EC..0x823AC0FC)
	// 823AC0EC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AC0F0: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 823AC0F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823AC0F8: 419AFFF0  beq cr6, 0x823ac0e8
	if ctx.cr[6].eq {
	pc = 0x823AC0E8; continue 'dispatch;
	}
	pc = 0x823AC0FC; continue 'dispatch;
            }
            0x823AC0FC => {
    //   block [0x823AC0FC..0x823AC104)
	// 823AC0FC: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AC100: 4E800020  blr
	return;
            }
            0x823AC104 => {
    //   block [0x823AC104..0x823AC120)
	// 823AC104: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC108: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC10C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823AC110: 409A001C  bne cr6, 0x823ac12c
	if !ctx.cr[6].eq {
	pc = 0x823AC12C; continue 'dispatch;
	}
	// 823AC114: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AC118: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823AC11C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823AC120; continue 'dispatch;
            }
            0x823AC120 => {
    //   block [0x823AC120..0x823AC12C)
	// 823AC120: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 823AC124: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823AC128: 419AFFDC  beq cr6, 0x823ac104
	if ctx.cr[6].eq {
	pc = 0x823AC104; continue 'dispatch;
	}
	pc = 0x823AC12C; continue 'dispatch;
            }
            0x823AC12C => {
    //   block [0x823AC12C..0x823AC13C)
	// 823AC12C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC130: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 823AC134: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823AC138: 419AFFC4  beq cr6, 0x823ac0fc
	if ctx.cr[6].eq {
	pc = 0x823AC0FC; continue 'dispatch;
	}
	pc = 0x823AC13C; continue 'dispatch;
            }
            0x823AC13C => {
    //   block [0x823AC13C..0x823AC144)
	// 823AC13C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 823AC140: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AC148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AC148 size=156
    let mut pc: u32 = 0x823AC148;
    'dispatch: loop {
        match pc {
            0x823AC148 => {
    //   block [0x823AC148..0x823AC170)
	// 823AC148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AC14C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AC150: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AC154: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 823AC158: 81693B44  lwz r11, 0x3b44(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(15172 as u32) ) } as u64;
	// 823AC15C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823AC160: 419A0010  beq cr6, 0x823ac170
	if ctx.cr[6].eq {
	pc = 0x823AC170; continue 'dispatch;
	}
	// 823AC164: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC168: 91493B44  stw r10, 0x3b44(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(15172 as u32), ctx.r[10].u32 ) };
	// 823AC16C: 48000054  b 0x823ac1c0
	pc = 0x823AC1C0; continue 'dispatch;
            }
            0x823AC170 => {
    //   block [0x823AC170..0x823AC1BC)
	// 823AC170: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 823AC174: 3D008311  lis r8, -0x7cef
	ctx.r[8].s64 = -2096037888;
	// 823AC178: 3CE08311  lis r7, -0x7cef
	ctx.r[7].s64 = -2096037888;
	// 823AC17C: 81693B5C  lwz r11, 0x3b5c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(15196 as u32) ) } as u64;
	// 823AC180: 81083B40  lwz r8, 0x3b40(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(15168 as u32) ) } as u64;
	// 823AC184: 80E73B3C  lwz r7, 0x3b3c(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(15164 as u32) ) } as u64;
	// 823AC188: 394B0018  addi r10, r11, 0x18
	ctx.r[10].s64 = ctx.r[11].s64 + 24;
	// 823AC18C: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 823AC190: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823AC194: 40990028  ble cr6, 0x823ac1bc
	if !ctx.cr[6].gt {
	pc = 0x823AC1BC; continue 'dispatch;
	}
	// 823AC198: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AC19C: 3CA0ACA4  lis r5, -0x535c
	ctx.r[5].s64 = -1398538240;
	// 823AC1A0: 386B07C8  addi r3, r11, 0x7c8
	ctx.r[3].s64 = ctx.r[11].s64 + 1992;
	// 823AC1A4: 38C00018  li r6, 0x18
	ctx.r[6].s64 = 24;
	// 823AC1A8: 60A5829B  ori r5, r5, 0x829b
	ctx.r[5].u64 = ctx.r[5].u64 | 33435;
	// 823AC1AC: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 823AC1B0: 481880F9  bl 0x825342a8
	ctx.lr = 0x823AC1B4;
	sub_825342A8(ctx, base);
	// 823AC1B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823AC1B8: 48000018  b 0x823ac1d0
	pc = 0x823AC1D0; continue 'dispatch;
            }
            0x823AC1BC => {
    //   block [0x823AC1BC..0x823AC1C0)
	// 823AC1BC: 91493B5C  stw r10, 0x3b5c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(15196 as u32), ctx.r[10].u32 ) };
	pc = 0x823AC1C0; continue 'dispatch;
            }
            0x823AC1C0 => {
    //   block [0x823AC1C0..0x823AC1D0)
	// 823AC1C0: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 823AC1C4: 812A3B48  lwz r9, 0x3b48(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15176 as u32) ) } as u64;
	// 823AC1C8: 3929FFE8  addi r9, r9, -0x18
	ctx.r[9].s64 = ctx.r[9].s64 + -24;
	// 823AC1CC: 912A3B48  stw r9, 0x3b48(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15176 as u32), ctx.r[9].u32 ) };
	pc = 0x823AC1D0; continue 'dispatch;
            }
            0x823AC1D0 => {
    //   block [0x823AC1D0..0x823AC1E4)
	// 823AC1D0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 823AC1D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823AC1D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AC1DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AC1E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AC1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AC1E8 size=168
    let mut pc: u32 = 0x823AC1E8;
    'dispatch: loop {
        match pc {
            0x823AC1E8 => {
    //   block [0x823AC1E8..0x823AC204)
	// 823AC1E8: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AC1EC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AC1F0: 41820014  beq 0x823ac204
	if ctx.cr[0].eq {
	pc = 0x823AC204; continue 'dispatch;
	}
	// 823AC1F4: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 823AC1F8: 216B001F  subfic r11, r11, 0x1f
	ctx.xer.ca = ctx.r[11].u32 <= 31 as u32;
	ctx.r[11].s64 = (31 as i64) - ctx.r[11].s64;
	// 823AC1FC: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 823AC200: 4098000C  bge cr6, 0x823ac20c
	if !ctx.cr[6].lt {
	pc = 0x823AC20C; continue 'dispatch;
	}
	pc = 0x823AC204; continue 'dispatch;
            }
            0x823AC204 => {
    //   block [0x823AC204..0x823AC20C)
	// 823AC204: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823AC208: 48000008  b 0x823ac210
	pc = 0x823AC210; continue 'dispatch;
            }
            0x823AC20C => {
    //   block [0x823AC20C..0x823AC210)
	// 823AC20C: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	pc = 0x823AC210; continue 'dispatch;
            }
            0x823AC210 => {
    //   block [0x823AC210..0x823AC248)
	// 823AC210: 7D295C30  srw r9, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) >> ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823AC214: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AC218: 552906FE  clrlwi r9, r9, 0x1b
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 823AC21C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823AC220: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823AC224: 394A0006  addi r10, r10, 6
	ctx.r[10].s64 = ctx.r[10].s64 + 6;
	// 823AC228: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AC22C: 9104000C  stw r8, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 823AC230: 7D0A182E  lwzx r8, r10, r3
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AC234: 91040008  stw r8, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 823AC238: 7D0A182E  lwzx r8, r10, r3
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AC23C: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AC240: 41820008  beq 0x823ac248
	if ctx.cr[0].eq {
	pc = 0x823AC248; continue 'dispatch;
	}
	// 823AC244: 9088000C  stw r4, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	pc = 0x823AC248; continue 'dispatch;
            }
            0x823AC248 => {
    //   block [0x823AC248..0x823AC290)
	// 823AC248: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 823AC24C: 7C8A192E  stwx r4, r10, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32), ctx.r[4].u32) };
	// 823AC250: 81430D98  lwz r10, 0xd98(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(3480 as u32) ) } as u64;
	// 823AC254: 390B0367  addi r8, r11, 0x367
	ctx.r[8].s64 = ctx.r[11].s64 + 871;
	// 823AC258: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823AC25C: 7CEB5830  slw r11, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823AC260: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 823AC264: 7CEA4830  slw r10, r7, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[7].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 823AC268: 91630D98  stw r11, 0xd98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(3480 as u32), ctx.r[11].u32 ) };
	// 823AC26C: 7D68182E  lwzx r11, r8, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AC270: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 823AC274: 7D68192E  stwx r11, r8, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32), ctx.r[11].u32) };
	// 823AC278: 90E40018  stw r7, 0x18(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 823AC27C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AC280: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AC284: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823AC288: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823AC28C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AC290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AC290 size=220
    let mut pc: u32 = 0x823AC290;
    'dispatch: loop {
        match pc {
            0x823AC290 => {
    //   block [0x823AC290..0x823AC2B8)
	// 823AC290: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823AC294: 2F05FFFF  cmpwi cr6, r5, -1
	ctx.cr[6].compare_i32(ctx.r[5].s32, -1, &mut ctx.xer);
	// 823AC298: 409A0034  bne cr6, 0x823ac2cc
	if !ctx.cr[6].eq {
	pc = 0x823AC2CC; continue 'dispatch;
	}
	// 823AC29C: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AC2A0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AC2A4: 41820014  beq 0x823ac2b8
	if ctx.cr[0].eq {
	pc = 0x823AC2B8; continue 'dispatch;
	}
	// 823AC2A8: 7D4B0034  cntlzw r11, r10
	ctx.r[11].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 823AC2AC: 216B001F  subfic r11, r11, 0x1f
	ctx.xer.ca = ctx.r[11].u32 <= 31 as u32;
	ctx.r[11].s64 = (31 as i64) - ctx.r[11].s64;
	// 823AC2B0: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 823AC2B4: 4098000C  bge cr6, 0x823ac2c0
	if !ctx.cr[6].lt {
	pc = 0x823AC2C0; continue 'dispatch;
	}
	pc = 0x823AC2B8; continue 'dispatch;
            }
            0x823AC2B8 => {
    //   block [0x823AC2B8..0x823AC2C0)
	// 823AC2B8: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 823AC2BC: 48000008  b 0x823ac2c4
	pc = 0x823AC2C4; continue 'dispatch;
            }
            0x823AC2C0 => {
    //   block [0x823AC2C0..0x823AC2C4)
	// 823AC2C0: 38ABFFFC  addi r5, r11, -4
	ctx.r[5].s64 = ctx.r[11].s64 + -4;
	pc = 0x823AC2C4; continue 'dispatch;
            }
            0x823AC2C4 => {
    //   block [0x823AC2C4..0x823AC2CC)
	// 823AC2C4: 7D4B2C30  srw r11, r10, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) >> ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 823AC2C8: 556606FE  clrlwi r6, r11, 0x1b
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	pc = 0x823AC2CC; continue 'dispatch;
            }
            0x823AC2CC => {
    //   block [0x823AC2CC..0x823AC300)
	// 823AC2CC: 54AB2834  slwi r11, r5, 5
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823AC2D0: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 823AC2D4: 396B0006  addi r11, r11, 6
	ctx.r[11].s64 = ctx.r[11].s64 + 6;
	// 823AC2D8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AC2DC: 7D6A182E  lwzx r11, r10, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AC2E0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AC2E4: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AC2E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AC2EC: 409A0014  bne cr6, 0x823ac300
	if !ctx.cr[6].eq {
	pc = 0x823AC300; continue 'dispatch;
	}
	// 823AC2F0: 7D6A192E  stwx r11, r10, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32), ctx.r[11].u32) };
	// 823AC2F4: 41820028  beq 0x823ac31c
	if ctx.cr[0].eq {
	pc = 0x823AC31C; continue 'dispatch;
	}
	// 823AC2F8: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 823AC2FC: 48000014  b 0x823ac310
	pc = 0x823AC310; continue 'dispatch;
            }
            0x823AC300 => {
    //   block [0x823AC300..0x823AC310)
	// 823AC300: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AC304: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823AC308: 41820008  beq 0x823ac310
	if ctx.cr[0].eq {
	pc = 0x823AC310; continue 'dispatch;
	}
	// 823AC30C: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	pc = 0x823AC310; continue 'dispatch;
            }
            0x823AC310 => {
    //   block [0x823AC310..0x823AC31C)
	// 823AC310: 7D6A182E  lwzx r11, r10, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AC314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823AC318: 409A0034  bne cr6, 0x823ac34c
	if !ctx.cr[6].eq {
	pc = 0x823AC34C; continue 'dispatch;
	}
	pc = 0x823AC31C; continue 'dispatch;
            }
            0x823AC31C => {
    //   block [0x823AC31C..0x823AC34C)
	// 823AC31C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823AC320: 39650367  addi r11, r5, 0x367
	ctx.r[11].s64 = ctx.r[5].s64 + 871;
	// 823AC324: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AC328: 7CEA182E  lwzx r7, r10, r3
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AC32C: 7D2B3030  slw r11, r9, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[9].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 823AC330: 7CEB5879  andc. r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 & !ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AC334: 7D6A192E  stwx r11, r10, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32), ctx.r[11].u32) };
	// 823AC338: 40820014  bne 0x823ac34c
	if !ctx.cr[0].eq {
	pc = 0x823AC34C; continue 'dispatch;
	}
	// 823AC33C: 81630D98  lwz r11, 0xd98(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(3480 as u32) ) } as u64;
	// 823AC340: 7D2A2830  slw r10, r9, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[9].u32) << ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 823AC344: 7D6B5078  andc r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & !ctx.r[10].u64;
	// 823AC348: 91630D98  stw r11, 0xd98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(3480 as u32), ctx.r[11].u32 ) };
	pc = 0x823AC34C; continue 'dispatch;
            }
            0x823AC34C => {
    //   block [0x823AC34C..0x823AC36C)
	// 823AC34C: 9104000C  stw r8, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 823AC350: 91040008  stw r8, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 823AC354: 91040018  stw r8, 0x18(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 823AC358: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AC35C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AC360: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823AC364: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823AC368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AC370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AC370 size=336
    let mut pc: u32 = 0x823AC370;
    'dispatch: loop {
        match pc {
            0x823AC370 => {
    //   block [0x823AC370..0x823AC398)
	// 823AC370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AC374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AC378: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AC37C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AC380: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823AC384: 419A0014  beq cr6, 0x823ac398
	if ctx.cr[6].eq {
	pc = 0x823AC398; continue 'dispatch;
	}
	// 823AC388: 7C8B0034  cntlzw r11, r4
	ctx.r[11].u64 = if ctx.r[4].u32 == 0 { 32 } else { ctx.r[4].u32.leading_zeros() as u64 };
	// 823AC38C: 216B001F  subfic r11, r11, 0x1f
	ctx.xer.ca = ctx.r[11].u32 <= 31 as u32;
	ctx.r[11].s64 = (31 as i64) - ctx.r[11].s64;
	// 823AC390: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 823AC394: 4098000C  bge cr6, 0x823ac3a0
	if !ctx.cr[6].lt {
	pc = 0x823AC3A0; continue 'dispatch;
	}
	pc = 0x823AC398; continue 'dispatch;
            }
            0x823AC398 => {
    //   block [0x823AC398..0x823AC3A0)
	// 823AC398: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823AC39C: 48000008  b 0x823ac3a4
	pc = 0x823AC3A4; continue 'dispatch;
            }
            0x823AC3A0 => {
    //   block [0x823AC3A0..0x823AC3A4)
	// 823AC3A0: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	pc = 0x823AC3A4; continue 'dispatch;
            }
            0x823AC3A4 => {
    //   block [0x823AC3A4..0x823AC3D4)
	// 823AC3A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 823AC3A8: 7C895C30  srw r9, r4, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[4].u32) >> ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823AC3AC: 552606FE  clrlwi r6, r9, 0x1b
	ctx.r[6].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 823AC3B0: 7CEA5830  slw r10, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823AC3B4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823AC3B8: 7D4A2039  and. r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[4].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AC3BC: 41820018  beq 0x823ac3d4
	if ctx.cr[0].eq {
	pc = 0x823AC3D4; continue 'dispatch;
	}
	// 823AC3C0: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 823AC3C4: 2B060020  cmplwi cr6, r6, 0x20
	ctx.cr[6].compare_u32(ctx.r[6].u32, 32 as u32, &mut ctx.xer);
	// 823AC3C8: 4198000C  blt cr6, 0x823ac3d4
	if ctx.cr[6].lt {
	pc = 0x823AC3D4; continue 'dispatch;
	}
	// 823AC3CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823AC3D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	pc = 0x823AC3D4; continue 'dispatch;
            }
            0x823AC3D4 => {
    //   block [0x823AC3D4..0x823AC3E0)
	// 823AC3D4: 81030D98  lwz r8, 0xd98(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(3480 as u32) ) } as u64;
	// 823AC3D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823AC3DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x823AC3E0; continue 'dispatch;
            }
            0x823AC3E0 => {
    //   block [0x823AC3E0..0x823AC404)
	// 823AC3E0: 7CE95830  slw r9, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823AC3E4: 394B0367  addi r10, r11, 0x367
	ctx.r[10].s64 = ctx.r[11].s64 + 871;
	// 823AC3E8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AC3EC: 7D4A182E  lwzx r10, r10, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AC3F0: 7D294039  and. r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823AC3F4: 41820010  beq 0x823ac404
	if ctx.cr[0].eq {
	pc = 0x823AC404; continue 'dispatch;
	}
	// 823AC3F8: 7CE93030  slw r9, r7, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[7].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 823AC3FC: 7D295039  and. r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823AC400: 40820074  bne 0x823ac474
	if !ctx.cr[0].eq {
	pc = 0x823AC474; continue 'dispatch;
	}
	pc = 0x823AC404; continue 'dispatch;
            }
            0x823AC404 => {
    //   block [0x823AC404..0x823AC440)
	// 823AC404: 7CE93030  slw r9, r7, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[7].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 823AC408: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823AC40C: 7D4A4879  andc. r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & !ctx.r[9].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AC410: 40820048  bne 0x823ac458
	if !ctx.cr[0].eq {
	pc = 0x823AC458; continue 'dispatch;
	}
	// 823AC414: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 823AC418: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823AC41C: 7CEA5030  slw r10, r7, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[7].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 823AC420: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823AC424: 7D0A5079  andc. r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 & !ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AC428: 41820050  beq 0x823ac478
	if ctx.cr[0].eq {
	pc = 0x823AC478; continue 'dispatch;
	}
	// 823AC42C: 7D6A00D0  neg r11, r10
	ctx.r[11].s64 = -ctx.r[10].s64;
	// 823AC430: 7D6B5039  and. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AC434: 4082000C  bne 0x823ac440
	if !ctx.cr[0].eq {
	pc = 0x823AC440; continue 'dispatch;
	}
	// 823AC438: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823AC43C: 4800000C  b 0x823ac448
	pc = 0x823AC448; continue 'dispatch;
            }
            0x823AC440 => {
    //   block [0x823AC440..0x823AC448)
	// 823AC440: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823AC444: 216B001F  subfic r11, r11, 0x1f
	ctx.xer.ca = ctx.r[11].u32 <= 31 as u32;
	ctx.r[11].s64 = (31 as i64) - ctx.r[11].s64;
	pc = 0x823AC448; continue 'dispatch;
            }
            0x823AC448 => {
    //   block [0x823AC448..0x823AC458)
	// 823AC448: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 823AC44C: 2F040002  cmpwi cr6, r4, 2
	ctx.cr[6].compare_i32(ctx.r[4].s32, 2, &mut ctx.xer);
	// 823AC450: 4198FF90  blt cr6, 0x823ac3e0
	if ctx.cr[6].lt {
	pc = 0x823AC3E0; continue 'dispatch;
	}
	// 823AC454: 48000024  b 0x823ac478
	pc = 0x823AC478; continue 'dispatch;
            }
            0x823AC458 => {
    //   block [0x823AC458..0x823AC46C)
	// 823AC458: 7D2A00D0  neg r9, r10
	ctx.r[9].s64 = -ctx.r[10].s64;
	// 823AC45C: 7D2A5039  and. r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AC460: 4082000C  bne 0x823ac46c
	if !ctx.cr[0].eq {
	pc = 0x823AC46C; continue 'dispatch;
	}
	// 823AC464: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823AC468: 4800000C  b 0x823ac474
	pc = 0x823AC474; continue 'dispatch;
            }
            0x823AC46C => {
    //   block [0x823AC46C..0x823AC474)
	// 823AC46C: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 823AC470: 20CA001F  subfic r6, r10, 0x1f
	ctx.xer.ca = ctx.r[10].u32 <= 31 as u32;
	ctx.r[6].s64 = (31 as i64) - ctx.r[10].s64;
	pc = 0x823AC474; continue 'dispatch;
            }
            0x823AC474 => {
    //   block [0x823AC474..0x823AC478)
	// 823AC474: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	pc = 0x823AC478; continue 'dispatch;
            }
            0x823AC478 => {
    //   block [0x823AC478..0x823AC488)
	// 823AC478: 54AA063F  clrlwi. r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AC47C: 4082000C  bne 0x823ac488
	if !ctx.cr[0].eq {
	pc = 0x823AC488; continue 'dispatch;
	}
	// 823AC480: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AC484: 48000028  b 0x823ac4ac
	pc = 0x823AC4AC; continue 'dispatch;
            }
            0x823AC488 => {
    //   block [0x823AC488..0x823AC4AC)
	// 823AC488: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AC48C: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 823AC490: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 823AC494: 396A0006  addi r11, r10, 6
	ctx.r[11].s64 = ctx.r[10].s64 + 6;
	// 823AC498: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823AC49C: 7FEB182E  lwzx r31, r11, r3
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AC4A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823AC4A4: 4BFFFDED  bl 0x823ac290
	ctx.lr = 0x823AC4A8;
	sub_823AC290(ctx, base);
	// 823AC4A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x823AC4AC; continue 'dispatch;
            }
            0x823AC4AC => {
    //   block [0x823AC4AC..0x823AC4C0)
	// 823AC4AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823AC4B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AC4B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AC4B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AC4BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AC4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AC4C0 size=172
    let mut pc: u32 = 0x823AC4C0;
    'dispatch: loop {
        match pc {
            0x823AC4C0 => {
    //   block [0x823AC4C0..0x823AC4E8)
	// 823AC4C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AC4C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AC4C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AC4CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AC4D0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 823AC4D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC4D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AC4DC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AC4E0: 41820008  beq 0x823ac4e8
	if ctx.cr[0].eq {
	pc = 0x823AC4E8; continue 'dispatch;
	}
	// 823AC4E4: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x823AC4E8; continue 'dispatch;
            }
            0x823AC4E8 => {
    //   block [0x823AC4E8..0x823AC51C)
	// 823AC4E8: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AC4EC: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AC4F0: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AC4F4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823AC4F8: 816B3B58  lwz r11, 0x3b58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15192 as u32) ) } as u64;
	// 823AC4FC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AC500: 91440014  stw r10, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 823AC504: 41980018  blt cr6, 0x823ac51c
	if ctx.cr[6].lt {
	pc = 0x823AC51C; continue 'dispatch;
	}
	// 823AC508: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 823AC50C: 814A3B54  lwz r10, 0x3b54(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15188 as u32) ) } as u64;
	// 823AC510: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823AC514: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AC518: 41980020  blt cr6, 0x823ac538
	if ctx.cr[6].lt {
	pc = 0x823AC538; continue 'dispatch;
	}
	pc = 0x823AC51C; continue 'dispatch;
            }
            0x823AC51C => {
    //   block [0x823AC51C..0x823AC538)
	// 823AC51C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AC520: 3CA0ACA4  lis r5, -0x535c
	ctx.r[5].s64 = -1398538240;
	// 823AC524: 386B059C  addi r3, r11, 0x59c
	ctx.r[3].s64 = ctx.r[11].s64 + 1436;
	// 823AC528: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 823AC52C: 60A5829A  ori r5, r5, 0x829a
	ctx.r[5].u64 = ctx.r[5].u64 | 33434;
	// 823AC530: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 823AC534: 48187D75  bl 0x825342a8
	ctx.lr = 0x823AC538;
	sub_825342A8(ctx, base);
	pc = 0x823AC538; continue 'dispatch;
            }
            0x823AC538 => {
    //   block [0x823AC538..0x823AC56C)
	// 823AC538: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AC53C: 814B3B50  lwz r10, 0x3b50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15184 as u32) ) } as u64;
	// 823AC540: 93EB3B50  stw r31, 0x3b50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(15184 as u32), ctx.r[31].u32 ) };
	// 823AC544: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AC548: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AC54C: 812B3B4C  lwz r9, 0x3b4c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15180 as u32) ) } as u64;
	// 823AC550: 3929001C  addi r9, r9, 0x1c
	ctx.r[9].s64 = ctx.r[9].s64 + 28;
	// 823AC554: 912B3B4C  stw r9, 0x3b4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(15180 as u32), ctx.r[9].u32 ) };
	// 823AC558: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823AC55C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AC560: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AC564: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AC568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AC570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AC570 size=308
    let mut pc: u32 = 0x823AC570;
    'dispatch: loop {
        match pc {
            0x823AC570 => {
    //   block [0x823AC570..0x823AC5B4)
	// 823AC570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AC574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AC578: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AC57C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AC580: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AC584: 48360CD9  bl 0x8270d25c
	ctx.lr = 0x823AC588;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823AC588: 80FF1064  lwz r7, 0x1064(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4196 as u32) ) } as u64;
	// 823AC58C: 397F1020  addi r11, r31, 0x1020
	ctx.r[11].s64 = ctx.r[31].s64 + 4128;
	// 823AC590: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823AC594: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AC598: 418200A0  beq 0x823ac638
	if ctx.cr[0].eq {
	pc = 0x823AC638; continue 'dispatch;
	}
	// 823AC59C: 815F1068  lwz r10, 0x1068(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4200 as u32) ) } as u64;
	// 823AC5A0: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 823AC5A4: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823AC5A8: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 823AC5AC: 40810028  ble 0x823ac5d4
	if !ctx.cr[0].gt {
	pc = 0x823AC5D4; continue 'dispatch;
	}
	// 823AC5B0: 39470014  addi r10, r7, 0x14
	ctx.r[10].s64 = ctx.r[7].s64 + 20;
	pc = 0x823AC5B4; continue 'dispatch;
            }
            0x823AC5B4 => {
    //   block [0x823AC5B4..0x823AC5D4)
	// 823AC5B4: 38CAFFD8  addi r6, r10, -0x28
	ctx.r[6].s64 = ctx.r[10].s64 + -40;
	// 823AC5B8: 914AFFF0  stw r10, -0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16 as u32), ctx.r[10].u32 ) };
	// 823AC5BC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823AC5C0: 90CAFFEC  stw r6, -0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-20 as u32), ctx.r[6].u32 ) };
	// 823AC5C4: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 823AC5C8: 80CB0040  lwz r6, 0x40(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 823AC5CC: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823AC5D0: 4198FFE4  blt cr6, 0x823ac5b4
	if ctx.cr[6].lt {
	pc = 0x823AC5B4; continue 'dispatch;
	}
	pc = 0x823AC5D4; continue 'dispatch;
            }
            0x823AC5D4 => {
    //   block [0x823AC5D4..0x823AC638)
	// 823AC5D4: 394B0020  addi r10, r11, 0x20
	ctx.r[10].s64 = ctx.r[11].s64 + 32;
	// 823AC5D8: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AC5DC: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 823AC5E0: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AC5E4: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AC5E8: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AC5EC: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 823AC5F0: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AC5F4: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 823AC5F8: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 823AC5FC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AC600: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC604: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AC608: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AC60C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AC610: 80EB001C  lwz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AC614: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823AC618: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC61C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823AC620: 394AFFEC  addi r10, r10, -0x14
	ctx.r[10].s64 = ctx.r[10].s64 + -20;
	// 823AC624: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AC628: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AC62C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC630: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AC634: 48000034  b 0x823ac668
	pc = 0x823AC668; continue 'dispatch;
            }
            0x823AC638 => {
    //   block [0x823AC638..0x823AC668)
	// 823AC638: 394B0020  addi r10, r11, 0x20
	ctx.r[10].s64 = ctx.r[11].s64 + 32;
	// 823AC63C: 910B0040  stw r8, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[8].u32 ) };
	// 823AC640: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AC644: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 823AC648: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AC64C: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AC650: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AC654: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AC658: 910B0014  stw r8, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 823AC65C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AC660: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AC664: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823AC668; continue 'dispatch;
            }
            0x823AC668 => {
    //   block [0x823AC668..0x823AC674)
	// 823AC668: 393F1040  addi r9, r31, 0x1040
	ctx.r[9].s64 = ctx.r[31].s64 + 4160;
	// 823AC66C: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 823AC670: 39400200  li r10, 0x200
	ctx.r[10].s64 = 512;
	pc = 0x823AC674; continue 'dispatch;
            }
            0x823AC674 => {
    //   block [0x823AC674..0x823AC6A4)
	// 823AC674: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 823AC678: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AC67C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823AC680: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 823AC684: 4082FFF0  bne 0x823ac674
	if !ctx.cr[0].eq {
	pc = 0x823AC674; continue 'dispatch;
	}
	// 823AC688: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AC68C: 48360BE1  bl 0x8270d26c
	ctx.lr = 0x823AC690;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823AC690: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823AC694: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AC698: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AC69C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AC6A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AC6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AC6A8 size=384
    let mut pc: u32 = 0x823AC6A8;
    'dispatch: loop {
        match pc {
            0x823AC6A8 => {
    //   block [0x823AC6A8..0x823AC7CC)
	// 823AC6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AC6AC: 48188A05  bl 0x825350b0
	ctx.lr = 0x823AC6B0;
	sub_82535080(ctx, base);
	// 823AC6B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AC6B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AC6B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823AC6BC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 823AC6C0: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 823AC6C4: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 823AC6C8: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 823AC6CC: 48360B91  bl 0x8270d25c
	ctx.lr = 0x823AC6D0;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823AC6D0: 393E0004  addi r9, r30, 4
	ctx.r[9].s64 = ctx.r[30].s64 + 4;
	// 823AC6D4: 80E100FC  lwz r7, 0xfc(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 823AC6D8: 7F480034  cntlzw r8, r26
	ctx.r[8].u64 = if ctx.r[26].u32 == 0 { 32 } else { ctx.r[26].u32.leading_zeros() as u64 };
	// 823AC6DC: 55241838  slwi r4, r9, 3
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 823AC6E0: 7F690034  cntlzw r9, r27
	ctx.r[9].u64 = if ctx.r[27].u32 == 0 { 32 } else { ctx.r[27].u32.leading_zeros() as u64 };
	// 823AC6E4: 5508DFFE  rlwinm r8, r8, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 823AC6E8: 5529EF7A  rlwinm r9, r9, 0x1d, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 823AC6EC: 69080001  xori r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u64 ^ 1;
	// 823AC6F0: 69290004  xori r9, r9, 4
	ctx.r[9].u64 = ctx.r[9].u64 ^ 4;
	// 823AC6F4: 7CE70034  cntlzw r7, r7
	ctx.r[7].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 823AC6F8: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 823AC6FC: 54E8DFFE  rlwinm r8, r7, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 823AC700: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823AC704: 69080001  xori r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u64 ^ 1;
	// 823AC708: 57C6B810  slwi r6, r30, 0x17
	ctx.r[6].u32 = ctx.r[30].u32.wrapping_shl(23);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 823AC70C: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 823AC710: 81010104  lwz r8, 0x104(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 823AC714: 57CA1838  slwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AC718: 7D080034  cntlzw r8, r8
	ctx.r[8].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 823AC71C: 513D1838  rlwimi r29, r9, 3, 0, 0x1c
	ctx.r[29].u64 = (((ctx.r[9].u32).rotate_left(3) as u64) & 0x00000000FFFFFFF8) | (ctx.r[29].u64 & 0xFFFFFFFF00000007);
	// 823AC720: 5509DFFE  rlwinm r9, r8, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 823AC724: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823AC728: 57A7083C  slwi r7, r29, 1
	ctx.r[7].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 823AC72C: 550804BE  clrlwi r8, r8, 0x12
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x00003FFFu64;
	// 823AC730: 69290001  xori r9, r9, 1
	ctx.r[9].u64 = ctx.r[9].u64 ^ 1;
	// 823AC734: 7D083378  or r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[6].u64;
	// 823AC738: 80C100F4  lwz r6, 0xf4(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 823AC73C: 7CE94B78  or r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 | ctx.r[9].u64;
	// 823AC740: 7CE4F82E  lwzx r7, r4, r31
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823AC744: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 823AC748: 55080490  rlwinm r8, r8, 0, 0x12, 8
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 823AC74C: 55297022  slwi r9, r9, 0xe
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(14);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823AC750: 397F1020  addi r11, r31, 0x1020
	ctx.r[11].s64 = ctx.r[31].s64 + 4128;
	// 823AC754: 7D254378  or r5, r9, r8
	ctx.r[5].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 823AC758: 810A0024  lwz r8, 0x24(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 823AC75C: 392B0020  addi r9, r11, 0x20
	ctx.r[9].s64 = ctx.r[11].s64 + 32;
	// 823AC760: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823AC764: 910A0024  stw r8, 0x24(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[8].u32 ) };
	// 823AC768: 810B001C  lwz r8, 0x1c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AC76C: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC770: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC774: 90680000  stw r3, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823AC778: 810B001C  lwz r8, 0x1c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AC77C: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC780: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AC784: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AC788: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 823AC78C: 910B0014  stw r8, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 823AC790: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	// 823AC794: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 823AC798: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 823AC79C: 90AB0008  stw r5, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 823AC7A0: 81690018  lwz r11, 0x18(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AC7A4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC7A8: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823AC7AC: 409A0044  bne cr6, 0x823ac7f0
	if !ctx.cr[6].eq {
	pc = 0x823AC7F0; continue 'dispatch;
	}
	// 823AC7B0: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AC7B4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823AC7B8: 409A0014  bne cr6, 0x823ac7cc
	if !ctx.cr[6].eq {
	pc = 0x823AC7CC; continue 'dispatch;
	}
	// 823AC7BC: 8169001C  lwz r11, 0x1c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AC7C0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AC7C4: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823AC7C8: 48000018  b 0x823ac7e0
	pc = 0x823AC7E0; continue 'dispatch;
            }
            0x823AC7CC => {
    //   block [0x823AC7CC..0x823AC7E0)
	// 823AC7CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC7D0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AC7D4: 81690018  lwz r11, 0x18(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AC7D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC7DC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x823AC7E0; continue 'dispatch;
            }
            0x823AC7E0 => {
    //   block [0x823AC7E0..0x823AC7F0)
	// 823AC7E0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823AC7E4: 81690018  lwz r11, 0x18(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AC7E8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AC7EC: 48000018  b 0x823ac804
	pc = 0x823AC804; continue 'dispatch;
            }
            0x823AC7F0 => {
    //   block [0x823AC7F0..0x823AC804)
	// 823AC7F0: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC7F4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AC7F8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823AC7FC: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 823AC800: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x823AC804; continue 'dispatch;
            }
            0x823AC804 => {
    //   block [0x823AC804..0x823AC828)
	// 823AC804: 81690014  lwz r11, 0x14(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AC808: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AC80C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823AC810: 91690014  stw r11, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 823AC814: 7D44F92E  stwx r10, r4, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	// 823AC818: 48360A55  bl 0x8270d26c
	ctx.lr = 0x823AC81C;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823AC81C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823AC820: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823AC824: 481888DC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AC828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AC828 size=352
    let mut pc: u32 = 0x823AC828;
    'dispatch: loop {
        match pc {
            0x823AC828 => {
    //   block [0x823AC828..0x823AC8A0)
	// 823AC828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AC82C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AC830: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823AC834: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AC838: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AC83C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AC840: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823AC844: 48360A19  bl 0x8270d25c
	ctx.lr = 0x823AC848;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823AC848: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AC84C: 393F1020  addi r9, r31, 0x1020
	ctx.r[9].s64 = ctx.r[31].s64 + 4128;
	// 823AC850: 55674DFE  srwi r7, r11, 0x17
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shr(23);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 823AC854: 39490020  addi r10, r9, 0x20
	ctx.r[10].s64 = ctx.r[9].s64 + 32;
	// 823AC858: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823AC85C: 397EFFF8  addi r11, r30, -8
	ctx.r[11].s64 = ctx.r[30].s64 + -8;
	// 823AC860: 7CC8FA14  add r6, r8, r31
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[31].u64;
	// 823AC864: 81060024  lwz r8, 0x24(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 823AC868: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 823AC86C: 91060024  stw r8, 0x24(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(36 as u32), ctx.r[8].u32 ) };
	// 823AC870: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AC874: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC878: 80880000  lwz r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC87C: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 823AC880: 409A0020  bne cr6, 0x823ac8a0
	if !ctx.cr[6].eq {
	pc = 0x823AC8A0; continue 'dispatch;
	}
	// 823AC884: 5484003E  slwi r4, r4, 0
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 823AC888: 80840004  lwz r4, 4(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC88C: 90880000  stw r4, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 823AC890: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AC894: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC898: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AC89C: 48000048  b 0x823ac8e4
	pc = 0x823AC8E4; continue 'dispatch;
            }
            0x823AC8A0 => {
    //   block [0x823AC8A0..0x823AC8CC)
	// 823AC8A0: 810A001C  lwz r8, 0x1c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AC8A4: 80880000  lwz r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC8A8: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 823AC8AC: 409A0020  bne cr6, 0x823ac8cc
	if !ctx.cr[6].eq {
	pc = 0x823AC8CC; continue 'dispatch;
	}
	// 823AC8B0: 5484003E  slwi r4, r4, 0
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 823AC8B4: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC8B8: 90880000  stw r4, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 823AC8BC: 810A001C  lwz r8, 0x1c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AC8C0: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC8C4: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823AC8C8: 4800001C  b 0x823ac8e4
	pc = 0x823AC8E4; continue 'dispatch;
            }
            0x823AC8CC => {
    //   block [0x823AC8CC..0x823AC8E4)
	// 823AC8CC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC8D0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC8D4: 90880004  stw r4, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 823AC8D8: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AC8DC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC8E0: 90880000  stw r4, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	pc = 0x823AC8E4; continue 'dispatch;
            }
            0x823AC8E4 => {
    //   block [0x823AC8E4..0x823AC90C)
	// 823AC8E4: 810A0014  lwz r8, 0x14(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AC8E8: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 823AC8EC: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 823AC8F0: 81490014  lwz r10, 0x14(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AC8F4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AC8F8: 409A0014  bne cr6, 0x823ac90c
	if !ctx.cr[6].eq {
	pc = 0x823AC90C; continue 'dispatch;
	}
	// 823AC8FC: 81490018  lwz r10, 0x18(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AC900: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AC904: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823AC908: 4800001C  b 0x823ac924
	pc = 0x823AC924; continue 'dispatch;
            }
            0x823AC90C => {
    //   block [0x823AC90C..0x823AC924)
	// 823AC90C: 8149001C  lwz r10, 0x1c(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AC910: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC914: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AC918: 8149001C  lwz r10, 0x1c(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AC91C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC920: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x823AC924; continue 'dispatch;
            }
            0x823AC924 => {
    //   block [0x823AC924..0x823AC954)
	// 823AC924: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823AC928: 39470004  addi r10, r7, 4
	ctx.r[10].s64 = ctx.r[7].s64 + 4;
	// 823AC92C: 8109001C  lwz r8, 0x1c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AC930: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AC934: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AC938: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AC93C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823AC940: 91090014  stw r8, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 823AC944: 7D2AF82E  lwzx r9, r10, r31
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823AC948: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AC94C: 409A0008  bne cr6, 0x823ac954
	if !ctx.cr[6].eq {
	pc = 0x823AC954; continue 'dispatch;
	}
	// 823AC950: 7CAAF92E  stwx r5, r10, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[5].u32) };
	pc = 0x823AC954; continue 'dispatch;
            }
            0x823AC954 => {
    //   block [0x823AC954..0x823AC968)
	// 823AC954: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 823AC958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823AC95C: 409A000C  bne cr6, 0x823ac968
	if !ctx.cr[6].eq {
	pc = 0x823AC968; continue 'dispatch;
	}
	// 823AC960: 397F1040  addi r11, r31, 0x1040
	ctx.r[11].s64 = ctx.r[31].s64 + 4160;
	// 823AC964: 7D6AF92E  stwx r11, r10, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u32) };
	pc = 0x823AC968; continue 'dispatch;
            }
            0x823AC968 => {
    //   block [0x823AC968..0x823AC988)
	// 823AC968: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AC96C: 48360901  bl 0x8270d26c
	ctx.lr = 0x823AC970;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823AC970: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823AC974: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AC978: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AC97C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823AC980: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AC984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AC988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AC988 size=456
    let mut pc: u32 = 0x823AC988;
    'dispatch: loop {
        match pc {
            0x823AC988 => {
    //   block [0x823AC988..0x823AC9CC)
	// 823AC988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AC98C: 4818871D  bl 0x825350a8
	ctx.lr = 0x823AC990;
	sub_82535080(ctx, base);
	// 823AC990: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AC994: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823AC998: 3D404E55  lis r10, 0x4e55
	ctx.r[10].s64 = 1314193408;
	// 823AC99C: 3D204749  lis r9, 0x4749
	ctx.r[9].s64 = 1195966464;
	// 823AC9A0: 614A5033  ori r10, r10, 0x5033
	ctx.r[10].u64 = ctx.r[10].u64 | 20531;
	// 823AC9A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823AC9A8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AC9AC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823AC9B0: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 823AC9B4: 61384458  ori r24, r9, 0x4458
	ctx.r[24].u64 = ctx.r[9].u64 | 17496;
	// 823AC9B8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823AC9BC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823AC9C0: 409A000C  bne cr6, 0x823ac9cc
	if !ctx.cr[6].eq {
	pc = 0x823AC9CC; continue 'dispatch;
	}
	// 823AC9C4: A39E0008  lhz r28, 8(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AC9C8: 4800004C  b 0x823aca14
	pc = 0x823ACA14; continue 'dispatch;
            }
            0x823AC9CC => {
    //   block [0x823AC9CC..0x823AC9E4)
	// 823AC9CC: 3D404E44  lis r10, 0x4e44
	ctx.r[10].s64 = 1313079296;
	// 823AC9D0: 614A5852  ori r10, r10, 0x5852
	ctx.r[10].u64 = ctx.r[10].u64 | 22610;
	// 823AC9D4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823AC9D8: 409A0018  bne cr6, 0x823ac9f0
	if !ctx.cr[6].eq {
	pc = 0x823AC9F0; continue 'dispatch;
	}
	// 823AC9DC: 897E0008  lbz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AC9E0: 895E0009  lbz r10, 9(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(9 as u32) ) } as u64;
	pc = 0x823AC9E4; continue 'dispatch;
            }
            0x823AC9E4 => {
    //   block [0x823AC9E4..0x823AC9F0)
	// 823AC9E4: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 823AC9E8: 7F8B5214  add r28, r11, r10
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823AC9EC: 48000028  b 0x823aca14
	pc = 0x823ACA14; continue 'dispatch;
            }
            0x823AC9F0 => {
    //   block [0x823AC9F0..0x823ACA10)
	// 823AC9F0: 7F0BC040  cmplw cr6, r11, r24
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[24].u32, &mut ctx.xer);
	// 823AC9F4: 409A001C  bne cr6, 0x823aca10
	if !ctx.cr[6].eq {
	pc = 0x823ACA10; continue 'dispatch;
	}
	// 823AC9F8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AC9FC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823ACA00: 409A0010  bne cr6, 0x823aca10
	if !ctx.cr[6].eq {
	pc = 0x823ACA10; continue 'dispatch;
	}
	// 823ACA04: 897E0018  lbz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 823ACA08: 895E0019  lbz r10, 0x19(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25 as u32) ) } as u64;
	// 823ACA0C: 4BFFFFD8  b 0x823ac9e4
	pc = 0x823AC9E4; continue 'dispatch;
            }
            0x823ACA10 => {
    //   block [0x823ACA10..0x823ACA14)
	// 823ACA10: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	pc = 0x823ACA14; continue 'dispatch;
            }
            0x823ACA14 => {
    //   block [0x823ACA14..0x823ACA74)
	// 823ACA14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823ACA18: 48360845  bl 0x8270d25c
	ctx.lr = 0x823ACA1C;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823ACA1C: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 823ACA20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823ACA24: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823ACA28: 917D0024  stw r11, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 823ACA2C: 83FD002C  lwz r31, 0x2c(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 823ACA30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACA34: 917D002C  stw r11, 0x2c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 823ACA38: 48360835  bl 0x8270d26c
	ctx.lr = 0x823ACA3C;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823ACA3C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823ACA40: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823ACA44: 419A0104  beq cr6, 0x823acb48
	if ctx.cr[6].eq {
	pc = 0x823ACB48; continue 'dispatch;
	}
	// 823ACA48: 2B1C0002  cmplwi cr6, r28, 2
	ctx.cr[6].compare_u32(ctx.r[28].u32, 2 as u32, &mut ctx.xer);
	// 823ACA4C: 40990084  ble cr6, 0x823acad0
	if !ctx.cr[6].gt {
	pc = 0x823ACAD0; continue 'dispatch;
	}
	// 823ACA50: 2B1C0200  cmplwi cr6, r28, 0x200
	ctx.cr[6].compare_u32(ctx.r[28].u32, 512 as u32, &mut ctx.xer);
	// 823ACA54: 409A00F4  bne cr6, 0x823acb48
	if !ctx.cr[6].eq {
	pc = 0x823ACB48; continue 'dispatch;
	}
	// 823ACA58: 572B07FF  clrlwi. r11, r25, 0x1f
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823ACA5C: 4082001C  bne 0x823aca78
	if !ctx.cr[0].eq {
	pc = 0x823ACA78; continue 'dispatch;
	}
	// 823ACA60: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACA64: 7F0BC040  cmplw cr6, r11, r24
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[24].u32, &mut ctx.xer);
	// 823ACA68: 409A000C  bne cr6, 0x823aca74
	if !ctx.cr[6].eq {
	pc = 0x823ACA74; continue 'dispatch;
	}
	// 823ACA6C: 837E0008  lwz r27, 8(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ACA70: 63390001  ori r25, r25, 1
	ctx.r[25].u64 = ctx.r[25].u64 | 1;
	pc = 0x823ACA74; continue 'dispatch;
            }
            0x823ACA74 => {
    //   block [0x823ACA74..0x823ACA78)
	// 823ACA74: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	pc = 0x823ACA78; continue 'dispatch;
            }
            0x823ACA78 => {
    //   block [0x823ACA78..0x823ACA90)
	// 823ACA78: 572B077B  rlwinm. r11, r25, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823ACA7C: 4182003C  beq 0x823acab8
	if ctx.cr[0].eq {
	pc = 0x823ACAB8; continue 'dispatch;
	}
	// 823ACA80: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823ACA84: 391F0004  addi r8, r31, 4
	ctx.r[8].s64 = ctx.r[31].s64 + 4;
	// 823ACA88: 396B19C0  addi r11, r11, 0x19c0
	ctx.r[11].s64 = ctx.r[11].s64 + 6592;
	// 823ACA8C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823ACA90; continue 'dispatch;
            }
            0x823ACA90 => {
    //   block [0x823ACA90..0x823ACAB8)
	// 823ACA90: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 823ACA94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823ACA98: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 823ACA9C: 7F40412D  stwcx. r26, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[26].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823ACAA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823ACAA4: 4082FFEC  bne 0x823aca90
	if !ctx.cr[0].eq {
	pc = 0x823ACA90; continue 'dispatch;
	}
	// 823ACAA8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823ACAAC: 935F000C  stw r26, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 823ACAB0: 396B1AA0  addi r11, r11, 0x1aa0
	ctx.r[11].s64 = ctx.r[11].s64 + 6816;
	// 823ACAB4: 4800004C  b 0x823acb00
	pc = 0x823ACB00; continue 'dispatch;
            }
            0x823ACAB8 => {
    //   block [0x823ACAB8..0x823ACAD0)
	// 823ACAB8: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 823ACABC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 823ACAC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823ACAC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823ACAC8: 48007301  bl 0x823b3dc8
	ctx.lr = 0x823ACACC;
	sub_823B3DC8(ctx, base);
	// 823ACACC: 4800007C  b 0x823acb48
	pc = 0x823ACB48; continue 'dispatch;
            }
            0x823ACAD0 => {
    //   block [0x823ACAD0..0x823ACAE0)
	// 823ACAD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823ACAD4: 391F0004  addi r8, r31, 4
	ctx.r[8].s64 = ctx.r[31].s64 + 4;
	// 823ACAD8: 396B19C0  addi r11, r11, 0x19c0
	ctx.r[11].s64 = ctx.r[11].s64 + 6592;
	// 823ACADC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823ACAE0; continue 'dispatch;
            }
            0x823ACAE0 => {
    //   block [0x823ACAE0..0x823ACB00)
	// 823ACAE0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 823ACAE4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823ACAE8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 823ACAEC: 7F40412D  stwcx. r26, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[26].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823ACAF0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823ACAF4: 4082FFEC  bne 0x823acae0
	if !ctx.cr[0].eq {
	pc = 0x823ACAE0; continue 'dispatch;
	}
	// 823ACAF8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823ACAFC: 396B1B10  addi r11, r11, 0x1b10
	ctx.r[11].s64 = ctx.r[11].s64 + 6928;
	pc = 0x823ACB00; continue 'dispatch;
            }
            0x823ACB00 => {
    //   block [0x823ACB00..0x823ACB48)
	// 823ACB00: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823ACB04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823ACB08: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 823ACB0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823ACB10: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823ACB14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823ACB18: 4E800421  bctrl
	ctx.lr = 0x823ACB1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823ACB1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACB20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823ACB24: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823ACB28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823ACB2C: 4E800421  bctrl
	ctx.lr = 0x823ACB30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823ACB30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACB34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823ACB38: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 823ACB3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823ACB40: 4E800421  bctrl
	ctx.lr = 0x823ACB44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823ACB44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            0x823ACB48 => {
    //   block [0x823ACB48..0x823ACB50)
	// 823ACB48: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823ACB4C: 481885AC  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ACB50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823ACB50 size=108
    let mut pc: u32 = 0x823ACB50;
    'dispatch: loop {
        match pc {
            0x823ACB50 => {
    //   block [0x823ACB50..0x823ACB74)
	// 823ACB50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACB54: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823ACB58: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 823ACB5C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ACB60: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823ACB64: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823ACB68: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 823ACB6C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823ACB70: 41820024  beq 0x823acb94
	if ctx.cr[0].eq {
	pc = 0x823ACB94; continue 'dispatch;
	}
	pc = 0x823ACB74; continue 'dispatch;
            }
            0x823ACB74 => {
    //   block [0x823ACB74..0x823ACB94)
	// 823ACB74: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 823ACB78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823ACB7C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823ACB80: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823ACB84: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ACB88: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823ACB8C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823ACB90: 4198FFE4  blt cr6, 0x823acb74
	if ctx.cr[6].lt {
	pc = 0x823ACB74; continue 'dispatch;
	}
	pc = 0x823ACB94; continue 'dispatch;
            }
            0x823ACB94 => {
    //   block [0x823ACB94..0x823ACBA8)
	// 823ACB94: 39430080  addi r10, r3, 0x80
	ctx.r[10].s64 = ctx.r[3].s64 + 128;
	// 823ACB98: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 823ACB9C: 39030010  addi r8, r3, 0x10
	ctx.r[8].s64 = ctx.r[3].s64 + 16;
	// 823ACBA0: 39200065  li r9, 0x65
	ctx.r[9].s64 = 101;
	// 823ACBA4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x823ACBA8; continue 'dispatch;
            }
            0x823ACBA8 => {
    //   block [0x823ACBA8..0x823ACBBC)
	// 823ACBA8: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823ACBAC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823ACBB0: 4200FFF8  bdnz 0x823acba8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823ACBA8; continue 'dispatch;
	}
	// 823ACBB4: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 823ACBB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ACBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823ACBC0 size=28
    let mut pc: u32 = 0x823ACBC0;
    'dispatch: loop {
        match pc {
            0x823ACBC0 => {
    //   block [0x823ACBC0..0x823ACBDC)
	// 823ACBC0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 823ACBC4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823ACBC8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ACBCC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823ACBD0: 4099000C  ble cr6, 0x823acbdc
	if !ctx.cr[6].gt {
		sub_823ACBDC(ctx, base);
		return;
	}
	// 823ACBD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823ACBD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ACBDC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823ACBDC size=148
    let mut pc: u32 = 0x823ACBDC;
    'dispatch: loop {
        match pc {
            0x823ACBDC => {
    //   block [0x823ACBDC..0x823ACC00)
	// 823ACBDC: 39600065  li r11, 0x65
	ctx.r[11].s64 = 101;
	// 823ACBE0: 908A0018  stw r4, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[4].u32 ) };
	// 823ACBE4: 7D645B96  divwu r11, r4, r11
	ctx.r[11].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 823ACBE8: 1D6B0065  mulli r11, r11, 0x65
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 101 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823ACBEC: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 823ACBF0: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 823ACBF4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823ACBF8: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823ACBFC: 48000018  b 0x823acc14
	pc = 0x823ACC14; continue 'dispatch;
            }
            0x823ACC00 => {
    //   block [0x823ACC00..0x823ACC14)
	// 823ACC00: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACC04: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ACC08: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823ACC0C: 41990008  bgt cr6, 0x823acc14
	if ctx.cr[6].gt {
	pc = 0x823ACC14; continue 'dispatch;
	}
	// 823ACC10: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	pc = 0x823ACC14; continue 'dispatch;
            }
            0x823ACC14 => {
    //   block [0x823ACC14..0x823ACC70)
	// 823ACC14: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACC18: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ACC1C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823ACC20: 409AFFE0  bne cr6, 0x823acc00
	if !ctx.cr[6].eq {
	pc = 0x823ACC00; continue 'dispatch;
	}
	// 823ACC24: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACC28: 390A0010  addi r8, r10, 0x10
	ctx.r[8].s64 = ctx.r[10].s64 + 16;
	// 823ACC2C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823ACC30: 409AFFA4  bne cr6, 0x823acbd4
	if !ctx.cr[6].eq {
		sub_823ACBC0(ctx, base);
		return;
	}
	// 823ACC34: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ACC38: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACC3C: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823ACC40: 4182FF94  beq 0x823acbd4
	if ctx.cr[0].eq {
		sub_823ACBC0(ctx, base);
		return;
	}
	// 823ACC44: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 823ACC48: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823ACC4C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 823ACC50: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 823ACC54: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823ACC58: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823ACC5C: 90AB000C  stw r5, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 823ACC60: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823ACC64: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823ACC68: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823ACC6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ACC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823ACC70 size=100
    let mut pc: u32 = 0x823ACC70;
    'dispatch: loop {
        match pc {
            0x823ACC70 => {
    //   block [0x823ACC70..0x823ACC98)
	// 823ACC70: 39600065  li r11, 0x65
	ctx.r[11].s64 = 101;
	// 823ACC74: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 823ACC78: 7D645B96  divwu r11, r4, r11
	ctx.r[11].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 823ACC7C: 1D6B0065  mulli r11, r11, 0x65
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 101 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823ACC80: 90860018  stw r4, 0x18(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(24 as u32), ctx.r[4].u32 ) };
	// 823ACC84: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 823ACC88: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 823ACC8C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823ACC90: 7D0B3214  add r8, r11, r6
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 823ACC94: 48000018  b 0x823accac
	pc = 0x823ACCAC; continue 'dispatch;
            }
            0x823ACC98 => {
    //   block [0x823ACC98..0x823ACCAC)
	// 823ACC98: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACC9C: 81680008  lwz r11, 8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ACCA0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823ACCA4: 41990008  bgt cr6, 0x823accac
	if ctx.cr[6].gt {
	pc = 0x823ACCAC; continue 'dispatch;
	}
	// 823ACCA8: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	pc = 0x823ACCAC; continue 'dispatch;
            }
            0x823ACCAC => {
    //   block [0x823ACCAC..0x823ACCD4)
	// 823ACCAC: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACCB0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823ACCB4: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823ACCB8: 409AFFE0  bne cr6, 0x823acc98
	if !ctx.cr[6].eq {
	pc = 0x823ACC98; continue 'dispatch;
	}
	// 823ACCBC: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACCC0: 39660010  addi r11, r6, 0x10
	ctx.r[11].s64 = ctx.r[6].s64 + 16;
	// 823ACCC4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823ACCC8: 409A000C  bne cr6, 0x823accd4
	if !ctx.cr[6].eq {
		sub_823ACCD4(ctx, base);
		return;
	}
	// 823ACCCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823ACCD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ACCD4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823ACCD4 size=136
    let mut pc: u32 = 0x823ACCD4;
    'dispatch: loop {
        match pc {
            0x823ACCD4 => {
    //   block [0x823ACCD4..0x823ACCE8)
	// 823ACCD4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACCD8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823ACCDC: 409A000C  bne cr6, 0x823acce8
	if !ctx.cr[6].eq {
	pc = 0x823ACCE8; continue 'dispatch;
	}
	// 823ACCE0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ACCE4: 48000054  b 0x823acd38
	pc = 0x823ACD38; continue 'dispatch;
            }
            0x823ACCE8 => {
    //   block [0x823ACCE8..0x823ACD00)
	// 823ACCE8: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ACCEC: 38EA0004  addi r7, r10, 4
	ctx.r[7].s64 = ctx.r[10].s64 + 4;
	// 823ACCF0: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823ACCF4: 409A000C  bne cr6, 0x823acd00
	if !ctx.cr[6].eq {
	pc = 0x823ACD00; continue 'dispatch;
	}
	// 823ACCF8: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823ACCFC: 48000040  b 0x823acd3c
	pc = 0x823ACD3C; continue 'dispatch;
            }
            0x823ACD00 => {
    //   block [0x823ACD00..0x823ACD08)
	// 823ACD00: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 823ACD04: 48000008  b 0x823acd0c
	pc = 0x823ACD0C; continue 'dispatch;
            }
            0x823ACD08 => {
    //   block [0x823ACD08..0x823ACD0C)
	// 823ACD08: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x823ACD0C; continue 'dispatch;
            }
            0x823ACD0C => {
    //   block [0x823ACD0C..0x823ACD38)
	// 823ACD0C: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACD10: 80A50000  lwz r5, 0(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACD14: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823ACD18: 409AFFF0  bne cr6, 0x823acd08
	if !ctx.cr[6].eq {
	pc = 0x823ACD08; continue 'dispatch;
	}
	// 823ACD1C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACD20: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ACD24: 90A90000  stw r5, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 823ACD28: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACD2C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823ACD30: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACD34: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x823ACD38; continue 'dispatch;
            }
            0x823ACD38 => {
    //   block [0x823ACD38..0x823ACD3C)
	// 823ACD38: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823ACD3C; continue 'dispatch;
            }
            0x823ACD3C => {
    //   block [0x823ACD3C..0x823ACD5C)
	// 823ACD3C: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ACD40: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823ACD44: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823ACD48: 8166000C  lwz r11, 0xc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 823ACD4C: 91460004  stw r10, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823ACD50: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823ACD54: 9166000C  stw r11, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823ACD58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ACD60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823ACD60 size=16
    let mut pc: u32 = 0x823ACD60;
    'dispatch: loop {
        match pc {
            0x823ACD60 => {
    //   block [0x823ACD60..0x823ACD70)
	// 823ACD60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823ACD64: 396B0578  addi r11, r11, 0x578
	ctx.r[11].s64 = ctx.r[11].s64 + 1400;
	// 823ACD68: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823ACD6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ACD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823ACD70 size=208
    let mut pc: u32 = 0x823ACD70;
    'dispatch: loop {
        match pc {
            0x823ACD70 => {
    //   block [0x823ACD70..0x823ACE40)
	// 823ACD70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823ACD74: 48188341  bl 0x825350b4
	ctx.lr = 0x823ACD78;
	sub_82535080(ctx, base);
	// 823ACD78: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823ACD7C: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823ACD80: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823ACD84: 5489073E  clrlwi r9, r4, 0x1c
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x0000000Fu64;
	// 823ACD88: 80630010  lwz r3, 0x10(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823ACD8C: 396B0814  addi r11, r11, 0x814
	ctx.r[11].s64 = ctx.r[11].s64 + 2068;
	// 823ACD90: 5488E73E  rlwinm r8, r4, 0x1c, 0x1c, 0x1f
	ctx.r[8].u64 = ctx.r[4].u32 as u64 & 0x0000000Fu64;
	// 823ACD94: 5487C73E  rlwinm r7, r4, 0x18, 0x1c, 0x1f
	ctx.r[7].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 823ACD98: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823ACD9C: 5486673E  rlwinm r6, r4, 0xc, 0x1c, 0x1f
	ctx.r[6].u64 = ctx.r[4].u32 as u64 & 0x000FFFFFu64;
	// 823ACDA0: 7FC958AE  lbzx r30, r9, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823ACDA4: 394A0790  addi r10, r10, 0x790
	ctx.r[10].s64 = ctx.r[10].s64 + 1936;
	// 823ACDA8: 7FA858AE  lbzx r29, r8, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823ACDAC: 5485873E  rlwinm r5, r4, 0x10, 0x1c, 0x1f
	ctx.r[5].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	// 823ACDB0: 7F8758AE  lbzx r28, r7, r11
	ctx.r[28].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823ACDB4: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823ACDB8: 549BA73E  rlwinm r27, r4, 0x14, 0x1c, 0x1f
	ctx.r[27].u64 = ctx.r[4].u32 as u64 & 0x00000FFFu64;
	// 823ACDBC: 3BEB0700  addi r31, r11, 0x700
	ctx.r[31].s64 = ctx.r[11].s64 + 1792;
	// 823ACDC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823ACDC4: 7D0650AE  lbzx r8, r6, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823ACDC8: 548946F6  rlwinm r9, r4, 8, 0x1b, 0x1b
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x00FFFFFFu64;
	// 823ACDCC: 7CE550AE  lbzx r7, r5, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823ACDD0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823ACDD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823ACDD8: 7CDB50AE  lbzx r6, r27, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823ACDDC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 823ACDE0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823ACDE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823ACDE8: 4E800421  bctrl
	ctx.lr = 0x823ACDEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823ACDEC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823ACDF0: 814B0480  lwz r10, 0x480(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1152 as u32) ) } as u64;
	// 823ACDF4: 53CA54EA  rlwimi r10, r30, 0xa, 0x13, 0x15
	ctx.r[10].u64 = (((ctx.r[30].u32).rotate_left(10) as u64) & 0x0000000000001C00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFE3FF);
	// 823ACDF8: 914B0480  stw r10, 0x480(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1152 as u32), ctx.r[10].u32 ) };
	// 823ACDFC: E94B0018  ld r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 823ACE00: 654A8000  oris r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 2147483648;
	// 823ACE04: F94B0018  std r10, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u64 ) };
	// 823ACE08: 814B0480  lwz r10, 0x480(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1152 as u32) ) } as u64;
	// 823ACE0C: 53AA6C24  rlwimi r10, r29, 0xd, 0x10, 0x12
	ctx.r[10].u64 = (((ctx.r[29].u32).rotate_left(13) as u64) & 0x000000000000E000) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF1FFF);
	// 823ACE10: 914B0480  stw r10, 0x480(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1152 as u32), ctx.r[10].u32 ) };
	// 823ACE14: E94B0018  ld r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 823ACE18: 654A8000  oris r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 2147483648;
	// 823ACE1C: F94B0018  std r10, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u64 ) };
	// 823ACE20: 814B0480  lwz r10, 0x480(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1152 as u32) ) } as u64;
	// 823ACE24: 538A835E  rlwimi r10, r28, 0x10, 0xd, 0xf
	ctx.r[10].u64 = (((ctx.r[28].u32).rotate_left(16) as u64) & 0x0000000000070000) | (ctx.r[10].u64 & 0xFFFFFFFFFFF8FFFF);
	// 823ACE28: 914B0480  stw r10, 0x480(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1152 as u32), ctx.r[10].u32 ) };
	// 823ACE2C: E94B0018  ld r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 823ACE30: 654A8000  oris r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 2147483648;
	// 823ACE34: F94B0018  std r10, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u64 ) };
	// 823ACE38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823ACE3C: 481882C8  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ACE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823ACE40 size=372
    let mut pc: u32 = 0x823ACE40;
    'dispatch: loop {
        match pc {
            0x823ACE40 => {
    //   block [0x823ACE40..0x823ACFB4)
	// 823ACE40: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 823ACE44: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 823ACE48: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823ACE4C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 823ACE50: 54FFF0BF  rlwinm. r31, r7, 0x1e, 2, 0x1f
	ctx.r[31].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823ACE54: 54FE07BE  clrlwi r30, r7, 0x1e
	ctx.r[30].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 823ACE58: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 823ACE5C: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823ACE60: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 823ACE64: D001FFD0  stfs f0, -0x30(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 823ACE68: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 823ACE6C: D001FFD4  stfs f0, -0x2c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-44 as u32), tmp.u32 ) };
	// 823ACE70: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 823ACE74: D001FFD8  stfs f0, -0x28(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), tmp.u32 ) };
	// 823ACE78: D001FFDC  stfs f0, -0x24(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-36 as u32), tmp.u32 ) };
	// 823ACE7C: 3881FFD0  addi r4, r1, -0x30
	ctx.r[4].s64 = ctx.r[1].s64 + -48;
	// 823ACE80: D001FFE0  stfs f0, -0x20(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 823ACE84: D001FFE4  stfs f0, -0x1c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 823ACE88: D001FFE8  stfs f0, -0x18(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), tmp.u32 ) };
	// 823ACE8C: D001FFEC  stfs f0, -0x14(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-20 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ACFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823ACFB8 size=336
    let mut pc: u32 = 0x823ACFB8;
    'dispatch: loop {
        match pc {
            0x823ACFB8 => {
    //   block [0x823ACFB8..0x823AD0AC)
	// 823ACFB8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 823ACFBC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823ACFC0: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 823ACFC4: 54E4F0BF  rlwinm. r4, r7, 0x1e, 2, 0x1f
	ctx.r[4].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823ACFC8: 54E307BE  clrlwi r3, r7, 0x1e
	ctx.r[3].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 823ACFCC: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 823ACFD0: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823ACFD4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 823ACFD8: D001FFD0  stfs f0, -0x30(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 823ACFDC: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 823ACFE0: D001FFD4  stfs f0, -0x2c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-44 as u32), tmp.u32 ) };
	// 823ACFE4: D001FFD8  stfs f0, -0x28(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), tmp.u32 ) };
	// 823ACFE8: D001FFDC  stfs f0, -0x24(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-36 as u32), tmp.u32 ) };
	// 823ACFEC: D001FFE0  stfs f0, -0x20(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 823ACFF0: D001FFE4  stfs f0, -0x1c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 823ACFF4: D001FFE8  stfs f0, -0x18(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), tmp.u32 ) };
	// 823ACFF8: D001FFEC  stfs f0, -0x14(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-20 as u32), tmp.u32 ) };
	// 823ACFFC: 418200B0  beq 0x823ad0ac
	if ctx.cr[0].eq {
	pc = 0x823AD0AC; continue 'dispatch;
	}
	// 823AD000: 3BE1FFD0  addi r31, r1, -0x30
	ctx.r[31].s64 = ctx.r[1].s64 + -48;
	pc = 0x823AD0AC; continue 'dispatch;
            }
            0x823AD0AC => {
    //   block [0x823AD0AC..0x823AD108)
	// 823AD0AC: 3881FFD0  addi r4, r1, -0x30
	ctx.r[4].s64 = ctx.r[1].s64 + -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AD108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823AD108 size=292
    let mut pc: u32 = 0x823AD108;
    'dispatch: loop {
        match pc {
            0x823AD108 => {
    //   block [0x823AD108..0x823AD1DC)
	// 823AD108: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AD10C: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 823AD110: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 823AD114: 54E6F0BF  rlwinm. r6, r7, 0x1e, 2, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 823AD118: 54E407BE  clrlwi r4, r7, 0x1e
	ctx.r[4].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 823AD11C: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AD120: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 823AD124: D001FFE0  stfs f0, -0x20(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 823AD128: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 823AD12C: D001FFE4  stfs f0, -0x1c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 823AD130: D001FFE8  stfs f0, -0x18(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), tmp.u32 ) };
	// 823AD134: D001FFEC  stfs f0, -0x14(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-20 as u32), tmp.u32 ) };
	// 823AD138: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 823AD13C: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 823AD140: D001FFF8  stfs f0, -8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 823AD144: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 823AD148: 41820094  beq 0x823ad1dc
	if ctx.cr[0].eq {
	pc = 0x823AD1DC; continue 'dispatch;
	}
	// 823AD14C: 3861FFE0  addi r3, r1, -0x20
	ctx.r[3].s64 = ctx.r[1].s64 + -32;
	pc = 0x823AD1DC; continue 'dispatch;
            }
            0x823AD1DC => {
    //   block [0x823AD1DC..0x823AD22C)
	// 823AD1DC: 38C1FFE0  addi r6, r1, -0x20
	ctx.r[6].s64 = ctx.r[1].s64 + -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AD230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823AD230 size=344
    let mut pc: u32 = 0x823AD230;
    'dispatch: loop {
        match pc {
            0x823AD230 => {
    //   block [0x823AD230..0x823AD2F4)
	// 823AD230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AD234: 48187E7D  bl 0x825350b0
	ctx.lr = 0x823AD238;
	sub_82535080(ctx, base);
	// 823AD238: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AD23C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823AD240: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	// 823AD244: 3B800030  li r28, 0x30
	ctx.r[28].s64 = 48;
	// 823AD248: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 823AD24C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823AD250: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AD254: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823AD258: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 823AD25C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823AD260: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823AD264: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 823AD268: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 823AD26C: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 823AD270: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 823AD274: 93A100DC  stw r29, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[29].u32 ) };
	// 823AD278: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 823AD27C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 823AD280: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AD284: 386B9000  addi r3, r11, -0x7000
	ctx.r[3].s64 = ctx.r[11].s64 + -28672;
	// 823AD288: 7D69502E  lwzx r11, r9, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823AD28C: 7C8BE9D6  mullw r4, r11, r29
	ctx.r[4].s32 = ((ctx.r[11].s32 as i64 * ctx.r[29].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 823AD290: 4BFF6991  bl 0x823a3c20
	ctx.lr = 0x823AD294;
	sub_823A3C20(ctx, base);
	// 823AD294: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 823AD298: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 823AD29C: 915E0030  stw r10, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 823AD2A0: 913E002C  stw r9, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 823AD2A4: 396100DC  addi r11, r1, 0xdc
	ctx.r[11].s64 = ctx.r[1].s64 + 220;
	// 823AD2A8: 390100DC  addi r8, r1, 0xdc
	ctx.r[8].s64 = ctx.r[1].s64 + 220;
	// 823AD2AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 823AD2B0: 7C00588E  lvewx v0, 0, r11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[0] using VectorMaskL[(tmp.u32 & 0xF)]
	// 823AD2B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AD2B8: 7CE0400C  lvsl v7, 0, r8
	tmp.u32 = ctx.r[8].u32;
	// ctx.v[7] = VectorShiftTableL[(tmp.u32 & 0xF)]
	// 823AD2BC: 100001EB  vperm v0, v0, v0, v7
	for i in 0..16 {
		let sel = (ctx.v[7].u8[i] & 0x1F) as usize;
		ctx.v[0].u8[i] = if sel < 16 { ctx.v[0].u8[sel] } else { ctx.v[0].u8[sel - 16] };
	}
	// 823AD2C0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823AD2C4: 1000028C  vspltw v0, v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = ctx.v[0].u32[3];
	}
	// 823AD2C8: 1000030A  vcfux v0, v0, 0
	// vcfux/vcuxwfp128: ctx.v[0].f32[i] = ( ctx.v[0].u32[i] as f32 ) * (2.0f32).powi(0);
	for i in 0..4 { ctx.v[0].f32[i] = (ctx.v[0].u32[i] as f32) * (2.0f32).powi(0); }
	// 823AD2CC: 1020010A  vrefp v1, v0
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[1].f32[i] = 1.0f32 / ctx.v[0].f32[i];
	}
	// 823AD2D0: 4198008C  blt cr6, 0x823ad35c
	if ctx.cr[6].lt {
	pc = 0x823AD35C; continue 'dispatch;
	}
	// 823AD2D4: 419A0060  beq cr6, 0x823ad334
	if ctx.cr[6].eq {
	pc = 0x823AD334; continue 'dispatch;
	}
	// 823AD2D8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 823AD2DC: 41980030  blt cr6, 0x823ad30c
	if ctx.cr[6].lt {
	pc = 0x823AD30C; continue 'dispatch;
	}
	// 823AD2E0: 409A00A0  bne cr6, 0x823ad380
	if !ctx.cr[6].eq {
	pc = 0x823AD380; continue 'dispatch;
	}
	// 823AD2E4: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823AD2E8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AD2EC: 40820008  bne 0x823ad2f4
	if !ctx.cr[0].eq {
	pc = 0x823AD2F4; continue 'dispatch;
	}
	// 823AD2F0: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	pc = 0x823AD2F4; continue 'dispatch;
            }
            0x823AD2F4 => {
    //   block [0x823AD2F4..0x823AD30C)
	// 823AD2F4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 823AD2F8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 823AD2FC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 823AD300: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD304: 4BFFFE05  bl 0x823ad108
	ctx.lr = 0x823AD308;
	sub_823AD108(ctx, base);
	// 823AD308: 48000078  b 0x823ad380
	pc = 0x823AD380; continue 'dispatch;
            }
            0x823AD30C => {
    //   block [0x823AD30C..0x823AD31C)
	// 823AD30C: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823AD310: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AD314: 40820008  bne 0x823ad31c
	if !ctx.cr[0].eq {
	pc = 0x823AD31C; continue 'dispatch;
	}
	// 823AD318: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	pc = 0x823AD31C; continue 'dispatch;
            }
            0x823AD31C => {
    //   block [0x823AD31C..0x823AD334)
	// 823AD31C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 823AD320: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 823AD324: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 823AD328: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD32C: 4BFFFC8D  bl 0x823acfb8
	ctx.lr = 0x823AD330;
	sub_823ACFB8(ctx, base);
	// 823AD330: 48000050  b 0x823ad380
	pc = 0x823AD380; continue 'dispatch;
            }
            0x823AD334 => {
    //   block [0x823AD334..0x823AD344)
	// 823AD334: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823AD338: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AD33C: 40820008  bne 0x823ad344
	if !ctx.cr[0].eq {
	pc = 0x823AD344; continue 'dispatch;
	}
	// 823AD340: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	pc = 0x823AD344; continue 'dispatch;
            }
            0x823AD344 => {
    //   block [0x823AD344..0x823AD35C)
	// 823AD344: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 823AD348: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 823AD34C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 823AD350: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD354: 4BFFFC65  bl 0x823acfb8
	ctx.lr = 0x823AD358;
	sub_823ACFB8(ctx, base);
	// 823AD358: 48000028  b 0x823ad380
	pc = 0x823AD380; continue 'dispatch;
            }
            0x823AD35C => {
    //   block [0x823AD35C..0x823AD36C)
	// 823AD35C: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823AD360: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AD364: 40820008  bne 0x823ad36c
	if !ctx.cr[0].eq {
	pc = 0x823AD36C; continue 'dispatch;
	}
	// 823AD368: 39000040  li r8, 0x40
	ctx.r[8].s64 = 64;
	pc = 0x823AD36C; continue 'dispatch;
            }
            0x823AD36C => {
    //   block [0x823AD36C..0x823AD380)
	// 823AD36C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 823AD370: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 823AD374: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 823AD378: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD37C: 4BFFFAC5  bl 0x823ace40
	ctx.lr = 0x823AD380;
	sub_823ACE40(ctx, base);
	pc = 0x823AD380; continue 'dispatch;
            }
            0x823AD380 => {
    //   block [0x823AD380..0x823AD388)
	// 823AD380: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823AD384: 48187D7C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AD388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823AD388 size=300
    let mut pc: u32 = 0x823AD388;
    'dispatch: loop {
        match pc {
            0x823AD388 => {
    //   block [0x823AD388..0x823AD470)
	// 823AD388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AD38C: 48187D31  bl 0x825350bc
	ctx.lr = 0x823AD390;
	sub_82535080(ctx, base);
	// 823AD390: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AD394: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 823AD398: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823AD39C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AD3A0: 394A083C  addi r10, r10, 0x83c
	ctx.r[10].s64 = ctx.r[10].s64 + 2108;
	// 823AD3A4: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 823AD3A8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 823AD3AC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823AD3B0: 90DF0010  stw r6, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 823AD3B4: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 823AD3B8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AD3BC: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 823AD3C0: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 823AD3C4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823AD3C8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823AD3CC: 39600016  li r11, 0x16
	ctx.r[11].s64 = 22;
	// 823AD3D0: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 823AD3D4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 823AD3D8: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 823AD3DC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 823AD3E0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 823AD3E4: 39400015  li r10, 0x15
	ctx.r[10].s64 = 21;
	// 823AD3E8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 823AD3EC: 39600017  li r11, 0x17
	ctx.r[11].s64 = 23;
	// 823AD3F0: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 823AD3F4: 38A0000D  li r5, 0xd
	ctx.r[5].s64 = 13;
	// 823AD3F8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 823AD3FC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AD400: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 823AD404: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AD408: 396B0858  addi r11, r11, 0x858
	ctx.r[11].s64 = ctx.r[11].s64 + 2136;
	// 823AD40C: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 823AD410: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 823AD414: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AD418: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 823AD41C: C01E001C  lfs f0, 0x1c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AD420: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 823AD424: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AD428: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AD42C: 7D4A382E  lwzx r10, r10, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 823AD430: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 823AD434: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AD438: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AD43C: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823AD440: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 823AD444: 7D6B302E  lwzx r11, r11, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 823AD448: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 823AD44C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AD450: 556B04A5  rlwinm. r11, r11, 0, 0x12, 0x12
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AD454: 4182001C  beq 0x823ad470
	if ctx.cr[0].eq {
	pc = 0x823AD470; continue 'dispatch;
	}
	// 823AD458: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 823AD45C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AD460: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 823AD464: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AD468: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 823AD46C: 4800001C  b 0x823ad488
	pc = 0x823AD488; continue 'dispatch;
            }
            0x823AD470 => {
    //   block [0x823AD470..0x823AD488)
	// 823AD470: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 823AD474: 7D264B78  mr r6, r9
	ctx.r[6].u64 = ctx.r[9].u64;
	// 823AD478: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 823AD47C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823AD480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AD484: 4BFFFDAD  bl 0x823ad230
	ctx.lr = 0x823AD488;
	sub_823AD230(ctx, base);
	pc = 0x823AD488; continue 'dispatch;
            }
            0x823AD488 => {
    //   block [0x823AD488..0x823AD4A8)
	// 823AD488: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AD48C: 556B03DF  rlwinm. r11, r11, 0, 0xf, 0xf
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AD490: 41820018  beq 0x823ad4a8
	if ctx.cr[0].eq {
	pc = 0x823AD4A8; continue 'dispatch;
	}
	// 823AD494: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 823AD498: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 823AD49C: F95D0000  std r10, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 823AD4A0: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 823AD4A4: F97D0008  std r11, 8(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	pc = 0x823AD4A8; continue 'dispatch;
            }
            0x823AD4A8 => {
    //   block [0x823AD4A8..0x823AD4B4)
	// 823AD4A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AD4AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823AD4B0: 48187C5C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AD4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823AD4B8 size=388
    let mut pc: u32 = 0x823AD4B8;
    'dispatch: loop {
        match pc {
            0x823AD4B8 => {
    //   block [0x823AD4B8..0x823AD528)
	// 823AD4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AD4BC: 48187BFD  bl 0x825350b8
	ctx.lr = 0x823AD4C0;
	sub_82535080(ctx, base);
	// 823AD4C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AD4C4: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AD4C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AD4CC: 3B8B0700  addi r28, r11, 0x700
	ctx.r[28].s64 = ctx.r[11].s64 + 1792;
	// 823AD4D0: 80DF0030  lwz r6, 0x30(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 823AD4D4: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AD4D8: 80BF002C  lwz r5, 0x2c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823AD4DC: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AD4E0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AD4E4: 48005CD5  bl 0x823b31b8
	ctx.lr = 0x823AD4E8;
	sub_823B31B8(ctx, base);
	// 823AD4E8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AD4EC: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AD4F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AD4F4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 823AD4F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AD4FC: 4E800421  bctrl
	ctx.lr = 0x823AD500;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AD500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AD504: 83BF0014  lwz r29, 0x14(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AD508: C03F0024  lfs f1, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823AD50C: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AD510: 4BFFF861  bl 0x823acd70
	ctx.lr = 0x823AD514;
	sub_823ACD70(ctx, base);
	// 823AD514: 57AB05EF  rlwinm. r11, r29, 0, 0x17, 0x17
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AD518: 41820010  beq 0x823ad528
	if ctx.cr[0].eq {
	pc = 0x823AD528; continue 'dispatch;
	}
	// 823AD51C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AD520: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD524: 4802F755  bl 0x823dcc78
	ctx.lr = 0x823AD528;
	sub_823DCC78(ctx, base);
            }
            0x823AD528 => {
    //   block [0x823AD528..0x823AD548)
	// 823AD528: 57AB05AD  rlwinm. r11, r29, 0, 0x16, 0x16
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AD52C: 4182001C  beq 0x823ad548
	if ctx.cr[0].eq {
	pc = 0x823AD548; continue 'dispatch;
	}
	// 823AD530: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AD534: 57AA5EFA  rlwinm r10, r29, 0xb, 0x1b, 0x1d
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x001FFFFFu64;
	// 823AD538: 396B081C  addi r11, r11, 0x81c
	ctx.r[11].s64 = ctx.r[11].s64 + 2076;
	// 823AD53C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD540: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823AD544: 4802F765  bl 0x823dcca8
	ctx.lr = 0x823AD548;
	sub_823DCCA8(ctx, base);
	pc = 0x823AD548; continue 'dispatch;
            }
            0x823AD548 => {
    //   block [0x823AD548..0x823AD574)
	// 823AD548: 57AB0673  rlwinm. r11, r29, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AD54C: 41820028  beq 0x823ad574
	if ctx.cr[0].eq {
	pc = 0x823AD574; continue 'dispatch;
	}
	// 823AD550: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823AD554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD558: 4802EFF1  bl 0x823dc548
	ctx.lr = 0x823AD55C;
	sub_823DC548(ctx, base);
	// 823AD55C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AD560: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD564: 4802F445  bl 0x823dc9a8
	ctx.lr = 0x823AD568;
	sub_823DC9A8(ctx, base);
	// 823AD568: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 823AD56C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD570: 4802F4A1  bl 0x823dca10
	ctx.lr = 0x823AD574;
	sub_823DCA10(ctx, base);
	pc = 0x823AD574; continue 'dispatch;
            }
            0x823AD574 => {
    //   block [0x823AD574..0x823AD5A0)
	// 823AD574: 57AB0631  rlwinm. r11, r29, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AD578: 41820028  beq 0x823ad5a0
	if ctx.cr[0].eq {
	pc = 0x823AD5A0; continue 'dispatch;
	}
	// 823AD57C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823AD580: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD584: 4802EFC5  bl 0x823dc548
	ctx.lr = 0x823AD588;
	sub_823DC548(ctx, base);
	// 823AD588: 388000FF  li r4, 0xff
	ctx.r[4].s64 = 255;
	// 823AD58C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD590: 4802F419  bl 0x823dc9a8
	ctx.lr = 0x823AD594;
	sub_823DC9A8(ctx, base);
	// 823AD594: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 823AD598: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD59C: 4802F475  bl 0x823dca10
	ctx.lr = 0x823AD5A0;
	sub_823DCA10(ctx, base);
	pc = 0x823AD5A0; continue 'dispatch;
            }
            0x823AD5A0 => {
    //   block [0x823AD5A0..0x823AD63C)
	// 823AD5A0: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 823AD5A4: 57ABF73A  rlwinm r11, r29, 0x1e, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000003u64;
	// 823AD5A8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823AD5AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD5B0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 823AD5B4: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 823AD5B8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 823AD5BC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823AD5C0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 823AD5C4: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823AD5C8: 4802EF21  bl 0x823dc4e8
	ctx.lr = 0x823AD5CC;
	sub_823DC4E8(ctx, base);
	// 823AD5CC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823AD5D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823AD5D4: 53AB9E36  rlwimi r11, r29, 0x13, 0x18, 0x1b
	ctx.r[11].u64 = (((ctx.r[29].u32).rotate_left(19) as u64) & 0x00000000000000F0) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFF0F);
	// 823AD5D8: 5564063E  clrlwi r4, r11, 0x18
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823AD5DC: 4BFF7275  bl 0x823a4850
	ctx.lr = 0x823AD5E0;
	sub_823A4850(ctx, base);
	// 823AD5E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823AD5E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD5E8: 80DF0028  lwz r6, 0x28(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823AD5EC: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823AD5F0: 4819A5A9  bl 0x82547b98
	ctx.lr = 0x823AD5F4;
	sub_82547B98(ctx, base);
	// 823AD5F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AD5F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823AD5FC: 4BFF7255  bl 0x823a4850
	ctx.lr = 0x823AD600;
	sub_823A4850(ctx, base);
	// 823AD600: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 823AD604: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD608: 4802EEE1  bl 0x823dc4e8
	ctx.lr = 0x823AD60C;
	sub_823DC4E8(ctx, base);
	// 823AD60C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AD610: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD614: 4802EF35  bl 0x823dc548
	ctx.lr = 0x823AD618;
	sub_823DC548(ctx, base);
	// 823AD618: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823AD61C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD620: 4802F659  bl 0x823dcc78
	ctx.lr = 0x823AD624;
	sub_823DCC78(ctx, base);
	// 823AD624: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 823AD628: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AD62C: 4802F67D  bl 0x823dcca8
	ctx.lr = 0x823AD630;
	sub_823DCCA8(ctx, base);
	// 823AD630: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AD634: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823AD638: 48187AD0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AD640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AD640 size=232
    let mut pc: u32 = 0x823AD640;
    'dispatch: loop {
        match pc {
            0x823AD640 => {
    //   block [0x823AD640..0x823AD728)
	// 823AD640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AD644: 48187A79  bl 0x825350bc
	ctx.lr = 0x823AD648;
	sub_82535080(ctx, base);
	// 823AD648: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AD64C: 80ED0000  lwz r7, 0(r13)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AD650: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 823AD654: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AD728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AD728 size=1160
    let mut pc: u32 = 0x823AD728;
    'dispatch: loop {
        match pc {
            0x823AD728 => {
    //   block [0x823AD728..0x823ADBB0)
	// 823AD728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AD72C: 48187971  bl 0x8253509c
	ctx.lr = 0x823AD730;
	sub_82535080(ctx, base);
	// 823AD730: 54AB3032  slwi r11, r5, 6
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823AD734: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 823AD738: 9161FF90  stw r11, -0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.r[11].u32 ) };
	// 823AD73C: 7C005A2C  dcbt 0, r11
	// 823AD740: 7D653050  subf r11, r5, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[5].s64;
	// 823AD744: B0A3001C  sth r5, 0x1c(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[5].u16 ) };
	// 823AD748: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823AD74C: B0C3001E  sth r6, 0x1e(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[6].u16 ) };
	// 823AD750: 9161FF98  stw r11, -0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.r[11].u32 ) };
	// 823AD754: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823AD758: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823AD75C: 9161FF94  stw r11, -0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-108 as u32), ctx.r[11].u32 ) };
	// 823AD760: 556B3830  slwi r11, r11, 7
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823AD764: 390B007F  addi r8, r11, 0x7f
	ctx.r[8].s64 = ctx.r[11].s64 + 127;
	// 823AD768: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AD76C: 55070030  rlwinm r7, r8, 0, 0, 0x18
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 823AD770: 396BD180  addi r11, r11, -0x2e80
	ctx.r[11].s64 = ctx.r[11].s64 + -11904;
	// 823AD774: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AD778: 7C0057EC  dcbz 0, r10
	ea.u32 = ctx.r[10].u32;
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823AD77C: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 823AD780: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AD784: 3BE00020  li r31, 0x20
	ctx.r[31].s64 = 32;
	// 823AD788: 3B880008  addi r28, r8, 8
	ctx.r[28].s64 = ctx.r[8].s64 + 8;
	// 823AD78C: 810B0018  lwz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AD790: 8121FF94  lwz r9, -0x6c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-108 as u32) ) } as u64;
	// 823AD794: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 823AD798: 7CE83A14  add r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 823AD79C: 82A1FF98  lwz r21, -0x68(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) } as u64;
	// 823AD7A0: 55293032  slwi r9, r9, 6
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ADBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823ADBB0 size=396
    let mut pc: u32 = 0x823ADBB0;
    'dispatch: loop {
        match pc {
            0x823ADBB0 => {
    //   block [0x823ADBB0..0x823ADBE8)
	// 823ADBB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823ADBB4: 48187509  bl 0x825350bc
	ctx.lr = 0x823ADBB8;
	sub_82535080(ctx, base);
	// 823ADBB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823ADBBC: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823ADBC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823ADBC4: 3BCB1B00  addi r30, r11, 0x1b00
	ctx.r[30].s64 = ctx.r[11].s64 + 6912;
	// 823ADBC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823ADBCC: 387E02F4  addi r3, r30, 0x2f4
	ctx.r[3].s64 = ctx.r[30].s64 + 756;
	// 823ADBD0: 4835F68D  bl 0x8270d25c
	ctx.lr = 0x823ADBD4;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823ADBD4: A17E0230  lhz r11, 0x230(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(560 as u32) ) } as u64;
	// 823ADBD8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823ADBDC: 4182000C  beq 0x823adbe8
	if ctx.cr[0].eq {
	pc = 0x823ADBE8; continue 'dispatch;
	}
	// 823ADBE0: 387E0230  addi r3, r30, 0x230
	ctx.r[3].s64 = ctx.r[30].s64 + 560;
	// 823ADBE4: 4BFF7DF5  bl 0x823a59d8
	ctx.lr = 0x823ADBE8;
	sub_823A59D8(ctx, base);
	pc = 0x823ADBE8; continue 'dispatch;
            }
            0x823ADBE8 => {
    //   block [0x823ADBE8..0x823ADD3C)
	// 823ADBE8: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 823ADBEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823ADBF0: 389E0240  addi r4, r30, 0x240
	ctx.r[4].s64 = ctx.r[30].s64 + 576;
	// 823ADBF4: 48186F5D  bl 0x82534b50
	ctx.lr = 0x823ADBF8;
	sub_82534B50(ctx, base);
	// 823ADBF8: 387E02F4  addi r3, r30, 0x2f4
	ctx.r[3].s64 = ctx.r[30].s64 + 756;
	// 823ADBFC: 4835F671  bl 0x8270d26c
	ctx.lr = 0x823ADC00;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ADD40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823ADD40 size=228
    let mut pc: u32 = 0x823ADD40;
    'dispatch: loop {
        match pc {
            0x823ADD40 => {
    //   block [0x823ADD40..0x823ADE24)
	// 823ADD40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823ADD44: 48187379  bl 0x825350bc
	ctx.lr = 0x823ADD48;
	sub_82535080(ctx, base);
	// 823ADD48: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 823ADD4C: 4818B659  bl 0x825393a4
	ctx.lr = 0x823ADD50;
	sub_82539130(ctx, base);
	// 823ADD50: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823ADD54: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823ADE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823ADE28 size=736
    let mut pc: u32 = 0x823ADE28;
    'dispatch: loop {
        match pc {
            0x823ADE28 => {
    //   block [0x823ADE28..0x823ADFE4)
	// 823ADE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823ADE2C: 48187289  bl 0x825350b4
	ctx.lr = 0x823ADE30;
	sub_82535080(ctx, base);
	// 823ADE30: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823ADE34: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 823ADE38: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823ADE3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823ADE40: 394A0874  addi r10, r10, 0x874
	ctx.r[10].s64 = ctx.r[10].s64 + 2164;
	// 823ADE44: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 823ADE48: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 823ADE4C: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 823ADE50: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823ADE54: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 823ADE58: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823ADE5C: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 823ADE60: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823ADE64: 93C10104  stw r30, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[30].u32 ) };
	// 823ADE68: 386A9000  addi r3, r10, -0x7000
	ctx.r[3].s64 = ctx.r[10].s64 + -28672;
	// 823ADE6C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823ADE70: 1C9E0030  mulli r4, r30, 0x30
	ctx.r[4].s32 = ((ctx.r[30].s32 as i64 * 48 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 823ADE74: 90DF0010  stw r6, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 823ADE78: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823ADE7C: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 823ADE80: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 823ADE84: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 823ADE88: 4BFF5D99  bl 0x823a3c20
	ctx.lr = 0x823ADE8C;
	sub_823A3C20(ctx, base);
	// 823ADE8C: 39210104  addi r9, r1, 0x104
	ctx.r[9].s64 = ctx.r[1].s64 + 260;
	// 823ADE90: 39010104  addi r8, r1, 0x104
	ctx.r[8].s64 = ctx.r[1].s64 + 260;
	// 823ADE94: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823ADE98: 57C7F0BE  srwi r7, r30, 2
	ctx.r[7].u32 = ctx.r[30].u32.wrapping_shr(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 823ADE9C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 823ADEA0: 7C00488E  lvewx v0, 0, r9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[0] using VectorMaskL[(tmp.u32 & 0xF)]
	// 823ADEA4: 57C507BE  clrlwi r5, r30, 0x1e
	ctx.r[5].u64 = ctx.r[30].u32 as u64 & 0x00000003u64;
	// 823ADEA8: 7CE0400C  lvsl v7, 0, r8
	tmp.u32 = ctx.r[8].u32;
	// ctx.v[7] = VectorShiftTableL[(tmp.u32 & 0xF)]
	// 823ADEAC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 823ADEB0: 100001EB  vperm v0, v0, v0, v7
	for i in 0..16 {
		let sel = (ctx.v[7].u8[i] & 0x1F) as usize;
		ctx.v[0].u8[i] = if sel < 16 { ctx.v[0].u8[sel] } else { ctx.v[0].u8[sel - 16] };
	}
	// 823ADEB4: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823ADEB8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823ADEBC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 823ADEC0: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 823ADEC4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 823ADEC8: 1000028C  vspltw v0, v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = ctx.v[0].u32[3];
	}
	// 823ADECC: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 823ADED0: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 823ADED4: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 823ADED8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 823ADEDC: 1000030A  vcfux v0, v0, 0
	// vcfux/vcuxwfp128: ctx.v[0].f32[i] = ( ctx.v[0].u32[i] as f32 ) * (2.0f32).powi(0);
	for i in 0..4 { ctx.v[0].f32[i] = (ctx.v[0].u32[i] as f32) * (2.0f32).powi(0); }
	// 823ADEE0: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 823ADEE4: 57AB06B5  rlwinm. r11, r29, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823ADEE8: 1120010A  vrefp v9, v0
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[9].f32[i] = 1.0f32 / ctx.v[0].f32[i];
	}
	// 823ADEEC: 418200F8  beq 0x823adfe4
	if ctx.cr[0].eq {
	pc = 0x823ADFE4; continue 'dispatch;
	}
	// 823ADEF0: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 823ADEF4: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	pc = 0x823ADFE4; continue 'dispatch;
            }
            0x823ADFE4 => {
    //   block [0x823ADFE4..0x823AE108)
	// 823ADFE4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 823ADFE8: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823ADFEC: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 823ADFF0: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 823ADFF4: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 823ADFF8: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 823ADFFC: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 823AE000: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AE108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AE108 size=140
    let mut pc: u32 = 0x823AE108;
    'dispatch: loop {
        match pc {
            0x823AE108 => {
    //   block [0x823AE108..0x823AE150)
	// 823AE108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AE10C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AE110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823AE114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AE118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AE11C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823AE120: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 823AE124: 57CB0631  rlwinm. r11, r30, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AE128: 41820028  beq 0x823ae150
	if ctx.cr[0].eq {
	pc = 0x823AE150; continue 'dispatch;
	}
	// 823AE12C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823AE130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE134: 4802E415  bl 0x823dc548
	ctx.lr = 0x823AE138;
	sub_823DC548(ctx, base);
	// 823AE138: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE13C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE140: 4802E869  bl 0x823dc9a8
	ctx.lr = 0x823AE144;
	sub_823DC9A8(ctx, base);
	// 823AE144: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 823AE148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE14C: 4802E8C5  bl 0x823dca10
	ctx.lr = 0x823AE150;
	sub_823DCA10(ctx, base);
	pc = 0x823AE150; continue 'dispatch;
            }
            0x823AE150 => {
    //   block [0x823AE150..0x823AE17C)
	// 823AE150: 57CB05EF  rlwinm. r11, r30, 0, 0x17, 0x17
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AE154: 41820028  beq 0x823ae17c
	if ctx.cr[0].eq {
	pc = 0x823AE17C; continue 'dispatch;
	}
	// 823AE158: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823AE15C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE160: 4802E3E9  bl 0x823dc548
	ctx.lr = 0x823AE164;
	sub_823DC548(ctx, base);
	// 823AE164: 388000FF  li r4, 0xff
	ctx.r[4].s64 = 255;
	// 823AE168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE16C: 4802E83D  bl 0x823dc9a8
	ctx.lr = 0x823AE170;
	sub_823DC9A8(ctx, base);
	// 823AE170: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 823AE174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE178: 4802E899  bl 0x823dca10
	ctx.lr = 0x823AE17C;
	sub_823DCA10(ctx, base);
	pc = 0x823AE17C; continue 'dispatch;
            }
            0x823AE17C => {
    //   block [0x823AE17C..0x823AE194)
	// 823AE17C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823AE180: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AE184: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AE188: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823AE18C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AE190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AE198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AE198 size=432
    let mut pc: u32 = 0x823AE198;
    'dispatch: loop {
        match pc {
            0x823AE198 => {
    //   block [0x823AE198..0x823AE218)
	// 823AE198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AE19C: 48186F1D  bl 0x825350b8
	ctx.lr = 0x823AE1A0;
	sub_82535080(ctx, base);
	// 823AE1A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AE1A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823AE1A8: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AE1AC: 3B8B0700  addi r28, r11, 0x700
	ctx.r[28].s64 = ctx.r[11].s64 + 1792;
	// 823AE1B0: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AE1B4: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AE1B8: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AE1BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AE1C0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 823AE1C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AE1C8: 4E800421  bctrl
	ctx.lr = 0x823AE1CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AE1CC: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AE1D0: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AE1D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823AE1D8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823AE1DC: 57A7D7FE  rlwinm r7, r29, 0x1a, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[29].u32 as u64 & 0x0000003Fu64;
	// 823AE1E0: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 823AE1E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AE1E8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823AE1EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE1F0: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 823AE1F4: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 823AE1F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AE1FC: 4E800421  bctrl
	ctx.lr = 0x823AE200;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AE200: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823AE204: 57AA04E7  rlwinm. r10, r29, 0, 0x13, 0x13
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AE208: 41820010  beq 0x823ae218
	if ctx.cr[0].eq {
	pc = 0x823AE218; continue 'dispatch;
	}
	// 823AE20C: 815F0480  lwz r10, 0x480(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1152 as u32) ) } as u64;
	// 823AE210: 554A05A4  rlwinm r10, r10, 0, 0x16, 0x12
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823AE214: 4800001C  b 0x823ae230
	pc = 0x823AE230; continue 'dispatch;
            }
            0x823AE218 => {
    //   block [0x823AE218..0x823AE22C)
	// 823AE218: 57AA01CF  rlwinm. r10, r29, 0, 7, 7
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AE21C: 815F0480  lwz r10, 0x480(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1152 as u32) ) } as u64;
	// 823AE220: 4182000C  beq 0x823ae22c
	if ctx.cr[0].eq {
	pc = 0x823AE22C; continue 'dispatch;
	}
	// 823AE224: 516A54EA  rlwimi r10, r11, 0xa, 0x13, 0x15
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(10) as u64) & 0x0000000000001C00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFE3FF);
	// 823AE228: 48000008  b 0x823ae230
	pc = 0x823AE230; continue 'dispatch;
            }
            0x823AE22C => {
    //   block [0x823AE22C..0x823AE230)
	// 823AE22C: 516A5CEA  rlwimi r10, r11, 0xb, 0x13, 0x15
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(11) as u64) & 0x0000000000001C00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFE3FF);
	pc = 0x823AE230; continue 'dispatch;
            }
            0x823AE230 => {
    //   block [0x823AE230..0x823AE258)
	// 823AE230: 915F0480  stw r10, 0x480(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1152 as u32), ctx.r[10].u32 ) };
	// 823AE234: E95F0018  ld r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 823AE238: 654A8000  oris r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 2147483648;
	// 823AE23C: F95F0018  std r10, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u64 ) };
	// 823AE240: 57AA04A5  rlwinm. r10, r29, 0, 0x12, 0x12
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AE244: 41820014  beq 0x823ae258
	if ctx.cr[0].eq {
	pc = 0x823AE258; continue 'dispatch;
	}
	// 823AE248: 817F0480  lwz r11, 0x480(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1152 as u32) ) } as u64;
	// 823AE24C: 556B04DE  rlwinm r11, r11, 0, 0x13, 0xf
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823AE250: 917F0480  stw r11, 0x480(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1152 as u32), ctx.r[11].u32 ) };
	// 823AE254: 48000020  b 0x823ae274
	pc = 0x823AE274; continue 'dispatch;
            }
            0x823AE258 => {
    //   block [0x823AE258..0x823AE26C)
	// 823AE258: 57AA018D  rlwinm. r10, r29, 0, 6, 6
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AE25C: 815F0480  lwz r10, 0x480(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1152 as u32) ) } as u64;
	// 823AE260: 4182000C  beq 0x823ae26c
	if ctx.cr[0].eq {
	pc = 0x823AE26C; continue 'dispatch;
	}
	// 823AE264: 516A6C24  rlwimi r10, r11, 0xd, 0x10, 0x12
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(13) as u64) & 0x000000000000E000) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF1FFF);
	// 823AE268: 48000008  b 0x823ae270
	pc = 0x823AE270; continue 'dispatch;
            }
            0x823AE26C => {
    //   block [0x823AE26C..0x823AE270)
	// 823AE26C: 516A7424  rlwimi r10, r11, 0xe, 0x10, 0x12
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(14) as u64) & 0x000000000000E000) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF1FFF);
	pc = 0x823AE270; continue 'dispatch;
            }
            0x823AE270 => {
    //   block [0x823AE270..0x823AE274)
	// 823AE270: 915F0480  stw r10, 0x480(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1152 as u32), ctx.r[10].u32 ) };
	pc = 0x823AE274; continue 'dispatch;
            }
            0x823AE274 => {
    //   block [0x823AE274..0x823AE294)
	// 823AE274: E97F0018  ld r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 823AE278: 656B8000  oris r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 2147483648;
	// 823AE27C: F97F0018  std r11, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 823AE280: 57AB05AD  rlwinm. r11, r29, 0, 0x16, 0x16
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AE284: 41820010  beq 0x823ae294
	if ctx.cr[0].eq {
	pc = 0x823AE294; continue 'dispatch;
	}
	// 823AE288: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE28C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE290: 4802E9E9  bl 0x823dcc78
	ctx.lr = 0x823AE294;
	sub_823DCC78(ctx, base);
	pc = 0x823AE294; continue 'dispatch;
            }
            0x823AE294 => {
    //   block [0x823AE294..0x823AE2A8)
	// 823AE294: 57AB056B  rlwinm. r11, r29, 0, 0x15, 0x15
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AE298: 41820010  beq 0x823ae2a8
	if ctx.cr[0].eq {
	pc = 0x823AE2A8; continue 'dispatch;
	}
	// 823AE29C: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 823AE2A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE2A4: 4802EA05  bl 0x823dcca8
	ctx.lr = 0x823AE2A8;
	sub_823DCCA8(ctx, base);
	pc = 0x823AE2A8; continue 'dispatch;
            }
            0x823AE2A8 => {
    //   block [0x823AE2A8..0x823AE348)
	// 823AE2A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823AE2AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823AE2B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AE2B4: 4BFFFE55  bl 0x823ae108
	ctx.lr = 0x823AE2B8;
	sub_823AE108(ctx, base);
	// 823AE2B8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823AE2BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823AE2C0: 53AB9E36  rlwimi r11, r29, 0x13, 0x18, 0x1b
	ctx.r[11].u64 = (((ctx.r[29].u32).rotate_left(19) as u64) & 0x00000000000000F0) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFF0F);
	// 823AE2C4: 5564063E  clrlwi r4, r11, 0x18
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823AE2C8: 4BFF6589  bl 0x823a4850
	ctx.lr = 0x823AE2CC;
	sub_823A4850(ctx, base);
	// 823AE2CC: 38800013  li r4, 0x13
	ctx.r[4].s64 = 19;
	// 823AE2D0: 80DE0020  lwz r6, 0x20(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 823AE2D4: 80BE001C  lwz r5, 0x1c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AE2D8: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AE2DC: 48004EDD  bl 0x823b31b8
	ctx.lr = 0x823AE2E0;
	sub_823B31B8(ctx, base);
	// 823AE2E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE2E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE2E8: 4802E201  bl 0x823dc4e8
	ctx.lr = 0x823AE2EC;
	sub_823DC4E8(ctx, base);
	// 823AE2EC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823AE2F0: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 823AE2F4: 80DE0018  lwz r6, 0x18(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AE2F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE2FC: 4819989D  bl 0x82547b98
	ctx.lr = 0x823AE300;
	sub_82547B98(ctx, base);
	// 823AE300: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 823AE304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE308: 4802E1E1  bl 0x823dc4e8
	ctx.lr = 0x823AE30C;
	sub_823DC4E8(ctx, base);
	// 823AE30C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE310: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823AE314: 4BFF653D  bl 0x823a4850
	ctx.lr = 0x823AE318;
	sub_823A4850(ctx, base);
	// 823AE318: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE31C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE320: 4802E229  bl 0x823dc548
	ctx.lr = 0x823AE324;
	sub_823DC548(ctx, base);
	// 823AE324: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823AE328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE32C: 4802E94D  bl 0x823dcc78
	ctx.lr = 0x823AE330;
	sub_823DCC78(ctx, base);
	// 823AE330: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 823AE334: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE338: 4802E971  bl 0x823dcca8
	ctx.lr = 0x823AE33C;
	sub_823DCCA8(ctx, base);
	// 823AE33C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AE340: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823AE344: 48186DC4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AE348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823AE348 size=292
    let mut pc: u32 = 0x823AE348;
    'dispatch: loop {
        match pc {
            0x823AE348 => {
    //   block [0x823AE348..0x823AE46C)
	// 823AE348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AE34C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AE350: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823AE354: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AE358: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AE35C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823AE360: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823AE364: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 823AE368: 394A0890  addi r10, r10, 0x890
	ctx.r[10].s64 = ctx.r[10].s64 + 2192;
	// 823AE36C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823AE370: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 823AE374: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 823AE378: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823AE37C: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823AE380: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 823AE384: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AE388: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823AE38C: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 823AE390: 90DE0010  stw r6, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 823AE394: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 823AE398: 38699000  addi r3, r9, -0x7000
	ctx.r[3].s64 = ctx.r[9].s64 + -28672;
	// 823AE39C: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 823AE3A0: 4BFF5881  bl 0x823a3c20
	ctx.lr = 0x823AE3A4;
	sub_823A3C20(ctx, base);
	// 823AE3A4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823AE3A8: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823AE3AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823AE3B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AE3B4: C00A2048  lfs f0, 0x2048(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AE3B8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823AE3BC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823AE3C0: C1AABFFC  lfs f13, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823AE3C4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823AE3C8: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823AE3CC: C19F0010  lfs f12, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE3D0: D18B0008  stfs f12, 8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823AE3D4: C19F0014  lfs f12, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE3D8: D18B000C  stfs f12, 0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 823AE3DC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 823AE3E0: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823AE3E4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823AE3E8: C19F0010  lfs f12, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE3EC: D18B0008  stfs f12, 8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823AE3F0: C19F001C  lfs f12, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE3F4: C17F0014  lfs f11, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823AE3F8: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 823AE3FC: D18B000C  stfs f12, 0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 823AE400: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 823AE404: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823AE408: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823AE40C: C19F0010  lfs f12, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE410: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AE414: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 823AE418: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823AE41C: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AE420: C19F0014  lfs f12, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE424: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 823AE428: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 823AE42C: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 823AE430: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 823AE434: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AE438: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823AE43C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823AE440: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 823AE444: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AE448: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 823AE44C: 915E001C  stw r10, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 823AE450: 913E0018  stw r9, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 823AE454: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823AE458: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AE45C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AE460: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823AE464: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AE468: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AE470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AE470 size=428
    let mut pc: u32 = 0x823AE470;
    'dispatch: loop {
        match pc {
            0x823AE470 => {
    //   block [0x823AE470..0x823AE4F0)
	// 823AE470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AE474: 48186C45  bl 0x825350b8
	ctx.lr = 0x823AE478;
	sub_82535080(ctx, base);
	// 823AE478: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AE47C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823AE480: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AE484: 3B8B0700  addi r28, r11, 0x700
	ctx.r[28].s64 = ctx.r[11].s64 + 1792;
	// 823AE488: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AE48C: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AE490: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AE494: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AE498: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 823AE49C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AE4A0: 4E800421  bctrl
	ctx.lr = 0x823AE4A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AE4A4: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AE4A8: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AE4AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823AE4B0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823AE4B4: 57A7D7FE  rlwinm r7, r29, 0x1a, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[29].u32 as u64 & 0x0000003Fu64;
	// 823AE4B8: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 823AE4BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AE4C0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823AE4C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE4C8: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 823AE4CC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 823AE4D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AE4D4: 4E800421  bctrl
	ctx.lr = 0x823AE4D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AE4D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823AE4DC: 57AB04E7  rlwinm. r11, r29, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AE4E0: 41820010  beq 0x823ae4f0
	if ctx.cr[0].eq {
	pc = 0x823AE4F0; continue 'dispatch;
	}
	// 823AE4E4: 813F0480  lwz r9, 0x480(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1152 as u32) ) } as u64;
	// 823AE4E8: 552905A4  rlwinm r9, r9, 0, 0x16, 0x12
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 823AE4EC: 4800001C  b 0x823ae508
	pc = 0x823AE508; continue 'dispatch;
            }
            0x823AE4F0 => {
    //   block [0x823AE4F0..0x823AE504)
	// 823AE4F0: 57A901CF  rlwinm. r9, r29, 0, 7, 7
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823AE4F4: 813F0480  lwz r9, 0x480(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1152 as u32) ) } as u64;
	// 823AE4F8: 4182000C  beq 0x823ae504
	if ctx.cr[0].eq {
	pc = 0x823AE504; continue 'dispatch;
	}
	// 823AE4FC: 514954EA  rlwimi r9, r10, 0xa, 0x13, 0x15
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(10) as u64) & 0x0000000000001C00) | (ctx.r[9].u64 & 0xFFFFFFFFFFFFE3FF);
	// 823AE500: 48000008  b 0x823ae508
	pc = 0x823AE508; continue 'dispatch;
            }
            0x823AE504 => {
    //   block [0x823AE504..0x823AE508)
	// 823AE504: 51495CEA  rlwimi r9, r10, 0xb, 0x13, 0x15
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(11) as u64) & 0x0000000000001C00) | (ctx.r[9].u64 & 0xFFFFFFFFFFFFE3FF);
	pc = 0x823AE508; continue 'dispatch;
            }
            0x823AE508 => {
    //   block [0x823AE508..0x823AE52C)
	// 823AE508: 913F0480  stw r9, 0x480(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1152 as u32), ctx.r[9].u32 ) };
	// 823AE50C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823AE510: E93F0018  ld r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 823AE514: 65298000  oris r9, r9, 0x8000
	ctx.r[9].u64 = ctx.r[9].u64 | 2147483648;
	// 823AE518: F93F0018  std r9, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u64 ) };
	// 823AE51C: 419A0010  beq cr6, 0x823ae52c
	if ctx.cr[6].eq {
	pc = 0x823AE52C; continue 'dispatch;
	}
	// 823AE520: 817F0480  lwz r11, 0x480(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1152 as u32) ) } as u64;
	// 823AE524: 556B04DE  rlwinm r11, r11, 0, 0x13, 0xf
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823AE528: 4800001C  b 0x823ae544
	pc = 0x823AE544; continue 'dispatch;
            }
            0x823AE52C => {
    //   block [0x823AE52C..0x823AE540)
	// 823AE52C: 57AB018D  rlwinm. r11, r29, 0, 6, 6
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AE530: 817F0480  lwz r11, 0x480(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1152 as u32) ) } as u64;
	// 823AE534: 4182000C  beq 0x823ae540
	if ctx.cr[0].eq {
	pc = 0x823AE540; continue 'dispatch;
	}
	// 823AE538: 514B6C24  rlwimi r11, r10, 0xd, 0x10, 0x12
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(13) as u64) & 0x000000000000E000) | (ctx.r[11].u64 & 0xFFFFFFFFFFFF1FFF);
	// 823AE53C: 48000008  b 0x823ae544
	pc = 0x823AE544; continue 'dispatch;
            }
            0x823AE540 => {
    //   block [0x823AE540..0x823AE544)
	// 823AE540: 514B7424  rlwimi r11, r10, 0xe, 0x10, 0x12
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(14) as u64) & 0x000000000000E000) | (ctx.r[11].u64 & 0xFFFFFFFFFFFF1FFF);
	pc = 0x823AE544; continue 'dispatch;
            }
            0x823AE544 => {
    //   block [0x823AE544..0x823AE568)
	// 823AE544: 917F0480  stw r11, 0x480(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1152 as u32), ctx.r[11].u32 ) };
	// 823AE548: E97F0018  ld r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 823AE54C: 656B8000  oris r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 2147483648;
	// 823AE550: F97F0018  std r11, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 823AE554: 57AB05AD  rlwinm. r11, r29, 0, 0x16, 0x16
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AE558: 41820010  beq 0x823ae568
	if ctx.cr[0].eq {
	pc = 0x823AE568; continue 'dispatch;
	}
	// 823AE55C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE564: 4802E715  bl 0x823dcc78
	ctx.lr = 0x823AE568;
	sub_823DCC78(ctx, base);
	pc = 0x823AE568; continue 'dispatch;
            }
            0x823AE568 => {
    //   block [0x823AE568..0x823AE57C)
	// 823AE568: 57AB056B  rlwinm. r11, r29, 0, 0x15, 0x15
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AE56C: 41820010  beq 0x823ae57c
	if ctx.cr[0].eq {
	pc = 0x823AE57C; continue 'dispatch;
	}
	// 823AE570: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 823AE574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE578: 4802E731  bl 0x823dcca8
	ctx.lr = 0x823AE57C;
	sub_823DCCA8(ctx, base);
	pc = 0x823AE57C; continue 'dispatch;
            }
            0x823AE57C => {
    //   block [0x823AE57C..0x823AE61C)
	// 823AE57C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823AE580: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823AE584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AE588: 4BFFFB81  bl 0x823ae108
	ctx.lr = 0x823AE58C;
	sub_823AE108(ctx, base);
	// 823AE58C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823AE590: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823AE594: 53AB9E36  rlwimi r11, r29, 0x13, 0x18, 0x1b
	ctx.r[11].u64 = (((ctx.r[29].u32).rotate_left(19) as u64) & 0x00000000000000F0) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFF0F);
	// 823AE598: 5564063E  clrlwi r4, r11, 0x18
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823AE59C: 4BFF62B5  bl 0x823a4850
	ctx.lr = 0x823AE5A0;
	sub_823A4850(ctx, base);
	// 823AE5A0: 38800012  li r4, 0x12
	ctx.r[4].s64 = 18;
	// 823AE5A4: 80DE001C  lwz r6, 0x1c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AE5A8: 80BE0018  lwz r5, 0x18(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AE5AC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AE5B0: 48004C09  bl 0x823b31b8
	ctx.lr = 0x823AE5B4;
	sub_823B31B8(ctx, base);
	// 823AE5B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE5B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE5BC: 4802DF2D  bl 0x823dc4e8
	ctx.lr = 0x823AE5C0;
	sub_823DC4E8(ctx, base);
	// 823AE5C0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 823AE5C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823AE5C8: 3880000D  li r4, 0xd
	ctx.r[4].s64 = 13;
	// 823AE5CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE5D0: 481995C9  bl 0x82547b98
	ctx.lr = 0x823AE5D4;
	sub_82547B98(ctx, base);
	// 823AE5D4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 823AE5D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE5DC: 4802DF0D  bl 0x823dc4e8
	ctx.lr = 0x823AE5E0;
	sub_823DC4E8(ctx, base);
	// 823AE5E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE5E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823AE5E8: 4BFF6269  bl 0x823a4850
	ctx.lr = 0x823AE5EC;
	sub_823A4850(ctx, base);
	// 823AE5EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE5F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE5F4: 4802DF55  bl 0x823dc548
	ctx.lr = 0x823AE5F8;
	sub_823DC548(ctx, base);
	// 823AE5F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823AE5FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE600: 4802E679  bl 0x823dcc78
	ctx.lr = 0x823AE604;
	sub_823DCC78(ctx, base);
	// 823AE604: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 823AE608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE60C: 4802E69D  bl 0x823dcca8
	ctx.lr = 0x823AE610;
	sub_823DCCA8(ctx, base);
	// 823AE610: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AE614: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823AE618: 48186AF0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AE620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823AE620 size=380
    let mut pc: u32 = 0x823AE620;
    'dispatch: loop {
        match pc {
            0x823AE620 => {
    //   block [0x823AE620..0x823AE79C)
	// 823AE620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AE624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AE628: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823AE62C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AE630: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AE634: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823AE638: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823AE63C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823AE640: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 823AE644: 394A08AC  addi r10, r10, 0x8ac
	ctx.r[10].s64 = ctx.r[10].s64 + 2220;
	// 823AE648: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 823AE64C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823AE650: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823AE654: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 823AE658: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 823AE65C: 90DE0010  stw r6, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 823AE660: 38699000  addi r3, r9, -0x7000
	ctx.r[3].s64 = ctx.r[9].s64 + -28672;
	// 823AE664: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823AE668: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 823AE66C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AE670: 911E0014  stw r8, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 823AE674: 4BFF55AD  bl 0x823a3c20
	ctx.lr = 0x823AE678;
	sub_823A3C20(ctx, base);
	// 823AE678: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AE67C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823AE680: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823AE684: C00BBFFC  lfs f0, -0x4004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AE688: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AE68C: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823AE690: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823AE694: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE698: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823AE69C: C19F0014  lfs f12, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE6A0: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 823AE6A4: C19F0050  lfs f12, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE6A8: D1830010  stfs f12, 0x10(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 823AE6AC: C1AB2048  lfs f13, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823AE6B0: 39630020  addi r11, r3, 0x20
	ctx.r[11].s64 = ctx.r[3].s64 + 32;
	// 823AE6B4: C19F0054  lfs f12, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE6B8: D1830014  stfs f12, 0x14(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 823AE6BC: C19F0058  lfs f12, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE6C0: D1830018  stfs f12, 0x18(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 823AE6C4: C19F005C  lfs f12, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE6C8: D183001C  stfs f12, 0x1c(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 823AE6CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AE6D0: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823AE6D4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823AE6D8: C19F0010  lfs f12, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE6DC: D18B0008  stfs f12, 8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823AE6E0: C19F0014  lfs f12, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE6E4: D18B000C  stfs f12, 0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 823AE6E8: C19F0060  lfs f12, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE6EC: D18B0010  stfs f12, 0x10(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 823AE6F0: C19F0064  lfs f12, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE6F4: D18B0014  stfs f12, 0x14(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 823AE6F8: C19F0068  lfs f12, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE6FC: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 823AE700: C19F006C  lfs f12, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE704: D18B001C  stfs f12, 0x1c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 823AE708: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 823AE70C: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823AE710: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823AE714: C19F0010  lfs f12, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE718: D18B0008  stfs f12, 8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823AE71C: C19F001C  lfs f12, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE720: D18B000C  stfs f12, 0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 823AE724: C19F0070  lfs f12, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE728: D18B0010  stfs f12, 0x10(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 823AE72C: C19F0074  lfs f12, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE730: D18B0014  stfs f12, 0x14(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 823AE734: C19F0078  lfs f12, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE738: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 823AE73C: C19F007C  lfs f12, 0x7c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823AE740: D18B001C  stfs f12, 0x1c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 823AE744: D00B0020  stfs f0, 0x20(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 823AE748: D1AB0024  stfs f13, 0x24(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 823AE74C: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AE750: D00B0028  stfs f0, 0x28(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 823AE754: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AE758: D00B002C  stfs f0, 0x2c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 823AE75C: C01F0080  lfs f0, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AE760: D00B0030  stfs f0, 0x30(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 823AE764: C01F0084  lfs f0, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AE768: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 823AE76C: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AE770: D00B0038  stfs f0, 0x38(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 823AE774: C01F008C  lfs f0, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AE778: D00B003C  stfs f0, 0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 823AE77C: 915E001C  stw r10, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 823AE780: 913E0018  stw r9, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 823AE784: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823AE788: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AE78C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AE790: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823AE794: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AE798: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AE7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AE7A0 size=404
    let mut pc: u32 = 0x823AE7A0;
    'dispatch: loop {
        match pc {
            0x823AE7A0 => {
    //   block [0x823AE7A0..0x823AE820)
	// 823AE7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AE7A4: 48186915  bl 0x825350b8
	ctx.lr = 0x823AE7A8;
	sub_82535080(ctx, base);
	// 823AE7A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AE7AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823AE7B0: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AE7B4: 3B8B0700  addi r28, r11, 0x700
	ctx.r[28].s64 = ctx.r[11].s64 + 1792;
	// 823AE7B8: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AE7BC: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AE7C0: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AE7C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AE7C8: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 823AE7CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AE7D0: 4E800421  bctrl
	ctx.lr = 0x823AE7D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AE7D4: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AE7D8: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AE7DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823AE7E0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823AE7E4: 57A7D7FE  rlwinm r7, r29, 0x1a, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[29].u32 as u64 & 0x0000003Fu64;
	// 823AE7E8: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 823AE7EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AE7F0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823AE7F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE7F8: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 823AE7FC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 823AE800: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AE804: 4E800421  bctrl
	ctx.lr = 0x823AE808;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AE808: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823AE80C: 57AA04E7  rlwinm. r10, r29, 0, 0x13, 0x13
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AE810: 41820010  beq 0x823ae820
	if ctx.cr[0].eq {
	pc = 0x823AE820; continue 'dispatch;
	}
	// 823AE814: 815F0480  lwz r10, 0x480(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1152 as u32) ) } as u64;
	// 823AE818: 554A05A4  rlwinm r10, r10, 0, 0x16, 0x12
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823AE81C: 4800001C  b 0x823ae838
	pc = 0x823AE838; continue 'dispatch;
            }
            0x823AE820 => {
    //   block [0x823AE820..0x823AE834)
	// 823AE820: 57AA01CF  rlwinm. r10, r29, 0, 7, 7
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AE824: 815F0480  lwz r10, 0x480(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1152 as u32) ) } as u64;
	// 823AE828: 4182000C  beq 0x823ae834
	if ctx.cr[0].eq {
	pc = 0x823AE834; continue 'dispatch;
	}
	// 823AE82C: 516A54EA  rlwimi r10, r11, 0xa, 0x13, 0x15
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(10) as u64) & 0x0000000000001C00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFE3FF);
	// 823AE830: 48000008  b 0x823ae838
	pc = 0x823AE838; continue 'dispatch;
            }
            0x823AE834 => {
    //   block [0x823AE834..0x823AE838)
	// 823AE834: 516A5CEA  rlwimi r10, r11, 0xb, 0x13, 0x15
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(11) as u64) & 0x0000000000001C00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFE3FF);
	pc = 0x823AE838; continue 'dispatch;
            }
            0x823AE838 => {
    //   block [0x823AE838..0x823AE860)
	// 823AE838: 915F0480  stw r10, 0x480(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1152 as u32), ctx.r[10].u32 ) };
	// 823AE83C: E95F0018  ld r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 823AE840: 654A8000  oris r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 2147483648;
	// 823AE844: F95F0018  std r10, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u64 ) };
	// 823AE848: 57AA04A5  rlwinm. r10, r29, 0, 0x12, 0x12
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AE84C: 41820014  beq 0x823ae860
	if ctx.cr[0].eq {
	pc = 0x823AE860; continue 'dispatch;
	}
	// 823AE850: 817F0480  lwz r11, 0x480(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1152 as u32) ) } as u64;
	// 823AE854: 556B04DE  rlwinm r11, r11, 0, 0x13, 0xf
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823AE858: 917F0480  stw r11, 0x480(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1152 as u32), ctx.r[11].u32 ) };
	// 823AE85C: 48000020  b 0x823ae87c
	pc = 0x823AE87C; continue 'dispatch;
            }
            0x823AE860 => {
    //   block [0x823AE860..0x823AE874)
	// 823AE860: 57AA018D  rlwinm. r10, r29, 0, 6, 6
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AE864: 815F0480  lwz r10, 0x480(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1152 as u32) ) } as u64;
	// 823AE868: 4182000C  beq 0x823ae874
	if ctx.cr[0].eq {
	pc = 0x823AE874; continue 'dispatch;
	}
	// 823AE86C: 516A6C24  rlwimi r10, r11, 0xd, 0x10, 0x12
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(13) as u64) & 0x000000000000E000) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF1FFF);
	// 823AE870: 48000008  b 0x823ae878
	pc = 0x823AE878; continue 'dispatch;
            }
            0x823AE874 => {
    //   block [0x823AE874..0x823AE878)
	// 823AE874: 516A7424  rlwimi r10, r11, 0xe, 0x10, 0x12
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(14) as u64) & 0x000000000000E000) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF1FFF);
	pc = 0x823AE878; continue 'dispatch;
            }
            0x823AE878 => {
    //   block [0x823AE878..0x823AE87C)
	// 823AE878: 915F0480  stw r10, 0x480(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1152 as u32), ctx.r[10].u32 ) };
	pc = 0x823AE87C; continue 'dispatch;
            }
            0x823AE87C => {
    //   block [0x823AE87C..0x823AE8B0)
	// 823AE87C: E97F0018  ld r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 823AE880: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823AE884: 656B8000  oris r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 2147483648;
	// 823AE888: F97F0018  std r11, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 823AE88C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823AE890: 53AB9E36  rlwimi r11, r29, 0x13, 0x18, 0x1b
	ctx.r[11].u64 = (((ctx.r[29].u32).rotate_left(19) as u64) & 0x00000000000000F0) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFF0F);
	// 823AE894: 5564063E  clrlwi r4, r11, 0x18
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823AE898: 4BFF5FB9  bl 0x823a4850
	ctx.lr = 0x823AE89C;
	sub_823A4850(ctx, base);
	// 823AE89C: 57AB05AD  rlwinm. r11, r29, 0, 0x16, 0x16
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AE8A0: 41820010  beq 0x823ae8b0
	if ctx.cr[0].eq {
	pc = 0x823AE8B0; continue 'dispatch;
	}
	// 823AE8A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE8A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE8AC: 4802E3CD  bl 0x823dcc78
	ctx.lr = 0x823AE8B0;
	sub_823DCC78(ctx, base);
	pc = 0x823AE8B0; continue 'dispatch;
            }
            0x823AE8B0 => {
    //   block [0x823AE8B0..0x823AE8C4)
	// 823AE8B0: 57AB056B  rlwinm. r11, r29, 0, 0x15, 0x15
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AE8B4: 41820010  beq 0x823ae8c4
	if ctx.cr[0].eq {
	pc = 0x823AE8C4; continue 'dispatch;
	}
	// 823AE8B8: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 823AE8BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE8C0: 4802E3E9  bl 0x823dcca8
	ctx.lr = 0x823AE8C4;
	sub_823DCCA8(ctx, base);
	pc = 0x823AE8C4; continue 'dispatch;
            }
            0x823AE8C4 => {
    //   block [0x823AE8C4..0x823AE934)
	// 823AE8C4: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 823AE8C8: 80DE001C  lwz r6, 0x1c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AE8CC: 80BE0018  lwz r5, 0x18(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AE8D0: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AE8D4: 480048E5  bl 0x823b31b8
	ctx.lr = 0x823AE8D8;
	sub_823B31B8(ctx, base);
	// 823AE8D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE8DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE8E0: 4802DC09  bl 0x823dc4e8
	ctx.lr = 0x823AE8E4;
	sub_823DC4E8(ctx, base);
	// 823AE8E4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 823AE8E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823AE8EC: 3880000D  li r4, 0xd
	ctx.r[4].s64 = 13;
	// 823AE8F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE8F4: 481992A5  bl 0x82547b98
	ctx.lr = 0x823AE8F8;
	sub_82547B98(ctx, base);
	// 823AE8F8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 823AE8FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE900: 4802DBE9  bl 0x823dc4e8
	ctx.lr = 0x823AE904;
	sub_823DC4E8(ctx, base);
	// 823AE904: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE908: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823AE90C: 4BFF5F45  bl 0x823a4850
	ctx.lr = 0x823AE910;
	sub_823A4850(ctx, base);
	// 823AE910: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823AE914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE918: 4802E361  bl 0x823dcc78
	ctx.lr = 0x823AE91C;
	sub_823DCC78(ctx, base);
	// 823AE91C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 823AE920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AE924: 4802E385  bl 0x823dcca8
	ctx.lr = 0x823AE928;
	sub_823DCCA8(ctx, base);
	// 823AE928: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AE92C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823AE930: 481867D8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AE938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AE938 size=8
    let mut pc: u32 = 0x823AE938;
    'dispatch: loop {
        match pc {
            0x823AE938 => {
    //   block [0x823AE938..0x823AE940)
	// 823AE938: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AE93C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AE940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AE940 size=16
    let mut pc: u32 = 0x823AE940;
    'dispatch: loop {
        match pc {
            0x823AE940 => {
    //   block [0x823AE940..0x823AE950)
	// 823AE940: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AE944: 396B08C8  addi r11, r11, 0x8c8
	ctx.r[11].s64 = ctx.r[11].s64 + 2248;
	// 823AE948: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AE94C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AE950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AE950 size=592
    let mut pc: u32 = 0x823AE950;
    'dispatch: loop {
        match pc {
            0x823AE950 => {
    //   block [0x823AE950..0x823AE9B4)
	// 823AE950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AE954: 48186749  bl 0x8253509c
	ctx.lr = 0x823AE958;
	sub_82535080(ctx, base);
	// 823AE958: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AE95C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823AE960: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 823AE964: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 823AE968: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 823AE96C: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 823AE970: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 823AE974: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 823AE978: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 823AE97C: 419A0038  beq cr6, 0x823ae9b4
	if ctx.cr[6].eq {
	pc = 0x823AE9B4; continue 'dispatch;
	}
	// 823AE980: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823AE984: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 823AE988: 386BF080  addi r3, r11, -0xf80
	ctx.r[3].s64 = ctx.r[11].s64 + -3968;
	// 823AE98C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823AE990: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 823AE994: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823AE998: 4BFEFCF1  bl 0x8239e688
	ctx.lr = 0x823AE99C;
	sub_8239E688(ctx, base);
	// 823AE99C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AE9A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AE9A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AE9A8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 823AE9AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AE9B0: 4E800421  bctrl
	ctx.lr = 0x823AE9B4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823AE9B4 => {
    //   block [0x823AE9B4..0x823AE9EC)
	// 823AE9B4: 3D601A22  lis r11, 0x1a22
	ctx.r[11].s64 = 438435840;
	// 823AE9B8: 616BAB5D  ori r11, r11, 0xab5d
	ctx.r[11].u64 = ctx.r[11].u64 | 43869;
	// 823AE9BC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AE9C0: 419A0044  beq cr6, 0x823aea04
	if ctx.cr[6].eq {
	pc = 0x823AEA04; continue 'dispatch;
	}
	// 823AE9C4: 3D602828  lis r11, 0x2828
	ctx.r[11].s64 = 673710080;
	// 823AE9C8: 616B0106  ori r11, r11, 0x106
	ctx.r[11].u64 = ctx.r[11].u64 | 262;
	// 823AE9CC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AE9D0: 419A0028  beq cr6, 0x823ae9f8
	if ctx.cr[6].eq {
	pc = 0x823AE9F8; continue 'dispatch;
	}
	// 823AE9D4: 3D602D22  lis r11, 0x2d22
	ctx.r[11].s64 = 757202944;
	// 823AE9D8: 616BAB9C  ori r11, r11, 0xab9c
	ctx.r[11].u64 = ctx.r[11].u64 | 43932;
	// 823AE9DC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AE9E0: 419A000C  beq cr6, 0x823ae9ec
	if ctx.cr[6].eq {
	pc = 0x823AE9EC; continue 'dispatch;
	}
	// 823AE9E4: 7FF5FB78  mr r21, r31
	ctx.r[21].u64 = ctx.r[31].u64;
	// 823AE9E8: 48000024  b 0x823aea0c
	pc = 0x823AEA0C; continue 'dispatch;
            }
            0x823AE9EC => {
    //   block [0x823AE9EC..0x823AE9F8)
	// 823AE9EC: 3EA02D22  lis r21, 0x2d22
	ctx.r[21].s64 = 757202944;
	// 823AE9F0: 62B5AB9F  ori r21, r21, 0xab9f
	ctx.r[21].u64 = ctx.r[21].u64 | 43935;
	// 823AE9F4: 48000018  b 0x823aea0c
	pc = 0x823AEA0C; continue 'dispatch;
            }
            0x823AE9F8 => {
    //   block [0x823AE9F8..0x823AEA04)
	// 823AE9F8: 3EA01828  lis r21, 0x1828
	ctx.r[21].s64 = 405274624;
	// 823AE9FC: 62B50186  ori r21, r21, 0x186
	ctx.r[21].u64 = ctx.r[21].u64 | 390;
	// 823AEA00: 4800000C  b 0x823aea0c
	pc = 0x823AEA0C; continue 'dispatch;
            }
            0x823AEA04 => {
    //   block [0x823AEA04..0x823AEA0C)
	// 823AEA04: 3EA01A22  lis r21, 0x1a22
	ctx.r[21].s64 = 438435840;
	// 823AEA08: 62B5AB60  ori r21, r21, 0xab60
	ctx.r[21].u64 = ctx.r[21].u64 | 43872;
	pc = 0x823AEA0C; continue 'dispatch;
            }
            0x823AEA0C => {
    //   block [0x823AEA0C..0x823AEA24)
	// 823AEA0C: 2F170001  cmpwi cr6, r23, 1
	ctx.cr[6].compare_i32(ctx.r[23].s32, 1, &mut ctx.xer);
	// 823AEA10: 419A0014  beq cr6, 0x823aea24
	if ctx.cr[6].eq {
	pc = 0x823AEA24; continue 'dispatch;
	}
	// 823AEA14: 3977FFFE  addi r11, r23, -2
	ctx.r[11].s64 = ctx.r[23].s64 + -2;
	// 823AEA18: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823AEA1C: 5576E7BC  rlwinm r22, r11, 0x1c, 0x1e, 0x1e
	ctx.r[22].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823AEA20: 48000008  b 0x823aea28
	pc = 0x823AEA28; continue 'dispatch;
            }
            0x823AEA24 => {
    //   block [0x823AEA24..0x823AEA28)
	// 823AEA24: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	pc = 0x823AEA28; continue 'dispatch;
            }
            0x823AEA28 => {
    //   block [0x823AEA28..0x823AEA3C)
	// 823AEA28: 570B073F  clrlwi. r11, r24, 0x1c
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AEA2C: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 823AEA30: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 823AEA34: 40820008  bne 0x823aea3c
	if !ctx.cr[0].eq {
	pc = 0x823AEA3C; continue 'dispatch;
	}
	// 823AEA38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x823AEA3C; continue 'dispatch;
            }
            0x823AEA3C => {
    //   block [0x823AEA3C..0x823AEA7C)
	// 823AEA3C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823AEA40: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823AEA44: 409900B4  ble cr6, 0x823aeaf8
	if !ctx.cr[6].gt {
	pc = 0x823AEAF8; continue 'dispatch;
	}
	// 823AEA48: 570A06F7  rlwinm. r10, r24, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AEA4C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823AEA50: 40820058  bne 0x823aeaa8
	if !ctx.cr[0].eq {
	pc = 0x823AEAA8; continue 'dispatch;
	}
	// 823AEA54: 7D5E5B96  divwu r10, r30, r11
	ctx.r[10].u32 = ctx.r[30].u32 / ctx.r[11].u32;
	// 823AEA58: 394A001F  addi r10, r10, 0x1f
	ctx.r[10].s64 = ctx.r[10].s64 + 31;
	// 823AEA5C: 555A0034  rlwinm r26, r10, 0, 0, 0x1a
	ctx.r[26].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823AEA60: 419A0098  beq cr6, 0x823aeaf8
	if ctx.cr[6].eq {
	pc = 0x823AEAF8; continue 'dispatch;
	}
	// 823AEA64: 395D0010  addi r10, r29, 0x10
	ctx.r[10].s64 = ctx.r[29].s64 + 16;
	// 823AEA68: 92FD0008  stw r23, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 823AEA6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823AEA70: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823AEA74: 419A002C  beq cr6, 0x823aeaa0
	if ctx.cr[6].eq {
	pc = 0x823AEAA0; continue 'dispatch;
	}
	// 823AEA78: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	pc = 0x823AEA7C; continue 'dispatch;
            }
            0x823AEA7C => {
    //   block [0x823AEA7C..0x823AEAA0)
	// 823AEA7C: 7D09D214  add r8, r9, r26
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[26].u64;
	// 823AEA80: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823AEA84: 938A0004  stw r28, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 823AEA88: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AEA8C: 932A000C  stw r25, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 823AEA90: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 823AEA94: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 823AEA98: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 823AEA9C: 4082FFE0  bne 0x823aea7c
	if !ctx.cr[0].eq {
	pc = 0x823AEA7C; continue 'dispatch;
	}
	pc = 0x823AEAA0; continue 'dispatch;
            }
            0x823AEAA0 => {
    //   block [0x823AEAA0..0x823AEAA8)
	// 823AEAA0: 93CAFFF8  stw r30, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[30].u32 ) };
	// 823AEAA4: 48000054  b 0x823aeaf8
	pc = 0x823AEAF8; continue 'dispatch;
            }
            0x823AEAA8 => {
    //   block [0x823AEAA8..0x823AEAD0)
	// 823AEAA8: 7D595B96  divwu r10, r25, r11
	ctx.r[10].u32 = ctx.r[25].u32 / ctx.r[11].u32;
	// 823AEAAC: 394A001F  addi r10, r10, 0x1f
	ctx.r[10].s64 = ctx.r[10].s64 + 31;
	// 823AEAB0: 555B0034  rlwinm r27, r10, 0, 0, 0x1a
	ctx.r[27].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823AEAB4: 419A0044  beq cr6, 0x823aeaf8
	if ctx.cr[6].eq {
	pc = 0x823AEAF8; continue 'dispatch;
	}
	// 823AEAB8: 395D0010  addi r10, r29, 0x10
	ctx.r[10].s64 = ctx.r[29].s64 + 16;
	// 823AEABC: 92FD0008  stw r23, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 823AEAC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823AEAC4: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823AEAC8: 419A002C  beq cr6, 0x823aeaf4
	if ctx.cr[6].eq {
	pc = 0x823AEAF4; continue 'dispatch;
	}
	// 823AEACC: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	pc = 0x823AEAD0; continue 'dispatch;
            }
            0x823AEAD0 => {
    //   block [0x823AEAD0..0x823AEAF4)
	// 823AEAD0: 7D09DA14  add r8, r9, r27
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[27].u64;
	// 823AEAD4: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823AEAD8: 938A0000  stw r28, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823AEADC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AEAE0: 93CA0008  stw r30, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823AEAE4: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 823AEAE8: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 823AEAEC: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 823AEAF0: 4082FFE0  bne 0x823aead0
	if !ctx.cr[0].eq {
	pc = 0x823AEAD0; continue 'dispatch;
	}
	pc = 0x823AEAF4; continue 'dispatch;
            }
            0x823AEAF4 => {
    //   block [0x823AEAF4..0x823AEAF8)
	// 823AEAF4: 932AFFFC  stw r25, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[25].u32 ) };
	pc = 0x823AEAF8; continue 'dispatch;
            }
            0x823AEAF8 => {
    //   block [0x823AEAF8..0x823AEB88)
	// 823AEAF8: 3FC082BA  lis r30, -0x7d46
	ctx.r[30].s64 = -2101739520;
	// 823AEAFC: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 823AEB00: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 823AEB04: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823AEB08: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823AEB0C: 83FEC474  lwz r31, -0x3b8c(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-15244 as u32) ) } as u64;
	// 823AEB10: 480069D9  bl 0x823b54e8
	ctx.lr = 0x823AEB14;
	sub_823B54E8(ctx, base);
	// 823AEB14: 7D63FA14  add r11, r3, r31
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[31].u64;
	// 823AEB18: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 823AEB1C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823AEB20: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 823AEB24: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 823AEB28: 917EC474  stw r11, -0x3b8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-15244 as u32), ctx.r[11].u32 ) };
	// 823AEB2C: 419A0068  beq cr6, 0x823aeb94
	if ctx.cr[6].eq {
	pc = 0x823AEB94; continue 'dispatch;
	}
	// 823AEB30: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AEB34: 3BEB0700  addi r31, r11, 0x700
	ctx.r[31].s64 = ctx.r[11].s64 + 1792;
	// 823AEB38: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 823AEB3C: 4835E721  bl 0x8270d25c
	ctx.lr = 0x823AEB40;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823AEB40: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AEB44: 4803147D  bl 0x823dffc0
	ctx.lr = 0x823AEB48;
	sub_823DFFC0(ctx, base);
	// 823AEB48: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 823AEB4C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 823AEB50: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 823AEB54: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823AEB58: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823AEB5C: 4802ACE5  bl 0x823d9840
	ctx.lr = 0x823AEB60;
	sub_823D9840(ctx, base);
	// 823AEB60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AEB64: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 823AEB68: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AEB6C: 4082001C  bne 0x823aeb88
	if !ctx.cr[0].eq {
	pc = 0x823AEB88; continue 'dispatch;
	}
	// 823AEB70: 48031491  bl 0x823e0000
	ctx.lr = 0x823AEB74;
	sub_823E0000(ctx, base);
	// 823AEB74: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 823AEB78: 4835E6F5  bl 0x8270d26c
	ctx.lr = 0x823AEB7C;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823AEB7C: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 823AEB80: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 823AEB84: 48000014  b 0x823aeb98
	pc = 0x823AEB98; continue 'dispatch;
            }
            0x823AEB88 => {
    //   block [0x823AEB88..0x823AEB94)
	// 823AEB88: 48031479  bl 0x823e0000
	ctx.lr = 0x823AEB8C;
	sub_823E0000(ctx, base);
	// 823AEB8C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 823AEB90: 4835E6DD  bl 0x8270d26c
	ctx.lr = 0x823AEB94;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x823AEB94; continue 'dispatch;
            }
            0x823AEB94 => {
    //   block [0x823AEB94..0x823AEB98)
	// 823AEB94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823AEB98; continue 'dispatch;
            }
            0x823AEB98 => {
    //   block [0x823AEB98..0x823AEBA0)
	// 823AEB98: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823AEB9C: 48186550  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AEBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AEBA0 size=496
    let mut pc: u32 = 0x823AEBA0;
    'dispatch: loop {
        match pc {
            0x823AEBA0 => {
    //   block [0x823AEBA0..0x823AEC04)
	// 823AEBA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AEBA4: 481864FD  bl 0x825350a0
	ctx.lr = 0x823AEBA8;
	sub_82535080(ctx, base);
	// 823AEBA8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AEBAC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823AEBB0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 823AEBB4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 823AEBB8: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 823AEBBC: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 823AEBC0: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 823AEBC4: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 823AEBC8: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 823AEBCC: 419A0038  beq cr6, 0x823aec04
	if ctx.cr[6].eq {
	pc = 0x823AEC04; continue 'dispatch;
	}
	// 823AEBD0: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823AEBD4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 823AEBD8: 386BF080  addi r3, r11, -0xf80
	ctx.r[3].s64 = ctx.r[11].s64 + -3968;
	// 823AEBDC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823AEBE0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 823AEBE4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 823AEBE8: 4BFEFAA1  bl 0x8239e688
	ctx.lr = 0x823AEBEC;
	sub_8239E688(ctx, base);
	// 823AEBEC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AEBF0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AEBF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AEBF8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 823AEBFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AEC00: 4E800421  bctrl
	ctx.lr = 0x823AEC04;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823AEC04 => {
    //   block [0x823AEC04..0x823AEC1C)
	// 823AEC04: 2F1F0001  cmpwi cr6, r31, 1
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1, &mut ctx.xer);
	// 823AEC08: 419A0014  beq cr6, 0x823aec1c
	if ctx.cr[6].eq {
	pc = 0x823AEC1C; continue 'dispatch;
	}
	// 823AEC0C: 397FFFFE  addi r11, r31, -2
	ctx.r[11].s64 = ctx.r[31].s64 + -2;
	// 823AEC10: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823AEC14: 5576E7BC  rlwinm r22, r11, 0x1c, 0x1e, 0x1e
	ctx.r[22].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823AEC18: 48000008  b 0x823aec20
	pc = 0x823AEC20; continue 'dispatch;
            }
            0x823AEC1C => {
    //   block [0x823AEC1C..0x823AEC20)
	// 823AEC1C: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	pc = 0x823AEC20; continue 'dispatch;
            }
            0x823AEC20 => {
    //   block [0x823AEC20..0x823AEC34)
	// 823AEC20: 570B073F  clrlwi. r11, r24, 0x1c
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AEC24: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 823AEC28: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 823AEC2C: 40820008  bne 0x823aec34
	if !ctx.cr[0].eq {
	pc = 0x823AEC34; continue 'dispatch;
	}
	// 823AEC30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x823AEC34; continue 'dispatch;
            }
            0x823AEC34 => {
    //   block [0x823AEC34..0x823AEC70)
	// 823AEC34: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823AEC38: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823AEC3C: 409900AC  ble cr6, 0x823aece8
	if !ctx.cr[6].gt {
	pc = 0x823AECE8; continue 'dispatch;
	}
	// 823AEC40: 570A06F7  rlwinm. r10, r24, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AEC44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823AEC48: 40820054  bne 0x823aec9c
	if !ctx.cr[0].eq {
	pc = 0x823AEC9C; continue 'dispatch;
	}
	// 823AEC4C: 7D5E5B96  divwu r10, r30, r11
	ctx.r[10].u32 = ctx.r[30].u32 / ctx.r[11].u32;
	// 823AEC50: 394A001F  addi r10, r10, 0x1f
	ctx.r[10].s64 = ctx.r[10].s64 + 31;
	// 823AEC54: 555A0034  rlwinm r26, r10, 0, 0, 0x1a
	ctx.r[26].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823AEC58: 419A0090  beq cr6, 0x823aece8
	if ctx.cr[6].eq {
	pc = 0x823AECE8; continue 'dispatch;
	}
	// 823AEC5C: 395D000C  addi r10, r29, 0xc
	ctx.r[10].s64 = ctx.r[29].s64 + 12;
	// 823AEC60: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823AEC64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823AEC68: 419A002C  beq cr6, 0x823aec94
	if ctx.cr[6].eq {
	pc = 0x823AEC94; continue 'dispatch;
	}
	// 823AEC6C: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	pc = 0x823AEC70; continue 'dispatch;
            }
            0x823AEC70 => {
    //   block [0x823AEC70..0x823AEC94)
	// 823AEC70: 7D09D214  add r8, r9, r26
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[26].u64;
	// 823AEC74: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823AEC78: 938A0004  stw r28, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 823AEC7C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AEC80: 932A000C  stw r25, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 823AEC84: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 823AEC88: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 823AEC8C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 823AEC90: 4082FFE0  bne 0x823aec70
	if !ctx.cr[0].eq {
	pc = 0x823AEC70; continue 'dispatch;
	}
	pc = 0x823AEC94; continue 'dispatch;
            }
            0x823AEC94 => {
    //   block [0x823AEC94..0x823AEC9C)
	// 823AEC94: 93CAFFF8  stw r30, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[30].u32 ) };
	// 823AEC98: 48000050  b 0x823aece8
	pc = 0x823AECE8; continue 'dispatch;
            }
            0x823AEC9C => {
    //   block [0x823AEC9C..0x823AECC0)
	// 823AEC9C: 7D595B96  divwu r10, r25, r11
	ctx.r[10].u32 = ctx.r[25].u32 / ctx.r[11].u32;
	// 823AECA0: 394A001F  addi r10, r10, 0x1f
	ctx.r[10].s64 = ctx.r[10].s64 + 31;
	// 823AECA4: 555B0034  rlwinm r27, r10, 0, 0, 0x1a
	ctx.r[27].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823AECA8: 419A0040  beq cr6, 0x823aece8
	if ctx.cr[6].eq {
	pc = 0x823AECE8; continue 'dispatch;
	}
	// 823AECAC: 395D000C  addi r10, r29, 0xc
	ctx.r[10].s64 = ctx.r[29].s64 + 12;
	// 823AECB0: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823AECB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823AECB8: 419A002C  beq cr6, 0x823aece4
	if ctx.cr[6].eq {
	pc = 0x823AECE4; continue 'dispatch;
	}
	// 823AECBC: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	pc = 0x823AECC0; continue 'dispatch;
            }
            0x823AECC0 => {
    //   block [0x823AECC0..0x823AECE4)
	// 823AECC0: 7D09DA14  add r8, r9, r27
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[27].u64;
	// 823AECC4: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823AECC8: 938A0000  stw r28, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823AECCC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AECD0: 93CA0008  stw r30, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823AECD4: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 823AECD8: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 823AECDC: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 823AECE0: 4082FFE0  bne 0x823aecc0
	if !ctx.cr[0].eq {
	pc = 0x823AECC0; continue 'dispatch;
	}
	pc = 0x823AECE4; continue 'dispatch;
            }
            0x823AECE4 => {
    //   block [0x823AECE4..0x823AECE8)
	// 823AECE4: 932AFFFC  stw r25, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[25].u32 ) };
	pc = 0x823AECE8; continue 'dispatch;
            }
            0x823AECE8 => {
    //   block [0x823AECE8..0x823AED78)
	// 823AECE8: 3FC082BA  lis r30, -0x7d46
	ctx.r[30].s64 = -2101739520;
	// 823AECEC: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 823AECF0: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 823AECF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823AECF8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823AECFC: 83FEC474  lwz r31, -0x3b8c(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-15244 as u32) ) } as u64;
	// 823AED00: 480067E9  bl 0x823b54e8
	ctx.lr = 0x823AED04;
	sub_823B54E8(ctx, base);
	// 823AED04: 7D63FA14  add r11, r3, r31
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[31].u64;
	// 823AED08: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 823AED0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823AED10: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 823AED14: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 823AED18: 917EC474  stw r11, -0x3b8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-15244 as u32), ctx.r[11].u32 ) };
	// 823AED1C: 419A0068  beq cr6, 0x823aed84
	if ctx.cr[6].eq {
	pc = 0x823AED84; continue 'dispatch;
	}
	// 823AED20: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AED24: 3BEB0700  addi r31, r11, 0x700
	ctx.r[31].s64 = ctx.r[11].s64 + 1792;
	// 823AED28: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 823AED2C: 4835E531  bl 0x8270d25c
	ctx.lr = 0x823AED30;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823AED30: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AED34: 4803128D  bl 0x823dffc0
	ctx.lr = 0x823AED38;
	sub_823DFFC0(ctx, base);
	// 823AED38: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 823AED3C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 823AED40: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 823AED44: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823AED48: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823AED4C: 4802AAF5  bl 0x823d9840
	ctx.lr = 0x823AED50;
	sub_823D9840(ctx, base);
	// 823AED50: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AED54: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 823AED58: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AED5C: 4082001C  bne 0x823aed78
	if !ctx.cr[0].eq {
	pc = 0x823AED78; continue 'dispatch;
	}
	// 823AED60: 480312A1  bl 0x823e0000
	ctx.lr = 0x823AED64;
	sub_823E0000(ctx, base);
	// 823AED64: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 823AED68: 4835E505  bl 0x8270d26c
	ctx.lr = 0x823AED6C;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823AED6C: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 823AED70: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 823AED74: 48000014  b 0x823aed88
	pc = 0x823AED88; continue 'dispatch;
            }
            0x823AED78 => {
    //   block [0x823AED78..0x823AED84)
	// 823AED78: 48031289  bl 0x823e0000
	ctx.lr = 0x823AED7C;
	sub_823E0000(ctx, base);
	// 823AED7C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 823AED80: 4835E4ED  bl 0x8270d26c
	ctx.lr = 0x823AED84;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x823AED84; continue 'dispatch;
            }
            0x823AED84 => {
    //   block [0x823AED84..0x823AED88)
	// 823AED84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823AED88; continue 'dispatch;
            }
            0x823AED88 => {
    //   block [0x823AED88..0x823AED90)
	// 823AED88: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823AED8C: 48186364  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AED90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AED90 size=704
    let mut pc: u32 = 0x823AED90;
    'dispatch: loop {
        match pc {
            0x823AED90 => {
    //   block [0x823AED90..0x823AEDB8)
	// 823AED90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AED94: 4818630D  bl 0x825350a0
	ctx.lr = 0x823AED98;
	sub_82535080(ctx, base);
	// 823AED98: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AED9C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AEDA0: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 823AEDA4: 3BAB0EA0  addi r29, r11, 0xea0
	ctx.r[29].s64 = ctx.r[11].s64 + 3744;
	// 823AEDA8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823AEDAC: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 823AEDB0: 3B8BD650  addi r28, r11, -0x29b0
	ctx.r[28].s64 = ctx.r[11].s64 + -10672;
	// 823AEDB4: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	pc = 0x823AEDB8; continue 'dispatch;
            }
            0x823AEDB8 => {
    //   block [0x823AEDB8..0x823AEE08)
	// 823AEDB8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AEDBC: 48028D4D  bl 0x823d7b08
	ctx.lr = 0x823AEDC0;
	sub_823D7B08(ctx, base);
	// 823AEDC0: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823AEDC4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823AEDC8: A15D0000  lhz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AEDCC: 397C0064  addi r11, r28, 0x64
	ctx.r[11].s64 = ctx.r[28].s64 + 100;
	// 823AEDD0: 3BBD0002  addi r29, r29, 2
	ctx.r[29].s64 = ctx.r[29].s64 + 2;
	// 823AEDD4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823AEDD8: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823AEDDC: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 823AEDE0: 4198FFD8  blt cr6, 0x823aedb8
	if ctx.cr[6].lt {
	pc = 0x823AEDB8; continue 'dispatch;
	}
	// 823AEDE4: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823AEDE8: 3BF800CC  addi r31, r24, 0xcc
	ctx.r[31].s64 = ctx.r[24].s64 + 204;
	// 823AEDEC: 3B8BD6B8  addi r28, r11, -0x2948
	ctx.r[28].s64 = ctx.r[11].s64 + -10568;
	// 823AEDF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AEDF4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 823AEDF8: 3B6B1320  addi r27, r11, 0x1320
	ctx.r[27].s64 = ctx.r[11].s64 + 4896;
	// 823AEDFC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AEE00: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823AEE04: 3B4B1300  addi r26, r11, 0x1300
	ctx.r[26].s64 = ctx.r[11].s64 + 4864;
	pc = 0x823AEE08; continue 'dispatch;
            }
            0x823AEE08 => {
    //   block [0x823AEE08..0x823AEE60)
	// 823AEE08: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AEE0C: 48028CFD  bl 0x823d7b08
	ctx.lr = 0x823AEE10;
	sub_823D7B08(ctx, base);
	// 823AEE10: 907FFFFC  stw r3, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[3].u32 ) };
	// 823AEE14: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823AEE18: 7D7DD22E  lhzx r11, r29, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 823AEE1C: 395C0040  addi r10, r28, 0x40
	ctx.r[10].s64 = ctx.r[28].s64 + 64;
	// 823AEE20: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823AEE24: B17F0000  sth r11, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 823AEE28: 7D7DDA2E  lhzx r11, r29, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 823AEE2C: 3BBD0002  addi r29, r29, 2
	ctx.r[29].s64 = ctx.r[29].s64 + 2;
	// 823AEE30: B17F0002  sth r11, 2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[11].u16 ) };
	// 823AEE34: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 823AEE38: 4198FFD0  blt cr6, 0x823aee08
	if ctx.cr[6].lt {
	pc = 0x823AEE08; continue 'dispatch;
	}
	// 823AEE3C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823AEE40: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AEE44: 3AEA1620  addi r23, r10, 0x1620
	ctx.r[23].s64 = ctx.r[10].s64 + 5664;
	// 823AEE48: 3B2B15C0  addi r25, r11, 0x15c0
	ctx.r[25].s64 = ctx.r[11].s64 + 5568;
	// 823AEE4C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823AEE50: 3BF80148  addi r31, r24, 0x148
	ctx.r[31].s64 = ctx.r[24].s64 + 328;
	// 823AEE54: 3B400002  li r26, 2
	ctx.r[26].s64 = 2;
	// 823AEE58: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 823AEE5C: 3ACA1448  addi r22, r10, 0x1448
	ctx.r[22].s64 = ctx.r[10].s64 + 5192;
	pc = 0x823AEE60; continue 'dispatch;
            }
            0x823AEE60 => {
    //   block [0x823AEE60..0x823AEE68)
	// 823AEE60: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 823AEE64: 3B600006  li r27, 6
	ctx.r[27].s64 = 6;
	pc = 0x823AEE68; continue 'dispatch;
            }
            0x823AEE68 => {
    //   block [0x823AEE68..0x823AEE70)
	// 823AEE68: 3BD60002  addi r30, r22, 2
	ctx.r[30].s64 = ctx.r[22].s64 + 2;
	// 823AEE6C: 3B800008  li r28, 8
	ctx.r[28].s64 = 8;
	pc = 0x823AEE70; continue 'dispatch;
            }
            0x823AEE70 => {
    //   block [0x823AEE70..0x823AEE88)
	// 823AEE70: A13E0000  lhz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AEE74: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823AEE78: A0FEFFFE  lhz r7, -2(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(-2 as u32) ) } as u64;
	// 823AEE7C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AEE80: 41820030  beq 0x823aeeb0
	if ctx.cr[0].eq {
	pc = 0x823AEEB0; continue 'dispatch;
	}
	// 823AEE84: 815E0002  lwz r10, 2(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	pc = 0x823AEE88; continue 'dispatch;
            }
            0x823AEE88 => {
    //   block [0x823AEE88..0x823AEEB0)
	// 823AEE88: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AEE8C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823AEE90: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823AEE94: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AEE98: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 823AEE9C: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AEEA0: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 823AEEA4: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 823AEEA8: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 823AEEAC: 4082FFDC  bne 0x823aee88
	if !ctx.cr[0].eq {
	pc = 0x823AEE88; continue 'dispatch;
	}
	pc = 0x823AEEB0; continue 'dispatch;
            }
            0x823AEEB0 => {
    //   block [0x823AEEB0..0x823AEEC0)
	// 823AEEB0: A13DFFFE  lhz r9, -2(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(-2 as u32) ) } as u64;
	// 823AEEB4: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AEEB8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AEEBC: 41820038  beq 0x823aeef4
	if ctx.cr[0].eq {
	pc = 0x823AEEF4; continue 'dispatch;
	}
	pc = 0x823AEEC0; continue 'dispatch;
            }
            0x823AEEC0 => {
    //   block [0x823AEEC0..0x823AEEF4)
	// 823AEEC0: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AEEC4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823AEEC8: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823AEECC: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AEED0: A10B0002  lhz r8, 2(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 823AEED4: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 823AEED8: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 823AEEDC: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AEEE0: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 823AEEE4: B10B0002  sth r8, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 823AEEE8: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 823AEEEC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 823AEEF0: 4082FFD0  bne 0x823aeec0
	if !ctx.cr[0].eq {
	pc = 0x823AEEC0; continue 'dispatch;
	}
	pc = 0x823AEEF4; continue 'dispatch;
            }
            0x823AEEF4 => {
    //   block [0x823AEEF4..0x823AEF5C)
	// 823AEEF4: A15DFFFC  lhz r10, -4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) } as u64;
	// 823AEEF8: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 823AEEFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823AEF00: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 823AEF04: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823AEF08: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AEF0C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AEF10: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AEF14: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AEF18: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 823AEF1C: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 823AEF20: 48028BE9  bl 0x823d7b08
	ctx.lr = 0x823AEF24;
	sub_823D7B08(ctx, base);
	// 823AEF24: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823AEF28: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823AEF2C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 823AEF30: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 823AEF34: 4082FF3C  bne 0x823aee70
	if !ctx.cr[0].eq {
	pc = 0x823AEE70; continue 'dispatch;
	}
	// 823AEF38: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 823AEF3C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 823AEF40: 4082FF28  bne 0x823aee68
	if !ctx.cr[0].eq {
	pc = 0x823AEE68; continue 'dispatch;
	}
	// 823AEF44: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823AEF48: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823AEF4C: 4082FF14  bne 0x823aee60
	if !ctx.cr[0].eq {
	pc = 0x823AEE60; continue 'dispatch;
	}
	// 823AEF50: 3BF8044E  addi r31, r24, 0x44e
	ctx.r[31].s64 = ctx.r[24].s64 + 1102;
	// 823AEF54: 3B400002  li r26, 2
	ctx.r[26].s64 = 2;
	// 823AEF58: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	pc = 0x823AEF5C; continue 'dispatch;
            }
            0x823AEF5C => {
    //   block [0x823AEF5C..0x823AEF64)
	// 823AEF5C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 823AEF60: 3B600006  li r27, 6
	ctx.r[27].s64 = 6;
	pc = 0x823AEF64; continue 'dispatch;
            }
            0x823AEF64 => {
    //   block [0x823AEF64..0x823AEF6C)
	// 823AEF64: 3BD60004  addi r30, r22, 4
	ctx.r[30].s64 = ctx.r[22].s64 + 4;
	// 823AEF68: 3B800008  li r28, 8
	ctx.r[28].s64 = 8;
	pc = 0x823AEF6C; continue 'dispatch;
            }
            0x823AEF6C => {
    //   block [0x823AEF6C..0x823AEF80)
	// 823AEF6C: A13EFFFE  lhz r9, -2(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(-2 as u32) ) } as u64;
	// 823AEF70: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823AEF74: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AEF78: 41820030  beq 0x823aefa8
	if ctx.cr[0].eq {
	pc = 0x823AEFA8; continue 'dispatch;
	}
	// 823AEF7C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x823AEF80; continue 'dispatch;
            }
            0x823AEF80 => {
    //   block [0x823AEF80..0x823AEFA8)
	// 823AEF80: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AEF84: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823AEF88: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823AEF8C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AEF90: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 823AEF94: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AEF98: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 823AEF9C: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 823AEFA0: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 823AEFA4: 4082FFDC  bne 0x823aef80
	if !ctx.cr[0].eq {
	pc = 0x823AEF80; continue 'dispatch;
	}
	pc = 0x823AEFA8; continue 'dispatch;
            }
            0x823AEFA8 => {
    //   block [0x823AEFA8..0x823AEFC0)
	// 823AEFA8: A15EFFFC  lhz r10, -4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) } as u64;
	// 823AEFAC: B15FFFFE  sth r10, -2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(-2 as u32), ctx.r[10].u16 ) };
	// 823AEFB0: A13DFFFE  lhz r9, -2(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(-2 as u32) ) } as u64;
	// 823AEFB4: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AEFB8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AEFBC: 41820034  beq 0x823aeff0
	if ctx.cr[0].eq {
	pc = 0x823AEFF0; continue 'dispatch;
	}
	pc = 0x823AEFC0; continue 'dispatch;
            }
            0x823AEFC0 => {
    //   block [0x823AEFC0..0x823AEFF0)
	// 823AEFC0: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AEFC4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 823AEFC8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823AEFCC: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823AEFD0: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AEFD4: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 823AEFD8: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AEFDC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 823AEFE0: B0EB0000  sth r7, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 823AEFE4: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 823AEFE8: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 823AEFEC: 4082FFD4  bne 0x823aefc0
	if !ctx.cr[0].eq {
	pc = 0x823AEFC0; continue 'dispatch;
	}
	pc = 0x823AEFF0; continue 'dispatch;
            }
            0x823AEFF0 => {
    //   block [0x823AEFF0..0x823AF050)
	// 823AEFF0: A15DFFFC  lhz r10, -4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) } as u64;
	// 823AEFF4: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 823AEFF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823AEFFC: B15F0000  sth r10, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 823AF000: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF004: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AF008: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AF00C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AF010: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 823AF014: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 823AF018: 48028AF1  bl 0x823d7b08
	ctx.lr = 0x823AF01C;
	sub_823D7B08(ctx, base);
	// 823AF01C: 907FFFFA  stw r3, -6(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-6 as u32), ctx.r[3].u32 ) };
	// 823AF020: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823AF024: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 823AF028: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 823AF02C: 4082FF40  bne 0x823aef6c
	if !ctx.cr[0].eq {
	pc = 0x823AEF6C; continue 'dispatch;
	}
	// 823AF030: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 823AF034: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 823AF038: 4082FF2C  bne 0x823aef64
	if !ctx.cr[0].eq {
	pc = 0x823AEF64; continue 'dispatch;
	}
	// 823AF03C: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823AF040: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823AF044: 4082FF18  bne 0x823aef5c
	if !ctx.cr[0].eq {
	pc = 0x823AEF5C; continue 'dispatch;
	}
	// 823AF048: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 823AF04C: 481860A4  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823AF050 size=180
    let mut pc: u32 = 0x823AF050;
    'dispatch: loop {
        match pc {
            0x823AF050 => {
    //   block [0x823AF050..0x823AF0F4)
	// 823AF050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AF054: 48186069  bl 0x825350bc
	ctx.lr = 0x823AF058;
	sub_82535080(ctx, base);
	// 823AF058: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AF05C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AF060: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823AF064: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823AF068: 4835E1F5  bl 0x8270d25c
	ctx.lr = 0x823AF06C;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823AF06C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823AF070: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 823AF074: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AF078: 93BF0034  stw r29, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[29].u32 ) };
	// 823AF07C: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 823AF080: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 823AF084: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 823AF088: 480064D1  bl 0x823b5558
	ctx.lr = 0x823AF08C;
	sub_823B5558(ctx, base);
	// 823AF08C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 823AF090: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AF094: 41820060  beq 0x823af0f4
	if ctx.cr[0].eq {
	pc = 0x823AF0F4; continue 'dispatch;
	}
	// 823AF098: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AF09C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 823AF0A0: 40990054  ble cr6, 0x823af0f4
	if !ctx.cr[6].gt {
	pc = 0x823AF0F4; continue 'dispatch;
	}
	// 823AF0A4: 814B0118  lwz r10, 0x118(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(280 as u32) ) } as u64;
	// 823AF0A8: C00B0100  lfs f0, 0x100(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AF0AC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823AF0B0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 823AF0B4: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 823AF0B8: C00B0104  lfs f0, 0x104(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AF0BC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 823AF0C0: 38CB0010  addi r6, r11, 0x10
	ctx.r[6].s64 = ctx.r[11].s64 + 16;
	// 823AF0C4: 5544DFFE  rlwinm r4, r10, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 823AF0C8: C00B0108  lfs f0, 0x108(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AF0CC: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 823AF0D0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 823AF0D4: C00B010C  lfs f0, 0x10c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AF0D8: 394A0700  addi r10, r10, 0x700
	ctx.r[10].s64 = ctx.r[10].s64 + 1792;
	// 823AF0DC: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 823AF0E0: 812B0114  lwz r9, 0x114(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(276 as u32) ) } as u64;
	// 823AF0E4: C02B0110  lfs f1, 0x110(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823AF0E8: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AF0EC: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AF0F0: 48037C89  bl 0x823e6d78
	ctx.lr = 0x823AF0F4;
	sub_823E6D78(ctx, base);
	pc = 0x823AF0F4; continue 'dispatch;
            }
            0x823AF0F4 => {
    //   block [0x823AF0F4..0x823AF104)
	// 823AF0F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AF0F8: 4835E175  bl 0x8270d26c
	ctx.lr = 0x823AF0FC;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823AF0FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823AF100: 4818600C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823AF108 size=192
    let mut pc: u32 = 0x823AF108;
    'dispatch: loop {
        match pc {
            0x823AF108 => {
    //   block [0x823AF108..0x823AF1B8)
	// 823AF108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AF10C: 48185FB1  bl 0x825350bc
	ctx.lr = 0x823AF110;
	sub_82535080(ctx, base);
	// 823AF110: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AF114: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AF118: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823AF11C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823AF120: 4835E13D  bl 0x8270d25c
	ctx.lr = 0x823AF124;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823AF124: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AF12C: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 823AF130: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AF134: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 823AF138: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AF13C: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 823AF140: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AF144: 93BF0034  stw r29, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[29].u32 ) };
	// 823AF148: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 823AF14C: 4800640D  bl 0x823b5558
	ctx.lr = 0x823AF150;
	sub_823B5558(ctx, base);
	// 823AF150: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 823AF154: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AF158: 41820060  beq 0x823af1b8
	if ctx.cr[0].eq {
	pc = 0x823AF1B8; continue 'dispatch;
	}
	// 823AF15C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AF160: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 823AF164: 40990054  ble cr6, 0x823af1b8
	if !ctx.cr[6].gt {
	pc = 0x823AF1B8; continue 'dispatch;
	}
	// 823AF168: 814B0118  lwz r10, 0x118(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(280 as u32) ) } as u64;
	// 823AF16C: C00B0100  lfs f0, 0x100(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AF170: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823AF174: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 823AF178: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 823AF17C: C00B0104  lfs f0, 0x104(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AF180: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 823AF184: 38CB0010  addi r6, r11, 0x10
	ctx.r[6].s64 = ctx.r[11].s64 + 16;
	// 823AF188: 5544DFFE  rlwinm r4, r10, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 823AF18C: C00B0108  lfs f0, 0x108(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AF190: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 823AF194: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 823AF198: C00B010C  lfs f0, 0x10c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823AF19C: 394A0700  addi r10, r10, 0x700
	ctx.r[10].s64 = ctx.r[10].s64 + 1792;
	// 823AF1A0: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 823AF1A4: 812B0114  lwz r9, 0x114(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(276 as u32) ) } as u64;
	// 823AF1A8: C02B0110  lfs f1, 0x110(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823AF1AC: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AF1B0: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AF1B4: 48037BC5  bl 0x823e6d78
	ctx.lr = 0x823AF1B8;
	sub_823E6D78(ctx, base);
	pc = 0x823AF1B8; continue 'dispatch;
            }
            0x823AF1B8 => {
    //   block [0x823AF1B8..0x823AF1C8)
	// 823AF1B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AF1BC: 4835E0B1  bl 0x8270d26c
	ctx.lr = 0x823AF1C0;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823AF1C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823AF1C4: 48185F48  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AF1C8 size=68
    let mut pc: u32 = 0x823AF1C8;
    'dispatch: loop {
        match pc {
            0x823AF1C8 => {
    //   block [0x823AF1C8..0x823AF1F4)
	// 823AF1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AF1CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AF1D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AF1D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AF1D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AF1DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AF1E0: 396B1638  addi r11, r11, 0x1638
	ctx.r[11].s64 = ctx.r[11].s64 + 5688;
	// 823AF1E4: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AF1E8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AF1EC: 41820008  beq 0x823af1f4
	if ctx.cr[0].eq {
	pc = 0x823AF1F4; continue 'dispatch;
	}
	// 823AF1F0: 481839C9  bl 0x82532bb8
	ctx.lr = 0x823AF1F4;
	sub_82532BB8(ctx, base);
	pc = 0x823AF1F4; continue 'dispatch;
            }
            0x823AF1F4 => {
    //   block [0x823AF1F4..0x823AF20C)
	// 823AF1F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AF1F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823AF1FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AF200: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AF204: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AF208: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AF210 size=16
    let mut pc: u32 = 0x823AF210;
    'dispatch: loop {
        match pc {
            0x823AF210 => {
    //   block [0x823AF210..0x823AF220)
	// 823AF210: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AF214: 396B1638  addi r11, r11, 0x1638
	ctx.r[11].s64 = ctx.r[11].s64 + 5688;
	// 823AF218: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AF21C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AF220 size=128
    let mut pc: u32 = 0x823AF220;
    'dispatch: loop {
        match pc {
            0x823AF220 => {
    //   block [0x823AF220..0x823AF2A0)
	// 823AF220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AF224: 48185E99  bl 0x825350bc
	ctx.lr = 0x823AF228;
	sub_82535080(ctx, base);
	// 823AF228: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AF22C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AF230: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AF234: 3BCB0700  addi r30, r11, 0x700
	ctx.r[30].s64 = ctx.r[11].s64 + 1792;
	// 823AF238: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AF23C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AF240: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AF244: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF248: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 823AF24C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AF250: 4E800421  bctrl
	ctx.lr = 0x823AF254;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823AF254: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 823AF258: 80DF0014  lwz r6, 0x14(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AF25C: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AF260: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AF264: 48003F55  bl 0x823b31b8
	ctx.lr = 0x823AF268;
	sub_823B31B8(ctx, base);
	// 823AF268: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AF26C: 889F001F  lbz r4, 0x1f(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(31 as u32) ) } as u64;
	// 823AF270: 4BFF55E1  bl 0x823a4850
	ctx.lr = 0x823AF274;
	sub_823A4850(ctx, base);
	// 823AF274: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823AF278: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 823AF27C: 80DF0018  lwz r6, 0x18(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AF280: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823AF284: 48198915  bl 0x82547b98
	ctx.lr = 0x823AF288;
	sub_82547B98(ctx, base);
	// 823AF288: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AF28C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AF290: 4BFF55C1  bl 0x823a4850
	ctx.lr = 0x823AF294;
	sub_823A4850(ctx, base);
	// 823AF294: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AF298: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823AF29C: 48185E70  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AF2A0 size=264
    let mut pc: u32 = 0x823AF2A0;
    'dispatch: loop {
        match pc {
            0x823AF2A0 => {
    //   block [0x823AF2A0..0x823AF2D8)
	// 823AF2A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AF2A4: 48185DFD  bl 0x825350a0
	ctx.lr = 0x823AF2A8;
	sub_82535080(ctx, base);
	// 823AF2A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AF2AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823AF2B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AF2B4: 396B16B4  addi r11, r11, 0x16b4
	ctx.r[11].s64 = ctx.r[11].s64 + 5812;
	// 823AF2B8: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 823AF2BC: 3B9F0020  addi r28, r31, 0x20
	ctx.r[28].s64 = ctx.r[31].s64 + 32;
	// 823AF2C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823AF2C4: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 823AF2C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AF2CC: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 823AF2D0: 931F0004  stw r24, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 823AF2D4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x823AF2D8; continue 'dispatch;
            }
            0x823AF2D8 => {
    //   block [0x823AF2D8..0x823AF31C)
	// 823AF2D8: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 823AF2DC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AF2E0: 930B0004  stw r24, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 823AF2E4: 930B011C  stw r24, 0x11c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(284 as u32), ctx.r[24].u32 ) };
	// 823AF2E8: 396B0130  addi r11, r11, 0x130
	ctx.r[11].s64 = ctx.r[11].s64 + 304;
	// 823AF2EC: 4080FFEC  bge 0x823af2d8
	if !ctx.cr[0].lt {
	pc = 0x823AF2D8; continue 'dispatch;
	}
	// 823AF2F0: 3AFF04E0  addi r23, r31, 0x4e0
	ctx.r[23].s64 = ctx.r[31].s64 + 1248;
	// 823AF2F4: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 823AF2F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823AF2FC: 93170000  stw r24, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 823AF300: 93170004  stw r24, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 823AF304: 90FF0610  stw r7, 0x610(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1552 as u32), ctx.r[7].u32 ) };
	// 823AF308: 419A0044  beq cr6, 0x823af34c
	if ctx.cr[6].eq {
	pc = 0x823AF34C; continue 'dispatch;
	}
	// 823AF30C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 823AF310: 3B3F0008  addi r25, r31, 8
	ctx.r[25].s64 = ctx.r[31].s64 + 8;
	// 823AF314: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 823AF318: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x823AF31C; continue 'dispatch;
            }
            0x823AF31C => {
    //   block [0x823AF31C..0x823AF34C)
	// 823AF31C: 38A00130  li r5, 0x130
	ctx.r[5].s64 = 304;
	// 823AF320: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF324: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823AF328: 48185829  bl 0x82534b50
	ctx.lr = 0x823AF32C;
	sub_82534B50(ctx, base);
	// 823AF32C: 93990000  stw r28, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823AF330: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 823AF334: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 823AF338: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 823AF33C: 3B9C0130  addi r28, r28, 0x130
	ctx.r[28].s64 = ctx.r[28].s64 + 304;
	// 823AF340: 4082FFDC  bne 0x823af31c
	if !ctx.cr[0].eq {
	pc = 0x823AF31C; continue 'dispatch;
	}
	// 823AF344: 2B1E0004  cmplwi cr6, r30, 4
	ctx.cr[6].compare_u32(ctx.r[30].u32, 4 as u32, &mut ctx.xer);
	// 823AF348: 40980030  bge cr6, 0x823af378
	if !ctx.cr[6].lt {
	pc = 0x823AF378; continue 'dispatch;
	}
	pc = 0x823AF34C; continue 'dispatch;
            }
            0x823AF34C => {
    //   block [0x823AF34C..0x823AF36C)
	// 823AF34C: 395D0002  addi r10, r29, 2
	ctx.r[10].s64 = ctx.r[29].s64 + 2;
	// 823AF350: 217D0004  subfic r11, r29, 4
	ctx.xer.ca = ctx.r[29].u32 <= 4 as u32;
	ctx.r[11].s64 = (4 as i64) - ctx.r[29].s64;
	// 823AF354: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AF358: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 823AF35C: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 823AF360: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AF364: 41820014  beq 0x823af378
	if ctx.cr[0].eq {
	pc = 0x823AF378; continue 'dispatch;
	}
	// 823AF368: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x823AF36C; continue 'dispatch;
            }
            0x823AF36C => {
    //   block [0x823AF36C..0x823AF378)
	// 823AF36C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823AF370: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823AF374: 4200FFF8  bdnz 0x823af36c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823AF36C; continue 'dispatch;
	}
	pc = 0x823AF378; continue 'dispatch;
            }
            0x823AF378 => {
    //   block [0x823AF378..0x823AF398)
	// 823AF378: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 823AF37C: 419A001C  beq cr6, 0x823af398
	if ctx.cr[6].eq {
	pc = 0x823AF398; continue 'dispatch;
	}
	// 823AF380: 38A00130  li r5, 0x130
	ctx.r[5].s64 = 304;
	// 823AF384: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 823AF388: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 823AF38C: 481857C5  bl 0x82534b50
	ctx.lr = 0x823AF390;
	sub_82534B50(ctx, base);
	// 823AF390: 92FF0018  stw r23, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[23].u32 ) };
	// 823AF394: 48000008  b 0x823af39c
	pc = 0x823AF39C; continue 'dispatch;
            }
            0x823AF398 => {
    //   block [0x823AF398..0x823AF39C)
	// 823AF398: 931F0018  stw r24, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[24].u32 ) };
	pc = 0x823AF39C; continue 'dispatch;
            }
            0x823AF39C => {
    //   block [0x823AF39C..0x823AF3A8)
	// 823AF39C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AF3A0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823AF3A4: 48185D4C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AF3A8 size=180
    let mut pc: u32 = 0x823AF3A8;
    'dispatch: loop {
        match pc {
            0x823AF3A8 => {
    //   block [0x823AF3A8..0x823AF404)
	// 823AF3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AF3AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AF3B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AF3B4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 823AF3B8: 38690020  addi r3, r9, 0x20
	ctx.r[3].s64 = ctx.r[9].s64 + 32;
	// 823AF3BC: 80890610  lwz r4, 0x610(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1552 as u32) ) } as u64;
	// 823AF3C0: 48006951  bl 0x823b5d10
	ctx.lr = 0x823AF3C4;
	sub_823B5D10(ctx, base);
	// 823AF3C4: 81690610  lwz r11, 0x610(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1552 as u32) ) } as u64;
	// 823AF3C8: 7D6858F8  nor r8, r11, r11
	ctx.r[8].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 823AF3CC: 556A073E  clrlwi r10, r11, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823AF3D0: 5508DFFE  rlwinm r8, r8, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 823AF3D4: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 823AF3D8: 910905FC  stw r8, 0x5fc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1532 as u32), ctx.r[8].u32 ) };
	// 823AF3DC: 409A0038  bne cr6, 0x823af414
	if !ctx.cr[6].eq {
	pc = 0x823AF414; continue 'dispatch;
	}
	// 823AF3E0: 556B052E  rlwinm r11, r11, 0, 0x14, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823AF3E4: 2B0B0200  cmplwi cr6, r11, 0x200
	ctx.cr[6].compare_u32(ctx.r[11].u32, 512 as u32, &mut ctx.xer);
	// 823AF3E8: 419A0024  beq cr6, 0x823af40c
	if ctx.cr[6].eq {
	pc = 0x823AF40C; continue 'dispatch;
	}
	// 823AF3EC: 2B0B0300  cmplwi cr6, r11, 0x300
	ctx.cr[6].compare_u32(ctx.r[11].u32, 768 as u32, &mut ctx.xer);
	// 823AF3F0: 419A0014  beq cr6, 0x823af404
	if ctx.cr[6].eq {
	pc = 0x823AF404; continue 'dispatch;
	}
	// 823AF3F4: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 823AF3F8: 409A0034  bne cr6, 0x823af42c
	if !ctx.cr[6].eq {
	pc = 0x823AF42C; continue 'dispatch;
	}
	// 823AF3FC: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 823AF400: 48000030  b 0x823af430
	pc = 0x823AF430; continue 'dispatch;
            }
            0x823AF404 => {
    //   block [0x823AF404..0x823AF40C)
	// 823AF404: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 823AF408: 48000028  b 0x823af430
	pc = 0x823AF430; continue 'dispatch;
            }
            0x823AF40C => {
    //   block [0x823AF40C..0x823AF414)
	// 823AF40C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 823AF410: 48000020  b 0x823af430
	pc = 0x823AF430; continue 'dispatch;
            }
            0x823AF414 => {
    //   block [0x823AF414..0x823AF42C)
	// 823AF414: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 823AF418: 409A0014  bne cr6, 0x823af42c
	if !ctx.cr[6].eq {
	pc = 0x823AF42C; continue 'dispatch;
	}
	// 823AF41C: 556B052E  rlwinm r11, r11, 0, 0x14, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823AF420: 2B0B0200  cmplwi cr6, r11, 0x200
	ctx.cr[6].compare_u32(ctx.r[11].u32, 512 as u32, &mut ctx.xer);
	// 823AF424: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 823AF428: 419A0008  beq cr6, 0x823af430
	if ctx.cr[6].eq {
	pc = 0x823AF430; continue 'dispatch;
	}
	pc = 0x823AF42C; continue 'dispatch;
            }
            0x823AF42C => {
    //   block [0x823AF42C..0x823AF430)
	// 823AF42C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	pc = 0x823AF430; continue 'dispatch;
            }
            0x823AF430 => {
    //   block [0x823AF430..0x823AF45C)
	// 823AF430: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 823AF434: 91690600  stw r11, 0x600(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1536 as u32), ctx.r[11].u32 ) };
	// 823AF438: 38890008  addi r4, r9, 8
	ctx.r[4].s64 = ctx.r[9].s64 + 8;
	// 823AF43C: 80A90018  lwz r5, 0x18(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AF440: 386A0200  addi r3, r10, 0x200
	ctx.r[3].s64 = ctx.r[10].s64 + 512;
	// 823AF444: 4BFFFCC5  bl 0x823af108
	ctx.lr = 0x823AF448;
	sub_823AF108(ctx, base);
	// 823AF448: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AF44C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823AF450: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AF454: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AF458: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AF460 size=116
    let mut pc: u32 = 0x823AF460;
    'dispatch: loop {
        match pc {
            0x823AF460 => {
    //   block [0x823AF460..0x823AF498)
	// 823AF460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AF464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AF468: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AF46C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AF470: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AF474: 3BEB0200  addi r31, r11, 0x200
	ctx.r[31].s64 = ctx.r[11].s64 + 512;
	// 823AF478: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AF47C: 4800616D  bl 0x823b55e8
	ctx.lr = 0x823AF480;
	sub_823B55E8(ctx, base);
	// 823AF480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AF484: 4835DDD9  bl 0x8270d25c
	ctx.lr = 0x823AF488;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823AF488: 395F0024  addi r10, r31, 0x24
	ctx.r[10].s64 = ctx.r[31].s64 + 36;
	// 823AF48C: 397F0038  addi r11, r31, 0x38
	ctx.r[11].s64 = ctx.r[31].s64 + 56;
	// 823AF490: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 823AF494: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x823AF498; continue 'dispatch;
            }
            0x823AF498 => {
    //   block [0x823AF498..0x823AF4D4)
	// 823AF498: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF49C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823AF4A0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823AF4A4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823AF4A8: 4200FFF0  bdnz 0x823af498
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823AF498; continue 'dispatch;
	}
	// 823AF4AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AF4B0: 480060A9  bl 0x823b5558
	ctx.lr = 0x823AF4B4;
	sub_823B5558(ctx, base);
	// 823AF4B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AF4B8: 4835DDB5  bl 0x8270d26c
	ctx.lr = 0x823AF4BC;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823AF4BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AF4C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823AF4C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AF4C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AF4CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AF4D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AF4D8 size=180
    let mut pc: u32 = 0x823AF4D8;
    'dispatch: loop {
        match pc {
            0x823AF4D8 => {
    //   block [0x823AF4D8..0x823AF534)
	// 823AF4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AF4DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AF4E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AF4E4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 823AF4E8: 38690010  addi r3, r9, 0x10
	ctx.r[3].s64 = ctx.r[9].s64 + 16;
	// 823AF4EC: 80890270  lwz r4, 0x270(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(624 as u32) ) } as u64;
	// 823AF4F0: 48006821  bl 0x823b5d10
	ctx.lr = 0x823AF4F4;
	sub_823B5D10(ctx, base);
	// 823AF4F4: 81690270  lwz r11, 0x270(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(624 as u32) ) } as u64;
	// 823AF4F8: 7D6858F8  nor r8, r11, r11
	ctx.r[8].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 823AF4FC: 556A073E  clrlwi r10, r11, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823AF500: 5508DFFE  rlwinm r8, r8, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 823AF504: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 823AF508: 9109025C  stw r8, 0x25c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(604 as u32), ctx.r[8].u32 ) };
	// 823AF50C: 409A0038  bne cr6, 0x823af544
	if !ctx.cr[6].eq {
	pc = 0x823AF544; continue 'dispatch;
	}
	// 823AF510: 556B052E  rlwinm r11, r11, 0, 0x14, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823AF514: 2B0B0200  cmplwi cr6, r11, 0x200
	ctx.cr[6].compare_u32(ctx.r[11].u32, 512 as u32, &mut ctx.xer);
	// 823AF518: 419A0024  beq cr6, 0x823af53c
	if ctx.cr[6].eq {
	pc = 0x823AF53C; continue 'dispatch;
	}
	// 823AF51C: 2B0B0300  cmplwi cr6, r11, 0x300
	ctx.cr[6].compare_u32(ctx.r[11].u32, 768 as u32, &mut ctx.xer);
	// 823AF520: 419A0014  beq cr6, 0x823af534
	if ctx.cr[6].eq {
	pc = 0x823AF534; continue 'dispatch;
	}
	// 823AF524: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 823AF528: 409A0034  bne cr6, 0x823af55c
	if !ctx.cr[6].eq {
	pc = 0x823AF55C; continue 'dispatch;
	}
	// 823AF52C: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 823AF530: 48000030  b 0x823af560
	pc = 0x823AF560; continue 'dispatch;
            }
            0x823AF534 => {
    //   block [0x823AF534..0x823AF53C)
	// 823AF534: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 823AF538: 48000028  b 0x823af560
	pc = 0x823AF560; continue 'dispatch;
            }
            0x823AF53C => {
    //   block [0x823AF53C..0x823AF544)
	// 823AF53C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 823AF540: 48000020  b 0x823af560
	pc = 0x823AF560; continue 'dispatch;
            }
            0x823AF544 => {
    //   block [0x823AF544..0x823AF55C)
	// 823AF544: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 823AF548: 409A0014  bne cr6, 0x823af55c
	if !ctx.cr[6].eq {
	pc = 0x823AF55C; continue 'dispatch;
	}
	// 823AF54C: 556B052E  rlwinm r11, r11, 0, 0x14, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823AF550: 2B0B0200  cmplwi cr6, r11, 0x200
	ctx.cr[6].compare_u32(ctx.r[11].u32, 512 as u32, &mut ctx.xer);
	// 823AF554: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 823AF558: 419A0008  beq cr6, 0x823af560
	if ctx.cr[6].eq {
	pc = 0x823AF560; continue 'dispatch;
	}
	pc = 0x823AF55C; continue 'dispatch;
            }
            0x823AF55C => {
    //   block [0x823AF55C..0x823AF560)
	// 823AF55C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	pc = 0x823AF560; continue 'dispatch;
            }
            0x823AF560 => {
    //   block [0x823AF560..0x823AF58C)
	// 823AF560: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 823AF564: 91690260  stw r11, 0x260(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(608 as u32), ctx.r[11].u32 ) };
	// 823AF568: 80A9000C  lwz r5, 0xc(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AF56C: 386A0200  addi r3, r10, 0x200
	ctx.r[3].s64 = ctx.r[10].s64 + 512;
	// 823AF570: 80890008  lwz r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AF574: 4BFFFADD  bl 0x823af050
	ctx.lr = 0x823AF578;
	sub_823AF050(ctx, base);
	// 823AF578: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AF57C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823AF580: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AF584: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AF588: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AF590 size=224
    let mut pc: u32 = 0x823AF590;
    'dispatch: loop {
        match pc {
            0x823AF590 => {
    //   block [0x823AF590..0x823AF5C8)
	// 823AF590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AF594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AF598: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823AF59C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AF5A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AF5A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823AF5A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823AF5AC: 4835DCB1  bl 0x8270d25c
	ctx.lr = 0x823AF5B0;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823AF5B0: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 823AF5B4: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 823AF5B8: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 823AF5BC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823AF5C0: 409A002C  bne cr6, 0x823af5ec
	if !ctx.cr[6].eq {
	pc = 0x823AF5EC; continue 'dispatch;
	}
	// 823AF5C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x823AF5C8; continue 'dispatch;
            }
            0x823AF5C8 => {
    //   block [0x823AF5C8..0x823AF5EC)
	// 823AF5C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AF5CC: 4835DCA1  bl 0x8270d26c
	ctx.lr = 0x823AF5D0;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823AF5D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AF5D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823AF5D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AF5DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AF5E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823AF5E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AF5E8: 4E800020  blr
	return;
            }
            0x823AF5EC => {
    //   block [0x823AF5EC..0x823AF638)
	// 823AF5EC: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AF5F0: 394B0018  addi r10, r11, 0x18
	ctx.r[10].s64 = ctx.r[11].s64 + 24;
	// 823AF5F4: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF5F8: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF5FC: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 823AF600: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AF604: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF608: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AF60C: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AF610: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 823AF614: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 823AF618: 93E90008  stw r31, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 823AF61C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AF620: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AF624: 409A0014  bne cr6, 0x823af638
	if !ctx.cr[6].eq {
	pc = 0x823AF638; continue 'dispatch;
	}
	// 823AF628: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AF62C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823AF630: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823AF634: 4800001C  b 0x823af650
	pc = 0x823AF650; continue 'dispatch;
            }
            0x823AF638 => {
    //   block [0x823AF638..0x823AF650)
	// 823AF638: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AF63C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF640: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823AF644: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AF648: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF64C: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x823AF650; continue 'dispatch;
            }
            0x823AF650 => {
    //   block [0x823AF650..0x823AF670)
	// 823AF650: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AF654: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 823AF658: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AF65C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823AF660: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AF664: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823AF668: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823AF66C: 4BFFFF5C  b 0x823af5c8
	pc = 0x823AF5C8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AF670 size=144
    let mut pc: u32 = 0x823AF670;
    'dispatch: loop {
        match pc {
            0x823AF670 => {
    //   block [0x823AF670..0x823AF6A0)
	// 823AF670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AF674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823AF678: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823AF67C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823AF680: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AF684: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AF688: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823AF68C: 4835DBD1  bl 0x8270d25c
	ctx.lr = 0x823AF690;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823AF690: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 823AF694: 391F0038  addi r8, r31, 0x38
	ctx.r[8].s64 = ctx.r[31].s64 + 56;
	// 823AF698: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF69C: 4800002C  b 0x823af6c8
	pc = 0x823AF6C8; continue 'dispatch;
            }
            0x823AF6A0 => {
    //   block [0x823AF6A0..0x823AF6A8)
	// 823AF6A0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AF6A4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x823AF6A8; continue 'dispatch;
            }
            0x823AF6A8 => {
    //   block [0x823AF6A8..0x823AF6C8)
	// 823AF6A8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF6AC: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 823AF6B0: 419A0028  beq cr6, 0x823af6d8
	if ctx.cr[6].eq {
	pc = 0x823AF6D8; continue 'dispatch;
	}
	// 823AF6B4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823AF6B8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823AF6BC: 2F090007  cmpwi cr6, r9, 7
	ctx.cr[6].compare_i32(ctx.r[9].s32, 7, &mut ctx.xer);
	// 823AF6C0: 4198FFE8  blt cr6, 0x823af6a8
	if ctx.cr[6].lt {
	pc = 0x823AF6A8; continue 'dispatch;
	}
	// 823AF6C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823AF6C8; continue 'dispatch;
            }
            0x823AF6C8 => {
    //   block [0x823AF6C8..0x823AF6D8)
	// 823AF6C8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823AF6CC: 409AFFD4  bne cr6, 0x823af6a0
	if !ctx.cr[6].eq {
	pc = 0x823AF6A0; continue 'dispatch;
	}
	// 823AF6D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823AF6D4: 48000008  b 0x823af6dc
	pc = 0x823AF6DC; continue 'dispatch;
            }
            0x823AF6D8 => {
    //   block [0x823AF6D8..0x823AF6DC)
	// 823AF6D8: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x823AF6DC; continue 'dispatch;
            }
            0x823AF6DC => {
    //   block [0x823AF6DC..0x823AF700)
	// 823AF6DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823AF6E0: 4835DB8D  bl 0x8270d26c
	ctx.lr = 0x823AF6E4;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823AF6E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AF6E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823AF6EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823AF6F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823AF6F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823AF6F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823AF6FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AF700 size=156
    let mut pc: u32 = 0x823AF700;
    'dispatch: loop {
        match pc {
            0x823AF700 => {
    //   block [0x823AF700..0x823AF714)
	// 823AF700: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 823AF704: 39230034  addi r9, r3, 0x34
	ctx.r[9].s64 = ctx.r[3].s64 + 52;
	// 823AF708: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823AF70C: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 823AF710: 3969000C  addi r11, r9, 0xc
	ctx.r[11].s64 = ctx.r[9].s64 + 12;
	pc = 0x823AF714; continue 'dispatch;
            }
            0x823AF714 => {
    //   block [0x823AF714..0x823AF79C)
	// 823AF714: 390BFFE8  addi r8, r11, -0x18
	ctx.r[8].s64 = ctx.r[11].s64 + -24;
	// 823AF718: 916BFFF8  stw r11, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 823AF71C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823AF720: 910BFFF4  stw r8, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[8].u32 ) };
	// 823AF724: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 823AF728: 81030030  lwz r8, 0x30(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 823AF72C: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 823AF730: 4198FFE4  blt cr6, 0x823af714
	if ctx.cr[6].lt {
	pc = 0x823AF714; continue 'dispatch;
	}
	// 823AF734: 39630018  addi r11, r3, 0x18
	ctx.r[11].s64 = ctx.r[3].s64 + 24;
	// 823AF738: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823AF73C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AF740: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 823AF744: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AF748: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AF74C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AF750: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 823AF754: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AF758: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823AF75C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823AF760: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AF764: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF768: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823AF76C: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AF770: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AF774: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AF778: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823AF77C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF780: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823AF784: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 823AF788: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AF78C: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AF790: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF794: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 823AF798: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AF7A0 size=220
    let mut pc: u32 = 0x823AF7A0;
    'dispatch: loop {
        match pc {
            0x823AF7A0 => {
    //   block [0x823AF7A0..0x823AF7DC)
	// 823AF7A0: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF7A4: 39640018  addi r11, r4, 0x18
	ctx.r[11].s64 = ctx.r[4].s64 + 24;
	// 823AF7A8: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AF7AC: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AF7B0: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823AF7B4: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF7B8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823AF7BC: 409A0020  bne cr6, 0x823af7dc
	if !ctx.cr[6].eq {
	pc = 0x823AF7DC; continue 'dispatch;
	}
	// 823AF7C0: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823AF7C4: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AF7C8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823AF7CC: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AF7D0: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF7D4: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823AF7D8: 48000048  b 0x823af820
	pc = 0x823AF820; continue 'dispatch;
            }
            0x823AF7DC => {
    //   block [0x823AF7DC..0x823AF808)
	// 823AF7DC: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AF7E0: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF7E4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823AF7E8: 409A0020  bne cr6, 0x823af808
	if !ctx.cr[6].eq {
	pc = 0x823AF808; continue 'dispatch;
	}
	// 823AF7EC: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823AF7F0: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF7F4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823AF7F8: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AF7FC: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF800: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AF804: 4800001C  b 0x823af820
	pc = 0x823AF820; continue 'dispatch;
            }
            0x823AF808 => {
    //   block [0x823AF808..0x823AF820)
	// 823AF808: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF80C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AF810: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 823AF814: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AF818: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF81C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x823AF820; continue 'dispatch;
            }
            0x823AF820 => {
    //   block [0x823AF820..0x823AF848)
	// 823AF820: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AF824: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823AF828: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 823AF82C: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AF830: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AF834: 409A0014  bne cr6, 0x823af848
	if !ctx.cr[6].eq {
	pc = 0x823AF848; continue 'dispatch;
	}
	// 823AF838: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 823AF83C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AF840: 908A0000  stw r4, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 823AF844: 4800001C  b 0x823af860
	pc = 0x823AF860; continue 'dispatch;
            }
            0x823AF848 => {
    //   block [0x823AF848..0x823AF860)
	// 823AF848: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AF84C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF850: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823AF854: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AF858: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AF85C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823AF860; continue 'dispatch;
            }
            0x823AF860 => {
    //   block [0x823AF860..0x823AF87C)
	// 823AF860: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 823AF864: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 823AF868: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AF86C: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 823AF870: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823AF874: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823AF878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AF880 size=40
    let mut pc: u32 = 0x823AF880;
    'dispatch: loop {
        match pc {
            0x823AF880 => {
    //   block [0x823AF880..0x823AF8A8)
	// 823AF880: 3D80820C  lis r12, -0x7df4
	ctx.r[12].s64 = -2113142784;
	// 823AF884: 398CDA80  addi r12, r12, -0x2580
	ctx.r[12].s64 = ctx.r[12].s64 + -9600;
	// 823AF888: 7C0C18AE  lbzx r0, r12, r3
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823AF88C: 3D80823B  lis r12, -0x7dc5
	ctx.r[12].s64 = -2110062592;
	// 823AF890: 398CF8A8  addi r12, r12, -0x758
	ctx.r[12].s64 = ctx.r[12].s64 + -1880;
	// 823AF894: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 823AF898: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 823AF89C: 60000000  nop
	// 823AF8A0: 60000000  nop
	// 823AF8A4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF8A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AF8A8 size=12
    let mut pc: u32 = 0x823AF8A8;
    'dispatch: loop {
        match pc {
            0x823AF8A8 => {
    //   block [0x823AF8A8..0x823AF8B4)
	// 823AF8A8: 3C601828  lis r3, 0x1828
	ctx.r[3].s64 = 405274624;
	// 823AF8AC: 60630186  ori r3, r3, 0x186
	ctx.r[3].u64 = ctx.r[3].u64 | 390;
	// 823AF8B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF8B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AF8B4 size=8
    let mut pc: u32 = 0x823AF8B4;
    'dispatch: loop {
        match pc {
            0x823AF8B4 => {
    //   block [0x823AF8B4..0x823AF8BC)
	// 823AF8B4: 3C602828  lis r3, 0x2828
	ctx.r[3].s64 = 673710080;
	// 823AF8B8: 4BFFFFF4  b 0x823af8ac
	sub_823AF8A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF8BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AF8BC size=12
    let mut pc: u32 = 0x823AF8BC;
    'dispatch: loop {
        match pc {
            0x823AF8BC => {
    //   block [0x823AF8BC..0x823AF8C8)
	// 823AF8BC: 3C601A22  lis r3, 0x1a22
	ctx.r[3].s64 = 438435840;
	// 823AF8C0: 6063AB5D  ori r3, r3, 0xab5d
	ctx.r[3].u64 = ctx.r[3].u64 | 43869;
	// 823AF8C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AF8C8 size=12
    let mut pc: u32 = 0x823AF8C8;
    'dispatch: loop {
        match pc {
            0x823AF8C8 => {
    //   block [0x823AF8C8..0x823AF8D4)
	// 823AF8C8: 3C602DA2  lis r3, 0x2da2
	ctx.r[3].s64 = 765591552;
	// 823AF8CC: 6063ABA4  ori r3, r3, 0xaba4
	ctx.r[3].u64 = ctx.r[3].u64 | 43940;
	// 823AF8D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF8D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AF8D4 size=12
    let mut pc: u32 = 0x823AF8D4;
    'dispatch: loop {
        match pc {
            0x823AF8D4 => {
    //   block [0x823AF8D4..0x823AF8E0)
	// 823AF8D4: 3C602D22  lis r3, 0x2d22
	ctx.r[3].s64 = 757202944;
	// 823AF8D8: 6063ABA5  ori r3, r3, 0xaba5
	ctx.r[3].u64 = ctx.r[3].u64 | 43941;
	// 823AF8DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AF8E0 size=12
    let mut pc: u32 = 0x823AF8E0;
    'dispatch: loop {
        match pc {
            0x823AF8E0 => {
    //   block [0x823AF8E0..0x823AF8EC)
	// 823AF8E0: 3C602D22  lis r3, 0x2d22
	ctx.r[3].s64 = 757202944;
	// 823AF8E4: 6063AB9C  ori r3, r3, 0xab9c
	ctx.r[3].u64 = ctx.r[3].u64 | 43932;
	// 823AF8E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF8EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AF8EC size=12
    let mut pc: u32 = 0x823AF8EC;
    'dispatch: loop {
        match pc {
            0x823AF8EC => {
    //   block [0x823AF8EC..0x823AF8F8)
	// 823AF8EC: 3C602828  lis r3, 0x2828
	ctx.r[3].s64 = 673710080;
	// 823AF8F0: 60630144  ori r3, r3, 0x144
	ctx.r[3].u64 = ctx.r[3].u64 | 324;
	// 823AF8F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AF8F8 size=12
    let mut pc: u32 = 0x823AF8F8;
    'dispatch: loop {
        match pc {
            0x823AF8F8 => {
    //   block [0x823AF8F8..0x823AF904)
	// 823AF8F8: 3C601828  lis r3, 0x1828
	ctx.r[3].s64 = 405274624;
	// 823AF8FC: 60630143  ori r3, r3, 0x143
	ctx.r[3].u64 = ctx.r[3].u64 | 323;
	// 823AF900: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF904(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823AF904 size=8
    let mut pc: u32 = 0x823AF904;
    'dispatch: loop {
        match pc {
            0x823AF904 => {
    //   block [0x823AF904..0x823AF90C)
	// 823AF904: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AF908: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AF910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AF910 size=508
    let mut pc: u32 = 0x823AF910;
    'dispatch: loop {
        match pc {
            0x823AF910 => {
    //   block [0x823AF910..0x823AF994)
	// 823AF910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AF914: 48185779  bl 0x8253508c
	ctx.lr = 0x823AF918;
	sub_82535080(ctx, base);
	// 823AF918: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AF91C: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 823AF920: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823AF924: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 823AF928: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 823AF92C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 823AF930: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 823AF934: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 823AF938: 92DF0000  stw r22, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 823AF93C: 54F9043F  clrlwi. r25, r7, 0x10
	ctx.r[25].u64 = ctx.r[7].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 823AF940: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823AF944: 7ED3B378  mr r19, r22
	ctx.r[19].u64 = ctx.r[22].u64;
	// 823AF948: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823AF94C: 7E579378  mr r23, r18
	ctx.r[23].u64 = ctx.r[18].u64;
	// 823AF950: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823AF954: 3A200001  li r17, 1
	ctx.r[17].s64 = 1;
	// 823AF958: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 823AF95C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 823AF960: 939F0020  stw r28, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[28].u32 ) };
	// 823AF964: 937F0024  stw r27, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[27].u32 ) };
	// 823AF968: 41820030  beq 0x823af998
	if ctx.cr[0].eq {
	pc = 0x823AF998; continue 'dispatch;
	}
	// 823AF96C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AF970: 3879FFFF  addi r3, r25, -1
	ctx.r[3].s64 = ctx.r[25].s64 + -1;
	// 823AF974: 7F53D378  mr r19, r26
	ctx.r[19].u64 = ctx.r[26].u64;
	// 823AF978: 522BE804  rlwimi r11, r17, 0x1d, 0, 2
	ctx.r[11].u64 = (((ctx.r[17].u32).rotate_left(29) as u64) & 0x00000000E0000000) | (ctx.r[11].u64 & 0xFFFFFFFF1FFFFFFF);
	// 823AF97C: 2B030007  cmplwi cr6, r3, 7
	ctx.cr[6].compare_u32(ctx.r[3].u32, 7 as u32, &mut ctx.xer);
	// 823AF980: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 823AF984: 41990010  bgt cr6, 0x823af994
	if ctx.cr[6].gt {
	pc = 0x823AF994; continue 'dispatch;
	}
	// 823AF988: 4BFFFEF9  bl 0x823af880
	ctx.lr = 0x823AF98C;
	sub_823AF880(ctx, base);
	// 823AF98C: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 823AF990: 48000008  b 0x823af998
	pc = 0x823AF998; continue 'dispatch;
            }
            0x823AF994 => {
    //   block [0x823AF994..0x823AF998)
	// 823AF994: 7E579378  mr r23, r18
	ctx.r[23].u64 = ctx.r[18].u64;
	pc = 0x823AF998; continue 'dispatch;
            }
            0x823AF998 => {
    //   block [0x823AF998..0x823AF9D8)
	// 823AF998: 54F4001F  rlwinm. r20, r7, 0, 0, 0xf
	ctx.r[20].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 823AF99C: 7E559378  mr r21, r18
	ctx.r[21].u64 = ctx.r[18].u64;
	// 823AF9A0: 41820054  beq 0x823af9f4
	if ctx.cr[0].eq {
	pc = 0x823AF9F4; continue 'dispatch;
	}
	// 823AF9A4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AF9A8: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 823AF9AC: 656B1000  oris r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 268435456;
	// 823AF9B0: 7F145040  cmplw cr6, r20, r10
	ctx.cr[6].compare_u32(ctx.r[20].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823AF9B4: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 823AF9B8: 419A0034  beq cr6, 0x823af9ec
	if ctx.cr[6].eq {
	pc = 0x823AF9EC; continue 'dispatch;
	}
	// 823AF9BC: 3D600002  lis r11, 2
	ctx.r[11].s64 = 131072;
	// 823AF9C0: 7F145840  cmplw cr6, r20, r11
	ctx.cr[6].compare_u32(ctx.r[20].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AF9C4: 419A0020  beq cr6, 0x823af9e4
	if ctx.cr[6].eq {
	pc = 0x823AF9E4; continue 'dispatch;
	}
	// 823AF9C8: 3D600004  lis r11, 4
	ctx.r[11].s64 = 262144;
	// 823AF9CC: 7F145840  cmplw cr6, r20, r11
	ctx.cr[6].compare_u32(ctx.r[20].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AF9D0: 419A0008  beq cr6, 0x823af9d8
	if ctx.cr[6].eq {
	pc = 0x823AF9D8; continue 'dispatch;
	}
	// 823AF9D4: 48000020  b 0x823af9f4
	pc = 0x823AF9F4; continue 'dispatch;
            }
            0x823AF9D8 => {
    //   block [0x823AF9D8..0x823AF9E4)
	// 823AF9D8: 3EA01A22  lis r21, 0x1a22
	ctx.r[21].s64 = 438435840;
	// 823AF9DC: 62B50158  ori r21, r21, 0x158
	ctx.r[21].u64 = ctx.r[21].u64 | 344;
	// 823AF9E0: 48000014  b 0x823af9f4
	pc = 0x823AF9F4; continue 'dispatch;
            }
            0x823AF9E4 => {
    //   block [0x823AF9E4..0x823AF9EC)
	// 823AF9E4: 3EA02DA0  lis r21, 0x2da0
	ctx.r[21].s64 = 765460480;
	// 823AF9E8: 48000008  b 0x823af9f0
	pc = 0x823AF9F0; continue 'dispatch;
            }
            0x823AF9EC => {
    //   block [0x823AF9EC..0x823AF9F0)
	// 823AF9EC: 3EA02D20  lis r21, 0x2d20
	ctx.r[21].s64 = 757071872;
	pc = 0x823AF9F0; continue 'dispatch;
            }
            0x823AF9F0 => {
    //   block [0x823AF9F0..0x823AF9F4)
	// 823AF9F0: 62B50196  ori r21, r21, 0x196
	ctx.r[21].u64 = ctx.r[21].u64 | 406;
	pc = 0x823AF9F4; continue 'dispatch;
            }
            0x823AF9F4 => {
    //   block [0x823AF9F4..0x823AFA04)
	// 823AF9F4: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AF9F8: 7E3D8B78  mr r29, r17
	ctx.r[29].u64 = ctx.r[17].u64;
	// 823AF9FC: 3BCB0F00  addi r30, r11, 0xf00
	ctx.r[30].s64 = ctx.r[11].s64 + 3840;
	// 823AFA00: 3F0082BA  lis r24, -0x7d46
	ctx.r[24].s64 = -2101739520;
	pc = 0x823AFA04; continue 'dispatch;
            }
            0x823AFA04 => {
    //   block [0x823AFA04..0x823AFA34)
	// 823AFA04: 9258C474  stw r18, -0x3b8c(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(-15244 as u32), ctx.r[18].u32 ) };
	// 823AFA08: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 823AFA0C: 419A0028  beq cr6, 0x823afa34
	if ctx.cr[6].eq {
	pc = 0x823AFA34; continue 'dispatch;
	}
	// 823AFA10: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 823AFA14: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823AFA18: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 823AFA1C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823AFA20: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 823AFA24: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 823AFA28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AFA2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AFA30: 4BFFEF21  bl 0x823ae950
	ctx.lr = 0x823AFA34;
	sub_823AE950(ctx, base);
	pc = 0x823AFA34; continue 'dispatch;
            }
            0x823AFA34 => {
    //   block [0x823AFA34..0x823AFA60)
	// 823AFA34: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 823AFA38: 419A0028  beq cr6, 0x823afa60
	if ctx.cr[6].eq {
	pc = 0x823AFA60; continue 'dispatch;
	}
	// 823AFA3C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 823AFA40: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823AFA44: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 823AFA48: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823AFA4C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 823AFA50: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 823AFA54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AFA58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AFA5C: 4BFFF145  bl 0x823aeba0
	ctx.lr = 0x823AFA60;
	sub_823AEBA0(ctx, base);
	pc = 0x823AFA60; continue 'dispatch;
            }
            0x823AFA60 => {
    //   block [0x823AFA60..0x823AFA74)
	// 823AFA60: 8178C474  lwz r11, -0x3b8c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-15244 as u32) ) } as u64;
	// 823AFA64: 2B0B0800  cmplwi cr6, r11, 0x800
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2048 as u32, &mut ctx.xer);
	// 823AFA68: 4099000C  ble cr6, 0x823afa74
	if !ctx.cr[6].gt {
	pc = 0x823AFA74; continue 'dispatch;
	}
	// 823AFA6C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823AFA70: 4BFFFF94  b 0x823afa04
	pc = 0x823AFA04; continue 'dispatch;
            }
            0x823AFA74 => {
    //   block [0x823AFA74..0x823AFAB0)
	// 823AFA74: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 823AFA78: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 823AFA7C: 9178C474  stw r11, -0x3b8c(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(-15244 as u32), ctx.r[11].u32 ) };
	// 823AFA80: 419A0040  beq cr6, 0x823afac0
	if ctx.cr[6].eq {
	pc = 0x823AFAC0; continue 'dispatch;
	}
	// 823AFA84: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 823AFA88: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823AFA8C: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 823AFA90: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823AFA94: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 823AFA98: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 823AFA9C: 389F0030  addi r4, r31, 0x30
	ctx.r[4].s64 = ctx.r[31].s64 + 48;
	// 823AFAA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AFAA4: 4BFFEEAD  bl 0x823ae950
	ctx.lr = 0x823AFAA8;
	sub_823AE950(ctx, base);
	// 823AFAA8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823AFAAC: 4182000C  beq 0x823afab8
	if ctx.cr[0].eq {
	pc = 0x823AFAB8; continue 'dispatch;
	}
	pc = 0x823AFAB0; continue 'dispatch;
            }
            0x823AFAB0 => {
    //   block [0x823AFAB0..0x823AFAB8)
	// 823AFAB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AFAB4: 48000050  b 0x823afb04
	pc = 0x823AFB04; continue 'dispatch;
            }
            0x823AFAB8 => {
    //   block [0x823AFAB8..0x823AFAC0)
	// 823AFAB8: 923F0154  stw r17, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[17].u32 ) };
	// 823AFABC: 925F0158  stw r18, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[18].u32 ) };
	pc = 0x823AFAC0; continue 'dispatch;
            }
            0x823AFAC0 => {
    //   block [0x823AFAC0..0x823AFB00)
	// 823AFAC0: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 823AFAC4: 419A003C  beq cr6, 0x823afb00
	if ctx.cr[6].eq {
	pc = 0x823AFB00; continue 'dispatch;
	}
	// 823AFAC8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 823AFACC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823AFAD0: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 823AFAD4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823AFAD8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 823AFADC: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 823AFAE0: 389F0750  addi r4, r31, 0x750
	ctx.r[4].s64 = ctx.r[31].s64 + 1872;
	// 823AFAE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823AFAE8: 4BFFF0B9  bl 0x823aeba0
	ctx.lr = 0x823AFAEC;
	sub_823AEBA0(ctx, base);
	// 823AFAEC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823AFAF0: 4082FFC0  bne 0x823afab0
	if !ctx.cr[0].eq {
	pc = 0x823AFAB0; continue 'dispatch;
	}
	// 823AFAF4: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 823AFAF8: 923F086C  stw r17, 0x86c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2156 as u32), ctx.r[17].u32 ) };
	// 823AFAFC: 917F0870  stw r11, 0x870(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2160 as u32), ctx.r[11].u32 ) };
	pc = 0x823AFB00; continue 'dispatch;
            }
            0x823AFB00 => {
    //   block [0x823AFB00..0x823AFB04)
	// 823AFB00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x823AFB04; continue 'dispatch;
            }
            0x823AFB04 => {
    //   block [0x823AFB04..0x823AFB0C)
	// 823AFB04: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 823AFB08: 481855D4  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AFB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AFB10 size=836
    let mut pc: u32 = 0x823AFB10;
    'dispatch: loop {
        match pc {
            0x823AFB10 => {
    //   block [0x823AFB10..0x823AFB70)
	// 823AFB10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AFB14: 4818556D  bl 0x82535080
	ctx.lr = 0x823AFB18;
	sub_82535080(ctx, base);
	// 823AFB18: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AFB1C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823AFB20: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 823AFB24: 7D144378  mr r20, r8
	ctx.r[20].u64 = ctx.r[8].u64;
	// 823AFB28: 3A200000  li r17, 0
	ctx.r[17].s64 = 0;
	// 823AFB2C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823AFB30: 7CCF3378  mr r15, r6
	ctx.r[15].u64 = ctx.r[6].u64;
	// 823AFB34: 553C043F  clrlwi. r28, r9, 0x10
	ctx.r[28].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823AFB38: 92BB0020  stw r21, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[21].u32 ) };
	// 823AFB3C: 7E378B78  mr r23, r17
	ctx.r[23].u64 = ctx.r[17].u64;
	// 823AFB40: 929B0024  stw r20, 0x24(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(36 as u32), ctx.r[20].u32 ) };
	// 823AFB44: 39C00001  li r14, 1
	ctx.r[14].s64 = 1;
	// 823AFB48: 4182002C  beq 0x823afb74
	if ctx.cr[0].eq {
	pc = 0x823AFB74; continue 'dispatch;
	}
	// 823AFB4C: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AFB50: 387CFFFF  addi r3, r28, -1
	ctx.r[3].s64 = ctx.r[28].s64 + -1;
	// 823AFB54: 51CBE804  rlwimi r11, r14, 0x1d, 0, 2
	ctx.r[11].u64 = (((ctx.r[14].u32).rotate_left(29) as u64) & 0x00000000E0000000) | (ctx.r[11].u64 & 0xFFFFFFFF1FFFFFFF);
	// 823AFB58: 2B030007  cmplwi cr6, r3, 7
	ctx.cr[6].compare_u32(ctx.r[3].u32, 7 as u32, &mut ctx.xer);
	// 823AFB5C: 917B001C  stw r11, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 823AFB60: 41990010  bgt cr6, 0x823afb70
	if ctx.cr[6].gt {
	pc = 0x823AFB70; continue 'dispatch;
	}
	// 823AFB64: 4BFFFD1D  bl 0x823af880
	ctx.lr = 0x823AFB68;
	sub_823AF880(ctx, base);
	// 823AFB68: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 823AFB6C: 48000008  b 0x823afb74
	pc = 0x823AFB74; continue 'dispatch;
            }
            0x823AFB70 => {
    //   block [0x823AFB70..0x823AFB74)
	// 823AFB70: 7E378B78  mr r23, r17
	ctx.r[23].u64 = ctx.r[17].u64;
	pc = 0x823AFB74; continue 'dispatch;
            }
            0x823AFB74 => {
    //   block [0x823AFB74..0x823AFBB4)
	// 823AFB74: 5536001F  rlwinm. r22, r9, 0, 0, 0xf
	ctx.r[22].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 823AFB78: 7E3F8B78  mr r31, r17
	ctx.r[31].u64 = ctx.r[17].u64;
	// 823AFB7C: 3E000004  lis r16, 4
	ctx.r[16].s64 = 262144;
	// 823AFB80: 3E600001  lis r19, 1
	ctx.r[19].s64 = 65536;
	// 823AFB84: 3E400002  lis r18, 2
	ctx.r[18].s64 = 131072;
	// 823AFB88: 41820048  beq 0x823afbd0
	if ctx.cr[0].eq {
	pc = 0x823AFBD0; continue 'dispatch;
	}
	// 823AFB8C: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AFB90: 7F169840  cmplw cr6, r22, r19
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[19].u32, &mut ctx.xer);
	// 823AFB94: 656B1000  oris r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 268435456;
	// 823AFB98: 917B001C  stw r11, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 823AFB9C: 419A002C  beq cr6, 0x823afbc8
	if ctx.cr[6].eq {
	pc = 0x823AFBC8; continue 'dispatch;
	}
	// 823AFBA0: 7F169040  cmplw cr6, r22, r18
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[18].u32, &mut ctx.xer);
	// 823AFBA4: 419A001C  beq cr6, 0x823afbc0
	if ctx.cr[6].eq {
	pc = 0x823AFBC0; continue 'dispatch;
	}
	// 823AFBA8: 7F168040  cmplw cr6, r22, r16
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[16].u32, &mut ctx.xer);
	// 823AFBAC: 419A0008  beq cr6, 0x823afbb4
	if ctx.cr[6].eq {
	pc = 0x823AFBB4; continue 'dispatch;
	}
	// 823AFBB0: 48000020  b 0x823afbd0
	pc = 0x823AFBD0; continue 'dispatch;
            }
            0x823AFBB4 => {
    //   block [0x823AFBB4..0x823AFBC0)
	// 823AFBB4: 3FE01A22  lis r31, 0x1a22
	ctx.r[31].s64 = 438435840;
	// 823AFBB8: 63FF0158  ori r31, r31, 0x158
	ctx.r[31].u64 = ctx.r[31].u64 | 344;
	// 823AFBBC: 48000014  b 0x823afbd0
	pc = 0x823AFBD0; continue 'dispatch;
            }
            0x823AFBC0 => {
    //   block [0x823AFBC0..0x823AFBC8)
	// 823AFBC0: 3FE02DA0  lis r31, 0x2da0
	ctx.r[31].s64 = 765460480;
	// 823AFBC4: 48000008  b 0x823afbcc
	pc = 0x823AFBCC; continue 'dispatch;
            }
            0x823AFBC8 => {
    //   block [0x823AFBC8..0x823AFBCC)
	// 823AFBC8: 3FE02D20  lis r31, 0x2d20
	ctx.r[31].s64 = 757071872;
	pc = 0x823AFBCC; continue 'dispatch;
            }
            0x823AFBCC => {
    //   block [0x823AFBCC..0x823AFBD0)
	// 823AFBCC: 63FF0196  ori r31, r31, 0x196
	ctx.r[31].u64 = ctx.r[31].u64 | 406;
	pc = 0x823AFBD0; continue 'dispatch;
            }
            0x823AFBD0 => {
    //   block [0x823AFBD0..0x823AFBE4)
	// 823AFBD0: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AFBD4: 7DDA7378  mr r26, r14
	ctx.r[26].u64 = ctx.r[14].u64;
	// 823AFBD8: 3B0B0F00  addi r24, r11, 0xf00
	ctx.r[24].s64 = ctx.r[11].s64 + 3840;
	// 823AFBDC: 3FC082BA  lis r30, -0x7d46
	ctx.r[30].s64 = -2101739520;
	// 823AFBE0: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	pc = 0x823AFBE4; continue 'dispatch;
            }
            0x823AFBE4 => {
    //   block [0x823AFBE4..0x823AFC14)
	// 823AFBE4: 923EC474  stw r17, -0x3b8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-15244 as u32), ctx.r[17].u32 ) };
	// 823AFBE8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823AFBEC: 419A0028  beq cr6, 0x823afc14
	if ctx.cr[6].eq {
	pc = 0x823AFC14; continue 'dispatch;
	}
	// 823AFBF0: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 823AFBF4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823AFBF8: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 823AFBFC: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 823AFC00: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 823AFC04: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 823AFC08: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AFC0C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 823AFC10: 4BFFED41  bl 0x823ae950
	ctx.lr = 0x823AFC14;
	sub_823AE950(ctx, base);
	pc = 0x823AFC14; continue 'dispatch;
            }
            0x823AFC14 => {
    //   block [0x823AFC14..0x823AFC40)
	// 823AFC14: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 823AFC18: 419A0028  beq cr6, 0x823afc40
	if ctx.cr[6].eq {
	pc = 0x823AFC40; continue 'dispatch;
	}
	// 823AFC1C: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 823AFC20: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823AFC24: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 823AFC28: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 823AFC2C: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 823AFC30: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 823AFC34: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AFC38: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 823AFC3C: 4BFFEF65  bl 0x823aeba0
	ctx.lr = 0x823AFC40;
	sub_823AEBA0(ctx, base);
	pc = 0x823AFC40; continue 'dispatch;
            }
            0x823AFC40 => {
    //   block [0x823AFC40..0x823AFC54)
	// 823AFC40: 817EC474  lwz r11, -0x3b8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-15244 as u32) ) } as u64;
	// 823AFC44: 2B0B0800  cmplwi cr6, r11, 0x800
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2048 as u32, &mut ctx.xer);
	// 823AFC48: 4099000C  ble cr6, 0x823afc54
	if !ctx.cr[6].gt {
	pc = 0x823AFC54; continue 'dispatch;
	}
	// 823AFC4C: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 823AFC50: 4BFFFF94  b 0x823afbe4
	pc = 0x823AFBE4; continue 'dispatch;
            }
            0x823AFC54 => {
    //   block [0x823AFC54..0x823AFC7C)
	// 823AFC54: 815B001C  lwz r10, 0x1c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AFC58: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 823AFC5C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823AFC60: 51CAE804  rlwimi r10, r14, 0x1d, 0, 2
	ctx.r[10].u64 = (((ctx.r[14].u32).rotate_left(29) as u64) & 0x00000000E0000000) | (ctx.r[10].u64 & 0xFFFFFFFF1FFFFFFF);
	// 823AFC64: 917EC474  stw r11, -0x3b8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-15244 as u32), ctx.r[11].u32 ) };
	// 823AFC68: 7E3E8B78  mr r30, r17
	ctx.r[30].u64 = ctx.r[17].u64;
	// 823AFC6C: 915B001C  stw r10, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 823AFC70: 419A0064  beq cr6, 0x823afcd4
	if ctx.cr[6].eq {
	pc = 0x823AFCD4; continue 'dispatch;
	}
	// 823AFC74: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 823AFC78: 3BFB0154  addi r31, r27, 0x154
	ctx.r[31].s64 = ctx.r[27].s64 + 340;
	pc = 0x823AFC7C; continue 'dispatch;
            }
            0x823AFC7C => {
    //   block [0x823AFC7C..0x823AFCD4)
	// 823AFC7C: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AFC80: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 823AFC84: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823AFC88: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 823AFC8C: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 823AFC90: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 823AFC94: 389FFEDC  addi r4, r31, -0x124
	ctx.r[4].s64 = ctx.r[31].s64 + -292;
	// 823AFC98: 90BC0000  stw r5, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 823AFC9C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 823AFCA0: 4BFFECB1  bl 0x823ae950
	ctx.lr = 0x823AFCA4;
	sub_823AE950(ctx, base);
	// 823AFCA4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823AFCA8: 408200D4  bne 0x823afd7c
	if !ctx.cr[0].eq {
	pc = 0x823AFD7C; continue 'dispatch;
	}
	// 823AFCAC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823AFCB0: 91DF0000  stw r14, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[14].u32 ) };
	// 823AFCB4: 923F0004  stw r17, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[17].u32 ) };
	// 823AFCB8: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 823AFCBC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823AFCC0: 3BFF0130  addi r31, r31, 0x130
	ctx.r[31].s64 = ctx.r[31].s64 + 304;
	// 823AFCC4: 2B1E0001  cmplwi cr6, r30, 1
	ctx.cr[6].compare_u32(ctx.r[30].u32, 1 as u32, &mut ctx.xer);
	// 823AFCC8: 4198FFB4  blt cr6, 0x823afc7c
	if ctx.cr[6].lt {
	pc = 0x823AFC7C; continue 'dispatch;
	}
	// 823AFCCC: 2B1E0006  cmplwi cr6, r30, 6
	ctx.cr[6].compare_u32(ctx.r[30].u32, 6 as u32, &mut ctx.xer);
	// 823AFCD0: 4098002C  bge cr6, 0x823afcfc
	if !ctx.cr[6].lt {
	pc = 0x823AFCFC; continue 'dispatch;
	}
	pc = 0x823AFCD4; continue 'dispatch;
            }
            0x823AFCD4 => {
    //   block [0x823AFCD4..0x823AFCF0)
	// 823AFCD4: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823AFCD8: 217E0006  subfic r11, r30, 6
	ctx.xer.ca = ctx.r[30].u32 <= 6 as u32;
	ctx.r[11].s64 = (6 as i64) - ctx.r[30].s64;
	// 823AFCDC: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 823AFCE0: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 823AFCE4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AFCE8: 41820014  beq 0x823afcfc
	if ctx.cr[0].eq {
	pc = 0x823AFCFC; continue 'dispatch;
	}
	// 823AFCEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x823AFCF0; continue 'dispatch;
            }
            0x823AFCF0 => {
    //   block [0x823AFCF0..0x823AFCFC)
	// 823AFCF0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823AFCF4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823AFCF8: 4200FFF8  bdnz 0x823afcf0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823AFCF0; continue 'dispatch;
	}
	pc = 0x823AFCFC; continue 'dispatch;
            }
            0x823AFCFC => {
    //   block [0x823AFCFC..0x823AFD40)
	// 823AFCFC: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 823AFD00: 419A0070  beq cr6, 0x823afd70
	if ctx.cr[6].eq {
	pc = 0x823AFD70; continue 'dispatch;
	}
	// 823AFD04: 2F0FFFFF  cmpwi cr6, r15, -1
	ctx.cr[6].compare_i32(ctx.r[15].s32, -1, &mut ctx.xer);
	// 823AFD08: 91FB0018  stw r15, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[15].u32 ) };
	// 823AFD0C: 419A0078  beq cr6, 0x823afd84
	if ctx.cr[6].eq {
	pc = 0x823AFD84; continue 'dispatch;
	}
	// 823AFD10: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AFD14: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 823AFD18: 396B1100  addi r11, r11, 0x1100
	ctx.r[11].s64 = ctx.r[11].s64 + 4352;
	// 823AFD1C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 823AFD20: 4BFFF951  bl 0x823af670
	ctx.lr = 0x823AFD24;
	sub_823AF670(ctx, base);
	// 823AFD24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AFD28: 4182005C  beq 0x823afd84
	if ctx.cr[0].eq {
	pc = 0x823AFD84; continue 'dispatch;
	}
	// 823AFD2C: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AFD30: 38830750  addi r4, r3, 0x750
	ctx.r[4].s64 = ctx.r[3].s64 + 1872;
	// 823AFD34: 556B00C7  rlwinm. r11, r11, 0, 3, 3
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AFD38: 40820008  bne 0x823afd40
	if !ctx.cr[0].eq {
	pc = 0x823AFD40; continue 'dispatch;
	}
	// 823AFD3C: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	pc = 0x823AFD40; continue 'dispatch;
            }
            0x823AFD40 => {
    //   block [0x823AFD40..0x823AFD4C)
	// 823AFD40: 387B0750  addi r3, r27, 0x750
	ctx.r[3].s64 = ctx.r[27].s64 + 1872;
	// 823AFD44: 38A00130  li r5, 0x130
	ctx.r[5].s64 = 304;
	// 823AFD48: 48184E09  bl 0x82534b50
	ctx.lr = 0x823AFD4C;
	sub_82534B50(ctx, base);
	pc = 0x823AFD4C; continue 'dispatch;
            }
            0x823AFD4C => {
    //   block [0x823AFD4C..0x823AFD70)
	// 823AFD4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823AFD50: 807B0754  lwz r3, 0x754(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1876 as u32) ) } as u64;
	// 823AFD54: 48029C15  bl 0x823d9968
	ctx.lr = 0x823AFD58;
	sub_823D9968(ctx, base);
	// 823AFD58: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AFD5C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 823AFD60: 91DB086C  stw r14, 0x86c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(2156 as u32), ctx.r[14].u32 ) };
	// 823AFD64: 656B1000  oris r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 268435456;
	// 823AFD68: 915B0870  stw r10, 0x870(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(2160 as u32), ctx.r[10].u32 ) };
	// 823AFD6C: 917B001C  stw r11, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	pc = 0x823AFD70; continue 'dispatch;
            }
            0x823AFD70 => {
    //   block [0x823AFD70..0x823AFD74)
	// 823AFD70: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x823AFD74; continue 'dispatch;
            }
            0x823AFD74 => {
    //   block [0x823AFD74..0x823AFD7C)
	// 823AFD74: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 823AFD78: 48185358  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            0x823AFD7C => {
    //   block [0x823AFD7C..0x823AFD84)
	// 823AFD7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AFD80: 4BFFFFF4  b 0x823afd74
	pc = 0x823AFD74; continue 'dispatch;
            }
            0x823AFD84 => {
    //   block [0x823AFD84..0x823AFDA4)
	// 823AFD84: 7F169840  cmplw cr6, r22, r19
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[19].u32, &mut ctx.xer);
	// 823AFD88: 419A0030  beq cr6, 0x823afdb8
	if ctx.cr[6].eq {
	pc = 0x823AFDB8; continue 'dispatch;
	}
	// 823AFD8C: 7F169040  cmplw cr6, r22, r18
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[18].u32, &mut ctx.xer);
	// 823AFD90: 419A0020  beq cr6, 0x823afdb0
	if ctx.cr[6].eq {
	pc = 0x823AFDB0; continue 'dispatch;
	}
	// 823AFD94: 7F168040  cmplw cr6, r22, r16
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[16].u32, &mut ctx.xer);
	// 823AFD98: 419A000C  beq cr6, 0x823afda4
	if ctx.cr[6].eq {
	pc = 0x823AFDA4; continue 'dispatch;
	}
	// 823AFD9C: 7E288B78  mr r8, r17
	ctx.r[8].u64 = ctx.r[17].u64;
	// 823AFDA0: 48000020  b 0x823afdc0
	pc = 0x823AFDC0; continue 'dispatch;
            }
            0x823AFDA4 => {
    //   block [0x823AFDA4..0x823AFDB0)
	// 823AFDA4: 3D001A22  lis r8, 0x1a22
	ctx.r[8].s64 = 438435840;
	// 823AFDA8: 61080158  ori r8, r8, 0x158
	ctx.r[8].u64 = ctx.r[8].u64 | 344;
	// 823AFDAC: 48000014  b 0x823afdc0
	pc = 0x823AFDC0; continue 'dispatch;
            }
            0x823AFDB0 => {
    //   block [0x823AFDB0..0x823AFDB8)
	// 823AFDB0: 3D002DA0  lis r8, 0x2da0
	ctx.r[8].s64 = 765460480;
	// 823AFDB4: 48000008  b 0x823afdbc
	pc = 0x823AFDBC; continue 'dispatch;
            }
            0x823AFDB8 => {
    //   block [0x823AFDB8..0x823AFDBC)
	// 823AFDB8: 3D002D20  lis r8, 0x2d20
	ctx.r[8].s64 = 757071872;
	pc = 0x823AFDBC; continue 'dispatch;
            }
            0x823AFDBC => {
    //   block [0x823AFDBC..0x823AFDC0)
	// 823AFDBC: 61080196  ori r8, r8, 0x196
	ctx.r[8].u64 = ctx.r[8].u64 | 406;
	pc = 0x823AFDC0; continue 'dispatch;
            }
            0x823AFDC0 => {
    //   block [0x823AFDC0..0x823AFDFC)
	// 823AFDC0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823AFDC4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823AFDC8: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 823AFDCC: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 823AFDD0: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 823AFDD4: 389B0750  addi r4, r27, 0x750
	ctx.r[4].s64 = ctx.r[27].s64 + 1872;
	// 823AFDD8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 823AFDDC: 4BFFEDC5  bl 0x823aeba0
	ctx.lr = 0x823AFDE0;
	sub_823AEBA0(ctx, base);
	// 823AFDE0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823AFDE4: 4080FF68  bge 0x823afd4c
	if !ctx.cr[0].lt {
	pc = 0x823AFD4C; continue 'dispatch;
	}
	// 823AFDE8: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AFDEC: 7E3E8B78  mr r30, r17
	ctx.r[30].u64 = ctx.r[17].u64;
	// 823AFDF0: 556B0005  rlwinm. r11, r11, 0, 0, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AFDF4: 4182004C  beq 0x823afe40
	if ctx.cr[0].eq {
	pc = 0x823AFE40; continue 'dispatch;
	}
	// 823AFDF8: 3BFB0030  addi r31, r27, 0x30
	ctx.r[31].s64 = ctx.r[27].s64 + 48;
	pc = 0x823AFDFC; continue 'dispatch;
            }
            0x823AFDFC => {
    //   block [0x823AFDFC..0x823AFE18)
	// 823AFDFC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AFE00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AFE04: 41820014  beq 0x823afe18
	if ctx.cr[0].eq {
	pc = 0x823AFE18; continue 'dispatch;
	}
	// 823AFE08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AFE0C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AFE10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AFE14: 4E800421  bctrl
	ctx.lr = 0x823AFE18;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823AFE18 => {
    //   block [0x823AFE18..0x823AFE28)
	// 823AFE18: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AFE1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AFE20: 41820008  beq 0x823afe28
	if ctx.cr[0].eq {
	pc = 0x823AFE28; continue 'dispatch;
	}
	// 823AFE24: 4802A365  bl 0x823da188
	ctx.lr = 0x823AFE28;
	sub_823DA188(ctx, base);
	pc = 0x823AFE28; continue 'dispatch;
            }
            0x823AFE28 => {
    //   block [0x823AFE28..0x823AFE40)
	// 823AFE28: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AFE2C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823AFE30: 3BFF0130  addi r31, r31, 0x130
	ctx.r[31].s64 = ctx.r[31].s64 + 304;
	// 823AFE34: 556B1F7E  srwi r11, r11, 0x1d
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(29);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823AFE38: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AFE3C: 4198FFC0  blt cr6, 0x823afdfc
	if ctx.cr[6].lt {
	pc = 0x823AFDFC; continue 'dispatch;
	}
	pc = 0x823AFE40; continue 'dispatch;
            }
            0x823AFE40 => {
    //   block [0x823AFE40..0x823AFE54)
	// 823AFE40: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AFE44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823AFE48: 556B00FE  clrlwi r11, r11, 3
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 823AFE4C: 917B001C  stw r11, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 823AFE50: 4BFFFF24  b 0x823afd74
	pc = 0x823AFD74; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823AFE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823AFE58 size=444
    let mut pc: u32 = 0x823AFE58;
    'dispatch: loop {
        match pc {
            0x823AFE58 => {
    //   block [0x823AFE58..0x823AFE80)
	// 823AFE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823AFE5C: 48185255  bl 0x825350b0
	ctx.lr = 0x823AFE60;
	sub_82535080(ctx, base);
	// 823AFE60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823AFE64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823AFE68: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823AFE6C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 823AFE70: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AFE74: 556B0005  rlwinm. r11, r11, 0, 0, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823AFE78: 4182004C  beq 0x823afec4
	if ctx.cr[0].eq {
	pc = 0x823AFEC4; continue 'dispatch;
	}
	// 823AFE7C: 3BFD0030  addi r31, r29, 0x30
	ctx.r[31].s64 = ctx.r[29].s64 + 48;
	pc = 0x823AFE80; continue 'dispatch;
            }
            0x823AFE80 => {
    //   block [0x823AFE80..0x823AFE9C)
	// 823AFE80: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AFE84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AFE88: 41820014  beq 0x823afe9c
	if ctx.cr[0].eq {
	pc = 0x823AFE9C; continue 'dispatch;
	}
	// 823AFE8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AFE90: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AFE94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AFE98: 4E800421  bctrl
	ctx.lr = 0x823AFE9C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823AFE9C => {
    //   block [0x823AFE9C..0x823AFEAC)
	// 823AFE9C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AFEA0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AFEA4: 41820008  beq 0x823afeac
	if ctx.cr[0].eq {
	pc = 0x823AFEAC; continue 'dispatch;
	}
	// 823AFEA8: 4802A2E1  bl 0x823da188
	ctx.lr = 0x823AFEAC;
	sub_823DA188(ctx, base);
	pc = 0x823AFEAC; continue 'dispatch;
            }
            0x823AFEAC => {
    //   block [0x823AFEAC..0x823AFEC4)
	// 823AFEAC: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AFEB0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823AFEB4: 3BFF0130  addi r31, r31, 0x130
	ctx.r[31].s64 = ctx.r[31].s64 + 304;
	// 823AFEB8: 556B1F7E  srwi r11, r11, 0x1d
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(29);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823AFEBC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AFEC0: 4198FFC0  blt cr6, 0x823afe80
	if ctx.cr[6].lt {
	pc = 0x823AFE80; continue 'dispatch;
	}
	pc = 0x823AFEC4; continue 'dispatch;
            }
            0x823AFEC4 => {
    //   block [0x823AFEC4..0x823AFEFC)
	// 823AFEC4: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AFEC8: 556B00FE  clrlwi r11, r11, 3
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 823AFECC: 917D001C  stw r11, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 823AFED0: 556A00C7  rlwinm. r10, r11, 0, 3, 3
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823AFED4: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AFED8: 3BEB1100  addi r31, r11, 0x1100
	ctx.r[31].s64 = ctx.r[11].s64 + 4352;
	// 823AFEDC: 418200B0  beq 0x823aff8c
	if ctx.cr[0].eq {
	pc = 0x823AFF8C; continue 'dispatch;
	}
	// 823AFEE0: 807D0750  lwz r3, 0x750(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1872 as u32) ) } as u64;
	// 823AFEE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AFEE8: 41820014  beq 0x823afefc
	if ctx.cr[0].eq {
	pc = 0x823AFEFC; continue 'dispatch;
	}
	// 823AFEEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AFEF0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AFEF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823AFEF8: 4E800421  bctrl
	ctx.lr = 0x823AFEFC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823AFEFC => {
    //   block [0x823AFEFC..0x823AFF0C)
	// 823AFEFC: 807D0754  lwz r3, 0x754(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1876 as u32) ) } as u64;
	// 823AFF00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823AFF04: 41820008  beq 0x823aff0c
	if ctx.cr[0].eq {
	pc = 0x823AFF0C; continue 'dispatch;
	}
	// 823AFF08: 4802A281  bl 0x823da188
	ctx.lr = 0x823AFF0C;
	sub_823DA188(ctx, base);
	pc = 0x823AFF0C; continue 'dispatch;
            }
            0x823AFF0C => {
    //   block [0x823AFF0C..0x823AFF30)
	// 823AFF0C: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AFF10: 837D0018  lwz r27, 0x18(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AFF14: 556B0104  rlwinm r11, r11, 0, 4, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823AFF18: 2F1BFFFF  cmpwi cr6, r27, -1
	ctx.cr[6].compare_i32(ctx.r[27].s32, -1, &mut ctx.xer);
	// 823AFF1C: 917D001C  stw r11, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 823AFF20: 419A006C  beq cr6, 0x823aff8c
	if ctx.cr[6].eq {
	pc = 0x823AFF8C; continue 'dispatch;
	}
	// 823AFF24: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 823AFF28: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AFF2C: 48000054  b 0x823aff80
	pc = 0x823AFF80; continue 'dispatch;
            }
            0x823AFF30 => {
    //   block [0x823AFF30..0x823AFF7C)
	// 823AFF30: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AFF34: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 823AFF38: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AFF3C: 409A0040  bne cr6, 0x823aff7c
	if !ctx.cr[6].eq {
	pc = 0x823AFF7C; continue 'dispatch;
	}
	// 823AFF40: 397E0750  addi r11, r30, 0x750
	ctx.r[11].s64 = ctx.r[30].s64 + 1872;
	// 823AFF44: 38A000F0  li r5, 0xf0
	ctx.r[5].s64 = 240;
	// 823AFF48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823AFF4C: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 823AFF50: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 823AFF54: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 823AFF58: 934B0120  stw r26, 0x120(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(288 as u32), ctx.r[26].u32 ) };
	// 823AFF5C: 934B0008  stw r26, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 823AFF60: 934B011C  stw r26, 0x11c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(284 as u32), ctx.r[26].u32 ) };
	// 823AFF64: 4818526D  bl 0x825351d0
	ctx.lr = 0x823AFF68;
	sub_825351D0(ctx, base);
	// 823AFF68: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 823AFF6C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 823AFF70: 556B0104  rlwinm r11, r11, 0, 4, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823AFF74: 915E0018  stw r10, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 823AFF78: 917E001C  stw r11, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	pc = 0x823AFF7C; continue 'dispatch;
            }
            0x823AFF7C => {
    //   block [0x823AFF7C..0x823AFF80)
	// 823AFF7C: 839C0004  lwz r28, 4(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823AFF80; continue 'dispatch;
            }
            0x823AFF80 => {
    //   block [0x823AFF80..0x823AFF8C)
	// 823AFF80: 397F003C  addi r11, r31, 0x3c
	ctx.r[11].s64 = ctx.r[31].s64 + 60;
	// 823AFF84: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823AFF88: 409AFFA8  bne cr6, 0x823aff30
	if !ctx.cr[6].eq {
	pc = 0x823AFF30; continue 'dispatch;
	}
	pc = 0x823AFF8C; continue 'dispatch;
            }
            0x823AFF8C => {
    //   block [0x823AFF8C..0x823AFFA0)
	// 823AFF8C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 823AFF90: 4835D2CD  bl 0x8270d25c
	ctx.lr = 0x823AFF94;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823AFF94: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 823AFF98: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823AFF9C: 48000014  b 0x823affb0
	pc = 0x823AFFB0; continue 'dispatch;
            }
            0x823AFFA0 => {
    //   block [0x823AFFA0..0x823AFFB0)
	// 823AFFA0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823AFFA4: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 823AFFA8: 419A0018  beq cr6, 0x823affc0
	if ctx.cr[6].eq {
	pc = 0x823AFFC0; continue 'dispatch;
	}
	// 823AFFAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823AFFB0; continue 'dispatch;
            }
            0x823AFFB0 => {
    //   block [0x823AFFB0..0x823AFFC0)
	// 823AFFB0: 395F003C  addi r10, r31, 0x3c
	ctx.r[10].s64 = ctx.r[31].s64 + 60;
	// 823AFFB4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823AFFB8: 409AFFE8  bne cr6, 0x823affa0
	if !ctx.cr[6].eq {
	pc = 0x823AFFA0; continue 'dispatch;
	}
	// 823AFFBC: 48000018  b 0x823affd4
	pc = 0x823AFFD4; continue 'dispatch;
            }
            0x823AFFC0 => {
    //   block [0x823AFFC0..0x823AFFD4)
	// 823AFFC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823AFFC4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823AFFC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823AFFCC: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 823AFFD0: 4BFFF7D1  bl 0x823af7a0
	ctx.lr = 0x823AFFD4;
	sub_823AF7A0(ctx, base);
	pc = 0x823AFFD4; continue 'dispatch;
            }
            0x823AFFD4 => {
    //   block [0x823AFFD4..0x823B0014)
	// 823AFFD4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 823AFFD8: 4835D295  bl 0x8270d26c
	ctx.lr = 0x823AFFDC;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823AFFDC: 387F01D8  addi r3, r31, 0x1d8
	ctx.r[3].s64 = ctx.r[31].s64 + 472;
	// 823AFFE0: 4835D27D  bl 0x8270d25c
	ctx.lr = 0x823AFFE4;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823AFFE4: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823AFFE8: 387F01D8  addi r3, r31, 0x1d8
	ctx.r[3].s64 = ctx.r[31].s64 + 472;
	// 823AFFEC: 396B1080  addi r11, r11, 0x1080
	ctx.r[11].s64 = ctx.r[11].s64 + 4224;
	// 823AFFF0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823AFFF4: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823AFFF8: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 823AFFFC: 817F01F8  lwz r11, 0x1f8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(504 as u32) ) } as u64;
	// 823B0000: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823B0004: 917F01F8  stw r11, 0x1f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), ctx.r[11].u32 ) };
	// 823B0008: 4835D265  bl 0x8270d26c
	ctx.lr = 0x823B000C;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B000C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823B0010: 481850F0  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B0018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B0018 size=92
    let mut pc: u32 = 0x823B0018;
    'dispatch: loop {
        match pc {
            0x823B0018 => {
    //   block [0x823B0018..0x823B005C)
	// 823B0018: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B001C: 39430078  addi r10, r3, 0x78
	ctx.r[10].s64 = ctx.r[3].s64 + 120;
	// 823B0020: 392B176C  addi r9, r11, 0x176c
	ctx.r[9].s64 = ctx.r[11].s64 + 5996;
	// 823B0024: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B0028: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 823B002C: 38EB1780  addi r7, r11, 0x1780
	ctx.r[7].s64 = ctx.r[11].s64 + 6016;
	// 823B0030: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823B0034: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823B0038: 392A0094  addi r9, r10, 0x94
	ctx.r[9].s64 = ctx.r[10].s64 + 148;
	// 823B003C: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823B0040: 91630070  stw r11, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 823B0044: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 823B0048: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 823B004C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823B0050: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823B0054: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823B0058: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x823B005C; continue 'dispatch;
            }
            0x823B005C => {
    //   block [0x823B005C..0x823B0074)
	// 823B005C: 9169FF80  stw r11, -0x80(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-128 as u32), ctx.r[11].u32 ) };
	// 823B0060: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823B0064: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B0068: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823B006C: 4082FFF0  bne 0x823b005c
	if !ctx.cr[0].eq {
	pc = 0x823B005C; continue 'dispatch;
	}
	// 823B0070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B0078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B0078 size=80
    let mut pc: u32 = 0x823B0078;
    'dispatch: loop {
        match pc {
            0x823B0078 => {
    //   block [0x823B0078..0x823B00B0)
	// 823B0078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B007C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B0080: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B0084: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B0088: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B008C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823B0090: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B0094: 396B1780  addi r11, r11, 0x1780
	ctx.r[11].s64 = ctx.r[11].s64 + 6016;
	// 823B0098: 394A1758  addi r10, r10, 0x1758
	ctx.r[10].s64 = ctx.r[10].s64 + 5976;
	// 823B009C: 548907FF  clrlwi. r9, r4, 0x1f
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823B00A0: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 823B00A4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823B00A8: 41820008  beq 0x823b00b0
	if ctx.cr[0].eq {
	pc = 0x823B00B0; continue 'dispatch;
	}
	// 823B00AC: 48182B0D  bl 0x82532bb8
	ctx.lr = 0x823B00B0;
	sub_82532BB8(ctx, base);
	pc = 0x823B00B0; continue 'dispatch;
            }
            0x823B00B0 => {
    //   block [0x823B00B0..0x823B00C8)
	// 823B00B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B00B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823B00B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B00BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B00C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B00C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B00C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B00C8 size=216
    let mut pc: u32 = 0x823B00C8;
    'dispatch: loop {
        match pc {
            0x823B00C8 => {
    //   block [0x823B00C8..0x823B00F4)
	// 823B00C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B00CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B00D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B00D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B00D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B00DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823B00E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B00E4: 2B1E0004  cmplwi cr6, r30, 4
	ctx.cr[6].compare_u32(ctx.r[30].u32, 4 as u32, &mut ctx.xer);
	// 823B00E8: 4198000C  blt cr6, 0x823b00f4
	if ctx.cr[6].lt {
	pc = 0x823B00F4; continue 'dispatch;
	}
	// 823B00EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B00F0: 48000098  b 0x823b0188
	pc = 0x823B0188; continue 'dispatch;
            }
            0x823B00F4 => {
    //   block [0x823B00F4..0x823B0170)
	// 823B00F4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 823B00F8: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 823B00FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B0100: 481850D1  bl 0x825351d0
	ctx.lr = 0x823B0104;
	sub_825351D0(ctx, base);
	// 823B0104: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823B0108: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 823B010C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 823B0110: 395F0078  addi r10, r31, 0x78
	ctx.r[10].s64 = ctx.r[31].s64 + 120;
	// 823B0114: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 823B0118: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 823B011C: 392A0094  addi r9, r10, 0x94
	ctx.r[9].s64 = ctx.r[10].s64 + 148;
	// 823B0120: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 823B0124: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 823B0128: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823B012C: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 823B0130: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823B0134: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 823B0138: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 823B013C: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 823B0140: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823B0144: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 823B0148: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 823B014C: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823B0150: B17F006C  sth r11, 0x6c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u16 ) };
	// 823B0154: B17F006E  sth r11, 0x6e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(110 as u32), ctx.r[11].u16 ) };
	// 823B0158: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 823B015C: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 823B0160: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823B0164: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823B0168: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823B016C: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x823B0170; continue 'dispatch;
            }
            0x823B0170 => {
    //   block [0x823B0170..0x823B0188)
	// 823B0170: 9169FF80  stw r11, -0x80(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-128 as u32), ctx.r[11].u32 ) };
	// 823B0174: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823B0178: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B017C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823B0180: 4082FFF0  bne 0x823b0170
	if !ctx.cr[0].eq {
	pc = 0x823B0170; continue 'dispatch;
	}
	// 823B0184: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x823B0188; continue 'dispatch;
            }
            0x823B0188 => {
    //   block [0x823B0188..0x823B01A0)
	// 823B0188: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B018C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B0190: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B0194: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B0198: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B019C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B01A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B01A0 size=256
    let mut pc: u32 = 0x823B01A0;
    'dispatch: loop {
        match pc {
            0x823B01A0 => {
    //   block [0x823B01A0..0x823B01D4)
	// 823B01A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B01A4: 48184F19  bl 0x825350bc
	ctx.lr = 0x823B01A8;
	sub_82535080(ctx, base);
	// 823B01A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B01AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B01B0: 3860FFFE  li r3, -2
	ctx.r[3].s64 = -2;
	// 823B01B4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823B01B8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B01BC: 2F0BFFFD  cmpwi cr6, r11, -3
	ctx.cr[6].compare_i32(ctx.r[11].s32, -3, &mut ctx.xer);
	// 823B01C0: 419A0014  beq cr6, 0x823b01d4
	if ctx.cr[6].eq {
	pc = 0x823B01D4; continue 'dispatch;
	}
	// 823B01C4: 40990090  ble cr6, 0x823b0254
	if !ctx.cr[6].gt {
	pc = 0x823B0254; continue 'dispatch;
	}
	// 823B01C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B01CC: 41980030  blt cr6, 0x823b01fc
	if ctx.cr[6].lt {
	pc = 0x823B01FC; continue 'dispatch;
	}
	// 823B01D0: 409A0084  bne cr6, 0x823b0254
	if !ctx.cr[6].eq {
	pc = 0x823B0254; continue 'dispatch;
	}
	pc = 0x823B01D4; continue 'dispatch;
            }
            0x823B01D4 => {
    //   block [0x823B01D4..0x823B01FC)
	// 823B01D4: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 823B01D8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B01DC: 3BA0FFFE  li r29, -2
	ctx.r[29].s64 = -2;
	// 823B01E0: 48196841  bl 0x82546a20
	ctx.lr = 0x823B01E4;
	sub_82546A20(ctx, base);
	// 823B01E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B01E8: 41820020  beq 0x823b0208
	if ctx.cr[0].eq {
	pc = 0x823B0208; continue 'dispatch;
	}
	// 823B01EC: 2B03048F  cmplwi cr6, r3, 0x48f
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1167 as u32, &mut ctx.xer);
	// 823B01F0: 409A0050  bne cr6, 0x823b0240
	if !ctx.cr[6].eq {
	pc = 0x823B0240; continue 'dispatch;
	}
	// 823B01F4: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 823B01F8: 48000048  b 0x823b0240
	pc = 0x823B0240; continue 'dispatch;
            }
            0x823B01FC => {
    //   block [0x823B01FC..0x823B0208)
	// 823B01FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B0200: 480000B9  bl 0x823b02b8
	ctx.lr = 0x823B0204;
	sub_823B02B8(ctx, base);
	// 823B0204: 48000040  b 0x823b0244
	pc = 0x823B0244; continue 'dispatch;
            }
            0x823B0208 => {
    //   block [0x823B0208..0x823B023C)
	// 823B0208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B020C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 823B0210: 480001A1  bl 0x823b03b0
	ctx.lr = 0x823B0214;
	sub_823B03B0(ctx, base);
	// 823B0214: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 823B0218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B021C: 419A0024  beq cr6, 0x823b0240
	if ctx.cr[6].eq {
	pc = 0x823B0240; continue 'dispatch;
	}
	// 823B0220: 389F006C  addi r4, r31, 0x6c
	ctx.r[4].s64 = ctx.r[31].s64 + 108;
	// 823B0224: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B0228: 48196809  bl 0x82546a30
	ctx.lr = 0x823B022C;
	sub_82546A30(ctx, base);
	// 823B022C: 2B0300AA  cmplwi cr6, r3, 0xaa
	ctx.cr[6].compare_u32(ctx.r[3].u32, 170 as u32, &mut ctx.xer);
	// 823B0230: 419A000C  beq cr6, 0x823b023c
	if ctx.cr[6].eq {
	pc = 0x823B023C; continue 'dispatch;
	}
	// 823B0234: 93DF0070  stw r30, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 823B0238: 48000008  b 0x823b0240
	pc = 0x823B0240; continue 'dispatch;
            }
            0x823B023C => {
    //   block [0x823B023C..0x823B0240)
	// 823B023C: 3BA0FFFD  li r29, -3
	ctx.r[29].s64 = -3;
	pc = 0x823B0240; continue 'dispatch;
            }
            0x823B0240 => {
    //   block [0x823B0240..0x823B0244)
	// 823B0240: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x823B0244; continue 'dispatch;
            }
            0x823B0244 => {
    //   block [0x823B0244..0x823B0254)
	// 823B0244: 2F03FFFE  cmpwi cr6, r3, -2
	ctx.cr[6].compare_i32(ctx.r[3].s32, -2, &mut ctx.xer);
	// 823B0248: 41980044  blt cr6, 0x823b028c
	if ctx.cr[6].lt {
	pc = 0x823B028C; continue 'dispatch;
	}
	// 823B024C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 823B0250: 4098003C  bge cr6, 0x823b028c
	if !ctx.cr[6].lt {
	pc = 0x823B028C; continue 'dispatch;
	}
	pc = 0x823B0254; continue 'dispatch;
            }
            0x823B0254 => {
    //   block [0x823B0254..0x823B027C)
	// 823B0254: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 823B0258: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 823B025C: 397F0028  addi r11, r31, 0x28
	ctx.r[11].s64 = ctx.r[31].s64 + 40;
	// 823B0260: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 823B0264: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 823B0268: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 823B026C: 3940000E  li r10, 0xe
	ctx.r[10].s64 = 14;
	// 823B0270: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 823B0274: 911F0020  stw r8, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 823B0278: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x823B027C; continue 'dispatch;
            }
            0x823B027C => {
    //   block [0x823B027C..0x823B028C)
	// 823B027C: B12B0000  sth r9, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 823B0280: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 823B0284: 4200FFF8  bdnz 0x823b027c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823B027C; continue 'dispatch;
	}
	// 823B0288: 93DF0074  stw r30, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	pc = 0x823B028C; continue 'dispatch;
            }
            0x823B028C => {
    //   block [0x823B028C..0x823B02A0)
	// 823B028C: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 823B0290: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 823B0294: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823B0298: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B029C: 48184E70  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B02B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B02B8 size=248
    let mut pc: u32 = 0x823B02B8;
    'dispatch: loop {
        match pc {
            0x823B02B8 => {
    //   block [0x823B02B8..0x823B02FC)
	// 823B02B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B02BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B02C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B02C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B02C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B02CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B02D0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B02D4: 38BF0058  addi r5, r31, 0x58
	ctx.r[5].s64 = ctx.r[31].s64 + 88;
	// 823B02D8: 3BC0FFFE  li r30, -2
	ctx.r[30].s64 = -2;
	// 823B02DC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B02E0: 48196739  bl 0x82546a18
	ctx.lr = 0x823B02E4;
	sub_82546A18(ctx, base);
	// 823B02E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B02E8: 41820014  beq 0x823b02fc
	if ctx.cr[0].eq {
	pc = 0x823B02FC; continue 'dispatch;
	}
	// 823B02EC: 2B03048F  cmplwi cr6, r3, 0x48f
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1167 as u32, &mut ctx.xer);
	// 823B02F0: 409A00A4  bne cr6, 0x823b0394
	if !ctx.cr[6].eq {
	pc = 0x823B0394; continue 'dispatch;
	}
	// 823B02F4: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 823B02F8: 4800009C  b 0x823b0394
	pc = 0x823B0394; continue 'dispatch;
            }
            0x823B02FC => {
    //   block [0x823B02FC..0x823B0344)
	// 823B02FC: 897F0059  lbz r11, 0x59(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(89 as u32) ) } as u64;
	// 823B0300: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B0304: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823B0308: 419A0064  beq cr6, 0x823b036c
	if ctx.cr[6].eq {
	pc = 0x823B036C; continue 'dispatch;
	}
	// 823B030C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 823B0310: 419A0054  beq cr6, 0x823b0364
	if ctx.cr[6].eq {
	pc = 0x823B0364; continue 'dispatch;
	}
	// 823B0314: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 823B0318: 419A0044  beq cr6, 0x823b035c
	if ctx.cr[6].eq {
	pc = 0x823B035C; continue 'dispatch;
	}
	// 823B031C: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 823B0320: 419A0034  beq cr6, 0x823b0354
	if ctx.cr[6].eq {
	pc = 0x823B0354; continue 'dispatch;
	}
	// 823B0324: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 823B0328: 419A0024  beq cr6, 0x823b034c
	if ctx.cr[6].eq {
	pc = 0x823B034C; continue 'dispatch;
	}
	// 823B032C: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 823B0330: 419A0014  beq cr6, 0x823b0344
	if ctx.cr[6].eq {
	pc = 0x823B0344; continue 'dispatch;
	}
	// 823B0334: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 823B0338: 409A0038  bne cr6, 0x823b0370
	if !ctx.cr[6].eq {
	pc = 0x823B0370; continue 'dispatch;
	}
	// 823B033C: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 823B0340: 48000030  b 0x823b0370
	pc = 0x823B0370; continue 'dispatch;
            }
            0x823B0344 => {
    //   block [0x823B0344..0x823B034C)
	// 823B0344: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 823B0348: 48000028  b 0x823b0370
	pc = 0x823B0370; continue 'dispatch;
            }
            0x823B034C => {
    //   block [0x823B034C..0x823B0354)
	// 823B034C: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 823B0350: 48000020  b 0x823b0370
	pc = 0x823B0370; continue 'dispatch;
            }
            0x823B0354 => {
    //   block [0x823B0354..0x823B035C)
	// 823B0354: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 823B0358: 48000018  b 0x823b0370
	pc = 0x823B0370; continue 'dispatch;
            }
            0x823B035C => {
    //   block [0x823B035C..0x823B0364)
	// 823B035C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 823B0360: 48000010  b 0x823b0370
	pc = 0x823B0370; continue 'dispatch;
            }
            0x823B0364 => {
    //   block [0x823B0364..0x823B036C)
	// 823B0364: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 823B0368: 48000008  b 0x823b0370
	pc = 0x823B0370; continue 'dispatch;
            }
            0x823B036C => {
    //   block [0x823B036C..0x823B0370)
	// 823B036C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x823B0370; continue 'dispatch;
            }
            0x823B0370 => {
    //   block [0x823B0370..0x823B0394)
	// 823B0370: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 823B0374: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B0378: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 823B037C: 481966A5  bl 0x82546a20
	ctx.lr = 0x823B0380;
	sub_82546A20(ctx, base);
	// 823B0380: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B0384: 40820010  bne 0x823b0394
	if !ctx.cr[0].eq {
	pc = 0x823B0394; continue 'dispatch;
	}
	// 823B0388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B038C: 48000025  bl 0x823b03b0
	ctx.lr = 0x823B0390;
	sub_823B03B0(ctx, base);
	// 823B0390: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x823B0394; continue 'dispatch;
            }
            0x823B0394 => {
    //   block [0x823B0394..0x823B03B0)
	// 823B0394: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B0398: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B039C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B03A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B03A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B03A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B03AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B03B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B03B0 size=440
    let mut pc: u32 = 0x823B03B0;
    'dispatch: loop {
        match pc {
            0x823B03B0 => {
    //   block [0x823B03B0..0x823B0404)
	// 823B03B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B03B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B03B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B03BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B03C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B03C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B03C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B03CC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 823B03D0: 396B1708  addi r11, r11, 0x1708
	ctx.r[11].s64 = ctx.r[11].s64 + 5896;
	// 823B03D4: A0FF0050  lhz r7, 0x50(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B03D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823B03DC: A15F0048  lhz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 823B03E0: A13F004C  lhz r9, 0x4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 823B03E4: A11F004E  lhz r8, 0x4e(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(78 as u32) ) } as u64;
	// 823B03E8: A0BF0052  lhz r5, 0x52(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(82 as u32) ) } as u64;
	// 823B03EC: B0FF0040  sth r7, 0x40(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[7].u16 ) };
	// 823B03F0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B03F4: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 823B03F8: B13F003C  sth r9, 0x3c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[9].u16 ) };
	// 823B03FC: B11F003E  sth r8, 0x3e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(62 as u32), ctx.r[8].u16 ) };
	// 823B0400: B0BF0042  sth r5, 0x42(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(66 as u32), ctx.r[5].u16 ) };
	pc = 0x823B0404; continue 'dispatch;
            }
            0x823B0404 => {
    //   block [0x823B0404..0x823B044C)
	// 823B0404: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 823B0408: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 823B040C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823B0410: 7D2AFA2E  lhzx r9, r10, r31
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823B0414: 7D2A0735  extsh. r10, r9
	ctx.r[10].s64 = ctx.r[9].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B0418: 41800034  blt 0x823b044c
	if ctx.cr[0].lt {
	pc = 0x823B044C; continue 'dispatch;
	}
	// 823B041C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0420: 2F0A3E80  cmpwi cr6, r10, 0x3e80
	ctx.cr[6].compare_i32(ctx.r[10].s32, 16000, &mut ctx.xer);
	// 823B0424: 39080014  addi r8, r8, 0x14
	ctx.r[8].s64 = ctx.r[8].s64 + 20;
	// 823B0428: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823B042C: 7D28FB2E  sthx r9, r8, r31
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[31].u32), ctx.r[9].u16) };
	// 823B0430: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B0434: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 823B0438: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823B043C: 7CEAFB2E  sthx r7, r10, r31
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[7].u16) };
	// 823B0440: 40990048  ble cr6, 0x823b0488
	if !ctx.cr[6].gt {
	pc = 0x823B0488; continue 'dispatch;
	}
	// 823B0444: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B0448: 48000034  b 0x823b047c
	pc = 0x823B047C; continue 'dispatch;
            }
            0x823B044C => {
    //   block [0x823B044C..0x823B047C)
	// 823B044C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0450: 210AFFFF  subfic r8, r10, -1
	ctx.xer.ca = ctx.r[10].u32 <= -1 as u32;
	ctx.r[8].s64 = (-1 as i64) - ctx.r[10].s64;
	// 823B0454: 2F0AC180  cmpwi cr6, r10, -0x3e80
	ctx.cr[6].compare_i32(ctx.r[10].s32, -16000, &mut ctx.xer);
	// 823B0458: 39290014  addi r9, r9, 0x14
	ctx.r[9].s64 = ctx.r[9].s64 + 20;
	// 823B045C: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B0460: 7CE9FB2E  sthx r7, r9, r31
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32), ctx.r[7].u16) };
	// 823B0464: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B0468: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 823B046C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823B0470: 7D0AFB2E  sthx r8, r10, r31
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[8].u16) };
	// 823B0474: 40980014  bge cr6, 0x823b0488
	if !ctx.cr[6].lt {
	pc = 0x823B0488; continue 'dispatch;
	}
	// 823B0478: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x823B047C; continue 'dispatch;
            }
            0x823B047C => {
    //   block [0x823B047C..0x823B0488)
	// 823B047C: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B0480: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 823B0484: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	pc = 0x823B0488; continue 'dispatch;
            }
            0x823B0488 => {
    //   block [0x823B0488..0x823B04D0)
	// 823B0488: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 823B048C: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 823B0490: 4082FF74  bne 0x823b0404
	if !ctx.cr[0].eq {
	pc = 0x823B0404; continue 'dispatch;
	}
	// 823B0494: 895F004A  lbz r10, 0x4a(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(74 as u32) ) } as u64;
	// 823B0498: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 823B049C: 1D4A7FFF  mulli r10, r10, 0x7fff
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 32767 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823B04A0: 7D4A5BD6  divw r10, r10, r11
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	// 823B04A4: B15F0038  sth r10, 0x38(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u16 ) };
	// 823B04A8: 895F004B  lbz r10, 0x4b(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(75 as u32) ) } as u64;
	// 823B04AC: 1D4A7FFF  mulli r10, r10, 0x7fff
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 32767 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823B04B0: 7D6A5BD6  divw r11, r10, r11
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	// 823B04B4: B17F003A  sth r11, 0x3a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(58 as u32), ctx.r[11].u16 ) };
	// 823B04B8: 897F004A  lbz r11, 0x4a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(74 as u32) ) } as u64;
	// 823B04BC: 2B0B001E  cmplwi cr6, r11, 0x1e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 30 as u32, &mut ctx.xer);
	// 823B04C0: 40990010  ble cr6, 0x823b04d0
	if !ctx.cr[6].gt {
	pc = 0x823B04D0; continue 'dispatch;
	}
	// 823B04C4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B04C8: 656B0001  oris r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 65536;
	// 823B04CC: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	pc = 0x823B04D0; continue 'dispatch;
            }
            0x823B04D0 => {
    //   block [0x823B04D0..0x823B04E8)
	// 823B04D0: 897F004B  lbz r11, 0x4b(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(75 as u32) ) } as u64;
	// 823B04D4: 2B0B001E  cmplwi cr6, r11, 0x1e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 30 as u32, &mut ctx.xer);
	// 823B04D8: 40990010  ble cr6, 0x823b04e8
	if !ctx.cr[6].gt {
	pc = 0x823B04E8; continue 'dispatch;
	}
	// 823B04DC: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B04E0: 656B0002  oris r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 131072;
	// 823B04E4: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	pc = 0x823B04E8; continue 'dispatch;
            }
            0x823B04E8 => {
    //   block [0x823B04E8..0x823B0544)
	// 823B04E8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B04EC: 3BDF0078  addi r30, r31, 0x78
	ctx.r[30].s64 = ctx.r[31].s64 + 120;
	// 823B04F0: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 823B04F4: 7D6958F8  nor r9, r11, r11
	ctx.r[9].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 823B04F8: 7D6A5278  xor r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 823B04FC: 7D4B5838  and r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 823B0500: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 823B0504: 913F0020  stw r9, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 823B0508: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 823B050C: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 823B0510: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B0514: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B0518: 419A002C  beq cr6, 0x823b0544
	if ctx.cr[6].eq {
	pc = 0x823B0544; continue 'dispatch;
	}
	// 823B051C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B0520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B0524: 419A0020  beq cr6, 0x823b0544
	if ctx.cr[6].eq {
	pc = 0x823B0544; continue 'dispatch;
	}
	// 823B0528: 4800F6B1  bl 0x823bfbd8
	ctx.lr = 0x823B052C;
	sub_823BFBD8(ctx, base);
	// 823B052C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 823B0530: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B0534: 80BF001C  lwz r5, 0x1c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B0538: 480000E9  bl 0x823b0620
	ctx.lr = 0x823B053C;
	sub_823B0620(ctx, base);
	// 823B053C: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B0540: 48000008  b 0x823b0548
	pc = 0x823B0548; continue 'dispatch;
            }
            0x823B0544 => {
    //   block [0x823B0544..0x823B0548)
	// 823B0544: 90FF0024  stw r7, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[7].u32 ) };
	pc = 0x823B0548; continue 'dispatch;
            }
            0x823B0548 => {
    //   block [0x823B0548..0x823B0568)
	// 823B0548: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B054C: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 823B0550: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B0554: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B0558: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B055C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B0560: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B0564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B0568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B0568 size=100
    let mut pc: u32 = 0x823B0568;
    'dispatch: loop {
        match pc {
            0x823B0568 => {
    //   block [0x823B0568..0x823B05CC)
	// 823B0568: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 823B056C: 39240012  addi r9, r4, 0x12
	ctx.r[9].s64 = ctx.r[4].s64 + 18;
	// 823B0570: 394BAFE0  addi r10, r11, -0x5020
	ctx.r[10].s64 = ctx.r[11].s64 + -20512;
	// 823B0574: 552B083C  slwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B0578: 5489083C  slwi r9, r4, 1
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B057C: 7D6B1AAE  lhax r11, r11, r3
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as i16) as i64;
	// 823B0580: 7D4952AE  lhax r10, r9, r10
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as i16) as i64;
	// 823B0584: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823B0588: 41800044  blt 0x823b05cc
	if ctx.cr[0].lt {
		sub_823B05CC(ctx, base);
		return;
	}
	// 823B058C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823B0590: 40990084  ble cr6, 0x823b0614
	if !ctx.cr[6].gt {
		sub_823B0614(ctx, base);
		return;
	}
	// 823B0594: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 823B0598: 214A7FFF  subfic r10, r10, 0x7fff
	ctx.xer.ca = ctx.r[10].u32 <= 32767 as u32;
	ctx.r[10].s64 = (32767 as i64) - ctx.r[10].s64;
	// 823B059C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823B05A0: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823B05A4: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 823B05A8: F941FFF8  std r10, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[10].u64 ) };
	// 823B05AC: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B05B0: C9A1FFF8  lfd f13, -8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 823B05B4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823B05B8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823B05BC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823B05C0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823B05C4: EC206824  fdivs f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823B05C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B05CC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B05CC size=72
    let mut pc: u32 = 0x823B05CC;
    'dispatch: loop {
        match pc {
            0x823B05CC => {
    //   block [0x823B05CC..0x823B0614)
	// 823B05CC: 7D4A00D0  neg r10, r10
	ctx.r[10].s64 = -ctx.r[10].s64;
	// 823B05D0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823B05D4: 40980040  bge cr6, 0x823b0614
	if !ctx.cr[6].lt {
		sub_823B0614(ctx, base);
		return;
	}
	// 823B05D8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 823B05DC: 214A8000  subfic r10, r10, -0x8000
	ctx.xer.ca = ctx.r[10].u32 <= -32768 as u32;
	ctx.r[10].s64 = (-32768 as i64) - ctx.r[10].s64;
	// 823B05E0: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823B05E4: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823B05E8: F961FFF8  std r11, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u64 ) };
	// 823B05EC: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 823B05F0: C801FFF8  lfd f0, -8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 823B05F4: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B05F8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823B05FC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823B0600: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823B0604: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823B0608: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823B060C: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 823B0610: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B0614(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823B0614 size=12
    let mut pc: u32 = 0x823B0614;
    'dispatch: loop {
        match pc {
            0x823B0614 => {
    //   block [0x823B0614..0x823B0620)
	// 823B0614: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B0618: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823B061C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B0620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B0620 size=332
    let mut pc: u32 = 0x823B0620;
    'dispatch: loop {
        match pc {
            0x823B0620 => {
    //   block [0x823B0620..0x823B0664)
	// 823B0620: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 823B0624: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 823B0628: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823B062C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 823B0630: 80EA000C  lwz r7, 0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B0634: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B0638: 41820128  beq 0x823b0760
	if ctx.cr[0].eq {
	pc = 0x823B0760; continue 'dispatch;
	}
	// 823B063C: 80CA0010  lwz r6, 0x10(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B0640: 28060000  cmplwi r6, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B0644: 4182011C  beq 0x823b0760
	if ctx.cr[0].eq {
	pc = 0x823B0760; continue 'dispatch;
	}
	// 823B0648: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B064C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823B0650: 41980098  blt cr6, 0x823b06e8
	if ctx.cr[6].lt {
	pc = 0x823B06E8; continue 'dispatch;
	}
	// 823B0654: 409A0108  bne cr6, 0x823b075c
	if !ctx.cr[6].eq {
	pc = 0x823B075C; continue 'dispatch;
	}
	// 823B0658: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 823B065C: 396A0094  addi r11, r10, 0x94
	ctx.r[11].s64 = ctx.r[10].s64 + 148;
	// 823B0660: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	pc = 0x823B0664; continue 'dispatch;
            }
            0x823B0664 => {
    //   block [0x823B0664..0x823B06A8)
	// 823B0664: 54C807FF  clrlwi. r8, r6, 0x1f
	ctx.r[8].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823B0668: 5529F87E  srwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B066C: 41820064  beq 0x823b06d0
	if ctx.cr[0].eq {
	pc = 0x823B06D0; continue 'dispatch;
	}
	// 823B0670: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0674: 80EBFF80  lwz r7, -0x80(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-128 as u32) ) } as u64;
	// 823B0678: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 823B067C: 7CE72050  subf r7, r7, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[7].s64;
	// 823B0680: 4198003C  blt cr6, 0x823b06bc
	if ctx.cr[6].lt {
	pc = 0x823B06BC; continue 'dispatch;
	}
	// 823B0684: 419A0024  beq cr6, 0x823b06a8
	if ctx.cr[6].eq {
	pc = 0x823B06A8; continue 'dispatch;
	}
	// 823B0688: 2B080003  cmplwi cr6, r8, 3
	ctx.cr[6].compare_u32(ctx.r[8].u32, 3 as u32, &mut ctx.xer);
	// 823B068C: 40980048  bge cr6, 0x823b06d4
	if !ctx.cr[6].lt {
	pc = 0x823B06D4; continue 'dispatch;
	}
	// 823B0690: 810A0010  lwz r8, 0x10(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B0694: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823B0698: 4198003C  blt cr6, 0x823b06d4
	if ctx.cr[6].lt {
	pc = 0x823B06D4; continue 'dispatch;
	}
	// 823B069C: 65298000  oris r9, r9, 0x8000
	ctx.r[9].u64 = ctx.r[9].u64 | 2147483648;
	// 823B06A0: 908BFF80  stw r4, -0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-128 as u32), ctx.r[4].u32 ) };
	// 823B06A4: 48000030  b 0x823b06d4
	pc = 0x823B06D4; continue 'dispatch;
            }
            0x823B06A8 => {
    //   block [0x823B06A8..0x823B06BC)
	// 823B06A8: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B06AC: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823B06B0: 41980024  blt cr6, 0x823b06d4
	if ctx.cr[6].lt {
	pc = 0x823B06D4; continue 'dispatch;
	}
	// 823B06B4: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 823B06B8: 48000008  b 0x823b06c0
	pc = 0x823B06C0; continue 'dispatch;
            }
            0x823B06BC => {
    //   block [0x823B06BC..0x823B06C0)
	// 823B06BC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x823B06C0; continue 'dispatch;
            }
            0x823B06C0 => {
    //   block [0x823B06C0..0x823B06D0)
	// 823B06C0: 908BFF80  stw r4, -0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-128 as u32), ctx.r[4].u32 ) };
	// 823B06C4: 65298000  oris r9, r9, 0x8000
	ctx.r[9].u64 = ctx.r[9].u64 | 2147483648;
	// 823B06C8: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823B06CC: 48000008  b 0x823b06d4
	pc = 0x823B06D4; continue 'dispatch;
            }
            0x823B06D0 => {
    //   block [0x823B06D0..0x823B06D4)
	// 823B06D0: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x823B06D4; continue 'dispatch;
            }
            0x823B06D4 => {
    //   block [0x823B06D4..0x823B06E8)
	// 823B06D4: 3463FFFF  addic. r3, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 823B06D8: 54C6F87E  srwi r6, r6, 1
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 823B06DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823B06E0: 4082FF84  bne 0x823b0664
	if !ctx.cr[0].eq {
	pc = 0x823B0664; continue 'dispatch;
	}
	// 823B06E4: 48000078  b 0x823b075c
	pc = 0x823B075C; continue 'dispatch;
            }
            0x823B06E8 => {
    //   block [0x823B06E8..0x823B0734)
	// 823B06E8: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 823B06EC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 823B06F0: 419A0068  beq cr6, 0x823b0758
	if ctx.cr[6].eq {
	pc = 0x823B0758; continue 'dispatch;
	}
	// 823B06F4: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B06F8: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823B06FC: 409A0048  bne cr6, 0x823b0744
	if !ctx.cr[6].eq {
	pc = 0x823B0744; continue 'dispatch;
	}
	// 823B0700: 816A0110  lwz r11, 0x110(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(272 as u32) ) } as u64;
	// 823B0704: 810A0090  lwz r8, 0x90(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 823B0708: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823B070C: 7D082050  subf r8, r8, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 823B0710: 41980034  blt cr6, 0x823b0744
	if ctx.cr[6].lt {
	pc = 0x823B0744; continue 'dispatch;
	}
	// 823B0714: 419A0020  beq cr6, 0x823b0734
	if ctx.cr[6].eq {
	pc = 0x823B0734; continue 'dispatch;
	}
	// 823B0718: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 823B071C: 40980040  bge cr6, 0x823b075c
	if !ctx.cr[6].lt {
	pc = 0x823B075C; continue 'dispatch;
	}
	// 823B0720: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 823B0724: 41980038  blt cr6, 0x823b075c
	if ctx.cr[6].lt {
	pc = 0x823B075C; continue 'dispatch;
	}
	// 823B0728: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 823B072C: 908A0090  stw r4, 0x90(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(144 as u32), ctx.r[4].u32 ) };
	// 823B0730: 4800002C  b 0x823b075c
	pc = 0x823B075C; continue 'dispatch;
            }
            0x823B0734 => {
    //   block [0x823B0734..0x823B0744)
	// 823B0734: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 823B0738: 41980024  blt cr6, 0x823b075c
	if ctx.cr[6].lt {
	pc = 0x823B075C; continue 'dispatch;
	}
	// 823B073C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823B0740: 48000008  b 0x823b0748
	pc = 0x823B0748; continue 'dispatch;
            }
            0x823B0744 => {
    //   block [0x823B0744..0x823B0748)
	// 823B0744: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x823B0748; continue 'dispatch;
            }
            0x823B0748 => {
    //   block [0x823B0748..0x823B0758)
	// 823B0748: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 823B074C: 908A0090  stw r4, 0x90(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(144 as u32), ctx.r[4].u32 ) };
	// 823B0750: 916A0110  stw r11, 0x110(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 823B0754: 48000008  b 0x823b075c
	pc = 0x823B075C; continue 'dispatch;
            }
            0x823B0758 => {
    //   block [0x823B0758..0x823B075C)
	// 823B0758: 93EA0110  stw r31, 0x110(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(272 as u32), ctx.r[31].u32 ) };
	pc = 0x823B075C; continue 'dispatch;
            }
            0x823B075C => {
    //   block [0x823B075C..0x823B0760)
	// 823B075C: 90AA0008  stw r5, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	pc = 0x823B0760; continue 'dispatch;
            }
            0x823B0760 => {
    //   block [0x823B0760..0x823B076C)
	// 823B0760: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 823B0764: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 823B0768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B0770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B0770 size=68
    let mut pc: u32 = 0x823B0770;
    'dispatch: loop {
        match pc {
            0x823B0770 => {
    //   block [0x823B0770..0x823B079C)
	// 823B0770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B0774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B0778: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B077C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B0780: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B0784: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B0788: 396B1780  addi r11, r11, 0x1780
	ctx.r[11].s64 = ctx.r[11].s64 + 6016;
	// 823B078C: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B0790: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B0794: 41820008  beq 0x823b079c
	if ctx.cr[0].eq {
	pc = 0x823B079C; continue 'dispatch;
	}
	// 823B0798: 48182421  bl 0x82532bb8
	ctx.lr = 0x823B079C;
	sub_82532BB8(ctx, base);
	pc = 0x823B079C; continue 'dispatch;
            }
            0x823B079C => {
    //   block [0x823B079C..0x823B07B4)
	// 823B079C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B07A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823B07A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B07A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B07AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B07B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B07B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B07B8 size=68
    let mut pc: u32 = 0x823B07B8;
    'dispatch: loop {
        match pc {
            0x823B07B8 => {
    //   block [0x823B07B8..0x823B07E4)
	// 823B07B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B07BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B07C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B07C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B07C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B07CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B07D0: 396B1758  addi r11, r11, 0x1758
	ctx.r[11].s64 = ctx.r[11].s64 + 5976;
	// 823B07D4: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B07D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B07DC: 41820008  beq 0x823b07e4
	if ctx.cr[0].eq {
	pc = 0x823B07E4; continue 'dispatch;
	}
	// 823B07E0: 481823D9  bl 0x82532bb8
	ctx.lr = 0x823B07E4;
	sub_82532BB8(ctx, base);
	pc = 0x823B07E4; continue 'dispatch;
            }
            0x823B07E4 => {
    //   block [0x823B07E4..0x823B07FC)
	// 823B07E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B07E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823B07EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B07F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B07F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B07F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B0800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B0800 size=120
    let mut pc: u32 = 0x823B0800;
    'dispatch: loop {
        match pc {
            0x823B0800 => {
    //   block [0x823B0800..0x823B0878)
	// 823B0800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B0804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B0808: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B080C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B0810: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B0814: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B0818: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823B081C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 823B0820: 38A00024  li r5, 0x24
	ctx.r[5].s64 = 36;
	// 823B0824: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B0828: 481849A9  bl 0x825351d0
	ctx.lr = 0x823B082C;
	sub_825351D0(ctx, base);
	// 823B082C: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 823B0830: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B0834: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 823B0838: 48184999  bl 0x825351d0
	ctx.lr = 0x823B083C;
	sub_825351D0(ctx, base);
	// 823B083C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823B0840: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 823B0844: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823B0848: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 823B084C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823B0850: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 823B0854: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 823B0858: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 823B085C: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 823B0860: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B0864: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B0868: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B086C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B0870: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B0874: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B0878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B0878 size=240
    let mut pc: u32 = 0x823B0878;
    'dispatch: loop {
        match pc {
            0x823B0878 => {
    //   block [0x823B0878..0x823B089C)
	// 823B0878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B087C: 48184835  bl 0x825350b0
	ctx.lr = 0x823B0880;
	sub_82535080(ctx, base);
	// 823B0880: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B0884: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823B0888: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823B088C: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 823B0890: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 823B0894: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 823B0898: 3BDC0028  addi r30, r28, 0x28
	ctx.r[30].s64 = ctx.r[28].s64 + 40;
	pc = 0x823B089C; continue 'dispatch;
            }
            0x823B089C => {
    //   block [0x823B089C..0x823B08C8)
	// 823B089C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823B08A0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 823B08A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B08A8: 48196251  bl 0x82546af8
	ctx.lr = 0x823B08AC;
	sub_82546AF8(ctx, base);
	// 823B08AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B08B0: 41820018  beq 0x823b08c8
	if ctx.cr[0].eq {
	pc = 0x823B08C8; continue 'dispatch;
	}
	// 823B08B4: 2B0310D2  cmplwi cr6, r3, 0x10d2
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4306 as u32, &mut ctx.xer);
	// 823B08B8: 419A0010  beq cr6, 0x823b08c8
	if ctx.cr[6].eq {
	pc = 0x823B08C8; continue 'dispatch;
	}
	// 823B08BC: 2B03048F  cmplwi cr6, r3, 0x48f
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1167 as u32, &mut ctx.xer);
	// 823B08C0: 419A0008  beq cr6, 0x823b08c8
	if ctx.cr[6].eq {
	pc = 0x823B08C8; continue 'dispatch;
	}
	// 823B08C4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	pc = 0x823B08C8; continue 'dispatch;
            }
            0x823B08C8 => {
    //   block [0x823B08C8..0x823B0908)
	// 823B08C8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 823B08CC: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823B08D0: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 823B08D4: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823B08D8: 2B1F0004  cmplwi cr6, r31, 4
	ctx.cr[6].compare_u32(ctx.r[31].u32, 4 as u32, &mut ctx.xer);
	// 823B08DC: 4198FFC0  blt cr6, 0x823b089c
	if ctx.cr[6].lt {
	pc = 0x823B089C; continue 'dispatch;
	}
	// 823B08E0: 3BE0FFFE  li r31, -2
	ctx.r[31].s64 = -2;
	// 823B08E4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823B08E8: 409A0070  bne cr6, 0x823b0958
	if !ctx.cr[6].eq {
	pc = 0x823B0958; continue 'dispatch;
	}
	// 823B08EC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B08F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B08F4: 419A0014  beq cr6, 0x823b0908
	if ctx.cr[6].eq {
	pc = 0x823B0908; continue 'dispatch;
	}
	// 823B08F8: 2B0B048F  cmplwi cr6, r11, 0x48f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1167 as u32, &mut ctx.xer);
	// 823B08FC: 419A002C  beq cr6, 0x823b0928
	if ctx.cr[6].eq {
	pc = 0x823B0928; continue 'dispatch;
	}
	// 823B0900: 2B0B10D2  cmplwi cr6, r11, 0x10d2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4306 as u32, &mut ctx.xer);
	// 823B0904: 409A0054  bne cr6, 0x823b0958
	if !ctx.cr[6].eq {
	pc = 0x823B0958; continue 'dispatch;
	}
	pc = 0x823B0908; continue 'dispatch;
            }
            0x823B0908 => {
    //   block [0x823B0908..0x823B0928)
	// 823B0908: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 823B090C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 823B0910: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823B0914: 4198003C  blt cr6, 0x823b0950
	if ctx.cr[6].lt {
	pc = 0x823B0950; continue 'dispatch;
	}
	// 823B0918: 409A0040  bne cr6, 0x823b0958
	if !ctx.cr[6].eq {
	pc = 0x823B0958; continue 'dispatch;
	}
	// 823B091C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823B0920: 48000199  bl 0x823b0ab8
	ctx.lr = 0x823B0924;
	sub_823B0AB8(ctx, base);
	// 823B0924: 48000034  b 0x823b0958
	pc = 0x823B0958; continue 'dispatch;
            }
            0x823B0928 => {
    //   block [0x823B0928..0x823B0938)
	// 823B0928: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 823B092C: 935C0014  stw r26, 0x14(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	// 823B0930: 397C0020  addi r11, r28, 0x20
	ctx.r[11].s64 = ctx.r[28].s64 + 32;
	// 823B0934: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	pc = 0x823B0938; continue 'dispatch;
            }
            0x823B0938 => {
    //   block [0x823B0938..0x823B0950)
	// 823B0938: B34BFFF8  sth r26, -8(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[26].u16 ) };
	// 823B093C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B0940: B34B0000  sth r26, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u16 ) };
	// 823B0944: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 823B0948: 4082FFF0  bne 0x823b0938
	if !ctx.cr[0].eq {
	pc = 0x823B0938; continue 'dispatch;
	}
	// 823B094C: 4800000C  b 0x823b0958
	pc = 0x823B0958; continue 'dispatch;
            }
            0x823B0950 => {
    //   block [0x823B0950..0x823B0958)
	// 823B0950: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823B0954: 4800002D  bl 0x823b0980
	ctx.lr = 0x823B0958;
	sub_823B0980(ctx, base);
	pc = 0x823B0958; continue 'dispatch;
            }
            0x823B0958 => {
    //   block [0x823B0958..0x823B0968)
	// 823B0958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B095C: 93FC0008  stw r31, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 823B0960: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823B0964: 4818479C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B0980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B0980 size=312
    let mut pc: u32 = 0x823B0980;
    'dispatch: loop {
        match pc {
            0x823B0980 => {
    //   block [0x823B0980..0x823B0A0C)
	// 823B0980: 396000E0  li r11, 0xe0
	ctx.r[11].s64 = 224;
	// 823B0984: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 823B0988: 3923002C  addi r9, r3, 0x2c
	ctx.r[9].s64 = ctx.r[3].s64 + 44;
	// 823B098C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B0990: 9161FFC0  stw r11, -0x40(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[11].u32 ) };
	// 823B0994: 396000E1  li r11, 0xe1
	ctx.r[11].s64 = 225;
	// 823B0998: 90C1FFC4  stw r6, -0x3c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-60 as u32), ctx.r[6].u32 ) };
	// 823B099C: 9161FFC8  stw r11, -0x38(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[11].u32 ) };
	// 823B09A0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 823B09A4: 9161FFCC  stw r11, -0x34(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-52 as u32), ctx.r[11].u32 ) };
	// 823B09A8: 396000E2  li r11, 0xe2
	ctx.r[11].s64 = 226;
	// 823B09AC: 9161FFD0  stw r11, -0x30(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[11].u32 ) };
	// 823B09B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823B09B4: 9161FFD4  stw r11, -0x2c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-44 as u32), ctx.r[11].u32 ) };
	// 823B09B8: 396000E3  li r11, 0xe3
	ctx.r[11].s64 = 227;
	// 823B09BC: 9161FFD8  stw r11, -0x28(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[11].u32 ) };
	// 823B09C0: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 823B09C4: 9161FFDC  stw r11, -0x24(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-36 as u32), ctx.r[11].u32 ) };
	// 823B09C8: 396000E4  li r11, 0xe4
	ctx.r[11].s64 = 228;
	// 823B09CC: 9161FFE0  stw r11, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[11].u32 ) };
	// 823B09D0: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 823B09D4: 9161FFE4  stw r11, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[11].u32 ) };
	// 823B09D8: 396000E5  li r11, 0xe5
	ctx.r[11].s64 = 229;
	// 823B09DC: 9161FFE8  stw r11, -0x18(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[11].u32 ) };
	// 823B09E0: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 823B09E4: 9161FFEC  stw r11, -0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-20 as u32), ctx.r[11].u32 ) };
	// 823B09E8: 396000E6  li r11, 0xe6
	ctx.r[11].s64 = 230;
	// 823B09EC: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 823B09F0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823B09F4: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 823B09F8: 396000E7  li r11, 0xe7
	ctx.r[11].s64 = 231;
	// 823B09FC: 9161FFF8  stw r11, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 823B0A00: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 823B0A04: 9161FFFC  stw r11, -4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 823B0A08: 39630018  addi r11, r3, 0x18
	ctx.r[11].s64 = ctx.r[3].s64 + 24;
	pc = 0x823B0A0C; continue 'dispatch;
            }
            0x823B0A0C => {
    //   block [0x823B0A0C..0x823B0A30)
	// 823B0A0C: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0A10: 554807FF  clrlwi. r8, r10, 0x1f
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823B0A14: 4182004C  beq 0x823b0a60
	if ctx.cr[0].eq {
	pc = 0x823B0A60; continue 'dispatch;
	}
	// 823B0A18: 88A90003  lbz r5, 3(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(3 as u32) ) } as u64;
	// 823B0A1C: 3941FFC4  addi r10, r1, -0x3c
	ctx.r[10].s64 = ctx.r[1].s64 + -60;
	// 823B0A20: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 823B0A24: B0AB0000  sth r5, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u16 ) };
	// 823B0A28: A0A9FFFE  lhz r5, -2(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(-2 as u32) ) } as u64;
	// 823B0A2C: B0AB0008  sth r5, 8(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u16 ) };
	pc = 0x823B0A30; continue 'dispatch;
            }
            0x823B0A30 => {
    //   block [0x823B0A30..0x823B0A50)
	// 823B0A30: A0AB0000  lhz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0A34: 808AFFFC  lwz r4, -4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 823B0A38: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 823B0A3C: 409A0014  bne cr6, 0x823b0a50
	if !ctx.cr[6].eq {
	pc = 0x823B0A50; continue 'dispatch;
	}
	// 823B0A40: 80A30014  lwz r5, 0x14(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B0A44: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0A48: 7CA52378  or r5, r5, r4
	ctx.r[5].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 823B0A4C: 90A30014  stw r5, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	pc = 0x823B0A50; continue 'dispatch;
            }
            0x823B0A50 => {
    //   block [0x823B0A50..0x823B0A60)
	// 823B0A50: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823B0A54: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 823B0A58: 4082FFD8  bne 0x823b0a30
	if !ctx.cr[0].eq {
	pc = 0x823B0A30; continue 'dispatch;
	}
	// 823B0A5C: 48000048  b 0x823b0aa4
	pc = 0x823B0AA4; continue 'dispatch;
            }
            0x823B0A60 => {
    //   block [0x823B0A60..0x823B0A78)
	// 823B0A60: 554A07BD  rlwinm. r10, r10, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B0A64: B0EB0000  sth r7, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 823B0A68: B0EB0008  sth r7, 8(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u16 ) };
	// 823B0A6C: 41820038  beq 0x823b0aa4
	if ctx.cr[0].eq {
	pc = 0x823B0AA4; continue 'dispatch;
	}
	// 823B0A70: 3941FFC4  addi r10, r1, -0x3c
	ctx.r[10].s64 = ctx.r[1].s64 + -60;
	// 823B0A74: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	pc = 0x823B0A78; continue 'dispatch;
            }
            0x823B0A78 => {
    //   block [0x823B0A78..0x823B0A98)
	// 823B0A78: 88A90003  lbz r5, 3(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(3 as u32) ) } as u64;
	// 823B0A7C: 808AFFFC  lwz r4, -4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 823B0A80: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 823B0A84: 409A0014  bne cr6, 0x823b0a98
	if !ctx.cr[6].eq {
	pc = 0x823B0A98; continue 'dispatch;
	}
	// 823B0A88: 80A30014  lwz r5, 0x14(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B0A8C: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0A90: 7CA52078  andc r5, r5, r4
	ctx.r[5].u64 = ctx.r[5].u64 & !ctx.r[4].u64;
	// 823B0A94: 90A30014  stw r5, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	pc = 0x823B0A98; continue 'dispatch;
            }
            0x823B0A98 => {
    //   block [0x823B0A98..0x823B0AA4)
	// 823B0A98: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823B0A9C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 823B0AA0: 4082FFD8  bne 0x823b0a78
	if !ctx.cr[0].eq {
	pc = 0x823B0A78; continue 'dispatch;
	}
	pc = 0x823B0AA4; continue 'dispatch;
            }
            0x823B0AA4 => {
    //   block [0x823B0AA4..0x823B0AB8)
	// 823B0AA4: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 823B0AA8: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 823B0AAC: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 823B0AB0: 4082FF5C  bne 0x823b0a0c
	if !ctx.cr[0].eq {
	pc = 0x823B0A0C; continue 'dispatch;
	}
	// 823B0AB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B0AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B0AB8 size=472
    let mut pc: u32 = 0x823B0AB8;
    'dispatch: loop {
        match pc {
            0x823B0AB8 => {
    //   block [0x823B0AB8..0x823B0B44)
	// 823B0AB8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 823B0ABC: 396000E0  li r11, 0xe0
	ctx.r[11].s64 = 224;
	// 823B0AC0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 823B0AC4: 38C3002F  addi r6, r3, 0x2f
	ctx.r[6].s64 = ctx.r[3].s64 + 47;
	// 823B0AC8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B0ACC: 9161FFB0  stw r11, -0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.r[11].u32 ) };
	// 823B0AD0: 396000E1  li r11, 0xe1
	ctx.r[11].s64 = 225;
	// 823B0AD4: 9081FFB4  stw r4, -0x4c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-76 as u32), ctx.r[4].u32 ) };
	// 823B0AD8: 9161FFB8  stw r11, -0x48(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.r[11].u32 ) };
	// 823B0ADC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 823B0AE0: 9161FFBC  stw r11, -0x44(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-68 as u32), ctx.r[11].u32 ) };
	// 823B0AE4: 396000E2  li r11, 0xe2
	ctx.r[11].s64 = 226;
	// 823B0AE8: 9161FFC0  stw r11, -0x40(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[11].u32 ) };
	// 823B0AEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823B0AF0: 9161FFC4  stw r11, -0x3c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-60 as u32), ctx.r[11].u32 ) };
	// 823B0AF4: 396000E3  li r11, 0xe3
	ctx.r[11].s64 = 227;
	// 823B0AF8: 9161FFC8  stw r11, -0x38(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[11].u32 ) };
	// 823B0AFC: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 823B0B00: 9161FFCC  stw r11, -0x34(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-52 as u32), ctx.r[11].u32 ) };
	// 823B0B04: 396000E4  li r11, 0xe4
	ctx.r[11].s64 = 228;
	// 823B0B08: 9161FFD0  stw r11, -0x30(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[11].u32 ) };
	// 823B0B0C: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 823B0B10: 9161FFD4  stw r11, -0x2c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-44 as u32), ctx.r[11].u32 ) };
	// 823B0B14: 396000E5  li r11, 0xe5
	ctx.r[11].s64 = 229;
	// 823B0B18: 9161FFD8  stw r11, -0x28(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[11].u32 ) };
	// 823B0B1C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 823B0B20: 9161FFDC  stw r11, -0x24(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-36 as u32), ctx.r[11].u32 ) };
	// 823B0B24: 396000E6  li r11, 0xe6
	ctx.r[11].s64 = 230;
	// 823B0B28: 9161FFE0  stw r11, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[11].u32 ) };
	// 823B0B2C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823B0B30: 9161FFE4  stw r11, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[11].u32 ) };
	// 823B0B34: 396000E7  li r11, 0xe7
	ctx.r[11].s64 = 231;
	// 823B0B38: 9161FFE8  stw r11, -0x18(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[11].u32 ) };
	// 823B0B3C: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 823B0B40: 9161FFEC  stw r11, -0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-20 as u32), ctx.r[11].u32 ) };
	pc = 0x823B0B44; continue 'dispatch;
            }
            0x823B0B44 => {
    //   block [0x823B0B44..0x823B0B68)
	// 823B0B44: A166FFFD  lhz r11, -3(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(-3 as u32) ) } as u64;
	// 823B0B48: 89460000  lbz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0B4C: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 823B0B50: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823B0B54: 418200A8  beq 0x823b0bfc
	if ctx.cr[0].eq {
	pc = 0x823B0BFC; continue 'dispatch;
	}
	// 823B0B58: 39430018  addi r10, r3, 0x18
	ctx.r[10].s64 = ctx.r[3].s64 + 24;
	// 823B0B5C: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 823B0B60: 54E8043E  clrlwi r8, r7, 0x10
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x0000FFFFu64;
	// 823B0B64: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x823B0B68; continue 'dispatch;
            }
            0x823B0B68 => {
    //   block [0x823B0B68..0x823B0B88)
	// 823B0B68: A3EB0000  lhz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0B6C: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823B0B70: 419A0054  beq cr6, 0x823b0bc4
	if ctx.cr[6].eq {
	pc = 0x823B0BC4; continue 'dispatch;
	}
	// 823B0B74: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823B0B78: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 823B0B7C: 2B090004  cmplwi cr6, r9, 4
	ctx.cr[6].compare_u32(ctx.r[9].u32, 4 as u32, &mut ctx.xer);
	// 823B0B80: 4198FFE8  blt cr6, 0x823b0b68
	if ctx.cr[6].lt {
	pc = 0x823B0B68; continue 'dispatch;
	}
	// 823B0B84: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x823B0B88; continue 'dispatch;
            }
            0x823B0B88 => {
    //   block [0x823B0B88..0x823B0BA8)
	// 823B0B88: A12A0000  lhz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0B8C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B0B90: 41820018  beq 0x823b0ba8
	if ctx.cr[0].eq {
	pc = 0x823B0BA8; continue 'dispatch;
	}
	// 823B0B94: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823B0B98: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 823B0B9C: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 823B0BA0: 4198FFE8  blt cr6, 0x823b0b88
	if ctx.cr[6].lt {
	pc = 0x823B0B88; continue 'dispatch;
	}
	// 823B0BA4: 48000020  b 0x823b0bc4
	pc = 0x823B0BC4; continue 'dispatch;
            }
            0x823B0BA8 => {
    //   block [0x823B0BA8..0x823B0BC4)
	// 823B0BA8: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 823B0BAC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 823B0BB0: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823B0BB4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B0BB8: 7CEA1B2E  sthx r7, r10, r3
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32), ctx.r[7].u16) };
	// 823B0BBC: A146FFFB  lhz r10, -5(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(-5 as u32) ) } as u64;
	// 823B0BC0: 7D4B1B2E  sthx r10, r11, r3
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u16) };
	pc = 0x823B0BC4; continue 'dispatch;
            }
            0x823B0BC4 => {
    //   block [0x823B0BC4..0x823B0BCC)
	// 823B0BC4: 3961FFB4  addi r11, r1, -0x4c
	ctx.r[11].s64 = ctx.r[1].s64 + -76;
	// 823B0BC8: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	pc = 0x823B0BCC; continue 'dispatch;
            }
            0x823B0BCC => {
    //   block [0x823B0BCC..0x823B0BEC)
	// 823B0BCC: 89260000  lbz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0BD0: 810BFFFC  lwz r8, -4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 823B0BD4: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823B0BD8: 409A0014  bne cr6, 0x823b0bec
	if !ctx.cr[6].eq {
	pc = 0x823B0BEC; continue 'dispatch;
	}
	// 823B0BDC: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B0BE0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0BE4: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 823B0BE8: 91230014  stw r9, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	pc = 0x823B0BEC; continue 'dispatch;
            }
            0x823B0BEC => {
    //   block [0x823B0BEC..0x823B0BFC)
	// 823B0BEC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B0BF0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 823B0BF4: 4082FFD8  bne 0x823b0bcc
	if !ctx.cr[0].eq {
	pc = 0x823B0BCC; continue 'dispatch;
	}
	// 823B0BF8: 48000084  b 0x823b0c7c
	pc = 0x823B0C7C; continue 'dispatch;
            }
            0x823B0BFC => {
    //   block [0x823B0BFC..0x823B0C10)
	// 823B0BFC: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B0C00: 4182007C  beq 0x823b0c7c
	if ctx.cr[0].eq {
	pc = 0x823B0C7C; continue 'dispatch;
	}
	// 823B0C04: 5549063E  clrlwi r9, r10, 0x18
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 823B0C08: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 823B0C0C: 39430018  addi r10, r3, 0x18
	ctx.r[10].s64 = ctx.r[3].s64 + 24;
	pc = 0x823B0C10; continue 'dispatch;
            }
            0x823B0C10 => {
    //   block [0x823B0C10..0x823B0C30)
	// 823B0C10: A10A0000  lhz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0C14: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823B0C18: 419A0018  beq cr6, 0x823b0c30
	if ctx.cr[6].eq {
	pc = 0x823B0C30; continue 'dispatch;
	}
	// 823B0C1C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823B0C20: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 823B0C24: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 823B0C28: 4198FFE8  blt cr6, 0x823b0c10
	if ctx.cr[6].lt {
	pc = 0x823B0C10; continue 'dispatch;
	}
	// 823B0C2C: 4800001C  b 0x823b0c48
	pc = 0x823B0C48; continue 'dispatch;
            }
            0x823B0C30 => {
    //   block [0x823B0C30..0x823B0C48)
	// 823B0C30: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 823B0C34: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 823B0C38: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823B0C3C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B0C40: 7CAA1B2E  sthx r5, r10, r3
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32), ctx.r[5].u16) };
	// 823B0C44: 7CAB1B2E  sthx r5, r11, r3
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[5].u16) };
	pc = 0x823B0C48; continue 'dispatch;
            }
            0x823B0C48 => {
    //   block [0x823B0C48..0x823B0C50)
	// 823B0C48: 3961FFB4  addi r11, r1, -0x4c
	ctx.r[11].s64 = ctx.r[1].s64 + -76;
	// 823B0C4C: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	pc = 0x823B0C50; continue 'dispatch;
            }
            0x823B0C50 => {
    //   block [0x823B0C50..0x823B0C70)
	// 823B0C50: 89260000  lbz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0C54: 810BFFFC  lwz r8, -4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 823B0C58: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823B0C5C: 409A0014  bne cr6, 0x823b0c70
	if !ctx.cr[6].eq {
	pc = 0x823B0C70; continue 'dispatch;
	}
	// 823B0C60: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B0C64: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0C68: 7D294078  andc r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 & !ctx.r[8].u64;
	// 823B0C6C: 91230014  stw r9, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	pc = 0x823B0C70; continue 'dispatch;
            }
            0x823B0C70 => {
    //   block [0x823B0C70..0x823B0C7C)
	// 823B0C70: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B0C74: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 823B0C78: 4082FFD8  bne 0x823b0c50
	if !ctx.cr[0].eq {
	pc = 0x823B0C50; continue 'dispatch;
	}
	pc = 0x823B0C7C; continue 'dispatch;
            }
            0x823B0C7C => {
    //   block [0x823B0C7C..0x823B0C90)
	// 823B0C7C: 3484FFFF  addic. r4, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823B0C80: 38C60008  addi r6, r6, 8
	ctx.r[6].s64 = ctx.r[6].s64 + 8;
	// 823B0C84: 4082FEC0  bne 0x823b0b44
	if !ctx.cr[0].eq {
	pc = 0x823B0B44; continue 'dispatch;
	}
	// 823B0C88: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 823B0C8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B0C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B0C90 size=132
    let mut pc: u32 = 0x823B0C90;
    'dispatch: loop {
        match pc {
            0x823B0C90 => {
    //   block [0x823B0C90..0x823B0D08)
	// 823B0C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B0C94: 48184421  bl 0x825350b4
	ctx.lr = 0x823B0C98;
	sub_82535080(ctx, base);
	// 823B0C98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B0C9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B0CA0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823B0CA4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 823B0CA8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823B0CAC: 419A005C  beq cr6, 0x823b0d08
	if ctx.cr[6].eq {
	pc = 0x823B0D08; continue 'dispatch;
	}
	// 823B0CB0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823B0CB4: 419A0054  beq cr6, 0x823b0d08
	if ctx.cr[6].eq {
	pc = 0x823B0D08; continue 'dispatch;
	}
	// 823B0CB8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0CBC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 823B0CC0: 41980048  blt cr6, 0x823b0d08
	if ctx.cr[6].lt {
	pc = 0x823B0D08; continue 'dispatch;
	}
	// 823B0CC4: 3880003A  li r4, 0x3a
	ctx.r[4].s64 = 58;
	// 823B0CC8: 481826A9  bl 0x82533370
	ctx.lr = 0x823B0CCC;
	sub_82533370(ctx, base);
	// 823B0CCC: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823B0CD0: 41820038  beq 0x823b0d08
	if ctx.cr[0].eq {
	pc = 0x823B0D08; continue 'dispatch;
	}
	// 823B0CD4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0CD8: 7FFEE850  subf r31, r30, r29
	ctx.r[31].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 823B0CDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823B0CE0: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823B0CE4: 40980024  bge cr6, 0x823b0d08
	if !ctx.cr[6].lt {
	pc = 0x823B0D08; continue 'dispatch;
	}
	// 823B0CE8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823B0CEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B0CF0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823B0CF4: 48183E5D  bl 0x82534b50
	ctx.lr = 0x823B0CF8;
	sub_82534B50(ctx, base);
	// 823B0CF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823B0CFC: 387D0001  addi r3, r29, 1
	ctx.r[3].s64 = ctx.r[29].s64 + 1;
	// 823B0D00: 7D7FD9AE  stbx r11, r31, r27
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[27].u32), ctx.r[11].u8) };
	// 823B0D04: 48000008  b 0x823b0d0c
	pc = 0x823B0D0C; continue 'dispatch;
            }
            0x823B0D08 => {
    //   block [0x823B0D08..0x823B0D0C)
	// 823B0D08: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823B0D0C; continue 'dispatch;
            }
            0x823B0D0C => {
    //   block [0x823B0D0C..0x823B0D14)
	// 823B0D0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823B0D10: 481843F4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B0D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B0D18 size=440
    let mut pc: u32 = 0x823B0D18;
    'dispatch: loop {
        match pc {
            0x823B0D18 => {
    //   block [0x823B0D18..0x823B0D40)
	// 823B0D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B0D1C: 48184389  bl 0x825350a4
	ctx.lr = 0x823B0D20;
	sub_82535080(ctx, base);
	// 823B0D20: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B0D24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B0D28: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 823B0D2C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 823B0D30: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 823B0D34: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823B0D38: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 823B0D3C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x823B0D40; continue 'dispatch;
            }
            0x823B0D40 => {
    //   block [0x823B0D40..0x823B0D70)
	// 823B0D40: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0D44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823B0D48: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823B0D4C: 409AFFF4  bne cr6, 0x823b0d40
	if !ctx.cr[6].eq {
	pc = 0x823B0D40; continue 'dispatch;
	}
	// 823B0D50: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 823B0D54: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 823B0D58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823B0D5C: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 823B0D60: 557C003E  slwi r28, r11, 0
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 823B0D64: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 823B0D68: 7D7CFA14  add r11, r28, r31
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 823B0D6C: 48000040  b 0x823b0dac
	pc = 0x823B0DAC; continue 'dispatch;
            }
            0x823B0D70 => {
    //   block [0x823B0D70..0x823B0DA8)
	// 823B0D70: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0D74: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 823B0D78: 2F0A002A  cmpwi cr6, r10, 0x2a
	ctx.cr[6].compare_i32(ctx.r[10].s32, 42, &mut ctx.xer);
	// 823B0D7C: 419A002C  beq cr6, 0x823b0da8
	if ctx.cr[6].eq {
	pc = 0x823B0DA8; continue 'dispatch;
	}
	// 823B0D80: 2F0A002F  cmpwi cr6, r10, 0x2f
	ctx.cr[6].compare_i32(ctx.r[10].s32, 47, &mut ctx.xer);
	// 823B0D84: 419A0038  beq cr6, 0x823b0dbc
	if ctx.cr[6].eq {
	pc = 0x823B0DBC; continue 'dispatch;
	}
	// 823B0D88: 2F0A003F  cmpwi cr6, r10, 0x3f
	ctx.cr[6].compare_i32(ctx.r[10].s32, 63, &mut ctx.xer);
	// 823B0D8C: 419A001C  beq cr6, 0x823b0da8
	if ctx.cr[6].eq {
	pc = 0x823B0DA8; continue 'dispatch;
	}
	// 823B0D90: 2F0A005B  cmpwi cr6, r10, 0x5b
	ctx.cr[6].compare_i32(ctx.r[10].s32, 91, &mut ctx.xer);
	// 823B0D94: 419A0014  beq cr6, 0x823b0da8
	if ctx.cr[6].eq {
	pc = 0x823B0DA8; continue 'dispatch;
	}
	// 823B0D98: 2F0A005C  cmpwi cr6, r10, 0x5c
	ctx.cr[6].compare_i32(ctx.r[10].s32, 92, &mut ctx.xer);
	// 823B0D9C: 419A0020  beq cr6, 0x823b0dbc
	if ctx.cr[6].eq {
	pc = 0x823B0DBC; continue 'dispatch;
	}
	// 823B0DA0: 2F0A005D  cmpwi cr6, r10, 0x5d
	ctx.cr[6].compare_i32(ctx.r[10].s32, 93, &mut ctx.xer);
	// 823B0DA4: 409A0008  bne cr6, 0x823b0dac
	if !ctx.cr[6].eq {
	pc = 0x823B0DAC; continue 'dispatch;
	}
	pc = 0x823B0DA8; continue 'dispatch;
            }
            0x823B0DA8 => {
    //   block [0x823B0DA8..0x823B0DAC)
	// 823B0DA8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x823B0DAC; continue 'dispatch;
            }
            0x823B0DAC => {
    //   block [0x823B0DAC..0x823B0DBC)
	// 823B0DAC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823B0DB0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 823B0DB4: 4098FFBC  bge cr6, 0x823b0d70
	if !ctx.cr[6].lt {
	pc = 0x823B0D70; continue 'dispatch;
	}
	// 823B0DB8: 48000014  b 0x823b0dcc
	pc = 0x823B0DCC; continue 'dispatch;
            }
            0x823B0DBC => {
    //   block [0x823B0DBC..0x823B0DCC)
	// 823B0DBC: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 823B0DC0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 823B0DC4: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 823B0DC8: 40980008  bge cr6, 0x823b0dd0
	if !ctx.cr[6].lt {
	pc = 0x823B0DD0; continue 'dispatch;
	}
	pc = 0x823B0DCC; continue 'dispatch;
            }
            0x823B0DCC => {
    //   block [0x823B0DCC..0x823B0DD0)
	// 823B0DCC: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	pc = 0x823B0DD0; continue 'dispatch;
            }
            0x823B0DD0 => {
    //   block [0x823B0DD0..0x823B0E04)
	// 823B0DD0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823B0DD4: 419A0088  beq cr6, 0x823b0e5c
	if ctx.cr[6].eq {
	pc = 0x823B0E5C; continue 'dispatch;
	}
	// 823B0DD8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823B0DDC: 419A0048  beq cr6, 0x823b0e24
	if ctx.cr[6].eq {
	pc = 0x823B0E24; continue 'dispatch;
	}
	// 823B0DE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B0DE4: 80BB0000  lwz r5, 0(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0DE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B0DEC: 48181DD5  bl 0x82532bc0
	ctx.lr = 0x823B0DF0;
	sub_82532BC0(ctx, base);
	// 823B0DF0: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0DF4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823B0DF8: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 823B0DFC: 9AEAFFFF  stb r23, -1(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-1 as u32), ctx.r[23].u8 ) };
	// 823B0E00: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x823B0E04; continue 'dispatch;
            }
            0x823B0E04 => {
    //   block [0x823B0E04..0x823B0E24)
	// 823B0E04: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0E08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823B0E0C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823B0E10: 409AFFF4  bne cr6, 0x823b0e04
	if !ctx.cr[6].eq {
	pc = 0x823B0E04; continue 'dispatch;
	}
	// 823B0E14: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 823B0E18: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823B0E1C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823B0E20: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823B0E24; continue 'dispatch;
            }
            0x823B0E24 => {
    //   block [0x823B0E24..0x823B0E5C)
	// 823B0E24: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 823B0E28: 419A00A0  beq cr6, 0x823b0ec8
	if ctx.cr[6].eq {
	pc = 0x823B0EC8; continue 'dispatch;
	}
	// 823B0E2C: 7F4B0034  cntlzw r11, r26
	ctx.r[11].u64 = if ctx.r[26].u32 == 0 { 32 } else { ctx.r[26].u32.leading_zeros() as u64 };
	// 823B0E30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823B0E34: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823B0E38: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 823B0E3C: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 823B0E40: 7FEBF214  add r31, r11, r30
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823B0E44: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823B0E48: 93F80000  stw r31, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823B0E4C: 48183D05  bl 0x82534b50
	ctx.lr = 0x823B0E50;
	sub_82534B50(ctx, base);
	// 823B0E50: 7D7FCA14  add r11, r31, r25
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[25].u64;
	// 823B0E54: 9AEBFFFF  stb r23, -1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-1 as u32), ctx.r[23].u8 ) };
	// 823B0E58: 48000070  b 0x823b0ec8
	pc = 0x823B0EC8; continue 'dispatch;
            }
            0x823B0E5C => {
    //   block [0x823B0E5C..0x823B0E80)
	// 823B0E5C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823B0E60: 419A0020  beq cr6, 0x823b0e80
	if ctx.cr[6].eq {
	pc = 0x823B0E80; continue 'dispatch;
	}
	// 823B0E64: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 823B0E68: 80B80000  lwz r5, 0(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0E6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B0E70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B0E74: 388BEA88  addi r4, r11, -0x1578
	ctx.r[4].s64 = ctx.r[11].s64 + -5496;
	// 823B0E78: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823B0E7C: 48183CD5  bl 0x82534b50
	ctx.lr = 0x823B0E80;
	sub_82534B50(ctx, base);
	pc = 0x823B0E80; continue 'dispatch;
            }
            0x823B0E80 => {
    //   block [0x823B0E80..0x823B0EBC)
	// 823B0E80: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 823B0E84: 419A0044  beq cr6, 0x823b0ec8
	if ctx.cr[6].eq {
	pc = 0x823B0EC8; continue 'dispatch;
	}
	// 823B0E88: 3BDC0001  addi r30, r28, 1
	ctx.r[30].s64 = ctx.r[28].s64 + 1;
	// 823B0E8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823B0E90: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 823B0E94: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823B0E98: 93D80000  stw r30, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823B0E9C: 48183CB5  bl 0x82534b50
	ctx.lr = 0x823B0EA0;
	sub_82534B50(ctx, base);
	// 823B0EA0: 7D7ECA14  add r11, r30, r25
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[25].u64;
	// 823B0EA4: 894BFFFE  lbz r10, -2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 823B0EA8: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 823B0EAC: 2F0A002F  cmpwi cr6, r10, 0x2f
	ctx.cr[6].compare_i32(ctx.r[10].s32, 47, &mut ctx.xer);
	// 823B0EB0: 419A000C  beq cr6, 0x823b0ebc
	if ctx.cr[6].eq {
	pc = 0x823B0EBC; continue 'dispatch;
	}
	// 823B0EB4: 2F0A005C  cmpwi cr6, r10, 0x5c
	ctx.cr[6].compare_i32(ctx.r[10].s32, 92, &mut ctx.xer);
	// 823B0EB8: 409A0010  bne cr6, 0x823b0ec8
	if !ctx.cr[6].eq {
	pc = 0x823B0EC8; continue 'dispatch;
	}
	pc = 0x823B0EBC; continue 'dispatch;
            }
            0x823B0EBC => {
    //   block [0x823B0EBC..0x823B0EC8)
	// 823B0EBC: 395EFFFF  addi r10, r30, -1
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	// 823B0EC0: 9AEBFFFE  stb r23, -2(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-2 as u32), ctx.r[23].u8 ) };
	// 823B0EC4: 91580000  stw r10, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x823B0EC8; continue 'dispatch;
            }
            0x823B0EC8 => {
    //   block [0x823B0EC8..0x823B0ED0)
	// 823B0EC8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823B0ECC: 48184228  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B0ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B0ED0 size=580
    let mut pc: u32 = 0x823B0ED0;
    'dispatch: loop {
        match pc {
            0x823B0ED0 => {
    //   block [0x823B0ED0..0x823B0EF4)
	// 823B0ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B0ED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B0ED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B0EDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B0EE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B0EE4: 89640000  lbz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0EE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B0EEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823B0EF0: 48000170  b 0x823b1060
	pc = 0x823B1060; continue 'dispatch;
            }
            0x823B0EF4 => {
    //   block [0x823B0EF4..0x823B0F0C)
	// 823B0EF4: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0EF8: 7D670775  extsb. r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823B0EFC: 40820010  bne 0x823b0f0c
	if !ctx.cr[0].eq {
	pc = 0x823B0F0C; continue 'dispatch;
	}
	// 823B0F00: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0F04: 2B0B002A  cmplwi cr6, r11, 0x2a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 42 as u32, &mut ctx.xer);
	// 823B0F08: 409A0050  bne cr6, 0x823b0f58
	if !ctx.cr[6].eq {
	pc = 0x823B0F58; continue 'dispatch;
	}
	pc = 0x823B0F0C; continue 'dispatch;
            }
            0x823B0F0C => {
    //   block [0x823B0F0C..0x823B0F4C)
	// 823B0F0C: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0F10: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 823B0F14: 7D4B0774  extsb r11, r10
	ctx.r[11].s64 = ctx.r[10].s8 as i64;
	// 823B0F18: 2F0B002A  cmpwi cr6, r11, 0x2a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 42, &mut ctx.xer);
	// 823B0F1C: 419A0178  beq cr6, 0x823b1094
	if ctx.cr[6].eq {
	pc = 0x823B1094; continue 'dispatch;
	}
	// 823B0F20: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 823B0F24: 419A012C  beq cr6, 0x823b1050
	if ctx.cr[6].eq {
	pc = 0x823B1050; continue 'dispatch;
	}
	// 823B0F28: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 823B0F2C: 419A0034  beq cr6, 0x823b0f60
	if ctx.cr[6].eq {
	pc = 0x823B0F60; continue 'dispatch;
	}
	// 823B0F30: 2F0B005C  cmpwi cr6, r11, 0x5c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 92, &mut ctx.xer);
	// 823B0F34: 409A0018  bne cr6, 0x823b0f4c
	if !ctx.cr[6].eq {
	pc = 0x823B0F4C; continue 'dispatch;
	}
	// 823B0F38: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0F3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B0F40: 4182000C  beq 0x823b0f4c
	if ctx.cr[0].eq {
	pc = 0x823B0F4C; continue 'dispatch;
	}
	// 823B0F44: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 823B0F48: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	pc = 0x823B0F4C; continue 'dispatch;
            }
            0x823B0F4C => {
    //   block [0x823B0F4C..0x823B0F58)
	// 823B0F4C: 7D4B0774  extsb r11, r10
	ctx.r[11].s64 = ctx.r[10].s8 as i64;
	// 823B0F50: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 823B0F54: 419A0104  beq cr6, 0x823b1058
	if ctx.cr[6].eq {
	pc = 0x823B1058; continue 'dispatch;
	}
	pc = 0x823B0F58; continue 'dispatch;
            }
            0x823B0F58 => {
    //   block [0x823B0F58..0x823B0F60)
	// 823B0F58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B0F5C: 4800011C  b 0x823b1078
	pc = 0x823B1078; continue 'dispatch;
            }
            0x823B0F60 => {
    //   block [0x823B0F60..0x823B0F74)
	// 823B0F60: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0F64: 2B0B005E  cmplwi cr6, r11, 0x5e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 94 as u32, &mut ctx.xer);
	// 823B0F68: 419A000C  beq cr6, 0x823b0f74
	if ctx.cr[6].eq {
	pc = 0x823B0F74; continue 'dispatch;
	}
	// 823B0F6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823B0F70: 4800000C  b 0x823b0f7c
	pc = 0x823B0F7C; continue 'dispatch;
            }
            0x823B0F74 => {
    //   block [0x823B0F74..0x823B0F7C)
	// 823B0F74: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 823B0F78: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	pc = 0x823B0F7C; continue 'dispatch;
            }
            0x823B0F7C => {
    //   block [0x823B0F7C..0x823B0F80)
	// 823B0F7C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x823B0F80; continue 'dispatch;
            }
            0x823B0F80 => {
    //   block [0x823B0F80..0x823B0FE0)
	// 823B0F80: 893F0000  lbz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0F84: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 823B0F88: 7D2A0775  extsb. r10, r9
	ctx.r[10].s64 = ctx.r[9].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B0F8C: 41820090  beq 0x823b101c
	if ctx.cr[0].eq {
	pc = 0x823B101C; continue 'dispatch;
	}
	// 823B0F90: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0F94: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B0F98: 4182FFC0  beq 0x823b0f58
	if ctx.cr[0].eq {
	pc = 0x823B0F58; continue 'dispatch;
	}
	// 823B0F9C: 2F0B002D  cmpwi cr6, r11, 0x2d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 45, &mut ctx.xer);
	// 823B0FA0: 409A0040  bne cr6, 0x823b0fe0
	if !ctx.cr[6].eq {
	pc = 0x823B0FE0; continue 'dispatch;
	}
	// 823B0FA4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 823B0FA8: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B0FAC: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B0FB0: 4182FFA8  beq 0x823b0f58
	if ctx.cr[0].eq {
	pc = 0x823B0F58; continue 'dispatch;
	}
	// 823B0FB4: 2F0B005D  cmpwi cr6, r11, 0x5d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 93, &mut ctx.xer);
	// 823B0FB8: 419A0054  beq cr6, 0x823b100c
	if ctx.cr[6].eq {
	pc = 0x823B100C; continue 'dispatch;
	}
	// 823B0FBC: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823B0FC0: 419A003C  beq cr6, 0x823b0ffc
	if ctx.cr[6].eq {
	pc = 0x823B0FFC; continue 'dispatch;
	}
	// 823B0FC4: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823B0FC8: 419A0034  beq cr6, 0x823b0ffc
	if ctx.cr[6].eq {
	pc = 0x823B0FFC; continue 'dispatch;
	}
	// 823B0FCC: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823B0FD0: 40990030  ble cr6, 0x823b1000
	if !ctx.cr[6].gt {
	pc = 0x823B1000; continue 'dispatch;
	}
	// 823B0FD4: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823B0FD8: 40980028  bge cr6, 0x823b1000
	if !ctx.cr[6].lt {
	pc = 0x823B1000; continue 'dispatch;
	}
	// 823B0FDC: 48000020  b 0x823b0ffc
	pc = 0x823B0FFC; continue 'dispatch;
            }
            0x823B0FE0 => {
    //   block [0x823B0FE0..0x823B0FEC)
	// 823B0FE0: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 823B0FE4: 409A0008  bne cr6, 0x823b0fec
	if !ctx.cr[6].eq {
	pc = 0x823B0FEC; continue 'dispatch;
	}
	// 823B0FE8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x823B0FEC; continue 'dispatch;
            }
            0x823B0FEC => {
    //   block [0x823B0FEC..0x823B0FFC)
	// 823B0FEC: 2F0B005D  cmpwi cr6, r11, 0x5d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 93, &mut ctx.xer);
	// 823B0FF0: 419A002C  beq cr6, 0x823b101c
	if ctx.cr[6].eq {
	pc = 0x823B101C; continue 'dispatch;
	}
	// 823B0FF4: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 823B0FF8: 409A0008  bne cr6, 0x823b1000
	if !ctx.cr[6].eq {
	pc = 0x823B1000; continue 'dispatch;
	}
	pc = 0x823B0FFC; continue 'dispatch;
            }
            0x823B0FFC => {
    //   block [0x823B0FFC..0x823B1000)
	// 823B0FFC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x823B1000; continue 'dispatch;
            }
            0x823B1000 => {
    //   block [0x823B1000..0x823B100C)
	// 823B1000: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823B1004: 419AFF7C  beq cr6, 0x823b0f80
	if ctx.cr[6].eq {
	pc = 0x823B0F80; continue 'dispatch;
	}
	// 823B1008: 48000014  b 0x823b101c
	pc = 0x823B101C; continue 'dispatch;
            }
            0x823B100C => {
    //   block [0x823B100C..0x823B101C)
	// 823B100C: 7D2B0774  extsb r11, r9
	ctx.r[11].s64 = ctx.r[9].s8 as i64;
	// 823B1010: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823B1014: 41980008  blt cr6, 0x823b101c
	if ctx.cr[6].lt {
	pc = 0x823B101C; continue 'dispatch;
	}
	// 823B1018: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x823B101C; continue 'dispatch;
            }
            0x823B101C => {
    //   block [0x823B101C..0x823B1028)
	// 823B101C: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823B1020: 419AFF38  beq cr6, 0x823b0f58
	if ctx.cr[6].eq {
	pc = 0x823B0F58; continue 'dispatch;
	}
	// 823B1024: 48000010  b 0x823b1034
	pc = 0x823B1034; continue 'dispatch;
            }
            0x823B1028 => {
    //   block [0x823B1028..0x823B1034)
	// 823B1028: 2F0B005D  cmpwi cr6, r11, 0x5d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 93, &mut ctx.xer);
	// 823B102C: 419A0014  beq cr6, 0x823b1040
	if ctx.cr[6].eq {
	pc = 0x823B1040; continue 'dispatch;
	}
	// 823B1030: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	pc = 0x823B1034; continue 'dispatch;
            }
            0x823B1034 => {
    //   block [0x823B1034..0x823B1040)
	// 823B1034: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B1038: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B103C: 4082FFEC  bne 0x823b1028
	if !ctx.cr[0].eq {
	pc = 0x823B1028; continue 'dispatch;
	}
	pc = 0x823B1040; continue 'dispatch;
            }
            0x823B1040 => {
    //   block [0x823B1040..0x823B1050)
	// 823B1040: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B1044: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 823B1048: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B104C: 48000008  b 0x823b1054
	pc = 0x823B1054; continue 'dispatch;
            }
            0x823B1050 => {
    //   block [0x823B1050..0x823B1054)
	// 823B1050: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	pc = 0x823B1054; continue 'dispatch;
            }
            0x823B1054 => {
    //   block [0x823B1054..0x823B1058)
	// 823B1054: 419AFF04  beq cr6, 0x823b0f58
	if ctx.cr[6].eq {
	pc = 0x823B0F58; continue 'dispatch;
	}
	pc = 0x823B1058; continue 'dispatch;
            }
            0x823B1058 => {
    //   block [0x823B1058..0x823B1060)
	// 823B1058: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B105C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	pc = 0x823B1060; continue 'dispatch;
            }
            0x823B1060 => {
    //   block [0x823B1060..0x823B1078)
	// 823B1060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B1064: 409AFE90  bne cr6, 0x823b0ef4
	if !ctx.cr[6].eq {
	pc = 0x823B0EF4; continue 'dispatch;
	}
	// 823B1068: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B106C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 823B1070: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823B1074: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	pc = 0x823B1078; continue 'dispatch;
            }
            0x823B1078 => {
    //   block [0x823B1078..0x823B1090)
	// 823B1078: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B107C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B1080: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B1084: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B1088: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B108C: 4E800020  blr
	return;
            }
            0x823B1090 => {
    //   block [0x823B1090..0x823B1094)
	// 823B1090: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	pc = 0x823B1094; continue 'dispatch;
            }
            0x823B1094 => {
    //   block [0x823B1094..0x823B10AC)
	// 823B1094: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B1098: 2B0B002A  cmplwi cr6, r11, 0x2a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 42 as u32, &mut ctx.xer);
	// 823B109C: 419AFFF4  beq cr6, 0x823b1090
	if ctx.cr[6].eq {
	pc = 0x823B1090; continue 'dispatch;
	}
	// 823B10A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823B10A4: 7D6A0775  extsb. r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B10A8: 4082000C  bne 0x823b10b4
	if !ctx.cr[0].eq {
	pc = 0x823B10B4; continue 'dispatch;
	}
	pc = 0x823B10AC; continue 'dispatch;
            }
            0x823B10AC => {
    //   block [0x823B10AC..0x823B10B4)
	// 823B10AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823B10B0: 4BFFFFC8  b 0x823b1078
	pc = 0x823B1078; continue 'dispatch;
            }
            0x823B10B4 => {
    //   block [0x823B10B4..0x823B10D0)
	// 823B10B4: 2F0A003F  cmpwi cr6, r10, 0x3f
	ctx.cr[6].compare_i32(ctx.r[10].s32, 63, &mut ctx.xer);
	// 823B10B8: 419A004C  beq cr6, 0x823b1104
	if ctx.cr[6].eq {
	pc = 0x823B1104; continue 'dispatch;
	}
	// 823B10BC: 2F0A005B  cmpwi cr6, r10, 0x5b
	ctx.cr[6].compare_i32(ctx.r[10].s32, 91, &mut ctx.xer);
	// 823B10C0: 419A0044  beq cr6, 0x823b1104
	if ctx.cr[6].eq {
	pc = 0x823B1104; continue 'dispatch;
	}
	// 823B10C4: 2F0A005C  cmpwi cr6, r10, 0x5c
	ctx.cr[6].compare_i32(ctx.r[10].s32, 92, &mut ctx.xer);
	// 823B10C8: 419A003C  beq cr6, 0x823b1104
	if ctx.cr[6].eq {
	pc = 0x823B1104; continue 'dispatch;
	}
	// 823B10CC: 48000010  b 0x823b10dc
	pc = 0x823B10DC; continue 'dispatch;
            }
            0x823B10D0 => {
    //   block [0x823B10D0..0x823B10DC)
	// 823B10D0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823B10D4: 419A0030  beq cr6, 0x823b1104
	if ctx.cr[6].eq {
	pc = 0x823B1104; continue 'dispatch;
	}
	// 823B10D8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	pc = 0x823B10DC; continue 'dispatch;
            }
            0x823B10DC => {
    //   block [0x823B10DC..0x823B10EC)
	// 823B10DC: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B10E0: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B10E4: 4082FFEC  bne 0x823b10d0
	if !ctx.cr[0].eq {
	pc = 0x823B10D0; continue 'dispatch;
	}
	// 823B10E8: 4800001C  b 0x823b1104
	pc = 0x823B1104; continue 'dispatch;
            }
            0x823B10EC => {
    //   block [0x823B10EC..0x823B1104)
	// 823B10EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823B10F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B10F4: 4BFFFDDD  bl 0x823b0ed0
	ctx.lr = 0x823B10F8;
	sub_823B0ED0(ctx, base);
	// 823B10F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B10FC: 4082FFB0  bne 0x823b10ac
	if !ctx.cr[0].eq {
	pc = 0x823B10AC; continue 'dispatch;
	}
	// 823B1100: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	pc = 0x823B1104; continue 'dispatch;
            }
            0x823B1104 => {
    //   block [0x823B1104..0x823B1114)
	// 823B1104: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B1108: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B110C: 409AFFE0  bne cr6, 0x823b10ec
	if !ctx.cr[6].eq {
	pc = 0x823B10EC; continue 'dispatch;
	}
	// 823B1110: 4BFFFE48  b 0x823b0f58
	pc = 0x823B0F58; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B1118 size=12
    let mut pc: u32 = 0x823B1118;
    'dispatch: loop {
        match pc {
            0x823B1118 => {
    //   block [0x823B1118..0x823B1124)
	// 823B1118: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823B111C: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 823B1120: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B1128 size=24
    let mut pc: u32 = 0x823B1128;
    'dispatch: loop {
        match pc {
            0x823B1128 => {
    //   block [0x823B1128..0x823B1140)
	// 823B1128: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B112C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 823B1130: 396B17FC  addi r11, r11, 0x17fc
	ctx.r[11].s64 = ctx.r[11].s64 + 6140;
	// 823B1134: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823B1138: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B113C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B1140 size=24
    let mut pc: u32 = 0x823B1140;
    'dispatch: loop {
        match pc {
            0x823B1140 => {
    //   block [0x823B1140..0x823B1158)
	// 823B1140: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B1144: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 823B1148: 396B17A4  addi r11, r11, 0x17a4
	ctx.r[11].s64 = ctx.r[11].s64 + 6052;
	// 823B114C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823B1150: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B1154: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B1158 size=8
    let mut pc: u32 = 0x823B1158;
    'dispatch: loop {
        match pc {
            0x823B1158 => {
    //   block [0x823B1158..0x823B1160)
	// 823B1158: 38600360  li r3, 0x360
	ctx.r[3].s64 = 864;
	// 823B115C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B1160 size=16
    let mut pc: u32 = 0x823B1160;
    'dispatch: loop {
        match pc {
            0x823B1160 => {
    //   block [0x823B1160..0x823B1170)
	// 823B1160: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B1164: 396B17A8  addi r11, r11, 0x17a8
	ctx.r[11].s64 = ctx.r[11].s64 + 6056;
	// 823B1168: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B116C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B1170 size=156
    let mut pc: u32 = 0x823B1170;
    'dispatch: loop {
        match pc {
            0x823B1170 => {
    //   block [0x823B1170..0x823B1190)
	// 823B1170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B1174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B1178: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B117C: 89430000  lbz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B1180: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B1184: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823B1188: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 823B118C: 4800004C  b 0x823b11d8
	pc = 0x823B11D8; continue 'dispatch;
            }
            0x823B1190 => {
    //   block [0x823B1190..0x823B11A0)
	// 823B1190: 7D470774  extsb r7, r10
	ctx.r[7].s64 = ctx.r[10].s8 as i64;
	// 823B1194: 2F07002F  cmpwi cr6, r7, 0x2f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 47, &mut ctx.xer);
	// 823B1198: 409A0008  bne cr6, 0x823b11a0
	if !ctx.cr[6].eq {
	pc = 0x823B11A0; continue 'dispatch;
	}
	// 823B119C: 3940005C  li r10, 0x5c
	ctx.r[10].s64 = 92;
	pc = 0x823B11A0; continue 'dispatch;
            }
            0x823B11A0 => {
    //   block [0x823B11A0..0x823B11BC)
	// 823B11A0: 7D470774  extsb r7, r10
	ctx.r[7].s64 = ctx.r[10].s8 as i64;
	// 823B11A4: 2F07005C  cmpwi cr6, r7, 0x5c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 92, &mut ctx.xer);
	// 823B11A8: 409A001C  bne cr6, 0x823b11c4
	if !ctx.cr[6].eq {
	pc = 0x823B11C4; continue 'dispatch;
	}
	// 823B11AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823B11B0: 409A000C  bne cr6, 0x823b11bc
	if !ctx.cr[6].eq {
	pc = 0x823B11BC; continue 'dispatch;
	}
	// 823B11B4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 823B11B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	pc = 0x823B11BC; continue 'dispatch;
            }
            0x823B11BC => {
    //   block [0x823B11BC..0x823B11C4)
	// 823B11BC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823B11C0: 48000010  b 0x823b11d0
	pc = 0x823B11D0; continue 'dispatch;
            }
            0x823B11C4 => {
    //   block [0x823B11C4..0x823B11D0)
	// 823B11C4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 823B11C8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B11CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	pc = 0x823B11D0; continue 'dispatch;
            }
            0x823B11D0 => {
    //   block [0x823B11D0..0x823B11D8)
	// 823B11D0: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823B11D4: 89480000  lbz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x823B11D8; continue 'dispatch;
            }
            0x823B11D8 => {
    //   block [0x823B11D8..0x823B120C)
	// 823B11D8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B11DC: 4082FFB4  bne 0x823b1190
	if !ctx.cr[0].eq {
	pc = 0x823B1190; continue 'dispatch;
	}
	// 823B11E0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823B11E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823B11E8: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 823B11EC: 38AA0001  addi r5, r10, 1
	ctx.r[5].s64 = ctx.r[10].s64 + 1;
	// 823B11F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B11F4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 823B11F8: 48183959  bl 0x82534b50
	ctx.lr = 0x823B11FC;
	sub_82534B50(ctx, base);
	// 823B11FC: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 823B1200: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B1204: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B1208: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B1210 size=120
    let mut pc: u32 = 0x823B1210;
    'dispatch: loop {
        match pc {
            0x823B1210 => {
    //   block [0x823B1210..0x823B1288)
	// 823B1210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B1214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B1218: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B121C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B1220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B1224: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 823B1228: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823B122C: 48195BFD  bl 0x82546e28
	ctx.lr = 0x823B1230;
	sub_82546E28(ctx, base);
	// 823B1230: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823B1234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B1238: 48195A01  bl 0x82546c38
	ctx.lr = 0x823B123C;
	sub_82546C38(ctx, base);
	// 823B123C: A1410062  lhz r10, 0x62(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(98 as u32) ) } as u64;
	// 823B1240: A1610060  lhz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 823B1244: A1210066  lhz r9, 0x66(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(102 as u32) ) } as u64;
	// 823B1248: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 823B124C: A1010068  lhz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 823B1250: A0E1006C  lhz r7, 0x6c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 823B1254: 995F0005  stb r10, 5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(5 as u32), ctx.r[10].u8 ) };
	// 823B1258: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 823B125C: A141006A  lhz r10, 0x6a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(106 as u32) ) } as u64;
	// 823B1260: 993F0004  stb r9, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u8 ) };
	// 823B1264: 991F0003  stb r8, 3(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(3 as u32), ctx.r[8].u8 ) };
	// 823B1268: 98FF0001  stb r7, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[7].u8 ) };
	// 823B126C: B17F0006  sth r11, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 823B1270: 995F0002  stb r10, 2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 823B1274: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823B1278: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B127C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B1280: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B1284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B1288 size=204
    let mut pc: u32 = 0x823B1288;
    'dispatch: loop {
        match pc {
            0x823B1288 => {
    //   block [0x823B1288..0x823B1324)
	// 823B1288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B128C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B1290: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B1294: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B1298: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B129C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823B12A0: 38A00128  li r5, 0x128
	ctx.r[5].s64 = 296;
	// 823B12A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B12A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B12AC: 48183F25  bl 0x825351d0
	ctx.lr = 0x823B12B0;
	sub_825351D0(ctx, base);
	// 823B12B0: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823B12B4: 389F002C  addi r4, r31, 0x2c
	ctx.r[4].s64 = ctx.r[31].s64 + 44;
	// 823B12B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B12BC: 48181905  bl 0x82532bc0
	ctx.lr = 0x823B12C0;
	sub_82532BC0(ctx, base);
	// 823B12C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823B12C4: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 823B12C8: 387E0108  addi r3, r30, 0x108
	ctx.r[3].s64 = ctx.r[30].s64 + 264;
	// 823B12CC: 997E00FF  stb r11, 0xff(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(255 as u32), ctx.r[11].u8 ) };
	// 823B12D0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B12D4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823B12D8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B12DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823B12E0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823B12E4: F97E0100  std r11, 0x100(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(256 as u32), ctx.r[11].u64 ) };
	// 823B12E8: 4BFFFF29  bl 0x823b1210
	ctx.lr = 0x823B12EC;
	sub_823B1210(ctx, base);
	// 823B12EC: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 823B12F0: 387E0110  addi r3, r30, 0x110
	ctx.r[3].s64 = ctx.r[30].s64 + 272;
	// 823B12F4: 4BFFFF1D  bl 0x823b1210
	ctx.lr = 0x823B12F8;
	sub_823B1210(ctx, base);
	// 823B12F8: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 823B12FC: 387E0118  addi r3, r30, 0x118
	ctx.r[3].s64 = ctx.r[30].s64 + 280;
	// 823B1300: 4BFFFF11  bl 0x823b1210
	ctx.lr = 0x823B1304;
	sub_823B1210(ctx, base);
	// 823B1304: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B1308: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B130C: 5569077B  rlwinm. r9, r11, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823B1310: 40820028  bne 0x823b1338
	if !ctx.cr[0].eq {
	pc = 0x823B1338; continue 'dispatch;
	}
	// 823B1314: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823B1318: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 823B131C: 40820008  bne 0x823b1324
	if !ctx.cr[0].eq {
	pc = 0x823B1324; continue 'dispatch;
	}
	// 823B1320: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	pc = 0x823B1324; continue 'dispatch;
            }
            0x823B1324 => {
    //   block [0x823B1324..0x823B1334)
	// 823B1324: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B1328: 4182000C  beq 0x823b1334
	if ctx.cr[0].eq {
	pc = 0x823B1334; continue 'dispatch;
	}
	// 823B132C: 614A0008  ori r10, r10, 8
	ctx.r[10].u64 = ctx.r[10].u64 | 8;
	// 823B1330: 48000008  b 0x823b1338
	pc = 0x823B1338; continue 'dispatch;
            }
            0x823B1334 => {
    //   block [0x823B1334..0x823B1338)
	// 823B1334: 614A0010  ori r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u64 | 16;
	pc = 0x823B1338; continue 'dispatch;
            }
            0x823B1338 => {
    //   block [0x823B1338..0x823B1354)
	// 823B1338: 915E0120  stw r10, 0x120(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(288 as u32), ctx.r[10].u32 ) };
	// 823B133C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B1340: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B1344: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B1348: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B134C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B1350: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B1358 size=472
    let mut pc: u32 = 0x823B1358;
    'dispatch: loop {
        match pc {
            0x823B1358 => {
    //   block [0x823B1358..0x823B13B0)
	// 823B1358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B135C: 48183D59  bl 0x825350b4
	ctx.lr = 0x823B1360;
	sub_82535080(ctx, base);
	// 823B1360: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B1364: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B1368: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 823B136C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823B1370: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823B1374: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823B1378: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 823B137C: 388A1798  addi r4, r10, 0x1798
	ctx.r[4].s64 = ctx.r[10].s64 + 6040;
	// 823B1380: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 823B1384: 38DF0208  addi r6, r31, 0x208
	ctx.r[6].s64 = ctx.r[31].s64 + 520;
	// 823B1388: 38BF0108  addi r5, r31, 0x108
	ctx.r[5].s64 = ctx.r[31].s64 + 264;
	// 823B138C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823B1390: 48181891  bl 0x82532c20
	ctx.lr = 0x823B1394;
	sub_82532C20(ctx, base);
	// 823B1394: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823B1398: 4BFFFDD9  bl 0x823b1170
	ctx.lr = 0x823B139C;
	sub_823B1170(ctx, base);
	// 823B139C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823B13A0: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 823B13A4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B13A8: 40820008  bne 0x823b13b0
	if !ctx.cr[0].eq {
	pc = 0x823B13B0; continue 'dispatch;
	}
	// 823B13AC: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x823B13B0; continue 'dispatch;
            }
            0x823B13B0 => {
    //   block [0x823B13B0..0x823B13C0)
	// 823B13B0: 57CB07BD  rlwinm. r11, r30, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B13B4: 3D604000  lis r11, 0x4000
	ctx.r[11].s64 = 1073741824;
	// 823B13B8: 40820008  bne 0x823b13c0
	if !ctx.cr[0].eq {
	pc = 0x823B13C0; continue 'dispatch;
	}
	// 823B13BC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x823B13C0; continue 'dispatch;
            }
            0x823B13C0 => {
    //   block [0x823B13C0..0x823B1400)
	// 823B13C0: 7D645378  or r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 823B13C4: 7FCBF0F8  nor r11, r30, r30
	ctx.r[11].u64 = !(ctx.r[30].u64 | ctx.r[30].u64);
	// 823B13C8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 823B13CC: 5565FFFE  rlwinm r5, r11, 0x1f, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 823B13D0: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 823B13D4: 419A0044  beq cr6, 0x823b1418
	if ctx.cr[6].eq {
	pc = 0x823B1418; continue 'dispatch;
	}
	// 823B13D8: 2B1D0002  cmplwi cr6, r29, 2
	ctx.cr[6].compare_u32(ctx.r[29].u32, 2 as u32, &mut ctx.xer);
	// 823B13DC: 419A0034  beq cr6, 0x823b1410
	if ctx.cr[6].eq {
	pc = 0x823B1410; continue 'dispatch;
	}
	// 823B13E0: 2B1D0003  cmplwi cr6, r29, 3
	ctx.cr[6].compare_u32(ctx.r[29].u32, 3 as u32, &mut ctx.xer);
	// 823B13E4: 419A0024  beq cr6, 0x823b1408
	if ctx.cr[6].eq {
	pc = 0x823B1408; continue 'dispatch;
	}
	// 823B13E8: 2B1D0004  cmplwi cr6, r29, 4
	ctx.cr[6].compare_u32(ctx.r[29].u32, 4 as u32, &mut ctx.xer);
	// 823B13EC: 419A0014  beq cr6, 0x823b1400
	if ctx.cr[6].eq {
	pc = 0x823B1400; continue 'dispatch;
	}
	// 823B13F0: 2B1D0005  cmplwi cr6, r29, 5
	ctx.cr[6].compare_u32(ctx.r[29].u32, 5 as u32, &mut ctx.xer);
	// 823B13F4: 409A0028  bne cr6, 0x823b141c
	if !ctx.cr[6].eq {
	pc = 0x823B141C; continue 'dispatch;
	}
	// 823B13F8: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 823B13FC: 48000020  b 0x823b141c
	pc = 0x823B141C; continue 'dispatch;
            }
            0x823B1400 => {
    //   block [0x823B1400..0x823B1408)
	// 823B1400: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 823B1404: 48000018  b 0x823b141c
	pc = 0x823B141C; continue 'dispatch;
            }
            0x823B1408 => {
    //   block [0x823B1408..0x823B1410)
	// 823B1408: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 823B140C: 48000010  b 0x823b141c
	pc = 0x823B141C; continue 'dispatch;
            }
            0x823B1410 => {
    //   block [0x823B1410..0x823B1418)
	// 823B1410: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 823B1414: 48000008  b 0x823b141c
	pc = 0x823B141C; continue 'dispatch;
            }
            0x823B1418 => {
    //   block [0x823B1418..0x823B141C)
	// 823B1418: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	pc = 0x823B141C; continue 'dispatch;
            }
            0x823B141C => {
    //   block [0x823B141C..0x823B146C)
	// 823B141C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B1420: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	// 823B1424: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823B1428: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823B142C: 4800F25D  bl 0x823c0688
	ctx.lr = 0x823B1430;
	sub_823C0688(ctx, base);
	// 823B1430: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B1434: 4800F24D  bl 0x823c0680
	ctx.lr = 0x823B1438;
	sub_823C0680(ctx, base);
	// 823B1438: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B143C: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 823B1440: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B1444: 409A0040  bne cr6, 0x823b1484
	if !ctx.cr[6].eq {
	pc = 0x823B1484; continue 'dispatch;
	}
	// 823B1448: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 823B144C: 4198002C  blt cr6, 0x823b1478
	if ctx.cr[6].lt {
	pc = 0x823B1478; continue 'dispatch;
	}
	// 823B1450: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 823B1454: 40990018  ble cr6, 0x823b146c
	if !ctx.cr[6].gt {
	pc = 0x823B146C; continue 'dispatch;
	}
	// 823B1458: 2F030050  cmpwi cr6, r3, 0x50
	ctx.cr[6].compare_i32(ctx.r[3].s32, 80, &mut ctx.xer);
	// 823B145C: 409A001C  bne cr6, 0x823b1478
	if !ctx.cr[6].eq {
	pc = 0x823B1478; continue 'dispatch;
	}
	// 823B1460: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1464: 6063FFFD  ori r3, r3, 0xfffd
	ctx.r[3].u64 = ctx.r[3].u64 | 65533;
	// 823B1468: 480000C0  b 0x823b1528
	pc = 0x823B1528; continue 'dispatch;
            }
            0x823B146C => {
    //   block [0x823B146C..0x823B1478)
	// 823B146C: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1470: 6063FFFE  ori r3, r3, 0xfffe
	ctx.r[3].u64 = ctx.r[3].u64 | 65534;
	// 823B1474: 480000B4  b 0x823b1528
	pc = 0x823B1528; continue 'dispatch;
            }
            0x823B1478 => {
    //   block [0x823B1478..0x823B1484)
	// 823B1478: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B147C: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B1480: 480000A8  b 0x823b1528
	pc = 0x823B1528; continue 'dispatch;
            }
            0x823B1484 => {
    //   block [0x823B1484..0x823B14A8)
	// 823B1484: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1488: 4BFECB51  bl 0x8239dfd8
	ctx.lr = 0x823B148C;
	sub_8239DFD8(ctx, base);
	// 823B148C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B1490: 40820018  bne 0x823b14a8
	if !ctx.cr[0].eq {
	pc = 0x823B14A8; continue 'dispatch;
	}
	// 823B1494: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B1498: 4800F4C1  bl 0x823c0958
	ctx.lr = 0x823B149C;
	sub_823C0958(ctx, base);
	// 823B149C: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B14A0: 6063FFFA  ori r3, r3, 0xfffa
	ctx.r[3].u64 = ctx.r[3].u64 | 65530;
	// 823B14A4: 48000084  b 0x823b1528
	pc = 0x823B1528; continue 'dispatch;
            }
            0x823B14A8 => {
    //   block [0x823B14A8..0x823B14C8)
	// 823B14A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B14AC: 3D407FFF  lis r10, 0x7fff
	ctx.r[10].s64 = 2147418112;
	// 823B14B0: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 823B14B4: 83AB0028  lwz r29, 0x28(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 823B14B8: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823B14BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823B14C0: 40980008  bge cr6, 0x823b14c8
	if !ctx.cr[6].lt {
	pc = 0x823B14C8; continue 'dispatch;
	}
	// 823B14C4: 395D0001  addi r10, r29, 1
	ctx.r[10].s64 = ctx.r[29].s64 + 1;
	pc = 0x823B14C8; continue 'dispatch;
            }
            0x823B14C8 => {
    //   block [0x823B14C8..0x823B1528)
	// 823B14C8: 914B0028  stw r10, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 823B14CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B14D0: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 823B14D4: 93C30018  stw r30, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 823B14D8: 396B17FC  addi r11, r11, 0x17fc
	ctx.r[11].s64 = ctx.r[11].s64 + 6140;
	// 823B14DC: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 823B14E0: 614A8000  ori r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 32768;
	// 823B14E4: 93630008  stw r27, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 823B14E8: 93830010  stw r28, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	// 823B14EC: 93E30014  stw r31, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 823B14F0: FB830020  std r28, 0x20(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[28].u64 ) };
	// 823B14F4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B14F8: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 823B14FC: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1500: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 823B1504: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 823B1508: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B150C: 4835BD51  bl 0x8270d25c
	ctx.lr = 0x823B1510;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B1510: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823B1514: 387F1CC4  addi r3, r31, 0x1cc4
	ctx.r[3].s64 = ctx.r[31].s64 + 7364;
	// 823B1518: 4BFF86F1  bl 0x823a9c08
	ctx.lr = 0x823B151C;
	sub_823A9C08(ctx, base);
	// 823B151C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B1520: 4835BD4D  bl 0x8270d26c
	ctx.lr = 0x823B1524;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B1524: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x823B1528; continue 'dispatch;
            }
            0x823B1528 => {
    //   block [0x823B1528..0x823B1530)
	// 823B1528: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 823B152C: 48183BD8  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B1530 size=88
    let mut pc: u32 = 0x823B1530;
    'dispatch: loop {
        match pc {
            0x823B1530 => {
    //   block [0x823B1530..0x823B1570)
	// 823B1530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B1534: 48183B89  bl 0x825350bc
	ctx.lr = 0x823B1538;
	sub_82535080(ctx, base);
	// 823B1538: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B153C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823B1540: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B1544: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B1548: 4800F411  bl 0x823c0958
	ctx.lr = 0x823B154C;
	sub_823C0958(ctx, base);
	// 823B154C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823B1550: 4800F131  bl 0x823c0680
	ctx.lr = 0x823B1554;
	sub_823C0680(ctx, base);
	// 823B1554: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1558: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823B155C: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B1560: 409A0010  bne cr6, 0x823b1570
	if !ctx.cr[6].eq {
	pc = 0x823B1570; continue 'dispatch;
	}
	// 823B1564: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1568: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B156C: 48000014  b 0x823b1580
	pc = 0x823B1580; continue 'dispatch;
            }
            0x823B1570 => {
    //   block [0x823B1570..0x823B1580)
	// 823B1570: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B1574: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1578: 4BFECB29  bl 0x8239e0a0
	ctx.lr = 0x823B157C;
	sub_8239E0A0(ctx, base);
	// 823B157C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823B1580; continue 'dispatch;
            }
            0x823B1580 => {
    //   block [0x823B1580..0x823B1588)
	// 823B1580: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B1584: 48183B88  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B1588 size=180
    let mut pc: u32 = 0x823B1588;
    'dispatch: loop {
        match pc {
            0x823B1588 => {
    //   block [0x823B1588..0x823B15D0)
	// 823B1588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B158C: 48183B29  bl 0x825350b4
	ctx.lr = 0x823B1590;
	sub_82535080(ctx, base);
	// 823B1590: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B1594: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823B1598: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823B159C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 823B15A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823B15A4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 823B15A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823B15AC: E89F0020  ld r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	// 823B15B0: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B15B4: 48195715  bl 0x82546cc8
	ctx.lr = 0x823B15B8;
	sub_82546CC8(ctx, base);
	// 823B15B8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823B15BC: 4800F0C5  bl 0x823c0680
	ctx.lr = 0x823B15C0;
	sub_823C0680(ctx, base);
	// 823B15C0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B15C4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823B15C8: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B15CC: 409A0010  bne cr6, 0x823b15dc
	if !ctx.cr[6].eq {
	pc = 0x823B15DC; continue 'dispatch;
	}
	pc = 0x823B15D0; continue 'dispatch;
            }
            0x823B15D0 => {
    //   block [0x823B15D0..0x823B15DC)
	// 823B15D0: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B15D4: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B15D8: 4800005C  b 0x823b1634
	pc = 0x823B1634; continue 'dispatch;
            }
            0x823B15DC => {
    //   block [0x823B15DC..0x823B15F4)
	// 823B15DC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B15E0: 2F2B0000  cmpdi cr6, r11, 0
	ctx.cr[6].compare_i64(ctx.r[11].s64, 0, &mut ctx.xer);
	// 823B15E4: 419A0010  beq cr6, 0x823b15f4
	if ctx.cr[6].eq {
	pc = 0x823B15F4; continue 'dispatch;
	}
	// 823B15E8: 7F3E5800  cmpd cr6, r30, r11
	ctx.cr[6].compare_i64(ctx.r[30].s64, ctx.r[11].s64, &mut ctx.xer);
	// 823B15EC: 40990008  ble cr6, 0x823b15f4
	if !ctx.cr[6].gt {
	pc = 0x823B15F4; continue 'dispatch;
	}
	// 823B15F0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	pc = 0x823B15F4; continue 'dispatch;
            }
            0x823B15F4 => {
    //   block [0x823B15F4..0x823B1634)
	// 823B15F4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B15F8: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B15FC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823B1600: 57C5003E  slwi r5, r30, 0
	ctx.r[5].u32 = ctx.r[30].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823B1604: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823B1608: 4800EDC9  bl 0x823c03d0
	ctx.lr = 0x823B160C;
	sub_823C03D0(ctx, base);
	// 823B160C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B1610: 4800F071  bl 0x823c0680
	ctx.lr = 0x823B1614;
	sub_823C0680(ctx, base);
	// 823B1614: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1618: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823B161C: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B1620: 419AFFB0  beq cr6, 0x823b15d0
	if ctx.cr[6].eq {
	pc = 0x823B15D0; continue 'dispatch;
	}
	// 823B1624: E97F0020  ld r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	// 823B1628: E8610052  lwa r3, 0x50(r1)
	ctx.r[3].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as i32) as i64;
	// 823B162C: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 823B1630: F97F0020  std r11, 0x20(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	pc = 0x823B1634; continue 'dispatch;
            }
            0x823B1634 => {
    //   block [0x823B1634..0x823B163C)
	// 823B1634: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823B1638: 48183ACC  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B1640 size=156
    let mut pc: u32 = 0x823B1640;
    'dispatch: loop {
        match pc {
            0x823B1640 => {
    //   block [0x823B1640..0x823B1688)
	// 823B1640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B1644: 48183A71  bl 0x825350b4
	ctx.lr = 0x823B1648;
	sub_82535080(ctx, base);
	// 823B1648: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B164C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823B1650: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 823B1654: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 823B1658: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823B165C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 823B1660: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B1664: E89F0020  ld r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	// 823B1668: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B166C: 4819565D  bl 0x82546cc8
	ctx.lr = 0x823B1670;
	sub_82546CC8(ctx, base);
	// 823B1670: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823B1674: 4800F00D  bl 0x823c0680
	ctx.lr = 0x823B1678;
	sub_823C0680(ctx, base);
	// 823B1678: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B167C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823B1680: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B1684: 409A0010  bne cr6, 0x823b1694
	if !ctx.cr[6].eq {
	pc = 0x823B1694; continue 'dispatch;
	}
	pc = 0x823B1688; continue 'dispatch;
            }
            0x823B1688 => {
    //   block [0x823B1688..0x823B1694)
	// 823B1688: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B168C: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B1690: 48000044  b 0x823b16d4
	pc = 0x823B16D4; continue 'dispatch;
            }
            0x823B1694 => {
    //   block [0x823B1694..0x823B16D4)
	// 823B1694: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B1698: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B169C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823B16A0: 5765003E  slwi r5, r27, 0
	ctx.r[5].u32 = ctx.r[27].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823B16A4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823B16A8: 4800EEB1  bl 0x823c0558
	ctx.lr = 0x823B16AC;
	sub_823C0558(ctx, base);
	// 823B16AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823B16B0: 4800EFD1  bl 0x823c0680
	ctx.lr = 0x823B16B4;
	sub_823C0680(ctx, base);
	// 823B16B4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B16B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823B16BC: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B16C0: 419AFFC8  beq cr6, 0x823b1688
	if ctx.cr[6].eq {
	pc = 0x823B1688; continue 'dispatch;
	}
	// 823B16C4: E97F0020  ld r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	// 823B16C8: E8610052  lwa r3, 0x50(r1)
	ctx.r[3].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as i32) as i64;
	// 823B16CC: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 823B16D0: F97F0020  std r11, 0x20(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	pc = 0x823B16D4; continue 'dispatch;
            }
            0x823B16D4 => {
    //   block [0x823B16D4..0x823B16DC)
	// 823B16D4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823B16D8: 48183A2C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B16E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B16E0 size=140
    let mut pc: u32 = 0x823B16E0;
    'dispatch: loop {
        match pc {
            0x823B16E0 => {
    //   block [0x823B16E0..0x823B1718)
	// 823B16E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B16E4: 481839D9  bl 0x825350bc
	ctx.lr = 0x823B16E8;
	sub_82535080(ctx, base);
	// 823B16E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B16EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823B16F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823B16F4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 823B16F8: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 823B16FC: 4198002C  blt cr6, 0x823b1728
	if ctx.cr[6].lt {
	pc = 0x823B1728; continue 'dispatch;
	}
	// 823B1700: 419A0020  beq cr6, 0x823b1720
	if ctx.cr[6].eq {
	pc = 0x823B1720; continue 'dispatch;
	}
	// 823B1704: 2B060003  cmplwi cr6, r6, 3
	ctx.cr[6].compare_u32(ctx.r[6].u32, 3 as u32, &mut ctx.xer);
	// 823B1708: 41980010  blt cr6, 0x823b1718
	if ctx.cr[6].lt {
	pc = 0x823B1718; continue 'dispatch;
	}
	// 823B170C: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1710: 6063FFFB  ori r3, r3, 0xfffb
	ctx.r[3].u64 = ctx.r[3].u64 | 65531;
	// 823B1714: 48000050  b 0x823b1764
	pc = 0x823B1764; continue 'dispatch;
            }
            0x823B1718 => {
    //   block [0x823B1718..0x823B1720)
	// 823B1718: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 823B171C: 48000010  b 0x823b172c
	pc = 0x823B172C; continue 'dispatch;
            }
            0x823B1720 => {
    //   block [0x823B1720..0x823B1728)
	// 823B1720: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 823B1724: 48000008  b 0x823b172c
	pc = 0x823B172C; continue 'dispatch;
            }
            0x823B1728 => {
    //   block [0x823B1728..0x823B172C)
	// 823B1728: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	pc = 0x823B172C; continue 'dispatch;
            }
            0x823B172C => {
    //   block [0x823B172C..0x823B175C)
	// 823B172C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823B1730: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B1734: 48195595  bl 0x82546cc8
	ctx.lr = 0x823B1738;
	sub_82546CC8(ctx, base);
	// 823B1738: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B173C: 4800EF45  bl 0x823c0680
	ctx.lr = 0x823B1740;
	sub_823C0680(ctx, base);
	// 823B1740: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1744: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823B1748: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B174C: 409A0010  bne cr6, 0x823b175c
	if !ctx.cr[6].eq {
	pc = 0x823B175C; continue 'dispatch;
	}
	// 823B1750: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1754: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B1758: 4800000C  b 0x823b1764
	pc = 0x823B1764; continue 'dispatch;
            }
            0x823B175C => {
    //   block [0x823B175C..0x823B1764)
	// 823B175C: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823B1760: F87E0020  std r3, 0x20(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[3].u64 ) };
	pc = 0x823B1764; continue 'dispatch;
            }
            0x823B1764 => {
    //   block [0x823B1764..0x823B176C)
	// 823B1764: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823B1768: 481839A4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B1770 size=100
    let mut pc: u32 = 0x823B1770;
    'dispatch: loop {
        match pc {
            0x823B1770 => {
    //   block [0x823B1770..0x823B17B8)
	// 823B1770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B1774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B1778: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B177C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B1780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B1784: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B1788: 80640018  lwz r3, 0x18(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B178C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823B1790: 48195439  bl 0x82546bc8
	ctx.lr = 0x823B1794;
	sub_82546BC8(ctx, base);
	// 823B1794: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B1798: 4800EEE9  bl 0x823c0680
	ctx.lr = 0x823B179C;
	sub_823C0680(ctx, base);
	// 823B179C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B17A0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823B17A4: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B17A8: 409A0010  bne cr6, 0x823b17b8
	if !ctx.cr[6].eq {
	pc = 0x823B17B8; continue 'dispatch;
	}
	// 823B17AC: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B17B0: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B17B4: 48000008  b 0x823b17bc
	pc = 0x823B17BC; continue 'dispatch;
            }
            0x823B17B8 => {
    //   block [0x823B17B8..0x823B17BC)
	// 823B17B8: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	pc = 0x823B17BC; continue 'dispatch;
            }
            0x823B17BC => {
    //   block [0x823B17BC..0x823B17D4)
	// 823B17BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B17C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B17C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B17C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B17CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B17D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B17D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B17D8 size=160
    let mut pc: u32 = 0x823B17D8;
    'dispatch: loop {
        match pc {
            0x823B17D8 => {
    //   block [0x823B17D8..0x823B1850)
	// 823B17D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B17DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B17E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B17E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B17E8: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B17EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B17F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B17F4: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 823B17F8: 388B1798  addi r4, r11, 0x1798
	ctx.r[4].s64 = ctx.r[11].s64 + 6040;
	// 823B17FC: 38DF0208  addi r6, r31, 0x208
	ctx.r[6].s64 = ctx.r[31].s64 + 520;
	// 823B1800: 38BF0108  addi r5, r31, 0x108
	ctx.r[5].s64 = ctx.r[31].s64 + 264;
	// 823B1804: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B1808: 48181419  bl 0x82532c20
	ctx.lr = 0x823B180C;
	sub_82532C20(ctx, base);
	// 823B180C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B1810: 4BFFF961  bl 0x823b1170
	ctx.lr = 0x823B1814;
	sub_823B1170(ctx, base);
	// 823B1814: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B1818: 48019D89  bl 0x823cb5a0
	ctx.lr = 0x823B181C;
	sub_823CB5A0(ctx, base);
	// 823B181C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B1820: 4800EE61  bl 0x823c0680
	ctx.lr = 0x823B1824;
	sub_823C0680(ctx, base);
	// 823B1824: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1828: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823B182C: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B1830: 409A002C  bne cr6, 0x823b185c
	if !ctx.cr[6].eq {
	pc = 0x823B185C; continue 'dispatch;
	}
	// 823B1834: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 823B1838: 41980018  blt cr6, 0x823b1850
	if ctx.cr[6].lt {
	pc = 0x823B1850; continue 'dispatch;
	}
	// 823B183C: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 823B1840: 41990010  bgt cr6, 0x823b1850
	if ctx.cr[6].gt {
	pc = 0x823B1850; continue 'dispatch;
	}
	// 823B1844: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1848: 6063FFFE  ori r3, r3, 0xfffe
	ctx.r[3].u64 = ctx.r[3].u64 | 65534;
	// 823B184C: 48000014  b 0x823b1860
	pc = 0x823B1860; continue 'dispatch;
            }
            0x823B1850 => {
    //   block [0x823B1850..0x823B185C)
	// 823B1850: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1854: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B1858: 48000008  b 0x823b1860
	pc = 0x823B1860; continue 'dispatch;
            }
            0x823B185C => {
    //   block [0x823B185C..0x823B1860)
	// 823B185C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823B1860; continue 'dispatch;
            }
            0x823B1860 => {
    //   block [0x823B1860..0x823B1878)
	// 823B1860: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 823B1864: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B1868: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B186C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B1870: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B1874: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B1878 size=160
    let mut pc: u32 = 0x823B1878;
    'dispatch: loop {
        match pc {
            0x823B1878 => {
    //   block [0x823B1878..0x823B190C)
	// 823B1878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B187C: 4818383D  bl 0x825350b8
	ctx.lr = 0x823B1880;
	sub_82535080(ctx, base);
	// 823B1880: 9421FD80  stwu r1, -0x280(r1)
	ea = ctx.r[1].u32.wrapping_add(-640 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B1884: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B1888: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B188C: 3BAB1798  addi r29, r11, 0x1798
	ctx.r[29].s64 = ctx.r[11].s64 + 6040;
	// 823B1890: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 823B1894: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823B1898: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823B189C: 38DF0208  addi r6, r31, 0x208
	ctx.r[6].s64 = ctx.r[31].s64 + 520;
	// 823B18A0: 38BF0108  addi r5, r31, 0x108
	ctx.r[5].s64 = ctx.r[31].s64 + 264;
	// 823B18A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823B18A8: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 823B18AC: 48181375  bl 0x82532c20
	ctx.lr = 0x823B18B0;
	sub_82532C20(ctx, base);
	// 823B18B0: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 823B18B4: 4BFFF8BD  bl 0x823b1170
	ctx.lr = 0x823B18B8;
	sub_823B1170(ctx, base);
	// 823B18B8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 823B18BC: 38DE0208  addi r6, r30, 0x208
	ctx.r[6].s64 = ctx.r[30].s64 + 520;
	// 823B18C0: 38BE0108  addi r5, r30, 0x108
	ctx.r[5].s64 = ctx.r[30].s64 + 264;
	// 823B18C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823B18C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B18CC: 48181355  bl 0x82532c20
	ctx.lr = 0x823B18D0;
	sub_82532C20(ctx, base);
	// 823B18D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B18D4: 4BFFF89D  bl 0x823b1170
	ctx.lr = 0x823B18D8;
	sub_823B1170(ctx, base);
	// 823B18D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B18DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823B18E0: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 823B18E4: 4801C075  bl 0x823cd958
	ctx.lr = 0x823B18E8;
	sub_823CD958(ctx, base);
	// 823B18E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B18EC: 4800ED95  bl 0x823c0680
	ctx.lr = 0x823B18F0;
	sub_823C0680(ctx, base);
	// 823B18F0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B18F4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823B18F8: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B18FC: 409A0010  bne cr6, 0x823b190c
	if !ctx.cr[6].eq {
	pc = 0x823B190C; continue 'dispatch;
	}
	// 823B1900: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1904: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B1908: 48000008  b 0x823b1910
	pc = 0x823B1910; continue 'dispatch;
            }
            0x823B190C => {
    //   block [0x823B190C..0x823B1910)
	// 823B190C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823B1910; continue 'dispatch;
            }
            0x823B1910 => {
    //   block [0x823B1910..0x823B1918)
	// 823B1910: 38210280  addi r1, r1, 0x280
	ctx.r[1].s64 = ctx.r[1].s64 + 640;
	// 823B1914: 481837F4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B1918 size=160
    let mut pc: u32 = 0x823B1918;
    'dispatch: loop {
        match pc {
            0x823B1918 => {
    //   block [0x823B1918..0x823B19AC)
	// 823B1918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B191C: 4818379D  bl 0x825350b8
	ctx.lr = 0x823B1920;
	sub_82535080(ctx, base);
	// 823B1920: 9421FD80  stwu r1, -0x280(r1)
	ea = ctx.r[1].u32.wrapping_add(-640 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B1924: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B1928: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B192C: 3BAB1798  addi r29, r11, 0x1798
	ctx.r[29].s64 = ctx.r[11].s64 + 6040;
	// 823B1930: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 823B1934: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823B1938: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823B193C: 38DF0208  addi r6, r31, 0x208
	ctx.r[6].s64 = ctx.r[31].s64 + 520;
	// 823B1940: 38BF0108  addi r5, r31, 0x108
	ctx.r[5].s64 = ctx.r[31].s64 + 264;
	// 823B1944: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823B1948: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 823B194C: 481812D5  bl 0x82532c20
	ctx.lr = 0x823B1950;
	sub_82532C20(ctx, base);
	// 823B1950: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 823B1954: 4BFFF81D  bl 0x823b1170
	ctx.lr = 0x823B1958;
	sub_823B1170(ctx, base);
	// 823B1958: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 823B195C: 38DE0208  addi r6, r30, 0x208
	ctx.r[6].s64 = ctx.r[30].s64 + 520;
	// 823B1960: 38BE0108  addi r5, r30, 0x108
	ctx.r[5].s64 = ctx.r[30].s64 + 264;
	// 823B1964: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823B1968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B196C: 481812B5  bl 0x82532c20
	ctx.lr = 0x823B1970;
	sub_82532C20(ctx, base);
	// 823B1970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B1974: 4BFFF7FD  bl 0x823b1170
	ctx.lr = 0x823B1978;
	sub_823B1170(ctx, base);
	// 823B1978: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 823B197C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823B1980: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 823B1984: 4800FAAD  bl 0x823c1430
	ctx.lr = 0x823B1988;
	sub_823C1430(ctx, base);
	// 823B1988: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B198C: 4800ECF5  bl 0x823c0680
	ctx.lr = 0x823B1990;
	sub_823C0680(ctx, base);
	// 823B1990: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1994: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823B1998: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B199C: 409A0010  bne cr6, 0x823b19ac
	if !ctx.cr[6].eq {
	pc = 0x823B19AC; continue 'dispatch;
	}
	// 823B19A0: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B19A4: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B19A8: 48000008  b 0x823b19b0
	pc = 0x823B19B0; continue 'dispatch;
            }
            0x823B19AC => {
    //   block [0x823B19AC..0x823B19B0)
	// 823B19AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823B19B0; continue 'dispatch;
            }
            0x823B19B0 => {
    //   block [0x823B19B0..0x823B19B8)
	// 823B19B0: 38210280  addi r1, r1, 0x280
	ctx.r[1].s64 = ctx.r[1].s64 + 640;
	// 823B19B4: 48183754  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B19B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B19B8 size=84
    let mut pc: u32 = 0x823B19B8;
    'dispatch: loop {
        match pc {
            0x823B19B8 => {
    //   block [0x823B19B8..0x823B1A0C)
	// 823B19B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B19BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B19C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B19C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B19C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B19CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823B19D0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823B19D4: 38830208  addi r4, r3, 0x208
	ctx.r[4].s64 = ctx.r[3].s64 + 520;
	// 823B19D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823B19DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B19E0: 481811E1  bl 0x82532bc0
	ctx.lr = 0x823B19E4;
	sub_82532BC0(ctx, base);
	// 823B19E4: 7D7FF214  add r11, r31, r30
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 823B19E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B19EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B19F0: 994BFFFF  stb r10, -1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-1 as u32), ctx.r[10].u8 ) };
	// 823B19F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B19F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B19FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B1A00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B1A04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B1A08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B1A10 size=276
    let mut pc: u32 = 0x823B1A10;
    'dispatch: loop {
        match pc {
            0x823B1A10 => {
    //   block [0x823B1A10..0x823B1A3C)
	// 823B1A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B1A14: 481836A9  bl 0x825350bc
	ctx.lr = 0x823B1A18;
	sub_82535080(ctx, base);
	// 823B1A18: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B1A1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B1A20: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823B1A24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B1A28: 48181199  bl 0x82532bc0
	ctx.lr = 0x823B1A2C;
	sub_82532BC0(ctx, base);
	// 823B1A2C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823B1A30: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823B1A34: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 823B1A38: 9BA1014F  stb r29, 0x14f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(335 as u32), ctx.r[29].u8 ) };
	pc = 0x823B1A3C; continue 'dispatch;
            }
            0x823B1A3C => {
    //   block [0x823B1A3C..0x823B1A90)
	// 823B1A3C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B1A40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823B1A44: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823B1A48: 409AFFF4  bne cr6, 0x823b1a3c
	if !ctx.cr[6].eq {
	pc = 0x823B1A3C; continue 'dispatch;
	}
	// 823B1A4C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 823B1A50: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823B1A54: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823B1A58: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B1A5C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823B1A60: 892AFFFF  lbz r9, -1(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-1 as u32) ) } as u64;
	// 823B1A64: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 823B1A68: 2F09005C  cmpwi cr6, r9, 0x5c
	ctx.cr[6].compare_i32(ctx.r[9].s32, 92, &mut ctx.xer);
	// 823B1A6C: 419A0024  beq cr6, 0x823b1a90
	if ctx.cr[6].eq {
	pc = 0x823B1A90; continue 'dispatch;
	}
	// 823B1A70: 2F09002F  cmpwi cr6, r9, 0x2f
	ctx.cr[6].compare_i32(ctx.r[9].s32, 47, &mut ctx.xer);
	// 823B1A74: 419A001C  beq cr6, 0x823b1a90
	if ctx.cr[6].eq {
	pc = 0x823B1A90; continue 'dispatch;
	}
	// 823B1A78: 2B0B00FE  cmplwi cr6, r11, 0xfe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 254 as u32, &mut ctx.xer);
	// 823B1A7C: 40980014  bge cr6, 0x823b1a90
	if !ctx.cr[6].lt {
	pc = 0x823B1A90; continue 'dispatch;
	}
	// 823B1A80: 3920005C  li r9, 0x5c
	ctx.r[9].s64 = 92;
	// 823B1A84: 39010051  addi r8, r1, 0x51
	ctx.r[8].s64 = ctx.r[1].s64 + 81;
	// 823B1A88: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 823B1A8C: 7FAB41AE  stbx r29, r11, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[29].u8) };
	pc = 0x823B1A90; continue 'dispatch;
            }
            0x823B1A90 => {
    //   block [0x823B1A90..0x823B1AE4)
	// 823B1A90: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 823B1A94: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823B1A98: 388BDEB4  addi r4, r11, -0x214c
	ctx.r[4].s64 = ctx.r[11].s64 + -8524;
	// 823B1A9C: 38BE0108  addi r5, r30, 0x108
	ctx.r[5].s64 = ctx.r[30].s64 + 264;
	// 823B1AA0: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 823B1AA4: 4818117D  bl 0x82532c20
	ctx.lr = 0x823B1AA8;
	sub_82532C20(ctx, base);
	// 823B1AA8: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 823B1AAC: 481953ED  bl 0x82546e98
	ctx.lr = 0x823B1AB0;
	sub_82546E98(ctx, base);
	// 823B1AB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B1AB4: 4800EBCD  bl 0x823c0680
	ctx.lr = 0x823B1AB8;
	sub_823C0680(ctx, base);
	// 823B1AB8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1ABC: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 823B1AC0: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B1AC4: 409A002C  bne cr6, 0x823b1af0
	if !ctx.cr[6].eq {
	pc = 0x823B1AF0; continue 'dispatch;
	}
	// 823B1AC8: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 823B1ACC: 41980018  blt cr6, 0x823b1ae4
	if ctx.cr[6].lt {
	pc = 0x823B1AE4; continue 'dispatch;
	}
	// 823B1AD0: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 823B1AD4: 41990010  bgt cr6, 0x823b1ae4
	if ctx.cr[6].gt {
	pc = 0x823B1AE4; continue 'dispatch;
	}
	// 823B1AD8: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1ADC: 6063FFFE  ori r3, r3, 0xfffe
	ctx.r[3].u64 = ctx.r[3].u64 | 65534;
	// 823B1AE0: 4800003C  b 0x823b1b1c
	pc = 0x823B1B1C; continue 'dispatch;
            }
            0x823B1AE4 => {
    //   block [0x823B1AE4..0x823B1AF0)
	// 823B1AE4: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1AE8: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B1AEC: 48000030  b 0x823b1b1c
	pc = 0x823B1B1C; continue 'dispatch;
            }
            0x823B1AF0 => {
    //   block [0x823B1AF0..0x823B1B04)
	// 823B1AF0: 57EB06F7  rlwinm. r11, r31, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B1AF4: 40820010  bne 0x823b1b04
	if !ctx.cr[0].eq {
	pc = 0x823B1B04; continue 'dispatch;
	}
	// 823B1AF8: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1AFC: 6063FFFB  ori r3, r3, 0xfffb
	ctx.r[3].u64 = ctx.r[3].u64 | 65531;
	// 823B1B00: 4800001C  b 0x823b1b1c
	pc = 0x823B1B1C; continue 'dispatch;
            }
            0x823B1B04 => {
    //   block [0x823B1B04..0x823B1B1C)
	// 823B1B04: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823B1B08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823B1B0C: 387E0208  addi r3, r30, 0x208
	ctx.r[3].s64 = ctx.r[30].s64 + 520;
	// 823B1B10: 481810B1  bl 0x82532bc0
	ctx.lr = 0x823B1B14;
	sub_82532BC0(ctx, base);
	// 823B1B14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B1B18: 9BBE0307  stb r29, 0x307(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(775 as u32), ctx.r[29].u8 ) };
	pc = 0x823B1B1C; continue 'dispatch;
            }
            0x823B1B1C => {
    //   block [0x823B1B1C..0x823B1B24)
	// 823B1B1C: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 823B1B20: 481835EC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B1B28 size=384
    let mut pc: u32 = 0x823B1B28;
    'dispatch: loop {
        match pc {
            0x823B1B28 => {
    //   block [0x823B1B28..0x823B1BA8)
	// 823B1B28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B1B2C: 4818358D  bl 0x825350b8
	ctx.lr = 0x823B1B30;
	sub_82535080(ctx, base);
	// 823B1B30: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B1B34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B1B38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823B1B3C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B1B40: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823B1B44: 388B1798  addi r4, r11, 0x1798
	ctx.r[4].s64 = ctx.r[11].s64 + 6040;
	// 823B1B48: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 823B1B4C: 38DE0208  addi r6, r30, 0x208
	ctx.r[6].s64 = ctx.r[30].s64 + 520;
	// 823B1B50: 38BE0108  addi r5, r30, 0x108
	ctx.r[5].s64 = ctx.r[30].s64 + 264;
	// 823B1B54: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 823B1B58: 481810C9  bl 0x82532c20
	ctx.lr = 0x823B1B5C;
	sub_82532C20(ctx, base);
	// 823B1B5C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 823B1B60: 4BFFF611  bl 0x823b1170
	ctx.lr = 0x823B1B64;
	sub_823B1170(ctx, base);
	// 823B1B64: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 823B1B68: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B1B6C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 823B1B70: 48019AE9  bl 0x823cb658
	ctx.lr = 0x823B1B74;
	sub_823CB658(ctx, base);
	// 823B1B74: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823B1B78: 4800EB09  bl 0x823c0680
	ctx.lr = 0x823B1B7C;
	sub_823C0680(ctx, base);
	// 823B1B7C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1B80: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823B1B84: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B1B88: 409A002C  bne cr6, 0x823b1bb4
	if !ctx.cr[6].eq {
	pc = 0x823B1BB4; continue 'dispatch;
	}
	// 823B1B8C: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 823B1B90: 41980018  blt cr6, 0x823b1ba8
	if ctx.cr[6].lt {
	pc = 0x823B1BA8; continue 'dispatch;
	}
	// 823B1B94: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 823B1B98: 41990010  bgt cr6, 0x823b1ba8
	if ctx.cr[6].gt {
	pc = 0x823B1BA8; continue 'dispatch;
	}
	// 823B1B9C: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1BA0: 6063FFFE  ori r3, r3, 0xfffe
	ctx.r[3].u64 = ctx.r[3].u64 | 65534;
	// 823B1BA4: 480000FC  b 0x823b1ca0
	pc = 0x823B1CA0; continue 'dispatch;
            }
            0x823B1BA8 => {
    //   block [0x823B1BA8..0x823B1BB4)
	// 823B1BA8: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1BAC: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B1BB0: 480000F0  b 0x823b1ca0
	pc = 0x823B1CA0; continue 'dispatch;
            }
            0x823B1BB4 => {
    //   block [0x823B1BB4..0x823B1BBC)
	// 823B1BB4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 823B1BB8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x823B1BBC; continue 'dispatch;
            }
            0x823B1BBC => {
    //   block [0x823B1BBC..0x823B1BE0)
	// 823B1BBC: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B1BC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823B1BC4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823B1BC8: 409AFFF4  bne cr6, 0x823b1bbc
	if !ctx.cr[6].eq {
	pc = 0x823B1BBC; continue 'dispatch;
	}
	// 823B1BCC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 823B1BD0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823B1BD4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B1BD8: 7FCBFA14  add r30, r11, r31
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823B1BDC: 48000014  b 0x823b1bf0
	pc = 0x823B1BF0; continue 'dispatch;
            }
            0x823B1BE0 => {
    //   block [0x823B1BE0..0x823B1BF0)
	// 823B1BE0: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B1BE4: 2B0B005C  cmplwi cr6, r11, 0x5c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 92 as u32, &mut ctx.xer);
	// 823B1BE8: 419A0014  beq cr6, 0x823b1bfc
	if ctx.cr[6].eq {
	pc = 0x823B1BFC; continue 'dispatch;
	}
	// 823B1BEC: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	pc = 0x823B1BF0; continue 'dispatch;
            }
            0x823B1BF0 => {
    //   block [0x823B1BF0..0x823B1BFC)
	// 823B1BF0: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 823B1BF4: 4199FFEC  bgt cr6, 0x823b1be0
	if ctx.cr[6].gt {
	pc = 0x823B1BE0; continue 'dispatch;
	}
	// 823B1BF8: 48000008  b 0x823b1c00
	pc = 0x823B1C00; continue 'dispatch;
            }
            0x823B1BFC => {
    //   block [0x823B1BFC..0x823B1C00)
	// 823B1BFC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	pc = 0x823B1C00; continue 'dispatch;
            }
            0x823B1C00 => {
    //   block [0x823B1C00..0x823B1C84)
	// 823B1C00: 38A00128  li r5, 0x128
	ctx.r[5].s64 = 296;
	// 823B1C04: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B1C08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B1C0C: 481835C5  bl 0x825351d0
	ctx.lr = 0x823B1C10;
	sub_825351D0(ctx, base);
	// 823B1C10: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823B1C14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B1C18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B1C1C: 48180FA5  bl 0x82532bc0
	ctx.lr = 0x823B1C20;
	sub_82532BC0(ctx, base);
	// 823B1C20: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 823B1C24: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 823B1C28: 387D0108  addi r3, r29, 0x108
	ctx.r[3].s64 = ctx.r[29].s64 + 264;
	// 823B1C2C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823B1C30: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 823B1C34: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823B1C38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823B1C3C: 997D00FF  stb r11, 0xff(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(255 as u32), ctx.r[11].u8 ) };
	// 823B1C40: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823B1C44: F97D0100  std r11, 0x100(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(256 as u32), ctx.r[11].u64 ) };
	// 823B1C48: 4BFFF5C9  bl 0x823b1210
	ctx.lr = 0x823B1C4C;
	sub_823B1210(ctx, base);
	// 823B1C4C: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 823B1C50: 387D0110  addi r3, r29, 0x110
	ctx.r[3].s64 = ctx.r[29].s64 + 272;
	// 823B1C54: 4BFFF5BD  bl 0x823b1210
	ctx.lr = 0x823B1C58;
	sub_823B1210(ctx, base);
	// 823B1C58: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 823B1C5C: 387D0118  addi r3, r29, 0x118
	ctx.r[3].s64 = ctx.r[29].s64 + 280;
	// 823B1C60: 4BFFF5B1  bl 0x823b1210
	ctx.lr = 0x823B1C64;
	sub_823B1210(ctx, base);
	// 823B1C64: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 823B1C68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823B1C6C: 5549077B  rlwinm. r9, r10, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823B1C70: 40820028  bne 0x823b1c98
	if !ctx.cr[0].eq {
	pc = 0x823B1C98; continue 'dispatch;
	}
	// 823B1C74: 554907FF  clrlwi. r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823B1C78: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 823B1C7C: 40820008  bne 0x823b1c84
	if !ctx.cr[0].eq {
	pc = 0x823B1C84; continue 'dispatch;
	}
	// 823B1C80: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	pc = 0x823B1C84; continue 'dispatch;
            }
            0x823B1C84 => {
    //   block [0x823B1C84..0x823B1C94)
	// 823B1C84: 554A06F7  rlwinm. r10, r10, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B1C88: 4182000C  beq 0x823b1c94
	if ctx.cr[0].eq {
	pc = 0x823B1C94; continue 'dispatch;
	}
	// 823B1C8C: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 823B1C90: 48000008  b 0x823b1c98
	pc = 0x823B1C98; continue 'dispatch;
            }
            0x823B1C94 => {
    //   block [0x823B1C94..0x823B1C98)
	// 823B1C94: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	pc = 0x823B1C98; continue 'dispatch;
            }
            0x823B1C98 => {
    //   block [0x823B1C98..0x823B1CA0)
	// 823B1C98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B1C9C: 917D0120  stw r11, 0x120(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	pc = 0x823B1CA0; continue 'dispatch;
            }
            0x823B1CA0 => {
    //   block [0x823B1CA0..0x823B1CA8)
	// 823B1CA0: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 823B1CA4: 48183464  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B1CA8 size=152
    let mut pc: u32 = 0x823B1CA8;
    'dispatch: loop {
        match pc {
            0x823B1CA8 => {
    //   block [0x823B1CA8..0x823B1D1C)
	// 823B1CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B1CAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B1CB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B1CB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B1CB8: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B1CBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B1CC0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B1CC4: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 823B1CC8: 388B1798  addi r4, r11, 0x1798
	ctx.r[4].s64 = ctx.r[11].s64 + 6040;
	// 823B1CCC: 38DF0208  addi r6, r31, 0x208
	ctx.r[6].s64 = ctx.r[31].s64 + 520;
	// 823B1CD0: 38BF0108  addi r5, r31, 0x108
	ctx.r[5].s64 = ctx.r[31].s64 + 264;
	// 823B1CD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B1CD8: 48180F49  bl 0x82532c20
	ctx.lr = 0x823B1CDC;
	sub_82532C20(ctx, base);
	// 823B1CDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B1CE0: 4BFFF491  bl 0x823b1170
	ctx.lr = 0x823B1CE4;
	sub_823B1170(ctx, base);
	// 823B1CE4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B1CE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B1CEC: 48194E4D  bl 0x82546b38
	ctx.lr = 0x823B1CF0;
	sub_82546B38(ctx, base);
	// 823B1CF0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B1CF4: 4800E98D  bl 0x823c0680
	ctx.lr = 0x823B1CF8;
	sub_823C0680(ctx, base);
	// 823B1CF8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1CFC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823B1D00: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B1D04: 409A0020  bne cr6, 0x823b1d24
	if !ctx.cr[6].eq {
	pc = 0x823B1D24; continue 'dispatch;
	}
	// 823B1D08: 2F030050  cmpwi cr6, r3, 0x50
	ctx.cr[6].compare_i32(ctx.r[3].s32, 80, &mut ctx.xer);
	// 823B1D0C: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1D10: 419A000C  beq cr6, 0x823b1d1c
	if ctx.cr[6].eq {
	pc = 0x823B1D1C; continue 'dispatch;
	}
	// 823B1D14: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B1D18: 48000010  b 0x823b1d28
	pc = 0x823B1D28; continue 'dispatch;
            }
            0x823B1D1C => {
    //   block [0x823B1D1C..0x823B1D24)
	// 823B1D1C: 6063FFFD  ori r3, r3, 0xfffd
	ctx.r[3].u64 = ctx.r[3].u64 | 65533;
	// 823B1D20: 48000008  b 0x823b1d28
	pc = 0x823B1D28; continue 'dispatch;
            }
            0x823B1D24 => {
    //   block [0x823B1D24..0x823B1D28)
	// 823B1D24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823B1D28; continue 'dispatch;
            }
            0x823B1D28 => {
    //   block [0x823B1D28..0x823B1D40)
	// 823B1D28: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 823B1D2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B1D30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B1D34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B1D38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B1D3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B1D40 size=160
    let mut pc: u32 = 0x823B1D40;
    'dispatch: loop {
        match pc {
            0x823B1D40 => {
    //   block [0x823B1D40..0x823B1DB8)
	// 823B1D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B1D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B1D48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B1D4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B1D50: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B1D54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B1D58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B1D5C: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 823B1D60: 388B1798  addi r4, r11, 0x1798
	ctx.r[4].s64 = ctx.r[11].s64 + 6040;
	// 823B1D64: 38DF0208  addi r6, r31, 0x208
	ctx.r[6].s64 = ctx.r[31].s64 + 520;
	// 823B1D68: 38BF0108  addi r5, r31, 0x108
	ctx.r[5].s64 = ctx.r[31].s64 + 264;
	// 823B1D6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B1D70: 48180EB1  bl 0x82532c20
	ctx.lr = 0x823B1D74;
	sub_82532C20(ctx, base);
	// 823B1D74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B1D78: 4BFFF3F9  bl 0x823b1170
	ctx.lr = 0x823B1D7C;
	sub_823B1170(ctx, base);
	// 823B1D7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B1D80: 48195051  bl 0x82546dd0
	ctx.lr = 0x823B1D84;
	sub_82546DD0(ctx, base);
	// 823B1D84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B1D88: 4800E8F9  bl 0x823c0680
	ctx.lr = 0x823B1D8C;
	sub_823C0680(ctx, base);
	// 823B1D8C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1D90: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823B1D94: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B1D98: 409A002C  bne cr6, 0x823b1dc4
	if !ctx.cr[6].eq {
	pc = 0x823B1DC4; continue 'dispatch;
	}
	// 823B1D9C: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 823B1DA0: 41980018  blt cr6, 0x823b1db8
	if ctx.cr[6].lt {
	pc = 0x823B1DB8; continue 'dispatch;
	}
	// 823B1DA4: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 823B1DA8: 41990010  bgt cr6, 0x823b1db8
	if ctx.cr[6].gt {
	pc = 0x823B1DB8; continue 'dispatch;
	}
	// 823B1DAC: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1DB0: 6063FFFE  ori r3, r3, 0xfffe
	ctx.r[3].u64 = ctx.r[3].u64 | 65534;
	// 823B1DB4: 48000014  b 0x823b1dc8
	pc = 0x823B1DC8; continue 'dispatch;
            }
            0x823B1DB8 => {
    //   block [0x823B1DB8..0x823B1DC4)
	// 823B1DB8: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1DBC: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B1DC0: 48000008  b 0x823b1dc8
	pc = 0x823B1DC8; continue 'dispatch;
            }
            0x823B1DC4 => {
    //   block [0x823B1DC4..0x823B1DC8)
	// 823B1DC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823B1DC8; continue 'dispatch;
            }
            0x823B1DC8 => {
    //   block [0x823B1DC8..0x823B1DE0)
	// 823B1DC8: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 823B1DCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B1DD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B1DD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B1DD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B1DDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B1DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B1DE0 size=568
    let mut pc: u32 = 0x823B1DE0;
    'dispatch: loop {
        match pc {
            0x823B1DE0 => {
    //   block [0x823B1DE0..0x823B1E5C)
	// 823B1DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B1DE4: 481832CD  bl 0x825350b0
	ctx.lr = 0x823B1DE8;
	sub_82535080(ctx, base);
	// 823B1DE8: 9421FC20  stwu r1, -0x3e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-992 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B1DEC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B1DF0: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 823B1DF4: 388B1798  addi r4, r11, 0x1798
	ctx.r[4].s64 = ctx.r[11].s64 + 6040;
	// 823B1DF8: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
	// 823B1DFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B1E00: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823B1E04: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823B1E08: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823B1E0C: 38DE0208  addi r6, r30, 0x208
	ctx.r[6].s64 = ctx.r[30].s64 + 520;
	// 823B1E10: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823B1E14: 38BE0108  addi r5, r30, 0x108
	ctx.r[5].s64 = ctx.r[30].s64 + 264;
	// 823B1E18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823B1E1C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 823B1E20: 48180E01  bl 0x82532c20
	ctx.lr = 0x823B1E24;
	sub_82532C20(ctx, base);
	// 823B1E24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823B1E28: 4BFFF349  bl 0x823b1170
	ctx.lr = 0x823B1E2C;
	sub_823B1170(ctx, base);
	// 823B1E2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823B1E30: 48195069  bl 0x82546e98
	ctx.lr = 0x823B1E34;
	sub_82546E98(ctx, base);
	// 823B1E34: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 823B1E38: 419A0024  beq cr6, 0x823b1e5c
	if ctx.cr[6].eq {
	pc = 0x823B1E5C; continue 'dispatch;
	}
	// 823B1E3C: 546B06F7  rlwinm. r11, r3, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B1E40: 4182001C  beq 0x823b1e5c
	if ctx.cr[0].eq {
	pc = 0x823B1E5C; continue 'dispatch;
	}
	// 823B1E44: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B1E48: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823B1E4C: 388B17A0  addi r4, r11, 0x17a0
	ctx.r[4].s64 = ctx.r[11].s64 + 6048;
	// 823B1E50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823B1E54: 481828E5  bl 0x82534738
	ctx.lr = 0x823B1E58;
	sub_82534738(ctx, base);
	// 823B1E58: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	pc = 0x823B1E5C; continue 'dispatch;
            }
            0x823B1E5C => {
    //   block [0x823B1E5C..0x823B1EA4)
	// 823B1E5C: 38810160  addi r4, r1, 0x160
	ctx.r[4].s64 = ctx.r[1].s64 + 352;
	// 823B1E60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823B1E64: 480196AD  bl 0x823cb510
	ctx.lr = 0x823B1E68;
	sub_823CB510(ctx, base);
	// 823B1E68: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823B1E6C: 4800E815  bl 0x823c0680
	ctx.lr = 0x823B1E70;
	sub_823C0680(ctx, base);
	// 823B1E70: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1E74: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 823B1E78: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B1E7C: 409A0054  bne cr6, 0x823b1ed0
	if !ctx.cr[6].eq {
	pc = 0x823B1ED0; continue 'dispatch;
	}
	// 823B1E80: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 823B1E84: 41980028  blt cr6, 0x823b1eac
	if ctx.cr[6].lt {
	pc = 0x823B1EAC; continue 'dispatch;
	}
	// 823B1E88: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 823B1E8C: 41990020  bgt cr6, 0x823b1eac
	if ctx.cr[6].gt {
	pc = 0x823B1EAC; continue 'dispatch;
	}
	// 823B1E90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823B1E94: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1E98: 419A000C  beq cr6, 0x823b1ea4
	if ctx.cr[6].eq {
	pc = 0x823B1EA4; continue 'dispatch;
	}
	// 823B1E9C: 6063FFF1  ori r3, r3, 0xfff1
	ctx.r[3].u64 = ctx.r[3].u64 | 65521;
	// 823B1EA0: 48000170  b 0x823b2010
	pc = 0x823B2010; continue 'dispatch;
            }
            0x823B1EA4 => {
    //   block [0x823B1EA4..0x823B1EAC)
	// 823B1EA4: 6063FFFE  ori r3, r3, 0xfffe
	ctx.r[3].u64 = ctx.r[3].u64 | 65534;
	// 823B1EA8: 48000168  b 0x823b2010
	pc = 0x823B2010; continue 'dispatch;
            }
            0x823B1EAC => {
    //   block [0x823B1EAC..0x823B1EB8)
	// 823B1EAC: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B1EB0: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B1EB4: 4800015C  b 0x823b2010
	pc = 0x823B2010; continue 'dispatch;
            }
            0x823B1EB8 => {
    //   block [0x823B1EB8..0x823B1ED0)
	// 823B1EB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823B1EBC: 480195FD  bl 0x823cb4b8
	ctx.lr = 0x823B1EC0;
	sub_823CB4B8(ctx, base);
	// 823B1EC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B1EC4: 4800E7BD  bl 0x823c0680
	ctx.lr = 0x823B1EC8;
	sub_823C0680(ctx, base);
	// 823B1EC8: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823B1ECC: 419A00F8  beq cr6, 0x823b1fc4
	if ctx.cr[6].eq {
	pc = 0x823B1FC4; continue 'dispatch;
	}
	pc = 0x823B1ED0; continue 'dispatch;
            }
            0x823B1ED0 => {
    //   block [0x823B1ED0..0x823B1F0C)
	// 823B1ED0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823B1ED4: 3861018C  addi r3, r1, 0x18c
	ctx.r[3].s64 = ctx.r[1].s64 + 396;
	// 823B1ED8: 4BFFEFF9  bl 0x823b0ed0
	ctx.lr = 0x823B1EDC;
	sub_823B0ED0(ctx, base);
	// 823B1EDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B1EE0: 38810160  addi r4, r1, 0x160
	ctx.r[4].s64 = ctx.r[1].s64 + 352;
	// 823B1EE4: 4182FFD4  beq 0x823b1eb8
	if ctx.cr[0].eq {
	pc = 0x823B1EB8; continue 'dispatch;
	}
	// 823B1EE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B1EEC: 4BFFF39D  bl 0x823b1288
	ctx.lr = 0x823B1EF0;
	sub_823B1288(ctx, base);
	// 823B1EF0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1EF4: 4BFEC38D  bl 0x8239e280
	ctx.lr = 0x823B1EF8;
	sub_8239E280(ctx, base);
	// 823B1EF8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823B1EFC: 40820010  bne 0x823b1f0c
	if !ctx.cr[0].eq {
	pc = 0x823B1F0C; continue 'dispatch;
	}
	// 823B1F00: 3FE0FEFF  lis r31, -0x101
	ctx.r[31].s64 = -16842752;
	// 823B1F04: 63FFFFF5  ori r31, r31, 0xfff5
	ctx.r[31].u64 = ctx.r[31].u64 | 65525;
	// 823B1F08: 480000DC  b 0x823b1fe4
	pc = 0x823B1FE4; continue 'dispatch;
            }
            0x823B1F0C => {
    //   block [0x823B1F0C..0x823B1F44)
	// 823B1F0C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 823B1F10: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823B1F14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823B1F18: 388102A0  addi r4, r1, 0x2a0
	ctx.r[4].s64 = ctx.r[1].s64 + 672;
	// 823B1F1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823B1F20: 4BFFEDF9  bl 0x823b0d18
	ctx.lr = 0x823B1F24;
	sub_823B0D18(ctx, base);
	// 823B1F24: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1F28: 3D407FFF  lis r10, 0x7fff
	ctx.r[10].s64 = 2147418112;
	// 823B1F2C: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 823B1F30: 83AB0028  lwz r29, 0x28(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 823B1F34: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823B1F38: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823B1F3C: 40980008  bge cr6, 0x823b1f44
	if !ctx.cr[6].lt {
	pc = 0x823B1F44; continue 'dispatch;
	}
	// 823B1F40: 395D0001  addi r10, r29, 1
	ctx.r[10].s64 = ctx.r[29].s64 + 1;
	pc = 0x823B1F44; continue 'dispatch;
            }
            0x823B1F44 => {
    //   block [0x823B1F44..0x823B1FC4)
	// 823B1F44: 914B0028  stw r10, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 823B1F48: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B1F4C: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823B1F50: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 823B1F54: 396B17A4  addi r11, r11, 0x17a4
	ctx.r[11].s64 = ctx.r[11].s64 + 6052;
	// 823B1F58: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823B1F5C: 388102A0  addi r4, r1, 0x2a0
	ctx.r[4].s64 = ctx.r[1].s64 + 672;
	// 823B1F60: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 823B1F64: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B1F68: 48180C59  bl 0x82532bc0
	ctx.lr = 0x823B1F6C;
	sub_82532BC0(ctx, base);
	// 823B1F6C: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823B1F70: 9B5F010B  stb r26, 0x10b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(267 as u32), ctx.r[26].u8 ) };
	// 823B1F74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823B1F78: 387F010C  addi r3, r31, 0x10c
	ctx.r[3].s64 = ctx.r[31].s64 + 268;
	// 823B1F7C: 48180C45  bl 0x82532bc0
	ctx.lr = 0x823B1F80;
	sub_82532BC0(ctx, base);
	// 823B1F80: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B1F84: 9B5F020B  stb r26, 0x20b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(523 as u32), ctx.r[26].u8 ) };
	// 823B1F88: 396B17A4  addi r11, r11, 0x17a4
	ctx.r[11].s64 = ctx.r[11].s64 + 6052;
	// 823B1F8C: 939F020C  stw r28, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[28].u32 ) };
	// 823B1F90: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 823B1F94: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B1F98: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1F9C: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 823B1FA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B1FA4: 4835B2B9  bl 0x8270d25c
	ctx.lr = 0x823B1FA8;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B1FA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823B1FAC: 387F1EAC  addi r3, r31, 0x1eac
	ctx.r[3].s64 = ctx.r[31].s64 + 7852;
	// 823B1FB0: 4BFF7C59  bl 0x823a9c08
	ctx.lr = 0x823B1FB4;
	sub_823A9C08(ctx, base);
	// 823B1FB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B1FB8: 4835B2B5  bl 0x8270d26c
	ctx.lr = 0x823B1FBC;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B1FBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B1FC0: 48000050  b 0x823b2010
	pc = 0x823B2010; continue 'dispatch;
            }
            0x823B1FC4 => {
    //   block [0x823B1FC4..0x823B1FE0)
	// 823B1FC4: 2F030012  cmpwi cr6, r3, 0x12
	ctx.cr[6].compare_i32(ctx.r[3].s32, 18, &mut ctx.xer);
	// 823B1FC8: 3FE0FEFF  lis r31, -0x101
	ctx.r[31].s64 = -16842752;
	// 823B1FCC: 419A0014  beq cr6, 0x823b1fe0
	if ctx.cr[6].eq {
	pc = 0x823B1FE0; continue 'dispatch;
	}
	// 823B1FD0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B1FD4: 63FFFFEE  ori r31, r31, 0xffee
	ctx.r[31].u64 = ctx.r[31].u64 | 65518;
	// 823B1FD8: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B1FDC: 48000008  b 0x823b1fe4
	pc = 0x823B1FE4; continue 'dispatch;
            }
            0x823B1FE0 => {
    //   block [0x823B1FE0..0x823B1FE4)
	// 823B1FE0: 63FFFFF1  ori r31, r31, 0xfff1
	ctx.r[31].u64 = ctx.r[31].u64 | 65521;
	pc = 0x823B1FE4; continue 'dispatch;
            }
            0x823B1FE4 => {
    //   block [0x823B1FE4..0x823B200C)
	// 823B1FE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823B1FE8: 4800E971  bl 0x823c0958
	ctx.lr = 0x823B1FEC;
	sub_823C0958(ctx, base);
	// 823B1FEC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823B1FF0: 4800E691  bl 0x823c0680
	ctx.lr = 0x823B1FF4;
	sub_823C0680(ctx, base);
	// 823B1FF4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823B1FF8: 409A0014  bne cr6, 0x823b200c
	if !ctx.cr[6].eq {
	pc = 0x823B200C; continue 'dispatch;
	}
	// 823B1FFC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B2000: 3FE0FEFF  lis r31, -0x101
	ctx.r[31].s64 = -16842752;
	// 823B2004: 63FFFFEE  ori r31, r31, 0xffee
	ctx.r[31].u64 = ctx.r[31].u64 | 65518;
	// 823B2008: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	pc = 0x823B200C; continue 'dispatch;
            }
            0x823B200C => {
    //   block [0x823B200C..0x823B2010)
	// 823B200C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x823B2010; continue 'dispatch;
            }
            0x823B2010 => {
    //   block [0x823B2010..0x823B2018)
	// 823B2010: 382103E0  addi r1, r1, 0x3e0
	ctx.r[1].s64 = ctx.r[1].s64 + 992;
	// 823B2014: 481830EC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2018 size=168
    let mut pc: u32 = 0x823B2018;
    'dispatch: loop {
        match pc {
            0x823B2018 => {
    //   block [0x823B2018..0x823B2058)
	// 823B2018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B201C: 48183099  bl 0x825350b4
	ctx.lr = 0x823B2020;
	sub_82535080(ctx, base);
	// 823B2020: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B2024: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823B2028: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823B202C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B2030: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 823B2034: 807F020C  lwz r3, 0x20c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 823B2038: 48019481  bl 0x823cb4b8
	ctx.lr = 0x823B203C;
	sub_823CB4B8(ctx, base);
	// 823B203C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823B2040: 4800E641  bl 0x823c0680
	ctx.lr = 0x823B2044;
	sub_823C0680(ctx, base);
	// 823B2044: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B2048: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823B204C: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B2050: 419A0040  beq cr6, 0x823b2090
	if ctx.cr[6].eq {
	pc = 0x823B2090; continue 'dispatch;
	}
	// 823B2054: 3B7F010C  addi r27, r31, 0x10c
	ctx.r[27].s64 = ctx.r[31].s64 + 268;
	pc = 0x823B2058; continue 'dispatch;
            }
            0x823B2058 => {
    //   block [0x823B2058..0x823B2090)
	// 823B2058: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823B205C: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 823B2060: 4BFFEE71  bl 0x823b0ed0
	ctx.lr = 0x823B2064;
	sub_823B0ED0(ctx, base);
	// 823B2064: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B2068: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823B206C: 40820040  bne 0x823b20ac
	if !ctx.cr[0].eq {
	pc = 0x823B20AC; continue 'dispatch;
	}
	// 823B2070: 807F020C  lwz r3, 0x20c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 823B2074: 48019445  bl 0x823cb4b8
	ctx.lr = 0x823B2078;
	sub_823CB4B8(ctx, base);
	// 823B2078: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823B207C: 4800E605  bl 0x823c0680
	ctx.lr = 0x823B2080;
	sub_823C0680(ctx, base);
	// 823B2080: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B2084: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823B2088: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B208C: 409AFFCC  bne cr6, 0x823b2058
	if !ctx.cr[6].eq {
	pc = 0x823B2058; continue 'dispatch;
	}
	pc = 0x823B2090; continue 'dispatch;
            }
            0x823B2090 => {
    //   block [0x823B2090..0x823B20A4)
	// 823B2090: 2F030012  cmpwi cr6, r3, 0x12
	ctx.cr[6].compare_i32(ctx.r[3].s32, 18, &mut ctx.xer);
	// 823B2094: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B2098: 419A000C  beq cr6, 0x823b20a4
	if ctx.cr[6].eq {
	pc = 0x823B20A4; continue 'dispatch;
	}
	// 823B209C: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B20A0: 48000018  b 0x823b20b8
	pc = 0x823B20B8; continue 'dispatch;
            }
            0x823B20A4 => {
    //   block [0x823B20A4..0x823B20AC)
	// 823B20A4: 6063FFF1  ori r3, r3, 0xfff1
	ctx.r[3].u64 = ctx.r[3].u64 | 65521;
	// 823B20A8: 48000010  b 0x823b20b8
	pc = 0x823B20B8; continue 'dispatch;
            }
            0x823B20AC => {
    //   block [0x823B20AC..0x823B20B8)
	// 823B20AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823B20B0: 4BFFF1D9  bl 0x823b1288
	ctx.lr = 0x823B20B4;
	sub_823B1288(ctx, base);
	// 823B20B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823B20B8; continue 'dispatch;
            }
            0x823B20B8 => {
    //   block [0x823B20B8..0x823B20C0)
	// 823B20B8: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 823B20BC: 48183048  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B20C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B20C0 size=88
    let mut pc: u32 = 0x823B20C0;
    'dispatch: loop {
        match pc {
            0x823B20C0 => {
    //   block [0x823B20C0..0x823B2100)
	// 823B20C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B20C4: 48182FF9  bl 0x825350bc
	ctx.lr = 0x823B20C8;
	sub_82535080(ctx, base);
	// 823B20C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B20CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823B20D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B20D4: 807E020C  lwz r3, 0x20c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(524 as u32) ) } as u64;
	// 823B20D8: 4800E881  bl 0x823c0958
	ctx.lr = 0x823B20DC;
	sub_823C0958(ctx, base);
	// 823B20DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823B20E0: 4800E5A1  bl 0x823c0680
	ctx.lr = 0x823B20E4;
	sub_823C0680(ctx, base);
	// 823B20E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B20E8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823B20EC: 906B0024  stw r3, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B20F0: 409A0010  bne cr6, 0x823b2100
	if !ctx.cr[6].eq {
	pc = 0x823B2100; continue 'dispatch;
	}
	// 823B20F4: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B20F8: 6063FFEE  ori r3, r3, 0xffee
	ctx.r[3].u64 = ctx.r[3].u64 | 65518;
	// 823B20FC: 48000014  b 0x823b2110
	pc = 0x823B2110; continue 'dispatch;
            }
            0x823B2100 => {
    //   block [0x823B2100..0x823B2110)
	// 823B2100: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B2104: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B2108: 4BFEC241  bl 0x8239e348
	ctx.lr = 0x823B210C;
	sub_8239E348(ctx, base);
	// 823B210C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823B2110; continue 'dispatch;
            }
            0x823B2110 => {
    //   block [0x823B2110..0x823B2118)
	// 823B2110: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B2114: 48182FF8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B2118 size=12
    let mut pc: u32 = 0x823B2118;
    'dispatch: loop {
        match pc {
            0x823B2118 => {
    //   block [0x823B2118..0x823B2124)
	// 823B2118: 3C60FEFF  lis r3, -0x101
	ctx.r[3].s64 = -16842752;
	// 823B211C: 6063FFF6  ori r3, r3, 0xfff6
	ctx.r[3].u64 = ctx.r[3].u64 | 65526;
	// 823B2120: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2128 size=132
    let mut pc: u32 = 0x823B2128;
    'dispatch: loop {
        match pc {
            0x823B2128 => {
    //   block [0x823B2128..0x823B217C)
	// 823B2128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B212C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B2130: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B2134: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B2138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B213C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B2140: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823B2144: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B2148: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B214C: 409A0030  bne cr6, 0x823b217c
	if !ctx.cr[6].eq {
	pc = 0x823B217C; continue 'dispatch;
	}
	// 823B2150: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823B2154: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B2158: 396BF080  addi r11, r11, -0xf80
	ctx.r[11].s64 = ctx.r[11].s64 + -3968;
	// 823B215C: 386B0080  addi r3, r11, 0x80
	ctx.r[3].s64 = ctx.r[11].s64 + 128;
	// 823B2160: 4BFF6961  bl 0x823a8ac0
	ctx.lr = 0x823B2164;
	sub_823A8AC0(ctx, base);
	// 823B2164: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B2168: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 823B216C: 40820010  bne 0x823b217c
	if !ctx.cr[0].eq {
	pc = 0x823B217C; continue 'dispatch;
	}
	// 823B2170: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823B2174: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 823B2178: 4800001C  b 0x823b2194
	pc = 0x823B2194; continue 'dispatch;
            }
            0x823B217C => {
    //   block [0x823B217C..0x823B2194)
	// 823B217C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B2180: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B2184: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B2188: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B218C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B2190: 4E800421  bctrl
	ctx.lr = 0x823B2194;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823B2194 => {
    //   block [0x823B2194..0x823B21AC)
	// 823B2194: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B2198: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B219C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B21A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B21A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B21A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B21B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B21B0 size=132
    let mut pc: u32 = 0x823B21B0;
    'dispatch: loop {
        match pc {
            0x823B21B0 => {
    //   block [0x823B21B0..0x823B2204)
	// 823B21B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B21B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B21B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B21BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B21C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B21C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B21C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823B21CC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B21D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B21D4: 409A0030  bne cr6, 0x823b2204
	if !ctx.cr[6].eq {
	pc = 0x823B2204; continue 'dispatch;
	}
	// 823B21D8: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823B21DC: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B21E0: 396BF080  addi r11, r11, -0xf80
	ctx.r[11].s64 = ctx.r[11].s64 + -3968;
	// 823B21E4: 386B0080  addi r3, r11, 0x80
	ctx.r[3].s64 = ctx.r[11].s64 + 128;
	// 823B21E8: 4BFF68D9  bl 0x823a8ac0
	ctx.lr = 0x823B21EC;
	sub_823A8AC0(ctx, base);
	// 823B21EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B21F0: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 823B21F4: 40820010  bne 0x823b2204
	if !ctx.cr[0].eq {
	pc = 0x823B2204; continue 'dispatch;
	}
	// 823B21F8: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823B21FC: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 823B2200: 4800001C  b 0x823b221c
	pc = 0x823B221C; continue 'dispatch;
            }
            0x823B2204 => {
    //   block [0x823B2204..0x823B221C)
	// 823B2204: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B2208: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B220C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B2210: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B2214: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B2218: 4E800421  bctrl
	ctx.lr = 0x823B221C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823B221C => {
    //   block [0x823B221C..0x823B2234)
	// 823B221C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B2220: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B2224: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B2228: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B222C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B2230: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2238 size=116
    let mut pc: u32 = 0x823B2238;
    'dispatch: loop {
        match pc {
            0x823B2238 => {
    //   block [0x823B2238..0x823B2288)
	// 823B2238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B223C: 48182E81  bl 0x825350bc
	ctx.lr = 0x823B2240;
	sub_82535080(ctx, base);
	// 823B2240: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B2244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B2248: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823B224C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823B2250: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B2254: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B2258: 409A0030  bne cr6, 0x823b2288
	if !ctx.cr[6].eq {
	pc = 0x823B2288; continue 'dispatch;
	}
	// 823B225C: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823B2260: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B2264: 396BF080  addi r11, r11, -0xf80
	ctx.r[11].s64 = ctx.r[11].s64 + -3968;
	// 823B2268: 386B0080  addi r3, r11, 0x80
	ctx.r[3].s64 = ctx.r[11].s64 + 128;
	// 823B226C: 4BFF6855  bl 0x823a8ac0
	ctx.lr = 0x823B2270;
	sub_823A8AC0(ctx, base);
	// 823B2270: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B2274: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 823B2278: 40820010  bne 0x823b2288
	if !ctx.cr[0].eq {
	pc = 0x823B2288; continue 'dispatch;
	}
	// 823B227C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823B2280: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 823B2284: 48000020  b 0x823b22a4
	pc = 0x823B22A4; continue 'dispatch;
            }
            0x823B2288 => {
    //   block [0x823B2288..0x823B22A4)
	// 823B2288: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B228C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823B2290: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B2294: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B2298: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B229C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B22A0: 4E800421  bctrl
	ctx.lr = 0x823B22A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823B22A4 => {
    //   block [0x823B22A4..0x823B22AC)
	// 823B22A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B22A8: 48182E64  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B22B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B22B0 size=116
    let mut pc: u32 = 0x823B22B0;
    'dispatch: loop {
        match pc {
            0x823B22B0 => {
    //   block [0x823B22B0..0x823B2300)
	// 823B22B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B22B4: 48182E09  bl 0x825350bc
	ctx.lr = 0x823B22B8;
	sub_82535080(ctx, base);
	// 823B22B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B22BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B22C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823B22C4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823B22C8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B22CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B22D0: 409A0030  bne cr6, 0x823b2300
	if !ctx.cr[6].eq {
	pc = 0x823B2300; continue 'dispatch;
	}
	// 823B22D4: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823B22D8: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B22DC: 396BF080  addi r11, r11, -0xf80
	ctx.r[11].s64 = ctx.r[11].s64 + -3968;
	// 823B22E0: 386B0080  addi r3, r11, 0x80
	ctx.r[3].s64 = ctx.r[11].s64 + 128;
	// 823B22E4: 4BFF67DD  bl 0x823a8ac0
	ctx.lr = 0x823B22E8;
	sub_823A8AC0(ctx, base);
	// 823B22E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B22EC: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 823B22F0: 40820010  bne 0x823b2300
	if !ctx.cr[0].eq {
	pc = 0x823B2300; continue 'dispatch;
	}
	// 823B22F4: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823B22F8: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 823B22FC: 48000020  b 0x823b231c
	pc = 0x823B231C; continue 'dispatch;
            }
            0x823B2300 => {
    //   block [0x823B2300..0x823B231C)
	// 823B2300: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B2304: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823B2308: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B230C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B2310: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 823B2314: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B2318: 4E800421  bctrl
	ctx.lr = 0x823B231C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823B231C => {
    //   block [0x823B231C..0x823B2324)
	// 823B231C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B2320: 48182DEC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2328 size=156
    let mut pc: u32 = 0x823B2328;
    'dispatch: loop {
        match pc {
            0x823B2328 => {
    //   block [0x823B2328..0x823B238C)
	// 823B2328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B232C: 48182D7D  bl 0x825350a8
	ctx.lr = 0x823B2330;
	sub_82535080(ctx, base);
	// 823B2330: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B2334: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B2338: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823B233C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823B2340: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823B2344: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 823B2348: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B234C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 823B2350: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 823B2354: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 823B2358: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B235C: 409A0030  bne cr6, 0x823b238c
	if !ctx.cr[6].eq {
	pc = 0x823B238C; continue 'dispatch;
	}
	// 823B2360: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823B2364: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B2368: 396BF080  addi r11, r11, -0xf80
	ctx.r[11].s64 = ctx.r[11].s64 + -3968;
	// 823B236C: 386B0080  addi r3, r11, 0x80
	ctx.r[3].s64 = ctx.r[11].s64 + 128;
	// 823B2370: 4BFF6751  bl 0x823a8ac0
	ctx.lr = 0x823B2374;
	sub_823A8AC0(ctx, base);
	// 823B2374: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B2378: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 823B237C: 40820010  bne 0x823b238c
	if !ctx.cr[0].eq {
	pc = 0x823B238C; continue 'dispatch;
	}
	// 823B2380: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823B2384: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 823B2388: 48000034  b 0x823b23bc
	pc = 0x823B23BC; continue 'dispatch;
            }
            0x823B238C => {
    //   block [0x823B238C..0x823B23BC)
	// 823B238C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B2390: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 823B2394: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 823B2398: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 823B239C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823B23A0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 823B23A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B23A8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823B23AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B23B0: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 823B23B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B23B8: 4E800421  bctrl
	ctx.lr = 0x823B23BC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823B23BC => {
    //   block [0x823B23BC..0x823B23C4)
	// 823B23BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823B23C0: 48182D38  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B23C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B23C8 size=124
    let mut pc: u32 = 0x823B23C8;
    'dispatch: loop {
        match pc {
            0x823B23C8 => {
    //   block [0x823B23C8..0x823B241C)
	// 823B23C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B23CC: 48182CED  bl 0x825350b8
	ctx.lr = 0x823B23D0;
	sub_82535080(ctx, base);
	// 823B23D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B23D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B23D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823B23DC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823B23E0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823B23E4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B23E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B23EC: 409A0030  bne cr6, 0x823b241c
	if !ctx.cr[6].eq {
	pc = 0x823B241C; continue 'dispatch;
	}
	// 823B23F0: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823B23F4: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B23F8: 396BF080  addi r11, r11, -0xf80
	ctx.r[11].s64 = ctx.r[11].s64 + -3968;
	// 823B23FC: 386B0080  addi r3, r11, 0x80
	ctx.r[3].s64 = ctx.r[11].s64 + 128;
	// 823B2400: 4BFF66C1  bl 0x823a8ac0
	ctx.lr = 0x823B2404;
	sub_823A8AC0(ctx, base);
	// 823B2404: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B2408: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 823B240C: 40820010  bne 0x823b241c
	if !ctx.cr[0].eq {
	pc = 0x823B241C; continue 'dispatch;
	}
	// 823B2410: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823B2414: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 823B2418: 48000024  b 0x823b243c
	pc = 0x823B243C; continue 'dispatch;
            }
            0x823B241C => {
    //   block [0x823B241C..0x823B243C)
	// 823B241C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B2420: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 823B2424: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823B2428: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B242C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B2430: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 823B2434: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B2438: 4E800421  bctrl
	ctx.lr = 0x823B243C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823B243C => {
    //   block [0x823B243C..0x823B2444)
	// 823B243C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823B2440: 48182CC8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2448 size=620
    let mut pc: u32 = 0x823B2448;
    'dispatch: loop {
        match pc {
            0x823B2448 => {
    //   block [0x823B2448..0x823B24C0)
	// 823B2448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B244C: 48182C49  bl 0x82535094
	ctx.lr = 0x823B2450;
	sub_82535080(ctx, base);
	// 823B2450: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B2454: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B2458: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823B245C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 823B2460: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 823B2464: 3A9E001C  addi r20, r30, 0x1c
	ctx.r[20].s64 = ctx.r[30].s64 + 28;
	// 823B2468: 83FE0014  lwz r31, 0x14(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B246C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 823B2470: 8ABB0011  lbz r21, 0x11(r27)
	ctx.r[21].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(17 as u32) ) } as u64;
	// 823B2474: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B2478: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823B247C: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B2480: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 823B2484: 92E1006C  stw r23, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[23].u32 ) };
	// 823B2488: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 823B248C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 823B2490: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 823B2494: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 823B2498: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 823B249C: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B24A0: 9281005C  stw r20, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[20].u32 ) };
	// 823B24A4: 4819C625  bl 0x8254eac8
	ctx.lr = 0x823B24A8;
	sub_8254EAC8(ctx, base);
	// 823B24A8: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B24AC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 823B24B0: 409A0010  bne cr6, 0x823b24c0
	if !ctx.cr[6].eq {
	pc = 0x823B24C0; continue 'dispatch;
	}
	// 823B24B4: 38801000  li r4, 0x1000
	ctx.r[4].s64 = 4096;
	// 823B24B8: 4BFEE4F9  bl 0x823a09b0
	ctx.lr = 0x823B24BC;
	sub_823A09B0(ctx, base);
	// 823B24BC: 907E0050  stw r3, 0x50(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	pc = 0x823B24C0; continue 'dispatch;
            }
            0x823B24C0 => {
    //   block [0x823B24C0..0x823B24D8)
	// 823B24C0: 809E0050  lwz r4, 0x50(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B24C4: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 823B24C8: 409A0010  bne cr6, 0x823b24d8
	if !ctx.cr[6].eq {
	pc = 0x823B24D8; continue 'dispatch;
	}
	// 823B24CC: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 823B24D0: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 823B24D4: 480001D8  b 0x823b26ac
	pc = 0x823B26AC; continue 'dispatch;
            }
            0x823B24D8 => {
    //   block [0x823B24D8..0x823B2520)
	// 823B24D8: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 823B24DC: 4819C73D  bl 0x8254ec18
	ctx.lr = 0x823B24E0;
	sub_8254EC18(ctx, base);
	// 823B24E0: 57F806BE  clrlwi r24, r31, 0x1a
	ctx.r[24].u64 = ctx.r[31].u32 as u64 & 0x0000003Fu64;
	// 823B24E4: 2B18002C  cmplwi cr6, r24, 0x2c
	ctx.cr[6].compare_u32(ctx.r[24].u32, 44 as u32, &mut ctx.xer);
	// 823B24E8: 41990038  bgt cr6, 0x823b2520
	if ctx.cr[6].gt {
	pc = 0x823B2520; continue 'dispatch;
	}
	// 823B24EC: 419A0064  beq cr6, 0x823b2550
	if ctx.cr[6].eq {
	pc = 0x823B2550; continue 'dispatch;
	}
	// 823B24F0: 2B18000B  cmplwi cr6, r24, 0xb
	ctx.cr[6].compare_u32(ctx.r[24].u32, 11 as u32, &mut ctx.xer);
	// 823B24F4: 41980054  blt cr6, 0x823b2548
	if ctx.cr[6].lt {
	pc = 0x823B2548; continue 'dispatch;
	}
	// 823B24F8: 2B18000C  cmplwi cr6, r24, 0xc
	ctx.cr[6].compare_u32(ctx.r[24].u32, 12 as u32, &mut ctx.xer);
	// 823B24FC: 40990054  ble cr6, 0x823b2550
	if !ctx.cr[6].gt {
	pc = 0x823B2550; continue 'dispatch;
	}
	// 823B2500: 2B180011  cmplwi cr6, r24, 0x11
	ctx.cr[6].compare_u32(ctx.r[24].u32, 17 as u32, &mut ctx.xer);
	// 823B2504: 40990044  ble cr6, 0x823b2548
	if !ctx.cr[6].gt {
	pc = 0x823B2548; continue 'dispatch;
	}
	// 823B2508: 2B180014  cmplwi cr6, r24, 0x14
	ctx.cr[6].compare_u32(ctx.r[24].u32, 20 as u32, &mut ctx.xer);
	// 823B250C: 40990044  ble cr6, 0x823b2550
	if !ctx.cr[6].gt {
	pc = 0x823B2550; continue 'dispatch;
	}
	// 823B2510: 2B180026  cmplwi cr6, r24, 0x26
	ctx.cr[6].compare_u32(ctx.r[24].u32, 38 as u32, &mut ctx.xer);
	// 823B2514: 40990034  ble cr6, 0x823b2548
	if !ctx.cr[6].gt {
	pc = 0x823B2548; continue 'dispatch;
	}
	// 823B2518: 2B180028  cmplwi cr6, r24, 0x28
	ctx.cr[6].compare_u32(ctx.r[24].u32, 40 as u32, &mut ctx.xer);
	// 823B251C: 48000028  b 0x823b2544
	pc = 0x823B2544; continue 'dispatch;
            }
            0x823B2520 => {
    //   block [0x823B2520..0x823B2544)
	// 823B2520: 2B180031  cmplwi cr6, r24, 0x31
	ctx.cr[6].compare_u32(ctx.r[24].u32, 49 as u32, &mut ctx.xer);
	// 823B2524: 419A002C  beq cr6, 0x823b2550
	if ctx.cr[6].eq {
	pc = 0x823B2550; continue 'dispatch;
	}
	// 823B2528: 2B180032  cmplwi cr6, r24, 0x32
	ctx.cr[6].compare_u32(ctx.r[24].u32, 50 as u32, &mut ctx.xer);
	// 823B252C: 4099001C  ble cr6, 0x823b2548
	if !ctx.cr[6].gt {
	pc = 0x823B2548; continue 'dispatch;
	}
	// 823B2530: 2B180035  cmplwi cr6, r24, 0x35
	ctx.cr[6].compare_u32(ctx.r[24].u32, 53 as u32, &mut ctx.xer);
	// 823B2534: 4099001C  ble cr6, 0x823b2550
	if !ctx.cr[6].gt {
	pc = 0x823B2550; continue 'dispatch;
	}
	// 823B2538: 2B180039  cmplwi cr6, r24, 0x39
	ctx.cr[6].compare_u32(ctx.r[24].u32, 57 as u32, &mut ctx.xer);
	// 823B253C: 4099000C  ble cr6, 0x823b2548
	if !ctx.cr[6].gt {
	pc = 0x823B2548; continue 'dispatch;
	}
	// 823B2540: 2B18003D  cmplwi cr6, r24, 0x3d
	ctx.cr[6].compare_u32(ctx.r[24].u32, 61 as u32, &mut ctx.xer);
	pc = 0x823B2544; continue 'dispatch;
            }
            0x823B2544 => {
    //   block [0x823B2544..0x823B2548)
	// 823B2544: 4099000C  ble cr6, 0x823b2550
	if !ctx.cr[6].gt {
	pc = 0x823B2550; continue 'dispatch;
	}
	pc = 0x823B2548; continue 'dispatch;
            }
            0x823B2548 => {
    //   block [0x823B2548..0x823B2550)
	// 823B2548: 7EF6BB78  mr r22, r23
	ctx.r[22].u64 = ctx.r[23].u64;
	// 823B254C: 48000008  b 0x823b2554
	pc = 0x823B2554; continue 'dispatch;
            }
            0x823B2550 => {
    //   block [0x823B2550..0x823B2554)
	// 823B2550: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	pc = 0x823B2554; continue 'dispatch;
            }
            0x823B2554 => {
    //   block [0x823B2554..0x823B2588)
	// 823B2554: 3D608283  lis r11, -0x7d7d
	ctx.r[11].s64 = -2105344000;
	// 823B2558: 895B0013  lbz r10, 0x13(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(19 as u32) ) } as u64;
	// 823B255C: 839E000C  lwz r28, 0xc(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B2560: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 823B2564: 396B4E80  addi r11, r11, 0x4e80
	ctx.r[11].s64 = ctx.r[11].s64 + 20096;
	// 823B2568: 835E0010  lwz r26, 0x10(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B256C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 823B2570: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823B2574: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 823B2578: 7F2A582E  lwzx r25, r10, r11
	ctx.r[25].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823B257C: 419A000C  beq cr6, 0x823b2588
	if ctx.cr[6].eq {
	pc = 0x823B2588; continue 'dispatch;
	}
	// 823B2580: 397C0003  addi r11, r28, 3
	ctx.r[11].s64 = ctx.r[28].s64 + 3;
	// 823B2584: 557D003A  rlwinm r29, r11, 0, 0, 0x1d
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x823B2588; continue 'dispatch;
            }
            0x823B2588 => {
    //   block [0x823B2588..0x823B25A4)
	// 823B2588: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 823B258C: 2B130001  cmplwi cr6, r19, 1
	ctx.cr[6].compare_u32(ctx.r[19].u32, 1 as u32, &mut ctx.xer);
	// 823B2590: 419A0014  beq cr6, 0x823b25a4
	if ctx.cr[6].eq {
	pc = 0x823B25A4; continue 'dispatch;
	}
	// 823B2594: 2B130002  cmplwi cr6, r19, 2
	ctx.cr[6].compare_u32(ctx.r[19].u32, 2 as u32, &mut ctx.xer);
	// 823B2598: 409A0010  bne cr6, 0x823b25a8
	if !ctx.cr[6].eq {
	pc = 0x823B25A8; continue 'dispatch;
	}
	// 823B259C: 817B0020  lwz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B25A0: 48000008  b 0x823b25a8
	pc = 0x823B25A8; continue 'dispatch;
            }
            0x823B25A4 => {
    //   block [0x823B25A4..0x823B25A8)
	// 823B25A4: A17B000C  lhz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x823B25A8; continue 'dispatch;
            }
            0x823B25A8 => {
    //   block [0x823B25A8..0x823B25E4)
	// 823B25A8: 7D5DC9D6  mullw r10, r29, r25
	ctx.r[10].s32 = ((ctx.r[29].s32 as i64 * ctx.r[25].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823B25AC: 811E0050  lwz r8, 0x50(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B25B0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B25B4: 92E1005C  stw r23, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[23].u32 ) };
	// 823B25B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 823B25BC: 7D4BDA14  add r10, r11, r27
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 823B25C0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B25C4: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 823B25C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B25CC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 823B25D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823B25D4: 4819D1C5  bl 0x8254f798
	ctx.lr = 0x823B25D8;
	sub_8254F798(ctx, base);
	// 823B25D8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 823B25DC: 2F150001  cmpwi cr6, r21, 1
	ctx.cr[6].compare_i32(ctx.r[21].s32, 1, &mut ctx.xer);
	// 823B25E0: 409900C4  ble cr6, 0x823b26a4
	if !ctx.cr[6].gt {
	pc = 0x823B26A4; continue 'dispatch;
	}
	pc = 0x823B25E4; continue 'dispatch;
            }
            0x823B25E4 => {
    //   block [0x823B25E4..0x823B261C)
	// 823B25E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823B25E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B25EC: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 823B25F0: 4819D661  bl 0x8254fc50
	ctx.lr = 0x823B25F4;
	sub_8254FC50(ctx, base);
	// 823B25F4: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 823B25F8: 815E0050  lwz r10, 0x50(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B25FC: 57BDF87E  srwi r29, r29, 1
	ctx.r[29].u32 = ctx.r[29].u32.wrapping_shr(1);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 823B2600: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 823B2604: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 823B2608: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823B260C: 419A0010  beq cr6, 0x823b261c
	if ctx.cr[6].eq {
	pc = 0x823B261C; continue 'dispatch;
	}
	// 823B2610: 397D0003  addi r11, r29, 3
	ctx.r[11].s64 = ctx.r[29].s64 + 3;
	// 823B2614: 557D003A  rlwinm r29, r11, 0, 0, 0x1d
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823B2618: 48000010  b 0x823b2628
	pc = 0x823B2628; continue 'dispatch;
            }
            0x823B261C => {
    //   block [0x823B261C..0x823B2628)
	// 823B261C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823B2620: 409A0008  bne cr6, 0x823b2628
	if !ctx.cr[6].eq {
	pc = 0x823B2628; continue 'dispatch;
	}
	// 823B2624: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	pc = 0x823B2628; continue 'dispatch;
            }
            0x823B2628 => {
    //   block [0x823B2628..0x823B2644)
	// 823B2628: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 823B262C: 2B130001  cmplwi cr6, r19, 1
	ctx.cr[6].compare_u32(ctx.r[19].u32, 1 as u32, &mut ctx.xer);
	// 823B2630: 419A0014  beq cr6, 0x823b2644
	if ctx.cr[6].eq {
	pc = 0x823B2644; continue 'dispatch;
	}
	// 823B2634: 2B130002  cmplwi cr6, r19, 2
	ctx.cr[6].compare_u32(ctx.r[19].u32, 2 as u32, &mut ctx.xer);
	// 823B2638: 409A0010  bne cr6, 0x823b2648
	if !ctx.cr[6].eq {
	pc = 0x823B2648; continue 'dispatch;
	}
	// 823B263C: 817B0020  lwz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B2640: 48000008  b 0x823b2648
	pc = 0x823B2648; continue 'dispatch;
            }
            0x823B2644 => {
    //   block [0x823B2644..0x823B2648)
	// 823B2644: A17B000C  lhz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x823B2648; continue 'dispatch;
            }
            0x823B2648 => {
    //   block [0x823B2648..0x823B265C)
	// 823B2648: 7D4BDA14  add r10, r11, r27
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 823B264C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823B2650: 419A0020  beq cr6, 0x823b2670
	if ctx.cr[6].eq {
	pc = 0x823B2670; continue 'dispatch;
	}
	// 823B2654: 393B0030  addi r9, r27, 0x30
	ctx.r[9].s64 = ctx.r[27].s64 + 48;
	// 823B2658: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x823B265C; continue 'dispatch;
            }
            0x823B265C => {
    //   block [0x823B265C..0x823B2670)
	// 823B265C: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B2660: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B2664: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823B2668: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 823B266C: 4082FFF0  bne 0x823b265c
	if !ctx.cr[0].eq {
	pc = 0x823B265C; continue 'dispatch;
	}
	pc = 0x823B2670; continue 'dispatch;
            }
            0x823B2670 => {
    //   block [0x823B2670..0x823B26A4)
	// 823B2670: 7D7DC9D6  mullw r11, r29, r25
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * ctx.r[25].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823B2674: 92E1005C  stw r23, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[23].u32 ) };
	// 823B2678: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B267C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823B2680: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B2684: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 823B2688: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823B268C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 823B2690: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823B2694: 4819D105  bl 0x8254f798
	ctx.lr = 0x823B2698;
	sub_8254F798(ctx, base);
	// 823B2698: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 823B269C: 7F1FA800  cmpw cr6, r31, r21
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[21].s32, &mut ctx.xer);
	// 823B26A0: 4198FF44  blt cr6, 0x823b25e4
	if ctx.cr[6].lt {
	pc = 0x823B25E4; continue 'dispatch;
	}
	pc = 0x823B26A4; continue 'dispatch;
            }
            0x823B26A4 => {
    //   block [0x823B26A4..0x823B26AC)
	// 823B26A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B26A8: 92BE0054  stw r21, 0x54(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), ctx.r[21].u32 ) };
	pc = 0x823B26AC; continue 'dispatch;
            }
            0x823B26AC => {
    //   block [0x823B26AC..0x823B26B4)
	// 823B26AC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 823B26B0: 48182A34  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B26B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B26B8 size=184
    let mut pc: u32 = 0x823B26B8;
    'dispatch: loop {
        match pc {
            0x823B26B8 => {
    //   block [0x823B26B8..0x823B2770)
	// 823B26B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B26BC: 481829ED  bl 0x825350a8
	ctx.lr = 0x823B26C0;
	sub_82535080(ctx, base);
	// 823B26C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B26C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823B26C8: 83E50004  lwz r31, 4(r5)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B26CC: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 823B26D0: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 823B26D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823B26D8: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 823B26DC: 794AFFE6  rldicr r10, r10, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 823B26E0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823B26E4: 38A3001C  addi r5, r3, 0x1c
	ctx.r[5].s64 = ctx.r[3].s64 + 28;
	// 823B26E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B26EC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 823B26F0: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 823B26F4: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 823B26F8: 7D5D5C36  srd r29, r10, r11
	if (ctx.r[11].u8 & 0x40) != 0 {
		ctx.r[29].u64 = 0;
	} else {
		ctx.r[29].u64 = (ctx.r[10].u64) >> ((ctx.r[11].u8 & 0x3F) as u32);
	}
	// 823B26FC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823B2700: 48027349  bl 0x823d9a48
	ctx.lr = 0x823B2704;
	sub_823D9A48(ctx, base);
	// 823B2704: 1D7E0018  mulli r11, r30, 0x18
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823B2708: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823B270C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 823B2710: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B2714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B2718: 814B048C  lwz r10, 0x48c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1164 as u32) ) } as u64;
	// 823B271C: 534AB9D0  rlwimi r10, r26, 0x17, 7, 8
	ctx.r[10].u64 = (((ctx.r[26].u32).rotate_left(23) as u64) & 0x0000000001800000) | (ctx.r[10].u64 & 0xFFFFFFFFFE7FFFFF);
	// 823B2720: 914B048C  stw r10, 0x48c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1164 as u32), ctx.r[10].u32 ) };
	// 823B2724: E97F0018  ld r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 823B2728: 7D6BEB78  or r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[29].u64;
	// 823B272C: F97F0018  std r11, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 823B2730: 4802B701  bl 0x823dde30
	ctx.lr = 0x823B2734;
	sub_823DDE30(ctx, base);
	// 823B2734: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823B2738: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B273C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B2740: 4802B881  bl 0x823ddfc0
	ctx.lr = 0x823B2744;
	sub_823DDFC0(ctx, base);
	// 823B2744: 38B90001  addi r5, r25, 1
	ctx.r[5].s64 = ctx.r[25].s64 + 1;
	// 823B2748: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B274C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B2750: 4802BAF1  bl 0x823de240
	ctx.lr = 0x823B2754;
	sub_823DE240(ctx, base);
	// 823B2754: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 823B2758: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B275C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B2760: 4802BC01  bl 0x823de360
	ctx.lr = 0x823B2764;
	sub_823DE360(ctx, base);
	// 823B2764: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B2768: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823B276C: 4818298C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2770 size=168
    let mut pc: u32 = 0x823B2770;
    'dispatch: loop {
        match pc {
            0x823B2770 => {
    //   block [0x823B2770..0x823B27DC)
	// 823B2770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B2774: 48182949  bl 0x825350bc
	ctx.lr = 0x823B2778;
	sub_82535080(ctx, base);
	// 823B2778: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B277C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B2780: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B2784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B2788: 409A0084  bne cr6, 0x823b280c
	if !ctx.cr[6].eq {
	pc = 0x823B280C; continue 'dispatch;
	}
	// 823B278C: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 823B2790: 80FF0014  lwz r7, 0x14(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B2794: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 823B2798: 80BF0054  lwz r5, 0x54(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 823B279C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B27A0: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B27A4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823B27A8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B27AC: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 823B27B0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 823B27B4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 823B27B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823B27BC: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 823B27C0: 4819C309  bl 0x8254eac8
	ctx.lr = 0x823B27C4;
	sub_8254EAC8(ctx, base);
	// 823B27C4: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B27C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823B27CC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 823B27D0: 419A000C  beq cr6, 0x823b27dc
	if ctx.cr[6].eq {
	pc = 0x823B27DC; continue 'dispatch;
	}
	// 823B27D4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 823B27D8: 4BFEE231  bl 0x823a0a08
	ctx.lr = 0x823B27DC;
	sub_823A0A08(ctx, base);
	pc = 0x823B27DC; continue 'dispatch;
            }
            0x823B27DC => {
    //   block [0x823B27DC..0x823B2804)
	// 823B27DC: 38801000  li r4, 0x1000
	ctx.r[4].s64 = 4096;
	// 823B27E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B27E4: 4BFEE1CD  bl 0x823a09b0
	ctx.lr = 0x823B27E8;
	sub_823A09B0(ctx, base);
	// 823B27E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 823B27EC: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 823B27F0: 909F0050  stw r4, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 823B27F4: 409A0010  bne cr6, 0x823b2804
	if !ctx.cr[6].eq {
	pc = 0x823B2804; continue 'dispatch;
	}
	// 823B27F8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 823B27FC: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 823B2800: 48000010  b 0x823b2810
	pc = 0x823B2810; continue 'dispatch;
            }
            0x823B2804 => {
    //   block [0x823B2804..0x823B280C)
	// 823B2804: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B2808: 4819C411  bl 0x8254ec18
	ctx.lr = 0x823B280C;
	sub_8254EC18(ctx, base);
	pc = 0x823B280C; continue 'dispatch;
            }
            0x823B280C => {
    //   block [0x823B280C..0x823B2810)
	// 823B280C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823B2810; continue 'dispatch;
            }
            0x823B2810 => {
    //   block [0x823B2810..0x823B2818)
	// 823B2810: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823B2814: 481828F8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2818 size=148
    let mut pc: u32 = 0x823B2818;
    'dispatch: loop {
        match pc {
            0x823B2818 => {
    //   block [0x823B2818..0x823B288C)
	// 823B2818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B281C: 48182899  bl 0x825350b4
	ctx.lr = 0x823B2820;
	sub_82535080(ctx, base);
	// 823B2820: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B2824: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B2828: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823B282C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823B2830: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 823B2834: 3B9F001C  addi r28, r31, 0x1c
	ctx.r[28].s64 = ctx.r[31].s64 + 28;
	// 823B2838: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 823B283C: 80FF0014  lwz r7, 0x14(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B2840: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B2844: 88BE0011  lbz r5, 0x11(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(17 as u32) ) } as u64;
	// 823B2848: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823B284C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B2850: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 823B2854: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 823B2858: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823B285C: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B2860: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 823B2864: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 823B2868: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 823B286C: 4819C25D  bl 0x8254eac8
	ctx.lr = 0x823B2870;
	sub_8254EAC8(ctx, base);
	// 823B2870: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 823B2874: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 823B2878: 419A0014  beq cr6, 0x823b288c
	if ctx.cr[6].eq {
	pc = 0x823B288C; continue 'dispatch;
	}
	// 823B287C: 2B1D0002  cmplwi cr6, r29, 2
	ctx.cr[6].compare_u32(ctx.r[29].u32, 2 as u32, &mut ctx.xer);
	// 823B2880: 409A0010  bne cr6, 0x823b2890
	if !ctx.cr[6].eq {
	pc = 0x823B2890; continue 'dispatch;
	}
	// 823B2884: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B2888: 48000008  b 0x823b2890
	pc = 0x823B2890; continue 'dispatch;
            }
            0x823B288C => {
    //   block [0x823B288C..0x823B2890)
	// 823B288C: A17E000C  lhz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x823B2890; continue 'dispatch;
            }
            0x823B2890 => {
    //   block [0x823B2890..0x823B28AC)
	// 823B2890: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823B2894: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823B2898: 909F0050  stw r4, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 823B289C: 4819C37D  bl 0x8254ec18
	ctx.lr = 0x823B28A0;
	sub_8254EC18(ctx, base);
	// 823B28A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B28A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823B28A8: 4818285C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B28B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B28B0 size=392
    let mut pc: u32 = 0x823B28B0;
    'dispatch: loop {
        match pc {
            0x823B28B0 => {
    //   block [0x823B28B0..0x823B28F0)
	// 823B28B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B28B4: 481827F5  bl 0x825350a8
	ctx.lr = 0x823B28B8;
	sub_82535080(ctx, base);
	// 823B28B8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B28BC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823B28C0: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 823B28C4: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 823B28C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B28CC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B28D0: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 823B28D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B28D8: 4E800421  bctrl
	ctx.lr = 0x823B28DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823B28DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823B28E0: 40800010  bge 0x823b28f0
	if !ctx.cr[0].lt {
	pc = 0x823B28F0; continue 'dispatch;
	}
	// 823B28E4: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 823B28E8: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 823B28EC: 48000144  b 0x823b2a30
	pc = 0x823B2A30; continue 'dispatch;
            }
            0x823B28F0 => {
    //   block [0x823B28F0..0x823B2938)
	// 823B28F0: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B28F4: 835C000C  lwz r26, 0xc(r28)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B28F8: 557B06BE  clrlwi r27, r11, 0x1a
	ctx.r[27].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 823B28FC: 2B1B002C  cmplwi cr6, r27, 0x2c
	ctx.cr[6].compare_u32(ctx.r[27].u32, 44 as u32, &mut ctx.xer);
	// 823B2900: 41990038  bgt cr6, 0x823b2938
	if ctx.cr[6].gt {
	pc = 0x823B2938; continue 'dispatch;
	}
	// 823B2904: 419A0064  beq cr6, 0x823b2968
	if ctx.cr[6].eq {
	pc = 0x823B2968; continue 'dispatch;
	}
	// 823B2908: 2B1B000B  cmplwi cr6, r27, 0xb
	ctx.cr[6].compare_u32(ctx.r[27].u32, 11 as u32, &mut ctx.xer);
	// 823B290C: 41980054  blt cr6, 0x823b2960
	if ctx.cr[6].lt {
	pc = 0x823B2960; continue 'dispatch;
	}
	// 823B2910: 2B1B000C  cmplwi cr6, r27, 0xc
	ctx.cr[6].compare_u32(ctx.r[27].u32, 12 as u32, &mut ctx.xer);
	// 823B2914: 40990054  ble cr6, 0x823b2968
	if !ctx.cr[6].gt {
	pc = 0x823B2968; continue 'dispatch;
	}
	// 823B2918: 2B1B0011  cmplwi cr6, r27, 0x11
	ctx.cr[6].compare_u32(ctx.r[27].u32, 17 as u32, &mut ctx.xer);
	// 823B291C: 40990044  ble cr6, 0x823b2960
	if !ctx.cr[6].gt {
	pc = 0x823B2960; continue 'dispatch;
	}
	// 823B2920: 2B1B0014  cmplwi cr6, r27, 0x14
	ctx.cr[6].compare_u32(ctx.r[27].u32, 20 as u32, &mut ctx.xer);
	// 823B2924: 40990044  ble cr6, 0x823b2968
	if !ctx.cr[6].gt {
	pc = 0x823B2968; continue 'dispatch;
	}
	// 823B2928: 2B1B0026  cmplwi cr6, r27, 0x26
	ctx.cr[6].compare_u32(ctx.r[27].u32, 38 as u32, &mut ctx.xer);
	// 823B292C: 40990034  ble cr6, 0x823b2960
	if !ctx.cr[6].gt {
	pc = 0x823B2960; continue 'dispatch;
	}
	// 823B2930: 2B1B0028  cmplwi cr6, r27, 0x28
	ctx.cr[6].compare_u32(ctx.r[27].u32, 40 as u32, &mut ctx.xer);
	// 823B2934: 48000028  b 0x823b295c
	pc = 0x823B295C; continue 'dispatch;
            }
            0x823B2938 => {
    //   block [0x823B2938..0x823B295C)
	// 823B2938: 2B1B0031  cmplwi cr6, r27, 0x31
	ctx.cr[6].compare_u32(ctx.r[27].u32, 49 as u32, &mut ctx.xer);
	// 823B293C: 419A002C  beq cr6, 0x823b2968
	if ctx.cr[6].eq {
	pc = 0x823B2968; continue 'dispatch;
	}
	// 823B2940: 2B1B0032  cmplwi cr6, r27, 0x32
	ctx.cr[6].compare_u32(ctx.r[27].u32, 50 as u32, &mut ctx.xer);
	// 823B2944: 4099001C  ble cr6, 0x823b2960
	if !ctx.cr[6].gt {
	pc = 0x823B2960; continue 'dispatch;
	}
	// 823B2948: 2B1B0035  cmplwi cr6, r27, 0x35
	ctx.cr[6].compare_u32(ctx.r[27].u32, 53 as u32, &mut ctx.xer);
	// 823B294C: 4099001C  ble cr6, 0x823b2968
	if !ctx.cr[6].gt {
	pc = 0x823B2968; continue 'dispatch;
	}
	// 823B2950: 2B1B0039  cmplwi cr6, r27, 0x39
	ctx.cr[6].compare_u32(ctx.r[27].u32, 57 as u32, &mut ctx.xer);
	// 823B2954: 4099000C  ble cr6, 0x823b2960
	if !ctx.cr[6].gt {
	pc = 0x823B2960; continue 'dispatch;
	}
	// 823B2958: 2B1B003D  cmplwi cr6, r27, 0x3d
	ctx.cr[6].compare_u32(ctx.r[27].u32, 61 as u32, &mut ctx.xer);
	pc = 0x823B295C; continue 'dispatch;
            }
            0x823B295C => {
    //   block [0x823B295C..0x823B2960)
	// 823B295C: 4099000C  ble cr6, 0x823b2968
	if !ctx.cr[6].gt {
	pc = 0x823B2968; continue 'dispatch;
	}
	pc = 0x823B2960; continue 'dispatch;
            }
            0x823B2960 => {
    //   block [0x823B2960..0x823B2968)
	// 823B2960: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B2964: 48000008  b 0x823b296c
	pc = 0x823B296C; continue 'dispatch;
            }
            0x823B2968 => {
    //   block [0x823B2968..0x823B296C)
	// 823B2968: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x823B296C; continue 'dispatch;
            }
            0x823B296C => {
    //   block [0x823B296C..0x823B2998)
	// 823B296C: 3D608283  lis r11, -0x7d7d
	ctx.r[11].s64 = -2105344000;
	// 823B2970: 89190013  lbz r8, 0x13(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(19 as u32) ) } as u64;
	// 823B2974: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823B2978: 394B4E80  addi r10, r11, 0x4e80
	ctx.r[10].s64 = ctx.r[11].s64 + 20096;
	// 823B297C: 5508183E  rotlwi r8, r8, 3
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(3)) as u64;
	// 823B2980: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823B2984: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 823B2988: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823B298C: 419A000C  beq cr6, 0x823b2998
	if ctx.cr[6].eq {
	pc = 0x823B2998; continue 'dispatch;
	}
	// 823B2990: 397A0003  addi r11, r26, 3
	ctx.r[11].s64 = ctx.r[26].s64 + 3;
	// 823B2994: 556B003A  rlwinm r11, r11, 0, 0, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x823B2998; continue 'dispatch;
            }
            0x823B2998 => {
    //   block [0x823B2998..0x823B29A4)
	// 823B2998: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823B299C: 3BDC001C  addi r30, r28, 0x1c
	ctx.r[30].s64 = ctx.r[28].s64 + 28;
	// 823B29A0: 7FAB51D6  mullw r29, r11, r10
	ctx.r[29].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[29].s64 = ctx.r[29].s32 as i64;
	pc = 0x823B29A4; continue 'dispatch;
            }
            0x823B29A4 => {
    //   block [0x823B29A4..0x823B29D8)
	// 823B29A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B29A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823B29AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B29B0: 4819D2A1  bl 0x8254fc50
	ctx.lr = 0x823B29B4;
	sub_8254FC50(ctx, base);
	// 823B29B4: 817C0050  lwz r11, 0x50(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B29B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B29BC: 2B180001  cmplwi cr6, r24, 1
	ctx.cr[6].compare_u32(ctx.r[24].u32, 1 as u32, &mut ctx.xer);
	// 823B29C0: 7D0B1A14  add r8, r11, r3
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 823B29C4: 419A0014  beq cr6, 0x823b29d8
	if ctx.cr[6].eq {
	pc = 0x823B29D8; continue 'dispatch;
	}
	// 823B29C8: 2B180002  cmplwi cr6, r24, 2
	ctx.cr[6].compare_u32(ctx.r[24].u32, 2 as u32, &mut ctx.xer);
	// 823B29CC: 409A0010  bne cr6, 0x823b29dc
	if !ctx.cr[6].eq {
	pc = 0x823B29DC; continue 'dispatch;
	}
	// 823B29D0: 81590020  lwz r10, 0x20(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B29D4: 48000008  b 0x823b29dc
	pc = 0x823B29DC; continue 'dispatch;
            }
            0x823B29D8 => {
    //   block [0x823B29D8..0x823B29DC)
	// 823B29D8: A159000C  lhz r10, 0xc(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x823B29DC; continue 'dispatch;
            }
            0x823B29DC => {
    //   block [0x823B29DC..0x823B29F8)
	// 823B29DC: 8179001C  lwz r11, 0x1c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B29E0: 7D4ACA14  add r10, r10, r25
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[25].u64;
	// 823B29E4: 556B05AD  rlwinm. r11, r11, 0, 0x16, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B29E8: 41820010  beq 0x823b29f8
	if ctx.cr[0].eq {
	pc = 0x823B29F8; continue 'dispatch;
	}
	// 823B29EC: 81790030  lwz r11, 0x30(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 823B29F0: 7D6BF9D6  mullw r11, r11, r31
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823B29F4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x823B29F8; continue 'dispatch;
            }
            0x823B29F8 => {
    //   block [0x823B29F8..0x823B2A30)
	// 823B29F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823B29FC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 823B2A00: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B2A04: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B2A08: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 823B2A0C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B2A10: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 823B2A14: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823B2A18: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823B2A1C: 4819CD7D  bl 0x8254f798
	ctx.lr = 0x823B2A20;
	sub_8254F798(ctx, base);
	// 823B2A20: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 823B2A24: 2F1F0006  cmpwi cr6, r31, 6
	ctx.cr[6].compare_i32(ctx.r[31].s32, 6, &mut ctx.xer);
	// 823B2A28: 4198FF7C  blt cr6, 0x823b29a4
	if ctx.cr[6].lt {
	pc = 0x823B29A4; continue 'dispatch;
	}
	// 823B2A2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823B2A30; continue 'dispatch;
            }
            0x823B2A30 => {
    //   block [0x823B2A30..0x823B2A38)
	// 823B2A30: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823B2A34: 481826C4  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2A38 size=68
    let mut pc: u32 = 0x823B2A38;
    'dispatch: loop {
        match pc {
            0x823B2A38 => {
    //   block [0x823B2A38..0x823B2A7C)
	// 823B2A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B2A3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B2A40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B2A44: 39440020  addi r10, r4, 0x20
	ctx.r[10].s64 = ctx.r[4].s64 + 32;
	// 823B2A48: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823B2A4C: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 823B2A50: 7929FFE6  rldicr r9, r9, 0x3f, 0x3f
	ctx.r[9].u64 = (ctx.r[9].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 823B2A54: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823B2A58: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B2A5C: 38AB001C  addi r5, r11, 0x1c
	ctx.r[5].s64 = ctx.r[11].s64 + 28;
	// 823B2A60: 7D265436  srd r6, r9, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[9].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 823B2A64: 48026FE5  bl 0x823d9a48
	ctx.lr = 0x823B2A68;
	sub_823D9A48(ctx, base);
	// 823B2A68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B2A6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823B2A70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B2A74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B2A78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2A80 size=160
    let mut pc: u32 = 0x823B2A80;
    'dispatch: loop {
        match pc {
            0x823B2A80 => {
    //   block [0x823B2A80..0x823B2AE4)
	// 823B2A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B2A84: 48182639  bl 0x825350bc
	ctx.lr = 0x823B2A88;
	sub_82535080(ctx, base);
	// 823B2A88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B2A8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B2A90: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B2A94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B2A98: 409A007C  bne cr6, 0x823b2b14
	if !ctx.cr[6].eq {
	pc = 0x823B2B14; continue 'dispatch;
	}
	// 823B2A9C: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 823B2AA0: 80DF0014  lwz r6, 0x14(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B2AA4: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 823B2AA8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B2AAC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823B2AB0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823B2AB4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B2AB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823B2ABC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B2AC0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B2AC4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 823B2AC8: 4819C071  bl 0x8254eb38
	ctx.lr = 0x823B2ACC;
	sub_8254EB38(ctx, base);
	// 823B2ACC: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B2AD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823B2AD4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 823B2AD8: 419A000C  beq cr6, 0x823b2ae4
	if ctx.cr[6].eq {
	pc = 0x823B2AE4; continue 'dispatch;
	}
	// 823B2ADC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 823B2AE0: 4BFEDF29  bl 0x823a0a08
	ctx.lr = 0x823B2AE4;
	sub_823A0A08(ctx, base);
	pc = 0x823B2AE4; continue 'dispatch;
            }
            0x823B2AE4 => {
    //   block [0x823B2AE4..0x823B2B0C)
	// 823B2AE4: 38801000  li r4, 0x1000
	ctx.r[4].s64 = 4096;
	// 823B2AE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B2AEC: 4BFEDEC5  bl 0x823a09b0
	ctx.lr = 0x823B2AF0;
	sub_823A09B0(ctx, base);
	// 823B2AF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 823B2AF4: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 823B2AF8: 909F0050  stw r4, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 823B2AFC: 409A0010  bne cr6, 0x823b2b0c
	if !ctx.cr[6].eq {
	pc = 0x823B2B0C; continue 'dispatch;
	}
	// 823B2B00: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 823B2B04: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 823B2B08: 48000010  b 0x823b2b18
	pc = 0x823B2B18; continue 'dispatch;
            }
            0x823B2B0C => {
    //   block [0x823B2B0C..0x823B2B14)
	// 823B2B0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B2B10: 4819C109  bl 0x8254ec18
	ctx.lr = 0x823B2B14;
	sub_8254EC18(ctx, base);
	pc = 0x823B2B14; continue 'dispatch;
            }
            0x823B2B14 => {
    //   block [0x823B2B14..0x823B2B18)
	// 823B2B14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823B2B18; continue 'dispatch;
            }
            0x823B2B18 => {
    //   block [0x823B2B18..0x823B2B20)
	// 823B2B18: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823B2B1C: 481825F0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2B20 size=136
    let mut pc: u32 = 0x823B2B20;
    'dispatch: loop {
        match pc {
            0x823B2B20 => {
    //   block [0x823B2B20..0x823B2B88)
	// 823B2B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B2B24: 48182591  bl 0x825350b4
	ctx.lr = 0x823B2B28;
	sub_82535080(ctx, base);
	// 823B2B28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B2B2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B2B30: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823B2B34: 3B9F001C  addi r28, r31, 0x1c
	ctx.r[28].s64 = ctx.r[31].s64 + 28;
	// 823B2B38: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823B2B3C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823B2B40: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 823B2B44: 80DF0014  lwz r6, 0x14(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B2B48: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823B2B4C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B2B50: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B2B54: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 823B2B58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B2B5C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 823B2B60: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B2B64: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 823B2B68: 4819BFD1  bl 0x8254eb38
	ctx.lr = 0x823B2B6C;
	sub_8254EB38(ctx, base);
	// 823B2B6C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 823B2B70: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 823B2B74: 419A0014  beq cr6, 0x823b2b88
	if ctx.cr[6].eq {
	pc = 0x823B2B88; continue 'dispatch;
	}
	// 823B2B78: 2B1D0002  cmplwi cr6, r29, 2
	ctx.cr[6].compare_u32(ctx.r[29].u32, 2 as u32, &mut ctx.xer);
	// 823B2B7C: 409A0010  bne cr6, 0x823b2b8c
	if !ctx.cr[6].eq {
	pc = 0x823B2B8C; continue 'dispatch;
	}
	// 823B2B80: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B2B84: 48000008  b 0x823b2b8c
	pc = 0x823B2B8C; continue 'dispatch;
            }
            0x823B2B88 => {
    //   block [0x823B2B88..0x823B2B8C)
	// 823B2B88: A17E000C  lhz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x823B2B8C; continue 'dispatch;
            }
            0x823B2B8C => {
    //   block [0x823B2B8C..0x823B2BA8)
	// 823B2B8C: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823B2B90: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823B2B94: 909F0050  stw r4, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 823B2B98: 4819C081  bl 0x8254ec18
	ctx.lr = 0x823B2B9C;
	sub_8254EC18(ctx, base);
	// 823B2B9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B2BA0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823B2BA4: 48182560  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2BA8 size=448
    let mut pc: u32 = 0x823B2BA8;
    'dispatch: loop {
        match pc {
            0x823B2BA8 => {
    //   block [0x823B2BA8..0x823B2C1C)
	// 823B2BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B2BAC: 48182501  bl 0x825350ac
	ctx.lr = 0x823B2BB0;
	sub_82535080(ctx, base);
	// 823B2BB0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B2BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B2BB8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823B2BBC: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 823B2BC0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823B2BC4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 823B2BC8: 837F0014  lwz r27, 0x14(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B2BCC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B2BD0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823B2BD4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B2BD8: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 823B2BDC: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 823B2BE0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 823B2BE4: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 823B2BE8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823B2BEC: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 823B2BF0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 823B2BF4: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B2BF8: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 823B2BFC: 4819BECD  bl 0x8254eac8
	ctx.lr = 0x823B2C00;
	sub_8254EAC8(ctx, base);
	// 823B2C00: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B2C04: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 823B2C08: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 823B2C0C: 409A0010  bne cr6, 0x823b2c1c
	if !ctx.cr[6].eq {
	pc = 0x823B2C1C; continue 'dispatch;
	}
	// 823B2C10: 38801000  li r4, 0x1000
	ctx.r[4].s64 = 4096;
	// 823B2C14: 4BFEDD9D  bl 0x823a09b0
	ctx.lr = 0x823B2C18;
	sub_823A09B0(ctx, base);
	// 823B2C18: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	pc = 0x823B2C1C; continue 'dispatch;
            }
            0x823B2C1C => {
    //   block [0x823B2C1C..0x823B2C34)
	// 823B2C1C: 809F0050  lwz r4, 0x50(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B2C20: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 823B2C24: 409A0010  bne cr6, 0x823b2c34
	if !ctx.cr[6].eq {
	pc = 0x823B2C34; continue 'dispatch;
	}
	// 823B2C28: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 823B2C2C: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 823B2C30: 48000130  b 0x823b2d60
	pc = 0x823B2D60; continue 'dispatch;
            }
            0x823B2C34 => {
    //   block [0x823B2C34..0x823B2C7C)
	// 823B2C34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B2C38: 4819BFE1  bl 0x8254ec18
	ctx.lr = 0x823B2C3C;
	sub_8254EC18(ctx, base);
	// 823B2C3C: 576606BE  clrlwi r6, r27, 0x1a
	ctx.r[6].u64 = ctx.r[27].u32 as u64 & 0x0000003Fu64;
	// 823B2C40: 2B06002C  cmplwi cr6, r6, 0x2c
	ctx.cr[6].compare_u32(ctx.r[6].u32, 44 as u32, &mut ctx.xer);
	// 823B2C44: 41990038  bgt cr6, 0x823b2c7c
	if ctx.cr[6].gt {
	pc = 0x823B2C7C; continue 'dispatch;
	}
	// 823B2C48: 419A0064  beq cr6, 0x823b2cac
	if ctx.cr[6].eq {
	pc = 0x823B2CAC; continue 'dispatch;
	}
	// 823B2C4C: 2B06000B  cmplwi cr6, r6, 0xb
	ctx.cr[6].compare_u32(ctx.r[6].u32, 11 as u32, &mut ctx.xer);
	// 823B2C50: 41980054  blt cr6, 0x823b2ca4
	if ctx.cr[6].lt {
	pc = 0x823B2CA4; continue 'dispatch;
	}
	// 823B2C54: 2B06000C  cmplwi cr6, r6, 0xc
	ctx.cr[6].compare_u32(ctx.r[6].u32, 12 as u32, &mut ctx.xer);
	// 823B2C58: 40990054  ble cr6, 0x823b2cac
	if !ctx.cr[6].gt {
	pc = 0x823B2CAC; continue 'dispatch;
	}
	// 823B2C5C: 2B060011  cmplwi cr6, r6, 0x11
	ctx.cr[6].compare_u32(ctx.r[6].u32, 17 as u32, &mut ctx.xer);
	// 823B2C60: 40990044  ble cr6, 0x823b2ca4
	if !ctx.cr[6].gt {
	pc = 0x823B2CA4; continue 'dispatch;
	}
	// 823B2C64: 2B060014  cmplwi cr6, r6, 0x14
	ctx.cr[6].compare_u32(ctx.r[6].u32, 20 as u32, &mut ctx.xer);
	// 823B2C68: 40990044  ble cr6, 0x823b2cac
	if !ctx.cr[6].gt {
	pc = 0x823B2CAC; continue 'dispatch;
	}
	// 823B2C6C: 2B060026  cmplwi cr6, r6, 0x26
	ctx.cr[6].compare_u32(ctx.r[6].u32, 38 as u32, &mut ctx.xer);
	// 823B2C70: 40990034  ble cr6, 0x823b2ca4
	if !ctx.cr[6].gt {
	pc = 0x823B2CA4; continue 'dispatch;
	}
	// 823B2C74: 2B060028  cmplwi cr6, r6, 0x28
	ctx.cr[6].compare_u32(ctx.r[6].u32, 40 as u32, &mut ctx.xer);
	// 823B2C78: 48000028  b 0x823b2ca0
	pc = 0x823B2CA0; continue 'dispatch;
            }
            0x823B2C7C => {
    //   block [0x823B2C7C..0x823B2CA0)
	// 823B2C7C: 2B060031  cmplwi cr6, r6, 0x31
	ctx.cr[6].compare_u32(ctx.r[6].u32, 49 as u32, &mut ctx.xer);
	// 823B2C80: 419A002C  beq cr6, 0x823b2cac
	if ctx.cr[6].eq {
	pc = 0x823B2CAC; continue 'dispatch;
	}
	// 823B2C84: 2B060032  cmplwi cr6, r6, 0x32
	ctx.cr[6].compare_u32(ctx.r[6].u32, 50 as u32, &mut ctx.xer);
	// 823B2C88: 4099001C  ble cr6, 0x823b2ca4
	if !ctx.cr[6].gt {
	pc = 0x823B2CA4; continue 'dispatch;
	}
	// 823B2C8C: 2B060035  cmplwi cr6, r6, 0x35
	ctx.cr[6].compare_u32(ctx.r[6].u32, 53 as u32, &mut ctx.xer);
	// 823B2C90: 4099001C  ble cr6, 0x823b2cac
	if !ctx.cr[6].gt {
	pc = 0x823B2CAC; continue 'dispatch;
	}
	// 823B2C94: 2B060039  cmplwi cr6, r6, 0x39
	ctx.cr[6].compare_u32(ctx.r[6].u32, 57 as u32, &mut ctx.xer);
	// 823B2C98: 4099000C  ble cr6, 0x823b2ca4
	if !ctx.cr[6].gt {
	pc = 0x823B2CA4; continue 'dispatch;
	}
	// 823B2C9C: 2B06003D  cmplwi cr6, r6, 0x3d
	ctx.cr[6].compare_u32(ctx.r[6].u32, 61 as u32, &mut ctx.xer);
	pc = 0x823B2CA0; continue 'dispatch;
            }
            0x823B2CA0 => {
    //   block [0x823B2CA0..0x823B2CA4)
	// 823B2CA0: 4099000C  ble cr6, 0x823b2cac
	if !ctx.cr[6].gt {
	pc = 0x823B2CAC; continue 'dispatch;
	}
	pc = 0x823B2CA4; continue 'dispatch;
            }
            0x823B2CA4 => {
    //   block [0x823B2CA4..0x823B2CAC)
	// 823B2CA4: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 823B2CA8: 48000008  b 0x823b2cb0
	pc = 0x823B2CB0; continue 'dispatch;
            }
            0x823B2CAC => {
    //   block [0x823B2CAC..0x823B2CB0)
	// 823B2CAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x823B2CB0; continue 'dispatch;
            }
            0x823B2CB0 => {
    //   block [0x823B2CB0..0x823B2CE0)
	// 823B2CB0: 3D608283  lis r11, -0x7d7d
	ctx.r[11].s64 = -2105344000;
	// 823B2CB4: 893D0013  lbz r9, 0x13(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(19 as u32) ) } as u64;
	// 823B2CB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823B2CBC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B2CC0: 396B4E80  addi r11, r11, 0x4e80
	ctx.r[11].s64 = ctx.r[11].s64 + 20096;
	// 823B2CC4: 552A183E  rotlwi r10, r9, 3
	ctx.r[10].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 823B2CC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823B2CCC: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823B2CD0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 823B2CD4: 419A000C  beq cr6, 0x823b2ce0
	if ctx.cr[6].eq {
	pc = 0x823B2CE0; continue 'dispatch;
	}
	// 823B2CD8: 396A0003  addi r11, r10, 3
	ctx.r[11].s64 = ctx.r[10].s64 + 3;
	// 823B2CDC: 556A003A  rlwinm r10, r11, 0, 0, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x823B2CE0; continue 'dispatch;
            }
            0x823B2CE0 => {
    //   block [0x823B2CE0..0x823B2D04)
	// 823B2CE0: 576B05EF  rlwinm. r11, r27, 0, 0x17, 0x17
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B2CE4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 823B2CE8: 2B1A0001  cmplwi cr6, r26, 1
	ctx.cr[6].compare_u32(ctx.r[26].u32, 1 as u32, &mut ctx.xer);
	// 823B2CEC: 41820048  beq 0x823b2d34
	if ctx.cr[0].eq {
	pc = 0x823B2D34; continue 'dispatch;
	}
	// 823B2CF0: 419A0014  beq cr6, 0x823b2d04
	if ctx.cr[6].eq {
	pc = 0x823B2D04; continue 'dispatch;
	}
	// 823B2CF4: 2B1A0002  cmplwi cr6, r26, 2
	ctx.cr[6].compare_u32(ctx.r[26].u32, 2 as u32, &mut ctx.xer);
	// 823B2CF8: 409A0010  bne cr6, 0x823b2d08
	if !ctx.cr[6].eq {
	pc = 0x823B2D08; continue 'dispatch;
	}
	// 823B2CFC: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B2D00: 48000008  b 0x823b2d08
	pc = 0x823B2D08; continue 'dispatch;
            }
            0x823B2D04 => {
    //   block [0x823B2D04..0x823B2D08)
	// 823B2D04: A17D000C  lhz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x823B2D08; continue 'dispatch;
            }
            0x823B2D08 => {
    //   block [0x823B2D08..0x823B2D34)
	// 823B2D08: 7D4A49D6  mullw r10, r10, r9
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823B2D0C: 811F0050  lwz r8, 0x50(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B2D10: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B2D14: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B2D18: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 823B2D1C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 823B2D20: 7D4BEA14  add r10, r11, r29
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 823B2D24: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B2D28: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B2D2C: 4819CA6D  bl 0x8254f798
	ctx.lr = 0x823B2D30;
	sub_8254F798(ctx, base);
	// 823B2D30: 4800002C  b 0x823b2d5c
	pc = 0x823B2D5C; continue 'dispatch;
            }
            0x823B2D34 => {
    //   block [0x823B2D34..0x823B2D48)
	// 823B2D34: 419A0014  beq cr6, 0x823b2d48
	if ctx.cr[6].eq {
	pc = 0x823B2D48; continue 'dispatch;
	}
	// 823B2D38: 2B1A0002  cmplwi cr6, r26, 2
	ctx.cr[6].compare_u32(ctx.r[26].u32, 2 as u32, &mut ctx.xer);
	// 823B2D3C: 409A0010  bne cr6, 0x823b2d4c
	if !ctx.cr[6].eq {
	pc = 0x823B2D4C; continue 'dispatch;
	}
	// 823B2D40: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B2D44: 48000008  b 0x823b2d4c
	pc = 0x823B2D4C; continue 'dispatch;
            }
            0x823B2D48 => {
    //   block [0x823B2D48..0x823B2D4C)
	// 823B2D48: A17D000C  lhz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x823B2D4C; continue 'dispatch;
            }
            0x823B2D4C => {
    //   block [0x823B2D4C..0x823B2D5C)
	// 823B2D4C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 823B2D50: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B2D54: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 823B2D58: 48181DF9  bl 0x82534b50
	ctx.lr = 0x823B2D5C;
	sub_82534B50(ctx, base);
	pc = 0x823B2D5C; continue 'dispatch;
            }
            0x823B2D5C => {
    //   block [0x823B2D5C..0x823B2D60)
	// 823B2D5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823B2D60; continue 'dispatch;
            }
            0x823B2D60 => {
    //   block [0x823B2D60..0x823B2D68)
	// 823B2D60: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823B2D64: 48182398  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2D68 size=80
    let mut pc: u32 = 0x823B2D68;
    'dispatch: loop {
        match pc {
            0x823B2D68 => {
    //   block [0x823B2D68..0x823B2D98)
	// 823B2D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B2D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B2D70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B2D74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B2D78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B2D7C: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B2D80: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 823B2D84: 419A0014  beq cr6, 0x823b2d98
	if ctx.cr[6].eq {
	pc = 0x823B2D98; continue 'dispatch;
	}
	// 823B2D88: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B2D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B2D90: 409A0008  bne cr6, 0x823b2d98
	if !ctx.cr[6].eq {
	pc = 0x823B2D98; continue 'dispatch;
	}
	// 823B2D94: 4BFEDC75  bl 0x823a0a08
	ctx.lr = 0x823B2D98;
	sub_823A0A08(ctx, base);
	pc = 0x823B2D98; continue 'dispatch;
            }
            0x823B2D98 => {
    //   block [0x823B2D98..0x823B2DB8)
	// 823B2D98: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 823B2D9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B2DA0: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823B2DA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823B2DA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B2DAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B2DB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B2DB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2DB8 size=144
    let mut pc: u32 = 0x823B2DB8;
    'dispatch: loop {
        match pc {
            0x823B2DB8 => {
    //   block [0x823B2DB8..0x823B2E48)
	// 823B2DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B2DBC: 481822F9  bl 0x825350b4
	ctx.lr = 0x823B2DC0;
	sub_82535080(ctx, base);
	// 823B2DC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B2DC4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823B2DC8: 83E50004  lwz r31, 4(r5)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B2DCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823B2DD0: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 823B2DD4: 794AFFE6  rldicr r10, r10, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 823B2DD8: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 823B2DDC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823B2DE0: 38A3001C  addi r5, r3, 0x1c
	ctx.r[5].s64 = ctx.r[3].s64 + 28;
	// 823B2DE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B2DE8: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 823B2DEC: 7D5D5C36  srd r29, r10, r11
	if (ctx.r[11].u8 & 0x40) != 0 {
		ctx.r[29].u64 = 0;
	} else {
		ctx.r[29].u64 = (ctx.r[10].u64) >> ((ctx.r[11].u8 & 0x3F) as u32);
	}
	// 823B2DF0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823B2DF4: 48026C55  bl 0x823d9a48
	ctx.lr = 0x823B2DF8;
	sub_823D9A48(ctx, base);
	// 823B2DF8: 1D7E0018  mulli r11, r30, 0x18
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823B2DFC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823B2E00: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823B2E04: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 823B2E08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B2E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B2E10: 812B048C  lwz r9, 0x48c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1164 as u32) ) } as u64;
	// 823B2E14: 5149C1D0  rlwimi r9, r10, 0x18, 7, 8
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(24) as u64) & 0x0000000001800000) | (ctx.r[9].u64 & 0xFFFFFFFFFE7FFFFF);
	// 823B2E18: 912B048C  stw r9, 0x48c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1164 as u32), ctx.r[9].u32 ) };
	// 823B2E1C: E97F0018  ld r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 823B2E20: 7D6BEB78  or r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[29].u64;
	// 823B2E24: F97F0018  std r11, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 823B2E28: 4802B009  bl 0x823dde30
	ctx.lr = 0x823B2E2C;
	sub_823DDE30(ctx, base);
	// 823B2E2C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823B2E30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B2E34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B2E38: 4802B189  bl 0x823ddfc0
	ctx.lr = 0x823B2E3C;
	sub_823DDFC0(ctx, base);
	// 823B2E3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B2E40: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823B2E44: 481822C0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B2E48 size=24
    let mut pc: u32 = 0x823B2E48;
    'dispatch: loop {
        match pc {
            0x823B2E48 => {
    //   block [0x823B2E48..0x823B2E60)
	// 823B2E48: 81630050  lwz r11, 0x50(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B2E4C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 823B2E50: 419A0010  beq cr6, 0x823b2e60
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x823B2E60);
		return;
	}
	// 823B2E54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B2E58: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B2E5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2E70 size=168
    let mut pc: u32 = 0x823B2E70;
    'dispatch: loop {
        match pc {
            0x823B2E70 => {
    //   block [0x823B2E70..0x823B2EDC)
	// 823B2E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B2E74: 48182249  bl 0x825350bc
	ctx.lr = 0x823B2E78;
	sub_82535080(ctx, base);
	// 823B2E78: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B2E7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B2E80: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B2E84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B2E88: 409A0084  bne cr6, 0x823b2f0c
	if !ctx.cr[6].eq {
	pc = 0x823B2F0C; continue 'dispatch;
	}
	// 823B2E8C: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 823B2E90: 80FF0014  lwz r7, 0x14(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B2E94: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 823B2E98: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B2E9C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B2EA0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B2EA4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823B2EA8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 823B2EAC: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 823B2EB0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 823B2EB4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 823B2EB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823B2EBC: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 823B2EC0: 4819BC09  bl 0x8254eac8
	ctx.lr = 0x823B2EC4;
	sub_8254EAC8(ctx, base);
	// 823B2EC4: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B2EC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823B2ECC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 823B2ED0: 419A000C  beq cr6, 0x823b2edc
	if ctx.cr[6].eq {
	pc = 0x823B2EDC; continue 'dispatch;
	}
	// 823B2ED4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 823B2ED8: 4BFEDB31  bl 0x823a0a08
	ctx.lr = 0x823B2EDC;
	sub_823A0A08(ctx, base);
	pc = 0x823B2EDC; continue 'dispatch;
            }
            0x823B2EDC => {
    //   block [0x823B2EDC..0x823B2F04)
	// 823B2EDC: 38801000  li r4, 0x1000
	ctx.r[4].s64 = 4096;
	// 823B2EE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B2EE4: 4BFEDACD  bl 0x823a09b0
	ctx.lr = 0x823B2EE8;
	sub_823A09B0(ctx, base);
	// 823B2EE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 823B2EEC: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 823B2EF0: 909F0050  stw r4, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 823B2EF4: 409A0010  bne cr6, 0x823b2f04
	if !ctx.cr[6].eq {
	pc = 0x823B2F04; continue 'dispatch;
	}
	// 823B2EF8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 823B2EFC: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 823B2F00: 48000010  b 0x823b2f10
	pc = 0x823B2F10; continue 'dispatch;
            }
            0x823B2F04 => {
    //   block [0x823B2F04..0x823B2F0C)
	// 823B2F04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B2F08: 4819BD11  bl 0x8254ec18
	ctx.lr = 0x823B2F0C;
	sub_8254EC18(ctx, base);
	pc = 0x823B2F0C; continue 'dispatch;
            }
            0x823B2F0C => {
    //   block [0x823B2F0C..0x823B2F10)
	// 823B2F0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823B2F10; continue 'dispatch;
            }
            0x823B2F10 => {
    //   block [0x823B2F10..0x823B2F18)
	// 823B2F10: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823B2F14: 481821F8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2F18 size=140
    let mut pc: u32 = 0x823B2F18;
    'dispatch: loop {
        match pc {
            0x823B2F18 => {
    //   block [0x823B2F18..0x823B2F84)
	// 823B2F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B2F1C: 48182199  bl 0x825350b4
	ctx.lr = 0x823B2F20;
	sub_82535080(ctx, base);
	// 823B2F20: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B2F24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B2F28: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823B2F2C: 3B7F001C  addi r27, r31, 0x1c
	ctx.r[27].s64 = ctx.r[31].s64 + 28;
	// 823B2F30: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823B2F34: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 823B2F38: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B2F3C: 80FF0014  lwz r7, 0x14(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B2F40: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823B2F44: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B2F48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823B2F4C: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 823B2F50: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 823B2F54: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 823B2F58: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823B2F5C: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B2F60: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 823B2F64: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 823B2F68: 4819BB61  bl 0x8254eac8
	ctx.lr = 0x823B2F6C;
	sub_8254EAC8(ctx, base);
	// 823B2F6C: 2B1C0001  cmplwi cr6, r28, 1
	ctx.cr[6].compare_u32(ctx.r[28].u32, 1 as u32, &mut ctx.xer);
	// 823B2F70: 419A0014  beq cr6, 0x823b2f84
	if ctx.cr[6].eq {
	pc = 0x823B2F84; continue 'dispatch;
	}
	// 823B2F74: 2B1C0002  cmplwi cr6, r28, 2
	ctx.cr[6].compare_u32(ctx.r[28].u32, 2 as u32, &mut ctx.xer);
	// 823B2F78: 409A0010  bne cr6, 0x823b2f88
	if !ctx.cr[6].eq {
	pc = 0x823B2F88; continue 'dispatch;
	}
	// 823B2F7C: 83DD0020  lwz r30, 0x20(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B2F80: 48000008  b 0x823b2f88
	pc = 0x823B2F88; continue 'dispatch;
            }
            0x823B2F84 => {
    //   block [0x823B2F84..0x823B2F88)
	// 823B2F84: A3DD000C  lhz r30, 0xc(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x823B2F88; continue 'dispatch;
            }
            0x823B2F88 => {
    //   block [0x823B2F88..0x823B2FA4)
	// 823B2F88: 7C9EEA14  add r4, r30, r29
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 823B2F8C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823B2F90: 909F0050  stw r4, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 823B2F94: 4819BC85  bl 0x8254ec18
	ctx.lr = 0x823B2F98;
	sub_8254EC18(ctx, base);
	// 823B2F98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B2F9C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823B2FA0: 48182164  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B2FA8 size=16
    let mut pc: u32 = 0x823B2FA8;
    'dispatch: loop {
        match pc {
            0x823B2FA8 => {
    //   block [0x823B2FA8..0x823B2FB8)
	// 823B2FA8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B2FAC: 396B053C  addi r11, r11, 0x53c
	ctx.r[11].s64 = ctx.r[11].s64 + 1340;
	// 823B2FB0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B2FB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B2FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B2FB8 size=364
    let mut pc: u32 = 0x823B2FB8;
    'dispatch: loop {
        match pc {
            0x823B2FB8 => {
    //   block [0x823B2FB8..0x823B3020)
	// 823B2FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B2FBC: 481820E5  bl 0x825350a0
	ctx.lr = 0x823B2FC0;
	sub_82535080(ctx, base);
	// 823B2FC0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B2FC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823B2FC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B2FCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823B2FD0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B2FD4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B2FD8: 7F0BFA14  add r24, r11, r31
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823B2FDC: 7D6AF82E  lwzx r11, r10, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823B2FE0: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823B2FE4: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B2FE8: 7ECBFA14  add r22, r11, r31
	ctx.r[22].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823B2FEC: 48024505  bl 0x823d74f0
	ctx.lr = 0x823B2FF0;
	sub_823D74F0(ctx, base);
	// 823B2FF0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823B2FF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B2FF8: 394B0003  addi r10, r11, 3
	ctx.r[10].s64 = ctx.r[11].s64 + 3;
	// 823B2FFC: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B3000: 555D003A  rlwinm r29, r10, 0, 0, 0x1d
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823B3004: 3AEBF400  addi r23, r11, -0xc00
	ctx.r[23].s64 = ctx.r[11].s64 + -3072;
	// 823B3008: 1C9D0003  mulli r4, r29, 3
	ctx.r[4].s32 = ((ctx.r[29].s32 as i64 * 3 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 823B300C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 823B3010: 4BFEC9C9  bl 0x8239f9d8
	ctx.lr = 0x823B3014;
	sub_8239F9D8(ctx, base);
	// 823B3014: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 823B3018: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823B301C: 907E0018  stw r3, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	pc = 0x823B3020; continue 'dispatch;
            }
            0x823B3020 => {
    //   block [0x823B3020..0x823B3064)
	// 823B3020: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823B3024: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823B3028: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823B302C: 48024C95  bl 0x823d7cc0
	ctx.lr = 0x823B3030;
	sub_823D7CC0(ctx, base);
	// 823B3030: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823B3034: 7F7BEA14  add r27, r27, r29
	ctx.r[27].u64 = ctx.r[27].u64 + ctx.r[29].u64;
	// 823B3038: 4082FFE8  bne 0x823b3020
	if !ctx.cr[0].eq {
	pc = 0x823B3020; continue 'dispatch;
	}
	// 823B303C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 823B3040: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 823B3044: 396B001F  addi r11, r11, 0x1f
	ctx.r[11].s64 = ctx.r[11].s64 + 31;
	// 823B3048: 55790034  rlwinm r25, r11, 0, 0, 0x1a
	ctx.r[25].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823B304C: 1C790003  mulli r3, r25, 3
	ctx.r[3].s32 = ((ctx.r[25].s32 as i64 * 3 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 823B3050: 4BFED961  bl 0x823a09b0
	ctx.lr = 0x823B3054;
	sub_823A09B0(ctx, base);
	// 823B3054: 835E0018  lwz r26, 0x18(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B3058: 907E0020  stw r3, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 823B305C: 3B600003  li r27, 3
	ctx.r[27].s64 = 3;
	// 823B3060: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	pc = 0x823B3064; continue 'dispatch;
            }
            0x823B3064 => {
    //   block [0x823B3064..0x823B30F4)
	// 823B3064: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823B3068: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 823B306C: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823B3070: 48181AE1  bl 0x82534b50
	ctx.lr = 0x823B3074;
	sub_82534B50(ctx, base);
	// 823B3074: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823B3078: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823B307C: 480246BD  bl 0x823d7738
	ctx.lr = 0x823B3080;
	sub_823D7738(ctx, base);
	// 823B3080: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 823B3084: 7F5AEA14  add r26, r26, r29
	ctx.r[26].u64 = ctx.r[26].u64 + ctx.r[29].u64;
	// 823B3088: 7F9CCA14  add r28, r28, r25
	ctx.r[28].u64 = ctx.r[28].u64 + ctx.r[25].u64;
	// 823B308C: 4082FFD8  bne 0x823b3064
	if !ctx.cr[0].eq {
	pc = 0x823B3064; continue 'dispatch;
	}
	// 823B3090: B3BE0030  sth r29, 0x30(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[29].u16 ) };
	// 823B3094: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B3098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B309C: 40990058  ble cr6, 0x823b30f4
	if !ctx.cr[6].gt {
	pc = 0x823B30F4; continue 'dispatch;
	}
	// 823B30A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823B30A4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 823B30A8: 48024449  bl 0x823d74f0
	ctx.lr = 0x823B30AC;
	sub_823D74F0(ctx, base);
	// 823B30AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B30B0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 823B30B4: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823B30B8: 4BFEC921  bl 0x8239f9d8
	ctx.lr = 0x823B30BC;
	sub_8239F9D8(ctx, base);
	// 823B30BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823B30C0: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823B30C4: 907E001C  stw r3, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 823B30C8: 48024BC1  bl 0x823d7c88
	ctx.lr = 0x823B30CC;
	sub_823D7C88(ctx, base);
	// 823B30CC: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 823B30D0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 823B30D4: 4BFED8DD  bl 0x823a09b0
	ctx.lr = 0x823B30D8;
	sub_823A09B0(ctx, base);
	// 823B30D8: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 823B30DC: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823B30E0: 907E0024  stw r3, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823B30E4: 48181A6D  bl 0x82534b50
	ctx.lr = 0x823B30E8;
	sub_82534B50(ctx, base);
	// 823B30E8: 809E0024  lwz r4, 0x24(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 823B30EC: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B30F0: 48024451  bl 0x823d7540
	ctx.lr = 0x823B30F4;
	sub_823D7540(ctx, base);
	pc = 0x823B30F4; continue 'dispatch;
            }
            0x823B30F4 => {
    //   block [0x823B30F4..0x823B3124)
	// 823B30F4: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B30F8: 38FE0014  addi r7, r30, 0x14
	ctx.r[7].s64 = ctx.r[30].s64 + 20;
	// 823B30FC: 386BFD80  addi r3, r11, -0x280
	ctx.r[3].s64 = ctx.r[11].s64 + -640;
	// 823B3100: 38DE0010  addi r6, r30, 0x10
	ctx.r[6].s64 = ctx.r[30].s64 + 16;
	// 823B3104: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823B3108: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B310C: 48002CC5  bl 0x823b5dd0
	ctx.lr = 0x823B3110;
	sub_823B5DD0(ctx, base);
	// 823B3110: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823B3114: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B3118: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823B311C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823B3120: 48181FD0  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B3128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B3128 size=136
    let mut pc: u32 = 0x823B3128;
    'dispatch: loop {
        match pc {
            0x823B3128 => {
    //   block [0x823B3128..0x823B3164)
	// 823B3128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B312C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B3130: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B3134: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B3138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B313C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B3140: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B3144: 3BCBF400  addi r30, r11, -0xc00
	ctx.r[30].s64 = ctx.r[11].s64 + -3072;
	// 823B3148: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B314C: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B3150: 41820014  beq 0x823b3164
	if ctx.cr[0].eq {
	pc = 0x823B3164; continue 'dispatch;
	}
	// 823B3154: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B3158: 4BFEC981  bl 0x8239fad8
	ctx.lr = 0x823B315C;
	sub_8239FAD8(ctx, base);
	// 823B315C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B3160: 4BFED8A9  bl 0x823a0a08
	ctx.lr = 0x823B3164;
	sub_823A0A08(ctx, base);
	pc = 0x823B3164; continue 'dispatch;
            }
            0x823B3164 => {
    //   block [0x823B3164..0x823B3180)
	// 823B3164: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B3168: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B316C: 41820014  beq 0x823b3180
	if ctx.cr[0].eq {
	pc = 0x823B3180; continue 'dispatch;
	}
	// 823B3170: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B3174: 4BFEC965  bl 0x8239fad8
	ctx.lr = 0x823B3178;
	sub_8239FAD8(ctx, base);
	// 823B3178: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 823B317C: 4BFED88D  bl 0x823a0a08
	ctx.lr = 0x823B3180;
	sub_823A0A08(ctx, base);
	pc = 0x823B3180; continue 'dispatch;
            }
            0x823B3180 => {
    //   block [0x823B3180..0x823B3194)
	// 823B3180: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B3184: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B3188: 4182000C  beq 0x823b3194
	if ctx.cr[0].eq {
	pc = 0x823B3194; continue 'dispatch;
	}
	// 823B318C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B3190: 4BFEC949  bl 0x8239fad8
	ctx.lr = 0x823B3194;
	sub_8239FAD8(ctx, base);
	pc = 0x823B3194; continue 'dispatch;
            }
            0x823B3194 => {
    //   block [0x823B3194..0x823B31B0)
	// 823B3194: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B3198: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B319C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B31A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B31A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B31A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B31AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B31B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B31B0 size=4
    let mut pc: u32 = 0x823B31B0;
    'dispatch: loop {
        match pc {
            0x823B31B0 => {
    //   block [0x823B31B0..0x823B31B4)
	// 823B31B0: 4BFF75C0  b 0x823aa770
	sub_823AA770(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B31B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B31B8 size=372
    let mut pc: u32 = 0x823B31B8;
    'dispatch: loop {
        match pc {
            0x823B31B8 => {
    //   block [0x823B31B8..0x823B31FC)
	// 823B31B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B31BC: 48181EED  bl 0x825350a8
	ctx.lr = 0x823B31C0;
	sub_82535080(ctx, base);
	// 823B31C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B31C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B31C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823B31CC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823B31D0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823B31D4: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 823B31D8: A13F0030  lhz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 823B31DC: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 823B31E0: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B31E4: B1610050  sth r11, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u16 ) };
	// 823B31E8: 397F0028  addi r11, r31, 0x28
	ctx.r[11].s64 = ctx.r[31].s64 + 40;
	// 823B31EC: 9B810052  stb r28, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[28].u8 ) };
	// 823B31F0: 7F6A4A14  add r27, r10, r9
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823B31F4: 9BA10053  stb r29, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[29].u8 ) };
	// 823B31F8: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823B31FC; continue 'dispatch;
            }
            0x823B31FC => {
    //   block [0x823B31FC..0x823B3230)
	// 823B31FC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B3200: 3D008311  lis r8, -0x7cef
	ctx.r[8].s64 = -2096037888;
	// 823B3204: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 823B3208: 3B480700  addi r26, r8, 0x700
	ctx.r[26].s64 = ctx.r[8].s64 + 1792;
	// 823B320C: 419A0070  beq cr6, 0x823b327c
	if ctx.cr[6].eq {
	pc = 0x823B327C; continue 'dispatch;
	}
	// 823B3210: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823B3214: 419A001C  beq cr6, 0x823b3230
	if ctx.cr[6].eq {
	pc = 0x823B3230; continue 'dispatch;
	}
	// 823B3218: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823B321C: 7F7B4A14  add r27, r27, r9
	ctx.r[27].u64 = ctx.r[27].u64 + ctx.r[9].u64;
	// 823B3220: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823B3224: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 823B3228: 4198FFD4  blt cr6, 0x823b31fc
	if ctx.cr[6].lt {
	pc = 0x823B31FC; continue 'dispatch;
	}
	// 823B322C: 48000050  b 0x823b327c
	pc = 0x823B327C; continue 'dispatch;
            }
            0x823B3230 => {
    //   block [0x823B3230..0x823B3240)
	// 823B3230: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 823B3234: 2B1C0040  cmplwi cr6, r28, 0x40
	ctx.cr[6].compare_u32(ctx.r[28].u32, 64 as u32, &mut ctx.xer);
	// 823B3238: 41980008  blt cr6, 0x823b3240
	if ctx.cr[6].lt {
	pc = 0x823B3240; continue 'dispatch;
	}
	// 823B323C: 397CFFC0  addi r11, r28, -0x40
	ctx.r[11].s64 = ctx.r[28].s64 + -64;
	pc = 0x823B3240; continue 'dispatch;
            }
            0x823B3240 => {
    //   block [0x823B3240..0x823B327C)
	// 823B3240: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3244: 395A002C  addi r10, r26, 0x2c
	ctx.r[10].s64 = ctx.r[26].s64 + 44;
	// 823B3248: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B324C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823B3250: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3254: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823B3258: 7D6B502A  ldx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 823B325C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823B3260: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823B3264: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B3268: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823B326C: 480306DD  bl 0x823e3948
	ctx.lr = 0x823B3270;
	sub_823E3948(ctx, base);
	// 823B3270: 397D000A  addi r11, r29, 0xa
	ctx.r[11].s64 = ctx.r[29].s64 + 10;
	// 823B3274: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3278: 7FCBF92E  stwx r30, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[30].u32) };
	pc = 0x823B327C; continue 'dispatch;
            }
            0x823B327C => {
    //   block [0x823B327C..0x823B32C4)
	// 823B327C: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B3280: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 823B3284: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B3288: 419A003C  beq cr6, 0x823b32c4
	if ctx.cr[6].eq {
	pc = 0x823B32C4; continue 'dispatch;
	}
	// 823B328C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823B3290: 480245A1  bl 0x823d7830
	ctx.lr = 0x823B3294;
	sub_823D7830(ctx, base);
	// 823B3294: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B3298: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B329C: 480242DD  bl 0x823d7578
	ctx.lr = 0x823B32A0;
	sub_823D7578(ctx, base);
	// 823B32A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B32A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B32A8: 48024759  bl 0x823d7a00
	ctx.lr = 0x823B32AC;
	sub_823D7A00(ctx, base);
	// 823B32AC: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 823B32B0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 823B32B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B32B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B32BC: 4802B9FD  bl 0x823decb8
	ctx.lr = 0x823B32C0;
	sub_823DECB8(ctx, base);
	// 823B32C0: 48000064  b 0x823b3324
	pc = 0x823B3324; continue 'dispatch;
            }
            0x823B32C4 => {
    //   block [0x823B32C4..0x823B32EC)
	// 823B32C4: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B32C8: 48024569  bl 0x823d7830
	ctx.lr = 0x823B32CC;
	sub_823D7830(ctx, base);
	// 823B32CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B32D0: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B32D4: 480242A5  bl 0x823d7578
	ctx.lr = 0x823B32D8;
	sub_823D7578(ctx, base);
	// 823B32D8: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B32DC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 823B32E0: 2B1C0040  cmplwi cr6, r28, 0x40
	ctx.cr[6].compare_u32(ctx.r[28].u32, 64 as u32, &mut ctx.xer);
	// 823B32E4: 41980008  blt cr6, 0x823b32ec
	if ctx.cr[6].lt {
	pc = 0x823B32EC; continue 'dispatch;
	}
	// 823B32E8: 397CFFC0  addi r11, r28, -0x40
	ctx.r[11].s64 = ctx.r[28].s64 + -64;
	pc = 0x823B32EC; continue 'dispatch;
            }
            0x823B32EC => {
    //   block [0x823B32EC..0x823B3324)
	// 823B32EC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B32F0: 395A002C  addi r10, r26, 0x2c
	ctx.r[10].s64 = ctx.r[26].s64 + 44;
	// 823B32F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B32F8: 7D6B502A  ldx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 823B32FC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 823B3300: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823B3304: 480246FD  bl 0x823d7a00
	ctx.lr = 0x823B3308;
	sub_823D7A00(ctx, base);
	// 823B3308: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 823B330C: 80E1005C  lwz r7, 0x5c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 823B3310: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 823B3314: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 823B3318: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B331C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3320: 4802B601  bl 0x823de920
	ctx.lr = 0x823B3324;
	sub_823DE920(ctx, base);
	pc = 0x823B3324; continue 'dispatch;
            }
            0x823B3324 => {
    //   block [0x823B3324..0x823B332C)
	// 823B3324: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823B3328: 48181DD0  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B3330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B3330 size=432
    let mut pc: u32 = 0x823B3330;
    'dispatch: loop {
        match pc {
            0x823B3330 => {
    //   block [0x823B3330..0x823B3378)
	// 823B3330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B3334: 48181D71  bl 0x825350a4
	ctx.lr = 0x823B3338;
	sub_82535080(ctx, base);
	// 823B3338: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B333C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B3340: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823B3344: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823B3348: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823B334C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 823B3350: A13F0030  lhz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 823B3354: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 823B3358: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B335C: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 823B3360: B1610050  sth r11, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u16 ) };
	// 823B3364: 397F0028  addi r11, r31, 0x28
	ctx.r[11].s64 = ctx.r[31].s64 + 40;
	// 823B3368: 9BA10052  stb r29, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[29].u8 ) };
	// 823B336C: 7F6A4A14  add r27, r10, r9
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823B3370: 9B810053  stb r28, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[28].u8 ) };
	// 823B3374: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823B3378; continue 'dispatch;
            }
            0x823B3378 => {
    //   block [0x823B3378..0x823B33AC)
	// 823B3378: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B337C: 3D008311  lis r8, -0x7cef
	ctx.r[8].s64 = -2096037888;
	// 823B3380: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 823B3384: 3B480700  addi r26, r8, 0x700
	ctx.r[26].s64 = ctx.r[8].s64 + 1792;
	// 823B3388: 419A0078  beq cr6, 0x823b3400
	if ctx.cr[6].eq {
	pc = 0x823B3400; continue 'dispatch;
	}
	// 823B338C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823B3390: 419A001C  beq cr6, 0x823b33ac
	if ctx.cr[6].eq {
	pc = 0x823B33AC; continue 'dispatch;
	}
	// 823B3394: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 823B3398: 7F7B4A14  add r27, r27, r9
	ctx.r[27].u64 = ctx.r[27].u64 + ctx.r[9].u64;
	// 823B339C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823B33A0: 2F1C0002  cmpwi cr6, r28, 2
	ctx.cr[6].compare_i32(ctx.r[28].s32, 2, &mut ctx.xer);
	// 823B33A4: 4198FFD4  blt cr6, 0x823b3378
	if ctx.cr[6].lt {
	pc = 0x823B3378; continue 'dispatch;
	}
	// 823B33A8: 48000058  b 0x823b3400
	pc = 0x823B3400; continue 'dispatch;
            }
            0x823B33AC => {
    //   block [0x823B33AC..0x823B33BC)
	// 823B33AC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823B33B0: 2B1D0040  cmplwi cr6, r29, 0x40
	ctx.cr[6].compare_u32(ctx.r[29].u32, 64 as u32, &mut ctx.xer);
	// 823B33B4: 41980008  blt cr6, 0x823b33bc
	if ctx.cr[6].lt {
	pc = 0x823B33BC; continue 'dispatch;
	}
	// 823B33B8: 397DFFC0  addi r11, r29, -0x40
	ctx.r[11].s64 = ctx.r[29].s64 + -64;
	pc = 0x823B33BC; continue 'dispatch;
            }
            0x823B33BC => {
    //   block [0x823B33BC..0x823B3400)
	// 823B33BC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B33C0: 395A00F4  addi r10, r26, 0xf4
	ctx.r[10].s64 = ctx.r[26].s64 + 244;
	// 823B33C4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B33C8: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 823B33CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B33D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823B33D4: 7D6B502A  ldx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 823B33D8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823B33DC: A1610054  lhz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823B33E0: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B33E4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 823B33E8: A1610056  lhz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 823B33EC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823B33F0: 48030559  bl 0x823e3948
	ctx.lr = 0x823B33F4;
	sub_823E3948(ctx, base);
	// 823B33F4: 397C000A  addi r11, r28, 0xa
	ctx.r[11].s64 = ctx.r[28].s64 + 10;
	// 823B33F8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B33FC: 7FCBF92E  stwx r30, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[30].u32) };
	pc = 0x823B3400; continue 'dispatch;
            }
            0x823B3400 => {
    //   block [0x823B3400..0x823B345C)
	// 823B3400: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B3404: 2F1C0002  cmpwi cr6, r28, 2
	ctx.cr[6].compare_i32(ctx.r[28].s32, 2, &mut ctx.xer);
	// 823B3408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B340C: 419A0050  beq cr6, 0x823b345c
	if ctx.cr[6].eq {
	pc = 0x823B345C; continue 'dispatch;
	}
	// 823B3410: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823B3414: 4802441D  bl 0x823d7830
	ctx.lr = 0x823B3418;
	sub_823D7830(ctx, base);
	// 823B3418: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B341C: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B3420: 48024159  bl 0x823d7578
	ctx.lr = 0x823B3424;
	sub_823D7578(ctx, base);
	// 823B3424: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3428: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B342C: 480245D5  bl 0x823d7a00
	ctx.lr = 0x823B3430;
	sub_823D7A00(ctx, base);
	// 823B3430: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823B3434: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 823B3438: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B343C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B3440: 4802B879  bl 0x823decb8
	ctx.lr = 0x823B3444;
	sub_823DECB8(ctx, base);
	// 823B3444: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 823B3448: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 823B344C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B3450: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B3454: 4802B865  bl 0x823decb8
	ctx.lr = 0x823B3458;
	sub_823DECB8(ctx, base);
	// 823B3458: 48000080  b 0x823b34d8
	pc = 0x823B34D8; continue 'dispatch;
            }
            0x823B345C => {
    //   block [0x823B345C..0x823B3484)
	// 823B345C: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B3460: 480243D1  bl 0x823d7830
	ctx.lr = 0x823B3464;
	sub_823D7830(ctx, base);
	// 823B3464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B3468: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B346C: 4802410D  bl 0x823d7578
	ctx.lr = 0x823B3470;
	sub_823D7578(ctx, base);
	// 823B3470: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B3474: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823B3478: 2B1D0040  cmplwi cr6, r29, 0x40
	ctx.cr[6].compare_u32(ctx.r[29].u32, 64 as u32, &mut ctx.xer);
	// 823B347C: 41980008  blt cr6, 0x823b3484
	if ctx.cr[6].lt {
	pc = 0x823B3484; continue 'dispatch;
	}
	// 823B3480: 397DFFC0  addi r11, r29, -0x40
	ctx.r[11].s64 = ctx.r[29].s64 + -64;
	pc = 0x823B3484; continue 'dispatch;
            }
            0x823B3484 => {
    //   block [0x823B3484..0x823B34D8)
	// 823B3484: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3488: 395A00F4  addi r10, r26, 0xf4
	ctx.r[10].s64 = ctx.r[26].s64 + 244;
	// 823B348C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3490: 7D6B502A  ldx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 823B3494: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823B3498: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B349C: 48024565  bl 0x823d7a00
	ctx.lr = 0x823B34A0;
	sub_823D7A00(ctx, base);
	// 823B34A0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 823B34A4: A0E10054  lhz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823B34A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823B34AC: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 823B34B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B34B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B34B8: 4802B469  bl 0x823de920
	ctx.lr = 0x823B34BC;
	sub_823DE920(ctx, base);
	// 823B34BC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 823B34C0: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 823B34C4: A0E10056  lhz r7, 0x56(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 823B34C8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 823B34CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B34D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B34D4: 4802B44D  bl 0x823de920
	ctx.lr = 0x823B34D8;
	sub_823DE920(ctx, base);
	pc = 0x823B34D8; continue 'dispatch;
            }
            0x823B34D8 => {
    //   block [0x823B34D8..0x823B34E0)
	// 823B34D8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823B34DC: 48181C18  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B34E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B34E0 size=416
    let mut pc: u32 = 0x823B34E0;
    'dispatch: loop {
        match pc {
            0x823B34E0 => {
    //   block [0x823B34E0..0x823B3528)
	// 823B34E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B34E4: 48181BC1  bl 0x825350a4
	ctx.lr = 0x823B34E8;
	sub_82535080(ctx, base);
	// 823B34E8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B34EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B34F0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823B34F4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823B34F8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823B34FC: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 823B3500: A13F0030  lhz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 823B3504: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 823B3508: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B350C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823B3510: B1610050  sth r11, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u16 ) };
	// 823B3514: 397F0028  addi r11, r31, 0x28
	ctx.r[11].s64 = ctx.r[31].s64 + 40;
	// 823B3518: 9B810052  stb r28, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[28].u8 ) };
	// 823B351C: 7F295214  add r25, r9, r10
	ctx.r[25].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 823B3520: 9B610053  stb r27, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[27].u8 ) };
	// 823B3524: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823B3528; continue 'dispatch;
            }
            0x823B3528 => {
    //   block [0x823B3528..0x823B355C)
	// 823B3528: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B352C: 3D008311  lis r8, -0x7cef
	ctx.r[8].s64 = -2096037888;
	// 823B3530: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 823B3534: 3BA80700  addi r29, r8, 0x700
	ctx.r[29].s64 = ctx.r[8].s64 + 1792;
	// 823B3538: 419A0084  beq cr6, 0x823b35bc
	if ctx.cr[6].eq {
	pc = 0x823B35BC; continue 'dispatch;
	}
	// 823B353C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823B3540: 419A001C  beq cr6, 0x823b355c
	if ctx.cr[6].eq {
	pc = 0x823B355C; continue 'dispatch;
	}
	// 823B3544: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 823B3548: 7F394A14  add r25, r25, r9
	ctx.r[25].u64 = ctx.r[25].u64 + ctx.r[9].u64;
	// 823B354C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823B3550: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 823B3554: 4198FFD4  blt cr6, 0x823b3528
	if ctx.cr[6].lt {
	pc = 0x823B3528; continue 'dispatch;
	}
	// 823B3558: 48000064  b 0x823b35bc
	pc = 0x823B35BC; continue 'dispatch;
            }
            0x823B355C => {
    //   block [0x823B355C..0x823B35BC)
	// 823B355C: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 823B3560: 578A073E  clrlwi r10, r28, 0x1c
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x0000000Fu64;
	// 823B3564: 5569E13E  srwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B3568: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823B356C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823B3570: 391D0174  addi r8, r29, 0x174
	ctx.r[8].s64 = ctx.r[29].s64 + 372;
	// 823B3574: 1D290006  mulli r9, r9, 6
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 6 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823B3578: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823B357C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B3580: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823B3584: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3588: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B358C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823B3590: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 823B3594: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3598: 7D6B402A  ldx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	// 823B359C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823B35A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823B35A4: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B35A8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823B35AC: 4803039D  bl 0x823e3948
	ctx.lr = 0x823B35B0;
	sub_823E3948(ctx, base);
	// 823B35B0: 397A000A  addi r11, r26, 0xa
	ctx.r[11].s64 = ctx.r[26].s64 + 10;
	// 823B35B4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B35B8: 7FCBF92E  stwx r30, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[30].u32) };
	pc = 0x823B35BC; continue 'dispatch;
            }
            0x823B35BC => {
    //   block [0x823B35BC..0x823B3604)
	// 823B35BC: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B35C0: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 823B35C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B35C8: 419A003C  beq cr6, 0x823b3604
	if ctx.cr[6].eq {
	pc = 0x823B3604; continue 'dispatch;
	}
	// 823B35CC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 823B35D0: 48024261  bl 0x823d7830
	ctx.lr = 0x823B35D4;
	sub_823D7830(ctx, base);
	// 823B35D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B35D8: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B35DC: 48023F9D  bl 0x823d7578
	ctx.lr = 0x823B35E0;
	sub_823D7578(ctx, base);
	// 823B35E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B35E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B35E8: 48024419  bl 0x823d7a00
	ctx.lr = 0x823B35EC;
	sub_823D7A00(ctx, base);
	// 823B35EC: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 823B35F0: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 823B35F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B35F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B35FC: 4802B6BD  bl 0x823decb8
	ctx.lr = 0x823B3600;
	sub_823DECB8(ctx, base);
	// 823B3600: 48000078  b 0x823b3678
	pc = 0x823B3678; continue 'dispatch;
            }
            0x823B3604 => {
    //   block [0x823B3604..0x823B3678)
	// 823B3604: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B3608: 48024229  bl 0x823d7830
	ctx.lr = 0x823B360C;
	sub_823D7830(ctx, base);
	// 823B360C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B3610: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B3614: 48023F65  bl 0x823d7578
	ctx.lr = 0x823B3618;
	sub_823D7578(ctx, base);
	// 823B3618: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 823B361C: 578A073E  clrlwi r10, r28, 0x1c
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x0000000Fu64;
	// 823B3620: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B3624: 5569E13E  srwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B3628: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823B362C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823B3630: 391D0174  addi r8, r29, 0x174
	ctx.r[8].s64 = ctx.r[29].s64 + 372;
	// 823B3634: 1D290006  mulli r9, r9, 6
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 6 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823B3638: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823B363C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3640: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3644: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823B3648: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B364C: 7D6B402A  ldx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	// 823B3650: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 823B3654: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823B3658: 480243A9  bl 0x823d7a00
	ctx.lr = 0x823B365C;
	sub_823D7A00(ctx, base);
	// 823B365C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 823B3660: 80E1005C  lwz r7, 0x5c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 823B3664: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 823B3668: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 823B366C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3674: 4802B2AD  bl 0x823de920
	ctx.lr = 0x823B3678;
	sub_823DE920(ctx, base);
	pc = 0x823B3678; continue 'dispatch;
            }
            0x823B3678 => {
    //   block [0x823B3678..0x823B3680)
	// 823B3678: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823B367C: 48181A78  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B3680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B3680 size=480
    let mut pc: u32 = 0x823B3680;
    'dispatch: loop {
        match pc {
            0x823B3680 => {
    //   block [0x823B3680..0x823B36D0)
	// 823B3680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B3684: 48181A19  bl 0x8253509c
	ctx.lr = 0x823B3688;
	sub_82535080(ctx, base);
	// 823B3688: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B368C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823B3690: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B3694: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823B3698: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823B369C: 7D354B78  mr r21, r9
	ctx.r[21].u64 = ctx.r[9].u64;
	// 823B36A0: B1610050  sth r11, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u16 ) };
	// 823B36A4: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 823B36A8: A13F0030  lhz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 823B36AC: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 823B36B0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B36B4: 7D164378  mr r22, r8
	ctx.r[22].u64 = ctx.r[8].u64;
	// 823B36B8: 9B810052  stb r28, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[28].u8 ) };
	// 823B36BC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823B36C0: 9B610053  stb r27, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[27].u8 ) };
	// 823B36C4: 395F0028  addi r10, r31, 0x28
	ctx.r[10].s64 = ctx.r[31].s64 + 40;
	// 823B36C8: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B36CC: 7F295A14  add r25, r9, r11
	ctx.r[25].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	pc = 0x823B36D0; continue 'dispatch;
            }
            0x823B36D0 => {
    //   block [0x823B36D0..0x823B3704)
	// 823B36D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B36D4: 3D008311  lis r8, -0x7cef
	ctx.r[8].s64 = -2096037888;
	// 823B36D8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 823B36DC: 3BA80700  addi r29, r8, 0x700
	ctx.r[29].s64 = ctx.r[8].s64 + 1792;
	// 823B36E0: 419A008C  beq cr6, 0x823b376c
	if ctx.cr[6].eq {
	pc = 0x823B376C; continue 'dispatch;
	}
	// 823B36E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B36E8: 419A001C  beq cr6, 0x823b3704
	if ctx.cr[6].eq {
	pc = 0x823B3704; continue 'dispatch;
	}
	// 823B36EC: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 823B36F0: 7F394A14  add r25, r25, r9
	ctx.r[25].u64 = ctx.r[25].u64 + ctx.r[9].u64;
	// 823B36F4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823B36F8: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 823B36FC: 4198FFD4  blt cr6, 0x823b36d0
	if ctx.cr[6].lt {
	pc = 0x823B36D0; continue 'dispatch;
	}
	// 823B3700: 4800006C  b 0x823b376c
	pc = 0x823B376C; continue 'dispatch;
            }
            0x823B3704 => {
    //   block [0x823B3704..0x823B376C)
	// 823B3704: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 823B3708: 578A073E  clrlwi r10, r28, 0x1c
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x0000000Fu64;
	// 823B370C: 5569E13E  srwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B3710: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823B3714: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823B3718: 391D0474  addi r8, r29, 0x474
	ctx.r[8].s64 = ctx.r[29].s64 + 1140;
	// 823B371C: 1D290006  mulli r9, r9, 6
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 6 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823B3720: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823B3724: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B3728: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 823B372C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3730: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3734: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823B3738: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 823B373C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3740: 7D6B402A  ldx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	// 823B3744: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823B3748: A1610054  lhz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823B374C: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B3750: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 823B3754: A1610056  lhz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 823B3758: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823B375C: 480301ED  bl 0x823e3948
	ctx.lr = 0x823B3760;
	sub_823E3948(ctx, base);
	// 823B3760: 397A000A  addi r11, r26, 0xa
	ctx.r[11].s64 = ctx.r[26].s64 + 10;
	// 823B3764: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3768: 7FCBF92E  stwx r30, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[30].u32) };
	pc = 0x823B376C; continue 'dispatch;
            }
            0x823B376C => {
    //   block [0x823B376C..0x823B37C8)
	// 823B376C: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B3770: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 823B3774: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B3778: 419A0050  beq cr6, 0x823b37c8
	if ctx.cr[6].eq {
	pc = 0x823B37C8; continue 'dispatch;
	}
	// 823B377C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 823B3780: 480240B1  bl 0x823d7830
	ctx.lr = 0x823B3784;
	sub_823D7830(ctx, base);
	// 823B3784: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B3788: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B378C: 48023DED  bl 0x823d7578
	ctx.lr = 0x823B3790;
	sub_823D7578(ctx, base);
	// 823B3790: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B3798: 48024269  bl 0x823d7a00
	ctx.lr = 0x823B379C;
	sub_823D7A00(ctx, base);
	// 823B379C: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 823B37A0: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 823B37A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B37A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B37AC: 4802B50D  bl 0x823decb8
	ctx.lr = 0x823B37B0;
	sub_823DECB8(ctx, base);
	// 823B37B0: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 823B37B4: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 823B37B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B37BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B37C0: 4802B4F9  bl 0x823decb8
	ctx.lr = 0x823B37C4;
	sub_823DECB8(ctx, base);
	// 823B37C4: 48000094  b 0x823b3858
	pc = 0x823B3858; continue 'dispatch;
            }
            0x823B37C8 => {
    //   block [0x823B37C8..0x823B3858)
	// 823B37C8: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B37CC: 48024065  bl 0x823d7830
	ctx.lr = 0x823B37D0;
	sub_823D7830(ctx, base);
	// 823B37D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B37D4: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B37D8: 48023DA1  bl 0x823d7578
	ctx.lr = 0x823B37DC;
	sub_823D7578(ctx, base);
	// 823B37DC: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 823B37E0: 578A073E  clrlwi r10, r28, 0x1c
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x0000000Fu64;
	// 823B37E4: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B37E8: 5569E13E  srwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B37EC: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823B37F0: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823B37F4: 391D0474  addi r8, r29, 0x474
	ctx.r[8].s64 = ctx.r[29].s64 + 1140;
	// 823B37F8: 1D290006  mulli r9, r9, 6
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 6 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823B37FC: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823B3800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3804: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3808: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823B380C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3810: 7D6B402A  ldx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	// 823B3814: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823B3818: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B381C: 480241E5  bl 0x823d7a00
	ctx.lr = 0x823B3820;
	sub_823D7A00(ctx, base);
	// 823B3820: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 823B3824: A0E10054  lhz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823B3828: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 823B382C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 823B3830: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3838: 4802B0E9  bl 0x823de920
	ctx.lr = 0x823B383C;
	sub_823DE920(ctx, base);
	// 823B383C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 823B3840: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 823B3844: A0E10056  lhz r7, 0x56(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 823B3848: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 823B384C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B3850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3854: 4802B0CD  bl 0x823de920
	ctx.lr = 0x823B3858;
	sub_823DE920(ctx, base);
	pc = 0x823B3858; continue 'dispatch;
            }
            0x823B3858 => {
    //   block [0x823B3858..0x823B3860)
	// 823B3858: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823B385C: 48181890  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B3860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B3860 size=532
    let mut pc: u32 = 0x823B3860;
    'dispatch: loop {
        match pc {
            0x823B3860 => {
    //   block [0x823B3860..0x823B38B4)
	// 823B3860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B3864: 48181839  bl 0x8253509c
	ctx.lr = 0x823B3868;
	sub_82535080(ctx, base);
	// 823B3868: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B386C: 549E063E  clrlwi r30, r4, 0x18
	ctx.r[30].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 823B3870: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B3874: 7D164378  mr r22, r8
	ctx.r[22].u64 = ctx.r[8].u64;
	// 823B3878: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 823B387C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823B3880: 391E0080  addi r8, r30, 0x80
	ctx.r[8].s64 = ctx.r[30].s64 + 128;
	// 823B3884: 7D354B78  mr r21, r9
	ctx.r[21].u64 = ctx.r[9].u64;
	// 823B3888: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B388C: A13F0030  lhz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 823B3890: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 823B3894: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 823B3898: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 823B389C: 9B610053  stb r27, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[27].u8 ) };
	// 823B38A0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823B38A4: 99010052  stb r8, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[8].u8 ) };
	// 823B38A8: 395F0028  addi r10, r31, 0x28
	ctx.r[10].s64 = ctx.r[31].s64 + 40;
	// 823B38AC: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B38B0: 7F2B4A14  add r25, r11, r9
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x823B38B4; continue 'dispatch;
            }
            0x823B38B4 => {
    //   block [0x823B38B4..0x823B38E8)
	// 823B38B4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B38B8: 3D008311  lis r8, -0x7cef
	ctx.r[8].s64 = -2096037888;
	// 823B38BC: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 823B38C0: 3B880700  addi r28, r8, 0x700
	ctx.r[28].s64 = ctx.r[8].s64 + 1792;
	// 823B38C4: 419A00A4  beq cr6, 0x823b3968
	if ctx.cr[6].eq {
	pc = 0x823B3968; continue 'dispatch;
	}
	// 823B38C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B38CC: 419A001C  beq cr6, 0x823b38e8
	if ctx.cr[6].eq {
	pc = 0x823B38E8; continue 'dispatch;
	}
	// 823B38D0: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 823B38D4: 7F394A14  add r25, r25, r9
	ctx.r[25].u64 = ctx.r[25].u64 + ctx.r[9].u64;
	// 823B38D8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823B38DC: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 823B38E0: 4198FFD4  blt cr6, 0x823b38b4
	if ctx.cr[6].lt {
	pc = 0x823B38B4; continue 'dispatch;
	}
	// 823B38E4: 48000084  b 0x823b3968
	pc = 0x823B3968; continue 'dispatch;
            }
            0x823B38E8 => {
    //   block [0x823B38E8..0x823B3968)
	// 823B38E8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823B38EC: 57C8F0BA  rlwinm r8, r30, 0x1e, 2, 0x1d
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000003u64;
	// 823B38F0: 3929162C  addi r9, r9, 0x162c
	ctx.r[9].s64 = ctx.r[9].s64 + 5676;
	// 823B38F4: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 823B38F8: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 823B38FC: 57CA073E  clrlwi r10, r30, 0x1c
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x0000000Fu64;
	// 823B3900: 38BC0474  addi r5, r28, 0x474
	ctx.r[5].s64 = ctx.r[28].s64 + 1140;
	// 823B3904: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B3908: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 823B390C: 8109FFFC  lwz r8, -4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) } as u64;
	// 823B3910: 5569E13E  srwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B3914: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823B3918: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823B391C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3920: 1D290006  mulli r9, r9, 6
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 6 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823B3924: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823B3928: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 823B392C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3930: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823B3934: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3938: 7D6B282A  ldx r11, r11, r5
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[5].u32)) };
	// 823B393C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823B3940: A1610054  lhz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823B3944: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B3948: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 823B394C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 823B3950: A1610056  lhz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 823B3954: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823B3958: 4802FFF1  bl 0x823e3948
	ctx.lr = 0x823B395C;
	sub_823E3948(ctx, base);
	// 823B395C: 397A000A  addi r11, r26, 0xa
	ctx.r[11].s64 = ctx.r[26].s64 + 10;
	// 823B3960: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3964: 7FABF92E  stwx r29, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[29].u32) };
	pc = 0x823B3968; continue 'dispatch;
            }
            0x823B3968 => {
    //   block [0x823B3968..0x823B39C4)
	// 823B3968: 83BC0004  lwz r29, 4(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B396C: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 823B3970: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B3974: 419A0050  beq cr6, 0x823b39c4
	if ctx.cr[6].eq {
	pc = 0x823B39C4; continue 'dispatch;
	}
	// 823B3978: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 823B397C: 48023EB5  bl 0x823d7830
	ctx.lr = 0x823B3980;
	sub_823D7830(ctx, base);
	// 823B3980: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B3984: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B3988: 48023BF1  bl 0x823d7578
	ctx.lr = 0x823B398C;
	sub_823D7578(ctx, base);
	// 823B398C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3990: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B3994: 4802406D  bl 0x823d7a00
	ctx.lr = 0x823B3998;
	sub_823D7A00(ctx, base);
	// 823B3998: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 823B399C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 823B39A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B39A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B39A8: 4802B311  bl 0x823decb8
	ctx.lr = 0x823B39AC;
	sub_823DECB8(ctx, base);
	// 823B39AC: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 823B39B0: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 823B39B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B39B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B39BC: 4802B2FD  bl 0x823decb8
	ctx.lr = 0x823B39C0;
	sub_823DECB8(ctx, base);
	// 823B39C0: 480000AC  b 0x823b3a6c
	pc = 0x823B3A6C; continue 'dispatch;
            }
            0x823B39C4 => {
    //   block [0x823B39C4..0x823B3A6C)
	// 823B39C4: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B39C8: 48023E69  bl 0x823d7830
	ctx.lr = 0x823B39CC;
	sub_823D7830(ctx, base);
	// 823B39CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B39D0: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B39D4: 48023BA5  bl 0x823d7578
	ctx.lr = 0x823B39D8;
	sub_823D7578(ctx, base);
	// 823B39D8: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 823B39DC: 57CA073E  clrlwi r10, r30, 0x1c
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x0000000Fu64;
	// 823B39E0: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B39E4: 5569E13E  srwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B39E8: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823B39EC: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823B39F0: 391C0474  addi r8, r28, 0x474
	ctx.r[8].s64 = ctx.r[28].s64 + 1140;
	// 823B39F4: 1D290006  mulli r9, r9, 6
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 6 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823B39F8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823B39FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3A00: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3A04: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823B3A08: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B3A0C: 7D6B402A  ldx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	// 823B3A10: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823B3A14: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B3A18: 48023FE9  bl 0x823d7a00
	ctx.lr = 0x823B3A1C;
	sub_823D7A00(ctx, base);
	// 823B3A1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B3A20: A1410054  lhz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823B3A24: 57C9F0BA  rlwinm r9, r30, 0x1e, 2, 0x1d
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000003u64;
	// 823B3A28: 396B162C  addi r11, r11, 0x162c
	ctx.r[11].s64 = ctx.r[11].s64 + 5676;
	// 823B3A2C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 823B3A30: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823B3A34: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 823B3A38: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 823B3A3C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3A40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3A44: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 823B3A48: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823B3A4C: 4802AED5  bl 0x823de920
	ctx.lr = 0x823B3A50;
	sub_823DE920(ctx, base);
	// 823B3A50: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 823B3A54: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 823B3A58: A0E10056  lhz r7, 0x56(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 823B3A5C: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 823B3A60: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B3A64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3A68: 4802AEB9  bl 0x823de920
	ctx.lr = 0x823B3A6C;
	sub_823DE920(ctx, base);
	pc = 0x823B3A6C; continue 'dispatch;
            }
            0x823B3A6C => {
    //   block [0x823B3A6C..0x823B3A74)
	// 823B3A6C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823B3A70: 4818167C  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B3A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B3A78 size=120
    let mut pc: u32 = 0x823B3A78;
    'dispatch: loop {
        match pc {
            0x823B3A78 => {
    //   block [0x823B3A78..0x823B3AA8)
	// 823B3A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B3A7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B3A80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B3A84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B3A88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B3A8C: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823B3A90: EBC30008  ld r30, 8(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 823B3A94: 3BEB1E80  addi r31, r11, 0x1e80
	ctx.r[31].s64 = ctx.r[11].s64 + 7808;
	// 823B3A98: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 823B3A9C: 7F2BF040  cmpld cr6, r11, r30
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[30].u64, &mut ctx.xer);
	// 823B3AA0: 40980034  bge cr6, 0x823b3ad4
	if !ctx.cr[6].lt {
	pc = 0x823B3AD4; continue 'dispatch;
	}
	// 823B3AA4: 48000014  b 0x823b3ab8
	pc = 0x823B3AB8; continue 'dispatch;
            }
            0x823B3AA8 => {
    //   block [0x823B3AA8..0x823B3AB8)
	// 823B3AA8: 483597C5  bl 0x8270d26c
	ctx.lr = 0x823B3AAC;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B3AAC: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 823B3AB0: 807F00A0  lwz r3, 0xa0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 823B3AB4: 4800DA65  bl 0x823c1518
	ctx.lr = 0x823B3AB8;
	sub_823C1518(ctx, base);
	pc = 0x823B3AB8; continue 'dispatch;
            }
            0x823B3AB8 => {
    //   block [0x823B3AB8..0x823B3AD4)
	// 823B3AB8: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 823B3ABC: 483597A1  bl 0x8270d25c
	ctx.lr = 0x823B3AC0;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B3AC0: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 823B3AC4: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 823B3AC8: 7F2BF040  cmpld cr6, r11, r30
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[30].u64, &mut ctx.xer);
	// 823B3ACC: 4198FFDC  blt cr6, 0x823b3aa8
	if ctx.cr[6].lt {
	pc = 0x823B3AA8; continue 'dispatch;
	}
	// 823B3AD0: 4835979D  bl 0x8270d26c
	ctx.lr = 0x823B3AD4;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x823B3AD4; continue 'dispatch;
            }
            0x823B3AD4 => {
    //   block [0x823B3AD4..0x823B3AF0)
	// 823B3AD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B3AD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B3ADC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B3AE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B3AE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B3AE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B3AEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B3AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823B3AF0 size=268
    let mut pc: u32 = 0x823B3AF0;
    'dispatch: loop {
        match pc {
            0x823B3AF0 => {
    //   block [0x823B3AF0..0x823B3BFC)
	// 823B3AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B3AF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B3AF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B3AFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B3B00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B3B04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B3B08: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 823B3B0C: 39410074  addi r10, r1, 0x74
	ctx.r[10].s64 = ctx.r[1].s64 + 116;
	// 823B3B10: 39210078  addi r9, r1, 0x78
	ctx.r[9].s64 = ctx.r[1].s64 + 120;
	// 823B3B14: 3901007C  addi r8, r1, 0x7c
	ctx.r[8].s64 = ctx.r[1].s64 + 124;
	// 823B3B18: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B3B1C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 823B3B20: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 823B3B24: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823B3B28: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B3B2C: C1BF000C  lfs f13, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823B3B30: C19F0010  lfs f12, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823B3B34: FDA06E5E  fctidz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 823B3B38: C17F0014  lfs f11, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823B3B3C: 3BCB0700  addi r30, r11, 0x700
	ctx.r[30].s64 = ctx.r[11].s64 + 1792;
	// 823B3B40: 7DA057AE  stfiwx f13, 0, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823B3B44: FC00665E  fctidz f0, f12
	ctx.f[0].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 823B3B48: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 823B3B4C: FDA05E5E  fctidz f13, f11
	ctx.f[13].s64 = if ctx.f[11].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[11].f64.trunc() as i64 };
	// 823B3B50: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B3B54: 7DA047AE  stfiwx f13, 0, r8
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 823B3B58: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 823B3B5C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B3B60: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B3B64: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 823B3B68: 4802B591  bl 0x823df0f8
	ctx.lr = 0x823B3B6C;
	sub_823DF0F8(ctx, base);
	// 823B3B6C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823B3B70: C01F0020  lfs f0, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B3B74: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 823B3B78: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823B3B7C: FDA06E5E  fctidz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 823B3B80: C19F0028  lfs f12, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823B3B84: FD80665E  fctidz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 823B3B88: C17F002C  lfs f11, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823B3B8C: FD605E5E  fctidz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[11].f64.trunc() as i64 };
	// 823B3B90: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823B3B94: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823B3B98: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B3B9C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B3BA0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823B3BA4: 7DA057AE  stfiwx f13, 0, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823B3BA8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 823B3BAC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B3BB0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 823B3BB4: 7D804FAE  stfiwx f12, 0, r9
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 823B3BB8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 823B3BBC: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B3BC0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 823B3BC4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823B3BC8: 7D6047AE  stfiwx f11, 0, r8
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 823B3BCC: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 823B3BD0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B3BD4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823B3BD8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 823B3BDC: 4802AC45  bl 0x823de820
	ctx.lr = 0x823B3BE0;
	sub_823DE820(ctx, base);
	// 823B3BE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B3BE4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823B3BE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B3BEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B3BF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B3BF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B3BF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B3C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B3C00 size=428
    let mut pc: u32 = 0x823B3C00;
    'dispatch: loop {
        match pc {
            0x823B3C00 => {
    //   block [0x823B3C00..0x823B3CB8)
	// 823B3C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B3C04: 481814B9  bl 0x825350bc
	ctx.lr = 0x823B3C08;
	sub_82535080(ctx, base);
	// 823B3C08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B3C0C: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B3C10: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 823B3C14: 396B0700  addi r11, r11, 0x700
	ctx.r[11].s64 = ctx.r[11].s64 + 1792;
	// 823B3C18: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B3C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3C20: 480295B1  bl 0x823dd1d0
	ctx.lr = 0x823B3C24;
	sub_823DD1D0(ctx, base);
	// 823B3C24: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 823B3C28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3C2C: 480295E5  bl 0x823dd210
	ctx.lr = 0x823B3C30;
	sub_823DD210(ctx, base);
	// 823B3C30: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 823B3C34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3C38: 48029619  bl 0x823dd250
	ctx.lr = 0x823B3C3C;
	sub_823DD250(ctx, base);
	// 823B3C3C: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 823B3C40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3C44: 4802964D  bl 0x823dd290
	ctx.lr = 0x823B3C48;
	sub_823DD290(ctx, base);
	// 823B3C48: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B3C4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3C50: 48029029  bl 0x823dcc78
	ctx.lr = 0x823B3C54;
	sub_823DCC78(ctx, base);
	// 823B3C54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3C58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3C5C: 480288ED  bl 0x823dc548
	ctx.lr = 0x823B3C60;
	sub_823DC548(ctx, base);
	// 823B3C60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3C64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3C68: 48028919  bl 0x823dc580
	ctx.lr = 0x823B3C6C;
	sub_823DC580(ctx, base);
	// 823B3C6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3C70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3C74: 48028C9D  bl 0x823dc910
	ctx.lr = 0x823B3C78;
	sub_823DC910(ctx, base);
	// 823B3C78: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B3C7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3C80: 48029E89  bl 0x823ddb08
	ctx.lr = 0x823B3C84;
	sub_823DDB08(ctx, base);
	// 823B3C84: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 823B3C88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3C8C: 4802885D  bl 0x823dc4e8
	ctx.lr = 0x823B3C90;
	sub_823DC4E8(ctx, base);
	// 823B3C90: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B3C94: 3BCB0200  addi r30, r11, 0x200
	ctx.r[30].s64 = ctx.r[11].s64 + 512;
	// 823B3C98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B3C9C: 483595C1  bl 0x8270d25c
	ctx.lr = 0x823B3CA0;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B3CA0: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 823B3CA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B3CA8: 409A0010  bne cr6, 0x823b3cb8
	if !ctx.cr[6].eq {
	pc = 0x823B3CB8; continue 'dispatch;
	}
	// 823B3CAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B3CB0: 483595BD  bl 0x8270d26c
	ctx.lr = 0x823B3CB4;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B3CB4: 48000028  b 0x823b3cdc
	pc = 0x823B3CDC; continue 'dispatch;
            }
            0x823B3CB8 => {
    //   block [0x823B3CB8..0x823B3CDC)
	// 823B3CB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823B3CBC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B3CC0: 48025CA9  bl 0x823d9968
	ctx.lr = 0x823B3CC4;
	sub_823D9968(ctx, base);
	// 823B3CC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B3CC8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B3CCC: 483595A1  bl 0x8270d26c
	ctx.lr = 0x823B3CD0;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B3CD0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823B3CD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B3CD8: 409A0008  bne cr6, 0x823b3ce0
	if !ctx.cr[6].eq {
	pc = 0x823B3CE0; continue 'dispatch;
	}
	pc = 0x823B3CDC; continue 'dispatch;
            }
            0x823B3CDC => {
    //   block [0x823B3CDC..0x823B3CE0)
	// 823B3CDC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x823B3CE0; continue 'dispatch;
            }
            0x823B3CE0 => {
    //   block [0x823B3CE0..0x823B3D60)
	// 823B3CE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3CE4: 48028F55  bl 0x823dcc38
	ctx.lr = 0x823B3CE8;
	sub_823DCC38(ctx, base);
	// 823B3CE8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 823B3CEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3CF0: 48028FB9  bl 0x823dcca8
	ctx.lr = 0x823B3CF4;
	sub_823DCCA8(ctx, base);
	// 823B3CF4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3CF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3CFC: 48029315  bl 0x823dd010
	ctx.lr = 0x823B3D00;
	sub_823DD010(ctx, base);
	// 823B3D00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3D04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3D08: 480293D1  bl 0x823dd0d8
	ctx.lr = 0x823B3D0C;
	sub_823DD0D8(ctx, base);
	// 823B3D0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3D14: 48028FCD  bl 0x823dcce0
	ctx.lr = 0x823B3D18;
	sub_823DCCE0(ctx, base);
	// 823B3D18: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3D1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3D20: 48029001  bl 0x823dcd20
	ctx.lr = 0x823B3D24;
	sub_823DCD20(ctx, base);
	// 823B3D24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3D28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3D2C: 48028BE5  bl 0x823dc910
	ctx.lr = 0x823B3D30;
	sub_823DC910(ctx, base);
	// 823B3D30: 3C800000  lis r4, 0
	ctx.r[4].s64 = 0;
	// 823B3D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3D38: 6084FFFF  ori r4, r4, 0xffff
	ctx.r[4].u64 = ctx.r[4].u64 | 65535;
	// 823B3D3C: 48029E35  bl 0x823ddb70
	ctx.lr = 0x823B3D40;
	sub_823DDB70(ctx, base);
	// 823B3D40: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B3D44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3D48: 48029DF9  bl 0x823ddb40
	ctx.lr = 0x823B3D4C;
	sub_823DDB40(ctx, base);
	// 823B3D4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B3D50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3D54: 4802B395  bl 0x823df0e8
	ctx.lr = 0x823B3D58;
	sub_823DF0E8(ctx, base);
	// 823B3D58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823B3D5C: 395F0494  addi r10, r31, 0x494
	ctx.r[10].s64 = ctx.r[31].s64 + 1172;
	pc = 0x823B3D60; continue 'dispatch;
            }
            0x823B3D60 => {
    //   block [0x823B3D60..0x823B3DAC)
	// 823B3D60: 392B0020  addi r9, r11, 0x20
	ctx.r[9].s64 = ctx.r[11].s64 + 32;
	// 823B3D64: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B3D68: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 823B3D6C: 79290020  clrldi r9, r9, 0x20
	ctx.r[9].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 823B3D70: 78E7FFE6  rldicr r7, r7, 0x3f, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 823B3D74: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 823B3D78: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823B3D7C: 50C807BE  rlwimi r8, r6, 0, 0x1e, 0x1f
	ctx.r[8].u64 = (((ctx.r[6].u32).rotate_left(0) as u64) & 0x0000000000000003) | (ctx.r[8].u64 & 0xFFFFFFFFFFFFFFFC);
	// 823B3D80: 2B0B001A  cmplwi cr6, r11, 0x1a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 26 as u32, &mut ctx.xer);
	// 823B3D84: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823B3D88: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	// 823B3D8C: E91F0018  ld r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 823B3D90: 7CE94C36  srd r9, r7, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = (ctx.r[7].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 823B3D94: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 823B3D98: F93F0018  std r9, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u64 ) };
	// 823B3D9C: 4198FFC4  blt cr6, 0x823b3d60
	if ctx.cr[6].lt {
	pc = 0x823B3D60; continue 'dispatch;
	}
	// 823B3DA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B3DA4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823B3DA8: 48181364  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B3DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B3DB0 size=20
    let mut pc: u32 = 0x823B3DB0;
    'dispatch: loop {
        match pc {
            0x823B3DB0 => {
    //   block [0x823B3DB0..0x823B3DC4)
	// 823B3DB0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B3DB4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823B3DB8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823B3DBC: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 823B3DC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B3DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B3DC8 size=196
    let mut pc: u32 = 0x823B3DC8;
    'dispatch: loop {
        match pc {
            0x823B3DC8 => {
    //   block [0x823B3DC8..0x823B3DF0)
	// 823B3DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B3DCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B3DD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B3DD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B3DD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B3DDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B3DE0: 396B19C0  addi r11, r11, 0x19c0
	ctx.r[11].s64 = ctx.r[11].s64 + 6592;
	// 823B3DE4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B3DE8: 38FF0004  addi r7, r31, 4
	ctx.r[7].s64 = ctx.r[31].s64 + 4;
	// 823B3DEC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823B3DF0; continue 'dispatch;
            }
            0x823B3DF0 => {
    //   block [0x823B3DF0..0x823B3E40)
	// 823B3DF0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 823B3DF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823B3DF8: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 823B3DFC: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823B3E00: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823B3E04: 4082FFEC  bne 0x823b3df0
	if !ctx.cr[0].eq {
	pc = 0x823B3DF0; continue 'dispatch;
	}
	// 823B3E08: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 823B3E0C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B3E10: 3D408310  lis r10, -0x7cf0
	ctx.r[10].s64 = -2096103424;
	// 823B3E14: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 823B3E18: 396B1A30  addi r11, r11, 0x1a30
	ctx.r[11].s64 = ctx.r[11].s64 + 6704;
	// 823B3E1C: 394A0A00  addi r10, r10, 0xa00
	ctx.r[10].s64 = ctx.r[10].s64 + 2560;
	// 823B3E20: 54C90673  rlwinm. r9, r6, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823B3E24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3E28: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B3E2C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B3E30: 915F009C  stw r10, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 823B3E34: 4182000C  beq 0x823b3e40
	if ctx.cr[0].eq {
	pc = 0x823B3E40; continue 'dispatch;
	}
	// 823B3E38: 48000309  bl 0x823b4140
	ctx.lr = 0x823B3E3C;
	sub_823B4140(ctx, base);
	// 823B3E3C: 48000038  b 0x823b3e74
	pc = 0x823B3E74; continue 'dispatch;
            }
            0x823B3E40 => {
    //   block [0x823B3E40..0x823B3E74)
	// 823B3E40: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B3E44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B3E48: 4E800421  bctrl
	ctx.lr = 0x823B3E4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823B3E4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B3E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3E54: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B3E58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B3E5C: 4E800421  bctrl
	ctx.lr = 0x823B3E60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823B3E60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B3E64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3E68: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B3E6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B3E70: 4E800421  bctrl
	ctx.lr = 0x823B3E74;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823B3E74 => {
    //   block [0x823B3E74..0x823B3E8C)
	// 823B3E74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B3E78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823B3E7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B3E80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B3E84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B3E88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B3E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B3E90 size=548
    let mut pc: u32 = 0x823B3E90;
    'dispatch: loop {
        match pc {
            0x823B3E90 => {
    //   block [0x823B3E90..0x823B3F14)
	// 823B3E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B3E94: 48181215  bl 0x825350a8
	ctx.lr = 0x823B3E98;
	sub_82535080(ctx, base);
	// 823B3E98: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B3E9C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823B3EA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B3EA4: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B3EA8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B3EAC: 811F0018  lwz r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B3EB0: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 823B3EB4: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B3EB8: 839E000C  lwz r28, 0xc(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B3EBC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 823B3EC0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B3EC4: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 823B3EC8: 7F890034  cntlzw r9, r28
	ctx.r[9].u64 = if ctx.r[28].u32 == 0 { 32 } else { ctx.r[28].u32.leading_zeros() as u64 };
	// 823B3ECC: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823B3ED0: 5529DFFE  rlwinm r9, r9, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 823B3ED4: 3BAB0030  addi r29, r11, 0x30
	ctx.r[29].s64 = ctx.r[11].s64 + 48;
	// 823B3ED8: 69390001  xori r25, r9, 1
	ctx.r[25].u64 = ctx.r[9].u64 ^ 1;
	// 823B3EDC: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B3EE0: 3B6AFFD0  addi r27, r10, -0x30
	ctx.r[27].s64 = ctx.r[10].s64 + -48;
	// 823B3EE4: 28190000  cmplwi r25, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B3EE8: 3B4BFE00  addi r26, r11, -0x200
	ctx.r[26].s64 = ctx.r[11].s64 + -512;
	// 823B3EEC: 40820028  bne 0x823b3f14
	if !ctx.cr[0].eq {
	pc = 0x823B3F14; continue 'dispatch;
	}
	// 823B3EF0: 387A004C  addi r3, r26, 0x4c
	ctx.r[3].s64 = ctx.r[26].s64 + 76;
	// 823B3EF4: 48359369  bl 0x8270d25c
	ctx.lr = 0x823B3EF8;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B3EF8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B3EFC: 7C9BEA14  add r4, r27, r29
	ctx.r[4].u64 = ctx.r[27].u64 + ctx.r[29].u64;
	// 823B3F00: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823B3F04: 4BFEBAD5  bl 0x8239f9d8
	ctx.lr = 0x823B3F08;
	sub_8239F9D8(ctx, base);
	// 823B3F08: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823B3F0C: 387A004C  addi r3, r26, 0x4c
	ctx.r[3].s64 = ctx.r[26].s64 + 76;
	// 823B3F10: 4835935D  bl 0x8270d26c
	ctx.lr = 0x823B3F14;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x823B3F14; continue 'dispatch;
            }
            0x823B3F14 => {
    //   block [0x823B3F14..0x823B3F78)
	// 823B3F14: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823B3F18: 419A0194  beq cr6, 0x823b40ac
	if ctx.cr[6].eq {
	pc = 0x823B40AC; continue 'dispatch;
	}
	// 823B3F1C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823B3F20: 939E000C  stw r28, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 823B3F24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823B3F28: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823B3F2C: 48180C25  bl 0x82534b50
	ctx.lr = 0x823B3F30;
	sub_82534B50(ctx, base);
	// 823B3F30: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B3F34: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B3F38: 7C7CEA14  add r3, r28, r29
	ctx.r[3].u64 = ctx.r[28].u64 + ctx.r[29].u64;
	// 823B3F3C: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B3F40: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 823B3F44: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 823B3F48: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823B3F4C: 907E0090  stw r3, 0x90(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 823B3F50: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 823B3F54: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823B3F58: 48180BF9  bl 0x82534b50
	ctx.lr = 0x823B3F5C;
	sub_82534B50(ctx, base);
	// 823B3F5C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B3F60: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B3F64: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 823B3F68: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823B3F6C: 419A000C  beq cr6, 0x823b3f78
	if ctx.cr[6].eq {
	pc = 0x823B3F78; continue 'dispatch;
	}
	// 823B3F70: 839E0084  lwz r28, 0x84(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 823B3F74: 48000010  b 0x823b3f84
	pc = 0x823B3F84; continue 'dispatch;
            }
            0x823B3F78 => {
    //   block [0x823B3F78..0x823B3F84)
	// 823B3F78: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B3F7C: 4BFECA35  bl 0x823a09b0
	ctx.lr = 0x823B3F80;
	sub_823A09B0(ctx, base);
	// 823B3F80: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	pc = 0x823B3F84; continue 'dispatch;
            }
            0x823B3F84 => {
    //   block [0x823B3F84..0x823B3FB8)
	// 823B3F84: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 823B3F88: 409A0030  bne cr6, 0x823b3fb8
	if !ctx.cr[6].eq {
	pc = 0x823B3FB8; continue 'dispatch;
	}
	// 823B3F8C: 387A004C  addi r3, r26, 0x4c
	ctx.r[3].s64 = ctx.r[26].s64 + 76;
	// 823B3F90: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B3F94: 483592C9  bl 0x8270d25c
	ctx.lr = 0x823B3F98;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B3F98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823B3F9C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823B3FA0: 4BFEBB39  bl 0x8239fad8
	ctx.lr = 0x823B3FA4;
	sub_8239FAD8(ctx, base);
	// 823B3FA4: 387A004C  addi r3, r26, 0x4c
	ctx.r[3].s64 = ctx.r[26].s64 + 76;
	// 823B3FA8: 483592C5  bl 0x8270d26c
	ctx.lr = 0x823B3FAC;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B3FAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823B3FB0: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823B3FB4: 480000F8  b 0x823b40ac
	pc = 0x823B40AC; continue 'dispatch;
            }
            0x823B3FB8 => {
    //   block [0x823B3FB8..0x823B4014)
	// 823B3FB8: 7FBDFA14  add r29, r29, r31
	ctx.r[29].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 823B3FBC: 939E0084  stw r28, 0x84(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[28].u32 ) };
	// 823B3FC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823B3FC4: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B3FC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823B3FCC: 48180B85  bl 0x82534b50
	ctx.lr = 0x823B3FD0;
	sub_82534B50(ctx, base);
	// 823B3FD0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B3FD4: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 823B3FD8: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 823B3FDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823B3FE0: 907E0088  stw r3, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[3].u32 ) };
	// 823B3FE4: 80BF0018  lwz r5, 0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B3FE8: 48180B69  bl 0x82534b50
	ctx.lr = 0x823B3FEC;
	sub_82534B50(ctx, base);
	// 823B3FEC: 839F001C  lwz r28, 0x1c(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B3FF0: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 823B3FF4: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B3FF8: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B3FFC: 7F6BEA14  add r27, r11, r29
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 823B4000: 41820098  beq 0x823b4098
	if ctx.cr[0].eq {
	pc = 0x823B4098; continue 'dispatch;
	}
	// 823B4004: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 823B4008: 419A000C  beq cr6, 0x823b4014
	if ctx.cr[6].eq {
	pc = 0x823B4014; continue 'dispatch;
	}
	// 823B400C: 807E008C  lwz r3, 0x8c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 823B4010: 4800002C  b 0x823b403c
	pc = 0x823B403C; continue 'dispatch;
            }
            0x823B4014 => {
    //   block [0x823B4014..0x823B403C)
	// 823B4014: 387A004C  addi r3, r26, 0x4c
	ctx.r[3].s64 = ctx.r[26].s64 + 76;
	// 823B4018: 48359245  bl 0x8270d25c
	ctx.lr = 0x823B401C;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B401C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B4020: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823B4024: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823B4028: 4BFEB9B1  bl 0x8239f9d8
	ctx.lr = 0x823B402C;
	sub_8239F9D8(ctx, base);
	// 823B402C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823B4030: 387A004C  addi r3, r26, 0x4c
	ctx.r[3].s64 = ctx.r[26].s64 + 76;
	// 823B4034: 48359239  bl 0x8270d26c
	ctx.lr = 0x823B4038;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B4038: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x823B403C; continue 'dispatch;
            }
            0x823B403C => {
    //   block [0x823B403C..0x823B4084)
	// 823B403C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823B4040: 409A0044  bne cr6, 0x823b4084
	if !ctx.cr[6].eq {
	pc = 0x823B4084; continue 'dispatch;
	}
	// 823B4044: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 823B4048: 807E0084  lwz r3, 0x84(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 823B404C: 931E008C  stw r24, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[24].u32 ) };
	// 823B4050: 4BFEC9B9  bl 0x823a0a08
	ctx.lr = 0x823B4054;
	sub_823A0A08(ctx, base);
	// 823B4054: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 823B4058: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B405C: 387A004C  addi r3, r26, 0x4c
	ctx.r[3].s64 = ctx.r[26].s64 + 76;
	// 823B4060: 917E0084  stw r11, 0x84(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 823B4064: 483591F9  bl 0x8270d25c
	ctx.lr = 0x823B4068;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B4068: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823B406C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823B4070: 4BFEBA69  bl 0x8239fad8
	ctx.lr = 0x823B4074;
	sub_8239FAD8(ctx, base);
	// 823B4074: 387A004C  addi r3, r26, 0x4c
	ctx.r[3].s64 = ctx.r[26].s64 + 76;
	// 823B4078: 483591F5  bl 0x8270d26c
	ctx.lr = 0x823B407C;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B407C: 931E000C  stw r24, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[24].u32 ) };
	// 823B4080: 4800002C  b 0x823b40ac
	pc = 0x823B40AC; continue 'dispatch;
            }
            0x823B4084 => {
    //   block [0x823B4084..0x823B4098)
	// 823B4084: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823B4088: 907E008C  stw r3, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 823B408C: 80BF001C  lwz r5, 0x1c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B4090: 48180AC1  bl 0x82534b50
	ctx.lr = 0x823B4094;
	sub_82534B50(ctx, base);
	// 823B4094: 48000008  b 0x823b409c
	pc = 0x823B409C; continue 'dispatch;
            }
            0x823B4098 => {
    //   block [0x823B4098..0x823B409C)
	// 823B4098: 931E008C  stw r24, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[24].u32 ) };
	pc = 0x823B409C; continue 'dispatch;
            }
            0x823B409C => {
    //   block [0x823B409C..0x823B40AC)
	// 823B409C: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 823B40A0: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B40A4: 931E0020  stw r24, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[24].u32 ) };
	// 823B40A8: 48003729  bl 0x823b77d0
	ctx.lr = 0x823B40AC;
	sub_823B77D0(ctx, base);
	pc = 0x823B40AC; continue 'dispatch;
            }
            0x823B40AC => {
    //   block [0x823B40AC..0x823B40B4)
	// 823B40AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823B40B0: 48181048  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B40B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B40B8 size=132
    let mut pc: u32 = 0x823B40B8;
    'dispatch: loop {
        match pc {
            0x823B40B8 => {
    //   block [0x823B40B8..0x823B410C)
	// 823B40B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B40BC: 48181001  bl 0x825350bc
	ctx.lr = 0x823B40C0;
	sub_82535080(ctx, base);
	// 823B40C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B40C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B40C8: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B40CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B40D0: 41820064  beq 0x823b4134
	if ctx.cr[0].eq {
	pc = 0x823B4134; continue 'dispatch;
	}
	// 823B40D4: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 823B40D8: 48003849  bl 0x823b7920
	ctx.lr = 0x823B40DC;
	sub_823B7920(ctx, base);
	// 823B40DC: 83BE008C  lwz r29, 0x8c(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 823B40E0: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B40E4: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B40E8: 3BEBFE00  addi r31, r11, -0x200
	ctx.r[31].s64 = ctx.r[11].s64 + -512;
	// 823B40EC: 41820020  beq 0x823b410c
	if ctx.cr[0].eq {
	pc = 0x823B410C; continue 'dispatch;
	}
	// 823B40F0: 387F004C  addi r3, r31, 0x4c
	ctx.r[3].s64 = ctx.r[31].s64 + 76;
	// 823B40F4: 48359169  bl 0x8270d25c
	ctx.lr = 0x823B40F8;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B40F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823B40FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B4100: 4BFEB9D9  bl 0x8239fad8
	ctx.lr = 0x823B4104;
	sub_8239FAD8(ctx, base);
	// 823B4104: 387F004C  addi r3, r31, 0x4c
	ctx.r[3].s64 = ctx.r[31].s64 + 76;
	// 823B4108: 48359165  bl 0x8270d26c
	ctx.lr = 0x823B410C;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x823B410C; continue 'dispatch;
            }
            0x823B410C => {
    //   block [0x823B410C..0x823B4134)
	// 823B410C: 807E0084  lwz r3, 0x84(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 823B4110: 4BFEC8F9  bl 0x823a0a08
	ctx.lr = 0x823B4114;
	sub_823A0A08(ctx, base);
	// 823B4114: 387F004C  addi r3, r31, 0x4c
	ctx.r[3].s64 = ctx.r[31].s64 + 76;
	// 823B4118: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B411C: 48359141  bl 0x8270d25c
	ctx.lr = 0x823B4120;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B4120: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B4124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B4128: 4BFEB9B1  bl 0x8239fad8
	ctx.lr = 0x823B412C;
	sub_8239FAD8(ctx, base);
	// 823B412C: 387F004C  addi r3, r31, 0x4c
	ctx.r[3].s64 = ctx.r[31].s64 + 76;
	// 823B4130: 4835913D  bl 0x8270d26c
	ctx.lr = 0x823B4134;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x823B4134; continue 'dispatch;
            }
            0x823B4134 => {
    //   block [0x823B4134..0x823B413C)
	// 823B4134: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B4138: 48180FD4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B4140 size=440
    let mut pc: u32 = 0x823B4140;
    'dispatch: loop {
        match pc {
            0x823B4140 => {
    //   block [0x823B4140..0x823B41C8)
	// 823B4140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B4144: 48180F65  bl 0x825350a8
	ctx.lr = 0x823B4148;
	sub_82535080(ctx, base);
	// 823B4148: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B414C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823B4150: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823B4154: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823B4158: 3B00FFFF  li r24, -1
	ctx.r[24].s64 = -1;
	// 823B415C: 813E001C  lwz r9, 0x1c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B4160: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B4164: 811E0018  lwz r8, 0x18(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B4168: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 823B416C: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B4170: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B4174: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 823B4178: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B417C: 3B4B0030  addi r26, r11, 0x30
	ctx.r[26].s64 = ctx.r[11].s64 + 48;
	// 823B4180: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 823B4184: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 823B4188: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823B418C: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B4190: 3B2AFFD0  addi r25, r10, -0x30
	ctx.r[25].s64 = ctx.r[10].s64 + -48;
	// 823B4194: 3BABFE00  addi r29, r11, -0x200
	ctx.r[29].s64 = ctx.r[11].s64 + -512;
	// 823B4198: 419A0060  beq cr6, 0x823b41f8
	if ctx.cr[6].eq {
	pc = 0x823B41F8; continue 'dispatch;
	}
	// 823B419C: 839F008C  lwz r28, 0x8c(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 823B41A0: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B41A4: 41820024  beq 0x823b41c8
	if ctx.cr[0].eq {
	pc = 0x823B41C8; continue 'dispatch;
	}
	// 823B41A8: 387D004C  addi r3, r29, 0x4c
	ctx.r[3].s64 = ctx.r[29].s64 + 76;
	// 823B41AC: 483590B1  bl 0x8270d25c
	ctx.lr = 0x823B41B0;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B41B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823B41B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B41B8: 4BFEB921  bl 0x8239fad8
	ctx.lr = 0x823B41BC;
	sub_8239FAD8(ctx, base);
	// 823B41BC: 387D004C  addi r3, r29, 0x4c
	ctx.r[3].s64 = ctx.r[29].s64 + 76;
	// 823B41C0: 483590AD  bl 0x8270d26c
	ctx.lr = 0x823B41C4;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B41C4: 937F008C  stw r27, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[27].u32 ) };
	pc = 0x823B41C8; continue 'dispatch;
            }
            0x823B41C8 => {
    //   block [0x823B41C8..0x823B41F8)
	// 823B41C8: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 823B41CC: 4BFEC83D  bl 0x823a0a08
	ctx.lr = 0x823B41D0;
	sub_823A0A08(ctx, base);
	// 823B41D0: 387D004C  addi r3, r29, 0x4c
	ctx.r[3].s64 = ctx.r[29].s64 + 76;
	// 823B41D4: 839F000C  lwz r28, 0xc(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B41D8: 931F0084  stw r24, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[24].u32 ) };
	// 823B41DC: 48359081  bl 0x8270d25c
	ctx.lr = 0x823B41E0;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B41E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823B41E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B41E8: 4BFEB8F1  bl 0x8239fad8
	ctx.lr = 0x823B41EC;
	sub_8239FAD8(ctx, base);
	// 823B41EC: 387D004C  addi r3, r29, 0x4c
	ctx.r[3].s64 = ctx.r[29].s64 + 76;
	// 823B41F0: 4835907D  bl 0x8270d26c
	ctx.lr = 0x823B41F4;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B41F4: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	pc = 0x823B41F8; continue 'dispatch;
            }
            0x823B41F8 => {
    //   block [0x823B41F8..0x823B4260)
	// 823B41F8: 387D004C  addi r3, r29, 0x4c
	ctx.r[3].s64 = ctx.r[29].s64 + 76;
	// 823B41FC: 48359061  bl 0x8270d25c
	ctx.lr = 0x823B4200;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B4200: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B4204: 7C99D214  add r4, r25, r26
	ctx.r[4].u64 = ctx.r[25].u64 + ctx.r[26].u64;
	// 823B4208: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B420C: 4BFEB7CD  bl 0x8239f9d8
	ctx.lr = 0x823B4210;
	sub_8239F9D8(ctx, base);
	// 823B4210: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823B4214: 387D004C  addi r3, r29, 0x4c
	ctx.r[3].s64 = ctx.r[29].s64 + 76;
	// 823B4218: 48359055  bl 0x8270d26c
	ctx.lr = 0x823B421C;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B421C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823B4220: 419A00D0  beq cr6, 0x823b42f0
	if ctx.cr[6].eq {
	pc = 0x823B42F0; continue 'dispatch;
	}
	// 823B4224: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 823B4228: 7D7CD214  add r11, r28, r26
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[26].u64;
	// 823B422C: 9B7C0009  stb r27, 9(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(9 as u32), ctx.r[27].u8 ) };
	// 823B4230: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B4234: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B4238: 9B6A0008  stb r27, 8(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[27].u8 ) };
	// 823B423C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B4240: B36A000A  sth r27, 0xa(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(10 as u32), ctx.r[27].u16 ) };
	// 823B4244: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 823B4248: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B424C: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B4250: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823B4254: 4BFEC75D  bl 0x823a09b0
	ctx.lr = 0x823B4258;
	sub_823A09B0(ctx, base);
	// 823B4258: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 823B425C: 409A002C  bne cr6, 0x823b4288
	if !ctx.cr[6].eq {
	pc = 0x823B4288; continue 'dispatch;
	}
	pc = 0x823B4260; continue 'dispatch;
            }
            0x823B4260 => {
    //   block [0x823B4260..0x823B4288)
	// 823B4260: 387D004C  addi r3, r29, 0x4c
	ctx.r[3].s64 = ctx.r[29].s64 + 76;
	// 823B4264: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B4268: 48358FF5  bl 0x8270d25c
	ctx.lr = 0x823B426C;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B426C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B4270: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B4274: 4BFEB865  bl 0x8239fad8
	ctx.lr = 0x823B4278;
	sub_8239FAD8(ctx, base);
	// 823B4278: 387D004C  addi r3, r29, 0x4c
	ctx.r[3].s64 = ctx.r[29].s64 + 76;
	// 823B427C: 48358FF1  bl 0x8270d26c
	ctx.lr = 0x823B4280;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B4280: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 823B4284: 4800006C  b 0x823b42f0
	pc = 0x823B42F0; continue 'dispatch;
            }
            0x823B4288 => {
    //   block [0x823B4288..0x823B42E0)
	// 823B4288: 907F0084  stw r3, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 823B428C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B4290: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 823B4294: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 823B4298: 83DE001C  lwz r30, 0x1c(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B429C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B42A0: 41820048  beq 0x823b42e8
	if ctx.cr[0].eq {
	pc = 0x823B42E8; continue 'dispatch;
	}
	// 823B42A4: 387D004C  addi r3, r29, 0x4c
	ctx.r[3].s64 = ctx.r[29].s64 + 76;
	// 823B42A8: 48358FB5  bl 0x8270d25c
	ctx.lr = 0x823B42AC;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B42AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B42B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B42B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B42B8: 4BFEB721  bl 0x8239f9d8
	ctx.lr = 0x823B42BC;
	sub_8239F9D8(ctx, base);
	// 823B42BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B42C0: 387D004C  addi r3, r29, 0x4c
	ctx.r[3].s64 = ctx.r[29].s64 + 76;
	// 823B42C4: 48358FA9  bl 0x8270d26c
	ctx.lr = 0x823B42C8;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B42C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823B42CC: 409A0014  bne cr6, 0x823b42e0
	if !ctx.cr[6].eq {
	pc = 0x823B42E0; continue 'dispatch;
	}
	// 823B42D0: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 823B42D4: 4BFEC735  bl 0x823a0a08
	ctx.lr = 0x823B42D8;
	sub_823A0A08(ctx, base);
	// 823B42D8: 931F0084  stw r24, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[24].u32 ) };
	// 823B42DC: 4BFFFF84  b 0x823b4260
	pc = 0x823B4260; continue 'dispatch;
            }
            0x823B42E0 => {
    //   block [0x823B42E0..0x823B42E8)
	// 823B42E0: 93DF008C  stw r30, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 823B42E4: 48000008  b 0x823b42ec
	pc = 0x823B42EC; continue 'dispatch;
            }
            0x823B42E8 => {
    //   block [0x823B42E8..0x823B42EC)
	// 823B42E8: 937F008C  stw r27, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[27].u32 ) };
	pc = 0x823B42EC; continue 'dispatch;
            }
            0x823B42EC => {
    //   block [0x823B42EC..0x823B42F0)
	// 823B42EC: 937F0020  stw r27, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[27].u32 ) };
	pc = 0x823B42F0; continue 'dispatch;
            }
            0x823B42F0 => {
    //   block [0x823B42F0..0x823B42F8)
	// 823B42F0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823B42F4: 48180E04  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B42F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B42F8 size=104
    let mut pc: u32 = 0x823B42F8;
    'dispatch: loop {
        match pc {
            0x823B42F8 => {
    //   block [0x823B42F8..0x823B4344)
	// 823B42F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823B42FC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 823B4300: 906B000C  stw r3, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 823B4304: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B4308: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 823B430C: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 823B4310: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 823B4314: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B4318: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 823B431C: 914B0088  stw r10, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 823B4320: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B4324: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B4328: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 823B432C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823B4330: 419A0014  beq cr6, 0x823b4344
	if ctx.cr[6].eq {
	pc = 0x823B4344; continue 'dispatch;
	}
	// 823B4334: 914B008C  stw r10, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 823B4338: 8123001C  lwz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B433C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 823B4340: 4800000C  b 0x823b434c
	pc = 0x823B434C; continue 'dispatch;
            }
            0x823B4344 => {
    //   block [0x823B4344..0x823B434C)
	// 823B4344: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B4348: 912B008C  stw r9, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[9].u32 ) };
	pc = 0x823B434C; continue 'dispatch;
            }
            0x823B434C => {
    //   block [0x823B434C..0x823B4360)
	// 823B434C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823B4350: 914B0090  stw r10, 0x90(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 823B4354: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 823B4358: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 823B435C: 48003474  b 0x823b77d0
	sub_823B77D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B4360 size=12
    let mut pc: u32 = 0x823B4360;
    'dispatch: loop {
        match pc {
            0x823B4360 => {
    //   block [0x823B4360..0x823B436C)
	// 823B4360: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 823B4364: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B4368: 480035B8  b 0x823b7920
	sub_823B7920(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823B4370 size=252
    let mut pc: u32 = 0x823B4370;
    'dispatch: loop {
        match pc {
            0x823B4370 => {
    //   block [0x823B4370..0x823B43E8)
	// 823B4370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B4374: 48180D3D  bl 0x825350b0
	ctx.lr = 0x823B4378;
	sub_82535080(ctx, base);
	// 823B4378: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B437C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 823B4380: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B4384: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823B4388: 656B8000  oris r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 2147483648;
	// 823B438C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823B4390: 656B4000  oris r11, r11, 0x4000
	ctx.r[11].u64 = ctx.r[11].u64 | 1073741824;
	// 823B4394: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 823B4398: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823B439C: 656B2000  oris r11, r11, 0x2000
	ctx.r[11].u64 = ctx.r[11].u64 | 536870912;
	// 823B43A0: 83FC000C  lwz r31, 0xc(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B43A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B43A8: 656B1000  oris r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 268435456;
	// 823B43AC: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 823B43B0: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 823B43B4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 823B43B8: 48002311  bl 0x823b66c8
	ctx.lr = 0x823B43BC;
	sub_823B66C8(ctx, base);
	// 823B43BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B43C0: 418200A4  beq 0x823b4464
	if ctx.cr[0].eq {
	pc = 0x823B4464; continue 'dispatch;
	}
	// 823B43C4: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823B43C8: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	// 823B43CC: 396B1B00  addi r11, r11, 0x1b00
	ctx.r[11].s64 = ctx.r[11].s64 + 6912;
	// 823B43D0: F94B0150  std r10, 0x150(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(336 as u32), ctx.r[10].u64 ) };
	// 823B43D4: A17F000A  lhz r11, 0xa(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 823B43D8: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 823B43DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B43E0: 41820084  beq 0x823b4464
	if ctx.cr[0].eq {
	pc = 0x823B4464; continue 'dispatch;
	}
	// 823B43E4: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	pc = 0x823B43E8; continue 'dispatch;
            }
            0x823B43E8 => {
    //   block [0x823B43E8..0x823B4410)
	// 823B43E8: A17F0026  lhz r11, 0x26(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 823B43EC: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B43F0: 40820068  bne 0x823b4458
	if !ctx.cr[0].eq {
	pc = 0x823B4458; continue 'dispatch;
	}
	// 823B43F4: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B43F8: 40820018  bne 0x823b4410
	if !ctx.cr[0].eq {
	pc = 0x823B4410; continue 'dispatch;
	}
	// 823B43FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823B4400: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B4404: 480022C5  bl 0x823b66c8
	ctx.lr = 0x823B4408;
	sub_823B66C8(ctx, base);
	// 823B4408: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B440C: 4182004C  beq 0x823b4458
	if ctx.cr[0].eq {
	pc = 0x823B4458; continue 'dispatch;
	}
	pc = 0x823B4410; continue 'dispatch;
            }
            0x823B4410 => {
    //   block [0x823B4410..0x823B4440)
	// 823B4410: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 823B4414: A3DF002A  lhz r30, 0x2a(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(42 as u32) ) } as u64;
	// 823B4418: C01F001C  lfs f0, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B441C: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823B4420: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823B4424: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4428: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823B442C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823B4430: 796B07A4  rldicr r11, r11, 0, 0x3e
	ctx.r[11].u64 = (ctx.r[11].u64).rotate_left(0) & 0xFFFFFFFFFFFFFFFE;
	// 823B4434: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823B4438: 41820020  beq 0x823b4458
	if ctx.cr[0].eq {
	pc = 0x823B4458; continue 'dispatch;
	}
	// 823B443C: 3BBC0010  addi r29, r28, 0x10
	ctx.r[29].s64 = ctx.r[28].s64 + 16;
	pc = 0x823B4440; continue 'dispatch;
            }
            0x823B4440 => {
    //   block [0x823B4440..0x823B4458)
	// 823B4440: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 823B4444: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823B4448: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823B444C: 480069BD  bl 0x823bae08
	ctx.lr = 0x823B4450;
	sub_823BAE08(ctx, base);
	// 823B4450: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823B4454: 4082FFEC  bne 0x823b4440
	if !ctx.cr[0].eq {
	pc = 0x823B4440; continue 'dispatch;
	}
	pc = 0x823B4458; continue 'dispatch;
            }
            0x823B4458 => {
    //   block [0x823B4458..0x823B4464)
	// 823B4458: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 823B445C: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823B4460: 4082FF88  bne 0x823b43e8
	if !ctx.cr[0].eq {
	pc = 0x823B43E8; continue 'dispatch;
	}
	pc = 0x823B4464; continue 'dispatch;
            }
            0x823B4464 => {
    //   block [0x823B4464..0x823B446C)
	// 823B4464: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 823B4468: 48180C98  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B4470 size=272
    let mut pc: u32 = 0x823B4470;
    'dispatch: loop {
        match pc {
            0x823B4470 => {
    //   block [0x823B4470..0x823B44B0)
	// 823B4470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B4474: 48180C3D  bl 0x825350b0
	ctx.lr = 0x823B4478;
	sub_82535080(ctx, base);
	// 823B4478: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B447C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823B4480: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823B4484: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 823B4488: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 823B448C: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 823B4490: 83BC000C  lwz r29, 0xc(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B4494: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823B4498: 419A0038  beq cr6, 0x823b44d0
	if ctx.cr[6].eq {
	pc = 0x823B44D0; continue 'dispatch;
	}
	// 823B449C: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 823B44A0: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 823B44A4: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823B44A8: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 823B44AC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x823B44B0; continue 'dispatch;
            }
            0x823B44B0 => {
    //   block [0x823B44B0..0x823B44D0)
	// 823B44B0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B44B4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B44B8: 80C9000C  lwz r6, 0xc(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B44BC: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 823B44C0: 7CC8592E  stwx r6, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 823B44C4: 7D27592E  stwx r9, r7, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 823B44C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823B44CC: 4082FFE4  bne 0x823b44b0
	if !ctx.cr[0].eq {
	pc = 0x823B44B0; continue 'dispatch;
	}
	pc = 0x823B44D0; continue 'dispatch;
            }
            0x823B44D0 => {
    //   block [0x823B44D0..0x823B4524)
	// 823B44D0: 816100D4  lwz r11, 0xd4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 823B44D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B44D8: 389D0020  addi r4, r29, 0x20
	ctx.r[4].s64 = ctx.r[29].s64 + 32;
	// 823B44DC: 656B8000  oris r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 2147483648;
	// 823B44E0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 823B44E4: 656B4000  oris r11, r11, 0x4000
	ctx.r[11].u64 = ctx.r[11].u64 | 1073741824;
	// 823B44E8: F94100B0  std r10, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[10].u64 ) };
	// 823B44EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823B44F0: 656B2000  oris r11, r11, 0x2000
	ctx.r[11].u64 = ctx.r[11].u64 | 536870912;
	// 823B44F4: 656B1000  oris r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 268435456;
	// 823B44F8: 914100D0  stw r10, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 823B44FC: 916100D4  stw r11, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 823B4500: 480021C9  bl 0x823b66c8
	ctx.lr = 0x823B4504;
	sub_823B66C8(ctx, base);
	// 823B4504: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4508: 41820070  beq 0x823b4578
	if ctx.cr[0].eq {
	pc = 0x823B4578; continue 'dispatch;
	}
	// 823B450C: A3FD000A  lhz r31, 0xa(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(10 as u32) ) } as u64;
	// 823B4510: 387D0030  addi r3, r29, 0x30
	ctx.r[3].s64 = ctx.r[29].s64 + 48;
	// 823B4514: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823B4518: 419A002C  beq cr6, 0x823b4544
	if ctx.cr[6].eq {
	pc = 0x823B4544; continue 'dispatch;
	}
	// 823B451C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823B4520: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x823B4524; continue 'dispatch;
            }
            0x823B4524 => {
    //   block [0x823B4524..0x823B4544)
	// 823B4524: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 823B4528: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 823B452C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B4530: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 823B4534: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 823B4538: 7D2B412E  stwx r9, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u32) };
	// 823B453C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823B4540: 4082FFE4  bne 0x823b4524
	if !ctx.cr[0].eq {
	pc = 0x823B4524; continue 'dispatch;
	}
	pc = 0x823B4544; continue 'dispatch;
            }
            0x823B4544 => {
    //   block [0x823B4544..0x823B4550)
	// 823B4544: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823B4548: 419A0030  beq cr6, 0x823b4578
	if ctx.cr[6].eq {
	pc = 0x823B4578; continue 'dispatch;
	}
	// 823B454C: 3BBC0010  addi r29, r28, 0x10
	ctx.r[29].s64 = ctx.r[28].s64 + 16;
	pc = 0x823B4550; continue 'dispatch;
            }
            0x823B4550 => {
    //   block [0x823B4550..0x823B4578)
	// 823B4550: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 823B4554: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 823B4558: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 823B455C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 823B4560: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 823B4564: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 823B4568: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823B456C: 4800221D  bl 0x823b6788
	ctx.lr = 0x823B4570;
	sub_823B6788(ctx, base);
	// 823B4570: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823B4574: 4082FFDC  bne 0x823b4550
	if !ctx.cr[0].eq {
	pc = 0x823B4550; continue 'dispatch;
	}
	pc = 0x823B4578; continue 'dispatch;
            }
            0x823B4578 => {
    //   block [0x823B4578..0x823B4580)
	// 823B4578: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 823B457C: 48180B84  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823B4580 size=268
    let mut pc: u32 = 0x823B4580;
    'dispatch: loop {
        match pc {
            0x823B4580 => {
    //   block [0x823B4580..0x823B4600)
	// 823B4580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B4584: 48180B2D  bl 0x825350b0
	ctx.lr = 0x823B4588;
	sub_82535080(ctx, base);
	// 823B4588: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 823B458C: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B4590: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 823B4594: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B4598: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823B459C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 823B45A0: 656B8000  oris r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 2147483648;
	// 823B45A4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823B45A8: 656B4000  oris r11, r11, 0x4000
	ctx.r[11].u64 = ctx.r[11].u64 | 1073741824;
	// 823B45AC: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 823B45B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823B45B4: 656B2000  oris r11, r11, 0x2000
	ctx.r[11].u64 = ctx.r[11].u64 | 536870912;
	// 823B45B8: 83FC000C  lwz r31, 0xc(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B45BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B45C0: 656B1000  oris r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 268435456;
	// 823B45C4: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 823B45C8: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 823B45CC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 823B45D0: 480020F9  bl 0x823b66c8
	ctx.lr = 0x823B45D4;
	sub_823B66C8(ctx, base);
	// 823B45D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B45D8: 418200A8  beq 0x823b4680
	if ctx.cr[0].eq {
	pc = 0x823B4680; continue 'dispatch;
	}
	// 823B45DC: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823B45E0: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	// 823B45E4: 396B1B00  addi r11, r11, 0x1b00
	ctx.r[11].s64 = ctx.r[11].s64 + 6912;
	// 823B45E8: F94B0150  std r10, 0x150(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(336 as u32), ctx.r[10].u64 ) };
	// 823B45EC: A17F000A  lhz r11, 0xa(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 823B45F0: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 823B45F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B45F8: 41820088  beq 0x823b4680
	if ctx.cr[0].eq {
	pc = 0x823B4680; continue 'dispatch;
	}
	// 823B45FC: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	pc = 0x823B4600; continue 'dispatch;
            }
            0x823B4600 => {
    //   block [0x823B4600..0x823B4628)
	// 823B4600: A17F0026  lhz r11, 0x26(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 823B4604: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B4608: 4082006C  bne 0x823b4674
	if !ctx.cr[0].eq {
	pc = 0x823B4674; continue 'dispatch;
	}
	// 823B460C: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B4610: 40820018  bne 0x823b4628
	if !ctx.cr[0].eq {
	pc = 0x823B4628; continue 'dispatch;
	}
	// 823B4614: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823B4618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B461C: 480020AD  bl 0x823b66c8
	ctx.lr = 0x823B4620;
	sub_823B66C8(ctx, base);
	// 823B4620: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4624: 41820050  beq 0x823b4674
	if ctx.cr[0].eq {
	pc = 0x823B4674; continue 'dispatch;
	}
	pc = 0x823B4628; continue 'dispatch;
            }
            0x823B4628 => {
    //   block [0x823B4628..0x823B4658)
	// 823B4628: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 823B462C: A3DF002A  lhz r30, 0x2a(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(42 as u32) ) } as u64;
	// 823B4630: C01F001C  lfs f0, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B4634: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823B4638: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823B463C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4640: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823B4644: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823B4648: 796B07A4  rldicr r11, r11, 0, 0x3e
	ctx.r[11].u64 = (ctx.r[11].u64).rotate_left(0) & 0xFFFFFFFFFFFFFFFE;
	// 823B464C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823B4650: 41820024  beq 0x823b4674
	if ctx.cr[0].eq {
	pc = 0x823B4674; continue 'dispatch;
	}
	// 823B4654: 3BBC0010  addi r29, r28, 0x10
	ctx.r[29].s64 = ctx.r[28].s64 + 16;
	pc = 0x823B4658; continue 'dispatch;
            }
            0x823B4658 => {
    //   block [0x823B4658..0x823B4674)
	// 823B4658: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 823B465C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823B4660: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823B4664: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823B4668: 48006929  bl 0x823baf90
	ctx.lr = 0x823B466C;
	sub_823BAF90(ctx, base);
	// 823B466C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823B4670: 4082FFE8  bne 0x823b4658
	if !ctx.cr[0].eq {
	pc = 0x823B4658; continue 'dispatch;
	}
	pc = 0x823B4674; continue 'dispatch;
            }
            0x823B4674 => {
    //   block [0x823B4674..0x823B4680)
	// 823B4674: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 823B4678: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823B467C: 4082FF84  bne 0x823b4600
	if !ctx.cr[0].eq {
	pc = 0x823B4600; continue 'dispatch;
	}
	pc = 0x823B4680; continue 'dispatch;
            }
            0x823B4680 => {
    //   block [0x823B4680..0x823B468C)
	// 823B4680: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 823B4684: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 823B4688: 48180A78  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B46B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B46B0 size=124
    let mut pc: u32 = 0x823B46B0;
    'dispatch: loop {
        match pc {
            0x823B46B0 => {
    //   block [0x823B46B0..0x823B46E8)
	// 823B46B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B46B4: 48180A05  bl 0x825350b8
	ctx.lr = 0x823B46B8;
	sub_82535080(ctx, base);
	// 823B46B8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B46BC: 8383000C  lwz r28, 0xc(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B46C0: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 823B46C4: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 823B46C8: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 823B46CC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 823B46D0: 419A0038  beq cr6, 0x823b4708
	if ctx.cr[6].eq {
	pc = 0x823B4708; continue 'dispatch;
	}
	// 823B46D4: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 823B46D8: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 823B46DC: 7FCB4050  subf r30, r11, r8
	ctx.r[30].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 823B46E0: 7FAB3850  subf r29, r11, r7
	ctx.r[29].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 823B46E4: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	pc = 0x823B46E8; continue 'dispatch;
            }
            0x823B46E8 => {
    //   block [0x823B46E8..0x823B4708)
	// 823B46E8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B46EC: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823B46F0: 38FF0010  addi r7, r31, 0x10
	ctx.r[7].s64 = ctx.r[31].s64 + 16;
	// 823B46F4: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B46F8: 7CFD592E  stwx r7, r29, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 823B46FC: 7D1E592E  stwx r8, r30, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	// 823B4700: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823B4704: 4082FFE4  bne 0x823b46e8
	if !ctx.cr[0].eq {
	pc = 0x823B46E8; continue 'dispatch;
	}
	pc = 0x823B4708; continue 'dispatch;
            }
            0x823B4708 => {
    //   block [0x823B4708..0x823B472C)
	// 823B4708: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 823B470C: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 823B4710: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 823B4714: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 823B4718: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 823B471C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823B4720: 48002991  bl 0x823b70b0
	ctx.lr = 0x823B4724;
	sub_823B70B0(ctx, base);
	// 823B4724: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823B4728: 481809E0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B4750 size=76
    let mut pc: u32 = 0x823B4750;
    'dispatch: loop {
        match pc {
            0x823B4750 => {
    //   block [0x823B4750..0x823B4778)
	// 823B4750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B4754: 48180965  bl 0x825350b8
	ctx.lr = 0x823B4758;
	sub_82535080(ctx, base);
	// 823B4758: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B475C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B4760: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823B4764: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 823B4768: 3BEB0030  addi r31, r11, 0x30
	ctx.r[31].s64 = ctx.r[11].s64 + 48;
	// 823B476C: A3CB000A  lhz r30, 0xa(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(10 as u32) ) } as u64;
	// 823B4770: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4774: 41820020  beq 0x823b4794
	if ctx.cr[0].eq {
	pc = 0x823B4794; continue 'dispatch;
	}
	pc = 0x823B4778; continue 'dispatch;
            }
            0x823B4778 => {
    //   block [0x823B4778..0x823B4794)
	// 823B4778: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823B477C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B4780: 7FA903A6  mtctr r29
	ctx.ctr.u64 = ctx.r[29].u64;
	// 823B4784: 4E800421  bctrl
	ctx.lr = 0x823B4788;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823B4788: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823B478C: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 823B4790: 4082FFE8  bne 0x823b4778
	if !ctx.cr[0].eq {
	pc = 0x823B4778; continue 'dispatch;
	}
            }
            0x823B4794 => {
    //   block [0x823B4794..0x823B479C)
	// 823B4794: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823B4798: 48180970  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B47A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B47A0 size=112
    let mut pc: u32 = 0x823B47A0;
    'dispatch: loop {
        match pc {
            0x823B47A0 => {
    //   block [0x823B47A0..0x823B47D0)
	// 823B47A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B47A4: 4818090D  bl 0x825350b0
	ctx.lr = 0x823B47A8;
	sub_82535080(ctx, base);
	// 823B47A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B47AC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B47B0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823B47B4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 823B47B8: A14B000A  lhz r10, 0xa(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(10 as u32) ) } as u64;
	// 823B47BC: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 823B47C0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B47C4: 41820044  beq 0x823b4808
	if ctx.cr[0].eq {
	pc = 0x823B4808; continue 'dispatch;
	}
	// 823B47C8: 3BAB002C  addi r29, r11, 0x2c
	ctx.r[29].s64 = ctx.r[11].s64 + 44;
	// 823B47CC: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	pc = 0x823B47D0; continue 'dispatch;
            }
            0x823B47D0 => {
    //   block [0x823B47D0..0x823B47E0)
	// 823B47D0: A3FDFFFE  lhz r31, -2(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(-2 as u32) ) } as u64;
	// 823B47D4: 83DD0000  lwz r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B47D8: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B47DC: 41820020  beq 0x823b47fc
	if ctx.cr[0].eq {
	pc = 0x823B47FC; continue 'dispatch;
	}
	pc = 0x823B47E0; continue 'dispatch;
            }
            0x823B47E0 => {
    //   block [0x823B47E0..0x823B47FC)
	// 823B47E0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 823B47E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B47E8: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 823B47EC: 4E800421  bctrl
	ctx.lr = 0x823B47F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823B47F0: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823B47F4: 3BDE0030  addi r30, r30, 0x30
	ctx.r[30].s64 = ctx.r[30].s64 + 48;
	// 823B47F8: 4082FFE8  bne 0x823b47e0
	if !ctx.cr[0].eq {
	pc = 0x823B47E0; continue 'dispatch;
	}
            }
            0x823B47FC => {
    //   block [0x823B47FC..0x823B4808)
	// 823B47FC: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823B4800: 3BBD0030  addi r29, r29, 0x30
	ctx.r[29].s64 = ctx.r[29].s64 + 48;
	// 823B4804: 4082FFCC  bne 0x823b47d0
	if !ctx.cr[0].eq {
	pc = 0x823B47D0; continue 'dispatch;
	}
	pc = 0x823B4808; continue 'dispatch;
            }
            0x823B4808 => {
    //   block [0x823B4808..0x823B4810)
	// 823B4808: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823B480C: 481808F4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B4810 size=116
    let mut pc: u32 = 0x823B4810;
    'dispatch: loop {
        match pc {
            0x823B4810 => {
    //   block [0x823B4810..0x823B4840)
	// 823B4810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B4814: 4818089D  bl 0x825350b0
	ctx.lr = 0x823B4818;
	sub_82535080(ctx, base);
	// 823B4818: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B481C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B4820: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823B4824: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 823B4828: A14B000A  lhz r10, 0xa(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(10 as u32) ) } as u64;
	// 823B482C: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 823B4830: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4834: 41820048  beq 0x823b487c
	if ctx.cr[0].eq {
	pc = 0x823B487C; continue 'dispatch;
	}
	// 823B4838: 3BAB002C  addi r29, r11, 0x2c
	ctx.r[29].s64 = ctx.r[11].s64 + 44;
	// 823B483C: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	pc = 0x823B4840; continue 'dispatch;
            }
            0x823B4840 => {
    //   block [0x823B4840..0x823B4854)
	// 823B4840: A3FDFFFE  lhz r31, -2(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(-2 as u32) ) } as u64;
	// 823B4844: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B4848: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B484C: 41820024  beq 0x823b4870
	if ctx.cr[0].eq {
	pc = 0x823B4870; continue 'dispatch;
	}
	// 823B4850: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	pc = 0x823B4854; continue 'dispatch;
            }
            0x823B4854 => {
    //   block [0x823B4854..0x823B4870)
	// 823B4854: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B4858: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 823B485C: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 823B4860: 4E800421  bctrl
	ctx.lr = 0x823B4864;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823B4864: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823B4868: 3BDE0030  addi r30, r30, 0x30
	ctx.r[30].s64 = ctx.r[30].s64 + 48;
	// 823B486C: 4082FFE8  bne 0x823b4854
	if !ctx.cr[0].eq {
	pc = 0x823B4854; continue 'dispatch;
	}
            }
            0x823B4870 => {
    //   block [0x823B4870..0x823B487C)
	// 823B4870: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823B4874: 3BBD0030  addi r29, r29, 0x30
	ctx.r[29].s64 = ctx.r[29].s64 + 48;
	// 823B4878: 4082FFC8  bne 0x823b4840
	if !ctx.cr[0].eq {
	pc = 0x823B4840; continue 'dispatch;
	}
	pc = 0x823B487C; continue 'dispatch;
            }
            0x823B487C => {
    //   block [0x823B487C..0x823B4884)
	// 823B487C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823B4880: 48180880  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B4888 size=240
    let mut pc: u32 = 0x823B4888;
    'dispatch: loop {
        match pc {
            0x823B4888 => {
    //   block [0x823B4888..0x823B48C8)
	// 823B4888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B488C: 4818082D  bl 0x825350b8
	ctx.lr = 0x823B4890;
	sub_82535080(ctx, base);
	// 823B4890: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B4894: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823B4898: A17C0008  lhz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B489C: 556B0463  rlwinm. r11, r11, 0, 0x11, 0x11
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B48A0: 408200CC  bne 0x823b496c
	if !ctx.cr[0].eq {
	pc = 0x823B496C; continue 'dispatch;
	}
	// 823B48A4: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823B48A8: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B48AC: 396B9180  addi r11, r11, -0x6e80
	ctx.r[11].s64 = ctx.r[11].s64 + -28288;
	// 823B48B0: 386B0080  addi r3, r11, 0x80
	ctx.r[3].s64 = ctx.r[11].s64 + 128;
	// 823B48B4: 4BFF4AFD  bl 0x823a93b0
	ctx.lr = 0x823B48B8;
	sub_823A93B0(ctx, base);
	// 823B48B8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823B48BC: 4082000C  bne 0x823b48c8
	if !ctx.cr[0].eq {
	pc = 0x823B48C8; continue 'dispatch;
	}
	// 823B48C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B48C4: 480000AC  b 0x823b4970
	pc = 0x823B4970; continue 'dispatch;
            }
            0x823B48C8 => {
    //   block [0x823B48C8..0x823B48F4)
	// 823B48C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B48CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B48D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B48D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B48D8: 4E800421  bctrl
	ctx.lr = 0x823B48DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823B48DC: A17C000A  lhz r11, 0xa(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(10 as u32) ) } as u64;
	// 823B48E0: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823B48E4: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823B48E8: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 823B48EC: 37EB0020  addic. r31, r11, 0x20
	ctx.xer.ca = (ctx.r[11].u32 > (!(32 as u32)));
	ctx.r[31].s64 = ctx.r[11].s64 + 32;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823B48F0: 41820070  beq 0x823b4960
	if ctx.cr[0].eq {
	pc = 0x823B4960; continue 'dispatch;
	}
            }
            0x823B48F4 => {
    //   block [0x823B48F4..0x823B4944)
	// 823B48F4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B48F8: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B48FC: 41820048  beq 0x823b4944
	if ctx.cr[0].eq {
	pc = 0x823B4944; continue 'dispatch;
	}
	// 823B4900: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B4904: 3BBF000C  addi r29, r31, 0xc
	ctx.r[29].s64 = ctx.r[31].s64 + 12;
	// 823B4908: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B490C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823B4910: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 823B4914: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B4918: 4E800421  bctrl
	ctx.lr = 0x823B491C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823B491C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B4920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B4924: 409A0020  bne cr6, 0x823b4944
	if !ctx.cr[6].eq {
	pc = 0x823B4944; continue 'dispatch;
	}
	// 823B4928: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B492C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823B4930: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B4934: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B4938: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 823B493C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B4940: 4E800421  bctrl
	ctx.lr = 0x823B4944;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823B4944 => {
    //   block [0x823B4944..0x823B4958)
	// 823B4944: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B4948: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B494C: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823B4950: 40820008  bne 0x823b4958
	if !ctx.cr[0].eq {
	pc = 0x823B4958; continue 'dispatch;
	}
	// 823B4954: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x823B4958; continue 'dispatch;
            }
            0x823B4958 => {
    //   block [0x823B4958..0x823B4960)
	// 823B4958: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823B495C: 409AFF98  bne cr6, 0x823b48f4
	if !ctx.cr[6].eq {
	pc = 0x823B48F4; continue 'dispatch;
	}
	pc = 0x823B4960; continue 'dispatch;
            }
            0x823B4960 => {
    //   block [0x823B4960..0x823B496C)
	// 823B4960: A17C0008  lhz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B4964: 616B4000  ori r11, r11, 0x4000
	ctx.r[11].u64 = ctx.r[11].u64 | 16384;
	// 823B4968: B17C0008  sth r11, 8(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u16 ) };
	pc = 0x823B496C; continue 'dispatch;
            }
            0x823B496C => {
    //   block [0x823B496C..0x823B4970)
	// 823B496C: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823B4970; continue 'dispatch;
            }
            0x823B4970 => {
    //   block [0x823B4970..0x823B4978)
	// 823B4970: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823B4974: 48180794  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823B4978 size=168
    let mut pc: u32 = 0x823B4978;
    'dispatch: loop {
        match pc {
            0x823B4978 => {
    //   block [0x823B4978..0x823B49C0)
	// 823B4978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B497C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B4980: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B4984: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B4988: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B498C: A1630008  lhz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B4990: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823B4994: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823B4998: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B499C: 4182005C  beq 0x823b49f8
	if ctx.cr[0].eq {
	pc = 0x823B49F8; continue 'dispatch;
	}
	// 823B49A0: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B49A4: 41820024  beq 0x823b49c8
	if ctx.cr[0].eq {
	pc = 0x823B49C8; continue 'dispatch;
	}
	// 823B49A8: 556B0739  rlwinm. r11, r11, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B49AC: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B49B0: 386BD180  addi r3, r11, -0x2e80
	ctx.r[3].s64 = ctx.r[11].s64 + -11904;
	// 823B49B4: 4182000C  beq 0x823b49c0
	if ctx.cr[0].eq {
	pc = 0x823B49C0; continue 'dispatch;
	}
	// 823B49B8: 4BFEB6E1  bl 0x823a0098
	ctx.lr = 0x823B49BC;
	sub_823A0098(ctx, base);
	// 823B49BC: 4800004C  b 0x823b4a08
	pc = 0x823B4A08; continue 'dispatch;
            }
            0x823B49C0 => {
    //   block [0x823B49C0..0x823B49C8)
	// 823B49C0: 4BFEB671  bl 0x823a0030
	ctx.lr = 0x823B49C4;
	sub_823A0030(ctx, base);
	// 823B49C4: 48000044  b 0x823b4a08
	pc = 0x823B4A08; continue 'dispatch;
            }
            0x823B49C8 => {
    //   block [0x823B49C8..0x823B49E0)
	// 823B49C8: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 823B49CC: 796B07E0  clrldi r11, r11, 0x3f
	ctx.r[11].u64 = ctx.r[11].u64 & 0x0000000000000001u64;
	// 823B49D0: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 823B49D4: 409A000C  bne cr6, 0x823b49e0
	if !ctx.cr[6].eq {
	pc = 0x823B49E0; continue 'dispatch;
	}
	// 823B49D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B49DC: 4BFF8C65  bl 0x823ad640
	ctx.lr = 0x823B49E0;
	sub_823AD640(ctx, base);
	pc = 0x823B49E0; continue 'dispatch;
            }
            0x823B49E0 => {
    //   block [0x823B49E0..0x823B49F8)
	// 823B49E0: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B49E4: C03E0008  lfs f1, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823B49E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823B49EC: 386BD180  addi r3, r11, -0x2e80
	ctx.r[3].s64 = ctx.r[11].s64 + -11904;
	// 823B49F0: 4BFEB5B9  bl 0x8239ffa8
	ctx.lr = 0x823B49F4;
	sub_8239FFA8(ctx, base);
	// 823B49F4: 48000014  b 0x823b4a08
	pc = 0x823B4A08; continue 'dispatch;
            }
            0x823B49F8 => {
    //   block [0x823B49F8..0x823B4A08)
	// 823B49F8: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B49FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823B4A00: 386BD180  addi r3, r11, -0x2e80
	ctx.r[3].s64 = ctx.r[11].s64 + -11904;
	// 823B4A04: 4BFEB53D  bl 0x8239ff40
	ctx.lr = 0x823B4A08;
	sub_8239FF40(ctx, base);
	pc = 0x823B4A08; continue 'dispatch;
            }
            0x823B4A08 => {
    //   block [0x823B4A08..0x823B4A20)
	// 823B4A08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B4A0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B4A10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B4A14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B4A18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B4A1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B4A20 size=180
    let mut pc: u32 = 0x823B4A20;
    'dispatch: loop {
        match pc {
            0x823B4A20 => {
    //   block [0x823B4A20..0x823B4A64)
	// 823B4A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B4A24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B4A28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823B4A2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B4A30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B4A34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B4A38: A17E000A  lhz r11, 0xa(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(10 as u32) ) } as u64;
	// 823B4A3C: 556B0463  rlwinm. r11, r11, 0, 0x11, 0x11
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B4A40: 40820078  bne 0x823b4ab8
	if !ctx.cr[0].eq {
	pc = 0x823B4AB8; continue 'dispatch;
	}
	// 823B4A44: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B4A48: 3D401000  lis r10, 0x1000
	ctx.r[10].s64 = 268435456;
	// 823B4A4C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823B4A50: 40980028  bge cr6, 0x823b4a78
	if !ctx.cr[6].lt {
	pc = 0x823B4A78; continue 'dispatch;
	}
	// 823B4A54: 7C8B2214  add r4, r11, r4
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 823B4A58: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823B4A5C: 396BF080  addi r11, r11, -0xf80
	ctx.r[11].s64 = ctx.r[11].s64 + -3968;
	// 823B4A60: 386B0080  addi r3, r11, 0x80
	ctx.r[3].s64 = ctx.r[11].s64 + 128;
	pc = 0x823B4A64; continue 'dispatch;
            }
            0x823B4A64 => {
    //   block [0x823B4A64..0x823B4A78)
	// 823B4A64: 4BFF405D  bl 0x823a8ac0
	ctx.lr = 0x823B4A68;
	sub_823A8AC0(ctx, base);
	// 823B4A68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823B4A6C: 40820020  bne 0x823b4a8c
	if !ctx.cr[0].eq {
	pc = 0x823B4A8C; continue 'dispatch;
	}
	// 823B4A70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B4A74: 48000048  b 0x823b4abc
	pc = 0x823B4ABC; continue 'dispatch;
            }
            0x823B4A78 => {
    //   block [0x823B4A78..0x823B4A8C)
	// 823B4A78: 3D408310  lis r10, -0x7cf0
	ctx.r[10].s64 = -2096103424;
	// 823B4A7C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 823B4A80: 394AF080  addi r10, r10, -0xf80
	ctx.r[10].s64 = ctx.r[10].s64 + -3968;
	// 823B4A84: 386A0080  addi r3, r10, 0x80
	ctx.r[3].s64 = ctx.r[10].s64 + 128;
	// 823B4A88: 4BFFFFDC  b 0x823b4a64
	pc = 0x823B4A64; continue 'dispatch;
            }
            0x823B4A8C => {
    //   block [0x823B4A8C..0x823B4AB8)
	// 823B4A8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B4A90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B4A94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B4A98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B4A9C: 4E800421  bctrl
	ctx.lr = 0x823B4AA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823B4AA0: A17E000A  lhz r11, 0xa(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(10 as u32) ) } as u64;
	// 823B4AA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B4AA8: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823B4AAC: 616B4000  ori r11, r11, 0x4000
	ctx.r[11].u64 = ctx.r[11].u64 | 16384;
	// 823B4AB0: B17E000A  sth r11, 0xa(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(10 as u32), ctx.r[11].u16 ) };
	// 823B4AB4: 48000008  b 0x823b4abc
	pc = 0x823B4ABC; continue 'dispatch;
            }
            0x823B4AB8 => {
    //   block [0x823B4AB8..0x823B4ABC)
	// 823B4AB8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823B4ABC; continue 'dispatch;
            }
            0x823B4ABC => {
    //   block [0x823B4ABC..0x823B4AD4)
	// 823B4ABC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B4AC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B4AC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B4AC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B4ACC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B4AD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B4AD8 size=16
    let mut pc: u32 = 0x823B4AD8;
    'dispatch: loop {
        match pc {
            0x823B4AD8 => {
    //   block [0x823B4AD8..0x823B4AE8)
	// 823B4AD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B4ADC: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 823B4AE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B4AE4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B4AE8 size=16
    let mut pc: u32 = 0x823B4AE8;
    'dispatch: loop {
        match pc {
            0x823B4AE8 => {
    //   block [0x823B4AE8..0x823B4AF8)
	// 823B4AE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B4AEC: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 823B4AF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B4AF4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B4AF8 size=16
    let mut pc: u32 = 0x823B4AF8;
    'dispatch: loop {
        match pc {
            0x823B4AF8 => {
    //   block [0x823B4AF8..0x823B4B08)
	// 823B4AF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B4AFC: 816B0074  lwz r11, 0x74(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 823B4B00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B4B04: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B4B08 size=16
    let mut pc: u32 = 0x823B4B08;
    'dispatch: loop {
        match pc {
            0x823B4B08 => {
    //   block [0x823B4B08..0x823B4B18)
	// 823B4B08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B4B0C: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 823B4B10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B4B14: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B4B18 size=16
    let mut pc: u32 = 0x823B4B18;
    'dispatch: loop {
        match pc {
            0x823B4B18 => {
    //   block [0x823B4B18..0x823B4B28)
	// 823B4B18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B4B1C: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 823B4B20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B4B24: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B4B28 size=16
    let mut pc: u32 = 0x823B4B28;
    'dispatch: loop {
        match pc {
            0x823B4B28 => {
    //   block [0x823B4B28..0x823B4B38)
	// 823B4B28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B4B2C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 823B4B30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B4B34: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B4B38 size=16
    let mut pc: u32 = 0x823B4B38;
    'dispatch: loop {
        match pc {
            0x823B4B38 => {
    //   block [0x823B4B38..0x823B4B48)
	// 823B4B38: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B4B3C: 396B19C0  addi r11, r11, 0x19c0
	ctx.r[11].s64 = ctx.r[11].s64 + 6592;
	// 823B4B40: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B4B44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B4B48 size=432
    let mut pc: u32 = 0x823B4B48;
    'dispatch: loop {
        match pc {
            0x823B4B48 => {
    //   block [0x823B4B48..0x823B4B7C)
	// 823B4B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B4B4C: 48180559  bl 0x825350a4
	ctx.lr = 0x823B4B50;
	sub_82535080(ctx, base);
	// 823B4B50: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B4B54: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 823B4B58: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 823B4B5C: 3B990020  addi r28, r25, 0x20
	ctx.r[28].s64 = ctx.r[25].s64 + 32;
	// 823B4B60: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823B4B64: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823B4B68: A379000A  lhz r27, 0xa(r25)
	ctx.r[27].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[25].u32.wrapping_add(10 as u32) ) } as u64;
	// 823B4B6C: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 823B4B70: 281B0000  cmplwi r27, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4B74: 41820070  beq 0x823b4be4
	if ctx.cr[0].eq {
	pc = 0x823B4BE4; continue 'dispatch;
	}
	// 823B4B78: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x823B4B7C; continue 'dispatch;
            }
            0x823B4B7C => {
    //   block [0x823B4B7C..0x823B4B94)
	// 823B4B7C: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B4B80: 38E90020  addi r7, r9, 0x20
	ctx.r[7].s64 = ctx.r[9].s64 + 32;
	// 823B4B84: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 823B4B88: 7FAAEA14  add r29, r10, r29
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 823B4B8C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4B90: 41820020  beq 0x823b4bb0
	if ctx.cr[0].eq {
	pc = 0x823B4BB0; continue 'dispatch;
	}
	pc = 0x823B4B94; continue 'dispatch;
            }
            0x823B4B94 => {
    //   block [0x823B4B94..0x823B4BB0)
	// 823B4B94: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B4B98: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B4B9C: 38A80001  addi r5, r8, 1
	ctx.r[5].s64 = ctx.r[8].s64 + 1;
	// 823B4BA0: 7FC8F214  add r30, r8, r30
	ctx.r[30].u64 = ctx.r[8].u64 + ctx.r[30].u64;
	// 823B4BA4: 54A82834  slwi r8, r5, 5
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823B4BA8: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 823B4BAC: 4082FFE8  bne 0x823b4b94
	if !ctx.cr[0].eq {
	pc = 0x823B4B94; continue 'dispatch;
	}
	pc = 0x823B4BB0; continue 'dispatch;
            }
            0x823B4BB0 => {
    //   block [0x823B4BB0..0x823B4BC0)
	// 823B4BB0: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B4BB4: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 823B4BB8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4BBC: 4182001C  beq 0x823b4bd8
	if ctx.cr[0].eq {
	pc = 0x823B4BD8; continue 'dispatch;
	}
	pc = 0x823B4BC0; continue 'dispatch;
            }
            0x823B4BC0 => {
    //   block [0x823B4BC0..0x823B4BD8)
	// 823B4BC0: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B4BC4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B4BC8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823B4BCC: 55292834  slwi r9, r9, 5
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B4BD0: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823B4BD4: 4082FFEC  bne 0x823b4bc0
	if !ctx.cr[0].eq {
	pc = 0x823B4BC0; continue 'dispatch;
	}
	pc = 0x823B4BD8; continue 'dispatch;
            }
            0x823B4BD8 => {
    //   block [0x823B4BD8..0x823B4BE4)
	// 823B4BD8: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 823B4BDC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 823B4BE0: 4082FF9C  bne 0x823b4b7c
	if !ctx.cr[0].eq {
	pc = 0x823B4B7C; continue 'dispatch;
	}
	pc = 0x823B4BE4; continue 'dispatch;
            }
            0x823B4BE4 => {
    //   block [0x823B4BE4..0x823B4C44)
	// 823B4BE4: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B4BE8: 3BEBFE00  addi r31, r11, -0x200
	ctx.r[31].s64 = ctx.r[11].s64 + -512;
	// 823B4BEC: 387F004C  addi r3, r31, 0x4c
	ctx.r[3].s64 = ctx.r[31].s64 + 76;
	// 823B4BF0: 4835866D  bl 0x8270d25c
	ctx.lr = 0x823B4BF4;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B4BF4: 7D7BF214  add r11, r27, r30
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[30].u64;
	// 823B4BF8: 1D5D0098  mulli r10, r29, 0x98
	ctx.r[10].s32 = ((ctx.r[29].s32 as i64 * 152 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823B4BFC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823B4C00: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B4C04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B4C08: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B4C0C: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823B4C10: 4BFEADC9  bl 0x8239f9d8
	ctx.lr = 0x823B4C14;
	sub_8239F9D8(ctx, base);
	// 823B4C14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823B4C18: 387F004C  addi r3, r31, 0x4c
	ctx.r[3].s64 = ctx.r[31].s64 + 76;
	// 823B4C1C: 48358651  bl 0x8270d26c
	ctx.lr = 0x823B4C20;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B4C20: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 823B4C24: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 823B4C28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B4C2C: 4817FF25  bl 0x82534b50
	ctx.lr = 0x823B4C30;
	sub_82534B50(ctx, base);
	// 823B4C30: A17D000A  lhz r11, 0xa(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(10 as u32) ) } as u64;
	// 823B4C34: 3BDD0020  addi r30, r29, 0x20
	ctx.r[30].s64 = ctx.r[29].s64 + 32;
	// 823B4C38: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4C3C: 418200B0  beq 0x823b4cec
	if ctx.cr[0].eq {
	pc = 0x823B4CEC; continue 'dispatch;
	}
	// 823B4C40: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	pc = 0x823B4C44; continue 'dispatch;
            }
            0x823B4C44 => {
    //   block [0x823B4C44..0x823B4C7C)
	// 823B4C44: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 823B4C48: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823B4C4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823B4C50: 4817FF01  bl 0x82534b50
	ctx.lr = 0x823B4C54;
	sub_82534B50(ctx, base);
	// 823B4C54: 3B5C0020  addi r26, r28, 0x20
	ctx.r[26].s64 = ctx.r[28].s64 + 32;
	// 823B4C58: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 823B4C5C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B4C60: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 823B4C64: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 823B4C68: 2B0B00C0  cmplwi cr6, r11, 0xc0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 192 as u32, &mut ctx.xer);
	// 823B4C6C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B4C70: 4198000C  blt cr6, 0x823b4c7c
	if ctx.cr[6].lt {
	pc = 0x823B4C7C; continue 'dispatch;
	}
	// 823B4C74: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 823B4C78: 48000008  b 0x823b4c80
	pc = 0x823B4C80; continue 'dispatch;
            }
            0x823B4C7C => {
    //   block [0x823B4C7C..0x823B4C80)
	// 823B4C7C: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x823B4C80; continue 'dispatch;
            }
            0x823B4C80 => {
    //   block [0x823B4C80..0x823B4C94)
	// 823B4C80: 837E0008  lwz r27, 8(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B4C84: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	// 823B4C88: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B4C8C: 281B0000  cmplwi r27, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4C90: 41820028  beq 0x823b4cb8
	if ctx.cr[0].eq {
	pc = 0x823B4CB8; continue 'dispatch;
	}
	pc = 0x823B4C94; continue 'dispatch;
            }
            0x823B4C94 => {
    //   block [0x823B4C94..0x823B4CB8)
	// 823B4C94: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823B4C98: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 823B4C9C: 48004D7D  bl 0x823b9a18
	ctx.lr = 0x823B4CA0;
	sub_823B9A18(ctx, base);
	// 823B4CA0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B4CA4: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 823B4CA8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823B4CAC: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B4CB0: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823B4CB4: 4082FFE0  bne 0x823b4c94
	if !ctx.cr[0].eq {
	pc = 0x823B4C94; continue 'dispatch;
	}
	pc = 0x823B4CB8; continue 'dispatch;
            }
            0x823B4CB8 => {
    //   block [0x823B4CB8..0x823B4CCC)
	// 823B4CB8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B4CBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B4CC0: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 823B4CC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4CC8: 4182001C  beq 0x823b4ce4
	if ctx.cr[0].eq {
	pc = 0x823B4CE4; continue 'dispatch;
	}
	pc = 0x823B4CCC; continue 'dispatch;
            }
            0x823B4CCC => {
    //   block [0x823B4CCC..0x823B4CE4)
	// 823B4CCC: 815C0014  lwz r10, 0x14(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B4CD0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B4CD4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823B4CD8: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823B4CDC: 7F8AE214  add r28, r10, r28
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 823B4CE0: 4082FFEC  bne 0x823b4ccc
	if !ctx.cr[0].eq {
	pc = 0x823B4CCC; continue 'dispatch;
	}
	pc = 0x823B4CE4; continue 'dispatch;
            }
            0x823B4CE4 => {
    //   block [0x823B4CE4..0x823B4CEC)
	// 823B4CE4: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 823B4CE8: 4082FF5C  bne 0x823b4c44
	if !ctx.cr[0].eq {
	pc = 0x823B4C44; continue 'dispatch;
	}
	pc = 0x823B4CEC; continue 'dispatch;
            }
            0x823B4CEC => {
    //   block [0x823B4CEC..0x823B4CF8)
	// 823B4CEC: 93B7000C  stw r29, 0xc(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 823B4CF0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823B4CF4: 48180400  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B4CF8 size=224
    let mut pc: u32 = 0x823B4CF8;
    'dispatch: loop {
        match pc {
            0x823B4CF8 => {
    //   block [0x823B4CF8..0x823B4D2C)
	// 823B4CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B4CFC: 481803B1  bl 0x825350ac
	ctx.lr = 0x823B4D00;
	sub_82535080(ctx, base);
	// 823B4D00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B4D04: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 823B4D08: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B4D0C: 3BEB0020  addi r31, r11, 0x20
	ctx.r[31].s64 = ctx.r[11].s64 + 32;
	// 823B4D10: A14B000A  lhz r10, 0xa(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(10 as u32) ) } as u64;
	// 823B4D14: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B4D18: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4D1C: 3BABFE00  addi r29, r11, -0x200
	ctx.r[29].s64 = ctx.r[11].s64 + -512;
	// 823B4D20: 41820090  beq 0x823b4db0
	if ctx.cr[0].eq {
	pc = 0x823B4DB0; continue 'dispatch;
	}
	// 823B4D24: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 823B4D28: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x823B4D2C; continue 'dispatch;
            }
            0x823B4D2C => {
    //   block [0x823B4D2C..0x823B4D40)
	// 823B4D2C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B4D30: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 823B4D34: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4D38: 41820070  beq 0x823b4da8
	if ctx.cr[0].eq {
	pc = 0x823B4DA8; continue 'dispatch;
	}
	// 823B4D3C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	pc = 0x823B4D40; continue 'dispatch;
            }
            0x823B4D40 => {
    //   block [0x823B4D40..0x823B4D7C)
	// 823B4D40: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 823B4D44: 4BFEBCC5  bl 0x823a0a08
	ctx.lr = 0x823B4D48;
	sub_823A0A08(ctx, base);
	// 823B4D48: A17F005C  lhz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 823B4D4C: 937F0024  stw r27, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[27].u32 ) };
	// 823B4D50: 2B0B0040  cmplwi cr6, r11, 0x40
	ctx.cr[6].compare_u32(ctx.r[11].u32, 64 as u32, &mut ctx.xer);
	// 823B4D54: 41980028  blt cr6, 0x823b4d7c
	if ctx.cr[6].lt {
	pc = 0x823B4D7C; continue 'dispatch;
	}
	// 823B4D58: 387D004C  addi r3, r29, 0x4c
	ctx.r[3].s64 = ctx.r[29].s64 + 76;
	// 823B4D5C: 83DF0048  lwz r30, 0x48(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 823B4D60: 483584FD  bl 0x8270d25c
	ctx.lr = 0x823B4D64;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B4D64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B4D68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B4D6C: 4BFEAD6D  bl 0x8239fad8
	ctx.lr = 0x823B4D70;
	sub_8239FAD8(ctx, base);
	// 823B4D70: 387D004C  addi r3, r29, 0x4c
	ctx.r[3].s64 = ctx.r[29].s64 + 76;
	// 823B4D74: 483584F9  bl 0x8270d26c
	ctx.lr = 0x823B4D78;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B4D78: 937F0048  stw r27, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[27].u32 ) };
	pc = 0x823B4D7C; continue 'dispatch;
            }
            0x823B4D7C => {
    //   block [0x823B4D7C..0x823B4D90)
	// 823B4D7C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B4D80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4D84: 4182000C  beq 0x823b4d90
	if ctx.cr[0].eq {
	pc = 0x823B4D90; continue 'dispatch;
	}
	// 823B4D88: 4BFEBC81  bl 0x823a0a08
	ctx.lr = 0x823B4D8C;
	sub_823A0A08(ctx, base);
	// 823B4D8C: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x823B4D90; continue 'dispatch;
            }
            0x823B4D90 => {
    //   block [0x823B4D90..0x823B4DA8)
	// 823B4D90: A17F0054  lhz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 823B4D94: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823B4D98: 556B283E  rotlwi r11, r11, 5
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(5)) as u64;
	// 823B4D9C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823B4DA0: 3BEB0098  addi r31, r11, 0x98
	ctx.r[31].s64 = ctx.r[11].s64 + 152;
	// 823B4DA4: 4082FF9C  bne 0x823b4d40
	if !ctx.cr[0].eq {
	pc = 0x823B4D40; continue 'dispatch;
	}
	pc = 0x823B4DA8; continue 'dispatch;
            }
            0x823B4DA8 => {
    //   block [0x823B4DA8..0x823B4DB0)
	// 823B4DA8: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823B4DAC: 4082FF80  bne 0x823b4d2c
	if !ctx.cr[0].eq {
	pc = 0x823B4D2C; continue 'dispatch;
	}
	pc = 0x823B4DB0; continue 'dispatch;
            }
            0x823B4DB0 => {
    //   block [0x823B4DB0..0x823B4DD8)
	// 823B4DB0: 387D004C  addi r3, r29, 0x4c
	ctx.r[3].s64 = ctx.r[29].s64 + 76;
	// 823B4DB4: 83F9000C  lwz r31, 0xc(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B4DB8: 483584A5  bl 0x8270d25c
	ctx.lr = 0x823B4DBC;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B4DBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823B4DC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B4DC4: 4BFEAD15  bl 0x8239fad8
	ctx.lr = 0x823B4DC8;
	sub_8239FAD8(ctx, base);
	// 823B4DC8: 387D004C  addi r3, r29, 0x4c
	ctx.r[3].s64 = ctx.r[29].s64 + 76;
	// 823B4DCC: 483584A1  bl 0x8270d26c
	ctx.lr = 0x823B4DD0;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B4DD0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823B4DD4: 48180328  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823B4DD8 size=248
    let mut pc: u32 = 0x823B4DD8;
    'dispatch: loop {
        match pc {
            0x823B4DD8 => {
    //   block [0x823B4DD8..0x823B4E34)
	// 823B4DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B4DDC: 481802E1  bl 0x825350bc
	ctx.lr = 0x823B4DE0;
	sub_82535080(ctx, base);
	// 823B4DE0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B4DE4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 823B4DE8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B4DEC: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B4DF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B4DF4: 656B8000  oris r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 2147483648;
	// 823B4DF8: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 823B4DFC: 656B4000  oris r11, r11, 0x4000
	ctx.r[11].u64 = ctx.r[11].u64 | 1073741824;
	// 823B4E00: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 823B4E04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823B4E08: 656B2000  oris r11, r11, 0x2000
	ctx.r[11].u64 = ctx.r[11].u64 | 536870912;
	// 823B4E0C: A3DF000A  lhz r30, 0xa(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 823B4E10: 656B1000  oris r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 268435456;
	// 823B4E14: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 823B4E18: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 823B4E1C: 480018AD  bl 0x823b66c8
	ctx.lr = 0x823B4E20;
	sub_823B66C8(ctx, base);
	// 823B4E20: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4E24: 418200A4  beq 0x823b4ec8
	if ctx.cr[0].eq {
	pc = 0x823B4EC8; continue 'dispatch;
	}
	// 823B4E28: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 823B4E2C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823B4E30: 419A0098  beq cr6, 0x823b4ec8
	if ctx.cr[6].eq {
	pc = 0x823B4EC8; continue 'dispatch;
	}
	pc = 0x823B4E34; continue 'dispatch;
            }
            0x823B4E34 => {
    //   block [0x823B4E34..0x823B4E7C)
	// 823B4E34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B4E38: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 823B4E3C: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823B4E40: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B4E44: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823B4E48: 794A07A4  rldicr r10, r10, 0, 0x3e
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(0) & 0xFFFFFFFFFFFFFFFE;
	// 823B4E4C: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 823B4E50: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 823B4E54: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B4E58: 40820040  bne 0x823b4e98
	if !ctx.cr[0].eq {
	pc = 0x823B4E98; continue 'dispatch;
	}
	// 823B4E5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B4E60: 48001869  bl 0x823b66c8
	ctx.lr = 0x823B4E64;
	sub_823B66C8(ctx, base);
	// 823B4E64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4E68: 40820030  bne 0x823b4e98
	if !ctx.cr[0].eq {
	pc = 0x823B4E98; continue 'dispatch;
	}
	// 823B4E6C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B4E70: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 823B4E74: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4E78: 41820048  beq 0x823b4ec0
	if ctx.cr[0].eq {
	pc = 0x823B4EC0; continue 'dispatch;
	}
	pc = 0x823B4E7C; continue 'dispatch;
            }
            0x823B4E7C => {
    //   block [0x823B4E7C..0x823B4E98)
	// 823B4E7C: A15F0054  lhz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 823B4E80: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B4E84: 554A283E  rotlwi r10, r10, 5
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(5)) as u64;
	// 823B4E88: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 823B4E8C: 3BEA0098  addi r31, r10, 0x98
	ctx.r[31].s64 = ctx.r[10].s64 + 152;
	// 823B4E90: 4082FFEC  bne 0x823b4e7c
	if !ctx.cr[0].eq {
	pc = 0x823B4E7C; continue 'dispatch;
	}
	// 823B4E94: 4800002C  b 0x823b4ec0
	pc = 0x823B4EC0; continue 'dispatch;
            }
            0x823B4E98 => {
    //   block [0x823B4E98..0x823B4EA8)
	// 823B4E98: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B4E9C: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 823B4EA0: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4EA4: 41820018  beq 0x823b4ebc
	if ctx.cr[0].eq {
	pc = 0x823B4EBC; continue 'dispatch;
	}
	pc = 0x823B4EA8; continue 'dispatch;
            }
            0x823B4EA8 => {
    //   block [0x823B4EA8..0x823B4EBC)
	// 823B4EA8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823B4EAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B4EB0: 48006A09  bl 0x823bb8b8
	ctx.lr = 0x823B4EB4;
	sub_823BB8B8(ctx, base);
	// 823B4EB4: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823B4EB8: 4082FFF0  bne 0x823b4ea8
	if !ctx.cr[0].eq {
	pc = 0x823B4EA8; continue 'dispatch;
	}
	pc = 0x823B4EBC; continue 'dispatch;
            }
            0x823B4EBC => {
    //   block [0x823B4EBC..0x823B4EC0)
	// 823B4EBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x823B4EC0; continue 'dispatch;
            }
            0x823B4EC0 => {
    //   block [0x823B4EC0..0x823B4EC8)
	// 823B4EC0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823B4EC4: 4082FF70  bne 0x823b4e34
	if !ctx.cr[0].eq {
	pc = 0x823B4E34; continue 'dispatch;
	}
	pc = 0x823B4EC8; continue 'dispatch;
            }
            0x823B4EC8 => {
    //   block [0x823B4EC8..0x823B4ED0)
	// 823B4EC8: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 823B4ECC: 48180240  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B4ED0 size=132
    let mut pc: u32 = 0x823B4ED0;
    'dispatch: loop {
        match pc {
            0x823B4ED0 => {
    //   block [0x823B4ED0..0x823B4F30)
	// 823B4ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B4ED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B4ED8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B4EDC: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B4EE0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 823B4EE4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B4EE8: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B4EEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B4EF0: 656B8000  oris r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 2147483648;
	// 823B4EF4: 656B4000  oris r11, r11, 0x4000
	ctx.r[11].u64 = ctx.r[11].u64 | 1073741824;
	// 823B4EF8: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 823B4EFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823B4F00: 656B2000  oris r11, r11, 0x2000
	ctx.r[11].u64 = ctx.r[11].u64 | 536870912;
	// 823B4F04: 656B1000  oris r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 268435456;
	// 823B4F08: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 823B4F0C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 823B4F10: A0DF000E  lhz r6, 0xe(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(14 as u32) ) } as u64;
	// 823B4F14: A0BF000C  lhz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B4F18: 4BFF8811  bl 0x823ad728
	ctx.lr = 0x823B4F1C;
	sub_823AD728(ctx, base);
	// 823B4F1C: A17F000A  lhz r11, 0xa(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 823B4F20: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 823B4F24: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B4F28: 41820018  beq 0x823b4f40
	if ctx.cr[0].eq {
	pc = 0x823B4F40; continue 'dispatch;
	}
	// 823B4F2C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x823B4F30; continue 'dispatch;
            }
            0x823B4F30 => {
    //   block [0x823B4F30..0x823B4F40)
	// 823B4F30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823B4F34: 48002C1D  bl 0x823b7b50
	ctx.lr = 0x823B4F38;
	sub_823B7B50(ctx, base);
	// 823B4F38: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823B4F3C: 4082FFF4  bne 0x823b4f30
	if !ctx.cr[0].eq {
	pc = 0x823B4F30; continue 'dispatch;
	}
	pc = 0x823B4F40; continue 'dispatch;
            }
            0x823B4F40 => {
    //   block [0x823B4F40..0x823B4F54)
	// 823B4F40: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 823B4F44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B4F48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B4F4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B4F50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B4F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823B4F58 size=1044
    let mut pc: u32 = 0x823B4F58;
    'dispatch: loop {
        match pc {
            0x823B4F58 => {
    //   block [0x823B4F58..0x823B500C)
	// 823B4F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B4F5C: 48180155  bl 0x825350b0
	ctx.lr = 0x823B4F60;
	sub_82535080(ctx, base);
	// 823B4F60: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 823B4F64: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 823B4F68: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 823B4F6C: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B4F70: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B4F74: 38A0007C  li r5, 0x7c
	ctx.r[5].s64 = 124;
	// 823B4F78: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B4F7C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823B4F80: 48180251  bl 0x825351d0
	ctx.lr = 0x823B4F84;
	sub_825351D0(ctx, base);
	// 823B4F84: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B4F88: 839E0008  lwz r28, 8(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B4F8C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 823B4F90: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823B4F94: 3D6082BF  lis r11, -0x7d41
	ctx.r[11].s64 = -2101411840;
	// 823B4F98: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 823B4F9C: 388BA480  addi r4, r11, -0x5b80
	ctx.r[4].s64 = ctx.r[11].s64 + -23424;
	// 823B4FA0: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 823B4FA4: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 823B4FA8: 93E100A8  stw r31, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 823B4FAC: 93E100AC  stw r31, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[31].u32 ) };
	// 823B4FB0: 93410094  stw r26, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[26].u32 ) };
	// 823B4FB4: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 823B4FB8: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 823B4FBC: 4817FB95  bl 0x82534b50
	ctx.lr = 0x823B4FC0;
	sub_82534B50(ctx, base);
	// 823B4FC0: 80FE000C  lwz r7, 0xc(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B4FC4: 39600280  li r11, 0x280
	ctx.r[11].s64 = 640;
	// 823B4FC8: 934100E8  stw r26, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[26].u32 ) };
	// 823B4FCC: 394001E0  li r10, 0x1e0
	ctx.r[10].s64 = 480;
	// 823B4FD0: 54E8063E  clrlwi r8, r7, 0x18
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 823B4FD4: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 823B4FD8: 2B080022  cmplwi cr6, r8, 0x22
	ctx.cr[6].compare_u32(ctx.r[8].u32, 34 as u32, &mut ctx.xer);
	// 823B4FDC: 41990060  bgt cr6, 0x823b503c
	if ctx.cr[6].gt {
	pc = 0x823B503C; continue 'dispatch;
	}
	// 823B4FE0: 419A0050  beq cr6, 0x823b5030
	if ctx.cr[6].eq {
	pc = 0x823B5030; continue 'dispatch;
	}
	// 823B4FE4: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 823B4FE8: 419A0038  beq cr6, 0x823b5020
	if ctx.cr[6].eq {
	pc = 0x823B5020; continue 'dispatch;
	}
	// 823B4FEC: 2B080002  cmplwi cr6, r8, 2
	ctx.cr[6].compare_u32(ctx.r[8].u32, 2 as u32, &mut ctx.xer);
	// 823B4FF0: 419A0028  beq cr6, 0x823b5018
	if ctx.cr[6].eq {
	pc = 0x823B5018; continue 'dispatch;
	}
	// 823B4FF4: 2B080003  cmplwi cr6, r8, 3
	ctx.cr[6].compare_u32(ctx.r[8].u32, 3 as u32, &mut ctx.xer);
	// 823B4FF8: 419A0014  beq cr6, 0x823b500c
	if ctx.cr[6].eq {
	pc = 0x823B500C; continue 'dispatch;
	}
	// 823B4FFC: 2B080021  cmplwi cr6, r8, 0x21
	ctx.cr[6].compare_u32(ctx.r[8].u32, 33 as u32, &mut ctx.xer);
	// 823B5000: 409A0078  bne cr6, 0x823b5078
	if !ctx.cr[6].eq {
	pc = 0x823B5078; continue 'dispatch;
	}
	// 823B5004: 39600350  li r11, 0x350
	ctx.r[11].s64 = 848;
	// 823B5008: 4800006C  b 0x823b5074
	pc = 0x823B5074; continue 'dispatch;
            }
            0x823B500C => {
    //   block [0x823B500C..0x823B5018)
	// 823B500C: 39600780  li r11, 0x780
	ctx.r[11].s64 = 1920;
	// 823B5010: 39400438  li r10, 0x438
	ctx.r[10].s64 = 1080;
	// 823B5014: 48000060  b 0x823b5074
	pc = 0x823B5074; continue 'dispatch;
            }
            0x823B5018 => {
    //   block [0x823B5018..0x823B5020)
	// 823B5018: 394002D0  li r10, 0x2d0
	ctx.r[10].s64 = 720;
	// 823B501C: 48000054  b 0x823b5070
	pc = 0x823B5070; continue 'dispatch;
            }
            0x823B5020 => {
    //   block [0x823B5020..0x823B5028)
	// 823B5020: 39600280  li r11, 0x280
	ctx.r[11].s64 = 640;
	// 823B5024: 394001E0  li r10, 0x1e0
	ctx.r[10].s64 = 480;
	pc = 0x823B5028; continue 'dispatch;
            }
            0x823B5028 => {
    //   block [0x823B5028..0x823B5030)
	// 823B5028: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 823B502C: 4800004C  b 0x823b5078
	pc = 0x823B5078; continue 'dispatch;
            }
            0x823B5030 => {
    //   block [0x823B5030..0x823B503C)
	// 823B5030: 39600400  li r11, 0x400
	ctx.r[11].s64 = 1024;
	// 823B5034: 39400300  li r10, 0x300
	ctx.r[10].s64 = 768;
	// 823B5038: 4BFFFFF0  b 0x823b5028
	pc = 0x823B5028; continue 'dispatch;
            }
            0x823B503C => {
    //   block [0x823B503C..0x823B5060)
	// 823B503C: 2B080023  cmplwi cr6, r8, 0x23
	ctx.cr[6].compare_u32(ctx.r[8].u32, 35 as u32, &mut ctx.xer);
	// 823B5040: 419A002C  beq cr6, 0x823b506c
	if ctx.cr[6].eq {
	pc = 0x823B506C; continue 'dispatch;
	}
	// 823B5044: 2B080024  cmplwi cr6, r8, 0x24
	ctx.cr[6].compare_u32(ctx.r[8].u32, 36 as u32, &mut ctx.xer);
	// 823B5048: 419A0018  beq cr6, 0x823b5060
	if ctx.cr[6].eq {
	pc = 0x823B5060; continue 'dispatch;
	}
	// 823B504C: 2B080025  cmplwi cr6, r8, 0x25
	ctx.cr[6].compare_u32(ctx.r[8].u32, 37 as u32, &mut ctx.xer);
	// 823B5050: 409A0028  bne cr6, 0x823b5078
	if !ctx.cr[6].eq {
	pc = 0x823B5078; continue 'dispatch;
	}
	// 823B5054: 39600550  li r11, 0x550
	ctx.r[11].s64 = 1360;
	// 823B5058: 39400300  li r10, 0x300
	ctx.r[10].s64 = 768;
	// 823B505C: 48000018  b 0x823b5074
	pc = 0x823B5074; continue 'dispatch;
            }
            0x823B5060 => {
    //   block [0x823B5060..0x823B506C)
	// 823B5060: 39600500  li r11, 0x500
	ctx.r[11].s64 = 1280;
	// 823B5064: 39400400  li r10, 0x400
	ctx.r[10].s64 = 1024;
	// 823B5068: 4BFFFFC0  b 0x823b5028
	pc = 0x823B5028; continue 'dispatch;
            }
            0x823B506C => {
    //   block [0x823B506C..0x823B5070)
	// 823B506C: 39400300  li r10, 0x300
	ctx.r[10].s64 = 768;
	pc = 0x823B5070; continue 'dispatch;
            }
            0x823B5070 => {
    //   block [0x823B5070..0x823B5074)
	// 823B5070: 39600500  li r11, 0x500
	ctx.r[11].s64 = 1280;
	pc = 0x823B5074; continue 'dispatch;
            }
            0x823B5074 => {
    //   block [0x823B5074..0x823B5078)
	// 823B5074: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	pc = 0x823B5078; continue 'dispatch;
            }
            0x823B5078 => {
    //   block [0x823B5078..0x823B50C8)
	// 823B5078: 54E8052B  rlwinm. r8, r7, 0, 0x14, 0x15
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823B507C: 41820074  beq 0x823b50f0
	if ctx.cr[0].eq {
	pc = 0x823B50F0; continue 'dispatch;
	}
	// 823B5080: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823B5084: 409A006C  bne cr6, 0x823b50f0
	if !ctx.cr[6].eq {
	pc = 0x823B50F0; continue 'dispatch;
	}
	// 823B5088: 2B080400  cmplwi cr6, r8, 0x400
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1024 as u32, &mut ctx.xer);
	// 823B508C: 409A003C  bne cr6, 0x823b50c8
	if !ctx.cr[6].eq {
	pc = 0x823B50C8; continue 'dispatch;
	}
	// 823B5090: 7D3C59D6  mullw r9, r28, r11
	ctx.r[9].s32 = ((ctx.r[28].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823B5094: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 823B5098: 7D295396  divwu r9, r9, r10
	ctx.r[9].u32 = ctx.r[9].u32 / ctx.r[10].u32;
	// 823B509C: 914100E4  stw r10, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[10].u32 ) };
	// 823B50A0: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 823B50A4: 934100D4  stw r26, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[26].u32 ) };
	// 823B50A8: 938100DC  stw r28, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[28].u32 ) };
	// 823B50AC: 7D69E850  subf r11, r9, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[9].s64;
	// 823B50B0: 7D5D4A14  add r10, r29, r9
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[9].u64;
	// 823B50B4: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B50B8: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 823B50BC: 554BF87E  srwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823B50C0: 916100D8  stw r11, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 823B50C4: 48000030  b 0x823b50f4
	pc = 0x823B50F4; continue 'dispatch;
            }
            0x823B50C8 => {
    //   block [0x823B50C8..0x823B50F0)
	// 823B50C8: 2B080800  cmplwi cr6, r8, 0x800
	ctx.cr[6].compare_u32(ctx.r[8].u32, 2048 as u32, &mut ctx.xer);
	// 823B50CC: 409A0024  bne cr6, 0x823b50f0
	if !ctx.cr[6].eq {
	pc = 0x823B50F0; continue 'dispatch;
	}
	// 823B50D0: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 823B50D4: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 823B50D8: 914100E4  stw r10, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[10].u32 ) };
	// 823B50DC: 934100D0  stw r26, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[26].u32 ) };
	// 823B50E0: 934100D4  stw r26, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[26].u32 ) };
	// 823B50E4: 93A100D8  stw r29, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[29].u32 ) };
	// 823B50E8: 938100DC  stw r28, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[28].u32 ) };
	// 823B50EC: 48000008  b 0x823b50f4
	pc = 0x823B50F4; continue 'dispatch;
            }
            0x823B50F0 => {
    //   block [0x823B50F0..0x823B50F4)
	// 823B50F0: 9341009C  stw r26, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[26].u32 ) };
	pc = 0x823B50F4; continue 'dispatch;
            }
            0x823B50F4 => {
    //   block [0x823B50F4..0x823B5124)
	// 823B50F4: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 823B50F8: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 823B50FC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 823B5100: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B5104: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B5108: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B510C: 4802B015  bl 0x823e0120
	ctx.lr = 0x823B5110;
	sub_823E0120(ctx, base);
	// 823B5110: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823B5114: 40800010  bge 0x823b5124
	if !ctx.cr[0].lt {
	pc = 0x823B5124; continue 'dispatch;
	}
	// 823B5118: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823B511C: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 823B5120: 48000238  b 0x823b5358
	pc = 0x823B5358; continue 'dispatch;
            }
            0x823B5124 => {
    //   block [0x823B5124..0x823B51A0)
	// 823B5124: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B5128: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B512C: 3BAB0700  addi r29, r11, 0x700
	ctx.r[29].s64 = ctx.r[11].s64 + 1792;
	// 823B5130: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 823B5134: 48358129  bl 0x8270d25c
	ctx.lr = 0x823B5138;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B5138: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823B513C: 387D002C  addi r3, r29, 0x2c
	ctx.r[3].s64 = ctx.r[29].s64 + 44;
	// 823B5140: 4BFF9C51  bl 0x823aed90
	ctx.lr = 0x823B5144;
	sub_823AED90(ctx, base);
	// 823B5144: 3D60823A  lis r11, -0x7dc6
	ctx.r[11].s64 = -2110128128;
	// 823B5148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B514C: 388B49B0  addi r4, r11, 0x49b0
	ctx.r[4].s64 = ctx.r[11].s64 + 18864;
	// 823B5150: 4802BDF1  bl 0x823e0f40
	ctx.lr = 0x823B5154;
	sub_823E0F40(ctx, base);
	// 823B5154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B5158: 48026679  bl 0x823db7d0
	ctx.lr = 0x823B515C;
	sub_823DB7D0(ctx, base);
	// 823B515C: 48026155  bl 0x823db2b0
	ctx.lr = 0x823B5160;
	sub_823DB2B0(ctx, base);
	// 823B5160: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B5164: 4802AE9D  bl 0x823e0000
	ctx.lr = 0x823B5168;
	sub_823E0000(ctx, base);
	// 823B5168: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 823B516C: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823B5170: 483580FD  bl 0x8270d26c
	ctx.lr = 0x823B5174;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B5174: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B5178: 3D402828  lis r10, 0x2828
	ctx.r[10].s64 = 673710080;
	// 823B517C: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 823B5180: 61480106  ori r8, r10, 0x106
	ctx.r[8].u64 = ctx.r[10].u64 | 262;
	// 823B5184: 911E0018  stw r8, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 823B5188: 557FBFFF  rlwinm. r31, r11, 0x17, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000001FFu64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823B518C: 41820014  beq 0x823b51a0
	if ctx.cr[0].eq {
	pc = 0x823B51A0; continue 'dispatch;
	}
	// 823B5190: 3D602D20  lis r11, 0x2d20
	ctx.r[11].s64 = 757071872;
	// 823B5194: 616B0196  ori r11, r11, 0x196
	ctx.r[11].u64 = ctx.r[11].u64 | 406;
	// 823B5198: 917E001C  stw r11, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 823B519C: 48000008  b 0x823b51a4
	pc = 0x823B51A4; continue 'dispatch;
            }
            0x823B51A0 => {
    //   block [0x823B51A0..0x823B51A4)
	// 823B51A0: 935E001C  stw r26, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[26].u32 ) };
	pc = 0x823B51A4; continue 'dispatch;
            }
            0x823B51A4 => {
    //   block [0x823B51A4..0x823B5208)
	// 823B51A4: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B51A8: 80FE0008  lwz r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B51AC: 3C8082BA  lis r4, -0x7d46
	ctx.r[4].s64 = -2101739520;
	// 823B51B0: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B51B4: 3B6B0F00  addi r27, r11, 0xf00
	ctx.r[27].s64 = ctx.r[11].s64 + 3840;
	// 823B51B8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 823B51BC: 3B9E0020  addi r28, r30, 0x20
	ctx.r[28].s64 = ctx.r[30].s64 + 32;
	// 823B51C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B51C4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B51C8: 38A0FFF0  li r5, -0x10
	ctx.r[5].s64 = -16;
	// 823B51CC: 9164C474  stw r11, -0x3b8c(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(-15244 as u32), ctx.r[11].u32 ) };
	// 823B51D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823B51D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823B51D8: 4BFF9779  bl 0x823ae950
	ctx.lr = 0x823B51DC;
	sub_823AE950(ctx, base);
	// 823B51DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823B51E0: 419A0028  beq cr6, 0x823b5208
	if ctx.cr[6].eq {
	pc = 0x823B5208; continue 'dispatch;
	}
	// 823B51E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B51E8: 811E001C  lwz r8, 0x1c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B51EC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B51F0: 80FE0008  lwz r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B51F4: 38A0FFF4  li r5, -0xc
	ctx.r[5].s64 = -12;
	// 823B51F8: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B51FC: 389E0280  addi r4, r30, 0x280
	ctx.r[4].s64 = ctx.r[30].s64 + 640;
	// 823B5200: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823B5204: 4BFF999D  bl 0x823aeba0
	ctx.lr = 0x823B5208;
	sub_823AEBA0(ctx, base);
	pc = 0x823B5208; continue 'dispatch;
            }
            0x823B5208 => {
    //   block [0x823B5208..0x823B5238)
	// 823B5208: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B520C: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 823B5210: 396B0180  addi r11, r11, 0x180
	ctx.r[11].s64 = ctx.r[11].s64 + 384;
	// 823B5214: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 823B5218: 935E0014  stw r26, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	// 823B521C: 48358041  bl 0x8270d25c
	ctx.lr = 0x823B5220;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B5220: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B5224: 4802AD9D  bl 0x823dffc0
	ctx.lr = 0x823B5228;
	sub_823DFFC0(ctx, base);
	// 823B5228: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823B522C: 3B7E0280  addi r27, r30, 0x280
	ctx.r[27].s64 = ctx.r[30].s64 + 640;
	// 823B5230: 409A0008  bne cr6, 0x823b5238
	if !ctx.cr[6].eq {
	pc = 0x823B5238; continue 'dispatch;
	}
	// 823B5234: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	pc = 0x823B5238; continue 'dispatch;
            }
            0x823B5238 => {
    //   block [0x823B5238..0x823B5280)
	// 823B5238: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B523C: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B5240: 3BEB0200  addi r31, r11, 0x200
	ctx.r[31].s64 = ctx.r[11].s64 + 512;
	// 823B5244: 1D6A0130  mulli r11, r10, 0x130
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 304 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823B5248: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823B524C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B5250: 3B8B0020  addi r28, r11, 0x20
	ctx.r[28].s64 = ctx.r[11].s64 + 32;
	// 823B5254: 48358009  bl 0x8270d25c
	ctx.lr = 0x823B5258;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B5258: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 823B525C: 939F0038  stw r28, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[28].u32 ) };
	// 823B5260: 393F0024  addi r9, r31, 0x24
	ctx.r[9].s64 = ctx.r[31].s64 + 36;
	// 823B5264: 395F0038  addi r10, r31, 0x38
	ctx.r[10].s64 = ctx.r[31].s64 + 56;
	// 823B5268: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 823B526C: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 823B5270: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 823B5274: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 823B5278: 937F0048  stw r27, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[27].u32 ) };
	// 823B527C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x823B5280; continue 'dispatch;
            }
            0x823B5280 => {
    //   block [0x823B5280..0x823B5358)
	// 823B5280: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5284: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823B5288: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B528C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823B5290: 4200FFF0  bdnz 0x823b5280
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823B5280; continue 'dispatch;
	}
	// 823B5294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B5298: 480002C1  bl 0x823b5558
	ctx.lr = 0x823B529C;
	sub_823B5558(ctx, base);
	// 823B529C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B52A0: 48357FCD  bl 0x8270d26c
	ctx.lr = 0x823B52A4;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B52A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 823B52A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B52AC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823B52B0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B52B4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B52B8: 38C0003F  li r6, 0x3f
	ctx.r[6].s64 = 63;
	// 823B52BC: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823B52C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B52C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B52C8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823B52CC: 4803BDD5  bl 0x823f10a0
	ctx.lr = 0x823B52D0;
	sub_823F10A0(ctx, base);
	// 823B52D0: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B52D4: 4802AD2D  bl 0x823e0000
	ctx.lr = 0x823B52D8;
	sub_823E0000(ctx, base);
	// 823B52D8: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 823B52DC: 48357F91  bl 0x8270d26c
	ctx.lr = 0x823B52E0;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B52E0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823B52E4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B52E8: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B52EC: 3BEB9980  addi r31, r11, -0x6680
	ctx.r[31].s64 = ctx.r[11].s64 + -26240;
	// 823B52F0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 823B52F4: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 823B52F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B52FC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 823B5300: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 823B5304: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823B5308: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 823B530C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823B5310: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823B5314: FFC00018  frsp f30, f0
	ctx.f[30].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823B5318: FFA06818  frsp f29, f13
	ctx.f[29].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823B531C: 48357F41  bl 0x8270d25c
	ctx.lr = 0x823B5320;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B5320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B5324: D3DF004C  stfs f30, 0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 823B5328: D3BF0050  stfs f29, 0x50(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823B532C: 48357F41  bl 0x8270d26c
	ctx.lr = 0x823B5330;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B5330: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B5334: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B5338: FCC0F890  fmr f6, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[6].f64 = ctx.f[31].f64;
	// 823B533C: FC80E890  fmr f4, f29
	ctx.f[4].f64 = ctx.f[29].f64;
	// 823B5340: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 823B5344: C0AB1FF8  lfs f5, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 823B5348: FC402890  fmr f2, f5
	ctx.f[2].f64 = ctx.f[5].f64;
	// 823B534C: FC202890  fmr f1, f5
	ctx.f[1].f64 = ctx.f[5].f64;
	// 823B5350: 4BFE75B9  bl 0x8239c908
	ctx.lr = 0x823B5354;
	sub_8239C908(ctx, base);
	// 823B5354: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823B5358; continue 'dispatch;
            }
            0x823B5358 => {
    //   block [0x823B5358..0x823B536C)
	// 823B5358: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 823B535C: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 823B5360: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 823B5364: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 823B5368: 4817FD98  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B5370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B5370 size=236
    let mut pc: u32 = 0x823B5370;
    'dispatch: loop {
        match pc {
            0x823B5370 => {
    //   block [0x823B5370..0x823B53E4)
	// 823B5370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B5374: 4817FD49  bl 0x825350bc
	ctx.lr = 0x823B5378;
	sub_82535080(ctx, base);
	// 823B5378: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B537C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B5380: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B5384: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B5388: 1D6B0130  mulli r11, r11, 0x130
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 304 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823B538C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823B5390: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 823B5394: 480007F5  bl 0x823b5b88
	ctx.lr = 0x823B5398;
	sub_823B5B88(ctx, base);
	// 823B5398: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B539C: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B53A0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B53A4: 396B0180  addi r11, r11, 0x180
	ctx.r[11].s64 = ctx.r[11].s64 + 384;
	// 823B53A8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823B53AC: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 823B53B0: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B53B4: 396B0700  addi r11, r11, 0x700
	ctx.r[11].s64 = ctx.r[11].s64 + 1792;
	// 823B53B8: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B53BC: 7D6A482E  lwzx r11, r10, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 823B53C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B53C4: 388B001C  addi r4, r11, 0x1c
	ctx.r[4].s64 = ctx.r[11].s64 + 28;
	// 823B53C8: 4802B5E1  bl 0x823e09a8
	ctx.lr = 0x823B53CC;
	sub_823E09A8(ctx, base);
	// 823B53CC: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B53D0: 3BBE0280  addi r29, r30, 0x280
	ctx.r[29].s64 = ctx.r[30].s64 + 640;
	// 823B53D4: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 823B53D8: 556BBFFF  rlwinm. r11, r11, 0x17, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000001FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B53DC: 40820008  bne 0x823b53e4
	if !ctx.cr[0].eq {
	pc = 0x823B53E4; continue 'dispatch;
	}
	// 823B53E0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x823B53E4; continue 'dispatch;
            }
            0x823B53E4 => {
    //   block [0x823B53E4..0x823B542C)
	// 823B53E4: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B53E8: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B53EC: 3BEB0200  addi r31, r11, 0x200
	ctx.r[31].s64 = ctx.r[11].s64 + 512;
	// 823B53F0: 1D6A0130  mulli r11, r10, 0x130
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 304 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823B53F4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823B53F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B53FC: 3BCB0020  addi r30, r11, 0x20
	ctx.r[30].s64 = ctx.r[11].s64 + 32;
	// 823B5400: 48357E5D  bl 0x8270d25c
	ctx.lr = 0x823B5404;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B5404: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823B5408: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 823B540C: 393F0024  addi r9, r31, 0x24
	ctx.r[9].s64 = ctx.r[31].s64 + 36;
	// 823B5410: 395F0038  addi r10, r31, 0x38
	ctx.r[10].s64 = ctx.r[31].s64 + 56;
	// 823B5414: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 823B5418: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 823B541C: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 823B5420: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 823B5424: 93BF0048  stw r29, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[29].u32 ) };
	// 823B5428: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x823B542C; continue 'dispatch;
            }
            0x823B542C => {
    //   block [0x823B542C..0x823B545C)
	// 823B542C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5430: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823B5434: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B5438: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823B543C: 4200FFF0  bdnz 0x823b542c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823B542C; continue 'dispatch;
	}
	// 823B5440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B5444: 48000115  bl 0x823b5558
	ctx.lr = 0x823B5448;
	sub_823B5558(ctx, base);
	// 823B5448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B544C: 48357E21  bl 0x8270d26c
	ctx.lr = 0x823B5450;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B5450: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B5454: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B5458: 4817FCB4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B5460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823B5460 size=132
    let mut pc: u32 = 0x823B5460;
    'dispatch: loop {
        match pc {
            0x823B5460 => {
    //   block [0x823B5460..0x823B54AC)
	// 823B5460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B5464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B5468: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823B546C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 823B5470: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B5474: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5478: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B547C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823B5480: 4E800421  bctrl
	ctx.lr = 0x823B5484;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823B5484: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823B5488: 48358835  bl 0x8270dcbc
	ctx.lr = 0x823B548C;
	// extern call 0x8270DCBC → crate::xboxkrnl::XGetVideoMode
	crate::xboxkrnl::XGetVideoMode(ctx, base);
	// 823B548C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B5490: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B5494: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 823B5498: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823B549C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823B54A0: 409A000C  bne cr6, 0x823b54ac
	if !ctx.cr[6].eq {
	pc = 0x823B54AC; continue 'dispatch;
	}
	// 823B54A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B54A8: C3EB1FF4  lfs f31, 0x1ff4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8180 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
            }
            0x823B54AC => {
    //   block [0x823B54AC..0x823B54E4)
	// 823B54AC: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823B54B0: 3BEB9980  addi r31, r11, -0x6680
	ctx.r[31].s64 = ctx.r[11].s64 + -26240;
	// 823B54B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B54B8: 48357DA5  bl 0x8270d25c
	ctx.lr = 0x823B54BC;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B54BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B54C0: D3FF00B0  stfs f31, 0xb0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 823B54C4: 48357DA9  bl 0x8270d26c
	ctx.lr = 0x823B54C8;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B54C8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B54CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823B54D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B54D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B54D8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823B54DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B54E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B54E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B54E8 size=112
    let mut pc: u32 = 0x823B54E8;
    'dispatch: loop {
        match pc {
            0x823B54E8 => {
    //   block [0x823B54E8..0x823B5504)
	// 823B54E8: 54A906BE  clrlwi r9, r5, 0x1a
	ctx.r[9].u64 = ctx.r[5].u32 as u64 & 0x0000003Fu64;
	// 823B54EC: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 823B54F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823B54F4: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 823B54F8: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 823B54FC: 41980008  blt cr6, 0x823b5504
	if ctx.cr[6].lt {
	pc = 0x823B5504; continue 'dispatch;
	}
	// 823B5500: 548A083C  slwi r10, r4, 1
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x823B5504; continue 'dispatch;
            }
            0x823B5504 => {
    //   block [0x823B5504..0x823B5510)
	// 823B5504: 2F060002  cmpwi cr6, r6, 2
	ctx.cr[6].compare_i32(ctx.r[6].s32, 2, &mut ctx.xer);
	// 823B5508: 409A0008  bne cr6, 0x823b5510
	if !ctx.cr[6].eq {
	pc = 0x823B5510; continue 'dispatch;
	}
	// 823B550C: 546B083C  slwi r11, r3, 1
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x823B5510; continue 'dispatch;
            }
            0x823B5510 => {
    //   block [0x823B5510..0x823B5540)
	// 823B5510: 396B004F  addi r11, r11, 0x4f
	ctx.r[11].s64 = ctx.r[11].s64 + 79;
	// 823B5514: 38E00050  li r7, 0x50
	ctx.r[7].s64 = 80;
	// 823B5518: 394A000F  addi r10, r10, 0xf
	ctx.r[10].s64 = ctx.r[10].s64 + 15;
	// 823B551C: 7CEB3B96  divwu r7, r11, r7
	ctx.r[7].u32 = ctx.r[11].u32 / ctx.r[7].u32;
	// 823B5520: 554B0036  rlwinm r11, r10, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823B5524: 1D470050  mulli r10, r7, 0x50
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * 80 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823B5528: 2F090015  cmpwi cr6, r9, 0x15
	ctx.cr[6].compare_i32(ctx.r[9].s32, 21, &mut ctx.xer);
	// 823B552C: 419A0014  beq cr6, 0x823b5540
	if ctx.cr[6].eq {
	pc = 0x823B5540; continue 'dispatch;
	}
	// 823B5530: 2F090020  cmpwi cr6, r9, 0x20
	ctx.cr[6].compare_i32(ctx.r[9].s32, 32, &mut ctx.xer);
	// 823B5534: 419A000C  beq cr6, 0x823b5540
	if ctx.cr[6].eq {
	pc = 0x823B5540; continue 'dispatch;
	}
	// 823B5538: 2F090025  cmpwi cr6, r9, 0x25
	ctx.cr[6].compare_i32(ctx.r[9].s32, 37, &mut ctx.xer);
	// 823B553C: 409A0008  bne cr6, 0x823b5544
	if !ctx.cr[6].eq {
	pc = 0x823B5544; continue 'dispatch;
	}
	pc = 0x823B5540; continue 'dispatch;
            }
            0x823B5540 => {
    //   block [0x823B5540..0x823B5544)
	// 823B5540: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	pc = 0x823B5544; continue 'dispatch;
            }
            0x823B5544 => {
    //   block [0x823B5544..0x823B5558)
	// 823B5544: 7D6B51D6  mullw r11, r11, r10
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823B5548: 7D6B41D6  mullw r11, r11, r8
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823B554C: 39401400  li r10, 0x1400
	ctx.r[10].s64 = 5120;
	// 823B5550: 7C6B5396  divwu r3, r11, r10
	ctx.r[3].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 823B5554: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B5558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B5558 size=140
    let mut pc: u32 = 0x823B5558;
    'dispatch: loop {
        match pc {
            0x823B5558 => {
    //   block [0x823B5558..0x823B5594)
	// 823B5558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B555C: 4817FB61  bl 0x825350bc
	ctx.lr = 0x823B5560;
	sub_82535080(ctx, base);
	// 823B5560: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B5564: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B5568: 3BE30024  addi r31, r3, 0x24
	ctx.r[31].s64 = ctx.r[3].s64 + 36;
	// 823B556C: 396B0700  addi r11, r11, 0x700
	ctx.r[11].s64 = ctx.r[11].s64 + 1792;
	// 823B5570: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823B5574: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B5578: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B557C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B5580: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B5584: 41820010  beq 0x823b5594
	if ctx.cr[0].eq {
	pc = 0x823B5594; continue 'dispatch;
	}
	// 823B5588: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B558C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823B5590: 48000008  b 0x823b5598
	pc = 0x823B5598; continue 'dispatch;
            }
            0x823B5594 => {
    //   block [0x823B5594..0x823B5598)
	// 823B5594: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x823B5598; continue 'dispatch;
            }
            0x823B5598 => {
    //   block [0x823B5598..0x823B55AC)
	// 823B5598: 480276A1  bl 0x823dcc38
	ctx.lr = 0x823B559C;
	sub_823DCC38(ctx, base);
	// 823B559C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B55A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B55A4: 48029FF5  bl 0x823df598
	ctx.lr = 0x823B55A8;
	sub_823DF598(ctx, base);
	// 823B55A8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x823B55AC; continue 'dispatch;
            }
            0x823B55AC => {
    //   block [0x823B55AC..0x823B55C0)
	// 823B55AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B55B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B55B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B55B8: 41820008  beq 0x823b55c0
	if ctx.cr[0].eq {
	pc = 0x823B55C0; continue 'dispatch;
	}
	// 823B55BC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823B55C0; continue 'dispatch;
            }
            0x823B55C0 => {
    //   block [0x823B55C0..0x823B55E4)
	// 823B55C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B55C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823B55C8: 4802A2A9  bl 0x823df870
	ctx.lr = 0x823B55CC;
	sub_823DF870(ctx, base);
	// 823B55CC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823B55D0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823B55D4: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 823B55D8: 4198FFD4  blt cr6, 0x823b55ac
	if ctx.cr[6].lt {
	pc = 0x823B55AC; continue 'dispatch;
	}
	// 823B55DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B55E0: 4817FB2C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B55E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823B55E8 size=732
    let mut pc: u32 = 0x823B55E8;
    'dispatch: loop {
        match pc {
            0x823B55E8 => {
    //   block [0x823B55E8..0x823B560C)
	// 823B55E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B55EC: 4817FAA9  bl 0x82535094
	ctx.lr = 0x823B55F0;
	sub_82535080(ctx, base);
	// 823B55F0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B55F4: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 823B55F8: 48357C65  bl 0x8270d25c
	ctx.lr = 0x823B55FC;
	// extern call 0x8270D25C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823B55FC: 3A930024  addi r20, r19, 0x24
	ctx.r[20].s64 = ctx.r[19].s64 + 36;
	// 823B5600: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 823B5604: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 823B5608: 7EB6AB78  mr r22, r21
	ctx.r[22].u64 = ctx.r[21].u64;
	pc = 0x823B560C; continue 'dispatch;
            }
            0x823B560C => {
    //   block [0x823B560C..0x823B5628)
	// 823B560C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5610: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823B5614: 419A0014  beq cr6, 0x823b5628
	if ctx.cr[6].eq {
	pc = 0x823B5628; continue 'dispatch;
	}
	// 823B5618: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 823B561C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823B5620: 2F160004  cmpwi cr6, r22, 4
	ctx.cr[6].compare_i32(ctx.r[22].s32, 4, &mut ctx.xer);
	// 823B5624: 4198FFE8  blt cr6, 0x823b560c
	if ctx.cr[6].lt {
	pc = 0x823B560C; continue 'dispatch;
	}
	pc = 0x823B5628; continue 'dispatch;
            }
            0x823B5628 => {
    //   block [0x823B5628..0x823B5664)
	// 823B5628: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 823B562C: 40990160  ble cr6, 0x823b578c
	if !ctx.cr[6].gt {
	pc = 0x823B578C; continue 'dispatch;
	}
	// 823B5630: 83340000  lwz r25, 0(r20)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5634: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B5638: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823B563C: 40990150  ble cr6, 0x823b578c
	if !ctx.cr[6].gt {
	pc = 0x823B578C; continue 'dispatch;
	}
	// 823B5640: 81790124  lwz r11, 0x124(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(292 as u32) ) } as u64;
	// 823B5644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B5648: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B564C: 3AEB0700  addi r23, r11, 0x700
	ctx.r[23].s64 = ctx.r[11].s64 + 1792;
	// 823B5650: 419A00EC  beq cr6, 0x823b573c
	if ctx.cr[6].eq {
	pc = 0x823B573C; continue 'dispatch;
	}
	// 823B5654: 7EBAAB78  mr r26, r21
	ctx.r[26].u64 = ctx.r[21].u64;
	// 823B5658: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 823B565C: 409900E0  ble cr6, 0x823b573c
	if !ctx.cr[6].gt {
	pc = 0x823B573C; continue 'dispatch;
	}
	// 823B5660: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	pc = 0x823B5664; continue 'dispatch;
            }
            0x823B5664 => {
    //   block [0x823B5664..0x823B56E4)
	// 823B5664: 83F80000  lwz r31, 0(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5668: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B566C: 418200C0  beq 0x823b572c
	if ctx.cr[0].eq {
	pc = 0x823B572C; continue 'dispatch;
	}
	// 823B5670: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5674: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B5678: 418200B4  beq 0x823b572c
	if ctx.cr[0].eq {
	pc = 0x823B572C; continue 'dispatch;
	}
	// 823B567C: 817F011C  lwz r11, 0x11c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 823B5680: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B5684: 409A00A8  bne cr6, 0x823b572c
	if !ctx.cr[6].eq {
	pc = 0x823B572C; continue 'dispatch;
	}
	// 823B5688: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 823B568C: C01F0100  lfs f0, 0x100(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B5690: 813F0128  lwz r9, 0x128(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 823B5694: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 823B5698: C01F0104  lfs f0, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B569C: 3B8A001C  addi r28, r10, 0x1c
	ctx.r[28].s64 = ctx.r[10].s64 + 28;
	// 823B56A0: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 823B56A4: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	// 823B56A8: C01F0108  lfs f0, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B56AC: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 823B56B0: C01F010C  lfs f0, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B56B4: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 823B56B8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B56BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823B56C0: 556A077C  rlwinm r10, r11, 0, 0x1d, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823B56C4: 214A0000  subfic r10, r10, 0
	ctx.xer.ca = ctx.r[10].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[10].s64;
	// 823B56C8: 7D4A5110  subfe r10, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 823B56CC: 516A45EE  rlwimi r10, r11, 8, 0x17, 0x17
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x0000000000000100) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFEFF);
	// 823B56D0: 554B05AE  rlwinm r11, r10, 0, 0x16, 0x17
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823B56D4: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 823B56D8: 7D7BD378  or r27, r11, r26
	ctx.r[27].u64 = ctx.r[11].u64 | ctx.r[26].u64;
	// 823B56DC: 40990050  ble cr6, 0x823b572c
	if !ctx.cr[6].gt {
	pc = 0x823B572C; continue 'dispatch;
	}
	// 823B56E0: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	pc = 0x823B56E4; continue 'dispatch;
            }
            0x823B56E4 => {
    //   block [0x823B56E4..0x823B572C)
	// 823B56E4: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 823B56E8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 823B56EC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B56F0: C03F0110  lfs f1, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823B56F4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823B56F8: 80770004  lwz r3, 4(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B56FC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 823B5700: 92A10064  stw r21, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	// 823B5704: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 823B5708: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823B570C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823B5710: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823B5714: 48037F15  bl 0x823ed628
	ctx.lr = 0x823B5718;
	sub_823ED628(ctx, base);
	// 823B5718: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B571C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823B5720: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 823B5724: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823B5728: 4198FFBC  blt cr6, 0x823b56e4
	if ctx.cr[6].lt {
	pc = 0x823B56E4; continue 'dispatch;
	}
	pc = 0x823B572C; continue 'dispatch;
            }
            0x823B572C => {
    //   block [0x823B572C..0x823B573C)
	// 823B572C: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 823B5730: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 823B5734: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 823B5738: 4198FF2C  blt cr6, 0x823b5664
	if ctx.cr[6].lt {
	pc = 0x823B5664; continue 'dispatch;
	}
	pc = 0x823B573C; continue 'dispatch;
            }
            0x823B573C => {
    //   block [0x823B573C..0x823B5758)
	// 823B573C: 80740010  lwz r3, 0x10(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B5740: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B5744: 41820014  beq 0x823b5758
	if ctx.cr[0].eq {
	pc = 0x823B5758; continue 'dispatch;
	}
	// 823B5748: 8163011C  lwz r11, 0x11c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(284 as u32) ) } as u64;
	// 823B574C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B5750: 419A0008  beq cr6, 0x823b5758
	if ctx.cr[6].eq {
	pc = 0x823B5758; continue 'dispatch;
	}
	// 823B5754: 48000515  bl 0x823b5c68
	ctx.lr = 0x823B5758;
	sub_823B5C68(ctx, base);
	pc = 0x823B5758; continue 'dispatch;
            }
            0x823B5758 => {
    //   block [0x823B5758..0x823B578C)
	// 823B5758: C0190100  lfs f0, 0x100(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B575C: 80770004  lwz r3, 4(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B5760: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 823B5764: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 823B5768: C0190104  lfs f0, 0x104(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B576C: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 823B5770: C0190108  lfs f0, 0x108(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B5774: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 823B5778: C019010C  lfs f0, 0x10c(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B577C: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 823B5780: 81390114  lwz r9, 0x114(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(276 as u32) ) } as u64;
	// 823B5784: C0390110  lfs f1, 0x110(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(272 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823B5788: 48000068  b 0x823b57f0
	pc = 0x823B57F0; continue 'dispatch;
            }
            0x823B578C => {
    //   block [0x823B578C..0x823B57F0)
	// 823B578C: 83F40010  lwz r31, 0x10(r20)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B5790: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B5794: 41820074  beq 0x823b5808
	if ctx.cr[0].eq {
	pc = 0x823B5808; continue 'dispatch;
	}
	// 823B5798: 817F011C  lwz r11, 0x11c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 823B579C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B57A0: 419A0068  beq cr6, 0x823b5808
	if ctx.cr[6].eq {
	pc = 0x823B5808; continue 'dispatch;
	}
	// 823B57A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B57A8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823B57AC: 4099005C  ble cr6, 0x823b5808
	if !ctx.cr[6].gt {
	pc = 0x823B5808; continue 'dispatch;
	}
	// 823B57B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823B57B4: 480004B5  bl 0x823b5c68
	ctx.lr = 0x823B57B8;
	sub_823B5C68(ctx, base);
	// 823B57B8: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B57BC: C01F0100  lfs f0, 0x100(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B57C0: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 823B57C4: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 823B57C8: 396B0700  addi r11, r11, 0x700
	ctx.r[11].s64 = ctx.r[11].s64 + 1792;
	// 823B57CC: C01F0104  lfs f0, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B57D0: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 823B57D4: C01F0108  lfs f0, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B57D8: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 823B57DC: C01F010C  lfs f0, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B57E0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B57E4: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 823B57E8: 813F0114  lwz r9, 0x114(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 823B57EC: C03F0110  lfs f1, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x823B57F0; continue 'dispatch;
            }
            0x823B57F0 => {
    //   block [0x823B57F0..0x823B5808)
	// 823B57F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B57F4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B57F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823B57FC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B5800: 48031A11  bl 0x823e7210
	ctx.lr = 0x823B5804;
	sub_823E7210(ctx, base);
	// 823B5804: 480000B0  b 0x823b58b4
	pc = 0x823B58B4; continue 'dispatch;
            }
            0x823B5808 => {
    //   block [0x823B5808..0x823B5830)
	// 823B5808: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 823B580C: 40990048  ble cr6, 0x823b5854
	if !ctx.cr[6].gt {
	pc = 0x823B5854; continue 'dispatch;
	}
	// 823B5810: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5814: 816B0124  lwz r11, 0x124(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(292 as u32) ) } as u64;
	// 823B5818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B581C: 419A0038  beq cr6, 0x823b5854
	if ctx.cr[6].eq {
	pc = 0x823B5854; continue 'dispatch;
	}
	// 823B5820: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 823B5824: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 823B5828: 4099002C  ble cr6, 0x823b5854
	if !ctx.cr[6].gt {
	pc = 0x823B5854; continue 'dispatch;
	}
	// 823B582C: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	pc = 0x823B5830; continue 'dispatch;
            }
            0x823B5830 => {
    //   block [0x823B5830..0x823B5844)
	// 823B5830: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5834: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B5838: 4182000C  beq 0x823b5844
	if ctx.cr[0].eq {
	pc = 0x823B5844; continue 'dispatch;
	}
	// 823B583C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B5840: 48000349  bl 0x823b5b88
	ctx.lr = 0x823B5844;
	sub_823B5B88(ctx, base);
	pc = 0x823B5844; continue 'dispatch;
            }
            0x823B5844 => {
    //   block [0x823B5844..0x823B5854)
	// 823B5844: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823B5848: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823B584C: 7F1EB000  cmpw cr6, r30, r22
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[22].s32, &mut ctx.xer);
	// 823B5850: 4198FFE0  blt cr6, 0x823b5830
	if ctx.cr[6].lt {
	pc = 0x823B5830; continue 'dispatch;
	}
	pc = 0x823B5854; continue 'dispatch;
            }
            0x823B5854 => {
    //   block [0x823B5854..0x823B58B4)
	// 823B5854: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823B5858: 419A005C  beq cr6, 0x823b58b4
	if ctx.cr[6].eq {
	pc = 0x823B58B4; continue 'dispatch;
	}
	// 823B585C: 817F011C  lwz r11, 0x11c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 823B5860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B5864: 419A0050  beq cr6, 0x823b58b4
	if ctx.cr[6].eq {
	pc = 0x823B58B4; continue 'dispatch;
	}
	// 823B5868: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B586C: 28060000  cmplwi r6, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B5870: 41820044  beq 0x823b58b4
	if ctx.cr[0].eq {
	pc = 0x823B58B4; continue 'dispatch;
	}
	// 823B5874: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B5878: 809F0120  lwz r4, 0x120(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 823B587C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B5880: 92A10064  stw r21, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	// 823B5884: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B5888: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 823B588C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823B5890: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B5894: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823B5898: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B589C: 38C6001C  addi r6, r6, 0x1c
	ctx.r[6].s64 = ctx.r[6].s64 + 28;
	// 823B58A0: 396B0700  addi r11, r11, 0x700
	ctx.r[11].s64 = ctx.r[11].s64 + 1792;
	// 823B58A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B58A8: 60840004  ori r4, r4, 4
	ctx.r[4].u64 = ctx.r[4].u64 | 4;
	// 823B58AC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B58B0: 48037D79  bl 0x823ed628
	ctx.lr = 0x823B58B4;
	sub_823ED628(ctx, base);
	pc = 0x823B58B4; continue 'dispatch;
            }
            0x823B58B4 => {
    //   block [0x823B58B4..0x823B58C4)
	// 823B58B4: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 823B58B8: 483579B5  bl 0x8270d26c
	ctx.lr = 0x823B58BC;
	// extern call 0x8270D26C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823B58BC: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 823B58C0: 4817F824  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B58C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B58C8 size=44
    let mut pc: u32 = 0x823B58C8;
    'dispatch: loop {
        match pc {
            0x823B58C8 => {
    //   block [0x823B58C8..0x823B58F4)
	// 823B58C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B58CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B58D0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B58D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B58D8: 386B1B94  addi r3, r11, 0x1b94
	ctx.r[3].s64 = ctx.r[11].s64 + 7060;
	// 823B58DC: 4817E9CD  bl 0x825342a8
	ctx.lr = 0x823B58E0;
	sub_825342A8(ctx, base);
	// 823B58E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B58E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823B58E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B58EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B58F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B58F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B58F8 size=44
    let mut pc: u32 = 0x823B58F8;
    'dispatch: loop {
        match pc {
            0x823B58F8 => {
    //   block [0x823B58F8..0x823B5924)
	// 823B58F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B58FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B5900: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B5904: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B5908: 386B1BC4  addi r3, r11, 0x1bc4
	ctx.r[3].s64 = ctx.r[11].s64 + 7108;
	// 823B590C: 4817E99D  bl 0x825342a8
	ctx.lr = 0x823B5910;
	sub_825342A8(ctx, base);
	// 823B5910: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B5914: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823B5918: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B591C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B5920: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B5928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B5928 size=12
    let mut pc: u32 = 0x823B5928;
    'dispatch: loop {
        match pc {
            0x823B5928 => {
    //   block [0x823B5928..0x823B5934)
	// 823B5928: A9640002  lha r11, 2(r4)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(2 as u32) ) } as i16) as i64;
	// 823B592C: 1C6B0003  mulli r3, r11, 3
	ctx.r[3].s32 = ((ctx.r[11].s32 as i64 * 3 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 823B5930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B5938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B5938 size=8
    let mut pc: u32 = 0x823B5938;
    'dispatch: loop {
        match pc {
            0x823B5938 => {
    //   block [0x823B5938..0x823B5940)
	// 823B5938: A8640000  lha r3, 0(r4)
	ctx.r[3].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823B593C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B5940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823B5940 size=60
    let mut pc: u32 = 0x823B5940;
    'dispatch: loop {
        match pc {
            0x823B5940 => {
    //   block [0x823B5940..0x823B597C)
	// 823B5940: 39650002  addi r11, r5, 2
	ctx.r[11].s64 = ctx.r[5].s64 + 2;
	// 823B5944: A94B0000  lha r10, 0(r11)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823B5948: 1D4A0003  mulli r10, r10, 3
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 3 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823B594C: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 823B5950: 7D4A31D6  mullw r10, r10, r6
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823B5954: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 823B5958: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823B595C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823B5960: 7D6A5AAE  lhax r11, r10, r11
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as i16) as i64;
	// 823B5964: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 823B5968: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B596C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823B5970: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823B5974: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823B5978: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B5980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823B5980 size=84
    let mut pc: u32 = 0x823B5980;
    'dispatch: loop {
        match pc {
            0x823B5980 => {
    //   block [0x823B5980..0x823B59A8)
	// 823B5980: 39650002  addi r11, r5, 2
	ctx.r[11].s64 = ctx.r[5].s64 + 2;
	// 823B5984: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 823B5988: A94B0000  lha r10, 0(r11)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823B598C: 1D4A0003  mulli r10, r10, 3
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 3 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823B5990: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 823B5994: 7D4A31D6  mullw r10, r10, r6
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823B5998: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823B599C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823B59A0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823B59A4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x823B59A8; continue 'dispatch;
            }
            0x823B59A8 => {
    //   block [0x823B59A8..0x823B59D4)
	// 823B59A8: A94B0000  lha r10, 0(r11)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823B59AC: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823B59B0: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 823B59B4: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 823B59B8: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823B59BC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823B59C0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823B59C4: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823B59C8: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 823B59CC: 4082FFDC  bne 0x823b59a8
	if !ctx.cr[0].eq {
	pc = 0x823B59A8; continue 'dispatch;
	}
	// 823B59D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B59D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823B59D8 size=152
    let mut pc: u32 = 0x823B59D8;
    'dispatch: loop {
        match pc {
            0x823B59D8 => {
    //   block [0x823B59D8..0x823B5A24)
	// 823B59D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B59DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823B59E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B59E4: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 823B59E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B59EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B59F0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823B59F4: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823B59F8: 554B07FF  clrlwi. r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B59FC: 41820028  beq 0x823b5a24
	if ctx.cr[0].eq {
	pc = 0x823B5A24; continue 'dispatch;
	}
	// 823B5A00: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B5A04: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 823B5A08: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823B5A0C: C0030014  lfs f0, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B5A10: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 823B5A14: C0030018  lfs f0, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B5A18: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 823B5A1C: C003001C  lfs f0, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B5A20: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	pc = 0x823B5A24; continue 'dispatch;
            }
            0x823B5A24 => {
    //   block [0x823B5A24..0x823B5A34)
	// 823B5A24: 554B07BD  rlwinm. r11, r10, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B5A28: 4182000C  beq 0x823b5a34
	if ctx.cr[0].eq {
	pc = 0x823B5A34; continue 'dispatch;
	}
	// 823B5A2C: C0230020  lfs f1, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823B5A30: 60840010  ori r4, r4, 0x10
	ctx.r[4].u64 = ctx.r[4].u64 | 16;
	pc = 0x823B5A34; continue 'dispatch;
            }
            0x823B5A34 => {
    //   block [0x823B5A34..0x823B5A44)
	// 823B5A34: 554B077B  rlwinm. r11, r10, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823B5A38: 4182000C  beq 0x823b5a44
	if ctx.cr[0].eq {
	pc = 0x823B5A44; continue 'dispatch;
	}
	// 823B5A3C: 81030024  lwz r8, 0x24(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 823B5A40: 60840020  ori r4, r4, 0x20
	ctx.r[4].u64 = ctx.r[4].u64 | 32;
	pc = 0x823B5A44; continue 'dispatch;
            }
            0x823B5A44 => {
    //   block [0x823B5A44..0x823B5A70)
	// 823B5A44: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B5A48: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823B5A4C: 396B0700  addi r11, r11, 0x700
	ctx.r[11].s64 = ctx.r[11].s64 + 1792;
	// 823B5A50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B5A54: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B5A58: 4803B521  bl 0x823f0f78
	ctx.lr = 0x823B5A5C;
	sub_823F0F78(ctx, base);
	// 823B5A5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B5A60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823B5A64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823B5A68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823B5A6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B5A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823B5A70 size=280
    let mut pc: u32 = 0x823B5A70;
    'dispatch: loop {
        match pc {
            0x823B5A70 => {
    //   block [0x823B5A70..0x823B5AD8)
	// 823B5A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B5A74: 4817F63D  bl 0x825350b0
	ctx.lr = 0x823B5A78;
	sub_82535080(ctx, base);
	// 823B5A78: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B5A7C: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B5A80: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B5A84: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823B5A88: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 823B5A8C: 7D1F4A14  add r8, r31, r9
	ctx.r[8].u64 = ctx.r[31].u64 + ctx.r[9].u64;
	// 823B5A90: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 823B5A94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B5A98: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 823B5A9C: 556A74BE  srwi r10, r11, 0x12
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(18);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823B5AA0: 556BEC7E  rlwinm r11, r11, 0x1d, 0x11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 823B5AA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823B5AA8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823B5AAC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823B5AB0: 419800C8  blt cr6, 0x823b5b78
	if ctx.cr[6].lt {
	pc = 0x823B5B78; continue 'dispatch;
	}
	// 823B5AB4: 83830018  lwz r28, 0x18(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 823B5AB8: 83630010  lwz r27, 0x10(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B5ABC: 7D1BE214  add r8, r27, r28
	ctx.r[8].u64 = ctx.r[27].u64 + ctx.r[28].u64;
	// 823B5AC0: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823B5AC4: 419800B4  blt cr6, 0x823b5b78
	if ctx.cr[6].lt {
	pc = 0x823B5B78; continue 'dispatch;
	}
	// 823B5AC8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823B5ACC: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 823B5AD0: 409A0008  bne cr6, 0x823b5ad8
	if !ctx.cr[6].eq {
	pc = 0x823B5AD8; continue 'dispatch;
	}
	// 823B5AD4: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	pc = 0x823B5AD8; continue 'dispatch;
            }
            0x823B5AD8 => {
    //   block [0x823B5AD8..0x823B5AE4)
	// 823B5AD8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823B5ADC: 409A0008  bne cr6, 0x823b5ae4
	if !ctx.cr[6].eq {
	pc = 0x823B5AE4; continue 'dispatch;
	}
	// 823B5AE0: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	pc = 0x823B5AE4; continue 'dispatch;
            }
            0x823B5AE4 => {
    //   block [0x823B5AE4..0x823B5B78)
	// 823B5AE4: 83A3001C  lwz r29, 0x1c(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 823B5AE8: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 823B5AEC: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 823B5AF0: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823B5AF4: 41990084  bgt cr6, 0x823b5b78
	if ctx.cr[6].gt {
	pc = 0x823B5B78; continue 'dispatch;
	}
	// 823B5AF8: 83C30020  lwz r30, 0x20(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 823B5AFC: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 823B5B00: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823B5B04: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823B5B08: 41990070  bgt cr6, 0x823b5b78
	if ctx.cr[6].gt {
	pc = 0x823B5B78; continue 'dispatch;
	}
	// 823B5B0C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B5B10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B5B14: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823B5B18: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 823B5B1C: 38CB001C  addi r6, r11, 0x1c
	ctx.r[6].s64 = ctx.r[11].s64 + 28;
	// 823B5B20: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 823B5B24: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B5B28: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 823B5B2C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B5B30: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 823B5B34: 396B0700  addi r11, r11, 0x700
	ctx.r[11].s64 = ctx.r[11].s64 + 1792;
	// 823B5B38: 90A10064  stw r5, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[5].u32 ) };
	// 823B5B3C: C0291FF8  lfs f1, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823B5B40: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 823B5B44: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B5B48: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823B5B4C: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 823B5B50: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B5B54: 7D7FD214  add r11, r31, r26
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[26].u64;
	// 823B5B58: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 823B5B5C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823B5B60: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 823B5B64: 7D7BE214  add r11, r27, r28
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[28].u64;
	// 823B5B68: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 823B5B6C: 48037ABD  bl 0x823ed628
	ctx.lr = 0x823B5B70;
	sub_823ED628(ctx, base);
	// 823B5B70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B5B74: 4800000C  b 0x823b5b80
	pc = 0x823B5B80; continue 'dispatch;
            }
            0x823B5B78 => {
    //   block [0x823B5B78..0x823B5B80)
	// 823B5B78: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823B5B7C: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	pc = 0x823B5B80; continue 'dispatch;
            }
            0x823B5B80 => {
    //   block [0x823B5B80..0x823B5B88)
	// 823B5B80: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 823B5B84: 4817F57C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B5B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823B5B88 size=220
    let mut pc: u32 = 0x823B5B88;
    'dispatch: loop {
        match pc {
            0x823B5B88 => {
    //   block [0x823B5B88..0x823B5C30)
	// 823B5B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B5B8C: 4817F531  bl 0x825350bc
	ctx.lr = 0x823B5B90;
	sub_82535080(ctx, base);
	// 823B5B90: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B5B94: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5B98: 28060000  cmplwi r6, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B5B9C: 418200C0  beq 0x823b5c5c
	if ctx.cr[0].eq {
	pc = 0x823B5C5C; continue 'dispatch;
	}
	// 823B5BA0: 8163011C  lwz r11, 0x11c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(284 as u32) ) } as u64;
	// 823B5BA4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823B5BA8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823B5BAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823B5BB0: 38C6001C  addi r6, r6, 0x1c
	ctx.r[6].s64 = ctx.r[6].s64 + 28;
	// 823B5BB4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B5BB8: 409A0078  bne cr6, 0x823b5c30
	if !ctx.cr[6].eq {
	pc = 0x823B5C30; continue 'dispatch;
	}
	// 823B5BBC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823B5BC0: 81630118  lwz r11, 0x118(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) } as u64;
	// 823B5BC4: C0030100  lfs f0, 0x100(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B5BC8: 83E30128  lwz r31, 0x128(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(296 as u32) ) } as u64;
	// 823B5BCC: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 823B5BD0: 83A30114  lwz r29, 0x114(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) } as u64;
	// 823B5BD4: C0030104  lfs f0, 0x104(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B5BD8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 823B5BDC: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 823B5BE0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B5BE4: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 823B5BE8: 557E077C  rlwinm r30, r11, 0, 0x1d, 0x1e
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823B5BEC: C0030108  lfs f0, 0x108(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B5BF0: 23DE0000  subfic r30, r30, 0
	ctx.xer.ca = ctx.r[30].u32 <= 0 as u32;
	ctx.r[30].s64 = (0 as i64) - ctx.r[30].s64;
	// 823B5BF4: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 823B5BF8: C003010C  lfs f0, 0x10c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823B5BFC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 823B5C00: 7FDEF110  subfe r30, r30, r30
	let x = (!ctx.r[30].u32);
	let y = ctx.r[30].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[30].u32 = res;
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 823B5C04: C0230110  lfs f1, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823B5C08: 3C608311  lis r3, -0x7cef
	ctx.r[3].s64 = -2096037888;
	// 823B5C0C: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 823B5C10: 517E45EE  rlwimi r30, r11, 8, 0x17, 0x17
	ctx.r[30].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x0000000000000100) | (ctx.r[30].u64 & 0xFFFFFFFFFFFFFEFF);
	// 823B5C14: 38630700  addi r3, r3, 0x700
	ctx.r[3].s64 = ctx.r[3].s64 + 1792;
	// 823B5C18: 57CB05AE  rlwinm r11, r30, 0, 0x16, 0x17
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 823B5C1C: 7D6BFB78  or r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[31].u64;
	// 823B5C20: 7D642378  or r4, r11, r4
	ctx.r[4].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 823B5C24: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B5C28: 48037A01  bl 0x823ed628
	ctx.lr = 0x823B5C2C;
	sub_823ED628(ctx, base);
	// 823B5C2C: 48000030  b 0x823b5c5c
	pc = 0x823B5C5C; continue 'dispatch;
            }
            0x823B5C30 => {
    //   block [0x823B5C30..0x823B5C5C)
	// 823B5C30: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B5C34: 81230120  lwz r9, 0x120(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(288 as u32) ) } as u64;
	// 823B5C38: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823B5C3C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B5C40: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823B5C44: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B5C48: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 823B5C4C: 396B0700  addi r11, r11, 0x700
	ctx.r[11].s64 = ctx.r[11].s64 + 1792;
	// 823B5C50: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 823B5C54: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B5C58: 480379D1  bl 0x823ed628
	ctx.lr = 0x823B5C5C;
	sub_823ED628(ctx, base);
	pc = 0x823B5C5C; continue 'dispatch;
            }
            0x823B5C5C => {
    //   block [0x823B5C5C..0x823B5C64)
	// 823B5C5C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823B5C60: 4817F4AC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B5C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823B5C68 size=164
    let mut pc: u32 = 0x823B5C68;
    'dispatch: loop {
        match pc {
            0x823B5C68 => {
    //   block [0x823B5C68..0x823B5CBC)
	// 823B5C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B5C6C: 4817F441  bl 0x825350ac
	ctx.lr = 0x823B5C70;
	sub_82535080(ctx, base);
	// 823B5C70: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 823B5C74: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B5C78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823B5C7C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5C80: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B5C84: 4182007C  beq 0x823b5d00
	if ctx.cr[0].eq {
	pc = 0x823B5D00; continue 'dispatch;
	}
	// 823B5C88: 815D0120  lwz r10, 0x120(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(288 as u32) ) } as u64;
	// 823B5C8C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823B5C90: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B5C94: 3B4B001C  addi r26, r11, 0x1c
	ctx.r[26].s64 = ctx.r[11].s64 + 28;
	// 823B5C98: 61590004  ori r25, r10, 4
	ctx.r[25].u64 = ctx.r[10].u64 | 4;
	// 823B5C9C: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 823B5CA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823B5CA4: 4099005C  ble cr6, 0x823b5d00
	if !ctx.cr[6].gt {
	pc = 0x823B5D00; continue 'dispatch;
	}
	// 823B5CA8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823B5CAC: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B5CB0: 3BFD000C  addi r31, r29, 0xc
	ctx.r[31].s64 = ctx.r[29].s64 + 12;
	// 823B5CB4: 3B8B0700  addi r28, r11, 0x700
	ctx.r[28].s64 = ctx.r[11].s64 + 1792;
	// 823B5CB8: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x823B5CBC; continue 'dispatch;
            }
            0x823B5CBC => {
    //   block [0x823B5CBC..0x823B5D00)
	// 823B5CBC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823B5CC0: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B5CC4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823B5CC8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823B5CCC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823B5CD0: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 823B5CD4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 823B5CD8: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 823B5CDC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 823B5CE0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823B5CE4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 823B5CE8: 48037941  bl 0x823ed628
	ctx.lr = 0x823B5CEC;
	sub_823ED628(ctx, base);
	// 823B5CEC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B5CF0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823B5CF4: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 823B5CF8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823B5CFC: 4198FFC0  blt cr6, 0x823b5cbc
	if ctx.cr[6].lt {
	pc = 0x823B5CBC; continue 'dispatch;
	}
	pc = 0x823B5D00; continue 'dispatch;
            }
            0x823B5D00 => {
    //   block [0x823B5D00..0x823B5D0C)
	// 823B5D00: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823B5D04: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 823B5D08: 4817F3F4  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B5D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B5D10 size=188
    let mut pc: u32 = 0x823B5D10;
    'dispatch: loop {
        match pc {
            0x823B5D10 => {
    //   block [0x823B5D10..0x823B5D6C)
	// 823B5D10: 7C8A20F8  nor r10, r4, r4
	ctx.r[10].u64 = !(ctx.r[4].u64 | ctx.r[4].u64);
	// 823B5D14: 548B073E  clrlwi r11, r4, 0x1c
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x0000000Fu64;
	// 823B5D18: 554AE7FE  rlwinm r10, r10, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 823B5D1C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 823B5D20: 91430124  stw r10, 0x124(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(292 as u32), ctx.r[10].u32 ) };
	// 823B5D24: 409A0078  bne cr6, 0x823b5d9c
	if !ctx.cr[6].eq {
	pc = 0x823B5D9C; continue 'dispatch;
	}
	// 823B5D28: 548B052E  rlwinm r11, r4, 0, 0x14, 0x17
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 823B5D2C: 2B0B0100  cmplwi cr6, r11, 0x100
	ctx.cr[6].compare_u32(ctx.r[11].u32, 256 as u32, &mut ctx.xer);
	// 823B5D30: 419A0064  beq cr6, 0x823b5d94
	if ctx.cr[6].eq {
	pc = 0x823B5D94; continue 'dispatch;
	}
	// 823B5D34: 2B0B0200  cmplwi cr6, r11, 0x200
	ctx.cr[6].compare_u32(ctx.r[11].u32, 512 as u32, &mut ctx.xer);
	// 823B5D38: 419A0054  beq cr6, 0x823b5d8c
	if ctx.cr[6].eq {
	pc = 0x823B5D8C; continue 'dispatch;
	}
	// 823B5D3C: 2B0B0300  cmplwi cr6, r11, 0x300
	ctx.cr[6].compare_u32(ctx.r[11].u32, 768 as u32, &mut ctx.xer);
	// 823B5D40: 419A0044  beq cr6, 0x823b5d84
	if ctx.cr[6].eq {
	pc = 0x823B5D84; continue 'dispatch;
	}
	// 823B5D44: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 823B5D48: 419A0034  beq cr6, 0x823b5d7c
	if ctx.cr[6].eq {
	pc = 0x823B5D7C; continue 'dispatch;
	}
	// 823B5D4C: 2B0B0500  cmplwi cr6, r11, 0x500
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1280 as u32, &mut ctx.xer);
	// 823B5D50: 419A0024  beq cr6, 0x823b5d74
	if ctx.cr[6].eq {
	pc = 0x823B5D74; continue 'dispatch;
	}
	// 823B5D54: 2B0B0600  cmplwi cr6, r11, 0x600
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1536 as u32, &mut ctx.xer);
	// 823B5D58: 419A0014  beq cr6, 0x823b5d6c
	if ctx.cr[6].eq {
	pc = 0x823B5D6C; continue 'dispatch;
	}
	// 823B5D5C: 2B0B0700  cmplwi cr6, r11, 0x700
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1792 as u32, &mut ctx.xer);
	// 823B5D60: 409A0060  bne cr6, 0x823b5dc0
	if !ctx.cr[6].eq {
	pc = 0x823B5DC0; continue 'dispatch;
	}
	// 823B5D64: 39600070  li r11, 0x70
	ctx.r[11].s64 = 112;
	// 823B5D68: 4800005C  b 0x823b5dc4
	pc = 0x823B5DC4; continue 'dispatch;
            }
            0x823B5D6C => {
    //   block [0x823B5D6C..0x823B5D74)
	// 823B5D6C: 39600060  li r11, 0x60
	ctx.r[11].s64 = 96;
	// 823B5D70: 48000054  b 0x823b5dc4
	pc = 0x823B5DC4; continue 'dispatch;
            }
            0x823B5D74 => {
    //   block [0x823B5D74..0x823B5D7C)
	// 823B5D74: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 823B5D78: 4800004C  b 0x823b5dc4
	pc = 0x823B5DC4; continue 'dispatch;
            }
            0x823B5D7C => {
    //   block [0x823B5D7C..0x823B5D84)
	// 823B5D7C: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 823B5D80: 48000044  b 0x823b5dc4
	pc = 0x823B5DC4; continue 'dispatch;
            }
            0x823B5D84 => {
    //   block [0x823B5D84..0x823B5D8C)
	// 823B5D84: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 823B5D88: 4800003C  b 0x823b5dc4
	pc = 0x823B5DC4; continue 'dispatch;
            }
            0x823B5D8C => {
    //   block [0x823B5D8C..0x823B5D94)
	// 823B5D8C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 823B5D90: 48000034  b 0x823b5dc4
	pc = 0x823B5DC4; continue 'dispatch;
            }
            0x823B5D94 => {
    //   block [0x823B5D94..0x823B5D9C)
	// 823B5D94: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 823B5D98: 4800002C  b 0x823b5dc4
	pc = 0x823B5DC4; continue 'dispatch;
            }
            0x823B5D9C => {
    //   block [0x823B5D9C..0x823B5DC0)
	// 823B5D9C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823B5DA0: 409A0020  bne cr6, 0x823b5dc0
	if !ctx.cr[6].eq {
	pc = 0x823B5DC0; continue 'dispatch;
	}
	// 823B5DA4: 548B052E  rlwinm r11, r4, 0, 0x14, 0x17
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 823B5DA8: 2B0B0100  cmplwi cr6, r11, 0x100
	ctx.cr[6].compare_u32(ctx.r[11].u32, 256 as u32, &mut ctx.xer);
	// 823B5DAC: 419AFFE8  beq cr6, 0x823b5d94
	if ctx.cr[6].eq {
	pc = 0x823B5D94; continue 'dispatch;
	}
	// 823B5DB0: 2B0B0200  cmplwi cr6, r11, 0x200
	ctx.cr[6].compare_u32(ctx.r[11].u32, 512 as u32, &mut ctx.xer);
	// 823B5DB4: 419AFFD8  beq cr6, 0x823b5d8c
	if ctx.cr[6].eq {
	pc = 0x823B5D8C; continue 'dispatch;
	}
	// 823B5DB8: 2B0B0500  cmplwi cr6, r11, 0x500
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1280 as u32, &mut ctx.xer);
	// 823B5DBC: 419AFFB8  beq cr6, 0x823b5d74
	if ctx.cr[6].eq {
	pc = 0x823B5D74; continue 'dispatch;
	}
	pc = 0x823B5DC0; continue 'dispatch;
            }
            0x823B5DC0 => {
    //   block [0x823B5DC0..0x823B5DC4)
	// 823B5DC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x823B5DC4; continue 'dispatch;
            }
            0x823B5DC4 => {
    //   block [0x823B5DC4..0x823B5DCC)
	// 823B5DC4: 91630128  stw r11, 0x128(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 823B5DC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B5DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823B5DD0 size=1312
    let mut pc: u32 = 0x823B5DD0;
    'dispatch: loop {
        match pc {
            0x823B5DD0 => {
    //   block [0x823B5DD0..0x823B5E10)
	// 823B5DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823B5DD4: 4817F2C5  bl 0x82535098
	ctx.lr = 0x823B5DD8;
	sub_82535080(ctx, base);
	// 823B5DD8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823B5DDC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 823B5DE0: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 823B5DE4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 823B5DE8: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 823B5DEC: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 823B5DF0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B5DF4: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
	// 823B5DF8: 7ED8B378  mr r24, r22
	ctx.r[24].u64 = ctx.r[22].u64;
	// 823B5DFC: 7F9F5A14  add r28, r31, r11
	ctx.r[28].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 823B5E00: 83BC0004  lwz r29, 4(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B5E04: 2C1D0000  cmpwi r29, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823B5E08: 40810054  ble 0x823b5e5c
	if !ctx.cr[0].gt {
	pc = 0x823B5E5C; continue 'dispatch;
	}
	// 823B5E0C: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	pc = 0x823B5E10; continue 'dispatch;
            }
            0x823B5E10 => {
    //   block [0x823B5E10..0x823B5E5C)
	// 823B5E10: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5E14: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 823B5E18: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 823B5E1C: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823B5E20: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823B5E24: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823B5E28: 7CCBF214  add r6, r11, r30
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823B5E2C: 7D4AF82E  lwzx r10, r10, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823B5E30: 7CAAFA14  add r5, r10, r31
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 823B5E34: 480045AD  bl 0x823ba3e0
	ctx.lr = 0x823B5E38;
	sub_823BA3E0(ctx, base);
	// 823B5E38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 823B5E3C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823B5E40: 480004C1  bl 0x823b6300
	ctx.lr = 0x823B5E44;
	sub_823B6300(ctx, base);
	// 823B5E44: 3963000F  addi r11, r3, 0xf
	ctx.r[11].s64 = ctx.r[3].s64 + 15;
	// 823B5E48: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823B5E4C: 556B0036  rlwinm r11, r11, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823B5E50: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 823B5E54: 7F0BC214  add r24, r11, r24
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 823B5E58: 4082FFB8  bne 0x823b5e10
	if !ctx.cr[0].eq {
	pc = 0x823B5E10; continue 'dispatch;
	}
	pc = 0x823B5E5C; continue 'dispatch;
            }
            0x823B5E5C => {
    //   block [0x823B5E5C..0x823B5E78)
	// 823B5E5C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B5E60: 7ED9B378  mr r25, r22
	ctx.r[25].u64 = ctx.r[22].u64;
	// 823B5E64: 7F9F5A14  add r28, r31, r11
	ctx.r[28].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 823B5E68: 83BC0004  lwz r29, 4(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B5E6C: 2C1D0000  cmpwi r29, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823B5E70: 40810054  ble 0x823b5ec4
	if !ctx.cr[0].gt {
	pc = 0x823B5EC4; continue 'dispatch;
	}
	// 823B5E74: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	pc = 0x823B5E78; continue 'dispatch;
            }
            0x823B5E78 => {
    //   block [0x823B5E78..0x823B5EC4)
	// 823B5E78: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5E7C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 823B5E80: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 823B5E84: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823B5E88: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823B5E8C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823B5E90: 7CCBF214  add r6, r11, r30
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823B5E94: 7D4AF82E  lwzx r10, r10, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823B5E98: 7CAAFA14  add r5, r10, r31
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 823B5E9C: 4800463D  bl 0x823ba4d8
	ctx.lr = 0x823B5EA0;
	sub_823BA4D8(ctx, base);
	// 823B5EA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 823B5EA4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823B5EA8: 48000459  bl 0x823b6300
	ctx.lr = 0x823B5EAC;
	sub_823B6300(ctx, base);
	// 823B5EAC: 3963000F  addi r11, r3, 0xf
	ctx.r[11].s64 = ctx.r[3].s64 + 15;
	// 823B5EB0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823B5EB4: 556B0036  rlwinm r11, r11, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823B5EB8: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 823B5EBC: 7F2BCA14  add r25, r11, r25
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 823B5EC0: 4082FFB8  bne 0x823b5e78
	if !ctx.cr[0].eq {
	pc = 0x823B5E78; continue 'dispatch;
	}
	pc = 0x823B5EC4; continue 'dispatch;
            }
            0x823B5EC4 => {
    //   block [0x823B5EC4..0x823B5EE8)
	// 823B5EC4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B5EC8: 7FD9C214  add r30, r25, r24
	ctx.r[30].u64 = ctx.r[25].u64 + ctx.r[24].u64;
	// 823B5ECC: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 823B5ED0: 7CDF5A14  add r6, r31, r11
	ctx.r[6].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 823B5ED4: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B5ED8: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823B5EDC: 40810048  ble 0x823b5f24
	if !ctx.cr[0].gt {
	pc = 0x823B5F24; continue 'dispatch;
	}
	// 823B5EE0: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5EE4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	pc = 0x823B5EE8; continue 'dispatch;
            }
            0x823B5EE8 => {
    //   block [0x823B5EE8..0x823B5EF4)
	// 823B5EE8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5EEC: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 823B5EF0: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x823B5EF4; continue 'dispatch;
            }
            0x823B5EF4 => {
    //   block [0x823B5EF4..0x823B5F24)
	// 823B5EF4: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5EF8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823B5EFC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 823B5F00: 409AFFF4  bne cr6, 0x823b5ef4
	if !ctx.cr[6].eq {
	pc = 0x823B5EF4; continue 'dispatch;
	}
	// 823B5F04: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 823B5F08: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B5F0C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823B5F10: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 823B5F14: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B5F18: 7D292A14  add r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 823B5F1C: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 823B5F20: 4082FFC8  bne 0x823b5ee8
	if !ctx.cr[0].eq {
	pc = 0x823B5EE8; continue 'dispatch;
	}
	pc = 0x823B5F24; continue 'dispatch;
            }
            0x823B5F24 => {
    //   block [0x823B5F24..0x823B5F44)
	// 823B5F24: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B5F28: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 823B5F2C: 7C9F5A14  add r4, r31, r11
	ctx.r[4].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 823B5F30: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B5F34: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823B5F38: 40810048  ble 0x823b5f80
	if !ctx.cr[0].gt {
	pc = 0x823B5F80; continue 'dispatch;
	}
	// 823B5F3C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5F40: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	pc = 0x823B5F44; continue 'dispatch;
            }
            0x823B5F44 => {
    //   block [0x823B5F44..0x823B5F50)
	// 823B5F44: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5F48: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 823B5F4C: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	pc = 0x823B5F50; continue 'dispatch;
            }
            0x823B5F50 => {
    //   block [0x823B5F50..0x823B5F80)
	// 823B5F50: 88690000  lbz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5F54: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823B5F58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823B5F5C: 409AFFF4  bne cr6, 0x823b5f50
	if !ctx.cr[6].eq {
	pc = 0x823B5F50; continue 'dispatch;
	}
	// 823B5F60: 7D274850  subf r9, r7, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 823B5F64: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B5F68: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823B5F6C: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 823B5F70: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B5F74: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 823B5F78: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 823B5F7C: 4082FFC8  bne 0x823b5f44
	if !ctx.cr[0].eq {
	pc = 0x823B5F44; continue 'dispatch;
	}
	pc = 0x823B5F80; continue 'dispatch;
            }
            0x823B5F80 => {
    //   block [0x823B5F80..0x823B5FA0)
	// 823B5F80: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B5F84: 7FA82A14  add r29, r8, r5
	ctx.r[29].u64 = ctx.r[8].u64 + ctx.r[5].u64;
	// 823B5F88: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 823B5F8C: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823B5F90: 4081004C  ble 0x823b5fdc
	if !ctx.cr[0].gt {
	pc = 0x823B5FDC; continue 'dispatch;
	}
	// 823B5F94: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5F98: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 823B5F9C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	pc = 0x823B5FA0; continue 'dispatch;
            }
            0x823B5FA0 => {
    //   block [0x823B5FA0..0x823B5FAC)
	// 823B5FA0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5FA4: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 823B5FA8: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x823B5FAC; continue 'dispatch;
            }
            0x823B5FAC => {
    //   block [0x823B5FAC..0x823B5FDC)
	// 823B5FAC: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5FB0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823B5FB4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 823B5FB8: 409AFFF4  bne cr6, 0x823b5fac
	if !ctx.cr[6].eq {
	pc = 0x823B5FAC; continue 'dispatch;
	}
	// 823B5FBC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 823B5FC0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B5FC4: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823B5FC8: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 823B5FCC: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B5FD0: 7D292A14  add r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 823B5FD4: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 823B5FD8: 4082FFC8  bne 0x823b5fa0
	if !ctx.cr[0].eq {
	pc = 0x823B5FA0; continue 'dispatch;
	}
	pc = 0x823B5FDC; continue 'dispatch;
            }
            0x823B5FDC => {
    //   block [0x823B5FDC..0x823B5FF8)
	// 823B5FDC: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B5FE0: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 823B5FE4: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823B5FE8: 4081004C  ble 0x823b6034
	if !ctx.cr[0].gt {
	pc = 0x823B6034; continue 'dispatch;
	}
	// 823B5FEC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5FF0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823B5FF4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	pc = 0x823B5FF8; continue 'dispatch;
            }
            0x823B5FF8 => {
    //   block [0x823B5FF8..0x823B6004)
	// 823B5FF8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B5FFC: 7D3F4A14  add r9, r31, r9
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[9].u64;
	// 823B6000: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	pc = 0x823B6004; continue 'dispatch;
            }
            0x823B6004 => {
    //   block [0x823B6004..0x823B6034)
	// 823B6004: 88C90000  lbz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B6008: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823B600C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 823B6010: 409AFFF4  bne cr6, 0x823b6004
	if !ctx.cr[6].eq {
	pc = 0x823B6004; continue 'dispatch;
	}
	// 823B6014: 7D274850  subf r9, r7, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 823B6018: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B601C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823B6020: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 823B6024: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B6028: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 823B602C: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 823B6030: 4082FFC8  bne 0x823b5ff8
	if !ctx.cr[0].eq {
	pc = 0x823B5FF8; continue 'dispatch;
	}
	pc = 0x823B6034; continue 'dispatch;
            }
            0x823B6034 => {
    //   block [0x823B6034..0x823B6044)
	// 823B6034: 7D682A14  add r11, r8, r5
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[5].u64;
	// 823B6038: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 823B603C: 7C8BF215  add. r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823B6040: 40820014  bne 0x823b6054
	if !ctx.cr[0].eq {
	pc = 0x823B6054; continue 'dispatch;
	}
	pc = 0x823B6044; continue 'dispatch;
            }
            0x823B6044 => {
    //   block [0x823B6044..0x823B6054)
	// 823B6044: 92D50000  stw r22, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 823B6048: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823B604C: 92D40000  stw r22, 0(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 823B6050: 48000298  b 0x823b62e8
	pc = 0x823B62E8; continue 'dispatch;
            }
            0x823B6054 => {
    //   block [0x823B6054..0x823B608C)
	// 823B6054: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823B6058: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823B605C: 386BF400  addi r3, r11, -0xc00
	ctx.r[3].s64 = ctx.r[11].s64 + -3072;
	// 823B6060: 4BFE9979  bl 0x8239f9d8
	ctx.lr = 0x823B6064;
	sub_8239F9D8(ctx, base);
	// 823B6064: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 823B6068: 4182FFDC  beq 0x823b6044
	if ctx.cr[0].eq {
	pc = 0x823B6044; continue 'dispatch;
	}
	// 823B606C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B6070: 7CBBF214  add r5, r27, r30
	ctx.r[5].u64 = ctx.r[27].u64 + ctx.r[30].u64;
	// 823B6074: 7CDF5A14  add r6, r31, r11
	ctx.r[6].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 823B6078: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 823B607C: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B6080: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823B6084: 4081006C  ble 0x823b60f0
	if !ctx.cr[0].gt {
	pc = 0x823B60F0; continue 'dispatch;
	}
	// 823B6088: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x823B608C; continue 'dispatch;
            }
            0x823B608C => {
    //   block [0x823B608C..0x823B60A0)
	// 823B608C: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B6090: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 823B6094: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823B6098: 7D29F82E  lwzx r9, r9, r31
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823B609C: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	pc = 0x823B60A0; continue 'dispatch;
            }
            0x823B60A0 => {
    //   block [0x823B60A0..0x823B60C0)
	// 823B60A0: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B60A4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823B60A8: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B60AC: 98E80000  stb r7, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 823B60B0: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823B60B4: 4082FFEC  bne 0x823b60a0
	if !ctx.cr[0].eq {
	pc = 0x823B60A0; continue 'dispatch;
	}
	// 823B60B8: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 823B60BC: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x823B60C0; continue 'dispatch;
            }
            0x823B60C0 => {
    //   block [0x823B60C0..0x823B60F0)
	// 823B60C0: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B60C4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823B60C8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 823B60CC: 409AFFF4  bne cr6, 0x823b60c0
	if !ctx.cr[6].eq {
	pc = 0x823B60C0; continue 'dispatch;
	}
	// 823B60D0: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 823B60D4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B60D8: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823B60DC: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 823B60E0: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B60E4: 7D29E214  add r9, r9, r28
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[28].u64;
	// 823B60E8: 3B890001  addi r28, r9, 1
	ctx.r[28].s64 = ctx.r[9].s64 + 1;
	// 823B60EC: 4082FFA0  bne 0x823b608c
	if !ctx.cr[0].eq {
	pc = 0x823B608C; continue 'dispatch;
	}
	pc = 0x823B60F0; continue 'dispatch;
            }
            0x823B60F0 => {
    //   block [0x823B60F0..0x823B6110)
	// 823B60F0: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B60F4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 823B60F8: 7C9F5214  add r4, r31, r10
	ctx.r[4].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 823B60FC: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B6100: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823B6104: 40810070  ble 0x823b6174
	if !ctx.cr[0].gt {
	pc = 0x823B6174; continue 'dispatch;
	}
	// 823B6108: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 823B610C: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	pc = 0x823B6110; continue 'dispatch;
            }
            0x823B6110 => {
    //   block [0x823B6110..0x823B6124)
	// 823B6110: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B6114: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 823B6118: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 823B611C: 7D29F82E  lwzx r9, r9, r31
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823B6120: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	pc = 0x823B6124; continue 'dispatch;
            }
            0x823B6124 => {
    //   block [0x823B6124..0x823B6144)
	// 823B6124: 88C90000  lbz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B6128: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823B612C: 28060000  cmplwi r6, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B6130: 98C80000  stb r6, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u8 ) };
	// 823B6134: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823B6138: 4082FFEC  bne 0x823b6124
	if !ctx.cr[0].eq {
	pc = 0x823B6124; continue 'dispatch;
	}
	// 823B613C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 823B6140: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x823B6144; continue 'dispatch;
            }
            0x823B6144 => {
    //   block [0x823B6144..0x823B6174)
	// 823B6144: 88C90000  lbz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B6148: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823B614C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 823B6150: 409AFFF4  bne cr6, 0x823b6144
	if !ctx.cr[6].eq {
	pc = 0x823B6144; continue 'dispatch;
	}
	// 823B6154: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 823B6158: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823B615C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823B6160: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 823B6164: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B6168: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823B616C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823B6170: 4082FFA0  bne 0x823b6110
	if !ctx.cr[0].eq {
	pc = 0x823B6110; continue 'dispatch;
	}
	pc = 0x823B6174; continue 'dispatch;
            }
            0x823B6174 => {
    //   block [0x823B6174..0x823B6194)
	// 823B6174: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823B6178: 7CC5EA14  add r6, r5, r29
	ctx.r[6].u64 = ctx.r[5].u64 + ctx.r[29].u64;
	// 823B617C: 7C9F5A14  add r4, r31, r11
	ctx.r[4].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 823B6180: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823B6184: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B6188: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823B618C: 40810070  ble 0x823b61fc
	if !ctx.cr[0].gt {
	pc = 0x823B61FC; continue 'dispatch;
	}
	// 823B6190: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x823B6194; continue 'dispatch;
            }
            0x823B6194 => {
    //   block [0x823B6194..0x823B61AC)
	// 823B6194: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B6198: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 823B619C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823B61A0: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 823B61A4: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B61A8: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	pc = 0x823B61AC; continue 'dispatch;
            }
            0x823B61AC => {
    //   block [0x823B61AC..0x823B61CC)
	// 823B61AC: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B61B0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823B61B4: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B61B8: 98E80000  stb r7, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 823B61BC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823B61C0: 4082FFEC  bne 0x823b61ac
	if !ctx.cr[0].eq {
	pc = 0x823B61AC; continue 'dispatch;
	}
	// 823B61C4: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 823B61C8: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x823B61CC; continue 'dispatch;
            }
            0x823B61CC => {
    //   block [0x823B61CC..0x823B61FC)
	// 823B61CC: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B61D0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823B61D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 823B61D8: 409AFFF4  bne cr6, 0x823b61cc
	if !ctx.cr[6].eq {
	pc = 0x823B61CC; continue 'dispatch;
	}
	// 823B61DC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 823B61E0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823B61E4: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823B61E8: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 823B61EC: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B61F0: 7D29EA14  add r9, r9, r29
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 823B61F4: 3BA90001  addi r29, r9, 1
	ctx.r[29].s64 = ctx.r[9].s64 + 1;
	// 823B61F8: 4082FF9C  bne 0x823b6194
	if !ctx.cr[0].eq {
	pc = 0x823B6194; continue 'dispatch;
	}
	pc = 0x823B61FC; continue 'dispatch;
            }
            0x823B61FC => {
    //   block [0x823B61FC..0x823B621C)
	// 823B61FC: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823B6200: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823B6204: 7C7F5214  add r3, r31, r10
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 823B6208: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823B620C: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823B6210: 40810074  ble 0x823b6284
	if !ctx.cr[0].gt {
	pc = 0x823B6284; continue 'dispatch;
	}
	// 823B6214: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 823B6218: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	pc = 0x823B621C; continue 'dispatch;
            }
            0x823B621C => {
    //   block [0x823B621C..0x823B6234)
	// 823B621C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B6220: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 823B6224: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 823B6228: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 823B622C: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 823B6230: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	pc = 0x823B6234; continue 'dispatch;
            }
            0x823B6234 => {
    //   block [0x823B6234..0x823B6254)
	// 823B6234: 88890000  lbz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B6238: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823B623C: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823B6240: 98880000  stb r4, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 823B6244: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823B6248: 4082FFEC  bne 0x823b6234
	if !ctx.cr[0].eq {
	pc = 0x823B6234; continue 'dispatch;
	}
	// 823B624C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 823B6250: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x823B6254; continue 'dispatch;
            }
            0x823B6254 => {
    //   block [0x823B6254..0x823B6284)
	// 823B6254: 88890000  lbz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823B6258: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823B625C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823B6260: 409AFFF4  bne cr6, 0x823b6254
	if !ctx.cr[6].eq {
	pc = 0x823B6254; continue 'dispatch;
	}
	// 823B6264: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 823B6268: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823B626C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823B6270: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 823B6274: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823B6278: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823B627C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823B6280: 4082FF9C  bne 0x823b621c
	if !ctx.cr[0].eq {
	pc = 0x823B621C; continue 'dispatch;
	}
	pc = 0x823B6284; continue 'dispatch;
            }
            0x823B6284 => {
    //   block [0x823B6284..0x823B62B0)
	// 823B6284: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 823B6288: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 823B628C: 419A0024  beq cr6, 0x823b62b0
	if ctx.cr[6].eq {
	pc = 0x823B62B0; continue 'dispatch;
	}
	// 823B6290: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 823B6294: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 823B6298: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823B629C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823B62A0: 48003CB1  bl 0x823b9f50
	ctx.lr = 0x823B62A4;
	sub_823B9F50(ctx, base);
	// 823B62A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823B62A8: 93750000  stw r27, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 823B62AC: 48000008  b 0x823b62b4
	pc = 0x823B62B4; continue 'dispatch;
            }
            0x823B62B0 => {
    //   block [0x823B62B0..0x823B62B4)
	// 823B62B0: 92D50000  stw r22, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	pc = 0x823B62B4; continue 'dispatch;
            }
            0x823B62B4 => {
    //   block [0x823B62B4..0x823B62E0)
	// 823B62B4: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 823B62B8: 419A0028  beq cr6, 0x823b62e0
	if ctx.cr[6].eq {
	pc = 0x823B62E0; continue 'dispatch;
	}
	// 823B62BC: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 823B62C0: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 823B62C4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823B62C8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823B62CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823B62D0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823B62D4: 48003E05  bl 0x823ba0d8
	ctx.lr = 0x823B62D8;
	sub_823BA0D8(ctx, base);
	// 823B62D8: 93D40000  stw r30, 0(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823B62DC: 48000008  b 0x823b62e4
	pc = 0x823B62E4; continue 'dispatch;
            }
            0x823B62E0 => {
    //   block [0x823B62E0..0x823B62E4)
	// 823B62E0: 92D40000  stw r22, 0(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	pc = 0x823B62E4; continue 'dispatch;
            }
            0x823B62E4 => {
    //   block [0x823B62E4..0x823B62E8)
	// 823B62E4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	pc = 0x823B62E8; continue 'dispatch;
            }
            0x823B62E8 => {
    //   block [0x823B62E8..0x823B62F0)
	// 823B62E8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823B62EC: 4817EDFC  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B62F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B62F0 size=16
    let mut pc: u32 = 0x823B62F0;
    'dispatch: loop {
        match pc {
            0x823B62F0 => {
    //   block [0x823B62F0..0x823B6300)
	// 823B62F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823B62F4: 396B1CA0  addi r11, r11, 0x1ca0
	ctx.r[11].s64 = ctx.r[11].s64 + 7328;
	// 823B62F8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823B62FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823B6300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823B6300 size=52
    let mut pc: u32 = 0x823B6300;
    'dispatch: loop {
        match pc {
            0x823B6300 => {
    //   block [0x823B6300..0x823B632C)
	// 823B6300: 2F040005  cmpwi cr6, r4, 5
	ctx.cr[6].compare_i32(ctx.r[4].s32, 5, &mut ctx.xer);
	// 823B6304: 41990048  bgt cr6, 0x823b634c
	if ctx.cr[6].gt {
		sub_823B634C(ctx, base);
		return;
	}
	// 823B6308: 419A0024  beq cr6, 0x823b632c
	if ctx.cr[6].eq {
	pc = 0x823B632C; continue 'dispatch;
	}
	// 823B630C: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 823B6310: 41980034  blt cr6, 0x823b6344
	if ctx.cr[6].lt {
		sub_823B6344(ctx, base);
		return;
	}
	// 823B6314: 419A0028  beq cr6, 0x823b633c
	if ctx.cr[6].eq {
		sub_823B633C(ctx, base);
		return;
	}
	// 823B6318: 2B040003  cmplwi cr6, r4, 3
	ctx.cr[6].compare_u32(ctx.r[4].u32, 3 as u32, &mut ctx.xer);
	// 823B631C: 41980018  blt cr6, 0x823b6334
	if ctx.cr[6].lt {
		sub_823B6334(ctx, base);
		return;
	}
	// 823B6320: 419A000C  beq cr6, 0x823b632c
	if ctx.cr[6].eq {
	pc = 0x823B632C; continue 'dispatch;
	}
	// 823B6324: 2B040005  cmplwi cr6, r4, 5
	ctx.cr[6].compare_u32(ctx.r[4].u32, 5 as u32, &mut ctx.xer);
	// 823B6328: 40980044  bge cr6, 0x823b636c
	if !ctx.cr[6].lt {
		sub_823B634C(ctx, base);
		return;
	}
	pc = 0x823B632C; continue 'dispatch;
            }
            0x823B632C => {
    //   block [0x823B632C..0x823B6334)
	// 823B632C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 823B6330: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


