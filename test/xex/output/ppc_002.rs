pub fn sub_82199A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82199A90 size=296
    let mut pc: u32 = 0x82199A90;
    'dispatch: loop {
        match pc {
            0x82199A90 => {
    //   block [0x82199A90..0x82199ABC)
	// 82199A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82199A94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82199A98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82199A9C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82199AA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82199AA4: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82199AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199AAC: 41990010  bgt cr6, 0x82199abc
	if ctx.cr[6].gt {
	pc = 0x82199ABC; continue 'dispatch;
	}
	// 82199AB0: 389F0054  addi r4, r31, 0x54
	ctx.r[4].s64 = ctx.r[31].s64 + 84;
	// 82199AB4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82199AB8: 480CB6E9  bl 0x822651a0
	ctx.lr = 0x82199ABC;
	sub_822651A0(ctx, base);
	pc = 0x82199ABC; continue 'dispatch;
            }
            0x82199ABC => {
    //   block [0x82199ABC..0x82199B20)
	// 82199ABC: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82199AC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199AC4: 419A007C  beq cr6, 0x82199b40
	if ctx.cr[6].eq {
	pc = 0x82199B40; continue 'dispatch;
	}
	// 82199AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82199ACC: 481053AD  bl 0x8229ee78
	ctx.lr = 0x82199AD0;
	sub_8229EE78(ctx, base);
	// 82199AD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199AD4: 419A006C  beq cr6, 0x82199b40
	if ctx.cr[6].eq {
	pc = 0x82199B40; continue 'dispatch;
	}
	// 82199AD8: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82199ADC: 4808577D  bl 0x8221f258
	ctx.lr = 0x82199AE0;
	sub_8221F258(ctx, base);
	// 82199AE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199AE4: 419A003C  beq cr6, 0x82199b20
	if ctx.cr[6].eq {
	pc = 0x82199B20; continue 'dispatch;
	}
	// 82199AE8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82199AEC: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82199AF0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82199AF4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82199AF8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82199AFC: 38E9B6C0  addi r7, r9, -0x4940
	ctx.r[7].s64 = ctx.r[9].s64 + -18752;
	// 82199B00: C00B9040  lfs f0, -0x6fc0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28608 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199B04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82199B08: C1AA9484  lfs f13, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82199B0C: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82199B10: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82199B14: 99030010  stb r8, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[8].u8 ) };
	// 82199B18: D1A3000C  stfs f13, 0xc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82199B1C: 48000008  b 0x82199b24
	pc = 0x82199B24; continue 'dispatch;
            }
            0x82199B20 => {
    //   block [0x82199B20..0x82199B24)
	// 82199B20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82199B24; continue 'dispatch;
            }
            0x82199B24 => {
    //   block [0x82199B24..0x82199B40)
	// 82199B24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82199B28: 48021F89  bl 0x821bbab0
	ctx.lr = 0x82199B2C;
	sub_821BBAB0(ctx, base);
	// 82199B2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82199B30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82199B34: 480D2335  bl 0x8226be68
	ctx.lr = 0x82199B38;
	sub_8226BE68(ctx, base);
	// 82199B38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82199B3C: 4801DFDD  bl 0x821b7b18
	ctx.lr = 0x82199B40;
	sub_821B7B18(ctx, base);
	pc = 0x82199B40; continue 'dispatch;
            }
            0x82199B40 => {
    //   block [0x82199B40..0x82199B84)
	// 82199B40: 897F0069  lbz r11, 0x69(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(105 as u32) ) } as u64;
	// 82199B44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199B48: 419A005C  beq cr6, 0x82199ba4
	if ctx.cr[6].eq {
	pc = 0x82199BA4; continue 'dispatch;
	}
	// 82199B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82199B50: 48105329  bl 0x8229ee78
	ctx.lr = 0x82199B54;
	sub_8229EE78(ctx, base);
	// 82199B54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199B58: 419A004C  beq cr6, 0x82199ba4
	if ctx.cr[6].eq {
	pc = 0x82199BA4; continue 'dispatch;
	}
	// 82199B5C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82199B60: 480856F9  bl 0x8221f258
	ctx.lr = 0x82199B64;
	sub_8221F258(ctx, base);
	// 82199B64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199B68: 419A001C  beq cr6, 0x82199b84
	if ctx.cr[6].eq {
	pc = 0x82199B84; continue 'dispatch;
	}
	// 82199B6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199B70: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82199B74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82199B78: 394BB6F8  addi r10, r11, -0x4908
	ctx.r[10].s64 = ctx.r[11].s64 + -18696;
	// 82199B7C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82199B80: 48000008  b 0x82199b88
	pc = 0x82199B88; continue 'dispatch;
            }
            0x82199B84 => {
    //   block [0x82199B84..0x82199B88)
	// 82199B84: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82199B88; continue 'dispatch;
            }
            0x82199B88 => {
    //   block [0x82199B88..0x82199BA4)
	// 82199B88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82199B8C: 48021F25  bl 0x821bbab0
	ctx.lr = 0x82199B90;
	sub_821BBAB0(ctx, base);
	// 82199B90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82199B94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82199B98: 480D22D1  bl 0x8226be68
	ctx.lr = 0x82199B9C;
	sub_8226BE68(ctx, base);
	// 82199B9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82199BA0: 4801DF79  bl 0x821b7b18
	ctx.lr = 0x82199BA4;
	sub_821B7B18(ctx, base);
	pc = 0x82199BA4; continue 'dispatch;
            }
            0x82199BA4 => {
    //   block [0x82199BA4..0x82199BB8)
	// 82199BA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82199BA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82199BAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82199BB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82199BB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82199BB8 size=1300
    let mut pc: u32 = 0x82199BB8;
    'dispatch: loop {
        match pc {
            0x82199BB8 => {
    //   block [0x82199BB8..0x82199C10)
	// 82199BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82199BBC: 48B0F839  bl 0x82ca93f4
	ctx.lr = 0x82199BC0;
	sub_82CA93D0(ctx, base);
	// 82199BC0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82199BC4: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 82199BC8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82199BCC: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82199BD0: 3F80834C  lis r28, -0x7cb4
	ctx.r[28].s64 = -2092171264;
	// 82199BD4: 816A3AC4  lwz r11, 0x3ac4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15044 as u32) ) } as u64;
	// 82199BD8: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82199BDC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82199BE0: 409A0030  bne cr6, 0x82199c10
	if !ctx.cr[6].eq {
	pc = 0x82199C10; continue 'dispatch;
	}
	// 82199BE4: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 82199BE8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82199BEC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82199BF0: 916A3AC4  stw r11, 0x3ac4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15044 as u32), ctx.r[11].u32 ) };
	// 82199BF4: C8099660  lfd f0, -0x69a0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-27040 as u32) ) };
	// 82199BF8: C9A80DF0  lfd f13, 0xdf0(r8)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(3568 as u32) ) };
	// 82199BFC: FC000372  fmul f0, f0, f13
	ctx.f[0].f64 = ctx.f[0].f64 * ctx.f[13].f64;
	// 82199C00: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82199C04: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 82199C08: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82199C0C: 90FC3AC0  stw r7, 0x3ac0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(15040 as u32), ctx.r[7].u32 ) };
	pc = 0x82199C10; continue 'dispatch;
            }
            0x82199C10 => {
    //   block [0x82199C10..0x82199C38)
	// 82199C10: 83DB0034  lwz r30, 0x34(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 82199C14: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82199C18: 817B0038  lwz r11, 0x38(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 82199C1C: 3BFB0028  addi r31, r27, 0x28
	ctx.r[31].s64 = ctx.r[27].s64 + 40;
	// 82199C20: 7F59D378  mr r25, r26
	ctx.r[25].u64 = ctx.r[26].u64;
	// 82199C24: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82199C28: 7F58D378  mr r24, r26
	ctx.r[24].u64 = ctx.r[26].u64;
	// 82199C2C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82199C30: 40990008  ble cr6, 0x82199c38
	if !ctx.cr[6].gt {
	pc = 0x82199C38; continue 'dispatch;
	}
	// 82199C34: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82199C38; continue 'dispatch;
            }
            0x82199C38 => {
    //   block [0x82199C38..0x82199C3C)
	// 82199C38: 3FA08332  lis r29, -0x7cce
	ctx.r[29].s64 = -2093875200;
	pc = 0x82199C3C; continue 'dispatch;
            }
            0x82199C3C => {
    //   block [0x82199C3C..0x82199C54)
	// 82199C3C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82199C40: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82199C44: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82199C48: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82199C4C: 40990008  ble cr6, 0x82199c54
	if !ctx.cr[6].gt {
	pc = 0x82199C54; continue 'dispatch;
	}
	// 82199C50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82199C54; continue 'dispatch;
            }
            0x82199C54 => {
    //   block [0x82199C54..0x82199C60)
	// 82199C54: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82199C58: 419A0008  beq cr6, 0x82199c60
	if ctx.cr[6].eq {
	pc = 0x82199C60; continue 'dispatch;
	}
	// 82199C5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82199C60; continue 'dispatch;
            }
            0x82199C60 => {
    //   block [0x82199C60..0x82199C84)
	// 82199C60: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82199C64: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 82199C68: 419A0110  beq cr6, 0x82199d78
	if ctx.cr[6].eq {
	pc = 0x82199D78; continue 'dispatch;
	}
	// 82199C6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199C70: 409A00E8  bne cr6, 0x82199d58
	if !ctx.cr[6].eq {
	pc = 0x82199D58; continue 'dispatch;
	}
	// 82199C74: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82199C78: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82199C7C: 41980008  blt cr6, 0x82199c84
	if ctx.cr[6].lt {
	pc = 0x82199C84; continue 'dispatch;
	}
	// 82199C80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82199C84; continue 'dispatch;
            }
            0x82199C84 => {
    //   block [0x82199C84..0x82199C94)
	// 82199C84: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82199C88: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82199C8C: 41990008  bgt cr6, 0x82199c94
	if ctx.cr[6].gt {
	pc = 0x82199C94; continue 'dispatch;
	}
	// 82199C90: 7D2BF050  subf r9, r11, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	pc = 0x82199C94; continue 'dispatch;
            }
            0x82199C94 => {
    //   block [0x82199C94..0x82199CC0)
	// 82199C94: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82199C98: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82199C9C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82199CA0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82199CA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199CA8: 419A001C  beq cr6, 0x82199cc4
	if ctx.cr[6].eq {
	pc = 0x82199CC4; continue 'dispatch;
	}
	// 82199CAC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82199CB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82199CB4: 419A000C  beq cr6, 0x82199cc0
	if ctx.cr[6].eq {
	pc = 0x82199CC0; continue 'dispatch;
	}
	// 82199CB8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82199CBC: 4800000C  b 0x82199cc8
	pc = 0x82199CC8; continue 'dispatch;
            }
            0x82199CC0 => {
    //   block [0x82199CC0..0x82199CC4)
	// 82199CC0: 4BFFA179  bl 0x82193e38
	ctx.lr = 0x82199CC4;
	sub_82193E38(ctx, base);
	pc = 0x82199CC4; continue 'dispatch;
            }
            0x82199CC4 => {
    //   block [0x82199CC4..0x82199CC8)
	// 82199CC4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82199CC8; continue 'dispatch;
            }
            0x82199CC8 => {
    //   block [0x82199CC8..0x82199CEC)
	// 82199CC8: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82199CCC: 409A008C  bne cr6, 0x82199d58
	if !ctx.cr[6].eq {
	pc = 0x82199D58; continue 'dispatch;
	}
	// 82199CD0: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82199CD4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82199CD8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82199CDC: 7CE95214  add r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82199CE0: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82199CE4: 41980008  blt cr6, 0x82199cec
	if ctx.cr[6].lt {
	pc = 0x82199CEC; continue 'dispatch;
	}
	// 82199CE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82199CEC; continue 'dispatch;
            }
            0x82199CEC => {
    //   block [0x82199CEC..0x82199CFC)
	// 82199CEC: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82199CF0: 7F06F040  cmplw cr6, r6, r30
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82199CF4: 41990008  bgt cr6, 0x82199cfc
	if ctx.cr[6].gt {
	pc = 0x82199CFC; continue 'dispatch;
	}
	// 82199CF8: 7D66F050  subf r11, r6, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[6].s64;
	pc = 0x82199CFC; continue 'dispatch;
            }
            0x82199CFC => {
    //   block [0x82199CFC..0x82199D3C)
	// 82199CFC: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82199D00: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82199D04: 817B0020  lwz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 82199D08: 813C3AC0  lwz r9, 0x3ac0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(15040 as u32) ) } as u64;
	// 82199D0C: 80BD9650  lwz r5, -0x69b0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 82199D10: 7C8A402E  lwzx r4, r10, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82199D14: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82199D18: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82199D1C: 7C6B4A14  add r3, r11, r9
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82199D20: 7F032800  cmpw cr6, r3, r5
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82199D24: 40990034  ble cr6, 0x82199d58
	if !ctx.cr[6].gt {
	pc = 0x82199D58; continue 'dispatch;
	}
	// 82199D28: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82199D2C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82199D30: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82199D34: 41980008  blt cr6, 0x82199d3c
	if ctx.cr[6].lt {
	pc = 0x82199D3C; continue 'dispatch;
	}
	// 82199D38: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82199D3C; continue 'dispatch;
            }
            0x82199D3C => {
    //   block [0x82199D3C..0x82199D48)
	// 82199D3C: 7F06F040  cmplw cr6, r6, r30
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82199D40: 41990008  bgt cr6, 0x82199d48
	if ctx.cr[6].gt {
	pc = 0x82199D48; continue 'dispatch;
	}
	// 82199D44: 7D66F050  subf r11, r6, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[6].s64;
	pc = 0x82199D48; continue 'dispatch;
            }
            0x82199D48 => {
    //   block [0x82199D48..0x82199D58)
	// 82199D48: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82199D4C: 815D9650  lwz r10, -0x69b0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 82199D50: 7D2B402E  lwzx r9, r11, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82199D54: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82199D58; continue 'dispatch;
            }
            0x82199D58 => {
    //   block [0x82199D58..0x82199D70)
	// 82199D58: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82199D5C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82199D60: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82199D64: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82199D68: 41980008  blt cr6, 0x82199d70
	if ctx.cr[6].lt {
	pc = 0x82199D70; continue 'dispatch;
	}
	// 82199D6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82199D70; continue 'dispatch;
            }
            0x82199D70 => {
    //   block [0x82199D70..0x82199D78)
	// 82199D70: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82199D74: 4BFFFEC8  b 0x82199c3c
	pc = 0x82199C3C; continue 'dispatch;
            }
            0x82199D78 => {
    //   block [0x82199D78..0x82199DC4)
	// 82199D78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199D7C: 409A0130  bne cr6, 0x82199eac
	if !ctx.cr[6].eq {
	pc = 0x82199EAC; continue 'dispatch;
	}
	// 82199D80: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82199D84: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82199D88: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82199D8C: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 82199D90: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82199D94: 419A00F4  beq cr6, 0x82199e88
	if ctx.cr[6].eq {
	pc = 0x82199E88; continue 'dispatch;
	}
	// 82199D98: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82199D9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82199DA0: 419A0024  beq cr6, 0x82199dc4
	if ctx.cr[6].eq {
	pc = 0x82199DC4; continue 'dispatch;
	}
	// 82199DA4: 892A0022  lbz r9, 0x22(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(34 as u32) ) } as u64;
	// 82199DA8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82199DAC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82199DB0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82199DB4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82199DB8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82199DBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82199DC0: 480000CC  b 0x82199e8c
	pc = 0x82199E8C; continue 'dispatch;
            }
            0x82199DC4 => {
    //   block [0x82199DC4..0x82199DE0)
	// 82199DC4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82199DC8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82199DCC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82199DD0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82199DD4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82199DD8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82199DDC: 40810054  ble 0x82199e30
	if !ctx.cr[0].gt {
	pc = 0x82199E30; continue 'dispatch;
	}
	pc = 0x82199DE0; continue 'dispatch;
            }
            0x82199DE0 => {
    //   block [0x82199DE0..0x82199E00)
	// 82199DE0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82199DE4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82199DE8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82199DEC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82199DF0: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 82199DF4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82199DF8: 41980008  blt cr6, 0x82199e00
	if ctx.cr[6].lt {
	pc = 0x82199E00; continue 'dispatch;
	}
	// 82199DFC: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x82199E00; continue 'dispatch;
            }
            0x82199E00 => {
    //   block [0x82199E00..0x82199E1C)
	// 82199E00: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82199E04: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82199E08: 419A0014  beq cr6, 0x82199e1c
	if ctx.cr[6].eq {
	pc = 0x82199E1C; continue 'dispatch;
	}
	// 82199E0C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82199E10: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82199E14: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82199E18: 4800000C  b 0x82199e24
	pc = 0x82199E24; continue 'dispatch;
            }
            0x82199E1C => {
    //   block [0x82199E1C..0x82199E24)
	// 82199E1C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82199E20: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82199E24; continue 'dispatch;
            }
            0x82199E24 => {
    //   block [0x82199E24..0x82199E30)
	// 82199E24: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82199E28: 4199FFB8  bgt cr6, 0x82199de0
	if ctx.cr[6].gt {
	pc = 0x82199DE0; continue 'dispatch;
	}
	// 82199E2C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82199E30; continue 'dispatch;
            }
            0x82199E30 => {
    //   block [0x82199E30..0x82199E4C)
	// 82199E30: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82199E34: 419A0040  beq cr6, 0x82199e74
	if ctx.cr[6].eq {
	pc = 0x82199E74; continue 'dispatch;
	}
	// 82199E38: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82199E3C: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 82199E40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82199E44: 41990008  bgt cr6, 0x82199e4c
	if ctx.cr[6].gt {
	pc = 0x82199E4C; continue 'dispatch;
	}
	// 82199E48: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82199E4C; continue 'dispatch;
            }
            0x82199E4C => {
    //   block [0x82199E4C..0x82199E74)
	// 82199E4C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82199E50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199E54: 409A0020  bne cr6, 0x82199e74
	if !ctx.cr[6].eq {
	pc = 0x82199E74; continue 'dispatch;
	}
	// 82199E58: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82199E5C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82199E60: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82199E64: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82199E68: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82199E6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82199E70: 4800001C  b 0x82199e8c
	pc = 0x82199E8C; continue 'dispatch;
            }
            0x82199E74 => {
    //   block [0x82199E74..0x82199E88)
	// 82199E74: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82199E78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82199E7C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82199E80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82199E84: 48000008  b 0x82199e8c
	pc = 0x82199E8C; continue 'dispatch;
            }
            0x82199E88 => {
    //   block [0x82199E88..0x82199E8C)
	// 82199E88: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82199E8C; continue 'dispatch;
            }
            0x82199E8C => {
    //   block [0x82199E8C..0x82199EAC)
	// 82199E8C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82199E90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199E94: 419A0018  beq cr6, 0x82199eac
	if ctx.cr[6].eq {
	pc = 0x82199EAC; continue 'dispatch;
	}
	// 82199E98: 485E2481  bl 0x8277c318
	ctx.lr = 0x82199E9C;
	sub_8277C318(ctx, base);
	// 82199E9C: 7D63B850  subf r11, r3, r23
	ctx.r[11].s64 = ctx.r[23].s64 - ctx.r[3].s64;
	// 82199EA0: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82199EA4: 5558DFFE  rlwinm r24, r10, 0x1b, 0x1f, 0x1f
	ctx.r[24].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82199EA8: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	pc = 0x82199EAC; continue 'dispatch;
            }
            0x82199EAC => {
    //   block [0x82199EAC..0x82199ECC)
	// 82199EAC: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 82199EB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199EB4: 409A0018  bne cr6, 0x82199ecc
	if !ctx.cr[6].eq {
	pc = 0x82199ECC; continue 'dispatch;
	}
	// 82199EB8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82199EBC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82199EC0: 48724D11  bl 0x828bebd0
	ctx.lr = 0x82199EC4;
	sub_828BEBD0(ctx, base);
	// 82199EC4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82199EC8: 7F38CB78  mr r24, r25
	ctx.r[24].u64 = ctx.r[25].u64;
	pc = 0x82199ECC; continue 'dispatch;
            }
            0x82199ECC => {
    //   block [0x82199ECC..0x82199EEC)
	// 82199ECC: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 82199ED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199ED4: 409A0018  bne cr6, 0x82199eec
	if !ctx.cr[6].eq {
	pc = 0x82199EEC; continue 'dispatch;
	}
	// 82199ED8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82199EDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82199EE0: 48724771  bl 0x828be650
	ctx.lr = 0x82199EE4;
	sub_828BE650(ctx, base);
	// 82199EE4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82199EE8: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	pc = 0x82199EEC; continue 'dispatch;
            }
            0x82199EEC => {
    //   block [0x82199EEC..0x82199F50)
	// 82199EEC: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 82199EF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199EF4: 409A01B0  bne cr6, 0x8219a0a4
	if !ctx.cr[6].eq {
	pc = 0x8219A0A4; continue 'dispatch;
	}
	// 82199EF8: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82199EFC: 48463255  bl 0x825fd150
	ctx.lr = 0x82199F00;
	sub_825FD150(ctx, base);
	// 82199F00: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82199F04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199F08: 419A019C  beq cr6, 0x8219a0a4
	if ctx.cr[6].eq {
	pc = 0x8219A0A4; continue 'dispatch;
	}
	// 82199F0C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82199F10: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82199F14: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82199F18: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82199F1C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82199F20: 419A00F4  beq cr6, 0x8219a014
	if ctx.cr[6].eq {
	pc = 0x8219A014; continue 'dispatch;
	}
	// 82199F24: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82199F28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82199F2C: 419A0024  beq cr6, 0x82199f50
	if ctx.cr[6].eq {
	pc = 0x82199F50; continue 'dispatch;
	}
	// 82199F30: 892A0085  lbz r9, 0x85(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(133 as u32) ) } as u64;
	// 82199F34: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82199F38: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82199F3C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82199F40: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82199F44: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82199F48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82199F4C: 480000CC  b 0x8219a018
	pc = 0x8219A018; continue 'dispatch;
            }
            0x82199F50 => {
    //   block [0x82199F50..0x82199F6C)
	// 82199F50: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82199F54: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82199F58: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82199F5C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82199F60: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82199F64: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82199F68: 40810054  ble 0x82199fbc
	if !ctx.cr[0].gt {
	pc = 0x82199FBC; continue 'dispatch;
	}
	pc = 0x82199F6C; continue 'dispatch;
            }
            0x82199F6C => {
    //   block [0x82199F6C..0x82199F8C)
	// 82199F6C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82199F70: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82199F74: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82199F78: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82199F7C: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 82199F80: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82199F84: 41980008  blt cr6, 0x82199f8c
	if ctx.cr[6].lt {
	pc = 0x82199F8C; continue 'dispatch;
	}
	// 82199F88: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x82199F8C; continue 'dispatch;
            }
            0x82199F8C => {
    //   block [0x82199F8C..0x82199FA8)
	// 82199F8C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82199F90: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82199F94: 419A0014  beq cr6, 0x82199fa8
	if ctx.cr[6].eq {
	pc = 0x82199FA8; continue 'dispatch;
	}
	// 82199F98: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82199F9C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82199FA0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82199FA4: 4800000C  b 0x82199fb0
	pc = 0x82199FB0; continue 'dispatch;
            }
            0x82199FA8 => {
    //   block [0x82199FA8..0x82199FB0)
	// 82199FA8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82199FAC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82199FB0; continue 'dispatch;
            }
            0x82199FB0 => {
    //   block [0x82199FB0..0x82199FBC)
	// 82199FB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82199FB4: 4199FFB8  bgt cr6, 0x82199f6c
	if ctx.cr[6].gt {
	pc = 0x82199F6C; continue 'dispatch;
	}
	// 82199FB8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82199FBC; continue 'dispatch;
            }
            0x82199FBC => {
    //   block [0x82199FBC..0x82199FD8)
	// 82199FBC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82199FC0: 419A0040  beq cr6, 0x8219a000
	if ctx.cr[6].eq {
	pc = 0x8219A000; continue 'dispatch;
	}
	// 82199FC4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82199FC8: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 82199FCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82199FD0: 41990008  bgt cr6, 0x82199fd8
	if ctx.cr[6].gt {
	pc = 0x82199FD8; continue 'dispatch;
	}
	// 82199FD4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82199FD8; continue 'dispatch;
            }
            0x82199FD8 => {
    //   block [0x82199FD8..0x8219A000)
	// 82199FD8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82199FDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199FE0: 409A0020  bne cr6, 0x8219a000
	if !ctx.cr[6].eq {
	pc = 0x8219A000; continue 'dispatch;
	}
	// 82199FE4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82199FE8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82199FEC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82199FF0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82199FF4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82199FF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82199FFC: 4800001C  b 0x8219a018
	pc = 0x8219A018; continue 'dispatch;
            }
            0x8219A000 => {
    //   block [0x8219A000..0x8219A014)
	// 8219A000: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8219A004: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A008: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8219A00C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A010: 48000008  b 0x8219a018
	pc = 0x8219A018; continue 'dispatch;
            }
            0x8219A014 => {
    //   block [0x8219A014..0x8219A018)
	// 8219A014: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x8219A018; continue 'dispatch;
            }
            0x8219A018 => {
    //   block [0x8219A018..0x8219A0A4)
	// 8219A018: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219A01C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A020: 419A0084  beq cr6, 0x8219a0a4
	if ctx.cr[6].eq {
	pc = 0x8219A0A4; continue 'dispatch;
	}
	// 8219A024: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8219A028: 48069F71  bl 0x82203f98
	ctx.lr = 0x8219A02C;
	sub_82203F98(ctx, base);
	// 8219A02C: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 8219A030: 409A0074  bne cr6, 0x8219a0a4
	if !ctx.cr[6].eq {
	pc = 0x8219A0A4; continue 'dispatch;
	}
	// 8219A034: 8097007C  lwz r4, 0x7c(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(124 as u32) ) } as u64;
	// 8219A038: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8219A03C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A040: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8219A044: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219A048: 4E800421  bctrl
	ctx.lr = 0x8219A04C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219A04C: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A050: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219A054: 8089007C  lwz r4, 0x7c(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 8219A058: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A05C: 80E80040  lwz r7, 0x40(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(64 as u32) ) } as u64;
	// 8219A060: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 8219A064: 4E800421  bctrl
	ctx.lr = 0x8219A068;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219A068: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8219A06C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8219A070: C01B0018  lfs f0, 0x18(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A074: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219A078: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            0x8219A0A4 => {
    //   block [0x8219A0A4..0x8219A0CC)
	// 8219A0A4: 570B063E  clrlwi r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 8219A0A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A0AC: 419A0014  beq cr6, 0x8219a0c0
	if ctx.cr[6].eq {
	pc = 0x8219A0C0; continue 'dispatch;
	}
	// 8219A0B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8219A0B4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8219A0B8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219A0BC: 48724BB5  bl 0x828bec70
	ctx.lr = 0x8219A0C0;
	sub_828BEC70(ctx, base);
	// 8219A0C0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8219A0C4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8219A0C8: 48B0F37C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A0D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219A0D0 size=1288
    let mut pc: u32 = 0x8219A0D0;
    'dispatch: loop {
        match pc {
            0x8219A0D0 => {
    //   block [0x8219A0D0..0x8219A134)
	// 8219A0D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219A0D4: 48B0F331  bl 0x82ca9404
	ctx.lr = 0x8219A0D8;
	sub_82CA93D0(ctx, base);
	// 8219A0D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219A0DC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8219A0E0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A0E4: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8219A0E8: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 8219A0EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219A0F0: 419A04DC  beq cr6, 0x8219a5cc
	if ctx.cr[6].eq {
	pc = 0x8219A5CC; continue 'dispatch;
	}
	// 8219A0F4: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 8219A0F8: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8219A0FC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219A100: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8219A104: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A108: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A10C: 480920AD  bl 0x8222c1b8
	ctx.lr = 0x8219A110;
	sub_8222C1B8(ctx, base);
	// 8219A110: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8219A114: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8219A118: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8219A11C: 419A0018  beq cr6, 0x8219a134
	if ctx.cr[6].eq {
	pc = 0x8219A134; continue 'dispatch;
	}
	// 8219A120: 897D0090  lbz r11, 0x90(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219A124: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219A128: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A12C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219A130: 409A0008  bne cr6, 0x8219a138
	if !ctx.cr[6].eq {
	pc = 0x8219A138; continue 'dispatch;
	}
	pc = 0x8219A134; continue 'dispatch;
            }
            0x8219A134 => {
    //   block [0x8219A134..0x8219A138)
	// 8219A134: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8219A138; continue 'dispatch;
            }
            0x8219A138 => {
    //   block [0x8219A138..0x8219A180)
	// 8219A138: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219A13C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A140: 419A048C  beq cr6, 0x8219a5cc
	if ctx.cr[6].eq {
	pc = 0x8219A5CC; continue 'dispatch;
	}
	// 8219A144: 815D0028  lwz r10, 0x28(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 8219A148: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8219A14C: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8219A150: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219A154: 419A00E8  beq cr6, 0x8219a23c
	if ctx.cr[6].eq {
	pc = 0x8219A23C; continue 'dispatch;
	}
	// 8219A158: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219A15C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A160: 419A0020  beq cr6, 0x8219a180
	if ctx.cr[6].eq {
	pc = 0x8219A180; continue 'dispatch;
	}
	// 8219A164: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 8219A168: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219A16C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8219A170: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219A174: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219A178: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A17C: 480000C4  b 0x8219a240
	pc = 0x8219A240; continue 'dispatch;
            }
            0x8219A180 => {
    //   block [0x8219A180..0x8219A19C)
	// 8219A180: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219A184: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 8219A188: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8219A18C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8219A190: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8219A194: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219A198: 40810054  ble 0x8219a1ec
	if !ctx.cr[0].gt {
	pc = 0x8219A1EC; continue 'dispatch;
	}
	pc = 0x8219A19C; continue 'dispatch;
            }
            0x8219A19C => {
    //   block [0x8219A19C..0x8219A1BC)
	// 8219A19C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8219A1A0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219A1A4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8219A1A8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A1AC: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 8219A1B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8219A1B4: 41980008  blt cr6, 0x8219a1bc
	if ctx.cr[6].lt {
	pc = 0x8219A1BC; continue 'dispatch;
	}
	// 8219A1B8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x8219A1BC; continue 'dispatch;
            }
            0x8219A1BC => {
    //   block [0x8219A1BC..0x8219A1D8)
	// 8219A1BC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8219A1C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219A1C4: 419A0014  beq cr6, 0x8219a1d8
	if ctx.cr[6].eq {
	pc = 0x8219A1D8; continue 'dispatch;
	}
	// 8219A1C8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8219A1CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219A1D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8219A1D4: 4800000C  b 0x8219a1e0
	pc = 0x8219A1E0; continue 'dispatch;
            }
            0x8219A1D8 => {
    //   block [0x8219A1D8..0x8219A1E0)
	// 8219A1D8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8219A1DC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8219A1E0; continue 'dispatch;
            }
            0x8219A1E0 => {
    //   block [0x8219A1E0..0x8219A1EC)
	// 8219A1E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219A1E4: 4199FFB8  bgt cr6, 0x8219a19c
	if ctx.cr[6].gt {
	pc = 0x8219A19C; continue 'dispatch;
	}
	// 8219A1E8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8219A1EC; continue 'dispatch;
            }
            0x8219A1EC => {
    //   block [0x8219A1EC..0x8219A208)
	// 8219A1EC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8219A1F0: 419A003C  beq cr6, 0x8219a22c
	if ctx.cr[6].eq {
	pc = 0x8219A22C; continue 'dispatch;
	}
	// 8219A1F4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A1F8: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 8219A1FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A200: 41990008  bgt cr6, 0x8219a208
	if ctx.cr[6].gt {
	pc = 0x8219A208; continue 'dispatch;
	}
	// 8219A204: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8219A208; continue 'dispatch;
            }
            0x8219A208 => {
    //   block [0x8219A208..0x8219A22C)
	// 8219A208: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219A20C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A210: 409A001C  bne cr6, 0x8219a22c
	if !ctx.cr[6].eq {
	pc = 0x8219A22C; continue 'dispatch;
	}
	// 8219A214: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219A218: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219A21C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219A220: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219A224: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A228: 48000018  b 0x8219a240
	pc = 0x8219A240; continue 'dispatch;
            }
            0x8219A22C => {
    //   block [0x8219A22C..0x8219A23C)
	// 8219A22C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8219A230: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219A234: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A238: 48000008  b 0x8219a240
	pc = 0x8219A240; continue 'dispatch;
            }
            0x8219A23C => {
    //   block [0x8219A23C..0x8219A240)
	// 8219A23C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x8219A240; continue 'dispatch;
            }
            0x8219A240 => {
    //   block [0x8219A240..0x8219A250)
	// 8219A240: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8219A244: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219A248: 419A0028  beq cr6, 0x8219a270
	if ctx.cr[6].eq {
	pc = 0x8219A270; continue 'dispatch;
	}
	// 8219A24C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	pc = 0x8219A250; continue 'dispatch;
            }
            0x8219A250 => {
    //   block [0x8219A250..0x8219A264)
	// 8219A250: 809B0004  lwz r4, 4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A254: 4800942D  bl 0x821a3680
	ctx.lr = 0x8219A258;
	sub_821A3680(ctx, base);
	// 8219A258: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219A25C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A260: 419A01A4  beq cr6, 0x8219a404
	if ctx.cr[6].eq {
	pc = 0x8219A404; continue 'dispatch;
	}
	pc = 0x8219A264; continue 'dispatch;
            }
            0x8219A264 => {
    //   block [0x8219A264..0x8219A270)
	// 8219A264: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219A268: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219A26C: 48B0F1E8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x8219A270 => {
    //   block [0x8219A270..0x8219A298)
	// 8219A270: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8219A274: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219A278: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219A27C: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8219A280: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219A284: 419A0014  beq cr6, 0x8219a298
	if ctx.cr[6].eq {
	pc = 0x8219A298; continue 'dispatch;
	}
	// 8219A288: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 8219A28C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A290: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A294: 409A0008  bne cr6, 0x8219a29c
	if !ctx.cr[6].eq {
	pc = 0x8219A29C; continue 'dispatch;
	}
	pc = 0x8219A298; continue 'dispatch;
            }
            0x8219A298 => {
    //   block [0x8219A298..0x8219A29C)
	// 8219A298: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8219A29C; continue 'dispatch;
            }
            0x8219A29C => {
    //   block [0x8219A29C..0x8219A2E0)
	// 8219A29C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219A2A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A2A4: 419A0160  beq cr6, 0x8219a404
	if ctx.cr[6].eq {
	pc = 0x8219A404; continue 'dispatch;
	}
	// 8219A2A8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8219A2AC: 806A009C  lwz r3, 0x9c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 8219A2B0: 480C9F81  bl 0x82264230
	ctx.lr = 0x8219A2B4;
	sub_82264230(ctx, base);
	// 8219A2B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219A2B8: 419A014C  beq cr6, 0x8219a404
	if ctx.cr[6].eq {
	pc = 0x8219A404; continue 'dispatch;
	}
	// 8219A2BC: 48104BBD  bl 0x8229ee78
	ctx.lr = 0x8219A2C0;
	sub_8229EE78(ctx, base);
	// 8219A2C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219A2C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A2C8: 419A0018  beq cr6, 0x8219a2e0
	if ctx.cr[6].eq {
	pc = 0x8219A2E0; continue 'dispatch;
	}
	// 8219A2CC: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219A2D0: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8219A2D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219A2D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219A2DC: 409A0008  bne cr6, 0x8219a2e4
	if !ctx.cr[6].eq {
	pc = 0x8219A2E4; continue 'dispatch;
	}
	pc = 0x8219A2E0; continue 'dispatch;
            }
            0x8219A2E0 => {
    //   block [0x8219A2E0..0x8219A2E4)
	// 8219A2E0: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x8219A2E4; continue 'dispatch;
            }
            0x8219A2E4 => {
    //   block [0x8219A2E4..0x8219A330)
	// 8219A2E4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8219A2E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219A2EC: 419A0118  beq cr6, 0x8219a404
	if ctx.cr[6].eq {
	pc = 0x8219A404; continue 'dispatch;
	}
	// 8219A2F0: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8219A2F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219A2F8: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8219A2FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219A300: 419A00F4  beq cr6, 0x8219a3f4
	if ctx.cr[6].eq {
	pc = 0x8219A3F4; continue 'dispatch;
	}
	// 8219A304: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219A308: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219A30C: 419A0024  beq cr6, 0x8219a330
	if ctx.cr[6].eq {
	pc = 0x8219A330; continue 'dispatch;
	}
	// 8219A310: 894A0021  lbz r10, 0x21(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 8219A314: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219A318: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8219A31C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219A320: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A324: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8219A328: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A32C: 480000CC  b 0x8219a3f8
	pc = 0x8219A3F8; continue 'dispatch;
            }
            0x8219A330 => {
    //   block [0x8219A330..0x8219A34C)
	// 8219A330: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219A334: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8219A338: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8219A33C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8219A340: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8219A344: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219A348: 40810054  ble 0x8219a39c
	if !ctx.cr[0].gt {
	pc = 0x8219A39C; continue 'dispatch;
	}
	pc = 0x8219A34C; continue 'dispatch;
            }
            0x8219A34C => {
    //   block [0x8219A34C..0x8219A36C)
	// 8219A34C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8219A350: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219A354: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8219A358: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A35C: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 8219A360: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8219A364: 41980008  blt cr6, 0x8219a36c
	if ctx.cr[6].lt {
	pc = 0x8219A36C; continue 'dispatch;
	}
	// 8219A368: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x8219A36C; continue 'dispatch;
            }
            0x8219A36C => {
    //   block [0x8219A36C..0x8219A388)
	// 8219A36C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8219A370: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219A374: 419A0014  beq cr6, 0x8219a388
	if ctx.cr[6].eq {
	pc = 0x8219A388; continue 'dispatch;
	}
	// 8219A378: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8219A37C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219A380: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8219A384: 4800000C  b 0x8219a390
	pc = 0x8219A390; continue 'dispatch;
            }
            0x8219A388 => {
    //   block [0x8219A388..0x8219A390)
	// 8219A388: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8219A38C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8219A390; continue 'dispatch;
            }
            0x8219A390 => {
    //   block [0x8219A390..0x8219A39C)
	// 8219A390: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219A394: 4199FFB8  bgt cr6, 0x8219a34c
	if ctx.cr[6].gt {
	pc = 0x8219A34C; continue 'dispatch;
	}
	// 8219A398: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8219A39C; continue 'dispatch;
            }
            0x8219A39C => {
    //   block [0x8219A39C..0x8219A3B8)
	// 8219A39C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8219A3A0: 419A0040  beq cr6, 0x8219a3e0
	if ctx.cr[6].eq {
	pc = 0x8219A3E0; continue 'dispatch;
	}
	// 8219A3A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A3A8: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 8219A3AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A3B0: 41990008  bgt cr6, 0x8219a3b8
	if ctx.cr[6].gt {
	pc = 0x8219A3B8; continue 'dispatch;
	}
	// 8219A3B4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8219A3B8; continue 'dispatch;
            }
            0x8219A3B8 => {
    //   block [0x8219A3B8..0x8219A3E0)
	// 8219A3B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219A3BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A3C0: 409A0020  bne cr6, 0x8219a3e0
	if !ctx.cr[6].eq {
	pc = 0x8219A3E0; continue 'dispatch;
	}
	// 8219A3C4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219A3C8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219A3CC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219A3D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A3D4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8219A3D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A3DC: 4800001C  b 0x8219a3f8
	pc = 0x8219A3F8; continue 'dispatch;
            }
            0x8219A3E0 => {
    //   block [0x8219A3E0..0x8219A3F4)
	// 8219A3E0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8219A3E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A3E8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8219A3EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A3F0: 48000008  b 0x8219a3f8
	pc = 0x8219A3F8; continue 'dispatch;
            }
            0x8219A3F4 => {
    //   block [0x8219A3F4..0x8219A3F8)
	// 8219A3F4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8219A3F8; continue 'dispatch;
            }
            0x8219A3F8 => {
    //   block [0x8219A3F8..0x8219A404)
	// 8219A3F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219A3FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A400: 409AFE50  bne cr6, 0x8219a250
	if !ctx.cr[6].eq {
	pc = 0x8219A250; continue 'dispatch;
	}
	pc = 0x8219A404; continue 'dispatch;
            }
            0x8219A404 => {
    //   block [0x8219A404..0x8219A448)
	// 8219A404: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A408: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 8219A40C: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8219A410: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 8219A414: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219A418: 419A00F4  beq cr6, 0x8219a50c
	if ctx.cr[6].eq {
	pc = 0x8219A50C; continue 'dispatch;
	}
	// 8219A41C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219A420: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219A424: 419A0024  beq cr6, 0x8219a448
	if ctx.cr[6].eq {
	pc = 0x8219A448; continue 'dispatch;
	}
	// 8219A428: 892A0085  lbz r9, 0x85(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(133 as u32) ) } as u64;
	// 8219A42C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219A430: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8219A434: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8219A438: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A43C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8219A440: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A444: 480000CC  b 0x8219a510
	pc = 0x8219A510; continue 'dispatch;
            }
            0x8219A448 => {
    //   block [0x8219A448..0x8219A464)
	// 8219A448: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219A44C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8219A450: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8219A454: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8219A458: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8219A45C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219A460: 40810054  ble 0x8219a4b4
	if !ctx.cr[0].gt {
	pc = 0x8219A4B4; continue 'dispatch;
	}
	pc = 0x8219A464; continue 'dispatch;
            }
            0x8219A464 => {
    //   block [0x8219A464..0x8219A484)
	// 8219A464: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8219A468: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219A46C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8219A470: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A474: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 8219A478: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8219A47C: 41980008  blt cr6, 0x8219a484
	if ctx.cr[6].lt {
	pc = 0x8219A484; continue 'dispatch;
	}
	// 8219A480: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x8219A484; continue 'dispatch;
            }
            0x8219A484 => {
    //   block [0x8219A484..0x8219A4A0)
	// 8219A484: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8219A488: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219A48C: 419A0014  beq cr6, 0x8219a4a0
	if ctx.cr[6].eq {
	pc = 0x8219A4A0; continue 'dispatch;
	}
	// 8219A490: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8219A494: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219A498: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8219A49C: 4800000C  b 0x8219a4a8
	pc = 0x8219A4A8; continue 'dispatch;
            }
            0x8219A4A0 => {
    //   block [0x8219A4A0..0x8219A4A8)
	// 8219A4A0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8219A4A4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8219A4A8; continue 'dispatch;
            }
            0x8219A4A8 => {
    //   block [0x8219A4A8..0x8219A4B4)
	// 8219A4A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219A4AC: 4199FFB8  bgt cr6, 0x8219a464
	if ctx.cr[6].gt {
	pc = 0x8219A464; continue 'dispatch;
	}
	// 8219A4B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8219A4B4; continue 'dispatch;
            }
            0x8219A4B4 => {
    //   block [0x8219A4B4..0x8219A4D0)
	// 8219A4B4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8219A4B8: 419A0040  beq cr6, 0x8219a4f8
	if ctx.cr[6].eq {
	pc = 0x8219A4F8; continue 'dispatch;
	}
	// 8219A4BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A4C0: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 8219A4C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A4C8: 41990008  bgt cr6, 0x8219a4d0
	if ctx.cr[6].gt {
	pc = 0x8219A4D0; continue 'dispatch;
	}
	// 8219A4CC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8219A4D0; continue 'dispatch;
            }
            0x8219A4D0 => {
    //   block [0x8219A4D0..0x8219A4F8)
	// 8219A4D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219A4D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A4D8: 409A0020  bne cr6, 0x8219a4f8
	if !ctx.cr[6].eq {
	pc = 0x8219A4F8; continue 'dispatch;
	}
	// 8219A4DC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219A4E0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219A4E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219A4E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A4EC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8219A4F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A4F4: 4800001C  b 0x8219a510
	pc = 0x8219A510; continue 'dispatch;
            }
            0x8219A4F8 => {
    //   block [0x8219A4F8..0x8219A50C)
	// 8219A4F8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8219A4FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A500: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8219A504: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A508: 48000008  b 0x8219a510
	pc = 0x8219A510; continue 'dispatch;
            }
            0x8219A50C => {
    //   block [0x8219A50C..0x8219A510)
	// 8219A50C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8219A510; continue 'dispatch;
            }
            0x8219A510 => {
    //   block [0x8219A510..0x8219A564)
	// 8219A510: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219A514: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A518: 419A00B4  beq cr6, 0x8219a5cc
	if ctx.cr[6].eq {
	pc = 0x8219A5CC; continue 'dispatch;
	}
	// 8219A51C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8219A520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A524: 48069A75  bl 0x82203f98
	ctx.lr = 0x8219A528;
	sub_82203F98(ctx, base);
	// 8219A528: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 8219A52C: 409A00A0  bne cr6, 0x8219a5cc
	if !ctx.cr[6].eq {
	pc = 0x8219A5CC; continue 'dispatch;
	}
	// 8219A530: 897B0022  lbz r11, 0x22(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(34 as u32) ) } as u64;
	// 8219A534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A538: 419AFD2C  beq cr6, 0x8219a264
	if ctx.cr[6].eq {
	pc = 0x8219A264; continue 'dispatch;
	}
	// 8219A53C: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8219A540: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219A544: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219A548: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8219A54C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219A550: 419A0014  beq cr6, 0x8219a564
	if ctx.cr[6].eq {
	pc = 0x8219A564; continue 'dispatch;
	}
	// 8219A554: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 8219A558: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A55C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A560: 409A0008  bne cr6, 0x8219a568
	if !ctx.cr[6].eq {
	pc = 0x8219A568; continue 'dispatch;
	}
	pc = 0x8219A564; continue 'dispatch;
            }
            0x8219A564 => {
    //   block [0x8219A564..0x8219A568)
	// 8219A564: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8219A568; continue 'dispatch;
            }
            0x8219A568 => {
    //   block [0x8219A568..0x8219A5AC)
	// 8219A568: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219A56C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A570: 419AFCF4  beq cr6, 0x8219a264
	if ctx.cr[6].eq {
	pc = 0x8219A264; continue 'dispatch;
	}
	// 8219A574: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8219A578: 806A009C  lwz r3, 0x9c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 8219A57C: 480C9CB5  bl 0x82264230
	ctx.lr = 0x8219A580;
	sub_82264230(ctx, base);
	// 8219A580: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219A584: 419AFCE0  beq cr6, 0x8219a264
	if ctx.cr[6].eq {
	pc = 0x8219A264; continue 'dispatch;
	}
	// 8219A588: 481048F1  bl 0x8229ee78
	ctx.lr = 0x8219A58C;
	sub_8229EE78(ctx, base);
	// 8219A58C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219A590: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219A594: 419A0018  beq cr6, 0x8219a5ac
	if ctx.cr[6].eq {
	pc = 0x8219A5AC; continue 'dispatch;
	}
	// 8219A598: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219A59C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219A5A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A5A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219A5A8: 409A0008  bne cr6, 0x8219a5b0
	if !ctx.cr[6].eq {
	pc = 0x8219A5B0; continue 'dispatch;
	}
	pc = 0x8219A5AC; continue 'dispatch;
            }
            0x8219A5AC => {
    //   block [0x8219A5AC..0x8219A5B0)
	// 8219A5AC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8219A5B0; continue 'dispatch;
            }
            0x8219A5B0 => {
    //   block [0x8219A5B0..0x8219A5CC)
	// 8219A5B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219A5B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A5B8: 419AFCAC  beq cr6, 0x8219a264
	if ctx.cr[6].eq {
	pc = 0x8219A264; continue 'dispatch;
	}
	// 8219A5BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A5C0: 480699D9  bl 0x82203f98
	ctx.lr = 0x8219A5C4;
	sub_82203F98(ctx, base);
	// 8219A5C4: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 8219A5C8: 419AFC9C  beq cr6, 0x8219a264
	if ctx.cr[6].eq {
	pc = 0x8219A264; continue 'dispatch;
	}
	pc = 0x8219A5CC; continue 'dispatch;
            }
            0x8219A5CC => {
    //   block [0x8219A5CC..0x8219A5D8)
	// 8219A5CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219A5D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219A5D4: 48B0EE80  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219A5D8 size=116
    let mut pc: u32 = 0x8219A5D8;
    'dispatch: loop {
        match pc {
            0x8219A5D8 => {
    //   block [0x8219A5D8..0x8219A628)
	// 8219A5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219A5DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219A5E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219A5E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219A5E8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8219A5EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219A5F0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8219A5F4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219A5F8: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8219A5FC: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A600: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A604: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8219A608: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 8219A60C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A610: 419A001C  beq cr6, 0x8219a62c
	if ctx.cr[6].eq {
	pc = 0x8219A62C; continue 'dispatch;
	}
	// 8219A614: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A618: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219A61C: 419A000C  beq cr6, 0x8219a628
	if ctx.cr[6].eq {
	pc = 0x8219A628; continue 'dispatch;
	}
	// 8219A620: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8219A624: 4800000C  b 0x8219a630
	pc = 0x8219A630; continue 'dispatch;
            }
            0x8219A628 => {
    //   block [0x8219A628..0x8219A62C)
	// 8219A628: 4BFF9811  bl 0x82193e38
	ctx.lr = 0x8219A62C;
	sub_82193E38(ctx, base);
	pc = 0x8219A62C; continue 'dispatch;
            }
            0x8219A62C => {
    //   block [0x8219A62C..0x8219A630)
	// 8219A62C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8219A630; continue 'dispatch;
            }
            0x8219A630 => {
    //   block [0x8219A630..0x8219A64C)
	// 8219A630: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 8219A634: 48335685  bl 0x824cfcb8
	ctx.lr = 0x8219A638;
	sub_824CFCB8(ctx, base);
	// 8219A638: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219A63C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219A640: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219A644: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219A648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219A650 size=144
    let mut pc: u32 = 0x8219A650;
    'dispatch: loop {
        match pc {
            0x8219A650 => {
    //   block [0x8219A650..0x8219A6A8)
	// 8219A650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219A654: 48B0EDB9  bl 0x82ca940c
	ctx.lr = 0x8219A658;
	sub_82CA93D0(ctx, base);
	// 8219A658: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219A65C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219A660: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8219A664: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219A668: 389F008C  addi r4, r31, 0x8c
	ctx.r[4].s64 = ctx.r[31].s64 + 140;
	// 8219A66C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8219A670: 48066101  bl 0x82200770
	ctx.lr = 0x8219A674;
	sub_82200770(ctx, base);
	// 8219A674: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A678: 3BDF0040  addi r30, r31, 0x40
	ctx.r[30].s64 = ctx.r[31].s64 + 64;
	// 8219A67C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8219A680: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219A684: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8219A688: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8219A68C: 83FF0044  lwz r31, 0x44(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 8219A690: 481DAB69  bl 0x823751f8
	ctx.lr = 0x8219A694;
	sub_823751F8(ctx, base);
	// 8219A694: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A69C: 419A000C  beq cr6, 0x8219a6a8
	if ctx.cr[6].eq {
	pc = 0x8219A6A8; continue 'dispatch;
	}
	// 8219A6A0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8219A6A4: 419A0008  beq cr6, 0x8219a6ac
	if ctx.cr[6].eq {
	pc = 0x8219A6AC; continue 'dispatch;
	}
	pc = 0x8219A6A8; continue 'dispatch;
            }
            0x8219A6A8 => {
    //   block [0x8219A6A8..0x8219A6AC)
	// 8219A6A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219A6AC; continue 'dispatch;
            }
            0x8219A6AC => {
    //   block [0x8219A6AC..0x8219A6D4)
	// 8219A6AC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A6B0: 8901005C  lbz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8219A6B4: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 8219A6B8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8219A6BC: 7D270034  cntlzw r7, r9
	ctx.r[7].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 8219A6C0: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 8219A6C4: 68DF0001  xori r31, r6, 1
	ctx.r[31].u64 = ctx.r[6].u64 ^ 1;
	// 8219A6C8: 419A000C  beq cr6, 0x8219a6d4
	if ctx.cr[6].eq {
	pc = 0x8219A6D4; continue 'dispatch;
	}
	// 8219A6CC: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8219A6D0: 4911F285  bl 0x832b9954
	ctx.lr = 0x8219A6D4;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x8219A6D4; continue 'dispatch;
            }
            0x8219A6D4 => {
    //   block [0x8219A6D4..0x8219A6E0)
	// 8219A6D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A6D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219A6DC: 48B0ED80  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219A6E0 size=116
    let mut pc: u32 = 0x8219A6E0;
    'dispatch: loop {
        match pc {
            0x8219A6E0 => {
    //   block [0x8219A6E0..0x8219A720)
	// 8219A6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219A6E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219A6E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219A6EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219A6F0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8219A6F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219A6F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8219A6FC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8219A700: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8219A704: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219A708: 4808BF21  bl 0x82226628
	ctx.lr = 0x8219A70C;
	sub_82226628(ctx, base);
	// 8219A70C: C01F0124  lfs f0, 0x124(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A710: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 8219A714: 4099000C  ble cr6, 0x8219a720
	if !ctx.cr[6].gt {
	pc = 0x8219A720; continue 'dispatch;
	}
	// 8219A718: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219A71C: 4800001C  b 0x8219a738
	pc = 0x8219A738; continue 'dispatch;
            }
            0x8219A720 => {
    //   block [0x8219A720..0x8219A738)
	// 8219A720: 397F0050  addi r11, r31, 0x50
	ctx.r[11].s64 = ctx.r[31].s64 + 80;
	// 8219A724: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 8219A728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x8219A738; continue 'dispatch;
            }
            0x8219A738 => {
    //   block [0x8219A738..0x8219A754)
	// 8219A738: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219A73C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219A740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219A744: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8219A748: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219A74C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219A750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219A758 size=228
    let mut pc: u32 = 0x8219A758;
    'dispatch: loop {
        match pc {
            0x8219A758 => {
    //   block [0x8219A758..0x8219A7C0)
	// 8219A758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219A75C: 48B0ECB1  bl 0x82ca940c
	ctx.lr = 0x8219A760;
	sub_82CA93D0(ctx, base);
	// 8219A760: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219A764: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219A768: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8219A76C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A774: 419A00C0  beq cr6, 0x8219a834
	if ctx.cr[6].eq {
	pc = 0x8219A834; continue 'dispatch;
	}
	// 8219A778: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A77C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219A780: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219A784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A788: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 8219A78C: 480002F5  bl 0x8219aa80
	ctx.lr = 0x8219A790;
	sub_8219AA80(ctx, base);
	// 8219A790: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A794: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8219A798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A79C: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219A7A0: 4808E969  bl 0x82229108
	ctx.lr = 0x8219A7A4;
	sub_82229108(ctx, base);
	// 8219A7A4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A7A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A7AC: 419A0014  beq cr6, 0x8219a7c0
	if ctx.cr[6].eq {
	pc = 0x8219A7C0; continue 'dispatch;
	}
	// 8219A7B0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8219A7B4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A7B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A7BC: 4808E94D  bl 0x82229108
	ctx.lr = 0x8219A7C0;
	sub_82229108(ctx, base);
	pc = 0x8219A7C0; continue 'dispatch;
            }
            0x8219A7C0 => {
    //   block [0x8219A7C0..0x8219A828)
	// 8219A7C0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219A7C4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219A7C8: 3CE082A2  lis r7, -0x7d5e
	ctx.r[7].s64 = -2103312384;
	// 8219A7CC: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219A7D0: 394BFFF0  addi r10, r11, -0x10
	ctx.r[10].s64 = ctx.r[11].s64 + -16;
	// 8219A7D4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 8219A7D8: 396BFFE8  addi r11, r11, -0x18
	ctx.r[11].s64 = ctx.r[11].s64 + -24;
	// 8219A7DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8219A7E0: 38874808  addi r4, r7, 0x4808
	ctx.r[4].s64 = ctx.r[7].s64 + 18440;
	// 8219A7E4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8219A7E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A7EC: 7CE85850  subf r7, r8, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 8219A7F0: 7CC85050  subf r6, r8, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8219A7F4: 4800004D  bl 0x8219a840
	ctx.lr = 0x8219A7F8;
	sub_8219A840(ctx, base);
	// 8219A7F8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8219A7FC: 419A002C  beq cr6, 0x8219a828
	if ctx.cr[6].eq {
	pc = 0x8219A828; continue 'dispatch;
	}
	// 8219A800: 48A62009  bl 0x82bfc808
	ctx.lr = 0x8219A804;
	sub_82BFC808(ctx, base);
	// 8219A804: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219A808: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219A80C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8219A810: 480926C1  bl 0x8222ced0
	ctx.lr = 0x8219A814;
	sub_8222CED0(ctx, base);
	// 8219A814: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219A818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219A81C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 8219A820: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8219A824: 4807A5B5  bl 0x82214dd8
	ctx.lr = 0x8219A828;
	sub_82214DD8(ctx, base);
	pc = 0x8219A828; continue 'dispatch;
            }
            0x8219A828 => {
    //   block [0x8219A828..0x8219A834)
	// 8219A828: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219A82C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 8219A830: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x8219A834; continue 'dispatch;
            }
            0x8219A834 => {
    //   block [0x8219A834..0x8219A83C)
	// 8219A834: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8219A838: 48B0EC24  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219A840 size=200
    let mut pc: u32 = 0x8219A840;
    'dispatch: loop {
        match pc {
            0x8219A840 => {
    //   block [0x8219A840..0x8219A8F8)
	// 8219A840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219A844: 48B0EBB9  bl 0x82ca93fc
	ctx.lr = 0x8219A848;
	sub_82CA93D0(ctx, base);
	// 8219A848: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219A84C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219A850: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8219A854: 833F0064  lwz r25, 0x64(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 8219A858: 90FF0064  stw r7, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 8219A85C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219A860: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8219A864: A39F0034  lhz r28, 0x34(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 8219A868: 8B7F0039  lbz r27, 0x39(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(57 as u32) ) } as u64;
	// 8219A86C: 7F4A5850  subf r26, r10, r11
	ctx.r[26].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8219A870: 480DD3C9  bl 0x82277c38
	ctx.lr = 0x8219A874;
	sub_82277C38(ctx, base);
	// 8219A874: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219A878: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8219A87C: 419A007C  beq cr6, 0x8219a8f8
	if ctx.cr[6].eq {
	pc = 0x8219A8F8; continue 'dispatch;
	}
	// 8219A880: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219A884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A888: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8219A88C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8219A890: 48090BD9  bl 0x8222b468
	ctx.lr = 0x8219A894;
	sub_8222B468(ctx, base);
	// 8219A894: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8219A898: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219A89C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A8A0: 488990F9  bl 0x82a33998
	ctx.lr = 0x8219A8A4;
	sub_82A33998(ctx, base);
	// 8219A8A4: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8219A8A8: B39F0034  sth r28, 0x34(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[28].u16 ) };
	// 8219A8AC: 7D6AD214  add r11, r10, r26
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 8219A8B0: 811F0030  lwz r8, 0x30(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219A8B4: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 8219A8B8: 2F084E20  cmpwi cr6, r8, 0x4e20
	ctx.cr[6].compare_i32(ctx.r[8].s32, 20000, &mut ctx.xer);
	// 8219A8BC: 7D2AD02E  lwzx r9, r10, r26
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 8219A8C0: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 8219A8C4: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219A8C8: 90FF0018  stw r7, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 8219A8CC: 9B7F0039  stb r27, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[27].u8 ) };
	// 8219A8D0: 40990028  ble cr6, 0x8219a8f8
	if !ctx.cr[6].gt {
	pc = 0x8219A8F8; continue 'dispatch;
	}
	// 8219A8D4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8219A8D8: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 8219A8DC: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 8219A8E0: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 8219A8E4: 2F094E20  cmpwi cr6, r9, 0x4e20
	ctx.cr[6].compare_i32(ctx.r[9].s32, 20000, &mut ctx.xer);
	// 8219A8E8: 40980010  bge cr6, 0x8219a8f8
	if !ctx.cr[6].lt {
	pc = 0x8219A8F8; continue 'dispatch;
	}
	// 8219A8EC: 38804E20  li r4, 0x4e20
	ctx.r[4].s64 = 20000;
	// 8219A8F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A8F4: 488992E5  bl 0x82a33bd8
	ctx.lr = 0x8219A8F8;
	sub_82A33BD8(ctx, base);
	pc = 0x8219A8F8; continue 'dispatch;
            }
            0x8219A8F8 => {
    //   block [0x8219A8F8..0x8219A908)
	// 8219A8F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219A8FC: 933F0064  stw r25, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 8219A900: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219A904: 48B0EB48  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219A908 size=152
    let mut pc: u32 = 0x8219A908;
    'dispatch: loop {
        match pc {
            0x8219A908 => {
    //   block [0x8219A908..0x8219A930)
	// 8219A908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219A90C: 48B0EB01  bl 0x82ca940c
	ctx.lr = 0x8219A910;
	sub_82CA93D0(ctx, base);
	// 8219A910: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219A914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219A918: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8219A91C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8219A920: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 8219A924: 409A000C  bne cr6, 0x8219a930
	if !ctx.cr[6].eq {
	pc = 0x8219A930; continue 'dispatch;
	}
	// 8219A928: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219A92C: 48000018  b 0x8219a944
	pc = 0x8219A944; continue 'dispatch;
            }
            0x8219A930 => {
    //   block [0x8219A930..0x8219A944)
	// 8219A930: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 8219A934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A938: 488897A9  bl 0x82a240e0
	ctx.lr = 0x8219A93C;
	sub_82A240E0(ctx, base);
	// 8219A93C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219A940: 7CEB1850  subf r7, r11, r3
	ctx.r[7].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	pc = 0x8219A944; continue 'dispatch;
            }
            0x8219A944 => {
    //   block [0x8219A944..0x8219A998)
	// 8219A944: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 8219A948: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219A94C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 8219A950: 3D2082A2  lis r9, -0x7d5e
	ctx.r[9].s64 = -2103312384;
	// 8219A954: 55681838  slwi r8, r11, 3
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219A958: 80DF0020  lwz r6, 0x20(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219A95C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8219A960: 7D685050  subf r11, r8, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8219A964: 38894808  addi r4, r9, 0x4808
	ctx.r[4].s64 = ctx.r[9].s64 + 18440;
	// 8219A968: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8219A96C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A970: 7CC65850  subf r6, r6, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 8219A974: 4BFFFECD  bl 0x8219a840
	ctx.lr = 0x8219A978;
	sub_8219A840(ctx, base);
	// 8219A978: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 8219A97C: 409A001C  bne cr6, 0x8219a998
	if !ctx.cr[6].eq {
	pc = 0x8219A998; continue 'dispatch;
	}
	// 8219A980: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219A984: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219A988: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219A98C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219A990: 41980008  blt cr6, 0x8219a998
	if ctx.cr[6].lt {
	pc = 0x8219A998; continue 'dispatch;
	}
	// 8219A994: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x8219A998; continue 'dispatch;
            }
            0x8219A998 => {
    //   block [0x8219A998..0x8219A9A0)
	// 8219A998: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8219A99C: 48B0EAC0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219A9A0 size=220
    let mut pc: u32 = 0x8219A9A0;
    'dispatch: loop {
        match pc {
            0x8219A9A0 => {
    //   block [0x8219A9A0..0x8219AA58)
	// 8219A9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219A9A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219A9A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219A9AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219A9B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219A9B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219A9B8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A9BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A9C0: 419A00A4  beq cr6, 0x8219aa64
	if ctx.cr[6].eq {
	pc = 0x8219AA64; continue 'dispatch;
	}
	// 8219A9C4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219A9C8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219A9CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219A9D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A9D4: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 8219A9D8: 480000A9  bl 0x8219aa80
	ctx.lr = 0x8219A9DC;
	sub_8219AA80(ctx, base);
	// 8219A9DC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A9E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A9E4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8219A9E8: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219A9EC: 4808E71D  bl 0x82229108
	ctx.lr = 0x8219A9F0;
	sub_82229108(ctx, base);
	// 8219A9F0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219A9F4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219A9F8: 80DF0020  lwz r6, 0x20(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219A9FC: 3D0082A2  lis r8, -0x7d5e
	ctx.r[8].s64 = -2103312384;
	// 8219AA00: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 8219AA04: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 8219AA08: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 8219AA0C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8219AA10: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8219AA14: 7CE65850  subf r7, r6, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 8219AA18: 38884808  addi r4, r8, 0x4808
	ctx.r[4].s64 = ctx.r[8].s64 + 18440;
	// 8219AA1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219AA20: 7CC65050  subf r6, r6, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 8219AA24: 4BFFFE1D  bl 0x8219a840
	ctx.lr = 0x8219AA28;
	sub_8219A840(ctx, base);
	// 8219AA28: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8219AA2C: 419A002C  beq cr6, 0x8219aa58
	if ctx.cr[6].eq {
	pc = 0x8219AA58; continue 'dispatch;
	}
	// 8219AA30: 48A61DD9  bl 0x82bfc808
	ctx.lr = 0x8219AA34;
	sub_82BFC808(ctx, base);
	// 8219AA34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219AA38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219AA3C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8219AA40: 48092491  bl 0x8222ced0
	ctx.lr = 0x8219AA44;
	sub_8222CED0(ctx, base);
	// 8219AA44: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219AA48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219AA4C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 8219AA50: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8219AA54: 4807A385  bl 0x82214dd8
	ctx.lr = 0x8219AA58;
	sub_82214DD8(ctx, base);
	pc = 0x8219AA58; continue 'dispatch;
            }
            0x8219AA58 => {
    //   block [0x8219AA58..0x8219AA64)
	// 8219AA58: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219AA5C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 8219AA60: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x8219AA64; continue 'dispatch;
            }
            0x8219AA64 => {
    //   block [0x8219AA64..0x8219AA7C)
	// 8219AA64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219AA68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219AA6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219AA70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219AA74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219AA78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219AA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219AA80 size=212
    let mut pc: u32 = 0x8219AA80;
    'dispatch: loop {
        match pc {
            0x8219AA80 => {
    //   block [0x8219AA80..0x8219AAB0)
	// 8219AA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219AA84: 48B0E989  bl 0x82ca940c
	ctx.lr = 0x8219AA88;
	sub_82CA93D0(ctx, base);
	// 8219AA88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219AA8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219AA90: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8219AA94: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8219AA98: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219AA9C: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 8219AAA0: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8219AAA4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219AAA8: 41980008  blt cr6, 0x8219aab0
	if ctx.cr[6].lt {
	pc = 0x8219AAB0; continue 'dispatch;
	}
	// 8219AAAC: 4BFDEAD5  bl 0x82179580
	ctx.lr = 0x8219AAB0;
	sub_82179580(ctx, base);
	pc = 0x8219AAB0; continue 'dispatch;
            }
            0x8219AAB0 => {
    //   block [0x8219AAB0..0x8219AAC8)
	// 8219AAB0: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219AAB4: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 8219AAB8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219AABC: 409A000C  bne cr6, 0x8219aac8
	if !ctx.cr[6].eq {
	pc = 0x8219AAC8; continue 'dispatch;
	}
	// 8219AAC0: 80BE0048  lwz r5, 0x48(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219AAC4: 48000010  b 0x8219aad4
	pc = 0x8219AAD4; continue 'dispatch;
            }
            0x8219AAC8 => {
    //   block [0x8219AAC8..0x8219AAD4)
	// 8219AAC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219AACC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219AAD0: 80AA000C  lwz r5, 0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x8219AAD4; continue 'dispatch;
            }
            0x8219AAD4 => {
    //   block [0x8219AAD4..0x8219AB08)
	// 8219AAD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219AAD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219AADC: 481010AD  bl 0x8229bb88
	ctx.lr = 0x8219AAE0;
	sub_8229BB88(ctx, base);
	// 8219AAE0: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AAE4: 93A30010  stw r29, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 8219AAE8: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8219AAEC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219AAF0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8219AAF4: 913E0008  stw r9, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8219AAF8: 419A0038  beq cr6, 0x8219ab30
	if ctx.cr[6].eq {
	pc = 0x8219AB30; continue 'dispatch;
	}
	// 8219AAFC: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 8219AB00: 2123FFEC  subfic r9, r3, -0x14
	ctx.xer.ca = ctx.r[3].u32 <= -20 as u32;
	ctx.r[9].s64 = (-20 as i64) - ctx.r[3].s64;
	// 8219AB04: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	pc = 0x8219AB08; continue 'dispatch;
            }
            0x8219AB08 => {
    //   block [0x8219AB08..0x8219AB30)
	// 8219AB08: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219AB0C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 8219AB10: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8219AB14: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219AB18: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219AB1C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219AB20: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8219AB24: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219AB28: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 8219AB2C: 4082FFDC  bne 0x8219ab08
	if !ctx.cr[0].eq {
	pc = 0x8219AB08; continue 'dispatch;
	}
	pc = 0x8219AB30; continue 'dispatch;
            }
            0x8219AB30 => {
    //   block [0x8219AB30..0x8219AB54)
	// 8219AB30: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219AB34: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 8219AB38: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 8219AB3C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8219AB40: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219AB44: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 8219AB48: 913E0008  stw r9, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8219AB4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219AB50: 48B0E90C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219AB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219AB58 size=432
    let mut pc: u32 = 0x8219AB58;
    'dispatch: loop {
        match pc {
            0x8219AB58 => {
    //   block [0x8219AB58..0x8219AD08)
	// 8219AB58: 10010C84  vmr v0, v1
	ctx.v[0] = ctx.v[1];
	// 8219AB5C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8219AB60: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 8219AB64: 1121034C  vspltish v9, 1
	for i in 0..8 {
		ctx.v[9].u16[i] = 1 as u16;
	}
	// 8219AB68: 392B0190  addi r9, r11, 0x190
	ctx.r[9].s64 = ctx.r[11].s64 + 400;
	// 8219AB6C: 13C1030C  vspltisb v30, 1
	for i in 0..16 {
		ctx.v[30].u8[i] = 1 as u8;
	}
	// 8219AB70: 396650E0  addi r11, r6, 0x50e0
	ctx.r[11].s64 = ctx.r[6].s64 + 20704;
	// 8219AB74: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 8219AB78: 110002CA  vrfim v8, v0
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[8].f32[i] = ctx.v[0].f32[i].floor();
	}
	// 8219AB7C: 3940FFE0  li r10, -0x20
	ctx.r[10].s64 = -32;
	// 8219AB80: 3900FFF0  li r8, -0x10
	ctx.r[8].s64 = -16;
	// 8219AB84: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 8219AB88: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219AD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219AD08 size=40
    let mut pc: u32 = 0x8219AD08;
    'dispatch: loop {
        match pc {
            0x8219AD08 => {
    //   block [0x8219AD08..0x8219AD24)
	// 8219AD08: 816300B0  lwz r11, 0xb0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) } as u64;
	// 8219AD0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219AD10: 419A0014  beq cr6, 0x8219ad24
	if ctx.cr[6].eq {
	pc = 0x8219AD24; continue 'dispatch;
	}
	// 8219AD14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219AD18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219AD1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219AD20: 41990008  bgt cr6, 0x8219ad28
	if ctx.cr[6].gt {
	pc = 0x8219AD28; continue 'dispatch;
	}
	pc = 0x8219AD24; continue 'dispatch;
            }
            0x8219AD24 => {
    //   block [0x8219AD24..0x8219AD28)
	// 8219AD24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219AD28; continue 'dispatch;
            }
            0x8219AD28 => {
    //   block [0x8219AD28..0x8219AD30)
	// 8219AD28: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219AD2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219AD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219AD30 size=280
    let mut pc: u32 = 0x8219AD30;
    'dispatch: loop {
        match pc {
            0x8219AD30 => {
    //   block [0x8219AD30..0x8219AD84)
	// 8219AD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219AD34: 48B0E6D9  bl 0x82ca940c
	ctx.lr = 0x8219AD38;
	sub_82CA93D0(ctx, base);
	// 8219AD38: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 8219AD3C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8219AD40: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219AD44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219AD48: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 8219AD4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219AD50: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 8219AD54: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219AD58: 83EB000C  lwz r31, 0xc(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219AD5C: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219AD60: 389F0150  addi r4, r31, 0x150
	ctx.r[4].s64 = ctx.r[31].s64 + 336;
	// 8219AD64: 4807072D  bl 0x8220b490
	ctx.lr = 0x8219AD68;
	sub_8220B490(ctx, base);
	// 8219AD68: 817D00B0  lwz r11, 0xb0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(176 as u32) ) } as u64;
	// 8219AD6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219AD70: 419A0014  beq cr6, 0x8219ad84
	if ctx.cr[6].eq {
	pc = 0x8219AD84; continue 'dispatch;
	}
	// 8219AD74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219AD78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219AD7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219AD80: 41990008  bgt cr6, 0x8219ad88
	if ctx.cr[6].gt {
	pc = 0x8219AD88; continue 'dispatch;
	}
	pc = 0x8219AD84; continue 'dispatch;
            }
            0x8219AD84 => {
    //   block [0x8219AD84..0x8219AD88)
	// 8219AD84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219AD88; continue 'dispatch;
            }
            0x8219AD88 => {
    //   block [0x8219AD88..0x8219ADD4)
	// 8219AD88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219AD8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219AD90: 419A0064  beq cr6, 0x8219adf4
	if ctx.cr[6].eq {
	pc = 0x8219ADF4; continue 'dispatch;
	}
	// 8219AD94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219AD98: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219AD9C: 4808741D  bl 0x822221b8
	ctx.lr = 0x8219ADA0;
	sub_822221B8(ctx, base);
	// 8219ADA0: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 8219ADA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219ADA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219ADAC: C02B0010  lfs f1, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219ADB0: 488DA8E9  bl 0x82a75698
	ctx.lr = 0x8219ADB4;
	sub_82A75698(ctx, base);
	// 8219ADB4: 809F0274  lwz r4, 0x274(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 8219ADB8: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 8219ADBC: 813F0278  lwz r9, 0x278(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 8219ADC0: 397F0270  addi r11, r31, 0x270
	ctx.r[11].s64 = ctx.r[31].s64 + 624;
	// 8219ADC4: 7D044850  subf r8, r4, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 8219ADC8: 7CE853D7  divw. r7, r8, r10
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 8219ADCC: 40820008  bne 0x8219add4
	if !ctx.cr[0].eq {
	pc = 0x8219ADD4; continue 'dispatch;
	}
	// 8219ADD0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	pc = 0x8219ADD4; continue 'dispatch;
            }
            0x8219ADD4 => {
    //   block [0x8219ADD4..0x8219ADF4)
	// 8219ADD4: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219ADD8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219ADDC: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219ADE0: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 8219ADE4: 7CA753D6  divw r5, r7, r10
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[10].s32;
	// 8219ADE8: 419A000C  beq cr6, 0x8219adf4
	if ctx.cr[6].eq {
	pc = 0x8219ADF4; continue 'dispatch;
	}
	// 8219ADEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219ADF0: 488F9411  bl 0x82a94200
	ctx.lr = 0x8219ADF4;
	sub_82A94200(ctx, base);
	pc = 0x8219ADF4; continue 'dispatch;
            }
            0x8219ADF4 => {
    //   block [0x8219ADF4..0x8219AE20)
	// 8219ADF4: D3DE0210  stfs f30, 0x210(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(528 as u32), tmp.u32 ) };
	// 8219ADF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8219ADFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219AE00: 4BFF2BA1  bl 0x8218d9a0
	ctx.lr = 0x8219AE04;
	sub_8218D9A0(ctx, base);
	// 8219AE04: 817D00B0  lwz r11, 0xb0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(176 as u32) ) } as u64;
	// 8219AE08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219AE0C: 419A0014  beq cr6, 0x8219ae20
	if ctx.cr[6].eq {
	pc = 0x8219AE20; continue 'dispatch;
	}
	// 8219AE10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219AE14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219AE18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219AE1C: 41990008  bgt cr6, 0x8219ae24
	if ctx.cr[6].gt {
	pc = 0x8219AE24; continue 'dispatch;
	}
	pc = 0x8219AE20; continue 'dispatch;
            }
            0x8219AE20 => {
    //   block [0x8219AE20..0x8219AE24)
	// 8219AE20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219AE24; continue 'dispatch;
            }
            0x8219AE24 => {
    //   block [0x8219AE24..0x8219AE38)
	// 8219AE24: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219AE28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219AE2C: 419A000C  beq cr6, 0x8219ae38
	if ctx.cr[6].eq {
	pc = 0x8219AE38; continue 'dispatch;
	}
	// 8219AE30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219AE34: 488F9BE5  bl 0x82a94a18
	ctx.lr = 0x8219AE38;
	sub_82A94A18(ctx, base);
	pc = 0x8219AE38; continue 'dispatch;
            }
            0x8219AE38 => {
    //   block [0x8219AE38..0x8219AE48)
	// 8219AE38: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8219AE3C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8219AE40: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8219AE44: 48B0E618  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219AE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219AE48 size=68
    let mut pc: u32 = 0x8219AE48;
    'dispatch: loop {
        match pc {
            0x8219AE48 => {
    //   block [0x8219AE48..0x8219AE8C)
	// 8219AE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219AE4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219AE50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219AE54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219AE58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219AE5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219AE60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8219AE64: 480E556D  bl 0x822803d0
	ctx.lr = 0x8219AE68;
	sub_822803D0(ctx, base);
	// 8219AE68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219AE6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219AE70: 48022FF9  bl 0x821bde68
	ctx.lr = 0x8219AE74;
	sub_821BDE68(ctx, base);
	// 8219AE74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219AE78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219AE7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219AE80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219AE84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219AE88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219AE90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219AE90 size=628
    let mut pc: u32 = 0x8219AE90;
    'dispatch: loop {
        match pc {
            0x8219AE90 => {
    //   block [0x8219AE90..0x8219AEB4)
	// 8219AE90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219AE94: 48B0E575  bl 0x82ca9408
	ctx.lr = 0x8219AE98;
	sub_82CA93D0(ctx, base);
	// 8219AE98: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219AE9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219AEA0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8219AEA4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8219AEA8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219AEAC: 838B9650  lwz r28, -0x69b0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 8219AEB0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8219AEB4; continue 'dispatch;
            }
            0x8219AEB4 => {
    //   block [0x8219AEB4..0x8219AECC)
	// 8219AEB4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219AEB8: 419A0054  beq cr6, 0x8219af0c
	if ctx.cr[6].eq {
	pc = 0x8219AF0C; continue 'dispatch;
	}
	// 8219AEBC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219AEC0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219AEC4: 409A0008  bne cr6, 0x8219aecc
	if !ctx.cr[6].eq {
	pc = 0x8219AECC; continue 'dispatch;
	}
	// 8219AEC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219AECC; continue 'dispatch;
            }
            0x8219AECC => {
    //   block [0x8219AECC..0x8219AEE4)
	// 8219AECC: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219AED0: 7F08E800  cmpw cr6, r8, r29
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[29].s32, &mut ctx.xer);
	// 8219AED4: 419A0018  beq cr6, 0x8219aeec
	if ctx.cr[6].eq {
	pc = 0x8219AEEC; continue 'dispatch;
	}
	// 8219AED8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219AEDC: 409A0008  bne cr6, 0x8219aee4
	if !ctx.cr[6].eq {
	pc = 0x8219AEE4; continue 'dispatch;
	}
	// 8219AEE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219AEE4; continue 'dispatch;
            }
            0x8219AEE4 => {
    //   block [0x8219AEE4..0x8219AEEC)
	// 8219AEE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219AEE8: 4BFFFFCC  b 0x8219aeb4
	pc = 0x8219AEB4; continue 'dispatch;
            }
            0x8219AEEC => {
    //   block [0x8219AEEC..0x8219AEFC)
	// 8219AEEC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219AEF0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219AEF4: 409A0008  bne cr6, 0x8219aefc
	if !ctx.cr[6].eq {
	pc = 0x8219AEFC; continue 'dispatch;
	}
	// 8219AEF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219AEFC; continue 'dispatch;
            }
            0x8219AEFC => {
    //   block [0x8219AEFC..0x8219AF0C)
	// 8219AEFC: 938B000C  stw r28, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 8219AF00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219AF04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219AF08: 48B0E550  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x8219AF0C => {
    //   block [0x8219AF0C..0x8219AF38)
	// 8219AF0C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8219AF10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219AF14: 4BFF0C0D  bl 0x8218bb20
	ctx.lr = 0x8219AF18;
	sub_8218BB20(ctx, base);
	// 8219AF18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219AF1C: 419A01D4  beq cr6, 0x8219b0f0
	if ctx.cr[6].eq {
	pc = 0x8219B0F0; continue 'dispatch;
	}
	// 8219AF20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219AF24: 2F0B0077  cmpwi cr6, r11, 0x77
	ctx.cr[6].compare_i32(ctx.r[11].s32, 119, &mut ctx.xer);
	// 8219AF28: 41980010  blt cr6, 0x8219af38
	if ctx.cr[6].lt {
	pc = 0x8219AF38; continue 'dispatch;
	}
	// 8219AF2C: 2F0B0094  cmpwi cr6, r11, 0x94
	ctx.cr[6].compare_i32(ctx.r[11].s32, 148, &mut ctx.xer);
	// 8219AF30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219AF34: 40990008  ble cr6, 0x8219af3c
	if !ctx.cr[6].gt {
	pc = 0x8219AF3C; continue 'dispatch;
	}
	pc = 0x8219AF38; continue 'dispatch;
            }
            0x8219AF38 => {
    //   block [0x8219AF38..0x8219AF3C)
	// 8219AF38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219AF3C; continue 'dispatch;
            }
            0x8219AF3C => {
    //   block [0x8219AF3C..0x8219AF58)
	// 8219AF3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219AF40: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8219AF44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219AF48: 419A0080  beq cr6, 0x8219afc8
	if ctx.cr[6].eq {
	pc = 0x8219AFC8; continue 'dispatch;
	}
	// 8219AF4C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219AF50: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219AF54: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x8219AF58; continue 'dispatch;
            }
            0x8219AF58 => {
    //   block [0x8219AF58..0x8219AF74)
	// 8219AF58: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219AF5C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219AF60: 419A0140  beq cr6, 0x8219b0a0
	if ctx.cr[6].eq {
	pc = 0x8219B0A0; continue 'dispatch;
	}
	// 8219AF64: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AF68: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219AF6C: 409A0008  bne cr6, 0x8219af74
	if !ctx.cr[6].eq {
	pc = 0x8219AF74; continue 'dispatch;
	}
	// 8219AF70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219AF74; continue 'dispatch;
            }
            0x8219AF74 => {
    //   block [0x8219AF74..0x8219AFA0)
	// 8219AF74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219AF78: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219AF7C: 4BFF0BA5  bl 0x8218bb20
	ctx.lr = 0x8219AF80;
	sub_8218BB20(ctx, base);
	// 8219AF80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219AF84: 419A002C  beq cr6, 0x8219afb0
	if ctx.cr[6].eq {
	pc = 0x8219AFB0; continue 'dispatch;
	}
	// 8219AF88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219AF8C: 2F0B0077  cmpwi cr6, r11, 0x77
	ctx.cr[6].compare_i32(ctx.r[11].s32, 119, &mut ctx.xer);
	// 8219AF90: 41980010  blt cr6, 0x8219afa0
	if ctx.cr[6].lt {
	pc = 0x8219AFA0; continue 'dispatch;
	}
	// 8219AF94: 2F0B0094  cmpwi cr6, r11, 0x94
	ctx.cr[6].compare_i32(ctx.r[11].s32, 148, &mut ctx.xer);
	// 8219AF98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219AF9C: 40990008  ble cr6, 0x8219afa4
	if !ctx.cr[6].gt {
	pc = 0x8219AFA4; continue 'dispatch;
	}
	pc = 0x8219AFA0; continue 'dispatch;
            }
            0x8219AFA0 => {
    //   block [0x8219AFA0..0x8219AFA4)
	// 8219AFA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219AFA4; continue 'dispatch;
            }
            0x8219AFA4 => {
    //   block [0x8219AFA4..0x8219AFB0)
	// 8219AFA4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219AFA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219AFAC: 419A00F4  beq cr6, 0x8219b0a0
	if ctx.cr[6].eq {
	pc = 0x8219B0A0; continue 'dispatch;
	}
	pc = 0x8219AFB0; continue 'dispatch;
            }
            0x8219AFB0 => {
    //   block [0x8219AFB0..0x8219AFC0)
	// 8219AFB0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219AFB4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219AFB8: 409A0008  bne cr6, 0x8219afc0
	if !ctx.cr[6].eq {
	pc = 0x8219AFC0; continue 'dispatch;
	}
	// 8219AFBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219AFC0; continue 'dispatch;
            }
            0x8219AFC0 => {
    //   block [0x8219AFC0..0x8219AFC8)
	// 8219AFC0: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219AFC4: 4BFFFF94  b 0x8219af58
	pc = 0x8219AF58; continue 'dispatch;
            }
            0x8219AFC8 => {
    //   block [0x8219AFC8..0x8219AFE0)
	// 8219AFC8: 89630024  lbz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 8219AFCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219AFD0: 419A0064  beq cr6, 0x8219b034
	if ctx.cr[6].eq {
	pc = 0x8219B034; continue 'dispatch;
	}
	// 8219AFD4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219AFD8: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219AFDC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x8219AFE0; continue 'dispatch;
            }
            0x8219AFE0 => {
    //   block [0x8219AFE0..0x8219AFFC)
	// 8219AFE0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219AFE4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219AFE8: 419A00B8  beq cr6, 0x8219b0a0
	if ctx.cr[6].eq {
	pc = 0x8219B0A0; continue 'dispatch;
	}
	// 8219AFEC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AFF0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219AFF4: 409A0008  bne cr6, 0x8219affc
	if !ctx.cr[6].eq {
	pc = 0x8219AFFC; continue 'dispatch;
	}
	// 8219AFF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219AFFC; continue 'dispatch;
            }
            0x8219AFFC => {
    //   block [0x8219AFFC..0x8219B01C)
	// 8219AFFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219B000: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219B004: 4BFF0B1D  bl 0x8218bb20
	ctx.lr = 0x8219B008;
	sub_8218BB20(ctx, base);
	// 8219B008: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219B00C: 419A0010  beq cr6, 0x8219b01c
	if ctx.cr[6].eq {
	pc = 0x8219B01C; continue 'dispatch;
	}
	// 8219B010: 89630024  lbz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 8219B014: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B018: 419A0088  beq cr6, 0x8219b0a0
	if ctx.cr[6].eq {
	pc = 0x8219B0A0; continue 'dispatch;
	}
	pc = 0x8219B01C; continue 'dispatch;
            }
            0x8219B01C => {
    //   block [0x8219B01C..0x8219B02C)
	// 8219B01C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B020: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219B024: 409A0008  bne cr6, 0x8219b02c
	if !ctx.cr[6].eq {
	pc = 0x8219B02C; continue 'dispatch;
	}
	// 8219B028: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219B02C; continue 'dispatch;
            }
            0x8219B02C => {
    //   block [0x8219B02C..0x8219B034)
	// 8219B02C: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B030: 4BFFFFB0  b 0x8219afe0
	pc = 0x8219AFE0; continue 'dispatch;
            }
            0x8219B034 => {
    //   block [0x8219B034..0x8219B04C)
	// 8219B034: 89630026  lbz r11, 0x26(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(38 as u32) ) } as u64;
	// 8219B038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B03C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B040: 419A0094  beq cr6, 0x8219b0d4
	if ctx.cr[6].eq {
	pc = 0x8219B0D4; continue 'dispatch;
	}
	// 8219B044: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B048: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x8219B04C; continue 'dispatch;
            }
            0x8219B04C => {
    //   block [0x8219B04C..0x8219B068)
	// 8219B04C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B050: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219B054: 419A004C  beq cr6, 0x8219b0a0
	if ctx.cr[6].eq {
	pc = 0x8219B0A0; continue 'dispatch;
	}
	// 8219B058: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219B05C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219B060: 409A0008  bne cr6, 0x8219b068
	if !ctx.cr[6].eq {
	pc = 0x8219B068; continue 'dispatch;
	}
	// 8219B064: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219B068; continue 'dispatch;
            }
            0x8219B068 => {
    //   block [0x8219B068..0x8219B088)
	// 8219B068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219B06C: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219B070: 4BFF0AB1  bl 0x8218bb20
	ctx.lr = 0x8219B074;
	sub_8218BB20(ctx, base);
	// 8219B074: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219B078: 419A0010  beq cr6, 0x8219b088
	if ctx.cr[6].eq {
	pc = 0x8219B088; continue 'dispatch;
	}
	// 8219B07C: 89630026  lbz r11, 0x26(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(38 as u32) ) } as u64;
	// 8219B080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B084: 419A001C  beq cr6, 0x8219b0a0
	if ctx.cr[6].eq {
	pc = 0x8219B0A0; continue 'dispatch;
	}
	pc = 0x8219B088; continue 'dispatch;
            }
            0x8219B088 => {
    //   block [0x8219B088..0x8219B098)
	// 8219B088: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B08C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219B090: 409A0008  bne cr6, 0x8219b098
	if !ctx.cr[6].eq {
	pc = 0x8219B098; continue 'dispatch;
	}
	// 8219B094: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219B098; continue 'dispatch;
            }
            0x8219B098 => {
    //   block [0x8219B098..0x8219B0A0)
	// 8219B098: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B09C: 4BFFFFB0  b 0x8219b04c
	pc = 0x8219B04C; continue 'dispatch;
            }
            0x8219B0A0 => {
    //   block [0x8219B0A0..0x8219B0D4)
	// 8219B0A0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 8219B0A4: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 8219B0A8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 8219B0AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219B0B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8219B0B4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 8219B0B8: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219B0BC: 482B5C85  bl 0x82450d40
	ctx.lr = 0x8219B0C0;
	sub_82450D40(ctx, base);
	// 8219B0C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219B0C4: 480E0ECD  bl 0x8227bf90
	ctx.lr = 0x8219B0C8;
	sub_8227BF90(ctx, base);
	// 8219B0C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219B0CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219B0D0: 48B0E388  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x8219B0D4 => {
    //   block [0x8219B0D4..0x8219B0F0)
	// 8219B0D4: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 8219B0D8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8219B0DC: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 8219B0E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219B0E4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8219B0E8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219B0EC: 484E8AB5  bl 0x82683ba0
	ctx.lr = 0x8219B0F0;
	sub_82683BA0(ctx, base);
	pc = 0x8219B0F0; continue 'dispatch;
            }
            0x8219B0F0 => {
    //   block [0x8219B0F0..0x8219B104)
	// 8219B0F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219B0F4: 480E0E9D  bl 0x8227bf90
	ctx.lr = 0x8219B0F8;
	sub_8227BF90(ctx, base);
	// 8219B0F8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219B0FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219B100: 48B0E358  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219B108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219B108 size=1168
    let mut pc: u32 = 0x8219B108;
    'dispatch: loop {
        match pc {
            0x8219B108 => {
    //   block [0x8219B108..0x8219B168)
	// 8219B108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219B10C: 48B0E2F9  bl 0x82ca9404
	ctx.lr = 0x8219B110;
	sub_82CA93D0(ctx, base);
	// 8219B110: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 8219B114: 48B12BC5  bl 0x82cadcd8
	ctx.lr = 0x8219B118;
	sub_82CADCA0(ctx, base);
	// 8219B118: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219B11C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8219B120: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8219B124: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 8219B128: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B12C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219B130: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8219B134: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219B138: 419A00F4  beq cr6, 0x8219b22c
	if ctx.cr[6].eq {
	pc = 0x8219B22C; continue 'dispatch;
	}
	// 8219B13C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219B140: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219B144: 419A0024  beq cr6, 0x8219b168
	if ctx.cr[6].eq {
	pc = 0x8219B168; continue 'dispatch;
	}
	// 8219B148: 894A0061  lbz r10, 0x61(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(97 as u32) ) } as u64;
	// 8219B14C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219B150: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8219B154: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219B158: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B15C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8219B160: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219B164: 480000CC  b 0x8219b230
	pc = 0x8219B230; continue 'dispatch;
            }
            0x8219B168 => {
    //   block [0x8219B168..0x8219B184)
	// 8219B168: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219B16C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8219B170: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 8219B174: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8219B178: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8219B17C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219B180: 40810054  ble 0x8219b1d4
	if !ctx.cr[0].gt {
	pc = 0x8219B1D4; continue 'dispatch;
	}
	pc = 0x8219B184; continue 'dispatch;
            }
            0x8219B184 => {
    //   block [0x8219B184..0x8219B1A4)
	// 8219B184: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8219B188: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219B18C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8219B190: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B194: 2F070061  cmpwi cr6, r7, 0x61
	ctx.cr[6].compare_i32(ctx.r[7].s32, 97, &mut ctx.xer);
	// 8219B198: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8219B19C: 41980008  blt cr6, 0x8219b1a4
	if ctx.cr[6].lt {
	pc = 0x8219B1A4; continue 'dispatch;
	}
	// 8219B1A0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x8219B1A4; continue 'dispatch;
            }
            0x8219B1A4 => {
    //   block [0x8219B1A4..0x8219B1C0)
	// 8219B1A4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8219B1A8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219B1AC: 419A0014  beq cr6, 0x8219b1c0
	if ctx.cr[6].eq {
	pc = 0x8219B1C0; continue 'dispatch;
	}
	// 8219B1B0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8219B1B4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219B1B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8219B1BC: 4800000C  b 0x8219b1c8
	pc = 0x8219B1C8; continue 'dispatch;
            }
            0x8219B1C0 => {
    //   block [0x8219B1C0..0x8219B1C8)
	// 8219B1C0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8219B1C4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8219B1C8; continue 'dispatch;
            }
            0x8219B1C8 => {
    //   block [0x8219B1C8..0x8219B1D4)
	// 8219B1C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219B1CC: 4199FFB8  bgt cr6, 0x8219b184
	if ctx.cr[6].gt {
	pc = 0x8219B184; continue 'dispatch;
	}
	// 8219B1D0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8219B1D4; continue 'dispatch;
            }
            0x8219B1D4 => {
    //   block [0x8219B1D4..0x8219B1F0)
	// 8219B1D4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8219B1D8: 419A0040  beq cr6, 0x8219b218
	if ctx.cr[6].eq {
	pc = 0x8219B218; continue 'dispatch;
	}
	// 8219B1DC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B1E0: 2F0B0061  cmpwi cr6, r11, 0x61
	ctx.cr[6].compare_i32(ctx.r[11].s32, 97, &mut ctx.xer);
	// 8219B1E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219B1E8: 41990008  bgt cr6, 0x8219b1f0
	if ctx.cr[6].gt {
	pc = 0x8219B1F0; continue 'dispatch;
	}
	// 8219B1EC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x8219B1F0; continue 'dispatch;
            }
            0x8219B1F0 => {
    //   block [0x8219B1F0..0x8219B218)
	// 8219B1F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219B1F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B1F8: 409A0020  bne cr6, 0x8219b218
	if !ctx.cr[6].eq {
	pc = 0x8219B218; continue 'dispatch;
	}
	// 8219B1FC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219B200: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219B204: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219B208: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B20C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8219B210: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219B214: 4800001C  b 0x8219b230
	pc = 0x8219B230; continue 'dispatch;
            }
            0x8219B218 => {
    //   block [0x8219B218..0x8219B22C)
	// 8219B218: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8219B21C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B220: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8219B224: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219B228: 48000008  b 0x8219b230
	pc = 0x8219B230; continue 'dispatch;
            }
            0x8219B22C => {
    //   block [0x8219B22C..0x8219B230)
	// 8219B22C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x8219B230; continue 'dispatch;
            }
            0x8219B230 => {
    //   block [0x8219B230..0x8219B258)
	// 8219B230: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219B234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B238: 419A0350  beq cr6, 0x8219b588
	if ctx.cr[6].eq {
	pc = 0x8219B588; continue 'dispatch;
	}
	// 8219B23C: 8BFC0015  lbz r31, 0x15(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 8219B240: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219B244: 419A0014  beq cr6, 0x8219b258
	if ctx.cr[6].eq {
	pc = 0x8219B258; continue 'dispatch;
	}
	// 8219B248: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219B24C: 889C0016  lbz r4, 0x16(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(22 as u32) ) } as u64;
	// 8219B250: 486CC659  bl 0x828678a8
	ctx.lr = 0x8219B254;
	sub_828678A8(ctx, base);
	// 8219B254: 9B7C0015  stb r27, 0x15(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(21 as u32), ctx.r[27].u8 ) };
	pc = 0x8219B258; continue 'dispatch;
            }
            0x8219B258 => {
    //   block [0x8219B258..0x8219B274)
	// 8219B258: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219B25C: 4BFF644D  bl 0x821916a8
	ctx.lr = 0x8219B260;
	sub_821916A8(ctx, base);
	// 8219B260: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 8219B264: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8219B268: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219B26C: 40990054  ble cr6, 0x8219b2c0
	if !ctx.cr[6].gt {
	pc = 0x8219B2C0; continue 'dispatch;
	}
	// 8219B270: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	pc = 0x8219B274; continue 'dispatch;
            }
            0x8219B274 => {
    //   block [0x8219B274..0x8219B298)
	// 8219B274: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B278: 7F0A1800  cmpw cr6, r10, r3
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[3].s32, &mut ctx.xer);
	// 8219B27C: 419A001C  beq cr6, 0x8219b298
	if ctx.cr[6].eq {
	pc = 0x8219B298; continue 'dispatch;
	}
	// 8219B280: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 8219B284: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 8219B288: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 8219B28C: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8219B290: 4198FFE4  blt cr6, 0x8219b274
	if ctx.cr[6].lt {
	pc = 0x8219B274; continue 'dispatch;
	}
	// 8219B294: 4800002C  b 0x8219b2c0
	pc = 0x8219B2C0; continue 'dispatch;
            }
            0x8219B298 => {
    //   block [0x8219B298..0x8219B2C0)
	// 8219B298: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219B29C: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 8219B2A0: 419A0020  beq cr6, 0x8219b2c0
	if ctx.cr[6].eq {
	pc = 0x8219B2C0; continue 'dispatch;
	}
	// 8219B2A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8219B2A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219B2AC: 480002ED  bl 0x8219b598
	ctx.lr = 0x8219B2B0;
	sub_8219B598(ctx, base);
	// 8219B2B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219B2B4: 409A000C  bne cr6, 0x8219b2c0
	if !ctx.cr[6].eq {
	pc = 0x8219B2C0; continue 'dispatch;
	}
	// 8219B2B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219B2BC: 4BFD98C5  bl 0x82174b80
	ctx.lr = 0x8219B2C0;
	sub_82174B80(ctx, base);
	pc = 0x8219B2C0; continue 'dispatch;
            }
            0x8219B2C0 => {
    //   block [0x8219B2C0..0x8219B2E8)
	// 8219B2C0: 83FD001C  lwz r31, 0x1c(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219B2C4: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219B2C8: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219B2CC: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 8219B2D0: 553E103A  slwi r30, r9, 2
	ctx.r[30].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 8219B2D4: 7D1E502E  lwzx r8, r30, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219B2D8: 2F080004  cmpwi cr6, r8, 4
	ctx.cr[6].compare_i32(ctx.r[8].s32, 4, &mut ctx.xer);
	// 8219B2DC: 4198000C  blt cr6, 0x8219b2e8
	if ctx.cr[6].lt {
	pc = 0x8219B2E8; continue 'dispatch;
	}
	// 8219B2E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219B2E4: 485A3E95  bl 0x8273f178
	ctx.lr = 0x8219B2E8;
	sub_8273F178(ctx, base);
	pc = 0x8219B2E8; continue 'dispatch;
            }
            0x8219B2E8 => {
    //   block [0x8219B2E8..0x8219B588)
	// 8219B2E8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B2EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219B2F0: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8219B2F4: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B2F8: 812A004C  lwz r9, 0x4c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) } as u64;
	// 8219B2FC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8219B300: 4E800421  bctrl
	ctx.lr = 0x8219B304;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219B304: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 8219B308: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
            }
            0x8219B588 => {
    //   block [0x8219B588..0x8219B598)
	// 8219B588: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8219B58C: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 8219B590: 48B12795  bl 0x82cadd24
	ctx.lr = 0x8219B594;
	sub_82CADCEC(ctx, base);
	// 8219B594: 48B0DEC0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219B598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219B598 size=880
    let mut pc: u32 = 0x8219B598;
    'dispatch: loop {
        match pc {
            0x8219B598 => {
    //   block [0x8219B598..0x8219B5F8)
	// 8219B598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219B59C: 48B0DE61  bl 0x82ca93fc
	ctx.lr = 0x8219B5A0;
	sub_82CA93D0(ctx, base);
	// 8219B5A0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8219B5A4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219B5A8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8219B5AC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8219B5B0: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 8219B5B4: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 8219B5B8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B5BC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8219B5C0: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 8219B5C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219B5C8: 419A00F4  beq cr6, 0x8219b6bc
	if ctx.cr[6].eq {
	pc = 0x8219B6BC; continue 'dispatch;
	}
	// 8219B5CC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219B5D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219B5D4: 419A0024  beq cr6, 0x8219b5f8
	if ctx.cr[6].eq {
	pc = 0x8219B5F8; continue 'dispatch;
	}
	// 8219B5D8: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 8219B5DC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219B5E0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8219B5E4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219B5E8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B5EC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8219B5F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219B5F4: 480000CC  b 0x8219b6c0
	pc = 0x8219B6C0; continue 'dispatch;
            }
            0x8219B5F8 => {
    //   block [0x8219B5F8..0x8219B614)
	// 8219B5F8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219B5FC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8219B600: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 8219B604: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8219B608: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8219B60C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219B610: 40810054  ble 0x8219b664
	if !ctx.cr[0].gt {
	pc = 0x8219B664; continue 'dispatch;
	}
	pc = 0x8219B614; continue 'dispatch;
            }
            0x8219B614 => {
    //   block [0x8219B614..0x8219B634)
	// 8219B614: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8219B618: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219B61C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8219B620: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B624: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8219B628: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8219B62C: 41980008  blt cr6, 0x8219b634
	if ctx.cr[6].lt {
	pc = 0x8219B634; continue 'dispatch;
	}
	// 8219B630: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x8219B634; continue 'dispatch;
            }
            0x8219B634 => {
    //   block [0x8219B634..0x8219B650)
	// 8219B634: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8219B638: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219B63C: 419A0014  beq cr6, 0x8219b650
	if ctx.cr[6].eq {
	pc = 0x8219B650; continue 'dispatch;
	}
	// 8219B640: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8219B644: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219B648: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8219B64C: 4800000C  b 0x8219b658
	pc = 0x8219B658; continue 'dispatch;
            }
            0x8219B650 => {
    //   block [0x8219B650..0x8219B658)
	// 8219B650: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8219B654: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8219B658; continue 'dispatch;
            }
            0x8219B658 => {
    //   block [0x8219B658..0x8219B664)
	// 8219B658: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219B65C: 4199FFB8  bgt cr6, 0x8219b614
	if ctx.cr[6].gt {
	pc = 0x8219B614; continue 'dispatch;
	}
	// 8219B660: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8219B664; continue 'dispatch;
            }
            0x8219B664 => {
    //   block [0x8219B664..0x8219B680)
	// 8219B664: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8219B668: 419A0040  beq cr6, 0x8219b6a8
	if ctx.cr[6].eq {
	pc = 0x8219B6A8; continue 'dispatch;
	}
	// 8219B66C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B670: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8219B674: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219B678: 41990008  bgt cr6, 0x8219b680
	if ctx.cr[6].gt {
	pc = 0x8219B680; continue 'dispatch;
	}
	// 8219B67C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x8219B680; continue 'dispatch;
            }
            0x8219B680 => {
    //   block [0x8219B680..0x8219B6A8)
	// 8219B680: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219B684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B688: 409A0020  bne cr6, 0x8219b6a8
	if !ctx.cr[6].eq {
	pc = 0x8219B6A8; continue 'dispatch;
	}
	// 8219B68C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219B690: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8219B694: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8219B698: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B69C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8219B6A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219B6A4: 4800001C  b 0x8219b6c0
	pc = 0x8219B6C0; continue 'dispatch;
            }
            0x8219B6A8 => {
    //   block [0x8219B6A8..0x8219B6BC)
	// 8219B6A8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8219B6AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B6B0: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8219B6B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219B6B8: 48000008  b 0x8219b6c0
	pc = 0x8219B6C0; continue 'dispatch;
            }
            0x8219B6BC => {
    //   block [0x8219B6BC..0x8219B6C0)
	// 8219B6BC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x8219B6C0; continue 'dispatch;
            }
            0x8219B6C0 => {
    //   block [0x8219B6C0..0x8219B700)
	// 8219B6C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219B6C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B6C8: 419A0234  beq cr6, 0x8219b8fc
	if ctx.cr[6].eq {
	pc = 0x8219B8FC; continue 'dispatch;
	}
	// 8219B6CC: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 8219B6D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B6D4: 419A0050  beq cr6, 0x8219b724
	if ctx.cr[6].eq {
	pc = 0x8219B724; continue 'dispatch;
	}
	// 8219B6D8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8219B6DC: 48083B7D  bl 0x8221f258
	ctx.lr = 0x8219B6E0;
	sub_8221F258(ctx, base);
	// 8219B6E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219B6E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219B6E8: C3EB92CC  lfs f31, -0x6d34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27956 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219B6EC: 419A0014  beq cr6, 0x8219b700
	if ctx.cr[6].eq {
	pc = 0x8219B700; continue 'dispatch;
	}
	// 8219B6F0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219B6F4: 480F044D  bl 0x8228bb40
	ctx.lr = 0x8219B6F8;
	sub_8228BB40(ctx, base);
	// 8219B6F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8219B6FC: 48000008  b 0x8219b704
	pc = 0x8219B704; continue 'dispatch;
            }
            0x8219B700 => {
    //   block [0x8219B700..0x8219B704)
	// 8219B700: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	pc = 0x8219B704; continue 'dispatch;
            }
            0x8219B704 => {
    //   block [0x8219B704..0x8219B724)
	// 8219B704: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8219B708: 48083B51  bl 0x8221f258
	ctx.lr = 0x8219B70C;
	sub_8221F258(ctx, base);
	// 8219B70C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219B710: 419A0060  beq cr6, 0x8219b770
	if ctx.cr[6].eq {
	pc = 0x8219B770; continue 'dispatch;
	}
	// 8219B714: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219B718: 4808E021  bl 0x82229738
	ctx.lr = 0x8219B71C;
	sub_82229738(ctx, base);
	// 8219B71C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219B720: 48000054  b 0x8219b774
	pc = 0x8219B774; continue 'dispatch;
            }
            0x8219B724 => {
    //   block [0x8219B724..0x8219B748)
	// 8219B724: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 8219B728: 48083B31  bl 0x8221f258
	ctx.lr = 0x8219B72C;
	sub_8221F258(ctx, base);
	// 8219B72C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219B730: 419A0018  beq cr6, 0x8219b748
	if ctx.cr[6].eq {
	pc = 0x8219B748; continue 'dispatch;
	}
	// 8219B734: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8219B738: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8219B73C: 394B18C0  addi r10, r11, 0x18c0
	ctx.r[10].s64 = ctx.r[11].s64 + 6336;
	// 8219B740: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8219B744: 48000008  b 0x8219b74c
	pc = 0x8219B74C; continue 'dispatch;
            }
            0x8219B748 => {
    //   block [0x8219B748..0x8219B74C)
	// 8219B748: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	pc = 0x8219B74C; continue 'dispatch;
            }
            0x8219B74C => {
    //   block [0x8219B74C..0x8219B770)
	// 8219B74C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 8219B750: 48083B09  bl 0x8221f258
	ctx.lr = 0x8219B754;
	sub_8221F258(ctx, base);
	// 8219B754: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219B758: 419A0018  beq cr6, 0x8219b770
	if ctx.cr[6].eq {
	pc = 0x8219B770; continue 'dispatch;
	}
	// 8219B75C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8219B760: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219B764: 394B1770  addi r10, r11, 0x1770
	ctx.r[10].s64 = ctx.r[11].s64 + 6000;
	// 8219B768: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8219B76C: 48000008  b 0x8219b774
	pc = 0x8219B774; continue 'dispatch;
            }
            0x8219B770 => {
    //   block [0x8219B770..0x8219B774)
	// 8219B770: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x8219B774; continue 'dispatch;
            }
            0x8219B774 => {
    //   block [0x8219B774..0x8219B798)
	// 8219B774: 817B0058  lwz r11, 0x58(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 8219B778: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B77C: 419A001C  beq cr6, 0x8219b798
	if ctx.cr[6].eq {
	pc = 0x8219B798; continue 'dispatch;
	}
	// 8219B780: 815B005C  lwz r10, 0x5c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(92 as u32) ) } as u64;
	// 8219B784: 3920003C  li r9, 0x3c
	ctx.r[9].s64 = 60;
	// 8219B788: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8219B78C: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 8219B790: 7F193840  cmplw cr6, r25, r7
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[7].u32, &mut ctx.xer);
	// 8219B794: 41980008  blt cr6, 0x8219b79c
	if ctx.cr[6].lt {
	pc = 0x8219B79C; continue 'dispatch;
	}
	pc = 0x8219B798; continue 'dispatch;
            }
            0x8219B798 => {
    //   block [0x8219B798..0x8219B79C)
	// 8219B798: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219B79C; continue 'dispatch;
            }
            0x8219B79C => {
    //   block [0x8219B79C..0x8219B7BC)
	// 8219B79C: 1D59003C  mulli r10, r25, 0x3c
	ctx.r[10].s32 = ((ctx.r[25].s32 as i64 * 60 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 8219B7A0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219B7A4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B7A8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B7AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219B7B0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8219B7B4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8219B7B8: 419A0020  beq cr6, 0x8219b7d8
	if ctx.cr[6].eq {
	pc = 0x8219B7D8; continue 'dispatch;
	}
	pc = 0x8219B7BC; continue 'dispatch;
            }
            0x8219B7BC => {
    //   block [0x8219B7BC..0x8219B7D8)
	// 8219B7BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8219B7C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219B7C4: 7D605028  lwarx r11, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8219B7C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8219B7CC: 7D60512D  stwcx. r11, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8219B7D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219B7D4: 4082FFE8  bne 0x8219b7bc
	if !ctx.cr[0].eq {
	pc = 0x8219B7BC; continue 'dispatch;
	}
	pc = 0x8219B7D8; continue 'dispatch;
            }
            0x8219B7D8 => {
    //   block [0x8219B7D8..0x8219B7F0)
	// 8219B7D8: 809B0050  lwz r4, 0x50(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219B7DC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219B7E0: 419A0010  beq cr6, 0x8219b7f0
	if ctx.cr[6].eq {
	pc = 0x8219B7F0; continue 'dispatch;
	}
	// 8219B7E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219B7E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219B7EC: 48112835  bl 0x822ae020
	ctx.lr = 0x8219B7F0;
	sub_822AE020(ctx, base);
	pc = 0x8219B7F0; continue 'dispatch;
            }
            0x8219B7F0 => {
    //   block [0x8219B7F0..0x8219B830)
	// 8219B7F0: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 8219B7F4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 8219B7F8: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 8219B7FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8219B800: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8219B804: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219B808: 48032939  bl 0x821ce140
	ctx.lr = 0x8219B80C;
	sub_821CE140(ctx, base);
	// 8219B80C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219B810: 817B0050  lwz r11, 0x50(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219B814: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B818: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8219B81C: 419A007C  beq cr6, 0x8219b898
	if ctx.cr[6].eq {
	pc = 0x8219B898; continue 'dispatch;
	}
	// 8219B820: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8219B824: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219B828: 419A0040  beq cr6, 0x8219b868
	if ctx.cr[6].eq {
	pc = 0x8219B868; continue 'dispatch;
	}
	// 8219B82C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8219B830; continue 'dispatch;
            }
            0x8219B830 => {
    //   block [0x8219B830..0x8219B864)
	// 8219B830: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8219B834: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219B838: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8219B83C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8219B840: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8219B844: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219B848: 4082FFE8  bne 0x8219b830
	if !ctx.cr[0].eq {
	pc = 0x8219B830; continue 'dispatch;
	}
	// 8219B84C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219B850: 409A0014  bne cr6, 0x8219b864
	if !ctx.cr[6].eq {
	pc = 0x8219B864; continue 'dispatch;
	}
	// 8219B854: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B858: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B85C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219B860: 4E800421  bctrl
	ctx.lr = 0x8219B864;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8219B864 => {
    //   block [0x8219B864..0x8219B868)
	// 8219B864: 935B0050  stw r26, 0x50(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	pc = 0x8219B868; continue 'dispatch;
            }
            0x8219B868 => {
    //   block [0x8219B868..0x8219B87C)
	// 8219B868: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B86C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B870: 917B0050  stw r11, 0x50(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8219B874: 419A0024  beq cr6, 0x8219b898
	if ctx.cr[6].eq {
	pc = 0x8219B898; continue 'dispatch;
	}
	// 8219B878: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x8219B87C; continue 'dispatch;
            }
            0x8219B87C => {
    //   block [0x8219B87C..0x8219B898)
	// 8219B87C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8219B880: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219B884: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8219B888: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219B88C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8219B890: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219B894: 4082FFE8  bne 0x8219b87c
	if !ctx.cr[0].eq {
	pc = 0x8219B87C; continue 'dispatch;
	}
	pc = 0x8219B898; continue 'dispatch;
            }
            0x8219B898 => {
    //   block [0x8219B898..0x8219B8AC)
	// 8219B898: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219B89C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B8A0: 419A0048  beq cr6, 0x8219b8e8
	if ctx.cr[6].eq {
	pc = 0x8219B8E8; continue 'dispatch;
	}
	// 8219B8A4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8219B8A8: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x8219B8AC; continue 'dispatch;
            }
            0x8219B8AC => {
    //   block [0x8219B8AC..0x8219B8E4)
	// 8219B8AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8219B8B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219B8B4: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8219B8B8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8219B8BC: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8219B8C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219B8C4: 4082FFE8  bne 0x8219b8ac
	if !ctx.cr[0].eq {
	pc = 0x8219B8AC; continue 'dispatch;
	}
	// 8219B8C8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8219B8CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219B8D0: 409A0014  bne cr6, 0x8219b8e4
	if !ctx.cr[6].eq {
	pc = 0x8219B8E4; continue 'dispatch;
	}
	// 8219B8D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B8D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B8DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219B8E0: 4E800421  bctrl
	ctx.lr = 0x8219B8E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8219B8E4 => {
    //   block [0x8219B8E4..0x8219B8E8)
	// 8219B8E4: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	pc = 0x8219B8E8; continue 'dispatch;
            }
            0x8219B8E8 => {
    //   block [0x8219B8E8..0x8219B8FC)
	// 8219B8E8: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219B8EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8219B8F0: 933B001C  stw r25, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[25].u32 ) };
	// 8219B8F4: 917B0020  stw r11, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 8219B8F8: 4801C221  bl 0x821b7b18
	ctx.lr = 0x8219B8FC;
	sub_821B7B18(ctx, base);
	pc = 0x8219B8FC; continue 'dispatch;
            }
            0x8219B8FC => {
    //   block [0x8219B8FC..0x8219B908)
	// 8219B8FC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8219B900: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8219B904: 48B0DB48  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219B908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219B908 size=1740
    let mut pc: u32 = 0x8219B908;
    'dispatch: loop {
        match pc {
            0x8219B908 => {
    //   block [0x8219B908..0x8219B9F0)
	// 8219B908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219B90C: 48B0DAE5  bl 0x82ca93f0
	ctx.lr = 0x8219B910;
	sub_82CA93D0(ctx, base);
	// 8219B910: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219B914: 3EE08332  lis r23, -0x7cce
	ctx.r[23].s64 = -2093875200;
	// 8219B918: 81778568  lwz r11, -0x7a98(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-31384 as u32) ) } as u64;
	// 8219B91C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 8219B920: 419A06AC  beq cr6, 0x8219bfcc
	if ctx.cr[6].eq {
	pc = 0x8219BFCC; continue 'dispatch;
	}
	// 8219B924: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 8219B928: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8219B92C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219B930: 39290EA4  addi r9, r9, 0xea4
	ctx.r[9].s64 = ctx.r[9].s64 + 3748;
	// 8219B934: 3B8A02B0  addi r28, r10, 0x2b0
	ctx.r[28].s64 = ctx.r[10].s64 + 688;
	// 8219B938: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8219B93C: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 8219B940: 3CC00800  lis r6, 0x800
	ctx.r[6].s64 = 134217728;
	// 8219B944: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8219B948: 917C0010  stw r11, 0x10(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8219B94C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219B950: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 8219B954: 4801B58D  bl 0x821b6ee0
	ctx.lr = 0x8219B958;
	sub_821B6EE0(ctx, base);
	// 8219B958: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 8219B95C: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 8219B960: 3BEA63A0  addi r31, r10, 0x63a0
	ctx.r[31].s64 = ctx.r[10].s64 + 25504;
	// 8219B964: 3BCB6F38  addi r30, r11, 0x6f38
	ctx.r[30].s64 = ctx.r[11].s64 + 28472;
	// 8219B968: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 8219B96C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8219B970: 3BAA2390  addi r29, r10, 0x2390
	ctx.r[29].s64 = ctx.r[10].s64 + 9104;
	// 8219B974: 891F0B25  lbz r8, 0xb25(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2853 as u32) ) } as u64;
	// 8219B978: 3ACB0DB8  addi r22, r11, 0xdb8
	ctx.r[22].s64 = ctx.r[11].s64 + 3512;
	// 8219B97C: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 8219B980: 1D282008  mulli r9, r8, 0x2008
	ctx.r[9].s32 = ((ctx.r[8].s32 as i64 * 8200 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8219B984: 7D29EA14  add r9, r9, r29
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 8219B988: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219B98C: 817F0B14  lwz r11, 0xb14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2836 as u32) ) } as u64;
	// 8219B990: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 8219B994: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219B998: 3969DFF8  addi r11, r9, -0x2008
	ctx.r[11].s64 = ctx.r[9].s64 + -8200;
	// 8219B99C: 419A0088  beq cr6, 0x8219ba24
	if ctx.cr[6].eq {
	pc = 0x8219BA24; continue 'dispatch;
	}
	// 8219B9A0: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 8219B9A4: 811F0B18  lwz r8, 0xb18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2840 as u32) ) } as u64;
	// 8219B9A8: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 8219B9AC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8219B9B0: 409A0040  bne cr6, 0x8219b9f0
	if !ctx.cr[6].eq {
	pc = 0x8219B9F0; continue 'dispatch;
	}
	// 8219B9B4: 80CB2004  lwz r6, 0x2004(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219B9B8: 7D2A4378  or r10, r9, r8
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 8219B9BC: 38BF0B10  addi r5, r31, 0xb10
	ctx.r[5].s64 = ctx.r[31].s64 + 2832;
	// 8219B9C0: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8219B9C4: 915F0B18  stw r10, 0xb18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2840 as u32), ctx.r[10].u32 ) };
	// 8219B9C8: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 8219B9CC: 815F0B14  lwz r10, 0xb14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2836 as u32) ) } as u64;
	// 8219B9D0: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219B9D4: 54691838  slwi r9, r3, 3
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8219B9D8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8219B9DC: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8219B9E0: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219B9E4: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 8219B9E8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219B9EC: 910B2004  stw r8, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x8219B9F0; continue 'dispatch;
            }
            0x8219B9F0 => {
    //   block [0x8219B9F0..0x8219BA24)
	// 8219B9F0: 897F0B24  lbz r11, 0xb24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2852 as u32) ) } as u64;
	// 8219B9F4: 90FF0B14  stw r7, 0xb14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2836 as u32), ctx.r[7].u32 ) };
	// 8219B9F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B9FC: 409A0028  bne cr6, 0x8219ba24
	if !ctx.cr[6].eq {
	pc = 0x8219BA24; continue 'dispatch;
	}
	// 8219BA00: 81780DB0  lwz r11, 0xdb0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(3504 as u32) ) } as u64;
	// 8219BA04: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8219BA08: 391F0B10  addi r8, r31, 0xb10
	ctx.r[8].s64 = ctx.r[31].s64 + 2832;
	// 8219BA0C: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8219BA10: 993F0B24  stb r9, 0xb24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2852 as u32), ctx.r[9].u8 ) };
	// 8219BA14: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 8219BA18: 90F80DB0  stw r7, 0xdb0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 8219BA1C: 7D06B12E  stwx r8, r6, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[22].u32), ctx.r[8].u32) };
	// 8219BA20: 48000008  b 0x8219ba28
	pc = 0x8219BA28; continue 'dispatch;
            }
            0x8219BA24 => {
    //   block [0x8219BA24..0x8219BA28)
	// 8219BA24: 80F80DB0  lwz r7, 0xdb0(r24)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x8219BA28; continue 'dispatch;
            }
            0x8219BA28 => {
    //   block [0x8219BA28..0x8219BA90)
	// 8219BA28: 897F0D05  lbz r11, 0xd05(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3333 as u32) ) } as u64;
	// 8219BA2C: 813F0CF4  lwz r9, 0xcf4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(3316 as u32) ) } as u64;
	// 8219BA30: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8219BA34: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8219BA38: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219BA3C: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 8219BA40: 419A007C  beq cr6, 0x8219babc
	if ctx.cr[6].eq {
	pc = 0x8219BABC; continue 'dispatch;
	}
	// 8219BA44: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 8219BA48: 811F0CF8  lwz r8, 0xcf8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(3320 as u32) ) } as u64;
	// 8219BA4C: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 8219BA50: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8219BA54: 409A003C  bne cr6, 0x8219ba90
	if !ctx.cr[6].eq {
	pc = 0x8219BA90; continue 'dispatch;
	}
	// 8219BA58: 80CB2004  lwz r6, 0x2004(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BA5C: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 8219BA60: 38BF0CF0  addi r5, r31, 0xcf0
	ctx.r[5].s64 = ctx.r[31].s64 + 3312;
	// 8219BA64: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8219BA68: 913F0CF8  stw r9, 0xcf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3320 as u32), ctx.r[9].u32 ) };
	// 8219BA6C: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 8219BA70: 813F0CF4  lwz r9, 0xcf4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(3316 as u32) ) } as u64;
	// 8219BA74: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BA78: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219BA7C: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 8219BA80: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8219BA84: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BA88: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 8219BA8C: 90CB2004  stw r6, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x8219BA90; continue 'dispatch;
            }
            0x8219BA90 => {
    //   block [0x8219BA90..0x8219BABC)
	// 8219BA90: 897F0D04  lbz r11, 0xd04(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3332 as u32) ) } as u64;
	// 8219BA94: 915F0CF4  stw r10, 0xcf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3316 as u32), ctx.r[10].u32 ) };
	// 8219BA98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219BA9C: 409A0020  bne cr6, 0x8219babc
	if !ctx.cr[6].eq {
	pc = 0x8219BABC; continue 'dispatch;
	}
	// 8219BAA0: 54EA103A  slwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219BAA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219BAA8: 393F0CF0  addi r9, r31, 0xcf0
	ctx.r[9].s64 = ctx.r[31].s64 + 3312;
	// 8219BAAC: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 8219BAB0: 997F0D04  stb r11, 0xd04(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(3332 as u32), ctx.r[11].u8 ) };
	// 8219BAB4: 90F80DB0  stw r7, 0xdb0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 8219BAB8: 7D2AB12E  stwx r9, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[9].u32) };
	pc = 0x8219BABC; continue 'dispatch;
            }
            0x8219BABC => {
    //   block [0x8219BABC..0x8219BB38)
	// 8219BABC: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 8219BAC0: 897F12A5  lbz r11, 0x12a5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4773 as u32) ) } as u64;
	// 8219BAC4: 813F1294  lwz r9, 0x1294(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4756 as u32) ) } as u64;
	// 8219BAC8: 3B4A6FC0  addi r26, r10, 0x6fc0
	ctx.r[26].s64 = ctx.r[10].s64 + 28608;
	// 8219BACC: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8219BAD0: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219BAD4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8219BAD8: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 8219BADC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219BAE0: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 8219BAE4: 419A0080  beq cr6, 0x8219bb64
	if ctx.cr[6].eq {
	pc = 0x8219BB64; continue 'dispatch;
	}
	// 8219BAE8: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 8219BAEC: 811F1298  lwz r8, 0x1298(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4760 as u32) ) } as u64;
	// 8219BAF0: 7D254038  and r5, r9, r8
	ctx.r[5].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 8219BAF4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8219BAF8: 409A0040  bne cr6, 0x8219bb38
	if !ctx.cr[6].eq {
	pc = 0x8219BB38; continue 'dispatch;
	}
	// 8219BAFC: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BB00: 7D2A4378  or r10, r9, r8
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 8219BB04: 389F1290  addi r4, r31, 0x1290
	ctx.r[4].s64 = ctx.r[31].s64 + 4752;
	// 8219BB08: 54A31838  slwi r3, r5, 3
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8219BB0C: 915F1298  stw r10, 0x1298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4760 as u32), ctx.r[10].u32 ) };
	// 8219BB10: 7C83592E  stwx r4, r3, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), ctx.r[4].u32) };
	// 8219BB14: 815F1294  lwz r10, 0x1294(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4756 as u32) ) } as u64;
	// 8219BB18: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BB1C: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8219BB20: 7D095A14  add r8, r9, r11
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8219BB24: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8219BB28: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BB2C: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 8219BB30: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219BB34: 90AB2004  stw r5, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	pc = 0x8219BB38; continue 'dispatch;
            }
            0x8219BB38 => {
    //   block [0x8219BB38..0x8219BB64)
	// 8219BB38: 897F12A4  lbz r11, 0x12a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4772 as u32) ) } as u64;
	// 8219BB3C: 90DF1294  stw r6, 0x1294(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4756 as u32), ctx.r[6].u32 ) };
	// 8219BB40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219BB44: 409A0020  bne cr6, 0x8219bb64
	if !ctx.cr[6].eq {
	pc = 0x8219BB64; continue 'dispatch;
	}
	// 8219BB48: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8219BB4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219BB50: 391F1290  addi r8, r31, 0x1290
	ctx.r[8].s64 = ctx.r[31].s64 + 4752;
	// 8219BB54: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 8219BB58: 997F12A4  stb r11, 0x12a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4772 as u32), ctx.r[11].u8 ) };
	// 8219BB5C: 90F80DB0  stw r7, 0xdb0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 8219BB60: 7D09B12E  stwx r8, r9, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[22].u32), ctx.r[8].u32) };
	pc = 0x8219BB64; continue 'dispatch;
            }
            0x8219BB64 => {
    //   block [0x8219BB64..0x8219BBCC)
	// 8219BB64: 897F10C5  lbz r11, 0x10c5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4293 as u32) ) } as u64;
	// 8219BB68: 813F10B4  lwz r9, 0x10b4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4276 as u32) ) } as u64;
	// 8219BB6C: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8219BB70: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8219BB74: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219BB78: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 8219BB7C: 419A007C  beq cr6, 0x8219bbf8
	if ctx.cr[6].eq {
	pc = 0x8219BBF8; continue 'dispatch;
	}
	// 8219BB80: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 8219BB84: 811F10B8  lwz r8, 0x10b8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4280 as u32) ) } as u64;
	// 8219BB88: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 8219BB8C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8219BB90: 409A003C  bne cr6, 0x8219bbcc
	if !ctx.cr[6].eq {
	pc = 0x8219BBCC; continue 'dispatch;
	}
	// 8219BB94: 80CB2004  lwz r6, 0x2004(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BB98: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 8219BB9C: 38BF10B0  addi r5, r31, 0x10b0
	ctx.r[5].s64 = ctx.r[31].s64 + 4272;
	// 8219BBA0: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8219BBA4: 913F10B8  stw r9, 0x10b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4280 as u32), ctx.r[9].u32 ) };
	// 8219BBA8: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 8219BBAC: 813F10B4  lwz r9, 0x10b4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4276 as u32) ) } as u64;
	// 8219BBB0: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BBB4: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219BBB8: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 8219BBBC: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8219BBC0: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BBC4: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 8219BBC8: 90CB2004  stw r6, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x8219BBCC; continue 'dispatch;
            }
            0x8219BBCC => {
    //   block [0x8219BBCC..0x8219BBF8)
	// 8219BBCC: 897F10C4  lbz r11, 0x10c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4292 as u32) ) } as u64;
	// 8219BBD0: 915F10B4  stw r10, 0x10b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4276 as u32), ctx.r[10].u32 ) };
	// 8219BBD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219BBD8: 409A0020  bne cr6, 0x8219bbf8
	if !ctx.cr[6].eq {
	pc = 0x8219BBF8; continue 'dispatch;
	}
	// 8219BBDC: 54EA103A  slwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219BBE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219BBE4: 393F10B0  addi r9, r31, 0x10b0
	ctx.r[9].s64 = ctx.r[31].s64 + 4272;
	// 8219BBE8: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 8219BBEC: 997F10C4  stb r11, 0x10c4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4292 as u32), ctx.r[11].u8 ) };
	// 8219BBF0: 90F80DB0  stw r7, 0xdb0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 8219BBF4: 7D2AB12E  stwx r9, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[9].u32) };
	pc = 0x8219BBF8; continue 'dispatch;
            }
            0x8219BBF8 => {
    //   block [0x8219BBF8..0x8219BC68)
	// 8219BBF8: 897F0945  lbz r11, 0x945(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2373 as u32) ) } as u64;
	// 8219BBFC: 3F208331  lis r25, -0x7ccf
	ctx.r[25].s64 = -2093940736;
	// 8219BC00: 815F0934  lwz r10, 0x934(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2356 as u32) ) } as u64;
	// 8219BC04: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8219BC08: 81196FCC  lwz r8, 0x6fcc(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28620 as u32) ) } as u64;
	// 8219BC0C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8219BC10: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8219BC14: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 8219BC18: 419A007C  beq cr6, 0x8219bc94
	if ctx.cr[6].eq {
	pc = 0x8219BC94; continue 'dispatch;
	}
	// 8219BC1C: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 8219BC20: 813F0938  lwz r9, 0x938(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2360 as u32) ) } as u64;
	// 8219BC24: 7D464838  and r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 8219BC28: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8219BC2C: 409A003C  bne cr6, 0x8219bc68
	if !ctx.cr[6].eq {
	pc = 0x8219BC68; continue 'dispatch;
	}
	// 8219BC30: 80CB2004  lwz r6, 0x2004(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BC34: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 8219BC38: 38BF0930  addi r5, r31, 0x930
	ctx.r[5].s64 = ctx.r[31].s64 + 2352;
	// 8219BC3C: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8219BC40: 915F0938  stw r10, 0x938(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2360 as u32), ctx.r[10].u32 ) };
	// 8219BC44: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 8219BC48: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BC4C: 54691838  slwi r9, r3, 3
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8219BC50: 815F0934  lwz r10, 0x934(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2356 as u32) ) } as u64;
	// 8219BC54: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8219BC58: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8219BC5C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BC60: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 8219BC64: 90CB2004  stw r6, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x8219BC68; continue 'dispatch;
            }
            0x8219BC68 => {
    //   block [0x8219BC68..0x8219BC94)
	// 8219BC68: 897F0944  lbz r11, 0x944(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2372 as u32) ) } as u64;
	// 8219BC6C: 911F0934  stw r8, 0x934(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2356 as u32), ctx.r[8].u32 ) };
	// 8219BC70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219BC74: 409A0020  bne cr6, 0x8219bc94
	if !ctx.cr[6].eq {
	pc = 0x8219BC94; continue 'dispatch;
	}
	// 8219BC78: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8219BC7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219BC80: 391F0930  addi r8, r31, 0x930
	ctx.r[8].s64 = ctx.r[31].s64 + 2352;
	// 8219BC84: 39470001  addi r10, r7, 1
	ctx.r[10].s64 = ctx.r[7].s64 + 1;
	// 8219BC88: 997F0944  stb r11, 0x944(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2372 as u32), ctx.r[11].u8 ) };
	// 8219BC8C: 91580DB0  stw r10, 0xdb0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 8219BC90: 7D09B12E  stwx r8, r9, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[22].u32), ctx.r[8].u32) };
	pc = 0x8219BC94; continue 'dispatch;
            }
            0x8219BC94 => {
    //   block [0x8219BC94..0x8219BD34)
	// 8219BC94: 81778568  lwz r11, -0x7a98(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-31384 as u32) ) } as u64;
	// 8219BC98: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8219BC9C: 3CC00400  lis r6, 0x400
	ctx.r[6].s64 = 67108864;
	// 8219BCA0: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 8219BCA4: 394A0F60  addi r10, r10, 0xf60
	ctx.r[10].s64 = ctx.r[10].s64 + 3936;
	// 8219BCA8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219BCAC: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8219BCB0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8219BCB4: 917C0014  stw r11, 0x14(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 8219BCB8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219BCBC: 4801B225  bl 0x821b6ee0
	ctx.lr = 0x8219BCC0;
	sub_821B6EE0(ctx, base);
	// 8219BCC0: 893F0B3D  lbz r9, 0xb3d(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2877 as u32) ) } as u64;
	// 8219BCC4: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219BCC8: 1D292008  mulli r9, r9, 0x2008
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 8200 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8219BCCC: 817F0B2C  lwz r11, 0xb2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2860 as u32) ) } as u64;
	// 8219BCD0: 7D29EA14  add r9, r9, r29
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 8219BCD4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219BCD8: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 8219BCDC: 3969DFF8  addi r11, r9, -0x2008
	ctx.r[11].s64 = ctx.r[9].s64 + -8200;
	// 8219BCE0: 419A0088  beq cr6, 0x8219bd68
	if ctx.cr[6].eq {
	pc = 0x8219BD68; continue 'dispatch;
	}
	// 8219BCE4: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 8219BCE8: 811F0B30  lwz r8, 0xb30(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2864 as u32) ) } as u64;
	// 8219BCEC: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 8219BCF0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8219BCF4: 409A0040  bne cr6, 0x8219bd34
	if !ctx.cr[6].eq {
	pc = 0x8219BD34; continue 'dispatch;
	}
	// 8219BCF8: 80CB2004  lwz r6, 0x2004(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BCFC: 7D2A4378  or r10, r9, r8
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 8219BD00: 38BF0B28  addi r5, r31, 0xb28
	ctx.r[5].s64 = ctx.r[31].s64 + 2856;
	// 8219BD04: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8219BD08: 915F0B30  stw r10, 0xb30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2864 as u32), ctx.r[10].u32 ) };
	// 8219BD0C: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 8219BD10: 815F0B2C  lwz r10, 0xb2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2860 as u32) ) } as u64;
	// 8219BD14: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BD18: 54691838  slwi r9, r3, 3
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8219BD1C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8219BD20: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8219BD24: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BD28: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 8219BD2C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219BD30: 910B2004  stw r8, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x8219BD34; continue 'dispatch;
            }
            0x8219BD34 => {
    //   block [0x8219BD34..0x8219BD68)
	// 8219BD34: 897F0B3C  lbz r11, 0xb3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2876 as u32) ) } as u64;
	// 8219BD38: 90FF0B2C  stw r7, 0xb2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2860 as u32), ctx.r[7].u32 ) };
	// 8219BD3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219BD40: 409A0028  bne cr6, 0x8219bd68
	if !ctx.cr[6].eq {
	pc = 0x8219BD68; continue 'dispatch;
	}
	// 8219BD44: 81780DB0  lwz r11, 0xdb0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(3504 as u32) ) } as u64;
	// 8219BD48: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8219BD4C: 391F0B28  addi r8, r31, 0xb28
	ctx.r[8].s64 = ctx.r[31].s64 + 2856;
	// 8219BD50: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8219BD54: 993F0B3C  stb r9, 0xb3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2876 as u32), ctx.r[9].u8 ) };
	// 8219BD58: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 8219BD5C: 90F80DB0  stw r7, 0xdb0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 8219BD60: 7D06B12E  stwx r8, r6, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[22].u32), ctx.r[8].u32) };
	// 8219BD64: 48000008  b 0x8219bd6c
	pc = 0x8219BD6C; continue 'dispatch;
            }
            0x8219BD68 => {
    //   block [0x8219BD68..0x8219BD6C)
	// 8219BD68: 80F80DB0  lwz r7, 0xdb0(r24)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x8219BD6C; continue 'dispatch;
            }
            0x8219BD6C => {
    //   block [0x8219BD6C..0x8219BDD4)
	// 8219BD6C: 897F0D1D  lbz r11, 0xd1d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3357 as u32) ) } as u64;
	// 8219BD70: 813F0D0C  lwz r9, 0xd0c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(3340 as u32) ) } as u64;
	// 8219BD74: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8219BD78: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8219BD7C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219BD80: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 8219BD84: 419A007C  beq cr6, 0x8219be00
	if ctx.cr[6].eq {
	pc = 0x8219BE00; continue 'dispatch;
	}
	// 8219BD88: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 8219BD8C: 811F0D10  lwz r8, 0xd10(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(3344 as u32) ) } as u64;
	// 8219BD90: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 8219BD94: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8219BD98: 409A003C  bne cr6, 0x8219bdd4
	if !ctx.cr[6].eq {
	pc = 0x8219BDD4; continue 'dispatch;
	}
	// 8219BD9C: 80CB2004  lwz r6, 0x2004(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BDA0: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 8219BDA4: 38BF0D08  addi r5, r31, 0xd08
	ctx.r[5].s64 = ctx.r[31].s64 + 3336;
	// 8219BDA8: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8219BDAC: 913F0D10  stw r9, 0xd10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3344 as u32), ctx.r[9].u32 ) };
	// 8219BDB0: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 8219BDB4: 813F0D0C  lwz r9, 0xd0c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(3340 as u32) ) } as u64;
	// 8219BDB8: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BDBC: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219BDC0: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 8219BDC4: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8219BDC8: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BDCC: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 8219BDD0: 90CB2004  stw r6, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x8219BDD4; continue 'dispatch;
            }
            0x8219BDD4 => {
    //   block [0x8219BDD4..0x8219BE00)
	// 8219BDD4: 897F0D1C  lbz r11, 0xd1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3356 as u32) ) } as u64;
	// 8219BDD8: 915F0D0C  stw r10, 0xd0c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3340 as u32), ctx.r[10].u32 ) };
	// 8219BDDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219BDE0: 409A0020  bne cr6, 0x8219be00
	if !ctx.cr[6].eq {
	pc = 0x8219BE00; continue 'dispatch;
	}
	// 8219BDE4: 54EA103A  slwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219BDE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219BDEC: 393F0D08  addi r9, r31, 0xd08
	ctx.r[9].s64 = ctx.r[31].s64 + 3336;
	// 8219BDF0: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 8219BDF4: 997F0D1C  stb r11, 0xd1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(3356 as u32), ctx.r[11].u8 ) };
	// 8219BDF8: 90F80DB0  stw r7, 0xdb0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 8219BDFC: 7D2AB12E  stwx r9, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[9].u32) };
	pc = 0x8219BE00; continue 'dispatch;
            }
            0x8219BE00 => {
    //   block [0x8219BE00..0x8219BE74)
	// 8219BE00: 897F12BD  lbz r11, 0x12bd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4797 as u32) ) } as u64;
	// 8219BE04: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219BE08: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8219BE0C: 813F12AC  lwz r9, 0x12ac(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4780 as u32) ) } as u64;
	// 8219BE10: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8219BE14: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 8219BE18: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219BE1C: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 8219BE20: 419A0080  beq cr6, 0x8219bea0
	if ctx.cr[6].eq {
	pc = 0x8219BEA0; continue 'dispatch;
	}
	// 8219BE24: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 8219BE28: 811F12B0  lwz r8, 0x12b0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4784 as u32) ) } as u64;
	// 8219BE2C: 7D054838  and r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 8219BE30: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8219BE34: 409A0040  bne cr6, 0x8219be74
	if !ctx.cr[6].eq {
	pc = 0x8219BE74; continue 'dispatch;
	}
	// 8219BE38: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BE3C: 7D0A4B78  or r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 8219BE40: 389F12A8  addi r4, r31, 0x12a8
	ctx.r[4].s64 = ctx.r[31].s64 + 4776;
	// 8219BE44: 54A31838  slwi r3, r5, 3
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8219BE48: 915F12B0  stw r10, 0x12b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4784 as u32), ctx.r[10].u32 ) };
	// 8219BE4C: 7C83592E  stwx r4, r3, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), ctx.r[4].u32) };
	// 8219BE50: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BE54: 55491838  slwi r9, r10, 3
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8219BE58: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8219BE5C: 815F12AC  lwz r10, 0x12ac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4780 as u32) ) } as u64;
	// 8219BE60: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8219BE64: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BE68: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219BE6C: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 8219BE70: 910B2004  stw r8, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x8219BE74; continue 'dispatch;
            }
            0x8219BE74 => {
    //   block [0x8219BE74..0x8219BEA0)
	// 8219BE74: 897F12BC  lbz r11, 0x12bc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4796 as u32) ) } as u64;
	// 8219BE78: 90DF12AC  stw r6, 0x12ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4780 as u32), ctx.r[6].u32 ) };
	// 8219BE7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219BE80: 409A0020  bne cr6, 0x8219bea0
	if !ctx.cr[6].eq {
	pc = 0x8219BEA0; continue 'dispatch;
	}
	// 8219BE84: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8219BE88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219BE8C: 391F12A8  addi r8, r31, 0x12a8
	ctx.r[8].s64 = ctx.r[31].s64 + 4776;
	// 8219BE90: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 8219BE94: 997F12BC  stb r11, 0x12bc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4796 as u32), ctx.r[11].u8 ) };
	// 8219BE98: 90F80DB0  stw r7, 0xdb0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 8219BE9C: 7D09B12E  stwx r8, r9, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[22].u32), ctx.r[8].u32) };
	pc = 0x8219BEA0; continue 'dispatch;
            }
            0x8219BEA0 => {
    //   block [0x8219BEA0..0x8219BF08)
	// 8219BEA0: 897F10DD  lbz r11, 0x10dd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4317 as u32) ) } as u64;
	// 8219BEA4: 813F10CC  lwz r9, 0x10cc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4300 as u32) ) } as u64;
	// 8219BEA8: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8219BEAC: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8219BEB0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219BEB4: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 8219BEB8: 419A007C  beq cr6, 0x8219bf34
	if ctx.cr[6].eq {
	pc = 0x8219BF34; continue 'dispatch;
	}
	// 8219BEBC: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 8219BEC0: 811F10D0  lwz r8, 0x10d0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4304 as u32) ) } as u64;
	// 8219BEC4: 7D064838  and r6, r8, r9
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 8219BEC8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8219BECC: 409A003C  bne cr6, 0x8219bf08
	if !ctx.cr[6].eq {
	pc = 0x8219BF08; continue 'dispatch;
	}
	// 8219BED0: 80CB2004  lwz r6, 0x2004(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BED4: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 8219BED8: 38BF10C8  addi r5, r31, 0x10c8
	ctx.r[5].s64 = ctx.r[31].s64 + 4296;
	// 8219BEDC: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8219BEE0: 913F10D0  stw r9, 0x10d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4304 as u32), ctx.r[9].u32 ) };
	// 8219BEE4: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 8219BEE8: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BEEC: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219BEF0: 813F10CC  lwz r9, 0x10cc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4300 as u32) ) } as u64;
	// 8219BEF4: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 8219BEF8: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8219BEFC: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BF00: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 8219BF04: 90CB2004  stw r6, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x8219BF08; continue 'dispatch;
            }
            0x8219BF08 => {
    //   block [0x8219BF08..0x8219BF34)
	// 8219BF08: 897F10DC  lbz r11, 0x10dc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4316 as u32) ) } as u64;
	// 8219BF0C: 915F10CC  stw r10, 0x10cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4300 as u32), ctx.r[10].u32 ) };
	// 8219BF10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219BF14: 409A0020  bne cr6, 0x8219bf34
	if !ctx.cr[6].eq {
	pc = 0x8219BF34; continue 'dispatch;
	}
	// 8219BF18: 54EA103A  slwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219BF1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219BF20: 393F10C8  addi r9, r31, 0x10c8
	ctx.r[9].s64 = ctx.r[31].s64 + 4296;
	// 8219BF24: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 8219BF28: 997F10DC  stb r11, 0x10dc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4316 as u32), ctx.r[11].u8 ) };
	// 8219BF2C: 90F80DB0  stw r7, 0xdb0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 8219BF30: 7D2AB12E  stwx r9, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[9].u32) };
	pc = 0x8219BF34; continue 'dispatch;
            }
            0x8219BF34 => {
    //   block [0x8219BF34..0x8219BFA0)
	// 8219BF34: 897F095D  lbz r11, 0x95d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2397 as u32) ) } as u64;
	// 8219BF38: 81196FCC  lwz r8, 0x6fcc(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28620 as u32) ) } as u64;
	// 8219BF3C: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8219BF40: 815F094C  lwz r10, 0x94c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2380 as u32) ) } as u64;
	// 8219BF44: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8219BF48: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8219BF4C: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 8219BF50: 419A007C  beq cr6, 0x8219bfcc
	if ctx.cr[6].eq {
	pc = 0x8219BFCC; continue 'dispatch;
	}
	// 8219BF54: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 8219BF58: 813F0950  lwz r9, 0x950(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2384 as u32) ) } as u64;
	// 8219BF5C: 7D265038  and r6, r9, r10
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 8219BF60: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8219BF64: 409A003C  bne cr6, 0x8219bfa0
	if !ctx.cr[6].eq {
	pc = 0x8219BFA0; continue 'dispatch;
	}
	// 8219BF68: 80CB2004  lwz r6, 0x2004(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BF6C: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 8219BF70: 38BF0948  addi r5, r31, 0x948
	ctx.r[5].s64 = ctx.r[31].s64 + 2376;
	// 8219BF74: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8219BF78: 915F0950  stw r10, 0x950(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2384 as u32), ctx.r[10].u32 ) };
	// 8219BF7C: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 8219BF80: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BF84: 815F094C  lwz r10, 0x94c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2380 as u32) ) } as u64;
	// 8219BF88: 54691838  slwi r9, r3, 3
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8219BF8C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8219BF90: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8219BF94: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 8219BF98: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 8219BF9C: 90CB2004  stw r6, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x8219BFA0; continue 'dispatch;
            }
            0x8219BFA0 => {
    //   block [0x8219BFA0..0x8219BFCC)
	// 8219BFA0: 897F095C  lbz r11, 0x95c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2396 as u32) ) } as u64;
	// 8219BFA4: 911F094C  stw r8, 0x94c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2380 as u32), ctx.r[8].u32 ) };
	// 8219BFA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219BFAC: 409A0020  bne cr6, 0x8219bfcc
	if !ctx.cr[6].eq {
	pc = 0x8219BFCC; continue 'dispatch;
	}
	// 8219BFB0: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8219BFB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219BFB8: 391F0948  addi r8, r31, 0x948
	ctx.r[8].s64 = ctx.r[31].s64 + 2376;
	// 8219BFBC: 39470001  addi r10, r7, 1
	ctx.r[10].s64 = ctx.r[7].s64 + 1;
	// 8219BFC0: 997F095C  stb r11, 0x95c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2396 as u32), ctx.r[11].u8 ) };
	// 8219BFC4: 91580DB0  stw r10, 0xdb0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 8219BFC8: 7D09B12E  stwx r8, r9, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[22].u32), ctx.r[8].u32) };
	pc = 0x8219BFCC; continue 'dispatch;
            }
            0x8219BFCC => {
    //   block [0x8219BFCC..0x8219BFD4)
	// 8219BFCC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8219BFD0: 48B0D470  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219BFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219BFD8 size=188
    let mut pc: u32 = 0x8219BFD8;
    'dispatch: loop {
        match pc {
            0x8219BFD8 => {
    //   block [0x8219BFD8..0x8219C044)
	// 8219BFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219BFDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219BFE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219BFE4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8219BFE8: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 8219BFEC: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 8219BFF0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219BFF4: 2F09001F  cmpwi cr6, r9, 0x1f
	ctx.cr[6].compare_i32(ctx.r[9].s32, 31, &mut ctx.xer);
	// 8219BFF8: 419A0088  beq cr6, 0x8219c080
	if ctx.cr[6].eq {
	pc = 0x8219C080; continue 'dispatch;
	}
	// 8219BFFC: 89630023  lbz r11, 0x23(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(35 as u32) ) } as u64;
	// 8219C000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C004: 409A0068  bne cr6, 0x8219c06c
	if !ctx.cr[6].eq {
	pc = 0x8219C06C; continue 'dispatch;
	}
	// 8219C008: 89630024  lbz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 8219C00C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C010: 409A005C  bne cr6, 0x8219c06c
	if !ctx.cr[6].eq {
	pc = 0x8219C06C; continue 'dispatch;
	}
	// 8219C014: 89630025  lbz r11, 0x25(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(37 as u32) ) } as u64;
	// 8219C018: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C01C: 409A0050  bne cr6, 0x8219c06c
	if !ctx.cr[6].eq {
	pc = 0x8219C06C; continue 'dispatch;
	}
	// 8219C020: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C024: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8219C028: C80B0078  lfd f0, 0x78(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) };
	// 8219C02C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219C030: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219C034: C00A9490  lfs f0, -0x6b70(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C038: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8219C03C: 40980008  bge cr6, 0x8219c044
	if !ctx.cr[6].lt {
	pc = 0x8219C044; continue 'dispatch;
	}
	// 8219C040: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219C044; continue 'dispatch;
            }
            0x8219C044 => {
    //   block [0x8219C044..0x8219C06C)
	// 8219C044: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219C048: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C04C: 419A0020  beq cr6, 0x8219c06c
	if ctx.cr[6].eq {
	pc = 0x8219C06C; continue 'dispatch;
	}
	// 8219C050: 89630022  lbz r11, 0x22(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(34 as u32) ) } as u64;
	// 8219C054: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C058: 409A0014  bne cr6, 0x8219c06c
	if !ctx.cr[6].eq {
	pc = 0x8219C06C; continue 'dispatch;
	}
	// 8219C05C: 480509D5  bl 0x821eca30
	ctx.lr = 0x8219C060;
	sub_821ECA30(ctx, base);
	// 8219C060: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219C064: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C068: 419A0018  beq cr6, 0x8219c080
	if ctx.cr[6].eq {
	pc = 0x8219C080; continue 'dispatch;
	}
	pc = 0x8219C06C; continue 'dispatch;
            }
            0x8219C06C => {
    //   block [0x8219C06C..0x8219C080)
	// 8219C06C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219C070: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219C074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219C078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219C07C: 4E800020  blr
	return;
            }
            0x8219C080 => {
    //   block [0x8219C080..0x8219C094)
	// 8219C080: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219C084: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219C088: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219C08C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219C090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219C098 size=400
    let mut pc: u32 = 0x8219C098;
    'dispatch: loop {
        match pc {
            0x8219C098 => {
    //   block [0x8219C098..0x8219C100)
	// 8219C098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219C09C: 48B0D365  bl 0x82ca9400
	ctx.lr = 0x8219C0A0;
	sub_82CA93D0(ctx, base);
	// 8219C0A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219C0A4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8219C0A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219C0AC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8219C0B0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8219C0B4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219C0B8: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8219C0BC: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C0C0: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C0C4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8219C0C8: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 8219C0CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C0D0: 419A00EC  beq cr6, 0x8219c1bc
	if ctx.cr[6].eq {
	pc = 0x8219C1BC; continue 'dispatch;
	}
	// 8219C0D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C0D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219C0DC: 419A00DC  beq cr6, 0x8219c1b8
	if ctx.cr[6].eq {
	pc = 0x8219C1B8; continue 'dispatch;
	}
	// 8219C0E0: 555D003E  slwi r29, r10, 0
	ctx.r[29].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 8219C0E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8219C0E8: 419A0018  beq cr6, 0x8219c100
	if ctx.cr[6].eq {
	pc = 0x8219C100; continue 'dispatch;
	}
	// 8219C0EC: 897D0090  lbz r11, 0x90(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219C0F0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219C0F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219C0F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219C0FC: 409A0008  bne cr6, 0x8219c104
	if !ctx.cr[6].eq {
	pc = 0x8219C104; continue 'dispatch;
	}
	pc = 0x8219C100; continue 'dispatch;
            }
            0x8219C100 => {
    //   block [0x8219C100..0x8219C104)
	// 8219C100: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8219C104; continue 'dispatch;
            }
            0x8219C104 => {
    //   block [0x8219C104..0x8219C18C)
	// 8219C104: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219C108: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C10C: 419A0114  beq cr6, 0x8219c220
	if ctx.cr[6].eq {
	pc = 0x8219C220; continue 'dispatch;
	}
	// 8219C110: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8219C114: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219C118: 388B0AF8  addi r4, r11, 0xaf8
	ctx.r[4].s64 = ctx.r[11].s64 + 2808;
	// 8219C11C: 4813A2ED  bl 0x822d6408
	ctx.lr = 0x8219C120;
	sub_822D6408(ctx, base);
	// 8219C120: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 8219C124: 9BC10058  stb r30, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 8219C128: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8219C12C: 9BC10059  stb r30, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[30].u8 ) };
	// 8219C130: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8219C134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219C138: 4812BC19  bl 0x822c7d50
	ctx.lr = 0x8219C13C;
	sub_822C7D50(ctx, base);
	// 8219C13C: 88DF0009  lbz r6, 9(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(9 as u32) ) } as u64;
	// 8219C140: 8B810059  lbz r28, 0x59(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 8219C144: 8B610058  lbz r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8219C148: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8219C14C: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219C150: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 8219C154: 409A0038  bne cr6, 0x8219c18c
	if !ctx.cr[6].eq {
	pc = 0x8219C18C; continue 'dispatch;
	}
	// 8219C158: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C15C: 7F0BD000  cmpw cr6, r11, r26
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[26].s32, &mut ctx.xer);
	// 8219C160: 409A002C  bne cr6, 0x8219c18c
	if !ctx.cr[6].eq {
	pc = 0x8219C18C; continue 'dispatch;
	}
	// 8219C164: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219C168: 576A063E  clrlwi r10, r27, 0x18
	ctx.r[10].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 8219C16C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219C170: 409A001C  bne cr6, 0x8219c18c
	if !ctx.cr[6].eq {
	pc = 0x8219C18C; continue 'dispatch;
	}
	// 8219C174: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8219C178: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219C17C: 4813A0E5  bl 0x822d6260
	ctx.lr = 0x8219C180;
	sub_822D6260(ctx, base);
	// 8219C180: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219C184: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C188: 419A0008  beq cr6, 0x8219c190
	if ctx.cr[6].eq {
	pc = 0x8219C190; continue 'dispatch;
	}
	pc = 0x8219C18C; continue 'dispatch;
            }
            0x8219C18C => {
    //   block [0x8219C18C..0x8219C190)
	// 8219C18C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x8219C190; continue 'dispatch;
            }
            0x8219C190 => {
    //   block [0x8219C190..0x8219C1B8)
	// 8219C190: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 8219C194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C198: 419A0080  beq cr6, 0x8219c218
	if ctx.cr[6].eq {
	pc = 0x8219C218; continue 'dispatch;
	}
	// 8219C19C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219C1A0: 419A0024  beq cr6, 0x8219c1c4
	if ctx.cr[6].eq {
	pc = 0x8219C1C4; continue 'dispatch;
	}
	// 8219C1A4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8219C1A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8219C1AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219C1B0: 483F9DE9  bl 0x82595f98
	ctx.lr = 0x8219C1B4;
	sub_82595F98(ctx, base);
	// 8219C1B4: 4800004C  b 0x8219c200
	pc = 0x8219C200; continue 'dispatch;
            }
            0x8219C1B8 => {
    //   block [0x8219C1B8..0x8219C1BC)
	// 8219C1B8: 4BFF7C81  bl 0x82193e38
	ctx.lr = 0x8219C1BC;
	sub_82193E38(ctx, base);
	pc = 0x8219C1BC; continue 'dispatch;
            }
            0x8219C1BC => {
    //   block [0x8219C1BC..0x8219C1C4)
	// 8219C1BC: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 8219C1C0: 4BFFFF40  b 0x8219c100
	pc = 0x8219C100; continue 'dispatch;
            }
            0x8219C1C4 => {
    //   block [0x8219C1C4..0x8219C1D8)
	// 8219C1C4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8219C1C8: 419A0010  beq cr6, 0x8219c1d8
	if ctx.cr[6].eq {
	pc = 0x8219C1D8; continue 'dispatch;
	}
	// 8219C1CC: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 8219C1D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219C1D4: 483FA09D  bl 0x82596270
	ctx.lr = 0x8219C1D8;
	sub_82596270(ctx, base);
	pc = 0x8219C1D8; continue 'dispatch;
            }
            0x8219C1D8 => {
    //   block [0x8219C1D8..0x8219C200)
	// 8219C1D8: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8219C1DC: 3BDF0018  addi r30, r31, 0x18
	ctx.r[30].s64 = ctx.r[31].s64 + 24;
	// 8219C1E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219C1E4: 419A001C  beq cr6, 0x8219c200
	if ctx.cr[6].eq {
	pc = 0x8219C200; continue 'dispatch;
	}
	// 8219C1E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C1EC: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219C1F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219C1F4: 4E800421  bctrl
	ctx.lr = 0x8219C1F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219C1F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219C1FC: 48A69CFD  bl 0x82c05ef8
	ctx.lr = 0x8219C200;
	sub_82C05EF8(ctx, base);
            }
            0x8219C200 => {
    //   block [0x8219C200..0x8219C218)
	// 8219C200: 9B9F0009  stb r28, 9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(9 as u32), ctx.r[28].u8 ) };
	// 8219C204: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8219C208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219C20C: 4811C69D  bl 0x822b88a8
	ctx.lr = 0x8219C210;
	sub_822B88A8(ctx, base);
	// 8219C210: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 8219C214: 9B7F0008  stb r27, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u8 ) };
	pc = 0x8219C218; continue 'dispatch;
            }
            0x8219C218 => {
    //   block [0x8219C218..0x8219C220)
	// 8219C218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219C21C: 4802A5DD  bl 0x821c67f8
	ctx.lr = 0x8219C220;
	sub_821C67F8(ctx, base);
	pc = 0x8219C220; continue 'dispatch;
            }
            0x8219C220 => {
    //   block [0x8219C220..0x8219C228)
	// 8219C220: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8219C224: 48B0D22C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219C228 size=288
    let mut pc: u32 = 0x8219C228;
    'dispatch: loop {
        match pc {
            0x8219C228 => {
    //   block [0x8219C228..0x8219C280)
	// 8219C228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219C22C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219C230: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219C234: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219C238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219C23C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219C240: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8219C244: 397F0048  addi r11, r31, 0x48
	ctx.r[11].s64 = ctx.r[31].s64 + 72;
	// 8219C248: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219C24C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C250: 5149083C  rlwimi r9, r10, 1, 0, 0x1e
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[9].u64 & 0xFFFFFFFF00000001);
	// 8219C254: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8219C258: C81F0050  lfd f0, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	// 8219C25C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8219C260: 40990020  ble cr6, 0x8219c280
	if !ctx.cr[6].gt {
	pc = 0x8219C280; continue 'dispatch;
	}
	// 8219C264: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 8219C268: D80B0000  stfd f0, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.f[0].u64 ) };
	// 8219C26C: D82B0008  stfd f1, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.f[1].u64 ) };
	// 8219C270: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219C274: C009D5C8  lfs f0, -0x2a38(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C278: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C27C: 48000008  b 0x8219c284
	pc = 0x8219C284; continue 'dispatch;
            }
            0x8219C280 => {
    //   block [0x8219C280..0x8219C284)
	// 8219C280: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8219C284; continue 'dispatch;
            }
            0x8219C284 => {
    //   block [0x8219C284..0x8219C2A4)
	// 8219C284: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8219C288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C28C: 419A0018  beq cr6, 0x8219c2a4
	if ctx.cr[6].eq {
	pc = 0x8219C2A4; continue 'dispatch;
	}
	// 8219C290: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219C298: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219C29C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219C2A0: 4E800421  bctrl
	ctx.lr = 0x8219C2A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8219C2A4 => {
    //   block [0x8219C2A4..0x8219C2C8)
	// 8219C2A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C2A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219C2AC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C2B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219C2B4: 4E800421  bctrl
	ctx.lr = 0x8219C2B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219C2B8: 2F03001C  cmpwi cr6, r3, 0x1c
	ctx.cr[6].compare_i32(ctx.r[3].s32, 28, &mut ctx.xer);
	// 8219C2BC: 419A000C  beq cr6, 0x8219c2c8
	if ctx.cr[6].eq {
	pc = 0x8219C2C8; continue 'dispatch;
	}
	// 8219C2C0: 2F030026  cmpwi cr6, r3, 0x26
	ctx.cr[6].compare_i32(ctx.r[3].s32, 38, &mut ctx.xer);
	// 8219C2C4: 409A006C  bne cr6, 0x8219c330
	if !ctx.cr[6].eq {
	pc = 0x8219C330; continue 'dispatch;
	}
            }
            0x8219C2C8 => {
    //   block [0x8219C2C8..0x8219C330)
	// 8219C2C8: C01E0008  lfs f0, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C2CC: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 8219C2D0: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8219C2D4: E97E0030  ld r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	// 8219C2D8: F97F00E0  std r11, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u64 ) };
	// 8219C2DC: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 8219C2E0: E95E0038  ld r10, 0x38(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	// 8219C2E4: 393E0030  addi r9, r30, 0x30
	ctx.r[9].s64 = ctx.r[30].s64 + 48;
	// 8219C2E8: F95F00E8  std r10, 0xe8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u64 ) };
	// 8219C2EC: 391F00E0  addi r8, r31, 0xe0
	ctx.r[8].s64 = ctx.r[31].s64 + 224;
	// 8219C2F0: 4BFF1CC9  bl 0x8218dfb8
	ctx.lr = 0x8219C2F4;
	sub_8218DFB8(ctx, base);
	// 8219C2F4: 389E0024  addi r4, r30, 0x24
	ctx.r[4].s64 = ctx.r[30].s64 + 36;
	// 8219C2F8: 387F00D4  addi r3, r31, 0xd4
	ctx.r[3].s64 = ctx.r[31].s64 + 212;
	// 8219C2FC: 4811C5AD  bl 0x822b88a8
	ctx.lr = 0x8219C300;
	sub_822B88A8(ctx, base);
	// 8219C300: 88BE002C  lbz r5, 0x2c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 8219C304: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8219C308: 38C00090  li r6, 0x90
	ctx.r[6].s64 = 144;
	// 8219C30C: 98BF00D8  stb r5, 0xd8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[5].u8 ) };
	// 8219C310: E89E0040  ld r4, 0x40(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	// 8219C314: F89F00F0  std r4, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[4].u64 ) };
	// 8219C318: E87E0048  ld r3, 0x48(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) };
	// 8219C31C: F87F00F8  std r3, 0xf8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[3].u64 ) };
	pc = 0x8219C330; continue 'dispatch;
            }
            0x8219C330 => {
    //   block [0x8219C330..0x8219C348)
	// 8219C330: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219C334: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219C338: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219C33C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219C340: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219C344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219C348 size=668
    let mut pc: u32 = 0x8219C348;
    'dispatch: loop {
        match pc {
            0x8219C348 => {
    //   block [0x8219C348..0x8219C3A0)
	// 8219C348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219C34C: 48B0D0B9  bl 0x82ca9404
	ctx.lr = 0x8219C350;
	sub_82CA93D0(ctx, base);
	// 8219C350: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219C354: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219C358: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8219C35C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8219C360: 397F0048  addi r11, r31, 0x48
	ctx.r[11].s64 = ctx.r[31].s64 + 72;
	// 8219C364: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8219C368: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219C36C: 3B8A9490  addi r28, r10, -0x6b70
	ctx.r[28].s64 = ctx.r[10].s64 + -27504;
	// 8219C370: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C374: 5128083C  rlwimi r8, r9, 1, 0, 0x1e
	ctx.r[8].u64 = (((ctx.r[9].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[8].u64 & 0xFFFFFFFF00000001);
	// 8219C378: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 8219C37C: C81F0050  lfd f0, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	// 8219C380: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8219C384: 4099001C  ble cr6, 0x8219c3a0
	if !ctx.cr[6].gt {
	pc = 0x8219C3A0; continue 'dispatch;
	}
	// 8219C388: C1BC4138  lfs f13, 0x4138(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16696 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C38C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219C390: D80B0000  stfd f0, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.f[0].u64 ) };
	// 8219C394: D82B0008  stfd f1, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.f[1].u64 ) };
	// 8219C398: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C39C: 48000008  b 0x8219c3a4
	pc = 0x8219C3A4; continue 'dispatch;
            }
            0x8219C3A0 => {
    //   block [0x8219C3A0..0x8219C3A4)
	// 8219C3A0: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	pc = 0x8219C3A4; continue 'dispatch;
            }
            0x8219C3A4 => {
    //   block [0x8219C3A4..0x8219C3D4)
	// 8219C3A4: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8219C3A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C3AC: 419A0028  beq cr6, 0x8219c3d4
	if ctx.cr[6].eq {
	pc = 0x8219C3D4; continue 'dispatch;
	}
	// 8219C3B0: E97F0080  ld r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	// 8219C3B4: 395F0080  addi r10, r31, 0x80
	ctx.r[10].s64 = ctx.r[31].s64 + 128;
	// 8219C3B8: E93F0088  ld r9, 0x88(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	// 8219C3BC: E91F0090  ld r8, 0x90(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	// 8219C3C0: E8FF0098  ld r7, 0x98(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	// 8219C3C4: F97F0060  std r11, 0x60(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 8219C3C8: F93F0068  std r9, 0x68(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 8219C3CC: F91F0070  std r8, 0x70(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[8].u64 ) };
	// 8219C3D0: F8FF0078  std r7, 0x78(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[7].u64 ) };
	pc = 0x8219C3D4; continue 'dispatch;
            }
            0x8219C3D4 => {
    //   block [0x8219C3D4..0x8219C5DC)
	// 8219C3D4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C3D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219C3DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C3E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219C3E4: 4E800421  bctrl
	ctx.lr = 0x8219C3E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219C3E8: 2F030031  cmpwi cr6, r3, 0x31
	ctx.cr[6].compare_i32(ctx.r[3].s32, 49, &mut ctx.xer);
	// 8219C3EC: 409A01F0  bne cr6, 0x8219c5dc
	if !ctx.cr[6].eq {
	pc = 0x8219C5DC; continue 'dispatch;
	}
	// 8219C3F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219C3F4: 39400028  li r10, 0x28
	ctx.r[10].s64 = 40;
	// 8219C3F8: 390B91A0  addi r8, r11, -0x6e60
	ctx.r[8].s64 = ctx.r[11].s64 + -28256;
	// 8219C3FC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219C400: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 8219C404: 389E0008  addi r4, r30, 8
	ctx.r[4].s64 = ctx.r[30].s64 + 8;
            }
            0x8219C5DC => {
    //   block [0x8219C5DC..0x8219C5E4)
	// 8219C5DC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8219C5E0: 48B0CE74  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219C5E8 size=200
    let mut pc: u32 = 0x8219C5E8;
    'dispatch: loop {
        match pc {
            0x8219C5E8 => {
    //   block [0x8219C5E8..0x8219C64C)
	// 8219C5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219C5EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219C5F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219C5F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219C5F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219C5FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219C600: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219C604: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8219C608: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8219C60C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219C610: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219C614: 388A0CA0  addi r4, r10, 0xca0
	ctx.r[4].s64 = ctx.r[10].s64 + 3232;
	// 8219C618: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8219C61C: 480FEB9D  bl 0x8229b1b8
	ctx.lr = 0x8219C620;
	sub_8229B1B8(ctx, base);
	// 8219C620: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219C624: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219C628: 419A006C  beq cr6, 0x8219c694
	if ctx.cr[6].eq {
	pc = 0x8219C694; continue 'dispatch;
	}
	// 8219C62C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8219C630: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8219C634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C638: 409A0014  bne cr6, 0x8219c64c
	if !ctx.cr[6].eq {
	pc = 0x8219C64C; continue 'dispatch;
	}
	// 8219C63C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8219C640: 816B6AC0  lwz r11, 0x6ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27328 as u32) ) } as u64;
	// 8219C644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C648: 419A004C  beq cr6, 0x8219c694
	if ctx.cr[6].eq {
	pc = 0x8219C694; continue 'dispatch;
	}
	pc = 0x8219C64C; continue 'dispatch;
            }
            0x8219C64C => {
    //   block [0x8219C64C..0x8219C66C)
	// 8219C64C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 8219C650: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C654: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C658: 83CA6DA0  lwz r30, 0x6da0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28064 as u32) ) } as u64;
	// 8219C65C: 409A0010  bne cr6, 0x8219c66c
	if !ctx.cr[6].eq {
	pc = 0x8219C66C; continue 'dispatch;
	}
	// 8219C660: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8219C664: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 8219C668: 48000008  b 0x8219c670
	pc = 0x8219C670; continue 'dispatch;
            }
            0x8219C66C => {
    //   block [0x8219C66C..0x8219C670)
	// 8219C66C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8219C670; continue 'dispatch;
            }
            0x8219C670 => {
    //   block [0x8219C670..0x8219C694)
	// 8219C670: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8219C674: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219C678: 4BFE2D19  bl 0x8217f390
	ctx.lr = 0x8219C67C;
	sub_8217F390(ctx, base);
	// 8219C67C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219C680: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219C684: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219C688: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8219C68C: 48047BC5  bl 0x821e4250
	ctx.lr = 0x8219C690;
	sub_821E4250(ctx, base);
	// 8219C690: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	pc = 0x8219C694; continue 'dispatch;
            }
            0x8219C694 => {
    //   block [0x8219C694..0x8219C6B0)
	// 8219C694: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219C698: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219C69C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219C6A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219C6A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219C6A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219C6AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219C6B0 size=336
    let mut pc: u32 = 0x8219C6B0;
    'dispatch: loop {
        match pc {
            0x8219C6B0 => {
    //   block [0x8219C6B0..0x8219C704)
	// 8219C6B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219C6B4: 48B0CD51  bl 0x82ca9404
	ctx.lr = 0x8219C6B8;
	sub_82CA93D0(ctx, base);
	// 8219C6B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219C6BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8219C6C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219C6C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8219C6C8: 388B1AEC  addi r4, r11, 0x1aec
	ctx.r[4].s64 = ctx.r[11].s64 + 6892;
	// 8219C6CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219C6D0: 48090801  bl 0x8222ced0
	ctx.lr = 0x8219C6D4;
	sub_8222CED0(ctx, base);
	// 8219C6D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8219C6D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8219C6DC: 4BFFFF0D  bl 0x8219c5e8
	ctx.lr = 0x8219C6E0;
	sub_8219C5E8(ctx, base);
	// 8219C6E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219C6E4: 480786F5  bl 0x82214dd8
	ctx.lr = 0x8219C6E8;
	sub_82214DD8(ctx, base);
	// 8219C6E8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8219C6EC: 3B8BFFDF  addi r28, r11, -0x21
	ctx.r[28].s64 = ctx.r[11].s64 + -33;
	// 8219C6F0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8219C6F4: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C6F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8219C6FC: 419A0008  beq cr6, 0x8219c704
	if ctx.cr[6].eq {
	pc = 0x8219C704; continue 'dispatch;
	}
	// 8219C700: 80FD0000  lwz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8219C704; continue 'dispatch;
            }
            0x8219C704 => {
    //   block [0x8219C704..0x8219C778)
	// 8219C704: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8219C708: 48015DF1  bl 0x821b24f8
	ctx.lr = 0x8219C70C;
	sub_821B24F8(ctx, base);
	// 8219C70C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219C710: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 8219C714: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219C718: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 8219C71C: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 8219C720: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8219C724: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C728: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 8219C72C: 4805762D  bl 0x821f3d58
	ctx.lr = 0x8219C730;
	sub_821F3D58(ctx, base);
	// 8219C730: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219C734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219C738: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 8219C73C: 48049235  bl 0x821e5970
	ctx.lr = 0x8219C740;
	sub_821E5970(ctx, base);
	// 8219C740: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C744: 554BC23E  srwi r11, r10, 8
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219C748: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 8219C74C: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219C750: 7D6BFA15  add. r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219C754: 41820024  beq 0x8219c778
	if ctx.cr[0].eq {
	pc = 0x8219C778; continue 'dispatch;
	}
	// 8219C758: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219C75C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8219C760: 7D0958AE  lbzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219C764: 7D0B0774  extsb r11, r8
	ctx.r[11].s64 = ctx.r[8].s8 as i64;
	// 8219C768: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8219C76C: 419A0060  beq cr6, 0x8219c7cc
	if ctx.cr[6].eq {
	pc = 0x8219C7CC; continue 'dispatch;
	}
	// 8219C770: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8219C774: 419A0024  beq cr6, 0x8219c798
	if ctx.cr[6].eq {
	pc = 0x8219C798; continue 'dispatch;
	}
	pc = 0x8219C778; continue 'dispatch;
            }
            0x8219C778 => {
    //   block [0x8219C778..0x8219C788)
	// 8219C778: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8219C77C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8219C780: 419A0008  beq cr6, 0x8219c788
	if ctx.cr[6].eq {
	pc = 0x8219C788; continue 'dispatch;
	}
	// 8219C784: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8219C788; continue 'dispatch;
            }
            0x8219C788 => {
    //   block [0x8219C788..0x8219C798)
	// 8219C788: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219C78C: 4BFFA3F5  bl 0x82196b80
	ctx.lr = 0x8219C790;
	sub_82196B80(ctx, base);
	// 8219C790: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219C794: 48B0CCC0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x8219C798 => {
    //   block [0x8219C798..0x8219C7A8)
	// 8219C798: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8219C79C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8219C7A0: 419A0008  beq cr6, 0x8219c7a8
	if ctx.cr[6].eq {
	pc = 0x8219C7A8; continue 'dispatch;
	}
	// 8219C7A4: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8219C7A8; continue 'dispatch;
            }
            0x8219C7A8 => {
    //   block [0x8219C7A8..0x8219C7CC)
	// 8219C7A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219C7AC: 481B788D  bl 0x82354038
	ctx.lr = 0x8219C7B0;
	sub_82354038(ctx, base);
	// 8219C7B0: 786B0020  clrldi r11, r3, 0x20
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 8219C7B4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8219C7B8: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8219C7BC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 8219C7C0: FC206818  frsp f1, f13
	ctx.f[1].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219C7C4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219C7C8: 48B0CC8C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x8219C7CC => {
    //   block [0x8219C7CC..0x8219C7DC)
	// 8219C7CC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8219C7D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8219C7D4: 419A0008  beq cr6, 0x8219c7dc
	if ctx.cr[6].eq {
	pc = 0x8219C7DC; continue 'dispatch;
	}
	// 8219C7D8: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8219C7DC; continue 'dispatch;
            }
            0x8219C7DC => {
    //   block [0x8219C7DC..0x8219C800)
	// 8219C7DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219C7E0: 48223041  bl 0x823bf820
	ctx.lr = 0x8219C7E4;
	sub_823BF820(ctx, base);
	// 8219C7E4: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 8219C7E8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8219C7EC: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8219C7F0: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 8219C7F4: FC206818  frsp f1, f13
	ctx.f[1].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219C7F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219C7FC: 48B0CC58  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219C800 size=464
    let mut pc: u32 = 0x8219C800;
    'dispatch: loop {
        match pc {
            0x8219C800 => {
    //   block [0x8219C800..0x8219C888)
	// 8219C800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219C804: 48B0CBFD  bl 0x82ca9400
	ctx.lr = 0x8219C808;
	sub_82CA93D0(ctx, base);
	// 8219C808: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8219C80C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219C810: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8219C814: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219C818: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8219C81C: 388B2458  addi r4, r11, 0x2458
	ctx.r[4].s64 = ctx.r[11].s64 + 9304;
	// 8219C820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219C824: 480906AD  bl 0x8222ced0
	ctx.lr = 0x8219C828;
	sub_8222CED0(ctx, base);
	// 8219C828: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8219C82C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219C830: CBEA9660  lfd f31, -0x69a0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 8219C834: 4BFFFE7D  bl 0x8219c6b0
	ctx.lr = 0x8219C838;
	sub_8219C6B0(ctx, base);
	// 8219C838: FC0107F2  fmul f0, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[31].f64;
	// 8219C83C: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219C840: 480F91C9  bl 0x82295a08
	ctx.lr = 0x8219C844;
	sub_82295A08(ctx, base);
	// 8219C844: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8219C848: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219C84C: FD80681E  fctiwz f12, f13
	ctx.f[12].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 8219C850: D9810058  stfd f12, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[12].u64 ) };
	// 8219C854: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8219C858: 48078581  bl 0x82214dd8
	ctx.lr = 0x8219C85C;
	sub_82214DD8(ctx, base);
	// 8219C85C: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 8219C860: 811F00B8  lwz r8, 0xb8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C864: 3BDF00B4  addi r30, r31, 0xb4
	ctx.r[30].s64 = ctx.r[31].s64 + 180;
	// 8219C868: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8219C86C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 8219C870: 81699650  lwz r11, -0x69b0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 8219C874: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8219C878: 7F5C5850  subf r26, r28, r11
	ctx.r[26].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 8219C87C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8219C880: 3B8B0B7C  addi r28, r11, 0xb7c
	ctx.r[28].s64 = ctx.r[11].s64 + 2940;
	// 8219C884: 83E80000  lwz r31, 0(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8219C888; continue 'dispatch;
            }
            0x8219C888 => {
    //   block [0x8219C888..0x8219C88C)
	// 8219C888: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	pc = 0x8219C88C; continue 'dispatch;
            }
            0x8219C88C => {
    //   block [0x8219C88C..0x8219C8A0)
	// 8219C88C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C890: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8219C894: 419A000C  beq cr6, 0x8219c8a0
	if ctx.cr[6].eq {
	pc = 0x8219C8A0; continue 'dispatch;
	}
	// 8219C898: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8219C89C: 419A0008  beq cr6, 0x8219c8a4
	if ctx.cr[6].eq {
	pc = 0x8219C8A4; continue 'dispatch;
	}
	pc = 0x8219C8A0; continue 'dispatch;
            }
            0x8219C8A0 => {
    //   block [0x8219C8A0..0x8219C8A4)
	// 8219C8A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219C8A4; continue 'dispatch;
            }
            0x8219C8A4 => {
    //   block [0x8219C8A4..0x8219C8B8)
	// 8219C8A4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219C8A8: 419A011C  beq cr6, 0x8219c9c4
	if ctx.cr[6].eq {
	pc = 0x8219C9C4; continue 'dispatch;
	}
	// 8219C8AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8219C8B0: 409A0008  bne cr6, 0x8219c8b8
	if !ctx.cr[6].eq {
	pc = 0x8219C8B8; continue 'dispatch;
	}
	// 8219C8B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219C8B8; continue 'dispatch;
            }
            0x8219C8B8 => {
    //   block [0x8219C8B8..0x8219C8C8)
	// 8219C8B8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C8BC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219C8C0: 409A0008  bne cr6, 0x8219c8c8
	if !ctx.cr[6].eq {
	pc = 0x8219C8C8; continue 'dispatch;
	}
	// 8219C8C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219C8C8; continue 'dispatch;
            }
            0x8219C8C8 => {
    //   block [0x8219C8C8..0x8219C8E0)
	// 8219C8C8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219C8CC: 7F0AD000  cmpw cr6, r10, r26
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[26].s32, &mut ctx.xer);
	// 8219C8D0: 4198007C  blt cr6, 0x8219c94c
	if ctx.cr[6].lt {
	pc = 0x8219C94C; continue 'dispatch;
	}
	// 8219C8D4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219C8D8: 409A0008  bne cr6, 0x8219c8e0
	if !ctx.cr[6].eq {
	pc = 0x8219C8E0; continue 'dispatch;
	}
	// 8219C8DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219C8E0; continue 'dispatch;
            }
            0x8219C8E0 => {
    //   block [0x8219C8E0..0x8219C91C)
	// 8219C8E0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219C8E4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8219C8E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C8EC: 419A0030  beq cr6, 0x8219c91c
	if ctx.cr[6].eq {
	pc = 0x8219C91C; continue 'dispatch;
	}
	// 8219C8F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C8F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219C8F8: 419A004C  beq cr6, 0x8219c944
	if ctx.cr[6].eq {
	pc = 0x8219C944; continue 'dispatch;
	}
	// 8219C8FC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219C900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C904: 419A0018  beq cr6, 0x8219c91c
	if ctx.cr[6].eq {
	pc = 0x8219C91C; continue 'dispatch;
	}
	// 8219C908: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219C90C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219C910: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219C914: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219C918: 409A0008  bne cr6, 0x8219c920
	if !ctx.cr[6].eq {
	pc = 0x8219C920; continue 'dispatch;
	}
	pc = 0x8219C91C; continue 'dispatch;
            }
            0x8219C91C => {
    //   block [0x8219C91C..0x8219C920)
	// 8219C91C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x8219C920; continue 'dispatch;
            }
            0x8219C920 => {
    //   block [0x8219C920..0x8219C93C)
	// 8219C920: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219C924: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C928: 419A0024  beq cr6, 0x8219c94c
	if ctx.cr[6].eq {
	pc = 0x8219C94C; continue 'dispatch;
	}
	// 8219C92C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C930: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219C934: 409A0008  bne cr6, 0x8219c93c
	if !ctx.cr[6].eq {
	pc = 0x8219C93C; continue 'dispatch;
	}
	// 8219C938: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219C93C; continue 'dispatch;
            }
            0x8219C93C => {
    //   block [0x8219C93C..0x8219C944)
	// 8219C93C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C940: 4BFFFF48  b 0x8219c888
	pc = 0x8219C888; continue 'dispatch;
            }
            0x8219C944 => {
    //   block [0x8219C944..0x8219C94C)
	// 8219C944: 4BFF74F5  bl 0x82193e38
	ctx.lr = 0x8219C948;
	sub_82193E38(ctx, base);
	// 8219C948: 4BFFFFD4  b 0x8219c91c
	pc = 0x8219C91C; continue 'dispatch;
            }
            0x8219C94C => {
    //   block [0x8219C94C..0x8219C964)
	// 8219C94C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219C950: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C954: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219C958: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219C95C: 409A0008  bne cr6, 0x8219c964
	if !ctx.cr[6].eq {
	pc = 0x8219C964; continue 'dispatch;
	}
	// 8219C960: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219C964; continue 'dispatch;
            }
            0x8219C964 => {
    //   block [0x8219C964..0x8219C9B0)
	// 8219C964: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C968: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C96C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219C970: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8219C974: 419A003C  beq cr6, 0x8219c9b0
	if ctx.cr[6].eq {
	pc = 0x8219C9B0; continue 'dispatch;
	}
	// 8219C978: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C97C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8219C980: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219C984: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C988: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C98C: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 8219C990: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 8219C994: 4BFF74A5  bl 0x82193e38
	ctx.lr = 0x8219C998;
	sub_82193E38(ctx, base);
	// 8219C998: 937F0010  stw r27, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[27].u32 ) };
	// 8219C99C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219C9A0: 4807F399  bl 0x8221bd38
	ctx.lr = 0x8219C9A4;
	sub_8221BD38(ctx, base);
	// 8219C9A4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219C9A8: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 8219C9AC: 90FE0008  stw r7, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	pc = 0x8219C9B0; continue 'dispatch;
            }
            0x8219C9B0 => {
    //   block [0x8219C9B0..0x8219C9C4)
	// 8219C9B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219C9B4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219C9B8: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219C9BC: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219C9C0: 4BFFFECC  b 0x8219c88c
	pc = 0x8219C88C; continue 'dispatch;
            }
            0x8219C9C4 => {
    //   block [0x8219C9C4..0x8219C9D0)
	// 8219C9C4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8219C9C8: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8219C9CC: 48B0CA84  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219C9D0 size=604
    let mut pc: u32 = 0x8219C9D0;
    'dispatch: loop {
        match pc {
            0x8219C9D0 => {
    //   block [0x8219C9D0..0x8219CA38)
	// 8219C9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219C9D4: 48B0CA2D  bl 0x82ca9400
	ctx.lr = 0x8219C9D8;
	sub_82CA93D0(ctx, base);
	// 8219C9D8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8219C9DC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219C9E0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8219C9E4: 835B0078  lwz r26, 0x78(r27)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(120 as u32) ) } as u64;
	// 8219C9E8: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 8219C9EC: 40990234  ble cr6, 0x8219cc20
	if !ctx.cr[6].gt {
	pc = 0x8219CC20; continue 'dispatch;
	}
	// 8219C9F0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C9F4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8219C9F8: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 8219C9FC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8219CA00: 55498FFE  rlwinm r9, r10, 0x11, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00007FFFu64;
	// 8219CA04: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219CA08: 419A00F4  beq cr6, 0x8219cafc
	if ctx.cr[6].eq {
	pc = 0x8219CAFC; continue 'dispatch;
	}
	// 8219CA0C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219CA10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219CA14: 419A0024  beq cr6, 0x8219ca38
	if ctx.cr[6].eq {
	pc = 0x8219CA38; continue 'dispatch;
	}
	// 8219CA18: 894A002F  lbz r10, 0x2f(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(47 as u32) ) } as u64;
	// 8219CA1C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219CA20: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8219CA24: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219CA28: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219CA2C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8219CA30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219CA34: 480000CC  b 0x8219cb00
	pc = 0x8219CB00; continue 'dispatch;
            }
            0x8219CA38 => {
    //   block [0x8219CA38..0x8219CA54)
	// 8219CA38: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219CA3C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8219CA40: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8219CA44: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8219CA48: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8219CA4C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219CA50: 40810054  ble 0x8219caa4
	if !ctx.cr[0].gt {
	pc = 0x8219CAA4; continue 'dispatch;
	}
	pc = 0x8219CA54; continue 'dispatch;
            }
            0x8219CA54 => {
    //   block [0x8219CA54..0x8219CA74)
	// 8219CA54: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8219CA58: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219CA5C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8219CA60: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219CA64: 2F07002F  cmpwi cr6, r7, 0x2f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 47, &mut ctx.xer);
	// 8219CA68: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8219CA6C: 41980008  blt cr6, 0x8219ca74
	if ctx.cr[6].lt {
	pc = 0x8219CA74; continue 'dispatch;
	}
	// 8219CA70: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8219CA74; continue 'dispatch;
            }
            0x8219CA74 => {
    //   block [0x8219CA74..0x8219CA90)
	// 8219CA74: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8219CA78: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219CA7C: 419A0014  beq cr6, 0x8219ca90
	if ctx.cr[6].eq {
	pc = 0x8219CA90; continue 'dispatch;
	}
	// 8219CA80: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8219CA84: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219CA88: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8219CA8C: 4800000C  b 0x8219ca98
	pc = 0x8219CA98; continue 'dispatch;
            }
            0x8219CA90 => {
    //   block [0x8219CA90..0x8219CA98)
	// 8219CA90: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8219CA94: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8219CA98; continue 'dispatch;
            }
            0x8219CA98 => {
    //   block [0x8219CA98..0x8219CAA4)
	// 8219CA98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219CA9C: 4199FFB8  bgt cr6, 0x8219ca54
	if ctx.cr[6].gt {
	pc = 0x8219CA54; continue 'dispatch;
	}
	// 8219CAA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8219CAA4; continue 'dispatch;
            }
            0x8219CAA4 => {
    //   block [0x8219CAA4..0x8219CAC0)
	// 8219CAA4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8219CAA8: 419A0040  beq cr6, 0x8219cae8
	if ctx.cr[6].eq {
	pc = 0x8219CAE8; continue 'dispatch;
	}
	// 8219CAAC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219CAB0: 2F0B002F  cmpwi cr6, r11, 0x2f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 47, &mut ctx.xer);
	// 8219CAB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219CAB8: 41990008  bgt cr6, 0x8219cac0
	if ctx.cr[6].gt {
	pc = 0x8219CAC0; continue 'dispatch;
	}
	// 8219CABC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8219CAC0; continue 'dispatch;
            }
            0x8219CAC0 => {
    //   block [0x8219CAC0..0x8219CAE8)
	// 8219CAC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219CAC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219CAC8: 409A0020  bne cr6, 0x8219cae8
	if !ctx.cr[6].eq {
	pc = 0x8219CAE8; continue 'dispatch;
	}
	// 8219CACC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219CAD0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219CAD4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219CAD8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219CADC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8219CAE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219CAE4: 4800001C  b 0x8219cb00
	pc = 0x8219CB00; continue 'dispatch;
            }
            0x8219CAE8 => {
    //   block [0x8219CAE8..0x8219CAFC)
	// 8219CAE8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8219CAEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219CAF0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8219CAF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219CAF8: 48000008  b 0x8219cb00
	pc = 0x8219CB00; continue 'dispatch;
            }
            0x8219CAFC => {
    //   block [0x8219CAFC..0x8219CB00)
	// 8219CAFC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8219CB00; continue 'dispatch;
            }
            0x8219CB00 => {
    //   block [0x8219CB00..0x8219CC20)
	// 8219CB00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219CB04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219CB08: 419A0118  beq cr6, 0x8219cc20
	if ctx.cr[6].eq {
	pc = 0x8219CC20; continue 'dispatch;
	}
	// 8219CB0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219CB10: 809E02E0  lwz r4, 0x2e0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(736 as u32) ) } as u64;
	// 8219CB14: 4803D835  bl 0x821da348
	ctx.lr = 0x8219CB18;
	sub_821DA348(ctx, base);
	// 8219CB18: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219CB1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219CB20: 419A0100  beq cr6, 0x8219cc20
	if ctx.cr[6].eq {
	pc = 0x8219CC20; continue 'dispatch;
	}
	// 8219CB24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8219CB28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219CB2C: 38EB0F58  addi r7, r11, 0xf58
	ctx.r[7].s64 = ctx.r[11].s64 + 3928;
	// 8219CB30: 480159C9  bl 0x821b24f8
	ctx.lr = 0x8219CB34;
	sub_821B24F8(ctx, base);
	// 8219CB34: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8219CB38: 4810CEB1  bl 0x822a99e8
	ctx.lr = 0x8219CB3C;
	sub_822A99E8(ctx, base);
	// 8219CB3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219CB40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219CB44: 419A00DC  beq cr6, 0x8219cc20
	if ctx.cr[6].eq {
	pc = 0x8219CC20; continue 'dispatch;
	}
	// 8219CB48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8219CB4C: 388B182C  addi r4, r11, 0x182c
	ctx.r[4].s64 = ctx.r[11].s64 + 6188;
	// 8219CB50: 4810CE99  bl 0x822a99e8
	ctx.lr = 0x8219CB54;
	sub_822A99E8(ctx, base);
	// 8219CB54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8219CB58: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8219CB5C: 419A00C4  beq cr6, 0x8219cc20
	if ctx.cr[6].eq {
	pc = 0x8219CC20; continue 'dispatch;
	}
	// 8219CB60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8219CB64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219CB68: 388B1D5C  addi r4, r11, 0x1d5c
	ctx.r[4].s64 = ctx.r[11].s64 + 7516;
	// 8219CB6C: 4BFFA015  bl 0x82196b80
	ctx.lr = 0x8219CB70;
	sub_82196B80(ctx, base);
	// 8219CB70: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8219CB74: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219CB78: 396B9490  addi r11, r11, -0x6b70
	ctx.r[11].s64 = ctx.r[11].s64 + -27504;
	// 8219CB7C: C80A9660  lfd f0, -0x69a0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 8219CB80: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 8219CB84: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CB88: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219CB8C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8219CB90: 40990090  ble cr6, 0x8219cc20
	if !ctx.cr[6].gt {
	pc = 0x8219CC20; continue 'dispatch;
	}
	// 8219CB94: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8219CB98: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219CB9C: 816A9650  lwz r11, -0x69b0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 8219CBA0: 7D3A5850  subf r9, r26, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 8219CBA4: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 8219CBA8: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 8219CBAC: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219CBB0: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 8219CBB4: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 8219CBB8: ED090024  fdivs f8, f9, f0
	ctx.f[8].f64 = ((ctx.f[9].f64 / ctx.f[0].f64) as f32) as f64;
	// 8219CBBC: EFEC4028  fsubs f31, f12, f8
	ctx.f[31].f64 = (((ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 8219CBC0: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 8219CBC4: 4099005C  ble cr6, 0x8219cc20
	if !ctx.cr[6].gt {
	pc = 0x8219CC20; continue 'dispatch;
	}
	// 8219CBC8: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 8219CBCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8219CBD0: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8219CBD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219CBD8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 8219CBDC: 48052455  bl 0x821ef030
	ctx.lr = 0x8219CBE0;
	sub_821EF030(ctx, base);
	// 8219CBE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8219CBE4: 387E00EC  addi r3, r30, 0xec
	ctx.r[3].s64 = ctx.r[30].s64 + 236;
	// 8219CBE8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219CBEC: 4869444D  bl 0x82831038
	ctx.lr = 0x8219CBF0;
	sub_82831038(ctx, base);
	// 8219CBF0: C01B0024  lfs f0, 0x24(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CBF4: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8219CBF8: D1BB0024  stfs f13, 0x24(r27)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219CBFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8219CC00: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219CC04: 387E00FC  addi r3, r30, 0xfc
	ctx.r[3].s64 = ctx.r[30].s64 + 252;
	// 8219CC08: 48694431  bl 0x82831038
	ctx.lr = 0x8219CC0C;
	sub_82831038(ctx, base);
	// 8219CC0C: C19B0028  lfs f12, 0x28(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219CC10: ED61602A  fadds f11, f1, f12
	ctx.f[11].f64 = ((ctx.f[1].f64 + ctx.f[12].f64) as f32) as f64;
	// 8219CC14: D17B0028  stfs f11, 0x28(r27)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8219CC18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219CC1C: 4841D345  bl 0x825b9f60
	ctx.lr = 0x8219CC20;
	sub_825B9F60(ctx, base);
	pc = 0x8219CC20; continue 'dispatch;
            }
            0x8219CC20 => {
    //   block [0x8219CC20..0x8219CC2C)
	// 8219CC20: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8219CC24: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8219CC28: 48B0C828  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219CC30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219CC30 size=144
    let mut pc: u32 = 0x8219CC30;
    'dispatch: loop {
        match pc {
            0x8219CC30 => {
    //   block [0x8219CC30..0x8219CC64)
	// 8219CC30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219CC34: 48B0C7D9  bl 0x82ca940c
	ctx.lr = 0x8219CC38;
	sub_82CA93D0(ctx, base);
	// 8219CC38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219CC3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219CC40: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8219CC44: 83DF3094  lwz r30, 0x3094(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12436 as u32) ) } as u64;
	// 8219CC48: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219CC4C: 419A0068  beq cr6, 0x8219ccb4
	if ctx.cr[6].eq {
	pc = 0x8219CCB4; continue 'dispatch;
	}
	// 8219CC50: 817F2A9C  lwz r11, 0x2a9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10908 as u32) ) } as u64;
	// 8219CC54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219CC58: 419A000C  beq cr6, 0x8219cc64
	if ctx.cr[6].eq {
	pc = 0x8219CC64; continue 'dispatch;
	}
	// 8219CC5C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8219CC60: 48000054  b 0x8219ccb4
	pc = 0x8219CCB4; continue 'dispatch;
            }
            0x8219CC64 => {
    //   block [0x8219CC64..0x8219CC8C)
	// 8219CC64: 817F2AA0  lwz r11, 0x2aa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10912 as u32) ) } as u64;
	// 8219CC68: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219CC6C: 7D6B5039  and. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219CC70: 41820044  beq 0x8219ccb4
	if ctx.cr[0].eq {
	pc = 0x8219CCB4; continue 'dispatch;
	}
	// 8219CC74: 817F34D8  lwz r11, 0x34d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13528 as u32) ) } as u64;
	// 8219CC78: 807F34D4  lwz r3, 0x34d4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13524 as u32) ) } as u64;
	// 8219CC7C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219CC80: 4198000C  blt cr6, 0x8219cc8c
	if ctx.cr[6].lt {
	pc = 0x8219CC8C; continue 'dispatch;
	}
	// 8219CC84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219CC88: 48A04E29  bl 0x82ba1ab0
	ctx.lr = 0x8219CC8C;
	sub_82BA1AB0(ctx, base);
	pc = 0x8219CC8C; continue 'dispatch;
            }
            0x8219CC8C => {
    //   block [0x8219CC8C..0x8219CCB4)
	// 8219CC8C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219CC90: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8219CC94: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 8219CC98: 53CBF0BE  rlwimi r11, r30, 0x1e, 2, 0x1f
	ctx.r[11].u64 = (((ctx.r[30].u32).rotate_left(30) as u64) & 0x000000003FFFFFFF) | (ctx.r[11].u64 & 0xFFFFFFFFC0000000);
	// 8219CC9C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8219CCA0: 556B0080  rlwinm r11, r11, 0, 2, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219CCA4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8219CCA8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219CCAC: F9630000  std r11, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8219CCB0: 913F34D4  stw r9, 0x34d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13524 as u32), ctx.r[9].u32 ) };
	pc = 0x8219CCB4; continue 'dispatch;
            }
            0x8219CCB4 => {
    //   block [0x8219CCB4..0x8219CCC0)
	// 8219CCB4: 93BF3094  stw r29, 0x3094(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12436 as u32), ctx.r[29].u32 ) };
	// 8219CCB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8219CCBC: 48B0C7A0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219CCC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219CCC0 size=64
    let mut pc: u32 = 0x8219CCC0;
    'dispatch: loop {
        match pc {
            0x8219CCC0 => {
    //   block [0x8219CCC0..0x8219CD00)
	// 8219CCC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219CCC4: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 8219CCC8: C001001C  lfs f0, 0x1c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CCCC: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 8219CCD0: D0032E78  stfs f0, 0x2e78(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(11896 as u32), tmp.u32 ) };
	// 8219CCD4: C1AB9410  lfs f13, -0x6bf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27632 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CCD8: 798CAFE6  rldicr r12, r12, 0x35, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(53) & 0xFFFFFFFFFFFFFFFF;
	// 8219CCDC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219CCE0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8219CCE4: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 8219CCE8: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 8219CCEC: B163296A  sth r11, 0x296a(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(10602 as u32), ctx.r[11].u16 ) };
	// 8219CCF0: E9630018  ld r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	// 8219CCF4: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 8219CCF8: F9630018  std r11, 0x18(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 8219CCFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219CD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219CD00 size=100
    let mut pc: u32 = 0x8219CD00;
    'dispatch: loop {
        match pc {
            0x8219CD00 => {
    //   block [0x8219CD00..0x8219CD30)
	// 8219CD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219CD04: 48B0C709  bl 0x82ca940c
	ctx.lr = 0x8219CD08;
	sub_82CA93D0(ctx, base);
	// 8219CD08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219CD0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219CD10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8219CD14: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8219CD18: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219CD1C: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 8219CD20: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8219CD24: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219CD28: 41980008  blt cr6, 0x8219cd30
	if ctx.cr[6].lt {
	pc = 0x8219CD30; continue 'dispatch;
	}
	// 8219CD2C: 480DED15  bl 0x8227ba40
	ctx.lr = 0x8219CD30;
	sub_8227BA40(ctx, base);
	pc = 0x8219CD30; continue 'dispatch;
            }
            0x8219CD30 => {
    //   block [0x8219CD30..0x8219CD64)
	// 8219CD30: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8219CD34: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219CD38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219CD3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219CD40: 480DEE79  bl 0x8227bbb8
	ctx.lr = 0x8219CD44;
	sub_8227BBB8(ctx, base);
	// 8219CD44: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8219CD48: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 8219CD4C: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8219CD50: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219CD54: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 8219CD58: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8219CD5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219CD60: 48B0C6FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219CD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219CD68 size=232
    let mut pc: u32 = 0x8219CD68;
    'dispatch: loop {
        match pc {
            0x8219CD68 => {
    //   block [0x8219CD68..0x8219CD94)
	// 8219CD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219CD6C: 48B0C6A1  bl 0x82ca940c
	ctx.lr = 0x8219CD70;
	sub_82CA93D0(ctx, base);
	// 8219CD70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219CD74: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8219CD78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219CD7C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219CD80: 409A0014  bne cr6, 0x8219cd94
	if !ctx.cr[6].eq {
	pc = 0x8219CD94; continue 'dispatch;
	}
	// 8219CD84: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8219CD88: 409A000C  bne cr6, 0x8219cd94
	if !ctx.cr[6].eq {
	pc = 0x8219CD94; continue 'dispatch;
	}
	// 8219CD8C: 3BC00040  li r30, 0x40
	ctx.r[30].s64 = 64;
	// 8219CD90: 38C00040  li r6, 0x40
	ctx.r[6].s64 = 64;
	pc = 0x8219CD94; continue 'dispatch;
            }
            0x8219CD94 => {
    //   block [0x8219CD94..0x8219CDA4)
	// 8219CD94: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219CD98: 4182000C  beq 0x8219cda4
	if ctx.cr[0].eq {
	pc = 0x8219CDA4; continue 'dispatch;
	}
	// 8219CD9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219CDA0: 48000014  b 0x8219cdb4
	pc = 0x8219CDB4; continue 'dispatch;
            }
            0x8219CDA4 => {
    //   block [0x8219CDA4..0x8219CDB4)
	// 8219CDA4: 817F2AA8  lwz r11, 0x2aa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10920 as u32) ) } as u64;
	// 8219CDA8: 53C6446E  rlwimi r6, r30, 8, 0x11, 0x17
	ctx.r[6].u64 = (((ctx.r[30].u32).rotate_left(8) as u64) & 0x0000000000007F00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF80FF);
	// 8219CDAC: 50CB2576  rlwimi r11, r6, 4, 0x15, 0x1b
	ctx.r[11].u64 = (((ctx.r[6].u32).rotate_left(4) as u64) & 0x00000000000007F0) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFF80F);
	// 8219CDB0: 50CB2366  rlwimi r11, r6, 4, 0xd, 0x13
	ctx.r[11].u64 = (((ctx.r[6].u32).rotate_left(4) as u64) & 0x000000000007F000) | (ctx.r[11].u64 & 0xFFFFFFFFFFF80FFF);
	pc = 0x8219CDB4; continue 'dispatch;
            }
            0x8219CDB4 => {
    //   block [0x8219CDB4..0x8219CDDC)
	// 8219CDB4: 917F2AA8  stw r11, 0x2aa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10920 as u32), ctx.r[11].u32 ) };
	// 8219CDB8: 815F31AC  lwz r10, 0x31ac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12716 as u32) ) } as u64;
	// 8219CDBC: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8219CDC0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219CDC4: 7D5D2038  and r29, r10, r4
	ctx.r[29].u64 = ctx.r[10].u64 & ctx.r[4].u64;
	// 8219CDC8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219CDCC: 40990010  ble cr6, 0x8219cddc
	if !ctx.cr[6].gt {
	pc = 0x8219CDDC; continue 'dispatch;
	}
	// 8219CDD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219CDD4: 4804C0ED  bl 0x821e8ec0
	ctx.lr = 0x8219CDD8;
	sub_821E8EC0(ctx, base);
	// 8219CDD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x8219CDDC; continue 'dispatch;
            }
            0x8219CDDC => {
    //   block [0x8219CDDC..0x8219CE50)
	// 8219CDDC: 67A9C001  oris r9, r29, 0xc001
	ctx.r[9].u64 = ctx.r[29].u64 | 3221291008;
	// 8219CDE0: 57CA1838  slwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219CDE4: 61293F00  ori r9, r9, 0x3f00
	ctx.r[9].u64 = ctx.r[9].u64 | 16128;
	// 8219CDE8: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 8219CDEC: 952B0004  stwu r9, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[11].u32 = ea;
	// 8219CDF0: 391E06BC  addi r8, r30, 0x6bc
	ctx.r[8].s64 = ctx.r[30].s64 + 1724;
	// 8219CDF4: 80FF35DC  lwz r7, 0x35dc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13788 as u32) ) } as u64;
	// 8219CDF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219CDFC: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219CE00: 94EB0004  stwu r7, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[7].u32) };
	ctx.r[11].u32 = ea;
	// 8219CE04: 80FF35D8  lwz r7, 0x35d8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13784 as u32) ) } as u64;
	// 8219CE08: 54E7023E  clrlwi r7, r7, 8
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 8219CE0C: 94EB0004  stwu r7, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[7].u32) };
	ctx.r[11].u32 = ea;
	// 8219CE10: 952B0004  stwu r9, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[11].u32 = ea;
	// 8219CE14: 814A35E4  lwz r10, 0x35e4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(13796 as u32) ) } as u64;
	// 8219CE18: 954B0004  stwu r10, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[11].u32 = ea;
	// 8219CE1C: 7D48F82E  lwzx r10, r8, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 8219CE20: 554A023E  clrlwi r10, r10, 8
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00FFFFFFu64;
	// 8219CE24: 954B0004  stwu r10, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[11].u32 = ea;
	// 8219CE28: 952B0004  stwu r9, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[11].u32 = ea;
	// 8219CE2C: 815F39E4  lwz r10, 0x39e4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14820 as u32) ) } as u64;
	// 8219CE30: 954B0004  stwu r10, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[11].u32 = ea;
	// 8219CE34: 815F39E0  lwz r10, 0x39e0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14816 as u32) ) } as u64;
	// 8219CE38: 554A023E  clrlwi r10, r10, 8
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00FFFFFFu64;
	// 8219CE3C: 954B0004  stwu r10, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[11].u32 = ea;
	// 8219CE40: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 8219CE44: 489FC0BD  bl 0x82b98f00
	ctx.lr = 0x8219CE48;
	sub_82B98F00(ctx, base);
	// 8219CE48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219CE4C: 48B0C610  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219CE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219CE50 size=260
    let mut pc: u32 = 0x8219CE50;
    'dispatch: loop {
        match pc {
            0x8219CE50 => {
    //   block [0x8219CE50..0x8219CE9C)
	// 8219CE50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219CE54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219CE58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219CE5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219CE60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219CE64: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8219CE68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219CE6C: 806BEC18  lwz r3, -0x13e8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5096 as u32) ) } as u64;
	// 8219CE70: 49097441  bl 0x832342b0
	ctx.lr = 0x8219CE74;
	sub_832342B0(ctx, base);
	// 8219CE74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219CE78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219CE7C: 419A0090  beq cr6, 0x8219cf0c
	if ctx.cr[6].eq {
	pc = 0x8219CF0C; continue 'dispatch;
	}
	// 8219CE80: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8219CE84: 806B6AB8  lwz r3, 0x6ab8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8219CE88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219CE8C: 419A0010  beq cr6, 0x8219ce9c
	if ctx.cr[6].eq {
	pc = 0x8219CE9C; continue 'dispatch;
	}
	// 8219CE90: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8219CE94: 896B6A5E  lbz r11, 0x6a5e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27230 as u32) ) } as u64;
	// 8219CE98: 48000008  b 0x8219cea0
	pc = 0x8219CEA0; continue 'dispatch;
            }
            0x8219CE9C => {
    //   block [0x8219CE9C..0x8219CEA0)
	// 8219CE9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219CEA0; continue 'dispatch;
            }
            0x8219CEA0 => {
    //   block [0x8219CEA0..0x8219CEF8)
	// 8219CEA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219CEA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219CEA8: 419A0064  beq cr6, 0x8219cf0c
	if ctx.cr[6].eq {
	pc = 0x8219CF0C; continue 'dispatch;
	}
	// 8219CEAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219CEB0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219CEB4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219CEB8: 4E800421  bctrl
	ctx.lr = 0x8219CEBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219CEBC: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 8219CEC0: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 8219CEC4: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219CEC8: 392B1AE0  addi r9, r11, 0x1ae0
	ctx.r[9].s64 = ctx.r[11].s64 + 6880;
	// 8219CECC: 816A1AF0  lwz r11, 0x1af0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6896 as u32) ) } as u64;
	// 8219CED0: 556807FE  clrlwi r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8219CED4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8219CED8: 409A0020  bne cr6, 0x8219cef8
	if !ctx.cr[6].eq {
	pc = 0x8219CEF8; continue 'dispatch;
	}
	// 8219CEDC: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 8219CEE0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8219CEE4: 38E8B2C0  addi r7, r8, -0x4d40
	ctx.r[7].s64 = ctx.r[8].s64 + -19776;
	// 8219CEE8: 916A1AF0  stw r11, 0x1af0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6896 as u32), ctx.r[11].u32 ) };
            }
            0x8219CEF8 => {
    //   block [0x8219CEF8..0x8219CF0C)
	pc = 0x8219CF0C; continue 'dispatch;
            }
            0x8219CF0C => {
    //   block [0x8219CF0C..0x8219CF54)
	// 8219CF0C: 897E00B4  lbz r11, 0xb4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) } as u64;
	// 8219CF10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219CF14: 419A0028  beq cr6, 0x8219cf3c
	if ctx.cr[6].eq {
	pc = 0x8219CF3C; continue 'dispatch;
	}
	// 8219CF18: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8219CF1C: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 8219CF20: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219CF24: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219CF28: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219CF2C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8219CF30: 4E800421  bctrl
	ctx.lr = 0x8219CF34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219CF34: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219CF38: 991E00B4  stb r8, 0xb4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(180 as u32), ctx.r[8].u8 ) };
	// 8219CF3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219CF40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219CF44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219CF48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219CF4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219CF50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219CF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219CF58 size=56
    let mut pc: u32 = 0x8219CF58;
    'dispatch: loop {
        match pc {
            0x8219CF58 => {
    //   block [0x8219CF58..0x8219CF90)
	// 8219CF58: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 8219CF5C: 816A1B10  lwz r11, 0x1b10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6928 as u32) ) } as u64;
	// 8219CF60: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8219CF64: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219CF68: 409A0028  bne cr6, 0x8219cf90
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8219CF90);
		return;
	}
	// 8219CF6C: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8219CF70: 3D00834C  lis r8, -0x7cb4
	ctx.r[8].s64 = -2092171264;
	// 8219CF74: 38E9B2B0  addi r7, r9, -0x4d50
	ctx.r[7].s64 = ctx.r[9].s64 + -19792;
	// 8219CF78: 38C81B00  addi r6, r8, 0x1b00
	ctx.r[6].s64 = ctx.r[8].s64 + 6912;
	// 8219CF7C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8219CF80: 916A1B10  stw r11, 0x1b10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6928 as u32), ctx.r[11].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219CFA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219CFA0 size=1772
    let mut pc: u32 = 0x8219CFA0;
    'dispatch: loop {
        match pc {
            0x8219CFA0 => {
    //   block [0x8219CFA0..0x8219D060)
	// 8219CFA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219CFA4: 48B0C449  bl 0x82ca93ec
	ctx.lr = 0x8219CFA8;
	sub_82CA93D0(ctx, base);
	// 8219CFA8: DBC1FF90  stfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 8219CFAC: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 8219CFB0: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 8219CFB4: 48E69A21  bl 0x830069d4
	ctx.lr = 0x8219CFB8;
	sub_83006760(ctx, base);
	// 8219CFB8: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219CFBC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8219CFC0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219CFC4: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 8219CFC8: C1BF0028  lfs f13, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CFCC: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219CFD0: FD606850  fneg f11, f13
	ctx.f[11].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219CFD4: C15F0008  lfs f10, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219CFD8: FCE06050  fneg f7, f12
	ctx.f[7].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219CFDC: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CFE0: FC605050  fneg f3, f10
	ctx.f[3].u64 = ctx.f[10].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219CFE4: C3FF003C  lfs f31, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219CFE8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219CFEC: C3DF0034  lfs f30, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219CFF0: C1BF0030  lfs f13, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CFF4: C19F002C  lfs f12, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219CFF8: C15F0024  lfs f10, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219CFFC: C13F0020  lfs f9, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219D000: C11F001C  lfs f8, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8219D004: C0DF0014  lfs f6, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 8219D008: C0BF0010  lfs f5, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 8219D00C: C09F000C  lfs f4, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219D010: C05F0004  lfs f2, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219D014: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219D018: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8219D01C: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8219D020: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8219D024: 4800066D  bl 0x8219d690
	ctx.lr = 0x8219D028;
	sub_8219D690(ctx, base);
	// 8219D028: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 8219D02C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 8219D030: 392B1B00  addi r9, r11, 0x1b00
	ctx.r[9].s64 = ctx.r[11].s64 + 6912;
	// 8219D034: 816A1B10  lwz r11, 0x1b10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6928 as u32) ) } as u64;
	// 8219D038: 556807FE  clrlwi r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8219D03C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8219D040: 409A0020  bne cr6, 0x8219d060
	if !ctx.cr[6].eq {
	pc = 0x8219D060; continue 'dispatch;
	}
	// 8219D044: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 8219D048: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8219D04C: 38E8B2B0  addi r7, r8, -0x4d50
	ctx.r[7].s64 = ctx.r[8].s64 + -19792;
	// 8219D050: 916A1B10  stw r11, 0x1b10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6928 as u32), ctx.r[11].u32 ) };
	pc = 0x8219D060; continue 'dispatch;
            }
            0x8219D060 => {
    //   block [0x8219D060..0x8219D68C)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219D690 size=260
    let mut pc: u32 = 0x8219D690;
    'dispatch: loop {
        match pc {
            0x8219D690 => {
    //   block [0x8219D690..0x8219D794)
	// 8219D690: 39610024  addi r11, r1, 0x24
	ctx.r[11].s64 = ctx.r[1].s64 + 36;
	// 8219D694: D021001C  stfs f1, 0x1c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219D698: 3941001C  addi r10, r1, 0x1c
	ctx.r[10].s64 = ctx.r[1].s64 + 28;
	// 8219D69C: D0410024  stfs f2, 0x24(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219D6A0: 39210044  addi r9, r1, 0x44
	ctx.r[9].s64 = ctx.r[1].s64 + 68;
	// 8219D6A4: D0A1003C  stfs f5, 0x3c(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8219D6A8: 3901003C  addi r8, r1, 0x3c
	ctx.r[8].s64 = ctx.r[1].s64 + 60;
	// 8219D6AC: D0C10044  stfs f6, 0x44(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8219D6B0: 38E10064  addi r7, r1, 0x64
	ctx.r[7].s64 = ctx.r[1].s64 + 100;
	// 8219D6B4: D121005C  stfs f9, 0x5c(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8219D6B8: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 8219D6BC: D1410064  stfs f10, 0x64(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219D798 size=152
    let mut pc: u32 = 0x8219D798;
    'dispatch: loop {
        match pc {
            0x8219D798 => {
    //   block [0x8219D798..0x8219D7DC)
	// 8219D798: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 8219D79C: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 8219D7A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219D7A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219D7A8: 38E83020  addi r7, r8, 0x3020
	ctx.r[7].s64 = ctx.r[8].s64 + 12320;
	// 8219D7AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8219D7B0: C0099490  lfs f0, -0x6b70(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D7B4: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8219D7B8: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219D7BC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8219D7C0: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 8219D7C4: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 8219D7C8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219D7CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D7D0: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8219D7D4: 419A0024  beq cr6, 0x8219d7f8
	if ctx.cr[6].eq {
	pc = 0x8219D7F8; continue 'dispatch;
	}
	// 8219D7D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x8219D7DC; continue 'dispatch;
            }
            0x8219D7DC => {
    //   block [0x8219D7DC..0x8219D7F8)
	// 8219D7DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8219D7E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219D7E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8219D7E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219D7EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8219D7F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219D7F4: 4082FFE8  bne 0x8219d7dc
	if !ctx.cr[0].eq {
	pc = 0x8219D7DC; continue 'dispatch;
	}
	pc = 0x8219D7F8; continue 'dispatch;
            }
            0x8219D7F8 => {
    //   block [0x8219D7F8..0x8219D80C)
	// 8219D7F8: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219D7FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D800: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8219D804: 419A0024  beq cr6, 0x8219d828
	if ctx.cr[6].eq {
	pc = 0x8219D828; continue 'dispatch;
	}
	// 8219D808: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x8219D80C; continue 'dispatch;
            }
            0x8219D80C => {
    //   block [0x8219D80C..0x8219D828)
	// 8219D80C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8219D810: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219D814: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8219D818: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219D81C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8219D820: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219D824: 4082FFE8  bne 0x8219d80c
	if !ctx.cr[0].eq {
	pc = 0x8219D80C; continue 'dispatch;
	}
	pc = 0x8219D828; continue 'dispatch;
            }
            0x8219D828 => {
    //   block [0x8219D828..0x8219D830)
	// 8219D828: D0230020  stfs f1, 0x20(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219D82C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219D830 size=760
    let mut pc: u32 = 0x8219D830;
    'dispatch: loop {
        match pc {
            0x8219D830 => {
    //   block [0x8219D830..0x8219D860)
	// 8219D830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219D834: 48B0BBC5  bl 0x82ca93f8
	ctx.lr = 0x8219D838;
	sub_82CA93D0(ctx, base);
	// 8219D838: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219D83C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8219D840: 817A0018  lwz r11, 0x18(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 8219D844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D848: 419A02D8  beq cr6, 0x8219db20
	if ctx.cr[6].eq {
	pc = 0x8219DB20; continue 'dispatch;
	}
	// 8219D84C: 817A0030  lwz r11, 0x30(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219D850: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 8219D854: 419A000C  beq cr6, 0x8219d860
	if ctx.cr[6].eq {
	pc = 0x8219D860; continue 'dispatch;
	}
	// 8219D858: 2F0BCFC7  cmpwi cr6, r11, -0x3039
	ctx.cr[6].compare_i32(ctx.r[11].s32, -12345, &mut ctx.xer);
	// 8219D85C: 409A02C4  bne cr6, 0x8219db20
	if !ctx.cr[6].eq {
	pc = 0x8219DB20; continue 'dispatch;
	}
	pc = 0x8219D860; continue 'dispatch;
            }
            0x8219D860 => {
    //   block [0x8219D860..0x8219D8E4)
	// 8219D860: 817A002C  lwz r11, 0x2c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 8219D864: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 8219D868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D86C: 419A01D0  beq cr6, 0x8219da3c
	if ctx.cr[6].eq {
	pc = 0x8219DA3C; continue 'dispatch;
	}
	// 8219D870: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8219D874: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8219D878: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 8219D87C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219D880: 93010064  stw r24, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[24].u32 ) };
	// 8219D884: 93010068  stw r24, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u32 ) };
	// 8219D888: 9301006C  stw r24, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[24].u32 ) };
	// 8219D88C: 48062A55  bl 0x822002e0
	ctx.lr = 0x8219D890;
	sub_822002E0(ctx, base);
	// 8219D890: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219D894: 83210058  lwz r25, 0x58(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8219D898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D89C: 419A0150  beq cr6, 0x8219d9ec
	if ctx.cr[6].eq {
	pc = 0x8219D9EC; continue 'dispatch;
	}
	// 8219D8A0: 38990024  addi r4, r25, 0x24
	ctx.r[4].s64 = ctx.r[25].s64 + 36;
	// 8219D8A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8219D8A8: 48052A49  bl 0x821f02f0
	ctx.lr = 0x8219D8AC;
	sub_821F02F0(ctx, base);
	// 8219D8AC: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8219D8B0: 81210068  lwz r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8219D8B4: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 8219D8B8: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 8219D8BC: 7D685BD7  divw. r11, r8, r11
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219D8C0: 4182012C  beq 0x8219d9ec
	if ctx.cr[0].eq {
	pc = 0x8219D9EC; continue 'dispatch;
	}
	// 8219D8C4: 3BAA0004  addi r29, r10, 4
	ctx.r[29].s64 = ctx.r[10].s64 + 4;
	// 8219D8C8: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 8219D8CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8219D8D0: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 8219D8D4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219D8D8: 3B8A0CA0  addi r28, r10, 0xca0
	ctx.r[28].s64 = ctx.r[10].s64 + 3232;
	// 8219D8DC: 3BC97088  addi r30, r9, 0x7088
	ctx.r[30].s64 = ctx.r[9].s64 + 28808;
	// 8219D8E0: 3BEB2EE0  addi r31, r11, 0x2ee0
	ctx.r[31].s64 = ctx.r[11].s64 + 12000;
	pc = 0x8219D8E4; continue 'dispatch;
            }
            0x8219D8E4 => {
    //   block [0x8219D8E4..0x8219D8EC)
	// 8219D8E4: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 8219D8E8: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	pc = 0x8219D8EC; continue 'dispatch;
            }
            0x8219D8EC => {
    //   block [0x8219D8EC..0x8219D910)
	// 8219D8EC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8219D8F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219D8F4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8219D8F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8219D8FC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8219D900: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219D904: 4082FFE8  bne 0x8219d8ec
	if !ctx.cr[0].eq {
	pc = 0x8219D8EC; continue 'dispatch;
	}
	// 8219D908: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8219D90C: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	pc = 0x8219D910; continue 'dispatch;
            }
            0x8219D910 => {
    //   block [0x8219D910..0x8219D950)
	// 8219D910: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 8219D914: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219D918: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 8219D91C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 8219D920: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8219D924: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219D928: 4082FFE8  bne 0x8219d910
	if !ctx.cr[0].eq {
	pc = 0x8219D910; continue 'dispatch;
	}
	// 8219D92C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8219D930: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8219D934: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219D938: 480C7C09  bl 0x82265540
	ctx.lr = 0x8219D93C;
	sub_82265540(ctx, base);
	// 8219D93C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8219D940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D944: 409A0038  bne cr6, 0x8219d97c
	if !ctx.cr[6].eq {
	pc = 0x8219D97C; continue 'dispatch;
	}
	// 8219D948: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 8219D94C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8219D950; continue 'dispatch;
            }
            0x8219D950 => {
    //   block [0x8219D950..0x8219D974)
	// 8219D950: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219D954: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219D958: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8219D95C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 8219D960: 419A0014  beq cr6, 0x8219d974
	if ctx.cr[6].eq {
	pc = 0x8219D974; continue 'dispatch;
	}
	// 8219D964: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8219D968: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219D96C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8219D970: 419AFFE0  beq cr6, 0x8219d950
	if ctx.cr[6].eq {
	pc = 0x8219D950; continue 'dispatch;
	}
	pc = 0x8219D974; continue 'dispatch;
            }
            0x8219D974 => {
    //   block [0x8219D974..0x8219D97C)
	// 8219D974: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 8219D978: 48000014  b 0x8219d98c
	pc = 0x8219D98C; continue 'dispatch;
            }
            0x8219D97C => {
    //   block [0x8219D97C..0x8219D98C)
	// 8219D97C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219D980: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219D984: 480CFE75  bl 0x8226d7f8
	ctx.lr = 0x8219D988;
	sub_8226D7F8(ctx, base);
	// 8219D988: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	pc = 0x8219D98C; continue 'dispatch;
            }
            0x8219D98C => {
    //   block [0x8219D98C..0x8219D9C8)
	// 8219D98C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8219D990: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219D994: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D998: 419A0038  beq cr6, 0x8219d9d0
	if ctx.cr[6].eq {
	pc = 0x8219D9D0; continue 'dispatch;
	}
	// 8219D99C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8219D9A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219D9A4: 485C7EED  bl 0x82765890
	ctx.lr = 0x8219D9A8;
	sub_82765890(ctx, base);
	// 8219D9A8: 8941007C  lbz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8219D9AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219D9B0: 419A0018  beq cr6, 0x8219d9c8
	if ctx.cr[6].eq {
	pc = 0x8219D9C8; continue 'dispatch;
	}
	// 8219D9B4: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8219D9B8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219D9BC: 419A000C  beq cr6, 0x8219d9c8
	if ctx.cr[6].eq {
	pc = 0x8219D9C8; continue 'dispatch;
	}
	// 8219D9C0: 387AFFF4  addi r3, r26, -0xc
	ctx.r[3].s64 = ctx.r[26].s64 + -12;
	// 8219D9C4: 485C993D  bl 0x82767300
	ctx.lr = 0x8219D9C8;
	sub_82767300(ctx, base);
	pc = 0x8219D9C8; continue 'dispatch;
            }
            0x8219D9C8 => {
    //   block [0x8219D9C8..0x8219D9D0)
	// 8219D9C8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8219D9CC: 4807740D  bl 0x82214dd8
	ctx.lr = 0x8219D9D0;
	sub_82214DD8(ctx, base);
	pc = 0x8219D9D0; continue 'dispatch;
            }
            0x8219D9D0 => {
    //   block [0x8219D9D0..0x8219D9EC)
	// 8219D9D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219D9D4: 48077405  bl 0x82214dd8
	ctx.lr = 0x8219D9D8;
	sub_82214DD8(ctx, base);
	// 8219D9D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8219D9DC: 480773FD  bl 0x82214dd8
	ctx.lr = 0x8219D9E0;
	sub_82214DD8(ctx, base);
	// 8219D9E0: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 8219D9E4: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 8219D9E8: 4082FEFC  bne 0x8219d8e4
	if !ctx.cr[0].eq {
	pc = 0x8219D8E4; continue 'dispatch;
	}
	pc = 0x8219D9EC; continue 'dispatch;
            }
            0x8219D9EC => {
    //   block [0x8219D9EC..0x8219D9F8)
	// 8219D9EC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8219D9F0: 419A0044  beq cr6, 0x8219da34
	if ctx.cr[6].eq {
	pc = 0x8219DA34; continue 'dispatch;
	}
	// 8219D9F4: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	pc = 0x8219D9F8; continue 'dispatch;
            }
            0x8219D9F8 => {
    //   block [0x8219D9F8..0x8219DA34)
	// 8219D9F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8219D9FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219DA00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8219DA04: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8219DA08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8219DA0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219DA10: 4082FFE8  bne 0x8219d9f8
	if !ctx.cr[0].eq {
	pc = 0x8219D9F8; continue 'dispatch;
	}
	// 8219DA14: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8219DA18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219DA1C: 409A0018  bne cr6, 0x8219da34
	if !ctx.cr[6].eq {
	pc = 0x8219DA34; continue 'dispatch;
	}
	// 8219DA20: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DA24: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8219DA28: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DA2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219DA30: 4E800421  bctrl
	ctx.lr = 0x8219DA34;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8219DA34 => {
    //   block [0x8219DA34..0x8219DA3C)
	// 8219DA34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8219DA38: 48851CA1  bl 0x829ef6d8
	ctx.lr = 0x8219DA3C;
	sub_829EF6D8(ctx, base);
	pc = 0x8219DA3C; continue 'dispatch;
            }
            0x8219DA3C => {
    //   block [0x8219DA3C..0x8219DA50)
	// 8219DA3C: 817A0014  lwz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219DA40: 3BBA0010  addi r29, r26, 0x10
	ctx.r[29].s64 = ctx.r[26].s64 + 16;
	// 8219DA44: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 8219DA48: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8219DA4C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8219DA50; continue 'dispatch;
            }
            0x8219DA50 => {
    //   block [0x8219DA50..0x8219DA54)
	// 8219DA50: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	pc = 0x8219DA54; continue 'dispatch;
            }
            0x8219DA54 => {
    //   block [0x8219DA54..0x8219DA68)
	// 8219DA54: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DA58: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219DA5C: 419A000C  beq cr6, 0x8219da68
	if ctx.cr[6].eq {
	pc = 0x8219DA68; continue 'dispatch;
	}
	// 8219DA60: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8219DA64: 419A0008  beq cr6, 0x8219da6c
	if ctx.cr[6].eq {
	pc = 0x8219DA6C; continue 'dispatch;
	}
	pc = 0x8219DA68; continue 'dispatch;
            }
            0x8219DA68 => {
    //   block [0x8219DA68..0x8219DA6C)
	// 8219DA68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219DA6C; continue 'dispatch;
            }
            0x8219DA6C => {
    //   block [0x8219DA6C..0x8219DA80)
	// 8219DA6C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219DA70: 419A00B0  beq cr6, 0x8219db20
	if ctx.cr[6].eq {
	pc = 0x8219DB20; continue 'dispatch;
	}
	// 8219DA74: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219DA78: 409A0008  bne cr6, 0x8219da80
	if !ctx.cr[6].eq {
	pc = 0x8219DA80; continue 'dispatch;
	}
	// 8219DA7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219DA80; continue 'dispatch;
            }
            0x8219DA80 => {
    //   block [0x8219DA80..0x8219DA90)
	// 8219DA80: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DA84: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219DA88: 409A0008  bne cr6, 0x8219da90
	if !ctx.cr[6].eq {
	pc = 0x8219DA90; continue 'dispatch;
	}
	// 8219DA8C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219DA90; continue 'dispatch;
            }
            0x8219DA90 => {
    //   block [0x8219DA90..0x8219DACC)
	// 8219DA90: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219DA94: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 8219DA98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DA9C: 419A0030  beq cr6, 0x8219dacc
	if ctx.cr[6].eq {
	pc = 0x8219DACC; continue 'dispatch;
	}
	// 8219DAA0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DAA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219DAA8: 419A004C  beq cr6, 0x8219daf4
	if ctx.cr[6].eq {
	pc = 0x8219DAF4; continue 'dispatch;
	}
	// 8219DAAC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219DAB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DAB4: 419A0018  beq cr6, 0x8219dacc
	if ctx.cr[6].eq {
	pc = 0x8219DACC; continue 'dispatch;
	}
	// 8219DAB8: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219DABC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219DAC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219DAC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219DAC8: 409A0008  bne cr6, 0x8219dad0
	if !ctx.cr[6].eq {
	pc = 0x8219DAD0; continue 'dispatch;
	}
	pc = 0x8219DACC; continue 'dispatch;
            }
            0x8219DACC => {
    //   block [0x8219DACC..0x8219DAD0)
	// 8219DACC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x8219DAD0; continue 'dispatch;
            }
            0x8219DAD0 => {
    //   block [0x8219DAD0..0x8219DAEC)
	// 8219DAD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219DAD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DAD8: 419A0024  beq cr6, 0x8219dafc
	if ctx.cr[6].eq {
	pc = 0x8219DAFC; continue 'dispatch;
	}
	// 8219DADC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DAE0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219DAE4: 409A0008  bne cr6, 0x8219daec
	if !ctx.cr[6].eq {
	pc = 0x8219DAEC; continue 'dispatch;
	}
	// 8219DAE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219DAEC; continue 'dispatch;
            }
            0x8219DAEC => {
    //   block [0x8219DAEC..0x8219DAF4)
	// 8219DAEC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DAF0: 4BFFFF60  b 0x8219da50
	pc = 0x8219DA50; continue 'dispatch;
            }
            0x8219DAF4 => {
    //   block [0x8219DAF4..0x8219DAFC)
	// 8219DAF4: 4BFF6345  bl 0x82193e38
	ctx.lr = 0x8219DAF8;
	sub_82193E38(ctx, base);
	// 8219DAF8: 4BFFFFD4  b 0x8219dacc
	pc = 0x8219DACC; continue 'dispatch;
            }
            0x8219DAFC => {
    //   block [0x8219DAFC..0x8219DB20)
	// 8219DAFC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8219DB00: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8219DB04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219DB08: 4BFED169  bl 0x8218ac70
	ctx.lr = 0x8219DB0C;
	sub_8218AC70(ctx, base);
	// 8219DB0C: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8219DB10: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8219DB14: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8219DB18: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8219DB1C: 4BFFFF38  b 0x8219da54
	pc = 0x8219DA54; continue 'dispatch;
            }
            0x8219DB20 => {
    //   block [0x8219DB20..0x8219DB28)
	// 8219DB20: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8219DB24: 48B0B924  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219DB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219DB28 size=204
    let mut pc: u32 = 0x8219DB28;
    'dispatch: loop {
        match pc {
            0x8219DB28 => {
    //   block [0x8219DB28..0x8219DB5C)
	// 8219DB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219DB2C: 48B0B8E1  bl 0x82ca940c
	ctx.lr = 0x8219DB30;
	sub_82CA93D0(ctx, base);
	// 8219DB30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219DB34: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8219DB38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219DB3C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219DB40: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8219DB44: 419A0018  beq cr6, 0x8219db5c
	if ctx.cr[6].eq {
	pc = 0x8219DB5C; continue 'dispatch;
	}
	// 8219DB48: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219DB4C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219DB50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219DB54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219DB58: 409A0008  bne cr6, 0x8219db60
	if !ctx.cr[6].eq {
	pc = 0x8219DB60; continue 'dispatch;
	}
	pc = 0x8219DB5C; continue 'dispatch;
            }
            0x8219DB5C => {
    //   block [0x8219DB5C..0x8219DB60)
	// 8219DB5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219DB60; continue 'dispatch;
            }
            0x8219DB60 => {
    //   block [0x8219DB60..0x8219DBB0)
	// 8219DB60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219DB64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DB68: 419A0048  beq cr6, 0x8219dbb0
	if ctx.cr[6].eq {
	pc = 0x8219DBB0; continue 'dispatch;
	}
	// 8219DB6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8219DB70: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219DB74: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 8219DB78: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8219DB7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219DB80: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8219DB84: 48076D15  bl 0x82214898
	ctx.lr = 0x8219DB88;
	sub_82214898(ctx, base);
	// 8219DB88: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8219DB8C: 389E004C  addi r4, r30, 0x4c
	ctx.r[4].s64 = ctx.r[30].s64 + 76;
	// 8219DB90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8219DB94: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 8219DB98: 83BE0054  lwz r29, 0x54(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219DB9C: 482E7155  bl 0x82484cf0
	ctx.lr = 0x8219DBA0;
	sub_82484CF0(ctx, base);
	// 8219DBA0: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DBA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219DBA8: 7F08E840  cmplw cr6, r8, r29
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8219DBAC: 409A0008  bne cr6, 0x8219dbb4
	if !ctx.cr[6].eq {
	pc = 0x8219DBB4; continue 'dispatch;
	}
	pc = 0x8219DBB0; continue 'dispatch;
            }
            0x8219DBB0 => {
    //   block [0x8219DBB0..0x8219DBB4)
	// 8219DBB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219DBB4; continue 'dispatch;
            }
            0x8219DBB4 => {
    //   block [0x8219DBB4..0x8219DBD8)
	// 8219DBB4: 57EA07FE  clrlwi r10, r31, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 8219DBB8: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219DBBC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219DBC0: 419A0018  beq cr6, 0x8219dbd8
	if ctx.cr[6].eq {
	pc = 0x8219DBD8; continue 'dispatch;
	}
	// 8219DBC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8219DBC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219DBCC: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 8219DBD0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8219DBD4: 4BFF6265  bl 0x82193e38
	ctx.lr = 0x8219DBD8;
	sub_82193E38(ctx, base);
	pc = 0x8219DBD8; continue 'dispatch;
            }
            0x8219DBD8 => {
    //   block [0x8219DBD8..0x8219DBEC)
	// 8219DBD8: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 8219DBDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219DBE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DBE4: 409A0008  bne cr6, 0x8219dbec
	if !ctx.cr[6].eq {
	pc = 0x8219DBEC; continue 'dispatch;
	}
	// 8219DBE8: 887E0024  lbz r3, 0x24(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	pc = 0x8219DBEC; continue 'dispatch;
            }
            0x8219DBEC => {
    //   block [0x8219DBEC..0x8219DBF4)
	// 8219DBEC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8219DBF0: 48B0B86C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219DBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219DBF8 size=1352
    let mut pc: u32 = 0x8219DBF8;
    'dispatch: loop {
        match pc {
            0x8219DBF8 => {
    //   block [0x8219DBF8..0x8219DC44)
	// 8219DBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219DBFC: 48B0B805  bl 0x82ca9400
	ctx.lr = 0x8219DC00;
	sub_82CA93D0(ctx, base);
	// 8219DC00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219DC04: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8219DC08: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 8219DC0C: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 8219DC10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DC14: 419A0030  beq cr6, 0x8219dc44
	if ctx.cr[6].eq {
	pc = 0x8219DC44; continue 'dispatch;
	}
	// 8219DC18: 576A063E  clrlwi r10, r27, 0x18
	ctx.r[10].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 8219DC1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219DC20: 409A0024  bne cr6, 0x8219dc44
	if !ctx.cr[6].eq {
	pc = 0x8219DC44; continue 'dispatch;
	}
	// 8219DC24: 897D0020  lbz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219DC28: 548A063E  clrlwi r10, r4, 0x18
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 8219DC2C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8219DC30: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 8219DC34: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 8219DC38: 68E30001  xori r3, r7, 1
	ctx.r[3].u64 = ctx.r[7].u64 ^ 1;
	// 8219DC3C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219DC40: 48B0B810  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x8219DC44 => {
    //   block [0x8219DC44..0x8219DC5C)
	// 8219DC44: 895D0020  lbz r10, 0x20(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219DC48: 549A063E  clrlwi r26, r4, 0x18
	ctx.r[26].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 8219DC4C: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8219DC50: 409A000C  bne cr6, 0x8219dc5c
	if !ctx.cr[6].eq {
	pc = 0x8219DC5C; continue 'dispatch;
	}
	// 8219DC54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DC58: 419A04DC  beq cr6, 0x8219e134
	if ctx.cr[6].eq {
	pc = 0x8219E134; continue 'dispatch;
	}
	pc = 0x8219DC5C; continue 'dispatch;
            }
            0x8219DC5C => {
    //   block [0x8219DC5C..0x8219DC74)
	// 8219DC5C: 897D0021  lbz r11, 0x21(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(33 as u32) ) } as u64;
	// 8219DC60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DC64: 419A001C  beq cr6, 0x8219dc80
	if ctx.cr[6].eq {
	pc = 0x8219DC80; continue 'dispatch;
	}
	// 8219DC68: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 8219DC6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DC70: 409A0010  bne cr6, 0x8219dc80
	if !ctx.cr[6].eq {
	pc = 0x8219DC80; continue 'dispatch;
	}
	pc = 0x8219DC74; continue 'dispatch;
            }
            0x8219DC74 => {
    //   block [0x8219DC74..0x8219DC80)
	// 8219DC74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219DC78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219DC7C: 48B0B7D4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x8219DC80 => {
    //   block [0x8219DC80..0x8219DCD4)
	// 8219DC80: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DC84: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8219DC88: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DC8C: 812A005C  lwz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 8219DC90: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8219DC94: 4E800421  bctrl
	ctx.lr = 0x8219DC98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219DC98: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8219DC9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219DCA0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8219DCA4: 419A0030  beq cr6, 0x8219dcd4
	if ctx.cr[6].eq {
	pc = 0x8219DCD4; continue 'dispatch;
	}
	// 8219DCA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8219DCAC: 4806C965  bl 0x8220a610
	ctx.lr = 0x8219DCB0;
	sub_8220A610(ctx, base);
	// 8219DCB0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219DCB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DCB8: 419A001C  beq cr6, 0x8219dcd4
	if ctx.cr[6].eq {
	pc = 0x8219DCD4; continue 'dispatch;
	}
	// 8219DCBC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219DCC0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8219DCC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DCC8: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219DCCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219DCD0: 4E800421  bctrl
	ctx.lr = 0x8219DCD4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8219DCD4 => {
    //   block [0x8219DCD4..0x8219DD18)
	// 8219DCD4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DCD8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219DCDC: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8219DCE0: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8219DCE4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219DCE8: 419A00F4  beq cr6, 0x8219dddc
	if ctx.cr[6].eq {
	pc = 0x8219DDDC; continue 'dispatch;
	}
	// 8219DCEC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219DCF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219DCF4: 419A0024  beq cr6, 0x8219dd18
	if ctx.cr[6].eq {
	pc = 0x8219DD18; continue 'dispatch;
	}
	// 8219DCF8: 894A0040  lbz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8219DCFC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219DD00: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8219DD04: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219DD08: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DD0C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8219DD10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219DD14: 480000CC  b 0x8219dde0
	pc = 0x8219DDE0; continue 'dispatch;
            }
            0x8219DD18 => {
    //   block [0x8219DD18..0x8219DD34)
	// 8219DD18: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219DD1C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8219DD20: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8219DD24: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8219DD28: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8219DD2C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219DD30: 40810054  ble 0x8219dd84
	if !ctx.cr[0].gt {
	pc = 0x8219DD84; continue 'dispatch;
	}
	pc = 0x8219DD34; continue 'dispatch;
            }
            0x8219DD34 => {
    //   block [0x8219DD34..0x8219DD54)
	// 8219DD34: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8219DD38: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219DD3C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8219DD40: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DD44: 2F070040  cmpwi cr6, r7, 0x40
	ctx.cr[6].compare_i32(ctx.r[7].s32, 64, &mut ctx.xer);
	// 8219DD48: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8219DD4C: 41980008  blt cr6, 0x8219dd54
	if ctx.cr[6].lt {
	pc = 0x8219DD54; continue 'dispatch;
	}
	// 8219DD50: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8219DD54; continue 'dispatch;
            }
            0x8219DD54 => {
    //   block [0x8219DD54..0x8219DD70)
	// 8219DD54: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8219DD58: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219DD5C: 419A0014  beq cr6, 0x8219dd70
	if ctx.cr[6].eq {
	pc = 0x8219DD70; continue 'dispatch;
	}
	// 8219DD60: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8219DD64: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219DD68: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8219DD6C: 4800000C  b 0x8219dd78
	pc = 0x8219DD78; continue 'dispatch;
            }
            0x8219DD70 => {
    //   block [0x8219DD70..0x8219DD78)
	// 8219DD70: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8219DD74: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8219DD78; continue 'dispatch;
            }
            0x8219DD78 => {
    //   block [0x8219DD78..0x8219DD84)
	// 8219DD78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219DD7C: 4199FFB8  bgt cr6, 0x8219dd34
	if ctx.cr[6].gt {
	pc = 0x8219DD34; continue 'dispatch;
	}
	// 8219DD80: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8219DD84; continue 'dispatch;
            }
            0x8219DD84 => {
    //   block [0x8219DD84..0x8219DDA0)
	// 8219DD84: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8219DD88: 419A0040  beq cr6, 0x8219ddc8
	if ctx.cr[6].eq {
	pc = 0x8219DDC8; continue 'dispatch;
	}
	// 8219DD8C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DD90: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 8219DD94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219DD98: 41990008  bgt cr6, 0x8219dda0
	if ctx.cr[6].gt {
	pc = 0x8219DDA0; continue 'dispatch;
	}
	// 8219DD9C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8219DDA0; continue 'dispatch;
            }
            0x8219DDA0 => {
    //   block [0x8219DDA0..0x8219DDC8)
	// 8219DDA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219DDA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DDA8: 409A0020  bne cr6, 0x8219ddc8
	if !ctx.cr[6].eq {
	pc = 0x8219DDC8; continue 'dispatch;
	}
	// 8219DDAC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219DDB0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219DDB4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219DDB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DDBC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8219DDC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219DDC4: 4800001C  b 0x8219dde0
	pc = 0x8219DDE0; continue 'dispatch;
            }
            0x8219DDC8 => {
    //   block [0x8219DDC8..0x8219DDDC)
	// 8219DDC8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8219DDCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DDD0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8219DDD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219DDD8: 48000008  b 0x8219dde0
	pc = 0x8219DDE0; continue 'dispatch;
            }
            0x8219DDDC => {
    //   block [0x8219DDDC..0x8219DDE0)
	// 8219DDDC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8219DDE0; continue 'dispatch;
            }
            0x8219DDE0 => {
    //   block [0x8219DDE0..0x8219DE18)
	// 8219DDE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219DDE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DDE8: 419A01CC  beq cr6, 0x8219dfb4
	if ctx.cr[6].eq {
	pc = 0x8219DFB4; continue 'dispatch;
	}
	// 8219DDEC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8219DDF0: 409A01C4  bne cr6, 0x8219dfb4
	if !ctx.cr[6].eq {
	pc = 0x8219DFB4; continue 'dispatch;
	}
	// 8219DDF4: 48101085  bl 0x8229ee78
	ctx.lr = 0x8219DDF8;
	sub_8229EE78(ctx, base);
	// 8219DDF8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219DDFC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219DE00: 419A0018  beq cr6, 0x8219de18
	if ctx.cr[6].eq {
	pc = 0x8219DE18; continue 'dispatch;
	}
	// 8219DE04: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219DE08: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219DE0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219DE10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219DE14: 409A0008  bne cr6, 0x8219de1c
	if !ctx.cr[6].eq {
	pc = 0x8219DE1C; continue 'dispatch;
	}
	pc = 0x8219DE18; continue 'dispatch;
            }
            0x8219DE18 => {
    //   block [0x8219DE18..0x8219DE1C)
	// 8219DE18: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8219DE1C; continue 'dispatch;
            }
            0x8219DE1C => {
    //   block [0x8219DE1C..0x8219DE60)
	// 8219DE1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219DE20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DE24: 419A0190  beq cr6, 0x8219dfb4
	if ctx.cr[6].eq {
	pc = 0x8219DFB4; continue 'dispatch;
	}
	// 8219DE28: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8219DE2C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8219DE30: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219DE34: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8219DE38: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DE3C: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DE40: 4808E379  bl 0x8222c1b8
	ctx.lr = 0x8219DE44;
	sub_8222C1B8(ctx, base);
	// 8219DE44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219DE48: 419A0018  beq cr6, 0x8219de60
	if ctx.cr[6].eq {
	pc = 0x8219DE60; continue 'dispatch;
	}
	// 8219DE4C: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219DE50: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219DE54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219DE58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219DE5C: 409A0008  bne cr6, 0x8219de64
	if !ctx.cr[6].eq {
	pc = 0x8219DE64; continue 'dispatch;
	}
	pc = 0x8219DE60; continue 'dispatch;
            }
            0x8219DE60 => {
    //   block [0x8219DE60..0x8219DE64)
	// 8219DE60: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8219DE64; continue 'dispatch;
            }
            0x8219DE64 => {
    //   block [0x8219DE64..0x8219DEB0)
	// 8219DE64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219DE68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DE6C: 419A0148  beq cr6, 0x8219dfb4
	if ctx.cr[6].eq {
	pc = 0x8219DFB4; continue 'dispatch;
	}
	// 8219DE70: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 8219DE74: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 8219DE78: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8219DE7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219DE80: 419A00F4  beq cr6, 0x8219df74
	if ctx.cr[6].eq {
	pc = 0x8219DF74; continue 'dispatch;
	}
	// 8219DE84: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219DE88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DE8C: 419A0024  beq cr6, 0x8219deb0
	if ctx.cr[6].eq {
	pc = 0x8219DEB0; continue 'dispatch;
	}
	// 8219DE90: 894B0045  lbz r10, 0x45(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(69 as u32) ) } as u64;
	// 8219DE94: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219DE98: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8219DE9C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219DEA0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DEA4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8219DEA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219DEAC: 480000CC  b 0x8219df78
	pc = 0x8219DF78; continue 'dispatch;
            }
            0x8219DEB0 => {
    //   block [0x8219DEB0..0x8219DECC)
	// 8219DEB0: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219DEB4: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 8219DEB8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8219DEBC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8219DEC0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8219DEC4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219DEC8: 40810054  ble 0x8219df1c
	if !ctx.cr[0].gt {
	pc = 0x8219DF1C; continue 'dispatch;
	}
	pc = 0x8219DECC; continue 'dispatch;
            }
            0x8219DECC => {
    //   block [0x8219DECC..0x8219DEEC)
	// 8219DECC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8219DED0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219DED4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8219DED8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DEDC: 2F070045  cmpwi cr6, r7, 0x45
	ctx.cr[6].compare_i32(ctx.r[7].s32, 69, &mut ctx.xer);
	// 8219DEE0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8219DEE4: 41980008  blt cr6, 0x8219deec
	if ctx.cr[6].lt {
	pc = 0x8219DEEC; continue 'dispatch;
	}
	// 8219DEE8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8219DEEC; continue 'dispatch;
            }
            0x8219DEEC => {
    //   block [0x8219DEEC..0x8219DF08)
	// 8219DEEC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8219DEF0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219DEF4: 419A0014  beq cr6, 0x8219df08
	if ctx.cr[6].eq {
	pc = 0x8219DF08; continue 'dispatch;
	}
	// 8219DEF8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8219DEFC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219DF00: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8219DF04: 4800000C  b 0x8219df10
	pc = 0x8219DF10; continue 'dispatch;
            }
            0x8219DF08 => {
    //   block [0x8219DF08..0x8219DF10)
	// 8219DF08: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8219DF0C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8219DF10; continue 'dispatch;
            }
            0x8219DF10 => {
    //   block [0x8219DF10..0x8219DF1C)
	// 8219DF10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219DF14: 4199FFB8  bgt cr6, 0x8219decc
	if ctx.cr[6].gt {
	pc = 0x8219DECC; continue 'dispatch;
	}
	// 8219DF18: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8219DF1C; continue 'dispatch;
            }
            0x8219DF1C => {
    //   block [0x8219DF1C..0x8219DF38)
	// 8219DF1C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8219DF20: 419A0040  beq cr6, 0x8219df60
	if ctx.cr[6].eq {
	pc = 0x8219DF60; continue 'dispatch;
	}
	// 8219DF24: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DF28: 2F0B0045  cmpwi cr6, r11, 0x45
	ctx.cr[6].compare_i32(ctx.r[11].s32, 69, &mut ctx.xer);
	// 8219DF2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219DF30: 41990008  bgt cr6, 0x8219df38
	if ctx.cr[6].gt {
	pc = 0x8219DF38; continue 'dispatch;
	}
	// 8219DF34: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8219DF38; continue 'dispatch;
            }
            0x8219DF38 => {
    //   block [0x8219DF38..0x8219DF60)
	// 8219DF38: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219DF3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DF40: 409A0020  bne cr6, 0x8219df60
	if !ctx.cr[6].eq {
	pc = 0x8219DF60; continue 'dispatch;
	}
	// 8219DF44: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219DF48: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219DF4C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219DF50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DF54: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8219DF58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219DF5C: 4800001C  b 0x8219df78
	pc = 0x8219DF78; continue 'dispatch;
            }
            0x8219DF60 => {
    //   block [0x8219DF60..0x8219DF74)
	// 8219DF60: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8219DF64: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DF68: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8219DF6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219DF70: 48000008  b 0x8219df78
	pc = 0x8219DF78; continue 'dispatch;
            }
            0x8219DF74 => {
    //   block [0x8219DF74..0x8219DF78)
	// 8219DF74: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8219DF78; continue 'dispatch;
            }
            0x8219DF78 => {
    //   block [0x8219DF78..0x8219DFB4)
	// 8219DF78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219DF7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DF80: 419A0034  beq cr6, 0x8219dfb4
	if ctx.cr[6].eq {
	pc = 0x8219DFB4; continue 'dispatch;
	}
	// 8219DF84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219DF88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219DF8C: 4873355D  bl 0x828d14e8
	ctx.lr = 0x8219DF90;
	sub_828D14E8(ctx, base);
	// 8219DF90: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219DF94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DF98: 419A001C  beq cr6, 0x8219dfb4
	if ctx.cr[6].eq {
	pc = 0x8219DFB4; continue 'dispatch;
	}
	// 8219DF9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219DFA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219DFA4: 4873485D  bl 0x828d2800
	ctx.lr = 0x8219DFA8;
	sub_828D2800(ctx, base);
	// 8219DFA8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219DFAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DFB0: 419AFCC4  beq cr6, 0x8219dc74
	if ctx.cr[6].eq {
	pc = 0x8219DC74; continue 'dispatch;
	}
	pc = 0x8219DFB4; continue 'dispatch;
            }
            0x8219DFB4 => {
    //   block [0x8219DFB4..0x8219DFFC)
	// 8219DFB4: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 8219DFB8: 9B7D0028  stb r27, 0x28(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[27].u8 ) };
	// 8219DFBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DFC0: 419A003C  beq cr6, 0x8219dffc
	if ctx.cr[6].eq {
	pc = 0x8219DFFC; continue 'dispatch;
	}
	// 8219DFC4: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 8219DFC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DFCC: 419A0030  beq cr6, 0x8219dffc
	if ctx.cr[6].eq {
	pc = 0x8219DFFC; continue 'dispatch;
	}
	// 8219DFD0: 897D0020  lbz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219DFD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219DFD8: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8219DFDC: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 8219DFE0: 993D0020  stb r9, 0x20(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[9].u8 ) };
	// 8219DFE4: 483E616D  bl 0x82584150
	ctx.lr = 0x8219DFE8;
	sub_82584150(ctx, base);
	// 8219DFE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219DFEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219DFF0: 483E5C29  bl 0x82583c18
	ctx.lr = 0x8219DFF4;
	sub_82583C18(ctx, base);
	// 8219DFF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219DFF8: 483E3541  bl 0x82581538
	ctx.lr = 0x8219DFFC;
	sub_82581538(ctx, base);
	pc = 0x8219DFFC; continue 'dispatch;
            }
            0x8219DFFC => {
    //   block [0x8219DFFC..0x8219E048)
	// 8219DFFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219E000: 483E4269  bl 0x82582268
	ctx.lr = 0x8219E004;
	sub_82582268(ctx, base);
	// 8219E004: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219E008: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 8219E00C: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8219E010: 55284FFE  rlwinm r8, r9, 9, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x007FFFFFu64;
	// 8219E014: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8219E018: 419A00F4  beq cr6, 0x8219e10c
	if ctx.cr[6].eq {
	pc = 0x8219E10C; continue 'dispatch;
	}
	// 8219E01C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219E020: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219E024: 419A0024  beq cr6, 0x8219e048
	if ctx.cr[6].eq {
	pc = 0x8219E048; continue 'dispatch;
	}
	// 8219E028: 892A0017  lbz r9, 0x17(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(23 as u32) ) } as u64;
	// 8219E02C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219E030: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8219E034: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8219E038: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219E03C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8219E040: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219E044: 480000CC  b 0x8219e110
	pc = 0x8219E110; continue 'dispatch;
            }
            0x8219E048 => {
    //   block [0x8219E048..0x8219E064)
	// 8219E048: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219E04C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8219E050: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8219E054: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8219E058: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8219E05C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219E060: 40810054  ble 0x8219e0b4
	if !ctx.cr[0].gt {
	pc = 0x8219E0B4; continue 'dispatch;
	}
	pc = 0x8219E064; continue 'dispatch;
            }
            0x8219E064 => {
    //   block [0x8219E064..0x8219E084)
	// 8219E064: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8219E068: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219E06C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8219E070: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E074: 2F070017  cmpwi cr6, r7, 0x17
	ctx.cr[6].compare_i32(ctx.r[7].s32, 23, &mut ctx.xer);
	// 8219E078: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8219E07C: 41980008  blt cr6, 0x8219e084
	if ctx.cr[6].lt {
	pc = 0x8219E084; continue 'dispatch;
	}
	// 8219E080: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8219E084; continue 'dispatch;
            }
            0x8219E084 => {
    //   block [0x8219E084..0x8219E0A0)
	// 8219E084: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8219E088: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219E08C: 419A0014  beq cr6, 0x8219e0a0
	if ctx.cr[6].eq {
	pc = 0x8219E0A0; continue 'dispatch;
	}
	// 8219E090: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8219E094: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219E098: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8219E09C: 4800000C  b 0x8219e0a8
	pc = 0x8219E0A8; continue 'dispatch;
            }
            0x8219E0A0 => {
    //   block [0x8219E0A0..0x8219E0A8)
	// 8219E0A0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8219E0A4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8219E0A8; continue 'dispatch;
            }
            0x8219E0A8 => {
    //   block [0x8219E0A8..0x8219E0B4)
	// 8219E0A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219E0AC: 4199FFB8  bgt cr6, 0x8219e064
	if ctx.cr[6].gt {
	pc = 0x8219E064; continue 'dispatch;
	}
	// 8219E0B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8219E0B4; continue 'dispatch;
            }
            0x8219E0B4 => {
    //   block [0x8219E0B4..0x8219E0D0)
	// 8219E0B4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8219E0B8: 419A0040  beq cr6, 0x8219e0f8
	if ctx.cr[6].eq {
	pc = 0x8219E0F8; continue 'dispatch;
	}
	// 8219E0BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E0C0: 2F0B0017  cmpwi cr6, r11, 0x17
	ctx.cr[6].compare_i32(ctx.r[11].s32, 23, &mut ctx.xer);
	// 8219E0C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219E0C8: 41990008  bgt cr6, 0x8219e0d0
	if ctx.cr[6].gt {
	pc = 0x8219E0D0; continue 'dispatch;
	}
	// 8219E0CC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8219E0D0; continue 'dispatch;
            }
            0x8219E0D0 => {
    //   block [0x8219E0D0..0x8219E0F8)
	// 8219E0D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219E0D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E0D8: 409A0020  bne cr6, 0x8219e0f8
	if !ctx.cr[6].eq {
	pc = 0x8219E0F8; continue 'dispatch;
	}
	// 8219E0DC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219E0E0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219E0E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219E0E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219E0EC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8219E0F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219E0F4: 4800001C  b 0x8219e110
	pc = 0x8219E110; continue 'dispatch;
            }
            0x8219E0F8 => {
    //   block [0x8219E0F8..0x8219E10C)
	// 8219E0F8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8219E0FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219E100: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8219E104: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219E108: 48000008  b 0x8219e110
	pc = 0x8219E110; continue 'dispatch;
            }
            0x8219E10C => {
    //   block [0x8219E10C..0x8219E110)
	// 8219E10C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8219E110; continue 'dispatch;
            }
            0x8219E110 => {
    //   block [0x8219E110..0x8219E134)
	// 8219E110: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219E114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E118: 419A001C  beq cr6, 0x8219e134
	if ctx.cr[6].eq {
	pc = 0x8219E134; continue 'dispatch;
	}
	// 8219E11C: 7F4B0034  cntlzw r11, r26
	ctx.r[11].u64 = if ctx.r[26].u32 == 0 { 32 } else { ctx.r[26].u32.leading_zeros() as u64 };
	// 8219E120: 892A0023  lbz r9, 0x23(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(35 as u32) ) } as u64;
	// 8219E124: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8219E128: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219E12C: 419A0008  beq cr6, 0x8219e134
	if ctx.cr[6].eq {
	pc = 0x8219E134; continue 'dispatch;
	}
	// 8219E130: 996A0023  stb r11, 0x23(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(35 as u32), ctx.r[11].u8 ) };
	pc = 0x8219E134; continue 'dispatch;
            }
            0x8219E134 => {
    //   block [0x8219E134..0x8219E140)
	// 8219E134: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219E138: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219E13C: 48B0B314  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219E140 size=204
    let mut pc: u32 = 0x8219E140;
    'dispatch: loop {
        match pc {
            0x8219E140 => {
    //   block [0x8219E140..0x8219E1F0)
	// 8219E140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219E144: 48B0B2C9  bl 0x82ca940c
	ctx.lr = 0x8219E148;
	sub_82CA93D0(ctx, base);
	// 8219E148: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219E14C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8219E150: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219E154: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219E158: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8219E15C: 4BFFF9CD  bl 0x8219db28
	ctx.lr = 0x8219E160;
	sub_8219DB28(ctx, base);
	// 8219E160: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219E164: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E168: 419A0088  beq cr6, 0x8219e1f0
	if ctx.cr[6].eq {
	pc = 0x8219E1F0; continue 'dispatch;
	}
	// 8219E16C: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 8219E170: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E174: 419A007C  beq cr6, 0x8219e1f0
	if ctx.cr[6].eq {
	pc = 0x8219E1F0; continue 'dispatch;
	}
	// 8219E178: 897F0020  lbz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219E17C: 57CA063E  clrlwi r10, r30, 0x18
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 8219E180: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219E184: 409A006C  bne cr6, 0x8219e1f0
	if !ctx.cr[6].eq {
	pc = 0x8219E1F0; continue 'dispatch;
	}
	// 8219E188: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 8219E18C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219E190: 419A0060  beq cr6, 0x8219e1f0
	if ctx.cr[6].eq {
	pc = 0x8219E1F0; continue 'dispatch;
	}
	// 8219E194: C0230028  lfs f1, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219E198: 481354B1  bl 0x822d3648
	ctx.lr = 0x8219E19C;
	sub_822D3648(ctx, base);
	// 8219E19C: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 8219E1A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219E1A4: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 8219E1A8: 995F0024  stb r10, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u8 ) };
	// 8219E1AC: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E1B0: C00B1460  lfs f0, 0x1460(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219E1B4: EC210028  fsubs f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219E1B8: 8109001C  lwz r8, 0x1c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219E1BC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8219E1C0: 4E800421  bctrl
	ctx.lr = 0x8219E1C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219E1C4: 88FF0020  lbz r7, 0x20(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219E1C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219E1CC: 7CE60034  cntlzw r6, r7
	ctx.r[6].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 8219E1D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219E1D4: 54C5DFFE  rlwinm r5, r6, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 8219E1D8: 98BF0020  stb r5, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[5].u8 ) };
	// 8219E1DC: 483E5A3D  bl 0x82583c18
	ctx.lr = 0x8219E1E0;
	sub_82583C18(ctx, base);
	// 8219E1E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219E1E4: 483E3355  bl 0x82581538
	ctx.lr = 0x8219E1E8;
	sub_82581538(ctx, base);
	// 8219E1E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219E1EC: 483E5F65  bl 0x82584150
	ctx.lr = 0x8219E1F0;
	sub_82584150(ctx, base);
            }
            0x8219E1F0 => {
    //   block [0x8219E1F0..0x8219E20C)
	// 8219E1F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219E1F4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8219E1F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219E1FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219E200: 4BFFF9F9  bl 0x8219dbf8
	ctx.lr = 0x8219E204;
	sub_8219DBF8(ctx, base);
	// 8219E204: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219E208: 48B0B254  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219E210 size=416
    let mut pc: u32 = 0x8219E210;
    'dispatch: loop {
        match pc {
            0x8219E210 => {
    //   block [0x8219E210..0x8219E244)
	// 8219E210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219E214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219E218: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219E21C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219E220: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8219E224: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 8219E228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E22C: 419A0018  beq cr6, 0x8219e244
	if ctx.cr[6].eq {
	pc = 0x8219E244; continue 'dispatch;
	}
	// 8219E230: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219E234: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8219E238: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219E23C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219E240: 409A0008  bne cr6, 0x8219e248
	if !ctx.cr[6].eq {
	pc = 0x8219E248; continue 'dispatch;
	}
	pc = 0x8219E244; continue 'dispatch;
            }
            0x8219E244 => {
    //   block [0x8219E244..0x8219E248)
	// 8219E244: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8219E248; continue 'dispatch;
            }
            0x8219E248 => {
    //   block [0x8219E248..0x8219E294)
	// 8219E248: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8219E24C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219E250: 419A0148  beq cr6, 0x8219e398
	if ctx.cr[6].eq {
	pc = 0x8219E398; continue 'dispatch;
	}
	// 8219E254: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8219E258: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219E25C: 5528A7FE  rlwinm r8, r9, 0x14, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000FFFu64;
	// 8219E260: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8219E264: 419A00F8  beq cr6, 0x8219e35c
	if ctx.cr[6].eq {
	pc = 0x8219E35C; continue 'dispatch;
	}
	// 8219E268: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219E26C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219E270: 419A0024  beq cr6, 0x8219e294
	if ctx.cr[6].eq {
	pc = 0x8219E294; continue 'dispatch;
	}
	// 8219E274: 892A004C  lbz r9, 0x4c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) } as u64;
	// 8219E278: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219E27C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8219E280: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8219E284: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219E288: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8219E28C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219E290: 480000D0  b 0x8219e360
	pc = 0x8219E360; continue 'dispatch;
            }
            0x8219E294 => {
    //   block [0x8219E294..0x8219E2B4)
	// 8219E294: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219E298: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219E29C: 83EB004C  lwz r31, 0x4c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8219E2A0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8219E2A4: 7D0AF850  subf r8, r10, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 8219E2A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8219E2AC: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219E2B0: 40810054  ble 0x8219e304
	if !ctx.cr[0].gt {
	pc = 0x8219E304; continue 'dispatch;
	}
	pc = 0x8219E2B4; continue 'dispatch;
            }
            0x8219E2B4 => {
    //   block [0x8219E2B4..0x8219E2D4)
	// 8219E2B4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8219E2B8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219E2BC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8219E2C0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E2C4: 2F07004C  cmpwi cr6, r7, 0x4c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 76, &mut ctx.xer);
	// 8219E2C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8219E2CC: 41980008  blt cr6, 0x8219e2d4
	if ctx.cr[6].lt {
	pc = 0x8219E2D4; continue 'dispatch;
	}
	// 8219E2D0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8219E2D4; continue 'dispatch;
            }
            0x8219E2D4 => {
    //   block [0x8219E2D4..0x8219E2F0)
	// 8219E2D4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8219E2D8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219E2DC: 419A0014  beq cr6, 0x8219e2f0
	if ctx.cr[6].eq {
	pc = 0x8219E2F0; continue 'dispatch;
	}
	// 8219E2E0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8219E2E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219E2E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8219E2EC: 4800000C  b 0x8219e2f8
	pc = 0x8219E2F8; continue 'dispatch;
            }
            0x8219E2F0 => {
    //   block [0x8219E2F0..0x8219E2F8)
	// 8219E2F0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8219E2F4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8219E2F8; continue 'dispatch;
            }
            0x8219E2F8 => {
    //   block [0x8219E2F8..0x8219E304)
	// 8219E2F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219E2FC: 4199FFB8  bgt cr6, 0x8219e2b4
	if ctx.cr[6].gt {
	pc = 0x8219E2B4; continue 'dispatch;
	}
	// 8219E300: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8219E304; continue 'dispatch;
            }
            0x8219E304 => {
    //   block [0x8219E304..0x8219E320)
	// 8219E304: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8219E308: 419A0040  beq cr6, 0x8219e348
	if ctx.cr[6].eq {
	pc = 0x8219E348; continue 'dispatch;
	}
	// 8219E30C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E310: 2F0B004C  cmpwi cr6, r11, 0x4c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 76, &mut ctx.xer);
	// 8219E314: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219E318: 41990008  bgt cr6, 0x8219e320
	if ctx.cr[6].gt {
	pc = 0x8219E320; continue 'dispatch;
	}
	// 8219E31C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219E320; continue 'dispatch;
            }
            0x8219E320 => {
    //   block [0x8219E320..0x8219E348)
	// 8219E320: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219E324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E328: 409A0020  bne cr6, 0x8219e348
	if !ctx.cr[6].eq {
	pc = 0x8219E348; continue 'dispatch;
	}
	// 8219E32C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219E330: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219E334: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219E338: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219E33C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8219E340: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219E344: 4800001C  b 0x8219e360
	pc = 0x8219E360; continue 'dispatch;
            }
            0x8219E348 => {
    //   block [0x8219E348..0x8219E35C)
	// 8219E348: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 8219E34C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219E350: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8219E354: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219E358: 48000008  b 0x8219e360
	pc = 0x8219E360; continue 'dispatch;
            }
            0x8219E35C => {
    //   block [0x8219E35C..0x8219E360)
	// 8219E35C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219E360; continue 'dispatch;
            }
            0x8219E360 => {
    //   block [0x8219E360..0x8219E398)
	// 8219E360: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219E364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E368: 419A0030  beq cr6, 0x8219e398
	if ctx.cr[6].eq {
	pc = 0x8219E398; continue 'dispatch;
	}
	// 8219E36C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219E370: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 8219E374: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219E378: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8219E37C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8219E380: 4E800421  bctrl
	ctx.lr = 0x8219E384;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219E384: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219E388: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219E38C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219E390: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219E394: 4E800020  blr
	return;
            }
            0x8219E398 => {
    //   block [0x8219E398..0x8219E3B0)
	// 8219E398: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219E39C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219E3A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219E3A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219E3A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219E3AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219E3B0 size=1532
    let mut pc: u32 = 0x8219E3B0;
    'dispatch: loop {
        match pc {
            0x8219E3B0 => {
    //   block [0x8219E3B0..0x8219E9AC)
	// 8219E3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219E3B4: 48B0B051  bl 0x82ca9404
	ctx.lr = 0x8219E3B8;
	sub_82CA93D0(ctx, base);
	// 8219E3B8: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 8219E3BC: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 8219E3C0: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8219E3C4: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219E9B0 size=20
    let mut pc: u32 = 0x8219E9B0;
    'dispatch: loop {
        match pc {
            0x8219E9B0 => {
    //   block [0x8219E9B0..0x8219E9C4)
	// 8219E9B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E9B4: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 8219E9B8: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8219E9BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219E9C0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E9C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219E9C8 size=120
    let mut pc: u32 = 0x8219E9C8;
    'dispatch: loop {
        match pc {
            0x8219E9C8 => {
    //   block [0x8219E9C8..0x8219EA00)
	// 8219E9C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219E9CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219E9D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219E9D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219E9D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219E9DC: 48000065  bl 0x8219ea40
	ctx.lr = 0x8219E9E0;
	sub_8219EA40(ctx, base);
	// 8219E9E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219E9E4: 419A001C  beq cr6, 0x8219ea00
	if ctx.cr[6].eq {
	pc = 0x8219EA00; continue 'dispatch;
	}
	// 8219E9E8: C0230024  lfs f1, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219E9EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219E9F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219E9F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219E9F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219E9FC: 4E800020  blr
	return;
            }
            0x8219EA00 => {
    //   block [0x8219EA00..0x8219EA20)
	// 8219EA00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219EA04: 4800003D  bl 0x8219ea40
	ctx.lr = 0x8219EA08;
	sub_8219EA40(ctx, base);
	// 8219EA08: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219EA0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219EA10: 396B92D4  addi r11, r11, -0x6d2c
	ctx.r[11].s64 = ctx.r[11].s64 + -27948;
	// 8219EA14: 419A000C  beq cr6, 0x8219ea20
	if ctx.cr[6].eq {
	pc = 0x8219EA20; continue 'dispatch;
	}
	// 8219EA18: C1A30020  lfs f13, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219EA1C: 48000008  b 0x8219ea24
	pc = 0x8219EA24; continue 'dispatch;
            }
            0x8219EA20 => {
    //   block [0x8219EA20..0x8219EA24)
	// 8219EA20: C1AB4E0C  lfs f13, 0x4e0c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19980 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x8219EA24; continue 'dispatch;
            }
            0x8219EA24 => {
    //   block [0x8219EA24..0x8219EA40)
	// 8219EA24: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219EA28: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219EA2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219EA30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219EA34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219EA38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219EA3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219EA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219EA40 size=360
    let mut pc: u32 = 0x8219EA40;
    'dispatch: loop {
        match pc {
            0x8219EA40 => {
    //   block [0x8219EA40..0x8219EA74)
	// 8219EA40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219EA44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219EA48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219EA4C: 480F0B9D  bl 0x8228f5e8
	ctx.lr = 0x8219EA50;
	sub_8228F5E8(ctx, base);
	// 8219EA50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219EA54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219EA58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219EA5C: 419A0018  beq cr6, 0x8219ea74
	if ctx.cr[6].eq {
	pc = 0x8219EA74; continue 'dispatch;
	}
	// 8219EA60: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219EA64: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8219EA68: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219EA6C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219EA70: 409A0008  bne cr6, 0x8219ea78
	if !ctx.cr[6].eq {
	pc = 0x8219EA78; continue 'dispatch;
	}
	pc = 0x8219EA74; continue 'dispatch;
            }
            0x8219EA74 => {
    //   block [0x8219EA74..0x8219EA78)
	// 8219EA74: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	pc = 0x8219EA78; continue 'dispatch;
            }
            0x8219EA78 => {
    //   block [0x8219EA78..0x8219EAC0)
	// 8219EA78: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8219EA7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219EA80: 419A0114  beq cr6, 0x8219eb94
	if ctx.cr[6].eq {
	pc = 0x8219EB94; continue 'dispatch;
	}
	// 8219EA84: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8219EA88: 5549A7FE  rlwinm r9, r10, 0x14, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000FFFu64;
	// 8219EA8C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219EA90: 419A00F4  beq cr6, 0x8219eb84
	if ctx.cr[6].eq {
	pc = 0x8219EB84; continue 'dispatch;
	}
	// 8219EA94: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219EA98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219EA9C: 419A0024  beq cr6, 0x8219eac0
	if ctx.cr[6].eq {
	pc = 0x8219EAC0; continue 'dispatch;
	}
	// 8219EAA0: 894A008C  lbz r10, 0x8c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219EAA4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219EAA8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8219EAAC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219EAB0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219EAB4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8219EAB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219EABC: 480000CC  b 0x8219eb88
	pc = 0x8219EB88; continue 'dispatch;
            }
            0x8219EAC0 => {
    //   block [0x8219EAC0..0x8219EADC)
	// 8219EAC0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219EAC4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8219EAC8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8219EACC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8219EAD0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8219EAD4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219EAD8: 40810054  ble 0x8219eb2c
	if !ctx.cr[0].gt {
	pc = 0x8219EB2C; continue 'dispatch;
	}
	pc = 0x8219EADC; continue 'dispatch;
            }
            0x8219EADC => {
    //   block [0x8219EADC..0x8219EAFC)
	// 8219EADC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8219EAE0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219EAE4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8219EAE8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219EAEC: 2F07008C  cmpwi cr6, r7, 0x8c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 140, &mut ctx.xer);
	// 8219EAF0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8219EAF4: 41980008  blt cr6, 0x8219eafc
	if ctx.cr[6].lt {
	pc = 0x8219EAFC; continue 'dispatch;
	}
	// 8219EAF8: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x8219EAFC; continue 'dispatch;
            }
            0x8219EAFC => {
    //   block [0x8219EAFC..0x8219EB18)
	// 8219EAFC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8219EB00: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219EB04: 419A0014  beq cr6, 0x8219eb18
	if ctx.cr[6].eq {
	pc = 0x8219EB18; continue 'dispatch;
	}
	// 8219EB08: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8219EB0C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219EB10: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8219EB14: 4800000C  b 0x8219eb20
	pc = 0x8219EB20; continue 'dispatch;
            }
            0x8219EB18 => {
    //   block [0x8219EB18..0x8219EB20)
	// 8219EB18: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8219EB1C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8219EB20; continue 'dispatch;
            }
            0x8219EB20 => {
    //   block [0x8219EB20..0x8219EB2C)
	// 8219EB20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219EB24: 4199FFB8  bgt cr6, 0x8219eadc
	if ctx.cr[6].gt {
	pc = 0x8219EADC; continue 'dispatch;
	}
	// 8219EB28: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8219EB2C; continue 'dispatch;
            }
            0x8219EB2C => {
    //   block [0x8219EB2C..0x8219EB48)
	// 8219EB2C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8219EB30: 419A0040  beq cr6, 0x8219eb70
	if ctx.cr[6].eq {
	pc = 0x8219EB70; continue 'dispatch;
	}
	// 8219EB34: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219EB38: 2F0B008C  cmpwi cr6, r11, 0x8c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 140, &mut ctx.xer);
	// 8219EB3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219EB40: 41990008  bgt cr6, 0x8219eb48
	if ctx.cr[6].gt {
	pc = 0x8219EB48; continue 'dispatch;
	}
	// 8219EB44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x8219EB48; continue 'dispatch;
            }
            0x8219EB48 => {
    //   block [0x8219EB48..0x8219EB70)
	// 8219EB48: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219EB4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219EB50: 409A0020  bne cr6, 0x8219eb70
	if !ctx.cr[6].eq {
	pc = 0x8219EB70; continue 'dispatch;
	}
	// 8219EB54: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219EB58: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219EB5C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219EB60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219EB64: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8219EB68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219EB6C: 4800001C  b 0x8219eb88
	pc = 0x8219EB88; continue 'dispatch;
            }
            0x8219EB70 => {
    //   block [0x8219EB70..0x8219EB84)
	// 8219EB70: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8219EB74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219EB78: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8219EB7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219EB80: 48000008  b 0x8219eb88
	pc = 0x8219EB88; continue 'dispatch;
            }
            0x8219EB84 => {
    //   block [0x8219EB84..0x8219EB88)
	// 8219EB84: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x8219EB88; continue 'dispatch;
            }
            0x8219EB88 => {
    //   block [0x8219EB88..0x8219EB94)
	// 8219EB88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219EB8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219EB90: 409A0008  bne cr6, 0x8219eb98
	if !ctx.cr[6].eq {
	pc = 0x8219EB98; continue 'dispatch;
	}
	pc = 0x8219EB94; continue 'dispatch;
            }
            0x8219EB94 => {
    //   block [0x8219EB94..0x8219EB98)
	// 8219EB94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8219EB98; continue 'dispatch;
            }
            0x8219EB98 => {
    //   block [0x8219EB98..0x8219EBA8)
	// 8219EB98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219EB9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219EBA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219EBA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219EBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219EBA8 size=72
    let mut pc: u32 = 0x8219EBA8;
    'dispatch: loop {
        match pc {
            0x8219EBA8 => {
    //   block [0x8219EBA8..0x8219EBF0)
	// 8219EBA8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 8219EBAC: D8210010  stfd f1, 0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(16 as u32), ctx.f[1].u64 ) };
	// 8219EBB0: D8410018  stfd f2, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[2].u64 ) };
	// 8219EBB4: 396BEC28  addi r11, r11, -0x13d8
	ctx.r[11].s64 = ctx.r[11].s64 + -5080;
	// 8219EBB8: C00B00A8  lfs f0, 0xa8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219EBBC: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 8219EBC0: 409A0040  bne cr6, 0x8219ec00
	if !ctx.cr[6].eq {
		sub_8219EBF8(ctx, base);
		return;
	}
	// 8219EBC4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8219EBC8: 409A0030  bne cr6, 0x8219ebf8
	if !ctx.cr[6].eq {
		sub_8219EBF8(ctx, base);
		return;
	}
	// 8219EBCC: 81410018  lwz r10, 0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) } as u64;
	// 8219EBD0: 554A0001  rlwinm. r10, r10, 0, 0, 0
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219EBD4: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 8219EBD8: 81410010  lwz r10, 0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219EBDC: 554A0001  rlwinm. r10, r10, 0, 0, 0
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219EBE0: 41820010  beq 0x8219ebf0
	if ctx.cr[0].eq {
		sub_8219EBF0(ctx, base);
		return;
	}
	// 8219EBE4: C80B0010  lfd f0, 0x10(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 8219EBE8: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219EBEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219EBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219EBF0 size=8
    let mut pc: u32 = 0x8219EBF0;
    'dispatch: loop {
        match pc {
            0x8219EBF0 => {
    //   block [0x8219EBF0..0x8219EBF8)
	// 8219EBF0: C82B0010  lfd f1, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 8219EBF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219EBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219EBF8 size=224
    let mut pc: u32 = 0x8219EBF8;
    'dispatch: loop {
        match pc {
            0x8219EBF8 => {
    //   block [0x8219EBF8..0x8219EC24)
	// 8219EBF8: C80B0008  lfd f0, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8219EBFC: 480000BC  b 0x8219ecb8
	pc = 0x8219ECB8; continue 'dispatch;
	// 8219EC00: FDA01210  fabs f13, f2
	ctx.f[13].u64 = ctx.f[2].u64 & !0x8000_0000_0000_0000u64;
	// 8219EC04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219EC08: FC000A10  fabs f0, f1
	ctx.f[0].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 8219EC0C: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 8219EC10: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8219EC14: 40990010  ble cr6, 0x8219ec24
	if !ctx.cr[6].gt {
	pc = 0x8219EC24; continue 'dispatch;
	}
	// 8219EC18: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 8219EC1C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 8219EC20: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
            }
            0x8219EC24 => {
    //   block [0x8219EC24..0x8219EC4C)
	// 8219EC24: FC006024  fdiv f0, f0, f12
	ctx.f[0].f64 = ctx.f[0].f64 / ctx.f[12].f64;
	// 8219EC28: C9AB0018  lfd f13, 0x18(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 8219EC2C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8219EC30: 4099001C  ble cr6, 0x8219ec4c
	if !ctx.cr[6].gt {
	pc = 0x8219EC4C; continue 'dispatch;
	}
	// 8219EC34: C9AB0028  lfd f13, 0x28(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	// 8219EC38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219EC3C: C18B00B0  lfs f12, 0xb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219EC40: FD6D002A  fadd f11, f13, f0
	ctx.f[11].f64 = ctx.f[13].f64 + ctx.f[0].f64;
	// 8219EC44: FC0D6038  fmsub f0, f13, f0, f12
	ctx.f[0].f64 = ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[12].f64;
	// 8219EC48: FC005824  fdiv f0, f0, f11
	ctx.f[0].f64 = ctx.f[0].f64 / ctx.f[11].f64;
	pc = 0x8219EC4C; continue 'dispatch;
            }
            0x8219EC4C => {
    //   block [0x8219EC4C..0x8219ECA8)
	// 8219EC4C: FCA00032  fmul f5, f0, f0
	ctx.f[5].f64 = ctx.f[0].f64 * ctx.f[0].f64;
	// 8219EC50: C98B0048  lfd f12, 0x48(r11)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) };
	// 8219EC54: C9AB0050  lfd f13, 0x50(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	// 8219EC58: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 8219EC5C: C96B0070  lfd f11, 0x70(r11)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) };
	// 8219EC60: C94B0040  lfd f10, 0x40(r11)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	// 8219EC64: C92B0068  lfd f9, 0x68(r11)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) };
	// 8219EC68: C90B0038  lfd f8, 0x38(r11)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	// 8219EC6C: C8EB0060  lfd f7, 0x60(r11)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	// 8219EC70: C8CB0058  lfd f6, 0x58(r11)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	// 8219EC74: FDAD617A  fmadd f13, f13, f5, f12
	ctx.f[13].f64 = ctx.f[13].f64 * ctx.f[5].f64 + ctx.f[12].f64;
	// 8219EC78: FD8B282A  fadd f12, f11, f5
	ctx.f[12].f64 = ctx.f[11].f64 + ctx.f[5].f64;
	// 8219EC7C: FDAD517A  fmadd f13, f13, f5, f10
	ctx.f[13].f64 = ctx.f[13].f64 * ctx.f[5].f64 + ctx.f[10].f64;
	// 8219EC80: FD8C497A  fmadd f12, f12, f5, f9
	ctx.f[12].f64 = ctx.f[12].f64 * ctx.f[5].f64 + ctx.f[9].f64;
	// 8219EC84: FDAD417A  fmadd f13, f13, f5, f8
	ctx.f[13].f64 = ctx.f[13].f64 * ctx.f[5].f64 + ctx.f[8].f64;
	// 8219EC88: FD8C397A  fmadd f12, f12, f5, f7
	ctx.f[12].f64 = ctx.f[12].f64 * ctx.f[5].f64 + ctx.f[7].f64;
	// 8219EC8C: FDAD0172  fmul f13, f13, f5
	ctx.f[13].f64 = ctx.f[13].f64 * ctx.f[5].f64;
	// 8219EC90: FD8C317A  fmadd f12, f12, f5, f6
	ctx.f[12].f64 = ctx.f[12].f64 * ctx.f[5].f64 + ctx.f[6].f64;
	// 8219EC94: FDAD0032  fmul f13, f13, f0
	ctx.f[13].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 8219EC98: FDAD6024  fdiv f13, f13, f12
	ctx.f[13].f64 = ctx.f[13].f64 / ctx.f[12].f64;
	// 8219EC9C: FC0D002A  fadd f0, f13, f0
	ctx.f[0].f64 = ctx.f[13].f64 + ctx.f[0].f64;
	// 8219ECA0: 40990008  ble cr6, 0x8219eca8
	if !ctx.cr[6].gt {
	pc = 0x8219ECA8; continue 'dispatch;
	}
	// 8219ECA4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x8219ECA8; continue 'dispatch;
            }
            0x8219ECA8 => {
    //   block [0x8219ECA8..0x8219ECB8)
	// 8219ECA8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219ECAC: 392B0080  addi r9, r11, 0x80
	ctx.r[9].s64 = ctx.r[11].s64 + 128;
	// 8219ECB0: 7DAA4CAE  lfdx f13, r10, r9
	ctx.f[13].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	// 8219ECB4: FC0D002A  fadd f0, f13, f0
	ctx.f[0].f64 = ctx.f[13].f64 + ctx.f[0].f64;
	pc = 0x8219ECB8; continue 'dispatch;
            }
            0x8219ECB8 => {
    //   block [0x8219ECB8..0x8219ECD8)
	// 8219ECB8: C9AB0010  lfd f13, 0x10(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 8219ECBC: 81610010  lwz r11, 0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219ECC0: FDAD0028  fsub f13, f13, f0
	ctx.f[13].f64 = ctx.f[13].f64 - ctx.f[0].f64;
	// 8219ECC4: 556B0001  rlwinm. r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219ECC8: FC22682E  fsel f1, f2, f0, f13
	ctx.f[1].f64 = if ctx.f[2].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 8219ECCC: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 8219ECD0: FC200850  fneg f1, f1
	ctx.f[1].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219ECD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219ECD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219ECD8 size=72
    let mut pc: u32 = 0x8219ECD8;
    'dispatch: loop {
        match pc {
            0x8219ECD8 => {
    //   block [0x8219ECD8..0x8219ED20)
	// 8219ECD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219ECDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219ECE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219ECE4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219ED20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219ED20 size=56
    let mut pc: u32 = 0x8219ED20;
    'dispatch: loop {
        match pc {
            0x8219ED20 => {
    //   block [0x8219ED20..0x8219ED58)
	// 8219ED20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219ED24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219ED28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219ED2C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8219ED30: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8219ED34: 38AB0128  addi r5, r11, 0x128
	ctx.r[5].s64 = ctx.r[11].s64 + 296;
	// 8219ED38: 388A0D18  addi r4, r10, 0xd18
	ctx.r[4].s64 = ctx.r[10].s64 + 3352;
	// 8219ED3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219ED40: 48A2EA71  bl 0x82bcd7b0
	ctx.lr = 0x8219ED44;
	sub_82BCD7B0(ctx, base);
	// 8219ED44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219ED48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219ED4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219ED50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219ED54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219ED58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219ED58 size=188
    let mut pc: u32 = 0x8219ED58;
    'dispatch: loop {
        match pc {
            0x8219ED58 => {
    //   block [0x8219ED58..0x8219EDA4)
	// 8219ED58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219ED5C: 48B0A6B1  bl 0x82ca940c
	ctx.lr = 0x8219ED60;
	sub_82CA93D0(ctx, base);
	// 8219ED60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219ED64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219ED68: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8219ED6C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8219ED70: A17F0034  lhz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 8219ED74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8219ED78: 556A043E  clrlwi r10, r11, 0x10
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 8219ED7C: B15F0034  sth r10, 0x34(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u16 ) };
	// 8219ED80: 2B0A00C8  cmplwi cr6, r10, 0xc8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 200 as u32, &mut ctx.xer);
	// 8219ED84: 41980038  blt cr6, 0x8219edbc
	if ctx.cr[6].lt {
	pc = 0x8219EDBC; continue 'dispatch;
	}
	// 8219ED88: 554B043E  clrlwi r11, r10, 0x10
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 8219ED8C: 2B0B00C8  cmplwi cr6, r11, 0xc8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 200 as u32, &mut ctx.xer);
	// 8219ED90: 409A0014  bne cr6, 0x8219eda4
	if !ctx.cr[6].eq {
	pc = 0x8219EDA4; continue 'dispatch;
	}
	// 8219ED94: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8219ED98: 388B3B08  addi r4, r11, 0x3b08
	ctx.r[4].s64 = ctx.r[11].s64 + 15112;
	// 8219ED9C: 48A31475  bl 0x82bd0210
	ctx.lr = 0x8219EDA0;
	sub_82BD0210(ctx, base);
	// 8219EDA0: 4800001C  b 0x8219edbc
	pc = 0x8219EDBC; continue 'dispatch;
            }
            0x8219EDA4 => {
    //   block [0x8219EDA4..0x8219EDBC)
	// 8219EDA4: A17F0034  lhz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 8219EDA8: 2B0B00E1  cmplwi cr6, r11, 0xe1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 225 as u32, &mut ctx.xer);
	// 8219EDAC: 41980010  blt cr6, 0x8219edbc
	if ctx.cr[6].lt {
	pc = 0x8219EDBC; continue 'dispatch;
	}
	// 8219EDB0: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8219EDB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219EDB8: 48A345F1  bl 0x82bd33a8
	ctx.lr = 0x8219EDBC;
	sub_82BD33A8(ctx, base);
	pc = 0x8219EDBC; continue 'dispatch;
            }
            0x8219EDBC => {
    //   block [0x8219EDBC..0x8219EDE0)
	// 8219EDBC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8219EDC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219EDC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219EDC8: 480001A1  bl 0x8219ef68
	ctx.lr = 0x8219EDCC;
	sub_8219EF68(ctx, base);
	// 8219EDCC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8219EDD0: 409A0010  bne cr6, 0x8219ede0
	if !ctx.cr[6].eq {
	pc = 0x8219EDE0; continue 'dispatch;
	}
	// 8219EDD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8219EDD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219EDDC: 4813FDA5  bl 0x822deb80
	ctx.lr = 0x8219EDE0;
	sub_822DEB80(ctx, base);
	pc = 0x8219EDE0; continue 'dispatch;
            }
            0x8219EDE0 => {
    //   block [0x8219EDE0..0x8219EE0C)
	// 8219EDE0: A17F0034  lhz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 8219EDE4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219EDE8: 3D2B0001  addis r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 65536;
	// 8219EDEC: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 8219EDF0: B13F0034  sth r9, 0x34(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[9].u16 ) };
	// 8219EDF4: 80EA0044  lwz r7, 0x44(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 8219EDF8: 80CA0040  lwz r6, 0x40(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8219EDFC: 7F073040  cmplw cr6, r7, r6
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8219EE00: 4198000C  blt cr6, 0x8219ee0c
	if ctx.cr[6].lt {
	pc = 0x8219EE0C; continue 'dispatch;
	}
	// 8219EE04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219EE08: 480DCC39  bl 0x8227ba40
	ctx.lr = 0x8219EE0C;
	sub_8227BA40(ctx, base);
	pc = 0x8219EE0C; continue 'dispatch;
            }
            0x8219EE0C => {
    //   block [0x8219EE0C..0x8219EE14)
	// 8219EE0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219EE10: 48B0A64C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219EE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219EE18 size=332
    let mut pc: u32 = 0x8219EE18;
    'dispatch: loop {
        match pc {
            0x8219EE18 => {
    //   block [0x8219EE18..0x8219EE7C)
	// 8219EE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219EE1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219EE20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219EE24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219EE28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219EE2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219EE30: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 8219EE34: 897F0036  lbz r11, 0x36(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(54 as u32) ) } as u64;
	// 8219EE38: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219EE3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219EE40: 419A0084  beq cr6, 0x8219eec4
	if ctx.cr[6].eq {
	pc = 0x8219EEC4; continue 'dispatch;
	}
	// 8219EE44: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219EE48: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8219EE4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8219EE50: 7FCB4050  subf r30, r11, r8
	ctx.r[30].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 8219EE54: 48A348D5  bl 0x82bd3728
	ctx.lr = 0x8219EE58;
	sub_82BD3728(ctx, base);
	// 8219EE58: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219EE5C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219EE60: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219EE64: 89090006  lbz r8, 6(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(6 as u32) ) } as u64;
	// 8219EE68: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8219EE6C: 409A0050  bne cr6, 0x8219eebc
	if !ctx.cr[6].eq {
	pc = 0x8219EEBC; continue 'dispatch;
	}
	// 8219EE70: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219EE74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219EE78: 419A0034  beq cr6, 0x8219eeac
	if ctx.cr[6].eq {
	pc = 0x8219EEAC; continue 'dispatch;
	}
	pc = 0x8219EE7C; continue 'dispatch;
            }
            0x8219EE7C => {
    //   block [0x8219EE7C..0x8219EEAC)
	// 8219EE7C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219EE80: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8219EE84: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8219EE88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219EE8C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219EE90: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8219EE94: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 8219EE98: 48A34891  bl 0x82bd3728
	ctx.lr = 0x8219EE9C;
	sub_82BD3728(ctx, base);
	// 8219EE9C: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219EEA0: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219EEA4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8219EEA8: 409AFFD4  bne cr6, 0x8219ee7c
	if !ctx.cr[6].eq {
	pc = 0x8219EE7C; continue 'dispatch;
	}
	pc = 0x8219EEAC; continue 'dispatch;
            }
            0x8219EEAC => {
    //   block [0x8219EEAC..0x8219EEBC)
	// 8219EEAC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219EEB0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219EEB4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8219EEB8: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	pc = 0x8219EEBC; continue 'dispatch;
            }
            0x8219EEBC => {
    //   block [0x8219EEBC..0x8219EEC4)
	// 8219EEBC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219EEC0: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	pc = 0x8219EEC4; continue 'dispatch;
            }
            0x8219EEC4 => {
    //   block [0x8219EEC4..0x8219EEF4)
	// 8219EEC4: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219EEC8: 3969FFE8  addi r11, r9, -0x18
	ctx.r[11].s64 = ctx.r[9].s64 + -24;
	// 8219EECC: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 8219EED0: 80E90010  lwz r7, 0x10(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219EED4: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 8219EED8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219EEDC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 8219EEE0: 80C9FFE8  lwz r6, -0x18(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24 as u32) ) } as u64;
	// 8219EEE4: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 8219EEE8: 80A9FFF4  lwz r5, -0xc(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) } as u64;
	// 8219EEEC: 90BF0018  stw r5, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[5].u32 ) };
	// 8219EEF0: 419A0038  beq cr6, 0x8219ef28
	if ctx.cr[6].eq {
	pc = 0x8219EF28; continue 'dispatch;
	}
	pc = 0x8219EEF4; continue 'dispatch;
            }
            0x8219EEF4 => {
    //   block [0x8219EEF4..0x8219EF28)
	// 8219EEF4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219EEF8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219EEFC: 4098002C  bge cr6, 0x8219ef28
	if !ctx.cr[6].lt {
	pc = 0x8219EF28; continue 'dispatch;
	}
	// 8219EF00: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 8219EF04: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 8219EF08: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219EF0C: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 8219EF10: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8219EF14: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219EF18: 90A60000  stw r5, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 8219EF1C: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219EF20: 90860004  stw r4, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 8219EF24: 4082FFD0  bne 0x8219eef4
	if !ctx.cr[0].eq {
	pc = 0x8219EEF4; continue 'dispatch;
	}
	pc = 0x8219EF28; continue 'dispatch;
            }
            0x8219EF28 => {
    //   block [0x8219EF28..0x8219EF34)
	// 8219EF28: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219EF2C: 40990018  ble cr6, 0x8219ef44
	if !ctx.cr[6].gt {
	pc = 0x8219EF44; continue 'dispatch;
	}
	// 8219EF30: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x8219EF34; continue 'dispatch;
            }
            0x8219EF34 => {
    //   block [0x8219EF34..0x8219EF44)
	// 8219EF34: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8219EF38: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219EF3C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8219EF40: 4181FFF4  bgt 0x8219ef34
	if ctx.cr[0].gt {
	pc = 0x8219EF34; continue 'dispatch;
	}
	pc = 0x8219EF44; continue 'dispatch;
            }
            0x8219EF44 => {
    //   block [0x8219EF44..0x8219EF64)
	// 8219EF44: 38670001  addi r3, r7, 1
	ctx.r[3].s64 = ctx.r[7].s64 + 1;
	// 8219EF48: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8219EF4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219EF50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219EF54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219EF58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219EF5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219EF60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219EF68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219EF68 size=660
    let mut pc: u32 = 0x8219EF68;
    'dispatch: loop {
        match pc {
            0x8219EF68 => {
    //   block [0x8219EF68..0x8219EF90)
	// 8219EF68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219EF6C: 48B0A495  bl 0x82ca9400
	ctx.lr = 0x8219EF70;
	sub_82CA93D0(ctx, base);
	// 8219EF70: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219EF74: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219EF78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219EF7C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8219EF80: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 8219EF84: 419A000C  beq cr6, 0x8219ef90
	if ctx.cr[6].eq {
	pc = 0x8219EF90; continue 'dispatch;
	}
	// 8219EF88: 48A34A81  bl 0x82bd3a08
	ctx.lr = 0x8219EF8C;
	sub_82BD3A08(ctx, base);
	// 8219EF8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	pc = 0x8219EF90; continue 'dispatch;
            }
            0x8219EF90 => {
    //   block [0x8219EF90..0x8219EFEC)
	// 8219EF90: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8219EF94: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219EF98: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219EF9C: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219EFA0: 7F682050  subf r27, r8, r4
	ctx.r[27].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 8219EFA4: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8219EFA8: 88EB0006  lbz r7, 6(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 8219EFAC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219EFB0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219EFB4: 409A0160  bne cr6, 0x8219f114
	if !ctx.cr[6].eq {
	pc = 0x8219F114; continue 'dispatch;
	}
	// 8219EFB8: 83AB0010  lwz r29, 0x10(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219EFBC: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219EFC0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8219EFC4: 897D004B  lbz r11, 0x4b(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(75 as u32) ) } as u64;
	// 8219EFC8: 5568183E  rotlwi r8, r11, 3
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8219EFCC: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 8219EFD0: 41990020  bgt cr6, 0x8219eff0
	if ctx.cr[6].gt {
	pc = 0x8219EFF0; continue 'dispatch;
	}
	// 8219EFD4: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 8219EFD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219EFDC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8219EFE0: 5544083C  slwi r4, r10, 1
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8219EFE4: 40990008  ble cr6, 0x8219efec
	if !ctx.cr[6].gt {
	pc = 0x8219EFEC; continue 'dispatch;
	}
	// 8219EFE8: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x8219EFEC; continue 'dispatch;
            }
            0x8219EFEC => {
    //   block [0x8219EFEC..0x8219EFF0)
	// 8219EFEC: 48A3458D  bl 0x82bd3578
	ctx.lr = 0x8219EFF0;
	sub_82BD3578(ctx, base);
	pc = 0x8219EFF0; continue 'dispatch;
            }
            0x8219EFF0 => {
    //   block [0x8219EFF0..0x8219F028)
	// 8219EFF0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219EFF4: 895D004A  lbz r10, 0x4a(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(74 as u32) ) } as u64;
	// 8219EFF8: 7F9B5A14  add r28, r27, r11
	ctx.r[28].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 8219EFFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219F000: 409A0028  bne cr6, 0x8219f028
	if !ctx.cr[6].eq {
	pc = 0x8219F028; continue 'dispatch;
	}
	// 8219F004: 897D0049  lbz r11, 0x49(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(73 as u32) ) } as u64;
	// 8219F008: 3BDC0008  addi r30, r28, 8
	ctx.r[30].s64 = ctx.r[28].s64 + 8;
	// 8219F00C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F010: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8219F014: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 8219F018: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219F01C: 40990034  ble cr6, 0x8219f050
	if !ctx.cr[6].gt {
	pc = 0x8219F050; continue 'dispatch;
	}
	// 8219F020: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8219F024: 4800002C  b 0x8219f050
	pc = 0x8219F050; continue 'dispatch;
            }
            0x8219F028 => {
    //   block [0x8219F028..0x8219F050)
	// 8219F028: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F02C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8219F030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F034: 7D5C5850  subf r10, r28, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 8219F038: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 8219F03C: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 8219F040: 48A347D9  bl 0x82bd3818
	ctx.lr = 0x8219F044;
	sub_82BD3818(ctx, base);
	// 8219F044: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219F048: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219F04C: 7F9B5A14  add r28, r27, r11
	ctx.r[28].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	pc = 0x8219F050; continue 'dispatch;
            }
            0x8219F050 => {
    //   block [0x8219F050..0x8219F06C)
	// 8219F050: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219F054: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8219F058: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219F05C: 409A0010  bne cr6, 0x8219f06c
	if !ctx.cr[6].eq {
	pc = 0x8219F06C; continue 'dispatch;
	}
	// 8219F060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F064: 48A34655  bl 0x82bd36b8
	ctx.lr = 0x8219F068;
	sub_82BD36B8(ctx, base);
	// 8219F068: 4800000C  b 0x8219f074
	pc = 0x8219F074; continue 'dispatch;
            }
            0x8219F06C => {
    //   block [0x8219F06C..0x8219F074)
	// 8219F06C: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 8219F070: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	pc = 0x8219F074; continue 'dispatch;
            }
            0x8219F074 => {
    //   block [0x8219F074..0x8219F0B4)
	// 8219F074: 93830004  stw r28, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 8219F078: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219F07C: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8219F080: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 8219F084: 897D004B  lbz r11, 0x4b(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(75 as u32) ) } as u64;
	// 8219F088: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8219F08C: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 8219F090: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8219F094: 811D000C  lwz r8, 0xc(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219F098: 911F0018  stw r8, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 8219F09C: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 8219F0A0: 93430010  stw r26, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 8219F0A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F0A8: 80E30008  lwz r7, 8(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F0AC: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 8219F0B0: 40980018  bge cr6, 0x8219f0c8
	if !ctx.cr[6].lt {
	pc = 0x8219F0C8; continue 'dispatch;
	}
	pc = 0x8219F0B4; continue 'dispatch;
            }
            0x8219F0B4 => {
    //   block [0x8219F0B4..0x8219F0C8)
	// 8219F0B4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8219F0B8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8219F0BC: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F0C0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219F0C4: 4198FFF0  blt cr6, 0x8219f0b4
	if ctx.cr[6].lt {
	pc = 0x8219F0B4; continue 'dispatch;
	}
	pc = 0x8219F0C8; continue 'dispatch;
            }
            0x8219F0C8 => {
    //   block [0x8219F0C8..0x8219F108)
	// 8219F0C8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F0CC: 895F0036  lbz r10, 0x36(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(54 as u32) ) } as u64;
	// 8219F0D0: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8219F0D4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8219F0D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219F0DC: 419A002C  beq cr6, 0x8219f108
	if ctx.cr[6].eq {
	pc = 0x8219F108; continue 'dispatch;
	}
	// 8219F0E0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8219F0E4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8219F0E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219F0EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8219F0F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F0F4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8219F0F8: 48A34631  bl 0x82bd3728
	ctx.lr = 0x8219F0FC;
	sub_82BD3728(ctx, base);
	// 8219F0FC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8219F100: 394BFFFC  addi r10, r11, -4
	ctx.r[10].s64 = ctx.r[11].s64 + -4;
	// 8219F104: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	pc = 0x8219F108; continue 'dispatch;
            }
            0x8219F108 => {
    //   block [0x8219F108..0x8219F114)
	// 8219F108: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219F10C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219F110: 48B0A340  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x8219F114 => {
    //   block [0x8219F114..0x8219F13C)
	// 8219F114: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219F118: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8219F11C: 2F0900A0  cmpwi cr6, r9, 0xa0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 160, &mut ctx.xer);
	// 8219F120: 41990020  bgt cr6, 0x8219f140
	if ctx.cr[6].gt {
	pc = 0x8219F140; continue 'dispatch;
	}
	// 8219F124: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 8219F128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F12C: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 8219F130: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8219F134: 40980008  bge cr6, 0x8219f13c
	if !ctx.cr[6].lt {
	pc = 0x8219F13C; continue 'dispatch;
	}
	// 8219F138: 388B0014  addi r4, r11, 0x14
	ctx.r[4].s64 = ctx.r[11].s64 + 20;
	pc = 0x8219F13C; continue 'dispatch;
            }
            0x8219F13C => {
    //   block [0x8219F13C..0x8219F140)
	// 8219F13C: 48A3443D  bl 0x82bd3578
	ctx.lr = 0x8219F140;
	sub_82BD3578(ctx, base);
	pc = 0x8219F140; continue 'dispatch;
            }
            0x8219F140 => {
    //   block [0x8219F140..0x8219F15C)
	// 8219F140: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219F144: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8219F148: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219F14C: 409A0010  bne cr6, 0x8219f15c
	if !ctx.cr[6].eq {
	pc = 0x8219F15C; continue 'dispatch;
	}
	// 8219F150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F154: 48A34565  bl 0x82bd36b8
	ctx.lr = 0x8219F158;
	sub_82BD36B8(ctx, base);
	// 8219F158: 4800000C  b 0x8219f164
	pc = 0x8219F164; continue 'dispatch;
            }
            0x8219F15C => {
    //   block [0x8219F15C..0x8219F164)
	// 8219F15C: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 8219F160: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	pc = 0x8219F164; continue 'dispatch;
            }
            0x8219F164 => {
    //   block [0x8219F164..0x8219F1AC)
	// 8219F164: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219F168: 7D7B5A14  add r11, r27, r11
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 8219F16C: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8219F170: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8219F174: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219F178: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8219F17C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F180: 396B00A0  addi r11, r11, 0xa0
	ctx.r[11].s64 = ctx.r[11].s64 + 160;
	// 8219F184: 93430010  stw r26, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 8219F188: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8219F18C: 895F0036  lbz r10, 0x36(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(54 as u32) ) } as u64;
	// 8219F190: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8219F194: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219F198: 419A0014  beq cr6, 0x8219f1ac
	if ctx.cr[6].eq {
	pc = 0x8219F1AC; continue 'dispatch;
	}
	// 8219F19C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8219F1A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219F1A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F1A8: 48A34581  bl 0x82bd3728
	ctx.lr = 0x8219F1AC;
	sub_82BD3728(ctx, base);
	pc = 0x8219F1AC; continue 'dispatch;
            }
            0x8219F1AC => {
    //   block [0x8219F1AC..0x8219F1DC)
	// 8219F1AC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219F1B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F1B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F1B8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F1BC: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219F1C0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8219F1C4: 4E800421  bctrl
	ctx.lr = 0x8219F1C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219F1C8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8219F1CC: 40980010  bge cr6, 0x8219f1dc
	if !ctx.cr[6].lt {
	pc = 0x8219F1DC; continue 'dispatch;
	}
	// 8219F1D0: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 8219F1D4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219F1D8: 48B0A278  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x8219F1DC => {
    //   block [0x8219F1DC..0x8219F1FC)
	// 8219F1DC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F1E0: 546A1838  slwi r10, r3, 3
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219F1E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F1E8: 7C8A5850  subf r4, r10, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8219F1EC: 4BFFFC2D  bl 0x8219ee18
	ctx.lr = 0x8219F1F0;
	sub_8219EE18(ctx, base);
	// 8219F1F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219F1F4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219F1F8: 48B0A258  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219F200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219F200 size=224
    let mut pc: u32 = 0x8219F200;
    'dispatch: loop {
        match pc {
            0x8219F200 => {
    //   block [0x8219F200..0x8219F2E0)
	// 8219F200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219F204: 48B0A209  bl 0x82ca940c
	ctx.lr = 0x8219F208;
	sub_82CA93D0(ctx, base);
	// 8219F208: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219F20C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219F210: 48A19391  bl 0x82bb85a0
	ctx.lr = 0x8219F214;
	sub_82BB85A0(ctx, base);
	// 8219F214: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219F218: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F21C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8219F220: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219F224: 4E800421  bctrl
	ctx.lr = 0x8219F228;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219F228: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F22C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8219F230: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219F234: 81090054  lwz r8, 0x54(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219F238: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8219F23C: 4E800421  bctrl
	ctx.lr = 0x8219F240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219F240: 80FD0000  lwz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F244: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8219F248: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219F24C: 80A70034  lwz r5, 0x34(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(52 as u32) ) } as u64;
	// 8219F250: 83C60000  lwz r30, 0(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F254: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 8219F258: 4E800421  bctrl
	ctx.lr = 0x8219F25C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219F25C: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F260: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219F264: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219F268: 4E800421  bctrl
	ctx.lr = 0x8219F26C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219F26C: 7C6A07B4  extsw r10, r3
	ctx.r[10].s64 = ctx.r[3].s32 as i64;
	// 8219F270: 7FC907B4  extsw r9, r30
	ctx.r[9].s64 = ctx.r[30].s32 as i64;
	// 8219F274: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F278: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 8219F27C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219F280: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 8219F284: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219F288: FD60069C  fcfid f11, f0
	ctx.f[11].f64 = (ctx.f[0].s64 as f64);
	// 8219F28C: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 8219F290: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 8219F294: C00794CC  lfs f0, -0x6b34(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27444 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219F298: FD205818  frsp f9, f11
	ctx.f[9].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8219F29C: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 8219F2A0: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 8219F2A4: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8219F2A8: FD406018  frsp f10, f12
	ctx.f[10].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8219F2AC: ECE90032  fmuls f7, f9, f0
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219F2B0: ED0A0032  fmuls f8, f10, f0
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219F2B4: D1080000  stfs f8, 0(r8)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219F2B8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F2BC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8219F2C0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8219F2C4: D0EB0000  stfs f7, 0(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219F2C8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8219F2CC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F2D0: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 8219F2D4: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 8219F2D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8219F2DC: 48B0A180  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219F2E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219F2E0 size=632
    let mut pc: u32 = 0x8219F2E0;
    'dispatch: loop {
        match pc {
            0x8219F2E0 => {
    //   block [0x8219F2E0..0x8219F358)
	// 8219F2E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219F2E4: 48B0A115  bl 0x82ca93f8
	ctx.lr = 0x8219F2E8;
	sub_82CA93D0(ctx, base);
	// 8219F2E8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219F2EC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8219F2F0: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 8219F2F4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 8219F2F8: 6169FFFE  ori r9, r11, 0xfffe
	ctx.r[9].u64 = ctx.r[11].u64 | 65534;
	// 8219F2FC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8219F300: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F304: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 8219F308: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 8219F30C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219F310: 41980048  blt cr6, 0x8219f358
	if ctx.cr[6].lt {
	pc = 0x8219F358; continue 'dispatch;
	}
	// 8219F314: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219F318: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219F31C: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 8219F320: 48152C21  bl 0x822f1f40
	ctx.lr = 0x8219F324;
	sub_822F1F40(ctx, base);
	// 8219F324: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8219F328: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219F32C: 48152A85  bl 0x822f1db0
	ctx.lr = 0x8219F330;
	sub_822F1DB0(ctx, base);
	// 8219F330: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8219F334: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219F338: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 8219F33C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 8219F340: 48152AE1  bl 0x822f1e20
	ctx.lr = 0x8219F344;
	sub_822F1E20(ctx, base);
	// 8219F344: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 8219F348: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219F34C: 484DC495  bl 0x8267b7e0
	ctx.lr = 0x8219F350;
	sub_8267B7E0(ctx, base);
	// 8219F350: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219F354: 4BFD24BD  bl 0x82171810
	ctx.lr = 0x8219F358;
	sub_82171810(ctx, base);
	pc = 0x8219F358; continue 'dispatch;
            }
            0x8219F358 => {
    //   block [0x8219F358..0x8219F3A0)
	// 8219F358: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 8219F35C: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F360: 4807FEF9  bl 0x8221f258
	ctx.lr = 0x8219F364;
	sub_8221F258(ctx, base);
	// 8219F364: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8219F368: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 8219F36C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8219F370: 419A0030  beq cr6, 0x8219f3a0
	if ctx.cr[6].eq {
	pc = 0x8219F3A0; continue 'dispatch;
	}
	// 8219F374: 397B000C  addi r11, r27, 0xc
	ctx.r[11].s64 = ctx.r[27].s64 + 12;
	// 8219F378: 93DB0000  stw r30, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8219F37C: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8219F380: 389C0004  addi r4, r28, 4
	ctx.r[4].s64 = ctx.r[28].s64 + 4;
	// 8219F384: 93DB0008  stw r30, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 8219F388: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 8219F38C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F390: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8219F394: 483C4C05  bl 0x82563f98
	ctx.lr = 0x8219F398;
	sub_82563F98(ctx, base);
	// 8219F398: 9B3B001C  stb r25, 0x1c(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 8219F39C: 9B3B001D  stb r25, 0x1d(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(29 as u32), ctx.r[25].u8 ) };
	pc = 0x8219F3A0; continue 'dispatch;
            }
            0x8219F3A0 => {
    //   block [0x8219F3A0..0x8219F3D0)
	// 8219F3A0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F3A4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F3A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219F3AC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219F3B0: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8219F3B4: 409A001C  bne cr6, 0x8219f3d0
	if !ctx.cr[6].eq {
	pc = 0x8219F3D0; continue 'dispatch;
	}
	// 8219F3B8: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 8219F3BC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F3C0: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 8219F3C4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F3C8: 936A0008  stw r27, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 8219F3CC: 48000044  b 0x8219f410
	pc = 0x8219F410; continue 'dispatch;
            }
            0x8219F3D0 => {
    //   block [0x8219F3D0..0x8219F3F8)
	// 8219F3D0: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 8219F3D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F3D8: 419A0020  beq cr6, 0x8219f3f8
	if ctx.cr[6].eq {
	pc = 0x8219F3F8; continue 'dispatch;
	}
	// 8219F3DC: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 8219F3E0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F3E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F3E8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219F3EC: 409A0024  bne cr6, 0x8219f410
	if !ctx.cr[6].eq {
	pc = 0x8219F410; continue 'dispatch;
	}
	// 8219F3F0: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 8219F3F4: 4800001C  b 0x8219f410
	pc = 0x8219F410; continue 'dispatch;
            }
            0x8219F3F8 => {
    //   block [0x8219F3F8..0x8219F410)
	// 8219F3F8: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 8219F3FC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F400: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F404: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219F408: 409A0008  bne cr6, 0x8219f410
	if !ctx.cr[6].eq {
	pc = 0x8219F410; continue 'dispatch;
	}
	// 8219F40C: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x8219F410; continue 'dispatch;
            }
            0x8219F410 => {
    //   block [0x8219F410..0x8219F42C)
	// 8219F410: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F414: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 8219F418: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 8219F41C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8219F420: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219F424: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219F428: 409A0110  bne cr6, 0x8219f538
	if !ctx.cr[6].eq {
	pc = 0x8219F538; continue 'dispatch;
	}
	pc = 0x8219F42C; continue 'dispatch;
            }
            0x8219F42C => {
    //   block [0x8219F42C..0x8219F474)
	// 8219F42C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F430: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F434: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F438: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219F43C: 409A0078  bne cr6, 0x8219f4b4
	if !ctx.cr[6].eq {
	pc = 0x8219F4B4; continue 'dispatch;
	}
	// 8219F440: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F444: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219F448: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219F44C: 409A0028  bne cr6, 0x8219f474
	if !ctx.cr[6].eq {
	pc = 0x8219F474; continue 'dispatch;
	}
	// 8219F450: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8219F454: 9BC9001C  stb r30, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 8219F458: 9BCA001C  stb r30, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 8219F45C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F460: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F464: 9B27001C  stb r25, 0x1c(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 8219F468: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F46C: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F470: 480000B4  b 0x8219f524
	pc = 0x8219F524; continue 'dispatch;
            }
            0x8219F474 => {
    //   block [0x8219F474..0x8219F48C)
	// 8219F474: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F478: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219F47C: 409A0010  bne cr6, 0x8219f48c
	if !ctx.cr[6].eq {
	pc = 0x8219F48C; continue 'dispatch;
	}
	// 8219F480: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219F484: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8219F488: 489CB399  bl 0x82b6a820
	ctx.lr = 0x8219F48C;
	sub_82B6A820(ctx, base);
	pc = 0x8219F48C; continue 'dispatch;
            }
            0x8219F48C => {
    //   block [0x8219F48C..0x8219F4B4)
	// 8219F48C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F490: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219F494: 9BCB001C  stb r30, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 8219F498: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F49C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F4A0: 9B29001C  stb r25, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 8219F4A4: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F4A8: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F4AC: 48A9C28D  bl 0x82c3b738
	ctx.lr = 0x8219F4B0;
	sub_82C3B738(ctx, base);
	// 8219F4B0: 48000074  b 0x8219f524
	pc = 0x8219F524; continue 'dispatch;
            }
            0x8219F4B4 => {
    //   block [0x8219F4B4..0x8219F4E8)
	// 8219F4B4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F4B8: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219F4BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219F4C0: 409A0028  bne cr6, 0x8219f4e8
	if !ctx.cr[6].eq {
	pc = 0x8219F4E8; continue 'dispatch;
	}
	// 8219F4C4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F4C8: 9BC9001C  stb r30, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 8219F4CC: 9BCA001C  stb r30, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 8219F4D0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F4D4: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F4D8: 9B27001C  stb r25, 0x1c(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 8219F4DC: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F4E0: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F4E4: 48000040  b 0x8219f524
	pc = 0x8219F524; continue 'dispatch;
            }
            0x8219F4E8 => {
    //   block [0x8219F4E8..0x8219F500)
	// 8219F4E8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F4EC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219F4F0: 409A0010  bne cr6, 0x8219f500
	if !ctx.cr[6].eq {
	pc = 0x8219F500; continue 'dispatch;
	}
	// 8219F4F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219F4F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8219F4FC: 48A9C23D  bl 0x82c3b738
	ctx.lr = 0x8219F500;
	sub_82C3B738(ctx, base);
	pc = 0x8219F500; continue 'dispatch;
            }
            0x8219F500 => {
    //   block [0x8219F500..0x8219F524)
	// 8219F500: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F504: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219F508: 9BCB001C  stb r30, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 8219F50C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F510: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F514: 9B29001C  stb r25, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 8219F518: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F51C: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F520: 489CB301  bl 0x82b6a820
	ctx.lr = 0x8219F524;
	sub_82B6A820(ctx, base);
	pc = 0x8219F524; continue 'dispatch;
            }
            0x8219F524 => {
    //   block [0x8219F524..0x8219F538)
	// 8219F524: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F528: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8219F52C: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219F530: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219F534: 419AFEF8  beq cr6, 0x8219f42c
	if ctx.cr[6].eq {
	pc = 0x8219F42C; continue 'dispatch;
	}
	pc = 0x8219F538; continue 'dispatch;
            }
            0x8219F538 => {
    //   block [0x8219F538..0x8219F558)
	// 8219F538: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F53C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 8219F540: 93780004  stw r27, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 8219F544: 93B80000  stw r29, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8219F548: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F54C: 9BCA001C  stb r30, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 8219F550: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8219F554: 48B09EF4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219F558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219F558 size=816
    let mut pc: u32 = 0x8219F558;
    'dispatch: loop {
        match pc {
            0x8219F558 => {
    //   block [0x8219F558..0x8219F888)
	// 8219F558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219F55C: 48B09EB1  bl 0x82ca940c
	ctx.lr = 0x8219F560;
	sub_82CA93D0(ctx, base);
	// 8219F560: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219F888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219F888 size=2524
    let mut pc: u32 = 0x8219F888;
    'dispatch: loop {
        match pc {
            0x8219F888 => {
    //   block [0x8219F888..0x8219F8F4)
	// 8219F888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219F88C: 48B09B45  bl 0x82ca93d0
	ctx.lr = 0x8219F890;
	sub_82CA93D0(ctx, base);
	// 8219F890: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 8219F894: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 8219F898: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219F89C: 7C6F1B78  mr r15, r3
	ctx.r[15].u64 = ctx.r[3].u64;
	// 8219F8A0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8219F8A4: 91E10184  stw r15, 0x184(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), ctx.r[15].u32 ) };
	// 8219F8A8: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 8219F8AC: 480F5805  bl 0x822950b0
	ctx.lr = 0x8219F8B0;
	sub_822950B0(ctx, base);
	// 8219F8B0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8219F8B4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8219F8B8: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 8219F8BC: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 8219F8C0: 894B9477  lbz r10, -0x6b89(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-27529 as u32) ) } as u64;
	// 8219F8C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219F8C8: 419A01E0  beq cr6, 0x8219faa8
	if ctx.cr[6].eq {
	pc = 0x8219FAA8; continue 'dispatch;
	}
	// 8219F8CC: 896F0021  lbz r11, 0x21(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(33 as u32) ) } as u64;
	// 8219F8D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F8D4: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8219F8D8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219F8DC: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8219F8E0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F8E4: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F8E8: 419A000C  beq cr6, 0x8219f8f4
	if ctx.cr[6].eq {
	pc = 0x8219F8F4; continue 'dispatch;
	}
	// 8219F8EC: 4808C8CD  bl 0x8222c1b8
	ctx.lr = 0x8219F8F0;
	sub_8222C1B8(ctx, base);
	// 8219F8F0: 48000008  b 0x8219f8f8
	pc = 0x8219F8F8; continue 'dispatch;
            }
            0x8219F8F4 => {
    //   block [0x8219F8F4..0x8219F8F8)
	// 8219F8F4: 48746185  bl 0x828e5a78
	ctx.lr = 0x8219F8F8;
	sub_828E5A78(ctx, base);
	pc = 0x8219F8F8; continue 'dispatch;
            }
            0x8219F8F8 => {
    //   block [0x8219F8F8..0x8219F914)
	// 8219F8F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219F8FC: 419A0018  beq cr6, 0x8219f914
	if ctx.cr[6].eq {
	pc = 0x8219F914; continue 'dispatch;
	}
	// 8219F900: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219F904: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F908: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219F90C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219F910: 409A0008  bne cr6, 0x8219f918
	if !ctx.cr[6].eq {
	pc = 0x8219F918; continue 'dispatch;
	}
	pc = 0x8219F914; continue 'dispatch;
            }
            0x8219F914 => {
    //   block [0x8219F914..0x8219F918)
	// 8219F914: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8219F918; continue 'dispatch;
            }
            0x8219F918 => {
    //   block [0x8219F918..0x8219F948)
	// 8219F918: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219F91C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F920: 419A0188  beq cr6, 0x8219faa8
	if ctx.cr[6].eq {
	pc = 0x8219FAA8; continue 'dispatch;
	}
	// 8219F924: 896F0021  lbz r11, 0x21(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(33 as u32) ) } as u64;
	// 8219F928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F92C: 409A001C  bne cr6, 0x8219f948
	if !ctx.cr[6].eq {
	pc = 0x8219F948; continue 'dispatch;
	}
	// 8219F930: 896F0022  lbz r11, 0x22(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(34 as u32) ) } as u64;
	// 8219F934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F938: 409A0010  bne cr6, 0x8219f948
	if !ctx.cr[6].eq {
	pc = 0x8219F948; continue 'dispatch;
	}
	// 8219F93C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 8219F940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F944: 419A0164  beq cr6, 0x8219faa8
	if ctx.cr[6].eq {
	pc = 0x8219FAA8; continue 'dispatch;
	}
	pc = 0x8219F948; continue 'dispatch;
            }
            0x8219F948 => {
    //   block [0x8219F948..0x8219F984)
	// 8219F948: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 8219F94C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 8219F950: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8219F954: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219F958: 419A00E8  beq cr6, 0x8219fa40
	if ctx.cr[6].eq {
	pc = 0x8219FA40; continue 'dispatch;
	}
	// 8219F95C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219F960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F964: 419A0020  beq cr6, 0x8219f984
	if ctx.cr[6].eq {
	pc = 0x8219F984; continue 'dispatch;
	}
	// 8219F968: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 8219F96C: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219F970: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8219F974: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219F978: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219F97C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F980: 480000C4  b 0x8219fa44
	pc = 0x8219FA44; continue 'dispatch;
            }
            0x8219F984 => {
    //   block [0x8219F984..0x8219F9A0)
	// 8219F984: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219F988: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 8219F98C: 93A10090  stw r29, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 8219F990: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8219F994: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 8219F998: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219F99C: 40810054  ble 0x8219f9f0
	if !ctx.cr[0].gt {
	pc = 0x8219F9F0; continue 'dispatch;
	}
	pc = 0x8219F9A0; continue 'dispatch;
            }
            0x8219F9A0 => {
    //   block [0x8219F9A0..0x8219F9C0)
	// 8219F9A0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8219F9A4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219F9A8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8219F9AC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F9B0: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 8219F9B4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8219F9B8: 41980008  blt cr6, 0x8219f9c0
	if ctx.cr[6].lt {
	pc = 0x8219F9C0; continue 'dispatch;
	}
	// 8219F9BC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x8219F9C0; continue 'dispatch;
            }
            0x8219F9C0 => {
    //   block [0x8219F9C0..0x8219F9DC)
	// 8219F9C0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8219F9C4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219F9C8: 419A0014  beq cr6, 0x8219f9dc
	if ctx.cr[6].eq {
	pc = 0x8219F9DC; continue 'dispatch;
	}
	// 8219F9CC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8219F9D0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219F9D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8219F9D8: 4800000C  b 0x8219f9e4
	pc = 0x8219F9E4; continue 'dispatch;
            }
            0x8219F9DC => {
    //   block [0x8219F9DC..0x8219F9E4)
	// 8219F9DC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8219F9E0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8219F9E4; continue 'dispatch;
            }
            0x8219F9E4 => {
    //   block [0x8219F9E4..0x8219F9F0)
	// 8219F9E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219F9E8: 4199FFB8  bgt cr6, 0x8219f9a0
	if ctx.cr[6].gt {
	pc = 0x8219F9A0; continue 'dispatch;
	}
	// 8219F9EC: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	pc = 0x8219F9F0; continue 'dispatch;
            }
            0x8219F9F0 => {
    //   block [0x8219F9F0..0x8219FA0C)
	// 8219F9F0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8219F9F4: 419A003C  beq cr6, 0x8219fa30
	if ctx.cr[6].eq {
	pc = 0x8219FA30; continue 'dispatch;
	}
	// 8219F9F8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F9FC: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 8219FA00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219FA04: 41990008  bgt cr6, 0x8219fa0c
	if ctx.cr[6].gt {
	pc = 0x8219FA0C; continue 'dispatch;
	}
	// 8219FA08: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8219FA0C; continue 'dispatch;
            }
            0x8219FA0C => {
    //   block [0x8219FA0C..0x8219FA30)
	// 8219FA0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219FA10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219FA14: 409A001C  bne cr6, 0x8219fa30
	if !ctx.cr[6].eq {
	pc = 0x8219FA30; continue 'dispatch;
	}
	// 8219FA18: E9610090  ld r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 8219FA1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219FA20: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 8219FA24: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 8219FA28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219FA2C: 48000018  b 0x8219fa44
	pc = 0x8219FA44; continue 'dispatch;
            }
            0x8219FA30 => {
    //   block [0x8219FA30..0x8219FA40)
	// 8219FA30: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8219FA34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219FA38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219FA3C: 48000008  b 0x8219fa44
	pc = 0x8219FA44; continue 'dispatch;
            }
            0x8219FA40 => {
    //   block [0x8219FA40..0x8219FA44)
	// 8219FA40: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x8219FA44; continue 'dispatch;
            }
            0x8219FA44 => {
    //   block [0x8219FA44..0x8219FA78)
	// 8219FA44: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8219FA48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219FA4C: 419A005C  beq cr6, 0x8219faa8
	if ctx.cr[6].eq {
	pc = 0x8219FAA8; continue 'dispatch;
	}
	// 8219FA50: 894B003B  lbz r10, 0x3b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(59 as u32) ) } as u64;
	// 8219FA54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219FA58: 409A0020  bne cr6, 0x8219fa78
	if !ctx.cr[6].eq {
	pc = 0x8219FA78; continue 'dispatch;
	}
	// 8219FA5C: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8219FA60: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8219FA64: 394A000A  addi r10, r10, 0xa
	ctx.r[10].s64 = ctx.r[10].s64 + 10;
	// 8219FA68: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 8219FA6C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219FA70: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 8219FA74: 41990008  bgt cr6, 0x8219fa7c
	if ctx.cr[6].gt {
	pc = 0x8219FA7C; continue 'dispatch;
	}
	pc = 0x8219FA78; continue 'dispatch;
            }
            0x8219FA78 => {
    //   block [0x8219FA78..0x8219FA7C)
	// 8219FA78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x8219FA7C; continue 'dispatch;
            }
            0x8219FA7C => {
    //   block [0x8219FA7C..0x8219FAA4)
	// 8219FA7C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219FA80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219FA84: 419A0020  beq cr6, 0x8219faa4
	if ctx.cr[6].eq {
	pc = 0x8219FAA4; continue 'dispatch;
	}
	// 8219FA88: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 8219FA8C: 4BFF10D5  bl 0x82190b60
	ctx.lr = 0x8219FA90;
	sub_82190B60(ctx, base);
	// 8219FA90: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8219FA94: 394B94A4  addi r10, r11, -0x6b5c
	ctx.r[10].s64 = ctx.r[11].s64 + -27484;
	// 8219FA98: 7D2350AE  lbzx r9, r3, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219FA9C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219FAA0: 419A0008  beq cr6, 0x8219faa8
	if ctx.cr[6].eq {
	pc = 0x8219FAA8; continue 'dispatch;
	}
	pc = 0x8219FAA4; continue 'dispatch;
            }
            0x8219FAA4 => {
    //   block [0x8219FAA4..0x8219FAA8)
	// 8219FAA4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	pc = 0x8219FAA8; continue 'dispatch;
            }
            0x8219FAA8 => {
    //   block [0x8219FAA8..0x8219FAE4)
	// 8219FAA8: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 8219FAAC: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 8219FAB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219FAB4: 419A00A4  beq cr6, 0x8219fb58
	if ctx.cr[6].eq {
	pc = 0x8219FB58; continue 'dispatch;
	}
	// 8219FAB8: 8BEF0024  lbz r31, 0x24(r15)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(36 as u32) ) } as u64;
	// 8219FABC: 4811E665  bl 0x822be120
	ctx.lr = 0x8219FAC0;
	sub_822BE120(ctx, base);
	// 8219FAC0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219FAC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219FAC8: 409A001C  bne cr6, 0x8219fae4
	if !ctx.cr[6].eq {
	pc = 0x8219FAE4; continue 'dispatch;
	}
	// 8219FACC: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 8219FAD0: 4828A021  bl 0x82429af0
	ctx.lr = 0x8219FAD4;
	sub_82429AF0(ctx, base);
	// 8219FAD4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219FAD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219FADC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 8219FAE0: 419A0008  beq cr6, 0x8219fae8
	if ctx.cr[6].eq {
	pc = 0x8219FAE8; continue 'dispatch;
	}
	pc = 0x8219FAE4; continue 'dispatch;
            }
            0x8219FAE4 => {
    //   block [0x8219FAE4..0x8219FAE8)
	// 8219FAE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x8219FAE8; continue 'dispatch;
            }
            0x8219FAE8 => {
    //   block [0x8219FAE8..0x8219FB10)
	// 8219FAE8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219FAEC: 57EA063E  clrlwi r10, r31, 0x18
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 8219FAF0: 996F0024  stb r11, 0x24(r15)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[15].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 8219FAF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219FAF8: 409A0018  bne cr6, 0x8219fb10
	if !ctx.cr[6].eq {
	pc = 0x8219FB10; continue 'dispatch;
	}
	// 8219FAFC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219FB00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219FB04: 419A000C  beq cr6, 0x8219fb10
	if ctx.cr[6].eq {
	pc = 0x8219FB10; continue 'dispatch;
	}
	// 8219FB08: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 8219FB0C: 4828B805  bl 0x8242b310
	ctx.lr = 0x8219FB10;
	sub_8242B310(ctx, base);
	pc = 0x8219FB10; continue 'dispatch;
            }
            0x8219FB10 => {
    //   block [0x8219FB10..0x8219FB40)
	// 8219FB10: 896F0021  lbz r11, 0x21(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(33 as u32) ) } as u64;
	// 8219FB14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219FB18: 409A0028  bne cr6, 0x8219fb40
	if !ctx.cr[6].eq {
	pc = 0x8219FB40; continue 'dispatch;
	}
	// 8219FB1C: 896F0022  lbz r11, 0x22(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(34 as u32) ) } as u64;
	// 8219FB20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219FB24: 409A001C  bne cr6, 0x8219fb40
	if !ctx.cr[6].eq {
	pc = 0x8219FB40; continue 'dispatch;
	}
	// 8219FB28: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 8219FB2C: 4828A085  bl 0x82429bb0
	ctx.lr = 0x8219FB30;
	sub_82429BB0(ctx, base);
	// 8219FB30: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8219FB34: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 8219FB38: 4BFD57D9  bl 0x82175310
	ctx.lr = 0x8219FB3C;
	sub_82175310(ctx, base);
	// 8219FB3C: 48000020  b 0x8219fb5c
	pc = 0x8219FB5C; continue 'dispatch;
            }
            0x8219FB40 => {
    //   block [0x8219FB40..0x8219FB58)
	// 8219FB40: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 8219FB44: 481040B5  bl 0x822a3bf8
	ctx.lr = 0x8219FB48;
	sub_822A3BF8(ctx, base);
	// 8219FB48: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8219FB4C: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 8219FB50: 4BFD57C1  bl 0x82175310
	ctx.lr = 0x8219FB54;
	sub_82175310(ctx, base);
	// 8219FB54: 48000008  b 0x8219fb5c
	pc = 0x8219FB5C; continue 'dispatch;
            }
            0x8219FB58 => {
    //   block [0x8219FB58..0x8219FB5C)
	// 8219FB58: 4828A059  bl 0x82429bb0
	ctx.lr = 0x8219FB5C;
	sub_82429BB0(ctx, base);
	pc = 0x8219FB5C; continue 'dispatch;
            }
            0x8219FB5C => {
    //   block [0x8219FB5C..0x8219FB90)
	// 8219FB5C: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 8219FB60: 4BFF0101  bl 0x8218fc60
	ctx.lr = 0x8219FB64;
	sub_8218FC60(ctx, base);
	// 8219FB64: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8219FB68: 894B6B4A  lbz r10, 0x6b4a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27466 as u32) ) } as u64;
	// 8219FB6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219FB70: 419A0640  beq cr6, 0x821a01b0
	if ctx.cr[6].eq {
	pc = 0x821A01B0; continue 'dispatch;
	}
	// 8219FB74: 896F0021  lbz r11, 0x21(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(33 as u32) ) } as u64;
	// 8219FB78: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 8219FB7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219FB80: 409A0010  bne cr6, 0x8219fb90
	if !ctx.cr[6].eq {
	pc = 0x8219FB90; continue 'dispatch;
	}
	// 8219FB84: 896F0022  lbz r11, 0x22(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(34 as u32) ) } as u64;
	// 8219FB88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219FB8C: 419A0624  beq cr6, 0x821a01b0
	if ctx.cr[6].eq {
	pc = 0x821A01B0; continue 'dispatch;
	}
	pc = 0x8219FB90; continue 'dispatch;
            }
            0x8219FB90 => {
    //   block [0x8219FB90..0x8219FBCC)
	// 8219FB90: 816F0004  lwz r11, 4(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219FB94: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8219FB98: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 8219FB9C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219FBA0: 419A00E8  beq cr6, 0x8219fc88
	if ctx.cr[6].eq {
	pc = 0x8219FC88; continue 'dispatch;
	}
	// 8219FBA4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219FBA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219FBAC: 419A0020  beq cr6, 0x8219fbcc
	if ctx.cr[6].eq {
	pc = 0x8219FBCC; continue 'dispatch;
	}
	// 8219FBB0: 894A0083  lbz r10, 0x83(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(131 as u32) ) } as u64;
	// 8219FBB4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219FBB8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8219FBBC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219FBC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219FBC4: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219FBC8: 480000C4  b 0x8219fc8c
	pc = 0x8219FC8C; continue 'dispatch;
            }
            0x8219FBCC => {
    //   block [0x8219FBCC..0x8219FBE8)
	// 8219FBCC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8219FBD0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8219FBD4: 93A10090  stw r29, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 8219FBD8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8219FBDC: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 8219FBE0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219FBE4: 40810054  ble 0x8219fc38
	if !ctx.cr[0].gt {
	pc = 0x8219FC38; continue 'dispatch;
	}
	pc = 0x8219FBE8; continue 'dispatch;
            }
            0x8219FBE8 => {
    //   block [0x8219FBE8..0x8219FC08)
	// 8219FBE8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8219FBEC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219FBF0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8219FBF4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219FBF8: 2F070083  cmpwi cr6, r7, 0x83
	ctx.cr[6].compare_i32(ctx.r[7].s32, 131, &mut ctx.xer);
	// 8219FBFC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8219FC00: 41980008  blt cr6, 0x8219fc08
	if ctx.cr[6].lt {
	pc = 0x8219FC08; continue 'dispatch;
	}
	// 8219FC04: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x8219FC08; continue 'dispatch;
            }
            0x8219FC08 => {
    //   block [0x8219FC08..0x8219FC24)
	// 8219FC08: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8219FC0C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219FC10: 419A0014  beq cr6, 0x8219fc24
	if ctx.cr[6].eq {
	pc = 0x8219FC24; continue 'dispatch;
	}
	// 8219FC14: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8219FC18: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219FC1C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8219FC20: 4800000C  b 0x8219fc2c
	pc = 0x8219FC2C; continue 'dispatch;
            }
            0x8219FC24 => {
    //   block [0x8219FC24..0x8219FC2C)
	// 8219FC24: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8219FC28: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8219FC2C; continue 'dispatch;
            }
            0x8219FC2C => {
    //   block [0x8219FC2C..0x8219FC38)
	// 8219FC2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219FC30: 4199FFB8  bgt cr6, 0x8219fbe8
	if ctx.cr[6].gt {
	pc = 0x8219FBE8; continue 'dispatch;
	}
	// 8219FC34: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	pc = 0x8219FC38; continue 'dispatch;
            }
            0x8219FC38 => {
    //   block [0x8219FC38..0x8219FC54)
	// 8219FC38: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8219FC3C: 419A003C  beq cr6, 0x8219fc78
	if ctx.cr[6].eq {
	pc = 0x8219FC78; continue 'dispatch;
	}
	// 8219FC40: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219FC44: 2F0B0083  cmpwi cr6, r11, 0x83
	ctx.cr[6].compare_i32(ctx.r[11].s32, 131, &mut ctx.xer);
	// 8219FC48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219FC4C: 41990008  bgt cr6, 0x8219fc54
	if ctx.cr[6].gt {
	pc = 0x8219FC54; continue 'dispatch;
	}
	// 8219FC50: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8219FC54; continue 'dispatch;
            }
            0x8219FC54 => {
    //   block [0x8219FC54..0x8219FC78)
	// 8219FC54: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219FC58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219FC5C: 409A001C  bne cr6, 0x8219fc78
	if !ctx.cr[6].eq {
	pc = 0x8219FC78; continue 'dispatch;
	}
	// 8219FC60: E9610090  ld r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 8219FC64: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 8219FC68: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 8219FC6C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219FC70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219FC74: 48000018  b 0x8219fc8c
	pc = 0x8219FC8C; continue 'dispatch;
            }
            0x8219FC78 => {
    //   block [0x8219FC78..0x8219FC88)
	// 8219FC78: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8219FC7C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219FC80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219FC84: 48000008  b 0x8219fc8c
	pc = 0x8219FC8C; continue 'dispatch;
            }
            0x8219FC88 => {
    //   block [0x8219FC88..0x8219FC8C)
	// 8219FC88: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8219FC8C; continue 'dispatch;
            }
            0x8219FC8C => {
    //   block [0x8219FC8C..0x8219FCAC)
	// 8219FC8C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219FC90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219FC94: 419A051C  beq cr6, 0x821a01b0
	if ctx.cr[6].eq {
	pc = 0x821A01B0; continue 'dispatch;
	}
	// 8219FC98: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8219FC9C: 894B6BAF  lbz r10, 0x6baf(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27567 as u32) ) } as u64;
	// 8219FCA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219FCA4: 409A0008  bne cr6, 0x8219fcac
	if !ctx.cr[6].eq {
	pc = 0x8219FCAC; continue 'dispatch;
	}
	// 8219FCA8: 48288E09  bl 0x82428ab0
	ctx.lr = 0x8219FCAC;
	sub_82428AB0(ctx, base);
	pc = 0x8219FCAC; continue 'dispatch;
            }
            0x8219FCAC => {
    //   block [0x8219FCAC..0x8219FD68)
	// 8219FCAC: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8219FCB0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8219FCB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8219FCB8: 38AA802C  addi r5, r10, -0x7fd4
	ctx.r[5].s64 = ctx.r[10].s64 + -32724;
	// 8219FCBC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219FCC0: 80890060  lwz r4, 0x60(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(96 as u32) ) } as u64;
	// 8219FCC4: 48055FFD  bl 0x821f5cc0
	ctx.lr = 0x8219FCC8;
	sub_821F5CC0(ctx, base);
	// 8219FCC8: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 8219FCCC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219FCD0: 38E00064  li r7, 0x64
	ctx.r[7].s64 = 100;
	// 8219FCD4: 38C85FE8  addi r6, r8, 0x5fe8
	ctx.r[6].s64 = ctx.r[8].s64 + 24552;
	// 8219FCD8: 3A3F000C  addi r17, r31, 0xc
	ctx.r[17].s64 = ctx.r[31].s64 + 12;
	// 8219FCDC: 3FE08332  lis r31, -0x7cce
	ctx.r[31].s64 = -2093875200;
	// 8219FCE0: 81685FE8  lwz r11, 0x5fe8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24552 as u32) ) } as u64;
	// 8219FCE4: 3A600001  li r19, 1
	ctx.r[19].s64 = 1;
	// 8219FCE8: 3B7F9B88  addi r27, r31, -0x6478
	ctx.r[27].s64 = ctx.r[31].s64 + -25720;
	// 8219FCEC: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219FCF0: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8219FCF4: 3CC0820B  lis r6, -0x7df5
	ctx.r[6].s64 = -2113208320;
	// 8219FCF8: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219FCFC: 7CAB4A14  add r5, r11, r9
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8219FD00: 7C8A4214  add r4, r10, r8
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8219FD04: 7D653BD6  divw r11, r5, r7
	ctx.r[11].s32 = ctx.r[5].s32 / ctx.r[7].s32;
	// 8219FD08: 7D443BD6  divw r10, r4, r7
	ctx.r[10].s32 = ctx.r[4].s32 / ctx.r[7].s32;
	// 8219FD0C: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 8219FD10: 3BCB000A  addi r30, r11, 0xa
	ctx.r[30].s64 = ctx.r[11].s64 + 10;
	// 8219FD14: 3BAA0050  addi r29, r10, 0x50
	ctx.r[29].s64 = ctx.r[10].s64 + 80;
	// 8219FD18: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8219FD1C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 8219FD20: 82830000  lwz r20, 0(r3)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219FD24: C3E7A938  lfs f31, -0x56c8(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-22216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219FD28: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 8219FD2C: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 8219FD30: 3CE0820B  lis r7, -0x7df5
	ctx.r[7].s64 = -2113208320;
	// 8219FD34: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 8219FD38: 3C80820B  lis r4, -0x7df5
	ctx.r[4].s64 = -2113208320;
	// 8219FD3C: 3C608349  lis r3, -0x7cb7
	ctx.r[3].s64 = -2092367872;
	// 8219FD40: 38C62650  addi r6, r6, 0x2650
	ctx.r[6].s64 = ctx.r[6].s64 + 9808;
	// 8219FD44: 3A4B2674  addi r18, r11, 0x2674
	ctx.r[18].s64 = ctx.r[11].s64 + 9844;
	// 8219FD48: 3B4A2660  addi r26, r10, 0x2660
	ctx.r[26].s64 = ctx.r[10].s64 + 9824;
	// 8219FD4C: 90C1007C  stw r6, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[6].u32 ) };
	// 8219FD50: 3B297F90  addi r25, r9, 0x7f90
	ctx.r[25].s64 = ctx.r[9].s64 + 32656;
	// 8219FD54: 3B084A00  addi r24, r8, 0x4a00
	ctx.r[24].s64 = ctx.r[8].s64 + 18944;
	// 8219FD58: 3A072658  addi r16, r7, 0x2658
	ctx.r[16].s64 = ctx.r[7].s64 + 9816;
	// 8219FD5C: 3AE52648  addi r23, r5, 0x2648
	ctx.r[23].s64 = ctx.r[5].s64 + 9800;
	// 8219FD60: 3AC42644  addi r22, r4, 0x2644
	ctx.r[22].s64 = ctx.r[4].s64 + 9796;
	// 8219FD64: 3AA37FA0  addi r21, r3, 0x7fa0
	ctx.r[21].s64 = ctx.r[3].s64 + 32672;
	pc = 0x8219FD68; continue 'dispatch;
            }
            0x8219FD68 => {
    //   block [0x8219FD68..0x8219FDB0)
	// 8219FD68: 81710004  lwz r11, 4(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219FD6C: 7F145840  cmplw cr6, r20, r11
	ctx.cr[6].compare_u32(ctx.r[20].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219FD70: 419A0434  beq cr6, 0x821a01a4
	if ctx.cr[6].eq {
	pc = 0x821A01A4; continue 'dispatch;
	}
	// 8219FD74: 7FAB07B4  extsw r11, r29
	ctx.r[11].s64 = ctx.r[29].s32 as i64;
	// 8219FD78: 81510004  lwz r10, 4(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219FD7C: 93C10090  stw r30, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 8219FD80: F96100A0  std r11, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u64 ) };
	// 8219FD84: C80100A0  lfd f0, 0xa0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 8219FD88: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 8219FD8C: 7F145040  cmplw cr6, r20, r10
	ctx.cr[6].compare_u32(ctx.r[20].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219FD90: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219FD94: ED6CF82A  fadds f11, f12, f31
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[31].f64) as f32) as f64;
	// 8219FD98: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 8219FD9C: D94100A8  stfd f10, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.f[10].u64 ) };
	// 8219FDA0: 838100AC  lwz r28, 0xac(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 8219FDA4: 93810094  stw r28, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[28].u32 ) };
	// 8219FDA8: 409A0008  bne cr6, 0x8219fdb0
	if !ctx.cr[6].eq {
	pc = 0x8219FDB0; continue 'dispatch;
	}
	// 8219FDAC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8219FDB0; continue 'dispatch;
            }
            0x8219FDB0 => {
    //   block [0x8219FDB0..0x8219FDEC)
	// 8219FDB0: 83F40008  lwz r31, 8(r20)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219FDB4: 897B0002  lbz r11, 2(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(2 as u32) ) } as u64;
	// 8219FDB8: 895B0001  lbz r10, 1(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(1 as u32) ) } as u64;
	// 8219FDBC: 893B0000  lbz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219FDC0: 891B0003  lbz r8, 3(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(3 as u32) ) } as u64;
	// 8219FDC4: 88DF000D  lbz r6, 0xd(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(13 as u32) ) } as u64;
	// 8219FDC8: 99610056  stb r11, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[11].u8 ) };
	// 8219FDCC: 99410055  stb r10, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[10].u8 ) };
	// 8219FDD0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8219FDD4: 99210054  stb r9, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u8 ) };
	// 8219FDD8: 99010057  stb r8, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[8].u8 ) };
	// 8219FDDC: 419A0010  beq cr6, 0x8219fdec
	if ctx.cr[6].eq {
	pc = 0x8219FDEC; continue 'dispatch;
	}
	// 8219FDE0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8219FDE4: 816B9B90  lwz r11, -0x6470(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25712 as u32) ) } as u64;
	// 8219FDE8: 48000024  b 0x8219fe0c
	pc = 0x8219FE0C; continue 'dispatch;
            }
            0x8219FDEC => {
    //   block [0x8219FDEC..0x8219FE0C)
	// 8219FDEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219FDF0: 808F0004  lwz r4, 4(r15)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219FDF4: 486A037D  bl 0x82840170
	ctx.lr = 0x8219FDF8;
	sub_82840170(ctx, base);
	// 8219FDF8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219FDFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219FE00: 419A0010  beq cr6, 0x8219fe10
	if ctx.cr[6].eq {
	pc = 0x8219FE10; continue 'dispatch;
	}
	// 8219FE04: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8219FE08: 816B9B8C  lwz r11, -0x6474(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25716 as u32) ) } as u64;
	pc = 0x8219FE0C; continue 'dispatch;
            }
            0x8219FE0C => {
    //   block [0x8219FE0C..0x8219FE10)
	// 8219FE0C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x8219FE10; continue 'dispatch;
            }
            0x8219FE10 => {
    //   block [0x8219FE10..0x8219FF18)
	// 8219FE10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219FE14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219FE18: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219FE1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219FE20: 4E800421  bctrl
	ctx.lr = 0x8219FE24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219FE24: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219FE28: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219FE2C: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 8219FE30: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8219FE34: 7FAA5A14  add r29, r10, r11
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219FE38: 481AEE89  bl 0x8234ecc0
	ctx.lr = 0x8219FE3C;
	sub_8234ECC0(ctx, base);
	// 8219FE3C: 7C6E1B78  mr r14, r3
	ctx.r[14].u64 = ctx.r[3].u64;
	// 8219FE40: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8219FE44: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8219FE48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8219FE4C: 4808D085  bl 0x8222ced0
	ctx.lr = 0x8219FE50;
	sub_8222CED0(ctx, base);
	// 8219FE50: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 8219FE54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8219FE58: 4804C9A1  bl 0x821ec7f8
	ctx.lr = 0x8219FE5C;
	sub_821EC7F8(ctx, base);
	// 8219FE5C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8219FE60: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8219FE64: 480503DD  bl 0x821f0240
	ctx.lr = 0x8219FE68;
	sub_821F0240(ctx, base);
	// 8219FE68: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8219FE6C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8219FE70: 4803AB51  bl 0x821da9c0
	ctx.lr = 0x8219FE74;
	sub_821DA9C0(ctx, base);
	// 8219FE74: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8219FE78: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 8219FE7C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 8219FE80: 3BA10054  addi r29, r1, 0x54
	ctx.r[29].s64 = ctx.r[1].s64 + 84;
	// 8219FE84: 39C10090  addi r14, r1, 0x90
	ctx.r[14].s64 = ctx.r[1].s64 + 144;
	// 8219FE88: 48043281  bl 0x821e3108
	ctx.lr = 0x8219FE8C;
	sub_821E3108(ctx, base);
	// 8219FE8C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8219FE90: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8219FE94: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 8219FE98: 7DC67378  mr r6, r14
	ctx.r[6].u64 = ctx.r[14].u64;
	// 8219FE9C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 8219FEA0: 4828AD89  bl 0x8242ac28
	ctx.lr = 0x8219FEA4;
	sub_8242AC28(ctx, base);
	// 8219FEA4: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 8219FEA8: 48074F31  bl 0x82214dd8
	ctx.lr = 0x8219FEAC;
	sub_82214DD8(ctx, base);
	// 8219FEAC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8219FEB0: 48074F29  bl 0x82214dd8
	ctx.lr = 0x8219FEB4;
	sub_82214DD8(ctx, base);
	// 8219FEB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8219FEB8: 48074F21  bl 0x82214dd8
	ctx.lr = 0x8219FEBC;
	sub_82214DD8(ctx, base);
	// 8219FEBC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8219FEC0: 48074F19  bl 0x82214dd8
	ctx.lr = 0x8219FEC4;
	sub_82214DD8(ctx, base);
	// 8219FEC4: 7F8907B4  extsw r9, r28
	ctx.r[9].s64 = ctx.r[28].s32 as i64;
	// 8219FEC8: 88FF000D  lbz r7, 0xd(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(13 as u32) ) } as u64;
	// 8219FECC: F92100B0  std r9, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[9].u64 ) };
	// 8219FED0: C80100B0  lfd f0, 0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 8219FED4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 8219FED8: 93C10090  stw r30, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 8219FEDC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219FEE0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219FEE4: ED6CF82A  fadds f11, f12, f31
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[31].f64) as f32) as f64;
	// 8219FEE8: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 8219FEEC: D94100A8  stfd f10, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.f[10].u64 ) };
	// 8219FEF0: 83A100AC  lwz r29, 0xac(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 8219FEF4: 93A10094  stw r29, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 8219FEF8: 409A0290  bne cr6, 0x821a0188
	if !ctx.cr[6].eq {
	pc = 0x821A0188; continue 'dispatch;
	}
	// 8219FEFC: 895F000C  lbz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219FF00: C3DF0008  lfs f30, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219FF04: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219FF08: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8219FF0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219FF10: 409A0008  bne cr6, 0x8219ff18
	if !ctx.cr[6].eq {
	pc = 0x8219FF18; continue 'dispatch;
	}
	// 8219FF14: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
            }
            0x8219FF18 => {
    //   block [0x8219FF18..0x821A004C)
	// 8219FF18: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8219FF1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219FF20: 4808CFB1  bl 0x8222ced0
	ctx.lr = 0x8219FF24;
	sub_8222CED0(ctx, base);
	// 8219FF24: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219FF28: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219FF2C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8219FF30: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8219FF34: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8219FF38: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219FF3C: 4808CF95  bl 0x8222ced0
	ctx.lr = 0x8219FF40;
	sub_8222CED0(ctx, base);
	// 8219FF40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219FF44: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8219FF48: 4804C8B1  bl 0x821ec7f8
	ctx.lr = 0x8219FF4C;
	sub_821EC7F8(ctx, base);
	// 8219FF4C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219FF50: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 8219FF54: 480502ED  bl 0x821f0240
	ctx.lr = 0x8219FF58;
	sub_821F0240(ctx, base);
	// 8219FF58: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8219FF5C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 8219FF60: 4803AA61  bl 0x821da9c0
	ctx.lr = 0x8219FF64;
	sub_821DA9C0(ctx, base);
	// 8219FF64: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 8219FF68: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8219FF6C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8219FF70: 3BE10054  addi r31, r1, 0x54
	ctx.r[31].s64 = ctx.r[1].s64 + 84;
	// 8219FF74: 39C10090  addi r14, r1, 0x90
	ctx.r[14].s64 = ctx.r[1].s64 + 144;
	// 8219FF78: 4804EA19  bl 0x821ee990
	ctx.lr = 0x8219FF7C;
	sub_821EE990(ctx, base);
	// 8219FF7C: 7C6F1B78  mr r15, r3
	ctx.r[15].u64 = ctx.r[3].u64;
	// 8219FF80: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8219FF84: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 8219FF88: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 8219FF8C: 4804317D  bl 0x821e3108
	ctx.lr = 0x8219FF90;
	sub_821E3108(ctx, base);
	// 8219FF90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219FF94: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219FF98: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 8219FF9C: 4804316D  bl 0x821e3108
	ctx.lr = 0x8219FFA0;
	sub_821E3108(ctx, base);
	// 8219FFA0: 81E10184  lwz r15, 0x184(r1)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 8219FFA4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8219FFA8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8219FFAC: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 8219FFB0: 7DC67378  mr r6, r14
	ctx.r[6].u64 = ctx.r[14].u64;
	// 8219FFB4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 8219FFB8: 4828AC71  bl 0x8242ac28
	ctx.lr = 0x8219FFBC;
	sub_8242AC28(ctx, base);
	// 8219FFBC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219FFC0: 48074E19  bl 0x82214dd8
	ctx.lr = 0x8219FFC4;
	sub_82214DD8(ctx, base);
	// 8219FFC4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 8219FFC8: 48074E11  bl 0x82214dd8
	ctx.lr = 0x8219FFCC;
	sub_82214DD8(ctx, base);
	// 8219FFCC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 8219FFD0: 48074E09  bl 0x82214dd8
	ctx.lr = 0x8219FFD4;
	sub_82214DD8(ctx, base);
	// 8219FFD4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8219FFD8: 48074E01  bl 0x82214dd8
	ctx.lr = 0x8219FFDC;
	sub_82214DD8(ctx, base);
	// 8219FFDC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8219FFE0: 48074DF9  bl 0x82214dd8
	ctx.lr = 0x8219FFE4;
	sub_82214DD8(ctx, base);
	// 8219FFE4: 7FAA07B4  extsw r10, r29
	ctx.r[10].s64 = ctx.r[29].s32 as i64;
	// 8219FFE8: 816F0004  lwz r11, 4(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219FFEC: F94100B8  std r10, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[10].u64 ) };
	// 8219FFF0: C80100B8  lfd f0, 0xb8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 8219FFF4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 8219FFF8: 93C10090  stw r30, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 8219FFFC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A0000: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A0004: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0008: 55288FFE  rlwinm r8, r9, 0x11, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00007FFFu64;
	// 821A000C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A0010: ED6CF82A  fadds f11, f12, f31
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[31].f64) as f32) as f64;
	// 821A0014: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 821A0018: D94100A8  stfd f10, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.f[10].u64 ) };
	// 821A001C: 83E100AC  lwz r31, 0xac(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 821A0020: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 821A0024: 419A00D8  beq cr6, 0x821a00fc
	if ctx.cr[6].eq {
	pc = 0x821A00FC; continue 'dispatch;
	}
	// 821A0028: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A002C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A0030: 419A001C  beq cr6, 0x821a004c
	if ctx.cr[6].eq {
	pc = 0x821A004C; continue 'dispatch;
	}
	// 821A0034: 894A002F  lbz r10, 0x2f(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(47 as u32) ) } as u64;
	// 821A0038: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A003C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A0040: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A0044: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A0048: 480000B4  b 0x821a00fc
	pc = 0x821A00FC; continue 'dispatch;
            }
            0x821A004C => {
    //   block [0x821A004C..0x821A006C)
	// 821A004C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A0050: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0054: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A0058: 91210098  stw r9, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[9].u32 ) };
	// 821A005C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A0060: 9141009C  stw r10, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 821A0064: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A0068: 40810054  ble 0x821a00bc
	if !ctx.cr[0].gt {
	pc = 0x821A00BC; continue 'dispatch;
	}
	pc = 0x821A006C; continue 'dispatch;
            }
            0x821A006C => {
    //   block [0x821A006C..0x821A008C)
	// 821A006C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A0070: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A0074: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821A0078: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A007C: 2F07002F  cmpwi cr6, r7, 0x2f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 47, &mut ctx.xer);
	// 821A0080: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A0084: 41980008  blt cr6, 0x821a008c
	if ctx.cr[6].lt {
	pc = 0x821A008C; continue 'dispatch;
	}
	// 821A0088: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821A008C; continue 'dispatch;
            }
            0x821A008C => {
    //   block [0x821A008C..0x821A00A8)
	// 821A008C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A0090: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A0094: 419A0014  beq cr6, 0x821a00a8
	if ctx.cr[6].eq {
	pc = 0x821A00A8; continue 'dispatch;
	}
	// 821A0098: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A009C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A00A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A00A4: 4800000C  b 0x821a00b0
	pc = 0x821A00B0; continue 'dispatch;
            }
            0x821A00A8 => {
    //   block [0x821A00A8..0x821A00B0)
	// 821A00A8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A00AC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A00B0; continue 'dispatch;
            }
            0x821A00B0 => {
    //   block [0x821A00B0..0x821A00BC)
	// 821A00B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A00B4: 4199FFB8  bgt cr6, 0x821a006c
	if ctx.cr[6].gt {
	pc = 0x821A006C; continue 'dispatch;
	}
	// 821A00B8: 9141009C  stw r10, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	pc = 0x821A00BC; continue 'dispatch;
            }
            0x821A00BC => {
    //   block [0x821A00BC..0x821A00D8)
	// 821A00BC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A00C0: 419A0034  beq cr6, 0x821a00f4
	if ctx.cr[6].eq {
	pc = 0x821A00F4; continue 'dispatch;
	}
	// 821A00C4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A00C8: 2F0B002F  cmpwi cr6, r11, 0x2f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 47, &mut ctx.xer);
	// 821A00CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A00D0: 41990008  bgt cr6, 0x821a00d8
	if ctx.cr[6].gt {
	pc = 0x821A00D8; continue 'dispatch;
	}
	// 821A00D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821A00D8; continue 'dispatch;
            }
            0x821A00D8 => {
    //   block [0x821A00D8..0x821A00F4)
	// 821A00D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A00DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A00E0: 409A0014  bne cr6, 0x821a00f4
	if !ctx.cr[6].eq {
	pc = 0x821A00F4; continue 'dispatch;
	}
	// 821A00E4: E9610098  ld r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 821A00E8: F96100A8  std r11, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	// 821A00EC: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 821A00F0: 48000008  b 0x821a00f8
	pc = 0x821A00F8; continue 'dispatch;
            }
            0x821A00F4 => {
    //   block [0x821A00F4..0x821A00F8)
	// 821A00F4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x821A00F8; continue 'dispatch;
            }
            0x821A00F8 => {
    //   block [0x821A00F8..0x821A00FC)
	// 821A00F8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821A00FC; continue 'dispatch;
            }
            0x821A00FC => {
    //   block [0x821A00FC..0x821A0188)
	// 821A00FC: 397C000B  addi r11, r28, 0xb
	ctx.r[11].s64 = ctx.r[28].s64 + 11;
	// 821A0100: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 821A0104: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A0108: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 821A010C: 7C29542E  lfsx f1, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A0110: 4804E881  bl 0x821ee990
	ctx.lr = 0x821A0114;
	sub_821EE990(ctx, base);
	// 821A0114: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A0118: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 821A011C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821A0120: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 821A0124: 4808CDAD  bl 0x8222ced0
	ctx.lr = 0x821A0128;
	sub_8222CED0(ctx, base);
	// 821A0128: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A012C: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 821A0130: 4804C6C9  bl 0x821ec7f8
	ctx.lr = 0x821A0134;
	sub_821EC7F8(ctx, base);
	// 821A0134: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 821A0138: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821A013C: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 821A0140: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 821A0144: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 821A0148: 4828AAE1  bl 0x8242ac28
	ctx.lr = 0x821A014C;
	sub_8242AC28(ctx, base);
	// 821A014C: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 821A0150: 48074C89  bl 0x82214dd8
	ctx.lr = 0x821A0154;
	sub_82214DD8(ctx, base);
	// 821A0154: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 821A0158: 48074C81  bl 0x82214dd8
	ctx.lr = 0x821A015C;
	sub_82214DD8(ctx, base);
	// 821A015C: 7FE807B4  extsw r8, r31
	ctx.r[8].s64 = ctx.r[31].s32 as i64;
	// 821A0160: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A0164: F90100C0  std r8, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[8].u64 ) };
	// 821A0168: C80100C0  lfd f0, 0xc0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 821A016C: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821A0170: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A0174: ED6CF82A  fadds f11, f12, f31
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[31].f64) as f32) as f64;
	// 821A0178: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 821A017C: D94100A8  stfd f10, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.f[10].u64 ) };
	// 821A0180: 83A100AC  lwz r29, 0xac(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 821A0184: 48074C55  bl 0x82214dd8
	ctx.lr = 0x821A0188;
	sub_82214DD8(ctx, base);
	pc = 0x821A0188; continue 'dispatch;
            }
            0x821A0188 => {
    //   block [0x821A0188..0x821A019C)
	// 821A0188: 81710004  lwz r11, 4(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A018C: 3A730001  addi r19, r19, 1
	ctx.r[19].s64 = ctx.r[19].s64 + 1;
	// 821A0190: 7F145840  cmplw cr6, r20, r11
	ctx.cr[6].compare_u32(ctx.r[20].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A0194: 409A0008  bne cr6, 0x821a019c
	if !ctx.cr[6].eq {
	pc = 0x821A019C; continue 'dispatch;
	}
	// 821A0198: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A019C; continue 'dispatch;
            }
            0x821A019C => {
    //   block [0x821A019C..0x821A01A4)
	// 821A019C: 82940000  lwz r20, 0(r20)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A01A0: 4BFFFBC8  b 0x8219fd68
	pc = 0x8219FD68; continue 'dispatch;
            }
            0x821A01A4 => {
    //   block [0x821A01A4..0x821A01B0)
	// 821A01A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821A01A8: 48091B11  bl 0x82231cb8
	ctx.lr = 0x821A01AC;
	sub_82231CB8(ctx, base);
	// 821A01AC: 8B810050  lbz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x821A01B0; continue 'dispatch;
            }
            0x821A01B0 => {
    //   block [0x821A01B0..0x821A01E8)
	// 821A01B0: 816F0004  lwz r11, 4(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A01B4: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821A01B8: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821A01BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A01C0: 409A0094  bne cr6, 0x821a0254
	if !ctx.cr[6].eq {
	pc = 0x821A0254; continue 'dispatch;
	}
	// 821A01C4: 896F0021  lbz r11, 0x21(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(33 as u32) ) } as u64;
	// 821A01C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A01CC: 409A001C  bne cr6, 0x821a01e8
	if !ctx.cr[6].eq {
	pc = 0x821A01E8; continue 'dispatch;
	}
	// 821A01D0: 896F0022  lbz r11, 0x22(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(34 as u32) ) } as u64;
	// 821A01D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A01D8: 409A0010  bne cr6, 0x821a01e8
	if !ctx.cr[6].eq {
	pc = 0x821A01E8; continue 'dispatch;
	}
	// 821A01DC: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 821A01E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A01E4: 419A0070  beq cr6, 0x821a0254
	if ctx.cr[6].eq {
	pc = 0x821A0254; continue 'dispatch;
	}
	pc = 0x821A01E8; continue 'dispatch;
            }
            0x821A01E8 => {
    //   block [0x821A01E8..0x821A024C)
	// 821A01E8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821A01EC: 816B6AF0  lwz r11, 0x6af0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27376 as u32) ) } as u64;
	// 821A01F0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821A01F4: 419A0060  beq cr6, 0x821a0254
	if ctx.cr[6].eq {
	pc = 0x821A0254; continue 'dispatch;
	}
	// 821A01F8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821A01FC: 814F0064  lwz r10, 0x64(r15)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(100 as u32) ) } as u64;
	// 821A0200: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 821A0204: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 821A0208: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821A020C: C8099660  lfd f0, -0x69a0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-27040 as u32) ) };
	// 821A0210: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 821A0214: C9A81718  lfd f13, 0x1718(r8)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(5912 as u32) ) };
	// 821A0218: F8E100C0  std r7, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[7].u64 ) };
	// 821A021C: C98100C0  lfd f12, 0xc0(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 821A0220: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 821A0224: FD405B7C  fnmsub f10, f0, f13, f11
	ctx.f[10].f64 = -(ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[11].f64);
	// 821A0228: FD20501E  fctiwz f9, f10
	ctx.f[9].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 821A022C: D92100C0  stfd f9, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.f[9].u64 ) };
	// 821A0230: 80C100C4  lwz r6, 0xc4(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 821A0234: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821A0238: 40990014  ble cr6, 0x821a024c
	if !ctx.cr[6].gt {
	pc = 0x821A024C; continue 'dispatch;
	}
	// 821A023C: 896F0068  lbz r11, 0x68(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(104 as u32) ) } as u64;
	// 821A0240: 894F0024  lbz r10, 0x24(r15)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A0244: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A0248: 419A000C  beq cr6, 0x821a0254
	if ctx.cr[6].eq {
	pc = 0x821A0254; continue 'dispatch;
	}
	pc = 0x821A024C; continue 'dispatch;
            }
            0x821A024C => {
    //   block [0x821A024C..0x821A0254)
	// 821A024C: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 821A0250: 4811A689  bl 0x822ba8d8
	ctx.lr = 0x821A0254;
	sub_822BA8D8(ctx, base);
	pc = 0x821A0254; continue 'dispatch;
            }
            0x821A0254 => {
    //   block [0x821A0254..0x821A0264)
	// 821A0254: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 821A0258: CBC1FF58  lfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 821A025C: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 821A0260: 48B091C0  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A0298 size=2240
    let mut pc: u32 = 0x821A0298;
    'dispatch: loop {
        match pc {
            0x821A0298 => {
    //   block [0x821A0298..0x821A0B58)
	// 821A0298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A029C: 48B0915D  bl 0x82ca93f8
	ctx.lr = 0x821A02A0;
	sub_82CA93D0(ctx, base);
	// 821A02A0: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 821A02A4: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A0B58 size=216
    let mut pc: u32 = 0x821A0B58;
    'dispatch: loop {
        match pc {
            0x821A0B58 => {
    //   block [0x821A0B58..0x821A0B88)
	// 821A0B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A0B5C: 48B088A9  bl 0x82ca9404
	ctx.lr = 0x821A0B60;
	sub_82CA93D0(ctx, base);
	// 821A0B60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0B64: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A0B68: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821A0B6C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A0B70: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821A0B74: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 821A0B78: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 821A0B7C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A0B80: 40990008  ble cr6, 0x821a0b88
	if !ctx.cr[6].gt {
	pc = 0x821A0B88; continue 'dispatch;
	}
	// 821A0B84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A0B88; continue 'dispatch;
            }
            0x821A0B88 => {
    //   block [0x821A0B88..0x821A0B8C)
	// 821A0B88: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	pc = 0x821A0B8C; continue 'dispatch;
            }
            0x821A0B8C => {
    //   block [0x821A0B8C..0x821A0BA0)
	// 821A0B8C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A0B90: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A0B94: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A0B98: 40990008  ble cr6, 0x821a0ba0
	if !ctx.cr[6].gt {
	pc = 0x821A0BA0; continue 'dispatch;
	}
	// 821A0B9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A0BA0; continue 'dispatch;
            }
            0x821A0BA0 => {
    //   block [0x821A0BA0..0x821A0BAC)
	// 821A0BA0: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A0BA4: 419A0008  beq cr6, 0x821a0bac
	if ctx.cr[6].eq {
	pc = 0x821A0BAC; continue 'dispatch;
	}
	// 821A0BA8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A0BAC; continue 'dispatch;
            }
            0x821A0BAC => {
    //   block [0x821A0BAC..0x821A0BC0)
	// 821A0BAC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A0BB0: 419A0078  beq cr6, 0x821a0c28
	if ctx.cr[6].eq {
	pc = 0x821A0C28; continue 'dispatch;
	}
	// 821A0BB4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A0BB8: 41980008  blt cr6, 0x821a0bc0
	if ctx.cr[6].lt {
	pc = 0x821A0BC0; continue 'dispatch;
	}
	// 821A0BBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A0BC0; continue 'dispatch;
            }
            0x821A0BC0 => {
    //   block [0x821A0BC0..0x821A0C04)
	// 821A0BC0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A0BC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A0BC8: 419A003C  beq cr6, 0x821a0c04
	if ctx.cr[6].eq {
	pc = 0x821A0C04; continue 'dispatch;
	}
	// 821A0BCC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A0BD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A0BD4: 419A0048  beq cr6, 0x821a0c1c
	if ctx.cr[6].eq {
	pc = 0x821A0C1C; continue 'dispatch;
	}
	// 821A0BD8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A0BDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A0BE0: 419A0024  beq cr6, 0x821a0c04
	if ctx.cr[6].eq {
	pc = 0x821A0C04; continue 'dispatch;
	}
	// 821A0BE4: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A0BE8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 821A0BEC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821A0BF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A0BF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A0BF8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A0BFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A0C00: 4E800421  bctrl
	ctx.lr = 0x821A0C04;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A0C04 => {
    //   block [0x821A0C04..0x821A0C14)
	// 821A0C04: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A0C08: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A0C0C: 41980008  blt cr6, 0x821a0c14
	if ctx.cr[6].lt {
	pc = 0x821A0C14; continue 'dispatch;
	}
	// 821A0C10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A0C14; continue 'dispatch;
            }
            0x821A0C14 => {
    //   block [0x821A0C14..0x821A0C1C)
	// 821A0C14: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 821A0C18: 4BFFFF74  b 0x821a0b8c
	pc = 0x821A0B8C; continue 'dispatch;
            }
            0x821A0C1C => {
    //   block [0x821A0C1C..0x821A0C28)
	// 821A0C1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A0C20: 4BFF3219  bl 0x82193e38
	ctx.lr = 0x821A0C24;
	sub_82193E38(ctx, base);
	// 821A0C24: 4BFFFFE0  b 0x821a0c04
	pc = 0x821A0C04; continue 'dispatch;
            }
            0x821A0C28 => {
    //   block [0x821A0C28..0x821A0C30)
	// 821A0C28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A0C2C: 48B08828  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A0C30 size=540
    let mut pc: u32 = 0x821A0C30;
    'dispatch: loop {
        match pc {
            0x821A0C30 => {
    //   block [0x821A0C30..0x821A0E4C)
	// 821A0C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A0C34: 48B087D1  bl 0x82ca9404
	ctx.lr = 0x821A0C38;
	sub_82CA93D0(ctx, base);
	// 821A0C38: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821A0C3C: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0E50 size=172
    let mut pc: u32 = 0x821A0E50;
    'dispatch: loop {
        match pc {
            0x821A0E50 => {
    //   block [0x821A0E50..0x821A0E7C)
	// 821A0E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A0E54: 48B085B9  bl 0x82ca940c
	ctx.lr = 0x821A0E58;
	sub_82CA93D0(ctx, base);
	// 821A0E58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0E5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A0E60: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821A0E64: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 821A0E68: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A0E6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A0E70: 409A000C  bne cr6, 0x821a0e7c
	if !ctx.cr[6].eq {
	pc = 0x821A0E7C; continue 'dispatch;
	}
	// 821A0E74: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0E78: 48000010  b 0x821a0e88
	pc = 0x821A0E88; continue 'dispatch;
            }
            0x821A0E7C => {
    //   block [0x821A0E7C..0x821A0E88)
	// 821A0E7C: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A0E80: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821A0E84: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x821A0E88; continue 'dispatch;
            }
            0x821A0E88 => {
    //   block [0x821A0E88..0x821A0EC4)
	// 821A0E88: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A0E8C: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 821A0E90: 7D2B4BD6  divw r9, r11, r9
	ctx.r[9].s32 = ctx.r[11].s32 / ctx.r[9].s32;
	// 821A0E94: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A0E98: 4098003C  bge cr6, 0x821a0ed4
	if !ctx.cr[6].lt {
	pc = 0x821A0ED4; continue 'dispatch;
	}
	// 821A0E9C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A0EA0: 419A0024  beq cr6, 0x821a0ec4
	if ctx.cr[6].eq {
	pc = 0x821A0EC4; continue 'dispatch;
	}
	// 821A0EA4: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A0EA8: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 821A0EAC: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A0EB0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 821A0EB4: 4804F38D  bl 0x821f0240
	ctx.lr = 0x821A0EB8;
	sub_821F0240(ctx, base);
	// 821A0EB8: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 821A0EBC: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 821A0EC0: 4804F381  bl 0x821f0240
	ctx.lr = 0x821A0EC4;
	sub_821F0240(ctx, base);
	pc = 0x821A0EC4; continue 'dispatch;
            }
            0x821A0EC4 => {
    //   block [0x821A0EC4..0x821A0ED4)
	// 821A0EC4: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 821A0EC8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821A0ECC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A0ED0: 48B0858C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A0ED4 => {
    //   block [0x821A0ED4..0x821A0EFC)
	// 821A0ED4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A0ED8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821A0EDC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821A0EE0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821A0EE4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821A0EE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A0EEC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A0EF0: 48043089  bl 0x821e3f78
	ctx.lr = 0x821A0EF4;
	sub_821E3F78(ctx, base);
	// 821A0EF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A0EF8: 48B08564  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A0F00 size=380
    let mut pc: u32 = 0x821A0F00;
    'dispatch: loop {
        match pc {
            0x821A0F00 => {
    //   block [0x821A0F00..0x821A0F54)
	// 821A0F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A0F04: 48B08505  bl 0x82ca9408
	ctx.lr = 0x821A0F08;
	sub_82CA93D0(ctx, base);
	// 821A0F08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0F0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A0F10: 909F0074  stw r4, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[4].u32 ) };
	// 821A0F14: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A0F18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A0F1C: 419A0148  beq cr6, 0x821a1064
	if ctx.cr[6].eq {
	pc = 0x821A1064; continue 'dispatch;
	}
	// 821A0F20: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A0F24: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821A0F28: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821A0F2C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A0F30: 40980134  bge cr6, 0x821a1064
	if !ctx.cr[6].lt {
	pc = 0x821A1064; continue 'dispatch;
	}
	// 821A0F34: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A0F38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A0F3C: 419A0018  beq cr6, 0x821a0f54
	if ctx.cr[6].eq {
	pc = 0x821A0F54; continue 'dispatch;
	}
	// 821A0F40: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A0F44: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821A0F48: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821A0F4C: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A0F50: 41980008  blt cr6, 0x821a0f58
	if ctx.cr[6].lt {
	pc = 0x821A0F58; continue 'dispatch;
	}
	pc = 0x821A0F54; continue 'dispatch;
            }
            0x821A0F54 => {
    //   block [0x821A0F54..0x821A0F58)
	// 821A0F54: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A0F58; continue 'dispatch;
            }
            0x821A0F58 => {
    //   block [0x821A0F58..0x821A0FE4)
	// 821A0F58: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A0F5C: 3BDF0064  addi r30, r31, 0x64
	ctx.r[30].s64 = ctx.r[31].s64 + 100;
	// 821A0F60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821A0F64: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821A0F68: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A0F6C: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A0F70: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821A0F74: 4E800421  bctrl
	ctx.lr = 0x821A0F78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A0F78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A0F7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A0F80: 4BFDA419  bl 0x8217b398
	ctx.lr = 0x821A0F84;
	sub_8217B398(ctx, base);
	// 821A0F84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821A0F88: 48016B91  bl 0x821b7b18
	ctx.lr = 0x821A0F8C;
	sub_821B7B18(ctx, base);
	// 821A0F8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A0F90: 83BF003C  lwz r29, 0x3c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 821A0F94: 839F0064  lwz r28, 0x64(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 821A0F98: 4BFD34D1  bl 0x82174468
	ctx.lr = 0x821A0F9C;
	sub_82174468(ctx, base);
	// 821A0F9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A0FA0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821A0FA4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821A0FA8: 480154B1  bl 0x821b6458
	ctx.lr = 0x821A0FAC;
	sub_821B6458(ctx, base);
	// 821A0FAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 821A0FB0: 4807E2A9  bl 0x8221f258
	ctx.lr = 0x821A0FB4;
	sub_8221F258(ctx, base);
	// 821A0FB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A0FB8: 419A002C  beq cr6, 0x821a0fe4
	if ctx.cr[6].eq {
	pc = 0x821A0FE4; continue 'dispatch;
	}
	// 821A0FBC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A0FC0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821A0FC4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0FC8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 821A0FCC: 390A1D24  addi r8, r10, 0x1d24
	ctx.r[8].s64 = ctx.r[10].s64 + 7460;
	// 821A0FD0: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821A0FD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A0FD8: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A0FDC: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821A0FE0: 48000008  b 0x821a0fe8
	pc = 0x821A0FE8; continue 'dispatch;
            }
            0x821A0FE4 => {
    //   block [0x821A0FE4..0x821A0FE8)
	// 821A0FE4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x821A0FE8; continue 'dispatch;
            }
            0x821A0FE8 => {
    //   block [0x821A0FE8..0x821A1020)
	// 821A0FE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821A0FEC: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A0FF0: 4801AAC1  bl 0x821bbab0
	ctx.lr = 0x821A0FF4;
	sub_821BBAB0(ctx, base);
	// 821A0FF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A0FF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A0FFC: 480CAE6D  bl 0x8226be68
	ctx.lr = 0x821A1000;
	sub_8226BE68(ctx, base);
	// 821A1000: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821A1004: 48016B15  bl 0x821b7b18
	ctx.lr = 0x821A1008;
	sub_821B7B18(ctx, base);
	// 821A1008: 897F007C  lbz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821A100C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1010: 419A0010  beq cr6, 0x821a1020
	if ctx.cr[6].eq {
	pc = 0x821A1020; continue 'dispatch;
	}
	// 821A1014: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1018: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821A101C: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	pc = 0x821A1020; continue 'dispatch;
            }
            0x821A1020 => {
    //   block [0x821A1020..0x821A1038)
	// 821A1020: 897F0050  lbz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1028: 419A0010  beq cr6, 0x821a1038
	if ctx.cr[6].eq {
	pc = 0x821A1038; continue 'dispatch;
	}
	// 821A102C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1030: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A1034: 994B0050  stb r10, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	pc = 0x821A1038; continue 'dispatch;
            }
            0x821A1038 => {
    //   block [0x821A1038..0x821A1064)
	// 821A1038: 897F0052  lbz r11, 0x52(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(82 as u32) ) } as u64;
	// 821A103C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1040: 419A0034  beq cr6, 0x821a1074
	if ctx.cr[6].eq {
	pc = 0x821A1074; continue 'dispatch;
	}
	// 821A1044: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1048: 894B0052  lbz r10, 0x52(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(82 as u32) ) } as u64;
	// 821A104C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A1050: 409A0024  bne cr6, 0x821a1074
	if !ctx.cr[6].eq {
	pc = 0x821A1074; continue 'dispatch;
	}
	// 821A1054: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A1058: 997F0052  stb r11, 0x52(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 821A105C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A1060: 48B083F8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A1064 => {
    //   block [0x821A1064..0x821A1074)
	// 821A1064: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 821A1068: 48016AB1  bl 0x821b7b18
	ctx.lr = 0x821A106C;
	sub_821B7B18(ctx, base);
	// 821A106C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A1070: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	pc = 0x821A1074; continue 'dispatch;
            }
            0x821A1074 => {
    //   block [0x821A1074..0x821A107C)
	// 821A1074: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A1078: 48B083E0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A1080 size=192
    let mut pc: u32 = 0x821A1080;
    'dispatch: loop {
        match pc {
            0x821A1080 => {
    //   block [0x821A1080..0x821A10B4)
	// 821A1080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A1084: 48B08385  bl 0x82ca9408
	ctx.lr = 0x821A1088;
	sub_82CA93D0(ctx, base);
	// 821A1088: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A108C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821A1090: 3BBC0038  addi r29, r28, 0x38
	ctx.r[29].s64 = ctx.r[28].s64 + 56;
	// 821A1094: C01C0020  lfs f0, 0x20(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1098: D01C0024  stfs f0, 0x24(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821A109C: D03C0020  stfs f1, 0x20(r28)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821A10A0: 83DC003C  lwz r30, 0x3c(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 821A10A4: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A10A8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A10AC: 40990008  ble cr6, 0x821a10b4
	if !ctx.cr[6].gt {
	pc = 0x821A10B4; continue 'dispatch;
	}
	// 821A10B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A10B4; continue 'dispatch;
            }
            0x821A10B4 => {
    //   block [0x821A10B4..0x821A10C8)
	// 821A10B4: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A10B8: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A10BC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A10C0: 40990008  ble cr6, 0x821a10c8
	if !ctx.cr[6].gt {
	pc = 0x821A10C8; continue 'dispatch;
	}
	// 821A10C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A10C8; continue 'dispatch;
            }
            0x821A10C8 => {
    //   block [0x821A10C8..0x821A10D4)
	// 821A10C8: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821A10CC: 419A0008  beq cr6, 0x821a10d4
	if ctx.cr[6].eq {
	pc = 0x821A10D4; continue 'dispatch;
	}
	// 821A10D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A10D4; continue 'dispatch;
            }
            0x821A10D4 => {
    //   block [0x821A10D4..0x821A10E8)
	// 821A10D4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A10D8: 419A0060  beq cr6, 0x821a1138
	if ctx.cr[6].eq {
	pc = 0x821A1138; continue 'dispatch;
	}
	// 821A10DC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A10E0: 41980008  blt cr6, 0x821a10e8
	if ctx.cr[6].lt {
	pc = 0x821A10E8; continue 'dispatch;
	}
	// 821A10E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A10E8; continue 'dispatch;
            }
            0x821A10E8 => {
    //   block [0x821A10E8..0x821A1120)
	// 821A10E8: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A10EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A10F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A10F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A10F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A10FC: 4E800421  bctrl
	ctx.lr = 0x821A1100;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A1100: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 821A1104: 409A001C  bne cr6, 0x821a1120
	if !ctx.cr[6].eq {
	pc = 0x821A1120; continue 'dispatch;
	}
	// 821A1108: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A110C: C03C0020  lfs f1, 0x20(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A1110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A1114: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A1118: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A111C: 4E800421  bctrl
	ctx.lr = 0x821A1120;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A1120 => {
    //   block [0x821A1120..0x821A1130)
	// 821A1120: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A1124: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1128: 41980008  blt cr6, 0x821a1130
	if ctx.cr[6].lt {
	pc = 0x821A1130; continue 'dispatch;
	}
	// 821A112C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A1130; continue 'dispatch;
            }
            0x821A1130 => {
    //   block [0x821A1130..0x821A1138)
	// 821A1130: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 821A1134: 4BFFFF80  b 0x821a10b4
	pc = 0x821A10B4; continue 'dispatch;
            }
            0x821A1138 => {
    //   block [0x821A1138..0x821A1140)
	// 821A1138: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A113C: 48B0831C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A1140 size=176
    let mut pc: u32 = 0x821A1140;
    'dispatch: loop {
        match pc {
            0x821A1140 => {
    //   block [0x821A1140..0x821A11A0)
	// 821A1140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A1144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A1148: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A114C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A1150: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821A1154: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A1158: 894B9409  lbz r10, -0x6bf7(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-27639 as u32) ) } as u64;
	// 821A115C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A1160: 419A007C  beq cr6, 0x821a11dc
	if ctx.cr[6].eq {
	pc = 0x821A11DC; continue 'dispatch;
	}
	// 821A1164: 897F0065  lbz r11, 0x65(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(101 as u32) ) } as u64;
	// 821A1168: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A116C: 41980070  blt cr6, 0x821a11dc
	if ctx.cr[6].lt {
	pc = 0x821A11DC; continue 'dispatch;
	}
	// 821A1170: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821A1174: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821A1178: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A117C: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A1180: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1184: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1188: 54EA003E  slwi r10, r7, 0
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A118C: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1190: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A1194: 409A000C  bne cr6, 0x821a11a0
	if !ctx.cr[6].eq {
	pc = 0x821A11A0; continue 'dispatch;
	}
	// 821A1198: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821A119C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A11A0; continue 'dispatch;
            }
            0x821A11A0 => {
    //   block [0x821A11A0..0x821A11DC)
	// 821A11A0: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A11A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A11A8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A11AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A11B0: 4E800421  bctrl
	ctx.lr = 0x821A11B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A11B4: 2F030007  cmpwi cr6, r3, 7
	ctx.cr[6].compare_i32(ctx.r[3].s32, 7, &mut ctx.xer);
	// 821A11B8: 419A0024  beq cr6, 0x821a11dc
	if ctx.cr[6].eq {
	pc = 0x821A11DC; continue 'dispatch;
	}
	// 821A11BC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A11C0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821A11C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A11C8: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A11CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A11D0: 4E800421  bctrl
	ctx.lr = 0x821A11D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A11D4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A11D8: 993F0064  stb r9, 0x64(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[9].u8 ) };
            }
            0x821A11DC => {
    //   block [0x821A11DC..0x821A11F0)
	// 821A11DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A11E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A11E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A11E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A11EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A11F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A11F0 size=144
    let mut pc: u32 = 0x821A11F0;
    'dispatch: loop {
        match pc {
            0x821A11F0 => {
    //   block [0x821A11F0..0x821A1228)
	// 821A11F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A11F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A11F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A11FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A1200: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A1204: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1208: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821A120C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1210: 419A001C  beq cr6, 0x821a122c
	if ctx.cr[6].eq {
	pc = 0x821A122C; continue 'dispatch;
	}
	// 821A1214: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1218: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A121C: 419A000C  beq cr6, 0x821a1228
	if ctx.cr[6].eq {
	pc = 0x821A1228; continue 'dispatch;
	}
	// 821A1220: 555E003E  slwi r30, r10, 0
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821A1224: 4800000C  b 0x821a1230
	pc = 0x821A1230; continue 'dispatch;
            }
            0x821A1228 => {
    //   block [0x821A1228..0x821A122C)
	// 821A1228: 4BFF2C11  bl 0x82193e38
	ctx.lr = 0x821A122C;
	sub_82193E38(ctx, base);
	pc = 0x821A122C; continue 'dispatch;
            }
            0x821A122C => {
    //   block [0x821A122C..0x821A1230)
	// 821A122C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x821A1230; continue 'dispatch;
            }
            0x821A1230 => {
    //   block [0x821A1230..0x821A1250)
	// 821A1230: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1238: 419A0020  beq cr6, 0x821a1258
	if ctx.cr[6].eq {
	pc = 0x821A1258; continue 'dispatch;
	}
	// 821A123C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1240: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A1244: 419A000C  beq cr6, 0x821a1250
	if ctx.cr[6].eq {
	pc = 0x821A1250; continue 'dispatch;
	}
	// 821A1248: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A124C: 48000010  b 0x821a125c
	pc = 0x821A125C; continue 'dispatch;
            }
            0x821A1250 => {
    //   block [0x821A1250..0x821A1258)
	// 821A1250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A1254: 4BFF2BE5  bl 0x82193e38
	ctx.lr = 0x821A1258;
	sub_82193E38(ctx, base);
	pc = 0x821A1258; continue 'dispatch;
            }
            0x821A1258 => {
    //   block [0x821A1258..0x821A125C)
	// 821A1258: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821A125C; continue 'dispatch;
            }
            0x821A125C => {
    //   block [0x821A125C..0x821A1280)
	// 821A125C: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 821A1260: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821A1264: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821A1268: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A126C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A1270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A1274: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A1278: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A127C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A1280 size=252
    let mut pc: u32 = 0x821A1280;
    'dispatch: loop {
        match pc {
            0x821A1280 => {
    //   block [0x821A1280..0x821A12AC)
	// 821A1280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A1284: 48B08185  bl 0x82ca9408
	ctx.lr = 0x821A1288;
	sub_82CA93D0(ctx, base);
	// 821A1288: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A128C: F8810098  std r4, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[4].u64 ) };
	// 821A1290: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A1294: F8A100A0  std r5, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[5].u64 ) };
	// 821A1298: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821A129C: 83E1009C  lwz r31, 0x9c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 821A12A0: 838100A4  lwz r28, 0xa4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 821A12A4: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821A12A8: 419A008C  beq cr6, 0x821a1334
	if ctx.cr[6].eq {
	pc = 0x821A1334; continue 'dispatch;
	}
	pc = 0x821A12AC; continue 'dispatch;
            }
            0x821A12AC => {
    //   block [0x821A12AC..0x821A12C4)
	// 821A12AC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A12B0: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A12B4: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821A12B8: 409A000C  bne cr6, 0x821a12c4
	if !ctx.cr[6].eq {
	pc = 0x821A12C4; continue 'dispatch;
	}
	// 821A12BC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A12C0: 48000020  b 0x821a12e0
	pc = 0x821A12E0; continue 'dispatch;
            }
            0x821A12C4 => {
    //   block [0x821A12C4..0x821A12DC)
	// 821A12C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A12C8: 419A0014  beq cr6, 0x821a12dc
	if ctx.cr[6].eq {
	pc = 0x821A12DC; continue 'dispatch;
	}
	// 821A12CC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A12D0: 419A000C  beq cr6, 0x821a12dc
	if ctx.cr[6].eq {
	pc = 0x821A12DC; continue 'dispatch;
	}
	// 821A12D4: 480CC4BD  bl 0x8226d790
	ctx.lr = 0x821A12D8;
	sub_8226D790(ctx, base);
	// 821A12D8: 48000008  b 0x821a12e0
	pc = 0x821A12E0; continue 'dispatch;
            }
            0x821A12DC => {
    //   block [0x821A12DC..0x821A12E0)
	// 821A12DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821A12E0; continue 'dispatch;
            }
            0x821A12E0 => {
    //   block [0x821A12E0..0x821A130C)
	// 821A12E0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821A12E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A12E8: 419A002C  beq cr6, 0x821a1314
	if ctx.cr[6].eq {
	pc = 0x821A1314; continue 'dispatch;
	}
	// 821A12EC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A12F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A12F4: 419A0018  beq cr6, 0x821a130c
	if ctx.cr[6].eq {
	pc = 0x821A130C; continue 'dispatch;
	}
	// 821A12F8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 821A12FC: 4BFD2B3D  bl 0x82173e38
	ctx.lr = 0x821A1300;
	sub_82173E38(ctx, base);
	// 821A1300: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1304: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821A1308: 409A000C  bne cr6, 0x821a1314
	if !ctx.cr[6].eq {
	pc = 0x821A1314; continue 'dispatch;
	}
	pc = 0x821A130C; continue 'dispatch;
            }
            0x821A130C => {
    //   block [0x821A130C..0x821A1314)
	// 821A130C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A1310: 48000008  b 0x821a1318
	pc = 0x821A1318; continue 'dispatch;
            }
            0x821A1314 => {
    //   block [0x821A1314..0x821A1318)
	// 821A1314: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821A1318; continue 'dispatch;
            }
            0x821A1318 => {
    //   block [0x821A1318..0x821A1334)
	// 821A1318: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A131C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1320: 409A0014  bne cr6, 0x821a1334
	if !ctx.cr[6].eq {
	pc = 0x821A1334; continue 'dispatch;
	}
	// 821A1324: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 821A1328: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 821A132C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821A1330: 409AFF7C  bne cr6, 0x821a12ac
	if !ctx.cr[6].eq {
	pc = 0x821A12AC; continue 'dispatch;
	}
	pc = 0x821A1334; continue 'dispatch;
            }
            0x821A1334 => {
    //   block [0x821A1334..0x821A134C)
	// 821A1334: E9610098  ld r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 821A1338: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 821A133C: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821A1340: 48025429  bl 0x821c6768
	ctx.lr = 0x821A1344;
	sub_821C6768(ctx, base);
	// 821A1344: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821A1348: 38EA7088  addi r7, r10, 0x7088
	ctx.r[7].s64 = ctx.r[10].s64 + 28808;
	pc = 0x821A134C; continue 'dispatch;
            }
            0x821A134C => {
    //   block [0x821A134C..0x821A137C)
	// 821A134C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 821A1350: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A1354: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 821A1358: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821A135C: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821A1360: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A1364: 4082FFE8  bne 0x821a134c
	if !ctx.cr[0].eq {
	pc = 0x821A134C; continue 'dispatch;
	}
	// 821A1368: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A136C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A1370: 90DE0004  stw r6, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821A1374: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A1378: 48B080E0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A1380 size=244
    let mut pc: u32 = 0x821A1380;
    'dispatch: loop {
        match pc {
            0x821A1380 => {
    //   block [0x821A1380..0x821A1474)
	// 821A1380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A1384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A1388: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A138C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A1390: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A1394: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821A1398: 38E00050  li r7, 0x50
	ctx.r[7].s64 = 80;
	// 821A139C: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 821A13A0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 821A13A4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A13A8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A13AC: 38CA2028  addi r6, r10, 0x2028
	ctx.r[6].s64 = ctx.r[10].s64 + 8232;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A1478 size=92
    let mut pc: u32 = 0x821A1478;
    'dispatch: loop {
        match pc {
            0x821A1478 => {
    //   block [0x821A1478..0x821A14C0)
	// 821A1478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A147C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A1480: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A1484: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1488: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821A148C: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A1490: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1494: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A1498: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A149C: 91280008  stw r9, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821A14A0: 80E4000C  lwz r7, 0xc(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A14A4: 90E8000C  stw r7, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 821A14A8: 80C40010  lwz r6, 0x10(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A14AC: 90C80010  stw r6, 0x10(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 821A14B0: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A14B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A14B8: 419A0008  beq cr6, 0x821a14c0
	if ctx.cr[6].eq {
	pc = 0x821A14C0; continue 'dispatch;
	}
	// 821A14BC: 4805ACBD  bl 0x821fc178
	ctx.lr = 0x821A14C0;
	sub_821FC178(ctx, base);
	pc = 0x821A14C0; continue 'dispatch;
            }
            0x821A14C0 => {
    //   block [0x821A14C0..0x821A14D4)
	// 821A14C0: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 821A14C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A14C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A14CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A14D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A14D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A14D8 size=196
    let mut pc: u32 = 0x821A14D8;
    'dispatch: loop {
        match pc {
            0x821A14D8 => {
    //   block [0x821A14D8..0x821A1518)
	// 821A14D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A14DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A14E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A14E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A14E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A14EC: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A14F0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A14F4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A14F8: 409A0020  bne cr6, 0x821a1518
	if !ctx.cr[6].eq {
	pc = 0x821A1518; continue 'dispatch;
	}
	// 821A14FC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1500: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 821A1504: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 821A1508: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821A150C: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 821A1510: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A1514: 48BB3DB5  bl 0x82d552c8
	ctx.lr = 0x821A1518;
	sub_82D552C8(ctx, base);
	pc = 0x821A1518; continue 'dispatch;
            }
            0x821A1518 => {
    //   block [0x821A1518..0x821A1550)
	// 821A1518: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A151C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1520: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A1524: 409A002C  bne cr6, 0x821a1550
	if !ctx.cr[6].eq {
	pc = 0x821A1550; continue 'dispatch;
	}
	// 821A1528: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 821A152C: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1530: 556B087C  rlwinm r11, r11, 1, 1, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 821A1534: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A1538: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 821A153C: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A1540: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 821A1544: 54E52036  slwi r5, r7, 4
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821A1548: 7C68482E  lwzx r3, r8, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A154C: 48BB3D7D  bl 0x82d552c8
	ctx.lr = 0x821A1550;
	sub_82D552C8(ctx, base);
	pc = 0x821A1550; continue 'dispatch;
            }
            0x821A1550 => {
    //   block [0x821A1550..0x821A1588)
	// 821A1550: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A1554: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1558: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A155C: 409A002C  bne cr6, 0x821a1588
	if !ctx.cr[6].eq {
	pc = 0x821A1588; continue 'dispatch;
	}
	// 821A1560: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 821A1564: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1568: 556B087C  rlwinm r11, r11, 1, 1, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 821A156C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1570: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 821A1574: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A1578: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 821A157C: 54E52036  slwi r5, r7, 4
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821A1580: 7C68482E  lwzx r3, r8, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A1584: 48BB3D45  bl 0x82d552c8
	ctx.lr = 0x821A1588;
	sub_82D552C8(ctx, base);
	pc = 0x821A1588; continue 'dispatch;
            }
            0x821A1588 => {
    //   block [0x821A1588..0x821A159C)
	// 821A1588: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A158C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A1590: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A1594: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A1598: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A15A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A15A0 size=352
    let mut pc: u32 = 0x821A15A0;
    'dispatch: loop {
        match pc {
            0x821A15A0 => {
    //   block [0x821A15A0..0x821A15D0)
	// 821A15A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A15A4: 48B07E61  bl 0x82ca9404
	ctx.lr = 0x821A15A8;
	sub_82CA93D0(ctx, base);
	// 821A15A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A15AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A15B0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821A15B4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821A15B8: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 821A15BC: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A15C0: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 821A15C4: 4198000C  blt cr6, 0x821a15d0
	if ctx.cr[6].lt {
	pc = 0x821A15D0; continue 'dispatch;
	}
	// 821A15C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A15CC: 48000008  b 0x821a15d4
	pc = 0x821A15D4; continue 'dispatch;
            }
            0x821A15D0 => {
    //   block [0x821A15D0..0x821A15D4)
	// 821A15D0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821A15D4; continue 'dispatch;
            }
            0x821A15D4 => {
    //   block [0x821A15D4..0x821A15EC)
	// 821A15D4: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A15D8: 4198002C  blt cr6, 0x821a1604
	if ctx.cr[6].lt {
	pc = 0x821A1604; continue 'dispatch;
	}
	// 821A15DC: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 821A15E0: 4198000C  blt cr6, 0x821a15ec
	if ctx.cr[6].lt {
	pc = 0x821A15EC; continue 'dispatch;
	}
	// 821A15E4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A15E8: 48000008  b 0x821a15f0
	pc = 0x821A15F0; continue 'dispatch;
            }
            0x821A15EC => {
    //   block [0x821A15EC..0x821A15F0)
	// 821A15EC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821A15F0; continue 'dispatch;
            }
            0x821A15F0 => {
    //   block [0x821A15F0..0x821A1604)
	// 821A15F0: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A15F4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A15F8: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821A15FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A1600: 41990008  bgt cr6, 0x821a1608
	if ctx.cr[6].gt {
	pc = 0x821A1608; continue 'dispatch;
	}
	pc = 0x821A1604; continue 'dispatch;
            }
            0x821A1604 => {
    //   block [0x821A1604..0x821A1608)
	// 821A1604: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821A1608; continue 'dispatch;
            }
            0x821A1608 => {
    //   block [0x821A1608..0x821A1624)
	// 821A1608: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A160C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1610: 419A0034  beq cr6, 0x821a1644
	if ctx.cr[6].eq {
	pc = 0x821A1644; continue 'dispatch;
	}
	// 821A1614: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 821A1618: 4198000C  blt cr6, 0x821a1624
	if ctx.cr[6].lt {
	pc = 0x821A1624; continue 'dispatch;
	}
	// 821A161C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1620: 48000008  b 0x821a1628
	pc = 0x821A1628; continue 'dispatch;
            }
            0x821A1624 => {
    //   block [0x821A1624..0x821A1628)
	// 821A1624: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821A1628; continue 'dispatch;
            }
            0x821A1628 => {
    //   block [0x821A1628..0x821A1644)
	// 821A1628: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821A162C: 7CABD850  subf r5, r11, r27
	ctx.r[5].s64 = ctx.r[27].s64 - ctx.r[11].s64;
	// 821A1630: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A1634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A1638: 481E28A1  bl 0x82383ed8
	ctx.lr = 0x821A163C;
	sub_82383ED8(ctx, base);
	// 821A163C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A1640: 48B07E14  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A1644 => {
    //   block [0x821A1644..0x821A1660)
	// 821A1644: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A1648: 214BFFFF  subfic r10, r11, -1
	ctx.xer.ca = ctx.r[11].u32 <= -1 as u32;
	ctx.r[10].s64 = (-1 as i64) - ctx.r[11].s64;
	// 821A164C: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821A1650: 40990010  ble cr6, 0x821a1660
	if !ctx.cr[6].gt {
	pc = 0x821A1660; continue 'dispatch;
	}
	// 821A1654: 7D4BE214  add r10, r11, r28
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821A1658: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A165C: 40980008  bge cr6, 0x821a1664
	if !ctx.cr[6].lt {
	pc = 0x821A1664; continue 'dispatch;
	}
	pc = 0x821A1660; continue 'dispatch;
            }
            0x821A1660 => {
    //   block [0x821A1660..0x821A1664)
	// 821A1660: 48B363D1  bl 0x82cd7a30
	ctx.lr = 0x821A1664;
	sub_82CD7A30(ctx, base);
	pc = 0x821A1664; continue 'dispatch;
            }
            0x821A1664 => {
    //   block [0x821A1664..0x821A16A4)
	// 821A1664: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821A1668: 419A008C  beq cr6, 0x821a16f4
	if ctx.cr[6].eq {
	pc = 0x821A16F4; continue 'dispatch;
	}
	// 821A166C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A1670: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A1674: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A1678: 7FDC5A14  add r30, r28, r11
	ctx.r[30].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 821A167C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A1680: 48007BB1  bl 0x821a9230
	ctx.lr = 0x821A1684;
	sub_821A9230(ctx, base);
	// 821A1684: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821A1688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A168C: 419A0068  beq cr6, 0x821a16f4
	if ctx.cr[6].eq {
	pc = 0x821A16F4; continue 'dispatch;
	}
	// 821A1690: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A1694: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 821A1698: 4198000C  blt cr6, 0x821a16a4
	if ctx.cr[6].lt {
	pc = 0x821A16A4; continue 'dispatch;
	}
	// 821A169C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A16A0: 48000008  b 0x821a16a8
	pc = 0x821A16A8; continue 'dispatch;
            }
            0x821A16A4 => {
    //   block [0x821A16A4..0x821A16A8)
	// 821A16A4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x821A16A8; continue 'dispatch;
            }
            0x821A16A8 => {
    //   block [0x821A16A8..0x821A16E8)
	// 821A16A8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A16AC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821A16B0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821A16B4: 7C8B4850  subf r4, r11, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 821A16B8: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A16BC: 48B08895  bl 0x82ca9f50
	ctx.lr = 0x821A16C0;
	sub_82CA9F50(ctx, base);
	// 821A16C0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A16C4: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 821A16C8: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 821A16CC: 4198001C  blt cr6, 0x821a16e8
	if ctx.cr[6].lt {
	pc = 0x821A16E8; continue 'dispatch;
	}
	// 821A16D0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A16D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A16D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A16DC: 7D4BF1AE  stbx r10, r11, r30
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[10].u8) };
	// 821A16E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A16E4: 48B07D70  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A16E8 => {
    //   block [0x821A16E8..0x821A16F4)
	// 821A16E8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821A16EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A16F0: 7D4BF1AE  stbx r10, r11, r30
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[10].u8) };
	pc = 0x821A16F4; continue 'dispatch;
            }
            0x821A16F4 => {
    //   block [0x821A16F4..0x821A1700)
	// 821A16F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A16F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A16FC: 48B07D58  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A1700 size=740
    let mut pc: u32 = 0x821A1700;
    'dispatch: loop {
        match pc {
            0x821A1700 => {
    //   block [0x821A1700..0x821A1748)
	// 821A1700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A1704: 48B07CFD  bl 0x82ca9400
	ctx.lr = 0x821A1708;
	sub_82CA93D0(ctx, base);
	// 821A1708: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 821A170C: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821A1710: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A1714: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821A1718: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821A171C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A1720: 394B7198  addi r10, r11, 0x7198
	ctx.r[10].s64 = ctx.r[11].s64 + 29080;
	// 821A1724: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821A1728: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821A172C: 93CB7198  stw r30, 0x7198(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(29080 as u32), ctx.r[30].u32 ) };
	// 821A1730: 98AA010C  stb r5, 0x10c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(268 as u32), ctx.r[5].u8 ) };
	// 821A1734: 40990044  ble cr6, 0x821a1778
	if !ctx.cr[6].gt {
	pc = 0x821A1778; continue 'dispatch;
	}
	// 821A1738: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 821A173C: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 821A1740: 7D09E050  subf r8, r9, r28
	ctx.r[8].s64 = ctx.r[28].s64 - ctx.r[9].s64;
	// 821A1744: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x821A1748; continue 'dispatch;
            }
            0x821A1748 => {
    //   block [0x821A1748..0x821A1778)
	// 821A1748: 7CE8582E  lwzx r7, r8, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821A174C: 7C885A14  add r4, r8, r11
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821A1750: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821A1754: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821A1758: 80640004  lwz r3, 4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A175C: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821A1760: 80E40008  lwz r7, 8(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A1764: 90EB0008  stw r7, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821A1768: 8084000C  lwz r4, 0xc(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A176C: 908B000C  stw r4, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 821A1770: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821A1774: 4082FFD4  bne 0x821a1748
	if !ctx.cr[0].eq {
	pc = 0x821A1748; continue 'dispatch;
	}
	pc = 0x821A1778; continue 'dispatch;
            }
            0x821A1778 => {
    //   block [0x821A1778..0x821A17B4)
	// 821A1778: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A177C: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821A1780: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A1784: D3CA0108  stfs f30, 0x108(r10)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 821A1788: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821A178C: 916A0104  stw r11, 0x104(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 821A1790: 992870C3  stb r9, 0x70c3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(28867 as u32), ctx.r[9].u8 ) };
	// 821A1794: 40990050  ble cr6, 0x821a17e4
	if !ctx.cr[6].gt {
	pc = 0x821A17E4; continue 'dispatch;
	}
	// 821A1798: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 821A179C: 38E10094  addi r7, r1, 0x94
	ctx.r[7].s64 = ctx.r[1].s64 + 148;
	// 821A17A0: 7D1C4850  subf r8, r28, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[28].s64;
	// 821A17A4: 39410094  addi r10, r1, 0x94
	ctx.r[10].s64 = ctx.r[1].s64 + 148;
	// 821A17A8: 397C0008  addi r11, r28, 8
	ctx.r[11].s64 = ctx.r[28].s64 + 8;
	// 821A17AC: 7CFC3850  subf r7, r28, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[28].s64;
	// 821A17B0: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x821A17B4; continue 'dispatch;
            }
            0x821A17B4 => {
    //   block [0x821A17B4..0x821A17E4)
	// 821A17B4: 808BFFF8  lwz r4, -8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A17B8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821A17BC: 806BFFFC  lwz r3, -4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821A17C0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A17C4: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A17C8: 908AFFFC  stw r4, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[4].u32 ) };
	// 821A17CC: 906A0000  stw r3, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821A17D0: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821A17D4: 7FE8592E  stwx r31, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 821A17D8: 7FA7592E  stwx r29, r7, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), ctx.r[29].u32) };
	// 821A17DC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821A17E0: 4082FFD4  bne 0x821a17b4
	if !ctx.cr[0].eq {
	pc = 0x821A17B4; continue 'dispatch;
	}
	pc = 0x821A17E4; continue 'dispatch;
            }
            0x821A17E4 => {
    //   block [0x821A17E4..0x821A1878)
	// 821A17E4: 88E60000  lbz r7, 0(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A17E8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821A17EC: 88860001  lbz r4, 1(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(1 as u32) ) } as u64;
	// 821A17F0: 54A8063E  clrlwi r8, r5, 0x18
	ctx.r[8].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 821A17F4: 88660002  lbz r3, 2(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 821A17F8: 3F602000  lis r27, 0x2000
	ctx.r[27].s64 = 536870912;
	// 821A17FC: 89660003  lbz r11, 3(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(3 as u32) ) } as u64;
	// 821A1800: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A1804: C00A16C8  lfs f0, 0x16c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1808: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 821A180C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A1810: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821A1814: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 821A1818: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A181C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821A1820: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A1824: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821A1828: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821A182C: FD00669C  fcfid f8, f12
	ctx.f[8].f64 = (ctx.f[12].s64 as f64);
	// 821A1830: FCE06E9C  fcfid f7, f13
	ctx.f[7].f64 = (ctx.f[13].s64 as f64);
	// 821A1834: FCC04E9C  fcfid f6, f9
	ctx.f[6].f64 = (ctx.f[9].s64 as f64);
	// 821A1838: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 821A183C: FC804018  frsp f4, f8
	ctx.f[4].f64 = (ctx.f[8].f64 as f32) as f64;
	// 821A1840: FC603818  frsp f3, f7
	ctx.f[3].f64 = (ctx.f[7].f64 as f32) as f64;
	// 821A1844: FC403018  frsp f2, f6
	ctx.f[2].f64 = (ctx.f[6].f64 as f32) as f64;
	// 821A1848: FCA05018  frsp f5, f10
	ctx.f[5].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821A184C: EDA40032  fmuls f13, f4, f0
	ctx.f[13].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A1850: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821A1854: ED830032  fmuls f12, f3, f0
	ctx.f[12].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A1858: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821A185C: ED620032  fmuls f11, f2, f0
	ctx.f[11].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A1860: D161006C  stfs f11, 0x6c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821A1864: EC250032  fmuls f1, f5, f0
	ctx.f[1].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A1868: D0210060  stfs f1, 0x60(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821A186C: 419A000C  beq cr6, 0x821a1878
	if ctx.cr[6].eq {
	pc = 0x821A1878; continue 'dispatch;
	}
	// 821A1870: 3F602000  lis r27, 0x2000
	ctx.r[27].s64 = 536870912;
	// 821A1874: 637B0006  ori r27, r27, 6
	ctx.r[27].u64 = ctx.r[27].u64 | 6;
	pc = 0x821A1878; continue 'dispatch;
            }
            0x821A1878 => {
    //   block [0x821A1878..0x821A18B8)
	// 821A1878: 3FA08336  lis r29, -0x7cca
	ctx.r[29].s64 = -2093613056;
	// 821A187C: 83FD0364  lwz r31, 0x364(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(868 as u32) ) } as u64;
	// 821A1880: 817F2AA4  lwz r11, 0x2aa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10916 as u32) ) } as u64;
	// 821A1884: 556A04A6  rlwinm r10, r11, 0, 0x12, 0x13
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1888: 2B0A2000  cmplwi cr6, r10, 0x2000
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8192 as u32, &mut ctx.xer);
	// 821A188C: 419A0054  beq cr6, 0x821a18e0
	if ctx.cr[6].eq {
	pc = 0x821A18E0; continue 'dispatch;
	}
	// 821A1890: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A1894: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821A1898: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A189C: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A18A0: 514B6CA6  rlwimi r11, r10, 0xd, 0x12, 0x13
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(13) as u64) & 0x0000000000003000) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFCFFF);
	// 821A18A4: 7F034840  cmplw cr6, r3, r9
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A18A8: 917F2AA4  stw r11, 0x2aa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10916 as u32), ctx.r[11].u32 ) };
	// 821A18AC: 4099000C  ble cr6, 0x821a18b8
	if !ctx.cr[6].gt {
	pc = 0x821A18B8; continue 'dispatch;
	}
	// 821A18B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A18B4: 4804760D  bl 0x821e8ec0
	ctx.lr = 0x821A18B8;
	sub_821E8EC0(ctx, base);
	pc = 0x821A18B8; continue 'dispatch;
            }
            0x821A18B8 => {
    //   block [0x821A18B8..0x821A18E0)
	// 821A18B8: 396005C8  li r11, 0x5c8
	ctx.r[11].s64 = 1480;
	// 821A18BC: 3D400002  lis r10, 2
	ctx.r[10].s64 = 131072;
	// 821A18C0: 95630004  stwu r11, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[3].u32 = ea;
	// 821A18C4: 39200F01  li r9, 0xf01
	ctx.r[9].s64 = 3841;
	// 821A18C8: 95430004  stwu r10, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[3].u32 = ea;
	// 821A18CC: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	// 821A18D0: 811F2AA4  lwz r8, 0x2aa4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10916 as u32) ) } as u64;
	// 821A18D4: 95030004  stwu r8, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[8].u32) };
	ctx.r[3].u32 = ea;
	// 821A18D8: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 821A18DC: 83FD0364  lwz r31, 0x364(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(868 as u32) ) } as u64;
	pc = 0x821A18E0; continue 'dispatch;
            }
            0x821A18E0 => {
    //   block [0x821A18E0..0x821A19E4)
	// 821A18E0: 3F40820A  lis r26, -0x7df6
	ctx.r[26].s64 = -2113273856;
	// 821A18E4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A18E8: 397A9484  addi r11, r26, -0x6b7c
	ctx.r[11].s64 = ctx.r[26].s64 + -27516;
	// 821A18EC: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821A18F0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821A18F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821A18F8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821A18FC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A1900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A1904: EC3FF028  fsubs f1, f31, f30
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 821A1908: 481048B9  bl 0x822a61c0
	ctx.lr = 0x821A190C;
	sub_822A61C0(ctx, base);
	// 821A190C: 807D0364  lwz r3, 0x364(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(868 as u32) ) } as u64;
	// 821A1910: C01A9484  lfs f0, -0x6b7c(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1914: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 821A1918: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821A191C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821A1920: 38C760B8  addi r6, r7, 0x60b8
	ctx.r[6].s64 = ctx.r[7].s64 + 24760;
	// 821A1924: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821A1928: C1A33168  lfs f13, 0x3168(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12648 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A192C: C1633170  lfs f11, 0x3170(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12656 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A1930: FD406E5E  fctidz f10, f13
	ctx.f[10].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 821A1934: FD205E5E  fctidz f9, f11
	ctx.f[9].s64 = if ctx.f[11].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[11].f64.trunc() as i64 };
	// 821A1938: D9210050  stfd f9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[9].u64 ) };
	// 821A193C: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1940: C103316C  lfs f8, 0x316c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12652 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821A1944: FCE0465E  fctidz f7, f8
	ctx.f[7].s64 = if ctx.f[8].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[8].f64.trunc() as i64 };
	// 821A1948: C0033174  lfs f0, 0x3174(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12660 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A194C: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A1950: D9810058  stfd f12, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[12].u64 ) };
	// 821A1954: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A1958: D9410058  stfd f10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[10].u64 ) };
	// 821A195C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A1960: D8E10058  stfd f7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[7].u64 ) };
	// 821A1964: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A1968: 91660004  stw r11, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821A196C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821A1970: 914760B8  stw r10, 0x60b8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(24760 as u32), ctx.r[10].u32 ) };
	// 821A1974: 7D685214  add r11, r8, r10
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821A1978: 9126000C  stw r9, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821A197C: 91660008  stw r11, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821A1980: C0C33174  lfs f6, 0x3174(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12660 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821A1984: C0833170  lfs f4, 0x3170(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12656 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821A1988: C003316C  lfs f0, 0x316c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12652 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A198C: C0A33168  lfs f5, 0x3168(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12648 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821A1990: FC202E5E  fctidz f1, f5
	ctx.f[1].s64 = if ctx.f[5].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[5].f64.trunc() as i64 };
	// 821A1994: D8210060  stfd f1, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[1].u64 ) };
	// 821A1998: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821A199C: FC60265E  fctidz f3, f4
	ctx.f[3].s64 = if ctx.f[4].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[4].f64.trunc() as i64 };
	// 821A19A0: D8610058  stfd f3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[3].u64 ) };
	// 821A19A4: FC40365E  fctidz f2, f6
	ctx.f[2].s64 = if ctx.f[6].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[6].f64.trunc() as i64 };
	// 821A19A8: D8410050  stfd f2, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[2].u64 ) };
	// 821A19AC: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A19B0: D9A10060  stfd f13, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[13].u64 ) };
	// 821A19B4: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A19B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A19BC: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821A19C0: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 821A19C4: 90A10078  stw r5, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[5].u32 ) };
	// 821A19C8: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821A19CC: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 821A19D0: 48058589  bl 0x821f9f58
	ctx.lr = 0x821A19D4;
	sub_821F9F58(ctx, base);
	// 821A19D4: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 821A19D8: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821A19DC: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821A19E0: 48B07A70  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A19E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A19E8 size=464
    let mut pc: u32 = 0x821A19E8;
    'dispatch: loop {
        match pc {
            0x821A19E8 => {
    //   block [0x821A19E8..0x821A1A74)
	// 821A19E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A19EC: 48B07A21  bl 0x82ca940c
	ctx.lr = 0x821A19F0;
	sub_82CA93D0(ctx, base);
	// 821A19F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A19F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821A19F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A19FC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A1A00: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A1A04: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821A1A08: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1A0C: 2F080008  cmpwi cr6, r8, 8
	ctx.cr[6].compare_i32(ctx.r[8].s32, 8, &mut ctx.xer);
	// 821A1A10: 4198019C  blt cr6, 0x821a1bac
	if ctx.cr[6].lt {
	pc = 0x821A1BAC; continue 'dispatch;
	}
	// 821A1A14: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821A1A18: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821A1A1C: 38AB79B0  addi r5, r11, 0x79b0
	ctx.r[5].s64 = ctx.r[11].s64 + 31152;
	// 821A1A20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A1A24: 480865A5  bl 0x82227fc8
	ctx.lr = 0x821A1A28;
	sub_82227FC8(ctx, base);
	// 821A1A28: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821A1A2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A1A30: 419A017C  beq cr6, 0x821a1bac
	if ctx.cr[6].eq {
	pc = 0x821A1BAC; continue 'dispatch;
	}
	// 821A1A34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821A1A38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A1A3C: 480866BD  bl 0x822280f8
	ctx.lr = 0x821A1A40;
	sub_822280F8(ctx, base);
	// 821A1A40: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1A44: 48085B1D  bl 0x82227560
	ctx.lr = 0x821A1A48;
	sub_82227560(ctx, base);
	// 821A1A48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A1A4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821A1A50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A1A54: 4803E935  bl 0x821e0388
	ctx.lr = 0x821A1A58;
	sub_821E0388(ctx, base);
	// 821A1A58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A1A5C: 419A0018  beq cr6, 0x821a1a74
	if ctx.cr[6].eq {
	pc = 0x821A1A74; continue 'dispatch;
	}
	// 821A1A60: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A1A64: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1A68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A1A6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A1A70: 409A0008  bne cr6, 0x821a1a78
	if !ctx.cr[6].eq {
	pc = 0x821A1A78; continue 'dispatch;
	}
	pc = 0x821A1A74; continue 'dispatch;
            }
            0x821A1A74 => {
    //   block [0x821A1A74..0x821A1A78)
	// 821A1A74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821A1A78; continue 'dispatch;
            }
            0x821A1A78 => {
    //   block [0x821A1A78..0x821A1AC0)
	// 821A1A78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A1A7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1A80: 419A012C  beq cr6, 0x821a1bac
	if ctx.cr[6].eq {
	pc = 0x821A1BAC; continue 'dispatch;
	}
	// 821A1A84: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A1A88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A1A8C: 5549BFFE  rlwinm r9, r10, 0x17, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000001FFu64;
	// 821A1A90: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A1A94: 419A00EC  beq cr6, 0x821a1b80
	if ctx.cr[6].eq {
	pc = 0x821A1B80; continue 'dispatch;
	}
	// 821A1A98: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A1A9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1AA0: 419A0020  beq cr6, 0x821a1ac0
	if ctx.cr[6].eq {
	pc = 0x821A1AC0; continue 'dispatch;
	}
	// 821A1AA4: 894B0029  lbz r10, 0x29(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 821A1AA8: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A1AAC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A1AB0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A1AB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A1AB8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1ABC: 480000C8  b 0x821a1b84
	pc = 0x821A1B84; continue 'dispatch;
            }
            0x821A1AC0 => {
    //   block [0x821A1AC0..0x821A1AE0)
	// 821A1AC0: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A1AC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A1AC8: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A1ACC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821A1AD0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A1AD4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821A1AD8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A1ADC: 40810054  ble 0x821a1b30
	if !ctx.cr[0].gt {
	pc = 0x821A1B30; continue 'dispatch;
	}
	pc = 0x821A1AE0; continue 'dispatch;
            }
            0x821A1AE0 => {
    //   block [0x821A1AE0..0x821A1B00)
	// 821A1AE0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A1AE4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A1AE8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821A1AEC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1AF0: 2F070029  cmpwi cr6, r7, 0x29
	ctx.cr[6].compare_i32(ctx.r[7].s32, 41, &mut ctx.xer);
	// 821A1AF4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A1AF8: 41980008  blt cr6, 0x821a1b00
	if ctx.cr[6].lt {
	pc = 0x821A1B00; continue 'dispatch;
	}
	// 821A1AFC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821A1B00; continue 'dispatch;
            }
            0x821A1B00 => {
    //   block [0x821A1B00..0x821A1B1C)
	// 821A1B00: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A1B04: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A1B08: 419A0014  beq cr6, 0x821a1b1c
	if ctx.cr[6].eq {
	pc = 0x821A1B1C; continue 'dispatch;
	}
	// 821A1B0C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A1B10: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A1B14: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A1B18: 4800000C  b 0x821a1b24
	pc = 0x821A1B24; continue 'dispatch;
            }
            0x821A1B1C => {
    //   block [0x821A1B1C..0x821A1B24)
	// 821A1B1C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A1B20: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A1B24; continue 'dispatch;
            }
            0x821A1B24 => {
    //   block [0x821A1B24..0x821A1B30)
	// 821A1B24: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A1B28: 4199FFB8  bgt cr6, 0x821a1ae0
	if ctx.cr[6].gt {
	pc = 0x821A1AE0; continue 'dispatch;
	}
	// 821A1B2C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821A1B30; continue 'dispatch;
            }
            0x821A1B30 => {
    //   block [0x821A1B30..0x821A1B4C)
	// 821A1B30: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A1B34: 419A003C  beq cr6, 0x821a1b70
	if ctx.cr[6].eq {
	pc = 0x821A1B70; continue 'dispatch;
	}
	// 821A1B38: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1B3C: 2F0B0029  cmpwi cr6, r11, 0x29
	ctx.cr[6].compare_i32(ctx.r[11].s32, 41, &mut ctx.xer);
	// 821A1B40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A1B44: 41990008  bgt cr6, 0x821a1b4c
	if ctx.cr[6].gt {
	pc = 0x821A1B4C; continue 'dispatch;
	}
	// 821A1B48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821A1B4C; continue 'dispatch;
            }
            0x821A1B4C => {
    //   block [0x821A1B4C..0x821A1B70)
	// 821A1B4C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A1B50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1B54: 409A001C  bne cr6, 0x821a1b70
	if !ctx.cr[6].eq {
	pc = 0x821A1B70; continue 'dispatch;
	}
	// 821A1B58: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A1B5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A1B60: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A1B64: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1B68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1B6C: 48000018  b 0x821a1b84
	pc = 0x821A1B84; continue 'dispatch;
            }
            0x821A1B70 => {
    //   block [0x821A1B70..0x821A1B80)
	// 821A1B70: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821A1B74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A1B78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1B7C: 48000008  b 0x821a1b84
	pc = 0x821A1B84; continue 'dispatch;
            }
            0x821A1B80 => {
    //   block [0x821A1B80..0x821A1B84)
	// 821A1B80: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821A1B84; continue 'dispatch;
            }
            0x821A1B84 => {
    //   block [0x821A1B84..0x821A1BAC)
	// 821A1B84: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821A1B88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A1B8C: 419A0020  beq cr6, 0x821a1bac
	if ctx.cr[6].eq {
	pc = 0x821A1BAC; continue 'dispatch;
	}
	// 821A1B90: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1B94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A1B98: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A1B9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A1BA0: 4E800421  bctrl
	ctx.lr = 0x821A1BA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A1BA4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A1BA8: 48B078B4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A1BAC => {
    //   block [0x821A1BAC..0x821A1BB8)
	// 821A1BAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A1BB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A1BB4: 48B078A8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A1BB8 size=204
    let mut pc: u32 = 0x821A1BB8;
    'dispatch: loop {
        match pc {
            0x821A1BB8 => {
    //   block [0x821A1BB8..0x821A1BE0)
	// 821A1BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A1BBC: 48B07851  bl 0x82ca940c
	ctx.lr = 0x821A1BC0;
	sub_82CA93D0(ctx, base);
	// 821A1BC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A1BC4: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A1BC8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821A1BCC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A1BD0: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 821A1BD4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1BD8: 40990008  ble cr6, 0x821a1be0
	if !ctx.cr[6].gt {
	pc = 0x821A1BE0; continue 'dispatch;
	}
	// 821A1BDC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A1BE0; continue 'dispatch;
            }
            0x821A1BE0 => {
    //   block [0x821A1BE0..0x821A1BF4)
	// 821A1BE0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A1BE4: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1BE8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A1BEC: 40990008  ble cr6, 0x821a1bf4
	if !ctx.cr[6].gt {
	pc = 0x821A1BF4; continue 'dispatch;
	}
	// 821A1BF0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A1BF4; continue 'dispatch;
            }
            0x821A1BF4 => {
    //   block [0x821A1BF4..0x821A1C00)
	// 821A1BF4: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821A1BF8: 419A0008  beq cr6, 0x821a1c00
	if ctx.cr[6].eq {
	pc = 0x821A1C00; continue 'dispatch;
	}
	// 821A1BFC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A1C00; continue 'dispatch;
            }
            0x821A1C00 => {
    //   block [0x821A1C00..0x821A1C14)
	// 821A1C00: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A1C04: 419A0078  beq cr6, 0x821a1c7c
	if ctx.cr[6].eq {
	pc = 0x821A1C7C; continue 'dispatch;
	}
	// 821A1C08: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1C0C: 41980008  blt cr6, 0x821a1c14
	if ctx.cr[6].lt {
	pc = 0x821A1C14; continue 'dispatch;
	}
	// 821A1C10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A1C14; continue 'dispatch;
            }
            0x821A1C14 => {
    //   block [0x821A1C14..0x821A1C2C)
	// 821A1C14: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1C18: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1C1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1C20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821A1C24: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821A1C28: 419A0020  beq cr6, 0x821a1c48
	if ctx.cr[6].eq {
	pc = 0x821A1C48; continue 'dispatch;
	}
	pc = 0x821A1C2C; continue 'dispatch;
            }
            0x821A1C2C => {
    //   block [0x821A1C2C..0x821A1C48)
	// 821A1C2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821A1C30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A1C34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821A1C38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A1C3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821A1C40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A1C44: 4082FFE8  bne 0x821a1c2c
	if !ctx.cr[0].eq {
	pc = 0x821A1C2C; continue 'dispatch;
	}
	pc = 0x821A1C48; continue 'dispatch;
            }
            0x821A1C48 => {
    //   block [0x821A1C48..0x821A1C74)
	// 821A1C48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1C4C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A1C50: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A1C54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A1C58: 4E800421  bctrl
	ctx.lr = 0x821A1C5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A1C5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821A1C60: 48015EB9  bl 0x821b7b18
	ctx.lr = 0x821A1C64;
	sub_821B7B18(ctx, base);
	// 821A1C64: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A1C68: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1C6C: 41980008  blt cr6, 0x821a1c74
	if ctx.cr[6].lt {
	pc = 0x821A1C74; continue 'dispatch;
	}
	// 821A1C70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
            }
            0x821A1C74 => {
    //   block [0x821A1C74..0x821A1C7C)
	// 821A1C74: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821A1C78: 4BFFFF68  b 0x821a1be0
	pc = 0x821A1BE0; continue 'dispatch;
            }
            0x821A1C7C => {
    //   block [0x821A1C7C..0x821A1C84)
	// 821A1C7C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A1C80: 48B077DC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A1C88 size=592
    let mut pc: u32 = 0x821A1C88;
    'dispatch: loop {
        match pc {
            0x821A1C88 => {
    //   block [0x821A1C88..0x821A1D00)
	// 821A1C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A1C8C: 48B07775  bl 0x82ca9400
	ctx.lr = 0x821A1C90;
	sub_82CA93D0(ctx, base);
	// 821A1C90: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A1C94: 81650018  lwz r11, 0x18(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A1C98: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821A1C9C: 39450014  addi r10, r5, 0x14
	ctx.r[10].s64 = ctx.r[5].s64 + 20;
	// 821A1CA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1CA4: 419A022C  beq cr6, 0x821a1ed0
	if ctx.cr[6].eq {
	pc = 0x821A1ED0; continue 'dispatch;
	}
	// 821A1CA8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1CAC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A1CB0: 419A013C  beq cr6, 0x821a1dec
	if ctx.cr[6].eq {
	pc = 0x821A1DEC; continue 'dispatch;
	}
	// 821A1CB4: 553E003E  slwi r30, r9, 0
	ctx.r[30].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821A1CB8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A1CBC: 419A0214  beq cr6, 0x821a1ed0
	if ctx.cr[6].eq {
	pc = 0x821A1ED0; continue 'dispatch;
	}
	// 821A1CC0: 817A000C  lwz r11, 0xc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A1CC4: 556A06FE  clrlwi r10, r11, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821A1CC8: 2F0A001F  cmpwi cr6, r10, 0x1f
	ctx.cr[6].compare_i32(ctx.r[10].s32, 31, &mut ctx.xer);
	// 821A1CCC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821A1CD0: 409A0200  bne cr6, 0x821a1ed0
	if !ctx.cr[6].eq {
	pc = 0x821A1ED0; continue 'dispatch;
	}
	// 821A1CD4: 3B830034  addi r28, r3, 0x34
	ctx.r[28].s64 = ctx.r[3].s64 + 52;
	// 821A1CD8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821A1CDC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A1CE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821A1CE4: 483DCF25  bl 0x8257ec08
	ctx.lr = 0x821A1CE8;
	sub_8257EC08(ctx, base);
	// 821A1CE8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1CEC: 83610060  lwz r27, 0x60(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821A1CF0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821A1CF4: 419A000C  beq cr6, 0x821a1d00
	if ctx.cr[6].eq {
	pc = 0x821A1D00; continue 'dispatch;
	}
	// 821A1CF8: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821A1CFC: 419A0008  beq cr6, 0x821a1d04
	if ctx.cr[6].eq {
	pc = 0x821A1D04; continue 'dispatch;
	}
	pc = 0x821A1D00; continue 'dispatch;
            }
            0x821A1D00 => {
    //   block [0x821A1D00..0x821A1D04)
	// 821A1D00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A1D04; continue 'dispatch;
            }
            0x821A1D04 => {
    //   block [0x821A1D04..0x821A1D1C)
	// 821A1D04: 83A10064  lwz r29, 0x64(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821A1D08: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1D0C: 419A01C4  beq cr6, 0x821a1ed0
	if ctx.cr[6].eq {
	pc = 0x821A1ED0; continue 'dispatch;
	}
	// 821A1D10: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821A1D14: 409A0008  bne cr6, 0x821a1d1c
	if !ctx.cr[6].eq {
	pc = 0x821A1D1C; continue 'dispatch;
	}
	// 821A1D18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A1D1C; continue 'dispatch;
            }
            0x821A1D1C => {
    //   block [0x821A1D1C..0x821A1D2C)
	// 821A1D1C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1D20: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1D24: 409A0008  bne cr6, 0x821a1d2c
	if !ctx.cr[6].eq {
	pc = 0x821A1D2C; continue 'dispatch;
	}
	// 821A1D28: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A1D2C; continue 'dispatch;
            }
            0x821A1D2C => {
    //   block [0x821A1D2C..0x821A1D48)
	// 821A1D2C: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A1D30: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 821A1D34: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A1D38: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1D3C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1D40: 40990008  ble cr6, 0x821a1d48
	if !ctx.cr[6].gt {
	pc = 0x821A1D48; continue 'dispatch;
	}
	// 821A1D44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A1D48; continue 'dispatch;
            }
            0x821A1D48 => {
    //   block [0x821A1D48..0x821A1D84)
	// 821A1D48: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821A1D4C: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 821A1D50: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A1D54: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 821A1D58: 390A0B7C  addi r8, r10, 0xb7c
	ctx.r[8].s64 = ctx.r[10].s64 + 2940;
	// 821A1D5C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821A1D60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A1D64: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821A1D68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821A1D6C: 48072B2D  bl 0x82214898
	ctx.lr = 0x821A1D70;
	sub_82214898(ctx, base);
	// 821A1D70: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1D74: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A1D78: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821A1D7C: 40990008  ble cr6, 0x821a1d84
	if !ctx.cr[6].gt {
	pc = 0x821A1D84; continue 'dispatch;
	}
	// 821A1D80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A1D84; continue 'dispatch;
            }
            0x821A1D84 => {
    //   block [0x821A1D84..0x821A1D98)
	// 821A1D84: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 821A1D88: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821A1D8C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 821A1D90: 40990008  ble cr6, 0x821a1d98
	if !ctx.cr[6].gt {
	pc = 0x821A1D98; continue 'dispatch;
	}
	// 821A1D94: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A1D98; continue 'dispatch;
            }
            0x821A1D98 => {
    //   block [0x821A1D98..0x821A1DD0)
	// 821A1D98: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821A1D9C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 821A1DA0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821A1DA4: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 821A1DA8: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821A1DAC: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A1DB0: 484BE861  bl 0x82660610
	ctx.lr = 0x821A1DB4;
	sub_82660610(ctx, base);
	// 821A1DB4: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821A1DB8: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A1DBC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821A1DC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1DC4: 419A000C  beq cr6, 0x821a1dd0
	if ctx.cr[6].eq {
	pc = 0x821A1DD0; continue 'dispatch;
	}
	// 821A1DC8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A1DCC: 419A0008  beq cr6, 0x821a1dd4
	if ctx.cr[6].eq {
	pc = 0x821A1DD4; continue 'dispatch;
	}
	pc = 0x821A1DD0; continue 'dispatch;
            }
            0x821A1DD0 => {
    //   block [0x821A1DD0..0x821A1DD4)
	// 821A1DD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A1DD4; continue 'dispatch;
            }
            0x821A1DD4 => {
    //   block [0x821A1DD4..0x821A1DEC)
	// 821A1DD4: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A1DD8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821A1DDC: 409A0020  bne cr6, 0x821a1dfc
	if !ctx.cr[6].eq {
	pc = 0x821A1DFC; continue 'dispatch;
	}
	// 821A1DE0: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821A1DE4: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 821A1DE8: 48000060  b 0x821a1e48
	pc = 0x821A1E48; continue 'dispatch;
            }
            0x821A1DEC => {
    //   block [0x821A1DEC..0x821A1DFC)
	// 821A1DEC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 821A1DF0: 4BFF2049  bl 0x82193e38
	ctx.lr = 0x821A1DF4;
	sub_82193E38(ctx, base);
	// 821A1DF4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A1DF8: 48B07658  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A1DFC => {
    //   block [0x821A1DFC..0x821A1E14)
	// 821A1DFC: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821A1E00: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A1E04: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821A1E08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1E0C: 409A0008  bne cr6, 0x821a1e14
	if !ctx.cr[6].eq {
	pc = 0x821A1E14; continue 'dispatch;
	}
	// 821A1E10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A1E14; continue 'dispatch;
            }
            0x821A1E14 => {
    //   block [0x821A1E14..0x821A1E28)
	// 821A1E14: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A1E18: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A1E1C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A1E20: 41980008  blt cr6, 0x821a1e28
	if ctx.cr[6].lt {
	pc = 0x821A1E28; continue 'dispatch;
	}
	// 821A1E24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A1E28; continue 'dispatch;
            }
            0x821A1E28 => {
    //   block [0x821A1E28..0x821A1E48)
	// 821A1E28: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821A1E2C: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 821A1E30: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 821A1E34: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 821A1E38: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821A1E3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821A1E40: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 821A1E44: 484BE8BD  bl 0x82660700
	ctx.lr = 0x821A1E48;
	sub_82660700(ctx, base);
	pc = 0x821A1E48; continue 'dispatch;
            }
            0x821A1E48 => {
    //   block [0x821A1E48..0x821A1E90)
	// 821A1E48: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 821A1E4C: E8C10070  ld r6, 0x70(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 821A1E50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A1E54: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A1E58: E8AB0000  ld r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A1E5C: 484BE1A5  bl 0x82660000
	ctx.lr = 0x821A1E60;
	sub_82660000(ctx, base);
	// 821A1E60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821A1E64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821A1E68: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 821A1E6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821A1E70: 4BFF1FC9  bl 0x82193e38
	ctx.lr = 0x821A1E74;
	sub_82193E38(ctx, base);
	// 821A1E74: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1E78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1E7C: 419A0014  beq cr6, 0x821a1e90
	if ctx.cr[6].eq {
	pc = 0x821A1E90; continue 'dispatch;
	}
	// 821A1E80: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A1E84: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821A1E88: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A1E8C: 40820044  bne 0x821a1ed0
	if !ctx.cr[0].eq {
	pc = 0x821A1ED0; continue 'dispatch;
	}
	pc = 0x821A1E90; continue 'dispatch;
            }
            0x821A1E90 => {
    //   block [0x821A1E90..0x821A1EA0)
	// 821A1E90: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1E94: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1E98: 409A0008  bne cr6, 0x821a1ea0
	if !ctx.cr[6].eq {
	pc = 0x821A1EA0; continue 'dispatch;
	}
	// 821A1E9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A1EA0; continue 'dispatch;
            }
            0x821A1EA0 => {
    //   block [0x821A1EA0..0x821A1ED0)
	// 821A1EA0: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A1EA4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A1EA8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821A1EAC: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821A1EB0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1EB4: 484CDDBD  bl 0x8266fc70
	ctx.lr = 0x821A1EB8;
	sub_8266FC70(ctx, base);
	// 821A1EB8: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1EBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A1EC0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821A1EC4: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A1EC8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821A1ECC: 4E800421  bctrl
	ctx.lr = 0x821A1ED0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A1ED0 => {
    //   block [0x821A1ED0..0x821A1ED8)
	// 821A1ED0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A1ED4: 48B0757C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A1ED8 size=248
    let mut pc: u32 = 0x821A1ED8;
    'dispatch: loop {
        match pc {
            0x821A1ED8 => {
    //   block [0x821A1ED8..0x821A1F1C)
	// 821A1ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A1EDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A1EE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A1EE4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A1EE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821A1EEC: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821A1EF0: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 821A1EF4: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A1EF8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A1EFC: 409A0020  bne cr6, 0x821a1f1c
	if !ctx.cr[6].eq {
	pc = 0x821A1F1C; continue 'dispatch;
	}
	// 821A1F00: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 821A1F04: 48987735  bl 0x82b29638
	ctx.lr = 0x821A1F08;
	sub_82B29638(ctx, base);
	// 821A1F08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A1F0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A1F10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A1F14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A1F18: 4E800020  blr
	return;
            }
            0x821A1F1C => {
    //   block [0x821A1F1C..0x821A1F44)
	// 821A1F1C: 81660034  lwz r11, 0x34(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(52 as u32) ) } as u64;
	// 821A1F20: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1F24: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A1F28: 4198001C  blt cr6, 0x821a1f44
	if ctx.cr[6].lt {
	pc = 0x821A1F44; continue 'dispatch;
	}
	// 821A1F2C: 8126003C  lwz r9, 0x3c(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(60 as u32) ) } as u64;
	// 821A1F30: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A1F34: 80E9001C  lwz r7, 0x1c(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 821A1F38: 80A70058  lwz r5, 0x58(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A1F3C: 7D65402E  lwzx r11, r5, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821A1F40: 4800000C  b 0x821a1f4c
	pc = 0x821A1F4C; continue 'dispatch;
            }
            0x821A1F44 => {
    //   block [0x821A1F44..0x821A1F4C)
	// 821A1F44: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821A1F48: 816B5760  lwz r11, 0x5760(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22368 as u32) ) } as u64;
	pc = 0x821A1F4C; continue 'dispatch;
            }
            0x821A1F4C => {
    //   block [0x821A1F4C..0x821A1F74)
	// 821A1F4C: 81060004  lwz r8, 4(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1F50: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821A1F54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A1F58: 80E6001C  lwz r7, 0x1c(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821A1F5C: 39280150  addi r9, r8, 0x150
	ctx.r[9].s64 = ctx.r[8].s64 + 336;
	// 821A1F60: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821A1F64: 480032BD  bl 0x821a5220
	ctx.lr = 0x821A1F68;
	sub_821A5220(ctx, base);
	// 821A1F68: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A1F6C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A1F70: 409A001C  bne cr6, 0x821a1f8c
	if !ctx.cr[6].eq {
	pc = 0x821A1F8C; continue 'dispatch;
	}
	pc = 0x821A1F74; continue 'dispatch;
            }
            0x821A1F74 => {
    //   block [0x821A1F74..0x821A1F8C)
	// 821A1F74: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A1F78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A1F7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A1F80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A1F84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A1F88: 4E800020  blr
	return;
            }
            0x821A1F8C => {
    //   block [0x821A1F8C..0x821A1FD0)
	// 821A1F8C: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A1F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1F94: 419AFFE0  beq cr6, 0x821a1f74
	if ctx.cr[6].eq {
	pc = 0x821A1F74; continue 'dispatch;
	}
	// 821A1F98: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A1F9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A1FA0: 419AFFD4  beq cr6, 0x821a1f74
	if ctx.cr[6].eq {
	pc = 0x821A1F74; continue 'dispatch;
	}
	// 821A1FA4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A1FA8: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1FAC: 5569273E  srwi r9, r11, 0x1c
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(28);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A1FB0: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 821A1FB4: 7D070034  cntlzw r7, r8
	ctx.r[7].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 821A1FB8: 54E3DFFE  rlwinm r3, r7, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 821A1FBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A1FC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A1FC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A1FC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A1FCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A1FD0 size=400
    let mut pc: u32 = 0x821A1FD0;
    'dispatch: loop {
        match pc {
            0x821A1FD0 => {
    //   block [0x821A1FD0..0x821A2160)
	// 821A1FD0: 3960000B  li r11, 0xb
	ctx.r[11].s64 = 11;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2160 size=500
    let mut pc: u32 = 0x821A2160;
    'dispatch: loop {
        match pc {
            0x821A2160 => {
    //   block [0x821A2160..0x821A2354)
	// 821A2160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2168: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A216C: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2358 size=312
    let mut pc: u32 = 0x821A2358;
    'dispatch: loop {
        match pc {
            0x821A2358 => {
    //   block [0x821A2358..0x821A2490)
	// 821A2358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A235C: 48B070A5  bl 0x82ca9400
	ctx.lr = 0x821A2360;
	sub_82CA93D0(ctx, base);
	// 821A2360: ED620828  fsubs f11, f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = (((ctx.f[2].f64 - ctx.f[1].f64) as f32) as f64);
	// 821A2364: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821A2368: ED441828  fsubs f10, f4, f3
	ctx.f[10].f64 = (((ctx.f[4].f64 - ctx.f[3].f64) as f32) as f64);
	// 821A236C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821A2370: 3901FF70  addi r8, r1, -0x90
	ctx.r[8].s64 = ctx.r[1].s64 + -144;
	// 821A2374: ED253028  fsubs f9, f5, f6
	ctx.f[9].f64 = (((ctx.f[5].f64 - ctx.f[6].f64) as f32) as f64);
	// 821A2378: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821A237C: ED01102A  fadds f8, f1, f2
	ctx.f[8].f64 = ((ctx.f[1].f64 + ctx.f[2].f64) as f32) as f64;
	// 821A2380: ECE3202A  fadds f7, f3, f4
	ctx.f[7].f64 = ((ctx.f[3].f64 + ctx.f[4].f64) as f32) as f64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2490 size=164
    let mut pc: u32 = 0x821A2490;
    'dispatch: loop {
        match pc {
            0x821A2490 => {
    //   block [0x821A2490..0x821A2534)
	// 821A2490: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2538 size=344
    let mut pc: u32 = 0x821A2538;
    'dispatch: loop {
        match pc {
            0x821A2538 => {
    //   block [0x821A2538..0x821A2690)
	// 821A2538: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A253C: 39400130  li r10, 0x130
	ctx.r[10].s64 = 304;
	// 821A2540: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A2544: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 821A2548: 55672036  slwi r7, r11, 4
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821A254C: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A2690 size=248
    let mut pc: u32 = 0x821A2690;
    'dispatch: loop {
        match pc {
            0x821A2690 => {
    //   block [0x821A2690..0x821A2758)
	// 821A2690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2694: 48B06D75  bl 0x82ca9408
	ctx.lr = 0x821A2698;
	sub_82CA93D0(ctx, base);
	// 821A2698: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A269C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A26A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821A26A4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A26A8: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 821A26AC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821A26B0: 409A00A8  bne cr6, 0x821a2758
	if !ctx.cr[6].eq {
	pc = 0x821A2758; continue 'dispatch;
	}
	// 821A26B4: 389F01C0  addi r4, r31, 0x1c0
	ctx.r[4].s64 = ctx.r[31].s64 + 448;
	// 821A26B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A26BC: 4BFFFDD5  bl 0x821a2490
	ctx.lr = 0x821A26C0;
	sub_821A2490(ctx, base);
	// 821A26C0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A26C4: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 821A26C8: 939F0150  stw r28, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[28].u32 ) };
	// 821A26CC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821A26D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A26D4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821A26D8: 481353A9  bl 0x822d7a80
	ctx.lr = 0x821A26DC;
	sub_822D7A80(ctx, base);
	// 821A26DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A26E0: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 821A26E4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821A26E8: 48135399  bl 0x822d7a80
	ctx.lr = 0x821A26EC;
	sub_822D7A80(ctx, base);
	// 821A26EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A26F0: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821A26F4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821A26F8: 48135389  bl 0x822d7a80
	ctx.lr = 0x821A26FC;
	sub_822D7A80(ctx, base);
	// 821A26FC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821A2700: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821A2704: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A2708: 48135379  bl 0x822d7a80
	ctx.lr = 0x821A270C;
	sub_822D7A80(ctx, base);
	// 821A270C: 80FD0100  lwz r7, 0x100(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(256 as u32) ) } as u64;
	// 821A2710: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A2714: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821A2718: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 821A271C: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 821A2720: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821A2724: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 821A2728: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821A272C: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821A2730: 2F070005  cmpwi cr6, r7, 5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 5, &mut ctx.xer);
	// 821A2734: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 821A2738: 41980048  blt cr6, 0x821a2780
	if ctx.cr[6].lt {
	pc = 0x821A2780; continue 'dispatch;
	}
	// 821A273C: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A2740: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821A2744: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A2748: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A274C: 4BFFFDED  bl 0x821a2538
	ctx.lr = 0x821A2750;
	sub_821A2538(ctx, base);
	// 821A2750: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821A2754: 48B06D04  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A2758 => {
    //   block [0x821A2758..0x821A2780)
	// 821A2758: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821A275C: 409A0024  bne cr6, 0x821a2780
	if !ctx.cr[6].eq {
	pc = 0x821A2780; continue 'dispatch;
	}
	// 821A2760: 389F01C0  addi r4, r31, 0x1c0
	ctx.r[4].s64 = ctx.r[31].s64 + 448;
	// 821A2764: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A2768: 4BFFFD29  bl 0x821a2490
	ctx.lr = 0x821A276C;
	sub_821A2490(ctx, base);
	// 821A276C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A2770: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821A2774: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 821A2778: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 821A277C: 480EB88D  bl 0x8228e008
	ctx.lr = 0x821A2780;
	sub_8228E008(ctx, base);
	pc = 0x821A2780; continue 'dispatch;
            }
            0x821A2780 => {
    //   block [0x821A2780..0x821A2788)
	// 821A2780: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821A2784: 48B06CD4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A2788 size=136
    let mut pc: u32 = 0x821A2788;
    'dispatch: loop {
        match pc {
            0x821A2788 => {
    //   block [0x821A2788..0x821A27CC)
	// 821A2788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A278C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2790: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A2794: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A2798: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A279C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A27A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821A27A4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A27A8: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 821A27AC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821A27B0: 409A001C  bne cr6, 0x821a27cc
	if !ctx.cr[6].eq {
	pc = 0x821A27CC; continue 'dispatch;
	}
	// 821A27B4: 4800005D  bl 0x821a2810
	ctx.lr = 0x821A27B8;
	sub_821A2810(ctx, base);
	// 821A27B8: 389E02F0  addi r4, r30, 0x2f0
	ctx.r[4].s64 = ctx.r[30].s64 + 752;
	// 821A27BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A27C0: 4BFFFED1  bl 0x821a2690
	ctx.lr = 0x821A27C4;
	sub_821A2690(ctx, base);
	// 821A27C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A27C8: 48000030  b 0x821a27f8
	pc = 0x821A27F8; continue 'dispatch;
            }
            0x821A27CC => {
    //   block [0x821A27CC..0x821A27F4)
	// 821A27CC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821A27D0: 409A0024  bne cr6, 0x821a27f4
	if !ctx.cr[6].eq {
	pc = 0x821A27F4; continue 'dispatch;
	}
	// 821A27D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A27D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A27DC: 488FE995  bl 0x82aa1170
	ctx.lr = 0x821A27E0;
	sub_82AA1170(ctx, base);
	// 821A27E0: 389E02F0  addi r4, r30, 0x2f0
	ctx.r[4].s64 = ctx.r[30].s64 + 752;
	// 821A27E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A27E8: 4BFFFEA9  bl 0x821a2690
	ctx.lr = 0x821A27EC;
	sub_821A2690(ctx, base);
	// 821A27EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A27F0: 48000008  b 0x821a27f8
	pc = 0x821A27F8; continue 'dispatch;
            }
            0x821A27F4 => {
    //   block [0x821A27F4..0x821A27F8)
	// 821A27F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821A27F8; continue 'dispatch;
            }
            0x821A27F8 => {
    //   block [0x821A27F8..0x821A2810)
	// 821A27F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A27FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A2800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A2804: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A2808: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A280C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A2810 size=420
    let mut pc: u32 = 0x821A2810;
    'dispatch: loop {
        match pc {
            0x821A2810 => {
    //   block [0x821A2810..0x821A29B4)
	// 821A2810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2814: 48B06BF9  bl 0x82ca940c
	ctx.lr = 0x821A2818;
	sub_82CA93D0(ctx, base);
	// 821A2818: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A281C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A2820: 48000199  bl 0x821a29b8
	ctx.lr = 0x821A2824;
	sub_821A29B8(ctx, base);
	// 821A2824: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A2828: 39410064  addi r10, r1, 0x64
	ctx.r[10].s64 = ctx.r[1].s64 + 100;
	// 821A282C: 392BE7AC  addi r9, r11, -0x1854
	ctx.r[9].s64 = ctx.r[11].s64 + -6228;
	// 821A2830: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 821A2834: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 821A2838: C00BE7AC  lfs f0, -0x1854(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A283C: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 821A2840: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821A2844: 3C60820A  lis r3, -0x7df6
	ctx.r[3].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A29B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A29B8 size=332
    let mut pc: u32 = 0x821A29B8;
    'dispatch: loop {
        match pc {
            0x821A29B8 => {
    //   block [0x821A29B8..0x821A2B04)
	// 821A29B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A29BC: 48B06A4D  bl 0x82ca9408
	ctx.lr = 0x821A29C0;
	sub_82CA93D0(ctx, base);
	// 821A29C0: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A29C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A29C8: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 821A29CC: 3BDF01A0  addi r30, r31, 0x1a0
	ctx.r[30].s64 = ctx.r[31].s64 + 416;
	// 821A29D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A29D4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821A29D8: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A29DC: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821A29E0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821A29E4: C05F0028  lfs f2, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A29E8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821A29EC: C03F0024  lfs f1, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A29F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821A29F4: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A29F8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A29FC: 3BBF0190  addi r29, r31, 0x190
	ctx.r[29].s64 = ctx.r[31].s64 + 400;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2B08 size=592
    let mut pc: u32 = 0x821A2B08;
    'dispatch: loop {
        match pc {
            0x821A2B08 => {
    //   block [0x821A2B08..0x821A2D58)
	// 821A2B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2B0C: 48B068F9  bl 0x82ca9404
	ctx.lr = 0x821A2B10;
	sub_82CA93D0(ctx, base);
	// 821A2B10: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A2D58 size=320
    let mut pc: u32 = 0x821A2D58;
    'dispatch: loop {
        match pc {
            0x821A2D58 => {
    //   block [0x821A2D58..0x821A2E90)
	// 821A2D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2D5C: 48B066B1  bl 0x82ca940c
	ctx.lr = 0x821A2D60;
	sub_82CA93D0(ctx, base);
	// 821A2D60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2D64: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821A2D68: 896970C3  lbz r11, 0x70c3(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(28867 as u32) ) } as u64;
	// 821A2D6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2D70: 419A0120  beq cr6, 0x821a2e90
	if ctx.cr[6].eq {
	pc = 0x821A2E90; continue 'dispatch;
	}
	// 821A2D74: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821A2D78: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 821A2D7C: 390B6088  addi r8, r11, 0x6088
	ctx.r[8].s64 = ctx.r[11].s64 + 24712;
	// 821A2D80: 38EA4700  addi r7, r10, 0x4700
	ctx.r[7].s64 = ctx.r[10].s64 + 18176;
	// 821A2D84: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 821A2D88: 20A40000  subfic r5, r4, 0
	ctx.xer.ca = ctx.r[4].u32 <= 0 as u32;
	ctx.r[5].s64 = (0 as i64) - ctx.r[4].s64;
	// 821A2D8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A2D90: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A2D94: 7CA52910  subfe r5, r5, r5
	let x = (!ctx.r[5].u32);
	let y = ctx.r[5].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[5].u32 = res;
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A2D98: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	pc = 0x821A2E90; continue 'dispatch;
            }
            0x821A2E90 => {
    //   block [0x821A2E90..0x821A2E98)
	// 821A2E90: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A2E94: 48B065C8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A2E98 size=532
    let mut pc: u32 = 0x821A2E98;
    'dispatch: loop {
        match pc {
            0x821A2E98 => {
    //   block [0x821A2E98..0x821A2EF4)
	// 821A2E98: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 821A2E9C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821A2EA0: 81640100  lwz r11, 0x100(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(256 as u32) ) } as u64;
	// 821A2EA4: 38A0FFE0  li r5, -0x20
	ctx.r[5].s64 = -32;
	// 821A2EA8: 3900FFF0  li r8, -0x10
	ctx.r[8].s64 = -16;
	// 821A2EAC: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 821A2EB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A2EB4: 7D6A1670  srawi r10, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821A2EB8: 7D6A0195  addze. r11, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[11].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A2EBC: 916300E0  stw r11, 0xe0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 821A2EC0: 4182017C  beq 0x821a303c
	if ctx.cr[0].eq {
	pc = 0x821A303C; continue 'dispatch;
	}
	// 821A2EC4: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 821A2EC8: 38E40020  addi r7, r4, 0x20
	ctx.r[7].s64 = ctx.r[4].s64 + 32;
	// 821A2ECC: 39630020  addi r11, r3, 0x20
	ctx.r[11].s64 = ctx.r[3].s64 + 32;
	// 821A2ED0: 3BE00010  li r31, 0x10
	ctx.r[31].s64 = 16;
	// 821A2ED4: 81440100  lwz r10, 0x100(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(256 as u32) ) } as u64;
	// 821A2ED8: 3BC9FFFE  addi r30, r9, -2
	ctx.r[30].s64 = ctx.r[9].s64 + -2;
	// 821A2EDC: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A2EE0: 40980014  bge cr6, 0x821a2ef4
	if !ctx.cr[6].lt {
	pc = 0x821A2EF4; continue 'dispatch;
	}
	// 821A2EE4: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	pc = 0x821A2EF4; continue 'dispatch;
            }
            0x821A2EF4 => {
    //   block [0x821A2EF4..0x821A303C)
	// 821A2EF4: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A2EF8: 3BC1FFE0  addi r30, r1, -0x20
	ctx.r[30].s64 = ctx.r[1].s64 + -32;
	// 821A2EFC: 7D4A2214  add r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	pc = 0x821A303C; continue 'dispatch;
            }
            0x821A303C => {
    //   block [0x821A303C..0x821A30AC)
	// 821A303C: 816300E0  lwz r11, 0xe0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) } as u64;
	// 821A3040: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 821A3044: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A3048: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A304C: 40990054  ble cr6, 0x821a30a0
	if !ctx.cr[6].gt {
	pc = 0x821A30A0; continue 'dispatch;
	}
	// 821A3050: 39630020  addi r11, r3, 0x20
	ctx.r[11].s64 = ctx.r[3].s64 + 32;
	// 821A3054: 394300A0  addi r10, r3, 0xa0
	ctx.r[10].s64 = ctx.r[3].s64 + 160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A30B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A30B0 size=16
    let mut pc: u32 = 0x821A30B0;
    'dispatch: loop {
        match pc {
            0x821A30B0 => {
    //   block [0x821A30B0..0x821A30C0)
	// 821A30B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A30B4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A30B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A30BC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A30C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A30C0 size=60
    let mut pc: u32 = 0x821A30C0;
    'dispatch: loop {
        match pc {
            0x821A30C0 => {
    //   block [0x821A30C0..0x821A30FC)
	// 821A30C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A30C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A30C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A30CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A30D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821A30D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821A30D8: 388B17A4  addi r4, r11, 0x17a4
	ctx.r[4].s64 = ctx.r[11].s64 + 6052;
	// 821A30DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A30E0: 48089DF1  bl 0x8222ced0
	ctx.lr = 0x821A30E4;
	sub_8222CED0(ctx, base);
	// 821A30E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A30E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A30EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A30F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A30F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A30F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3100 size=280
    let mut pc: u32 = 0x821A3100;
    'dispatch: loop {
        match pc {
            0x821A3100 => {
    //   block [0x821A3100..0x821A3218)
	// 821A3100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A3104: 48B062FD  bl 0x82ca9400
	ctx.lr = 0x821A3108;
	sub_82CA93D0(ctx, base);
	// 821A3108: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821A310C: C1A3001C  lfs f13, 0x1c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A3110: 394005B0  li r10, 0x5b0
	ctx.r[10].s64 = 1456;
	// 821A3114: C1830034  lfs f12, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A3118: 3921FFB0  addi r9, r1, -0x50
	ctx.r[9].s64 = ctx.r[1].s64 + -80;
	// 821A311C: 3BC1FFB0  addi r30, r1, -0x50
	ctx.r[30].s64 = ctx.r[1].s64 + -80;
	// 821A3120: 3BA1FFB0  addi r29, r1, -0x50
	ctx.r[29].s64 = ctx.r[1].s64 + -80;
	// 821A3124: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821A3128: 3B81FFB0  addi r28, r1, -0x50
	ctx.r[28].s64 = ctx.r[1].s64 + -80;
	// 821A312C: 3B61FFB0  addi r27, r1, -0x50
	ctx.r[27].s64 = ctx.r[1].s64 + -80;
	// 821A3130: 3B41FFB0  addi r26, r1, -0x50
	ctx.r[26].s64 = ctx.r[1].s64 + -80;
	// 821A3134: 39000570  li r8, 0x570
	ctx.r[8].s64 = 1392;
	// 821A3138: 38E00580  li r7, 0x580
	ctx.r[7].s64 = 1408;
	// 821A313C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3140: 38C00590  li r6, 0x590
	ctx.r[6].s64 = 1424;
	// 821A3144: 38A005A0  li r5, 0x5a0
	ctx.r[5].s64 = 1440;
	// 821A3148: 3BE005C0  li r31, 0x5c0
	ctx.r[31].s64 = 1472;
	// 821A314C: 816B0058  lwz r11, 0x58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A3150: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A3154: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A3158: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A3218 size=128
    let mut pc: u32 = 0x821A3218;
    'dispatch: loop {
        match pc {
            0x821A3218 => {
    //   block [0x821A3218..0x821A3260)
	// 821A3218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A321C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A3220: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A3224: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821A3228: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821A322C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A3230: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821A3234: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821A3238: 81690038  lwz r11, 0x38(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(56 as u32) ) } as u64;
	// 821A323C: 890B000C  lbz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3240: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A3244: 409A001C  bne cr6, 0x821a3260
	if !ctx.cr[6].eq {
	pc = 0x821A3260; continue 'dispatch;
	}
	// 821A3248: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821A324C: C1AB0004  lfs f13, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A3250: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A3254: C0099484  lfs f0, -0x6b7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3258: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821A325C: 40990008  ble cr6, 0x821a3264
	if !ctx.cr[6].gt {
	pc = 0x821A3264; continue 'dispatch;
	}
	pc = 0x821A3260; continue 'dispatch;
            }
            0x821A3260 => {
    //   block [0x821A3260..0x821A3264)
	// 821A3260: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821A3264; continue 'dispatch;
            }
            0x821A3264 => {
    //   block [0x821A3264..0x821A3274)
	// 821A3264: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A3268: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A326C: 419A0008  beq cr6, 0x821a3274
	if ctx.cr[6].eq {
	pc = 0x821A3274; continue 'dispatch;
	}
	// 821A3270: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821A3274; continue 'dispatch;
            }
            0x821A3274 => {
    //   block [0x821A3274..0x821A3298)
	// 821A3274: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 821A3278: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821A327C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821A3280: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821A3284: 480F3F05  bl 0x82297188
	ctx.lr = 0x821A3288;
	sub_82297188(ctx, base);
	// 821A3288: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A328C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A3290: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A3294: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3298 size=548
    let mut pc: u32 = 0x821A3298;
    'dispatch: loop {
        match pc {
            0x821A3298 => {
    //   block [0x821A3298..0x821A34BC)
	// 821A3298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A329C: 48B06171  bl 0x82ca940c
	ctx.lr = 0x821A32A0;
	sub_82CA93D0(ctx, base);
	// 821A32A0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821A32A4: 48B0AA35  bl 0x82cadcd8
	ctx.lr = 0x821A32A8;
	sub_82CADCA0(ctx, base);
	// 821A32A8: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A34C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A34C0 size=116
    let mut pc: u32 = 0x821A34C0;
    'dispatch: loop {
        match pc {
            0x821A34C0 => {
    //   block [0x821A34C0..0x821A3500)
	// 821A34C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A34C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A34C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A34CC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821A34D0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A34D4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821A34D8: C00A92D8  lfs f0, -0x6d28(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27944 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A34DC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A34E0: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A34E4: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A34E8: C1A70084  lfs f13, 0x84(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A34EC: C1870080  lfs f12, 0x80(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(128 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A34F0: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 821A34F4: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 821A34F8: 40980008  bge cr6, 0x821a3500
	if !ctx.cr[6].lt {
	pc = 0x821A3500; continue 'dispatch;
	}
	// 821A34FC: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	pc = 0x821A3500; continue 'dispatch;
            }
            0x821A3500 => {
    //   block [0x821A3500..0x821A3520)
	// 821A3500: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A3504: 419A001C  beq cr6, 0x821a3520
	if ctx.cr[6].eq {
	pc = 0x821A3520; continue 'dispatch;
	}
	// 821A3508: 480641C1  bl 0x822076c8
	ctx.lr = 0x821A350C;
	sub_822076C8(ctx, base);
	// 821A350C: EC210332  fmuls f1, f1, f12
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 821A3510: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A3514: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A3518: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A351C: 4E800020  blr
	return;
            }
            0x821A3520 => {
    //   block [0x821A3520..0x821A3534)
	// 821A3520: FC206090  fmr f1, f12
	ctx.f[1].f64 = ctx.f[12].f64;
	// 821A3524: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A3528: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A352C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A3530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3538 size=208
    let mut pc: u32 = 0x821A3538;
    'dispatch: loop {
        match pc {
            0x821A3538 => {
    //   block [0x821A3538..0x821A3608)
	// 821A3538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A353C: 48B05ED1  bl 0x82ca940c
	ctx.lr = 0x821A3540;
	sub_82CA93D0(ctx, base);
	// 821A3540: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A3608 size=116
    let mut pc: u32 = 0x821A3608;
    'dispatch: loop {
        match pc {
            0x821A3608 => {
    //   block [0x821A3608..0x821A3654)
	// 821A3608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A360C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A3610: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 821A3614: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A3618: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821A361C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A3620: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821A3624: C3EA9484  lfs f31, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A3628: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A362C: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A3630: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A3634: 80C70008  lwz r6, 8(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3638: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A363C: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A3640: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A3644: 419A0010  beq cr6, 0x821a3654
	if ctx.cr[6].eq {
	pc = 0x821A3654; continue 'dispatch;
	}
	// 821A3648: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A364C: 4804B615  bl 0x821eec60
	ctx.lr = 0x821A3650;
	sub_821EEC60(ctx, base);
	// 821A3650: 48000008  b 0x821a3658
	pc = 0x821A3658; continue 'dispatch;
            }
            0x821A3654 => {
    //   block [0x821A3654..0x821A3658)
	// 821A3654: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x821A3658; continue 'dispatch;
            }
            0x821A3658 => {
    //   block [0x821A3658..0x821A3668)
	// 821A3658: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 821A365C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A3660: 41990008  bgt cr6, 0x821a3668
	if ctx.cr[6].gt {
	pc = 0x821A3668; continue 'dispatch;
	}
	// 821A3664: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821A3668; continue 'dispatch;
            }
            0x821A3668 => {
    //   block [0x821A3668..0x821A367C)
	// 821A3668: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A366C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A3670: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A3674: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A3678: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A3680 size=1016
    let mut pc: u32 = 0x821A3680;
    'dispatch: loop {
        match pc {
            0x821A3680 => {
    //   block [0x821A3680..0x821A370C)
	// 821A3680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A3684: 48B05D89  bl 0x82ca940c
	ctx.lr = 0x821A3688;
	sub_82CA93D0(ctx, base);
	// 821A3688: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A368C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821A3690: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A3694: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3698: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821A369C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A36A0: 409A03CC  bne cr6, 0x821a3a6c
	if !ctx.cr[6].eq {
	pc = 0x821A3A6C; continue 'dispatch;
	}
	// 821A36A4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821A36A8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821A36AC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A36B0: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A36B4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A36B8: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A36BC: 4808F0BD  bl 0x82232778
	ctx.lr = 0x821A36C0;
	sub_82232778(ctx, base);
	// 821A36C0: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821A36C4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A36C8: 409A03A4  bne cr6, 0x821a3a6c
	if !ctx.cr[6].eq {
	pc = 0x821A3A6C; continue 'dispatch;
	}
	// 821A36CC: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A36D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A36D4: 556A37FE  rlwinm r10, r11, 6, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 821A36D8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821A36DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A36E0: 419A00E8  beq cr6, 0x821a37c8
	if ctx.cr[6].eq {
	pc = 0x821A37C8; continue 'dispatch;
	}
	// 821A36E4: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A36E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A36EC: 419A0020  beq cr6, 0x821a370c
	if ctx.cr[6].eq {
	pc = 0x821A370C; continue 'dispatch;
	}
	// 821A36F0: 894B007A  lbz r10, 0x7a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(122 as u32) ) } as u64;
	// 821A36F4: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A36F8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A36FC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A3700: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A3704: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A3708: 480000C4  b 0x821a37cc
	pc = 0x821A37CC; continue 'dispatch;
            }
            0x821A370C => {
    //   block [0x821A370C..0x821A3728)
	// 821A370C: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A3710: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A3714: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821A3718: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A371C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821A3720: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A3724: 40810054  ble 0x821a3778
	if !ctx.cr[0].gt {
	pc = 0x821A3778; continue 'dispatch;
	}
	pc = 0x821A3728; continue 'dispatch;
            }
            0x821A3728 => {
    //   block [0x821A3728..0x821A3748)
	// 821A3728: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A372C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A3730: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821A3734: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3738: 2F07007A  cmpwi cr6, r7, 0x7a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 122, &mut ctx.xer);
	// 821A373C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A3740: 41980008  blt cr6, 0x821a3748
	if ctx.cr[6].lt {
	pc = 0x821A3748; continue 'dispatch;
	}
	// 821A3744: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x821A3748; continue 'dispatch;
            }
            0x821A3748 => {
    //   block [0x821A3748..0x821A3764)
	// 821A3748: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A374C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A3750: 419A0014  beq cr6, 0x821a3764
	if ctx.cr[6].eq {
	pc = 0x821A3764; continue 'dispatch;
	}
	// 821A3754: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A3758: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A375C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A3760: 4800000C  b 0x821a376c
	pc = 0x821A376C; continue 'dispatch;
            }
            0x821A3764 => {
    //   block [0x821A3764..0x821A376C)
	// 821A3764: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A3768: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A376C; continue 'dispatch;
            }
            0x821A376C => {
    //   block [0x821A376C..0x821A3778)
	// 821A376C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A3770: 4199FFB8  bgt cr6, 0x821a3728
	if ctx.cr[6].gt {
	pc = 0x821A3728; continue 'dispatch;
	}
	// 821A3774: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821A3778; continue 'dispatch;
            }
            0x821A3778 => {
    //   block [0x821A3778..0x821A3794)
	// 821A3778: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A377C: 419A003C  beq cr6, 0x821a37b8
	if ctx.cr[6].eq {
	pc = 0x821A37B8; continue 'dispatch;
	}
	// 821A3780: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3784: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 821A3788: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A378C: 41990008  bgt cr6, 0x821a3794
	if ctx.cr[6].gt {
	pc = 0x821A3794; continue 'dispatch;
	}
	// 821A3790: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821A3794; continue 'dispatch;
            }
            0x821A3794 => {
    //   block [0x821A3794..0x821A37B8)
	// 821A3794: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A3798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A379C: 409A001C  bne cr6, 0x821a37b8
	if !ctx.cr[6].eq {
	pc = 0x821A37B8; continue 'dispatch;
	}
	// 821A37A0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A37A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A37A8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A37AC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A37B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A37B4: 48000018  b 0x821a37cc
	pc = 0x821A37CC; continue 'dispatch;
            }
            0x821A37B8 => {
    //   block [0x821A37B8..0x821A37C8)
	// 821A37B8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821A37BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A37C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A37C4: 48000008  b 0x821a37cc
	pc = 0x821A37CC; continue 'dispatch;
            }
            0x821A37C8 => {
    //   block [0x821A37C8..0x821A37CC)
	// 821A37C8: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x821A37CC; continue 'dispatch;
            }
            0x821A37CC => {
    //   block [0x821A37CC..0x821A382C)
	// 821A37CC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821A37D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A37D4: 419A0138  beq cr6, 0x821a390c
	if ctx.cr[6].eq {
	pc = 0x821A390C; continue 'dispatch;
	}
	// 821A37D8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A37DC: 4801F23D  bl 0x821c2a18
	ctx.lr = 0x821A37E0;
	sub_821C2A18(ctx, base);
	// 821A37E0: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 821A37E4: 409A0128  bne cr6, 0x821a390c
	if !ctx.cr[6].eq {
	pc = 0x821A390C; continue 'dispatch;
	}
	// 821A37E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A37EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A37F0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A37F4: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 821A37F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A37FC: 419A00F4  beq cr6, 0x821a38f0
	if ctx.cr[6].eq {
	pc = 0x821A38F0; continue 'dispatch;
	}
	// 821A3800: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A3804: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A3808: 419A0024  beq cr6, 0x821a382c
	if ctx.cr[6].eq {
	pc = 0x821A382C; continue 'dispatch;
	}
	// 821A380C: 894A007A  lbz r10, 0x7a(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(122 as u32) ) } as u64;
	// 821A3810: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A3814: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A3818: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A381C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A3820: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A3824: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A3828: 480000CC  b 0x821a38f4
	pc = 0x821A38F4; continue 'dispatch;
            }
            0x821A382C => {
    //   block [0x821A382C..0x821A3848)
	// 821A382C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A3830: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A3834: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821A3838: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A383C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821A3840: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A3844: 40810054  ble 0x821a3898
	if !ctx.cr[0].gt {
	pc = 0x821A3898; continue 'dispatch;
	}
	pc = 0x821A3848; continue 'dispatch;
            }
            0x821A3848 => {
    //   block [0x821A3848..0x821A3868)
	// 821A3848: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A384C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A3850: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821A3854: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3858: 2F07007A  cmpwi cr6, r7, 0x7a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 122, &mut ctx.xer);
	// 821A385C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A3860: 41980008  blt cr6, 0x821a3868
	if ctx.cr[6].lt {
	pc = 0x821A3868; continue 'dispatch;
	}
	// 821A3864: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x821A3868; continue 'dispatch;
            }
            0x821A3868 => {
    //   block [0x821A3868..0x821A3884)
	// 821A3868: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A386C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A3870: 419A0014  beq cr6, 0x821a3884
	if ctx.cr[6].eq {
	pc = 0x821A3884; continue 'dispatch;
	}
	// 821A3874: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A3878: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A387C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A3880: 4800000C  b 0x821a388c
	pc = 0x821A388C; continue 'dispatch;
            }
            0x821A3884 => {
    //   block [0x821A3884..0x821A388C)
	// 821A3884: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A3888: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A388C; continue 'dispatch;
            }
            0x821A388C => {
    //   block [0x821A388C..0x821A3898)
	// 821A388C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A3890: 4199FFB8  bgt cr6, 0x821a3848
	if ctx.cr[6].gt {
	pc = 0x821A3848; continue 'dispatch;
	}
	// 821A3894: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821A3898; continue 'dispatch;
            }
            0x821A3898 => {
    //   block [0x821A3898..0x821A38B4)
	// 821A3898: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A389C: 419A0040  beq cr6, 0x821a38dc
	if ctx.cr[6].eq {
	pc = 0x821A38DC; continue 'dispatch;
	}
	// 821A38A0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A38A4: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 821A38A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A38AC: 41990008  bgt cr6, 0x821a38b4
	if ctx.cr[6].gt {
	pc = 0x821A38B4; continue 'dispatch;
	}
	// 821A38B0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821A38B4; continue 'dispatch;
            }
            0x821A38B4 => {
    //   block [0x821A38B4..0x821A38DC)
	// 821A38B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A38B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A38BC: 409A0020  bne cr6, 0x821a38dc
	if !ctx.cr[6].eq {
	pc = 0x821A38DC; continue 'dispatch;
	}
	// 821A38C0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A38C4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A38C8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A38CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A38D0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A38D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A38D8: 4800001C  b 0x821a38f4
	pc = 0x821A38F4; continue 'dispatch;
            }
            0x821A38DC => {
    //   block [0x821A38DC..0x821A38F0)
	// 821A38DC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821A38E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A38E4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A38E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A38EC: 48000008  b 0x821a38f4
	pc = 0x821A38F4; continue 'dispatch;
            }
            0x821A38F0 => {
    //   block [0x821A38F0..0x821A38F4)
	// 821A38F0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821A38F4; continue 'dispatch;
            }
            0x821A38F4 => {
    //   block [0x821A38F4..0x821A390C)
	// 821A38F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A38F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A38FC: 419A0170  beq cr6, 0x821a3a6c
	if ctx.cr[6].eq {
	pc = 0x821A3A6C; continue 'dispatch;
	}
	// 821A3900: 4801F119  bl 0x821c2a18
	ctx.lr = 0x821A3904;
	sub_821C2A18(ctx, base);
	// 821A3904: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 821A3908: 409A0164  bne cr6, 0x821a3a6c
	if !ctx.cr[6].eq {
	pc = 0x821A3A6C; continue 'dispatch;
	}
	pc = 0x821A390C; continue 'dispatch;
            }
            0x821A390C => {
    //   block [0x821A390C..0x821A3938)
	// 821A390C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A3910: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A3914: 48122A05  bl 0x822c6318
	ctx.lr = 0x821A3918;
	sub_822C6318(ctx, base);
	// 821A3918: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821A391C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A3920: 419A014C  beq cr6, 0x821a3a6c
	if ctx.cr[6].eq {
	pc = 0x821A3A6C; continue 'dispatch;
	}
	// 821A3924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A3928: 4804AA21  bl 0x821ee348
	ctx.lr = 0x821A392C;
	sub_821EE348(ctx, base);
	// 821A392C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821A3930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A3934: 409A0010  bne cr6, 0x821a3944
	if !ctx.cr[6].eq {
	pc = 0x821A3944; continue 'dispatch;
	}
	pc = 0x821A3938; continue 'dispatch;
            }
            0x821A3938 => {
    //   block [0x821A3938..0x821A3944)
	// 821A3938: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A393C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A3940: 48B05B1C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A3944 => {
    //   block [0x821A3944..0x821A3988)
	// 821A3944: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A3948: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A394C: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821A3950: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821A3954: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A3958: 419A00F4  beq cr6, 0x821a3a4c
	if ctx.cr[6].eq {
	pc = 0x821A3A4C; continue 'dispatch;
	}
	// 821A395C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A3960: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A3964: 419A0024  beq cr6, 0x821a3988
	if ctx.cr[6].eq {
	pc = 0x821A3988; continue 'dispatch;
	}
	// 821A3968: 892A0085  lbz r9, 0x85(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(133 as u32) ) } as u64;
	// 821A396C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A3970: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821A3974: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A3978: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A397C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A3980: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A3984: 480000CC  b 0x821a3a50
	pc = 0x821A3A50; continue 'dispatch;
            }
            0x821A3988 => {
    //   block [0x821A3988..0x821A39A4)
	// 821A3988: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A398C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A3990: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821A3994: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A3998: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821A399C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A39A0: 40810054  ble 0x821a39f4
	if !ctx.cr[0].gt {
	pc = 0x821A39F4; continue 'dispatch;
	}
	pc = 0x821A39A4; continue 'dispatch;
            }
            0x821A39A4 => {
    //   block [0x821A39A4..0x821A39C4)
	// 821A39A4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A39A8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A39AC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821A39B0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A39B4: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 821A39B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A39BC: 41980008  blt cr6, 0x821a39c4
	if ctx.cr[6].lt {
	pc = 0x821A39C4; continue 'dispatch;
	}
	// 821A39C0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x821A39C4; continue 'dispatch;
            }
            0x821A39C4 => {
    //   block [0x821A39C4..0x821A39E0)
	// 821A39C4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A39C8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A39CC: 419A0014  beq cr6, 0x821a39e0
	if ctx.cr[6].eq {
	pc = 0x821A39E0; continue 'dispatch;
	}
	// 821A39D0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A39D4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A39D8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A39DC: 4800000C  b 0x821a39e8
	pc = 0x821A39E8; continue 'dispatch;
            }
            0x821A39E0 => {
    //   block [0x821A39E0..0x821A39E8)
	// 821A39E0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A39E4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A39E8; continue 'dispatch;
            }
            0x821A39E8 => {
    //   block [0x821A39E8..0x821A39F4)
	// 821A39E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A39EC: 4199FFB8  bgt cr6, 0x821a39a4
	if ctx.cr[6].gt {
	pc = 0x821A39A4; continue 'dispatch;
	}
	// 821A39F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821A39F4; continue 'dispatch;
            }
            0x821A39F4 => {
    //   block [0x821A39F4..0x821A3A10)
	// 821A39F4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A39F8: 419A0040  beq cr6, 0x821a3a38
	if ctx.cr[6].eq {
	pc = 0x821A3A38; continue 'dispatch;
	}
	// 821A39FC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3A00: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 821A3A04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A3A08: 41990008  bgt cr6, 0x821a3a10
	if ctx.cr[6].gt {
	pc = 0x821A3A10; continue 'dispatch;
	}
	// 821A3A0C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821A3A10; continue 'dispatch;
            }
            0x821A3A10 => {
    //   block [0x821A3A10..0x821A3A38)
	// 821A3A10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A3A14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A3A18: 409A0020  bne cr6, 0x821a3a38
	if !ctx.cr[6].eq {
	pc = 0x821A3A38; continue 'dispatch;
	}
	// 821A3A1C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A3A20: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A3A24: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A3A28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A3A2C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A3A30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A3A34: 4800001C  b 0x821a3a50
	pc = 0x821A3A50; continue 'dispatch;
            }
            0x821A3A38 => {
    //   block [0x821A3A38..0x821A3A4C)
	// 821A3A38: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821A3A3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A3A40: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A3A44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A3A48: 48000008  b 0x821a3a50
	pc = 0x821A3A50; continue 'dispatch;
            }
            0x821A3A4C => {
    //   block [0x821A3A4C..0x821A3A50)
	// 821A3A4C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821A3A50; continue 'dispatch;
            }
            0x821A3A50 => {
    //   block [0x821A3A50..0x821A3A6C)
	// 821A3A50: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A3A54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A3A58: 419AFEE0  beq cr6, 0x821a3938
	if ctx.cr[6].eq {
	pc = 0x821A3938; continue 'dispatch;
	}
	// 821A3A5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A3A60: 48060539  bl 0x82203f98
	ctx.lr = 0x821A3A64;
	sub_82203F98(ctx, base);
	// 821A3A64: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 821A3A68: 419AFED0  beq cr6, 0x821a3938
	if ctx.cr[6].eq {
	pc = 0x821A3938; continue 'dispatch;
	}
	pc = 0x821A3A6C; continue 'dispatch;
            }
            0x821A3A6C => {
    //   block [0x821A3A6C..0x821A3A78)
	// 821A3A6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A3A70: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A3A74: 48B059E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A3A78 size=152
    let mut pc: u32 = 0x821A3A78;
    'dispatch: loop {
        match pc {
            0x821A3A78 => {
    //   block [0x821A3A78..0x821A3AF8)
	// 821A3A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A3A7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A3A80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A3A84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A3A88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A3A8C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821A3A90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A3A94: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821A3A98: 41980060  blt cr6, 0x821a3af8
	if ctx.cr[6].lt {
	pc = 0x821A3AF8; continue 'dispatch;
	}
	// 821A3A9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A3AA0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 821A3AA4: 48085665  bl 0x82229108
	ctx.lr = 0x821A3AA8;
	sub_82229108(ctx, base);
	// 821A3AA8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821A3AAC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 821A3AB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A3AB4: 4809DDDD  bl 0x82241890
	ctx.lr = 0x821A3AB8;
	sub_82241890(ctx, base);
	// 821A3AB8: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 821A3ABC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3AC0: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 821A3AC4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A3AC8: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A3ACC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821A3AD0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A3AD4: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A3AD8: D1890000  stfs f12, 0(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3ADC: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A3AE0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 821A3AE4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3AE8: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 821A3AEC: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821A3AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A3AF4: 4809DD9D  bl 0x82241890
	ctx.lr = 0x821A3AF8;
	sub_82241890(ctx, base);
	pc = 0x821A3AF8; continue 'dispatch;
            }
            0x821A3AF8 => {
    //   block [0x821A3AF8..0x821A3B10)
	// 821A3AF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A3AFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A3B00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A3B04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A3B08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A3B0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3B10 size=5056
    let mut pc: u32 = 0x821A3B10;
    'dispatch: loop {
        match pc {
            0x821A3B10 => {
    //   block [0x821A3B10..0x821A4ED0)
	// 821A3B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A3B14: 48B058BD  bl 0x82ca93d0
	ctx.lr = 0x821A3B18;
	sub_82CA93D0(ctx, base);
	// 821A3B18: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821A3B1C: 48B0A1B5  bl 0x82cadcd0
	ctx.lr = 0x821A3B20;
	sub_82CADCA0(ctx, base);
	// 821A3B20: 3980FF20  li r12, -0xe0
	ctx.r[12].s64 = -224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A4ED0 size=180
    let mut pc: u32 = 0x821A4ED0;
    'dispatch: loop {
        match pc {
            0x821A4ED0 => {
    //   block [0x821A4ED0..0x821A4F44)
	// 821A4ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A4ED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A4ED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A4EDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A4EE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A4EE4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821A4EE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821A4EEC: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 821A4EF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A4EF4: 806B6F1C  lwz r3, 0x6f1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28444 as u32) ) } as u64;
	// 821A4EF8: 48A462E9  bl 0x82beb1e0
	ctx.lr = 0x821A4EFC;
	sub_82BEB1E0(ctx, base);
	// 821A4EFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A4F00: 419A0044  beq cr6, 0x821a4f44
	if ctx.cr[6].eq {
	pc = 0x821A4F44; continue 'dispatch;
	}
	// 821A4F04: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821A4F08: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A4F0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A4F10: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 821A4F14: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821A4F18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A4F1C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821A4F20: 38E80FAC  addi r7, r8, 0xfac
	ctx.r[7].s64 = ctx.r[8].s64 + 4012;
	// 821A4F24: 81496F18  lwz r10, 0x6f18(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28440 as u32) ) } as u64;
	// 821A4F28: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821A4F2C: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821A4F30: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 821A4F34: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821A4F38: 91696F18  stw r11, 0x6f18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28440 as u32), ctx.r[11].u32 ) };
	// 821A4F3C: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 821A4F40: 48000008  b 0x821a4f48
	pc = 0x821A4F48; continue 'dispatch;
            }
            0x821A4F44 => {
    //   block [0x821A4F44..0x821A4F48)
	// 821A4F44: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x821A4F48; continue 'dispatch;
            }
            0x821A4F48 => {
    //   block [0x821A4F48..0x821A4F84)
	// 821A4F48: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A4F4C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4F50: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 821A4F54: 386B02A0  addi r3, r11, 0x2a0
	ctx.r[3].s64 = ctx.r[11].s64 + 672;
	// 821A4F58: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821A4F5C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A4F60: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821A4F64: FC206818  frsp f1, f13
	ctx.f[1].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A4F68: 48087349  bl 0x8222c2b0
	ctx.lr = 0x821A4F6C;
	sub_8222C2B0(ctx, base);
	// 821A4F6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A4F70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A4F74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A4F78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A4F7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A4F80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A4F88 size=376
    let mut pc: u32 = 0x821A4F88;
    'dispatch: loop {
        match pc {
            0x821A4F88 => {
    //   block [0x821A4F88..0x821A5018)
	// 821A4F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A4F8C: 48B0447D  bl 0x82ca9408
	ctx.lr = 0x821A4F90;
	sub_82CA93D0(ctx, base);
	// 821A4F90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A4F94: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821A4F98: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821A4F9C: 3BEA63A0  addi r31, r10, 0x63a0
	ctx.r[31].s64 = ctx.r[10].s64 + 25504;
	// 821A4FA0: 3BCB2390  addi r30, r11, 0x2390
	ctx.r[30].s64 = ctx.r[11].s64 + 9104;
	// 821A4FA4: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821A4FA8: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 821A4FAC: 3B8A0DB8  addi r28, r10, 0xdb8
	ctx.r[28].s64 = ctx.r[10].s64 + 3512;
	// 821A4FB0: 897F1ACD  lbz r11, 0x1acd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6861 as u32) ) } as u64;
	// 821A4FB4: 815F1ABC  lwz r10, 0x1abc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6844 as u32) ) } as u64;
	// 821A4FB8: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821A4FBC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821A4FC0: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 821A4FC4: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821A4FC8: 419A0080  beq cr6, 0x821a5048
	if ctx.cr[6].eq {
	pc = 0x821A5048; continue 'dispatch;
	}
	// 821A4FCC: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821A4FD0: 813F1AC0  lwz r9, 0x1ac0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6848 as u32) ) } as u64;
	// 821A4FD4: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821A4FD8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A4FDC: 409A003C  bne cr6, 0x821a5018
	if !ctx.cr[6].eq {
	pc = 0x821A5018; continue 'dispatch;
	}
	// 821A4FE0: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821A4FE4: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821A4FE8: 38FF1AB8  addi r7, r31, 0x1ab8
	ctx.r[7].s64 = ctx.r[31].s64 + 6840;
	// 821A4FEC: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821A4FF0: 915F1AC0  stw r10, 0x1ac0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6848 as u32), ctx.r[10].u32 ) };
	// 821A4FF4: 7CE6592E  stwx r7, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821A4FF8: 815F1ABC  lwz r10, 0x1abc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6844 as u32) ) } as u64;
	// 821A4FFC: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821A5000: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A5004: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821A5008: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A500C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821A5010: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 821A5014: 910B2004  stw r8, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x821A5018; continue 'dispatch;
            }
            0x821A5018 => {
    //   block [0x821A5018..0x821A5048)
	// 821A5018: 897F1ACC  lbz r11, 0x1acc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6860 as u32) ) } as u64;
	// 821A501C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A5020: 915F1ABC  stw r10, 0x1abc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6844 as u32), ctx.r[10].u32 ) };
	// 821A5024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5028: 409A0020  bne cr6, 0x821a5048
	if !ctx.cr[6].eq {
	pc = 0x821A5048; continue 'dispatch;
	}
	// 821A502C: 817D0DB0  lwz r11, 0xdb0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821A5030: 393F1AB8  addi r9, r31, 0x1ab8
	ctx.r[9].s64 = ctx.r[31].s64 + 6840;
	// 821A5034: 995F1ACC  stb r10, 0x1acc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6860 as u32), ctx.r[10].u8 ) };
	// 821A5038: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A503C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A5040: 917D0DB0  stw r11, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 821A5044: 7D28E12E  stwx r9, r8, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	pc = 0x821A5048; continue 'dispatch;
            }
            0x821A5048 => {
    //   block [0x821A5048..0x821A50C4)
	// 821A5048: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A504C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5050: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821A5054: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A5058: 4E800421  bctrl
	ctx.lr = 0x821A505C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A505C: 817F1ABC  lwz r11, 0x1abc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6844 as u32) ) } as u64;
	// 821A5060: 893F1ACD  lbz r9, 0x1acd(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6861 as u32) ) } as u64;
	// 821A5064: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5068: 1D692008  mulli r11, r9, 0x2008
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821A506C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821A5070: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821A5074: 419A0084  beq cr6, 0x821a50f8
	if ctx.cr[6].eq {
	pc = 0x821A50F8; continue 'dispatch;
	}
	// 821A5078: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821A507C: 813F1AC0  lwz r9, 0x1ac0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6848 as u32) ) } as u64;
	// 821A5080: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821A5084: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A5088: 409A003C  bne cr6, 0x821a50c4
	if !ctx.cr[6].eq {
	pc = 0x821A50C4; continue 'dispatch;
	}
	// 821A508C: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821A5090: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821A5094: 38FF1AB8  addi r7, r31, 0x1ab8
	ctx.r[7].s64 = ctx.r[31].s64 + 6840;
	// 821A5098: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821A509C: 915F1AC0  stw r10, 0x1ac0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6848 as u32), ctx.r[10].u32 ) };
	// 821A50A0: 7CE6592E  stwx r7, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821A50A4: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821A50A8: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A50AC: 815F1ABC  lwz r10, 0x1abc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6844 as u32) ) } as u64;
	// 821A50B0: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821A50B4: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A50B8: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821A50BC: 386A0001  addi r3, r10, 1
	ctx.r[3].s64 = ctx.r[10].s64 + 1;
	// 821A50C0: 906B2004  stw r3, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
            }
            0x821A50C4 => {
    //   block [0x821A50C4..0x821A50F8)
	// 821A50C4: 897F1ACC  lbz r11, 0x1acc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6860 as u32) ) } as u64;
	// 821A50C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A50CC: 915F1ABC  stw r10, 0x1abc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6844 as u32), ctx.r[10].u32 ) };
	// 821A50D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A50D4: 409A0024  bne cr6, 0x821a50f8
	if !ctx.cr[6].eq {
	pc = 0x821A50F8; continue 'dispatch;
	}
	// 821A50D8: 817D0DB0  lwz r11, 0xdb0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821A50DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A50E0: 393F1AB8  addi r9, r31, 0x1ab8
	ctx.r[9].s64 = ctx.r[31].s64 + 6840;
	// 821A50E4: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A50E8: 995F1ACC  stb r10, 0x1acc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6860 as u32), ctx.r[10].u8 ) };
	// 821A50EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A50F0: 917D0DB0  stw r11, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 821A50F4: 7D28E12E  stwx r9, r8, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	pc = 0x821A50F8; continue 'dispatch;
            }
            0x821A50F8 => {
    //   block [0x821A50F8..0x821A5100)
	// 821A50F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A50FC: 48B0435C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A5100 size=112
    let mut pc: u32 = 0x821A5100;
    'dispatch: loop {
        match pc {
            0x821A5100 => {
    //   block [0x821A5100..0x821A5144)
	// 821A5100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5104: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A5108: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A510C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5110: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821A5114: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821A5118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A511C: 48039515  bl 0x821de630
	ctx.lr = 0x821A5120;
	sub_821DE630(ctx, base);
	// 821A5120: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 821A5124: 816AF94C  lwz r11, -0x6b4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-1716 as u32) ) } as u64;
	// 821A5128: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A512C: 916AF94C  stw r11, -0x6b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-1716 as u32), ctx.r[11].u32 ) };
	// 821A5130: 4082002C  bne 0x821a515c
	if !ctx.cr[0].eq {
	pc = 0x821A515C; continue 'dispatch;
	}
	// 821A5134: 817F06FC  lwz r11, 0x6fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821A5138: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821A513C: 409A0008  bne cr6, 0x821a5144
	if !ctx.cr[6].eq {
	pc = 0x821A5144; continue 'dispatch;
	}
	// 821A5140: 4811FFB9  bl 0x822c50f8
	ctx.lr = 0x821A5144;
	sub_822C50F8(ctx, base);
	pc = 0x821A5144; continue 'dispatch;
            }
            0x821A5144 => {
    //   block [0x821A5144..0x821A515C)
	// 821A5144: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821A5148: 386B4FF8  addi r3, r11, 0x4ff8
	ctx.r[3].s64 = ctx.r[11].s64 + 20472;
	// 821A514C: 4800CA5D  bl 0x821b1ba8
	ctx.lr = 0x821A5150;
	sub_821B1BA8(ctx, base);
	// 821A5150: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821A5154: 386A5018  addi r3, r10, 0x5018
	ctx.r[3].s64 = ctx.r[10].s64 + 20504;
	// 821A5158: 4800CA51  bl 0x821b1ba8
	ctx.lr = 0x821A515C;
	sub_821B1BA8(ctx, base);
	pc = 0x821A515C; continue 'dispatch;
            }
            0x821A515C => {
    //   block [0x821A515C..0x821A5170)
	// 821A515C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A5160: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A5164: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A5168: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A516C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A5170 size=176
    let mut pc: u32 = 0x821A5170;
    'dispatch: loop {
        match pc {
            0x821A5170 => {
    //   block [0x821A5170..0x821A51C8)
	// 821A5170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5174: 48B04291  bl 0x82ca9404
	ctx.lr = 0x821A5178;
	sub_82CA93D0(ctx, base);
	// 821A5178: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A517C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821A5180: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821A5184: 392BF820  addi r9, r11, -0x7e0
	ctx.r[9].s64 = ctx.r[11].s64 + -2016;
	// 821A5188: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821A518C: 3BDC0008  addi r30, r28, 8
	ctx.r[30].s64 = ctx.r[28].s64 + 8;
	// 821A5190: 836BF820  lwz r27, -0x7e0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2016 as u32) ) } as u64;
	// 821A5194: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A5198: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A519C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A51A0: 419A0028  beq cr6, 0x821a51c8
	if ctx.cr[6].eq {
	pc = 0x821A51C8; continue 'dispatch;
	}
	// 821A51A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A51A8: 48012971  bl 0x821b7b18
	ctx.lr = 0x821A51AC;
	sub_821B7B18(ctx, base);
	// 821A51AC: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 821A51B0: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A51B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A51B8: 419A0010  beq cr6, 0x821a51c8
	if ctx.cr[6].eq {
	pc = 0x821A51C8; continue 'dispatch;
	}
	// 821A51BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A51C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A51C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821A51C8; continue 'dispatch;
            }
            0x821A51C8 => {
    //   block [0x821A51C8..0x821A51F0)
	// 821A51C8: 3BFC0010  addi r31, r28, 0x10
	ctx.r[31].s64 = ctx.r[28].s64 + 16;
	// 821A51CC: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A51D0: 419A0020  beq cr6, 0x821a51f0
	if ctx.cr[6].eq {
	pc = 0x821A51F0; continue 'dispatch;
	}
	// 821A51D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A51D8: 48056E31  bl 0x821fc008
	ctx.lr = 0x821A51DC;
	sub_821FC008(ctx, base);
	// 821A51DC: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A51E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A51E4: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821A51E8: 419A0008  beq cr6, 0x821a51f0
	if ctx.cr[6].eq {
	pc = 0x821A51F0; continue 'dispatch;
	}
	// 821A51EC: 48056F8D  bl 0x821fc178
	ctx.lr = 0x821A51F0;
	sub_821FC178(ctx, base);
	pc = 0x821A51F0; continue 'dispatch;
            }
            0x821A51F0 => {
    //   block [0x821A51F0..0x821A5220)
	// 821A51F0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821A51F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A51F8: 394B2A30  addi r10, r11, 0x2a30
	ctx.r[10].s64 = ctx.r[11].s64 + 10800;
	// 821A51FC: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A5200: 48056E09  bl 0x821fc008
	ctx.lr = 0x821A5204;
	sub_821FC008(ctx, base);
	// 821A5204: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 821A5208: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A520C: 39092A40  addi r8, r9, 0x2a40
	ctx.r[8].s64 = ctx.r[9].s64 + 10816;
	// 821A5210: 911D0000  stw r8, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A5214: 48056DF5  bl 0x821fc008
	ctx.lr = 0x821A5218;
	sub_821FC008(ctx, base);
	// 821A5218: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A521C: 48B04238  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A5220 size=804
    let mut pc: u32 = 0x821A5220;
    'dispatch: loop {
        match pc {
            0x821A5220 => {
    //   block [0x821A5220..0x821A5544)
	// 821A5220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5224: 48B041D1  bl 0x82ca93f4
	ctx.lr = 0x821A5228;
	sub_82CA93D0(ctx, base);
	// 821A5228: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A522C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A5230: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 821A5234: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 821A5238: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A523C: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 821A5240: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 821A5244: 3AEB91A0  addi r23, r11, -0x6e60
	ctx.r[23].s64 = ctx.r[11].s64 + -28256;
	// 821A5248: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821A524C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A5548 size=176
    let mut pc: u32 = 0x821A5548;
    'dispatch: loop {
        match pc {
            0x821A5548 => {
    //   block [0x821A5548..0x821A5570)
	// 821A5548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A554C: 48B03EB5  bl 0x82ca9400
	ctx.lr = 0x821A5550;
	sub_82CA93D0(ctx, base);
	// 821A5550: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5554: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A5558: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821A555C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821A5560: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 821A5564: 3BDD000C  addi r30, r29, 0xc
	ctx.r[30].s64 = ctx.r[29].s64 + 12;
	// 821A5568: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A556C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821A5570; continue 'dispatch;
            }
            0x821A5570 => {
    //   block [0x821A5570..0x821A5580)
	// 821A5570: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5574: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821A5578: 419A0008  beq cr6, 0x821a5580
	if ctx.cr[6].eq {
	pc = 0x821A5580; continue 'dispatch;
	}
	// 821A557C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A5580; continue 'dispatch;
            }
            0x821A5580 => {
    //   block [0x821A5580..0x821A5598)
	// 821A5580: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A5584: 419A0068  beq cr6, 0x821a55ec
	if ctx.cr[6].eq {
	pc = 0x821A55EC; continue 'dispatch;
	}
	// 821A5588: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A558C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A5590: 409A0008  bne cr6, 0x821a5598
	if !ctx.cr[6].eq {
	pc = 0x821A5598; continue 'dispatch;
	}
	// 821A5594: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A5598; continue 'dispatch;
            }
            0x821A5598 => {
    //   block [0x821A5598..0x821A55D8)
	// 821A5598: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A559C: C03D006C  lfs f1, 0x6c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A55A0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821A55A4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821A55A8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A55AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A55B0: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A55B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A55B8: 4E800421  bctrl
	ctx.lr = 0x821A55BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A55BC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821A55C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A55C4: 409A001C  bne cr6, 0x821a55e0
	if !ctx.cr[6].eq {
	pc = 0x821A55E0; continue 'dispatch;
	}
	// 821A55C8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A55CC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A55D0: 409A0008  bne cr6, 0x821a55d8
	if !ctx.cr[6].eq {
	pc = 0x821A55D8; continue 'dispatch;
	}
	// 821A55D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
            }
            0x821A55D8 => {
    //   block [0x821A55D8..0x821A55E0)
	// 821A55D8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A55DC: 4BFFFF94  b 0x821a5570
	pc = 0x821A5570; continue 'dispatch;
            }
            0x821A55E0 => {
    //   block [0x821A55E0..0x821A55EC)
	// 821A55E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A55E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A55E8: 48B03E68  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A55EC => {
    //   block [0x821A55EC..0x821A55F8)
	// 821A55EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A55F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A55F4: 48B03E5C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A55F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A55F8 size=996
    let mut pc: u32 = 0x821A55F8;
    'dispatch: loop {
        match pc {
            0x821A55F8 => {
    //   block [0x821A55F8..0x821A5654)
	// 821A55F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A55FC: 48B03E05  bl 0x82ca9400
	ctx.lr = 0x821A5600;
	sub_82CA93D0(ctx, base);
	// 821A5600: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821A5604: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5608: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821A560C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821A5610: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821A5614: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 821A5618: 817C0024  lwz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A561C: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 821A5620: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A5624: 419A00F4  beq cr6, 0x821a5718
	if ctx.cr[6].eq {
	pc = 0x821A5718; continue 'dispatch;
	}
	// 821A5628: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A562C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5630: 419A0024  beq cr6, 0x821a5654
	if ctx.cr[6].eq {
	pc = 0x821A5654; continue 'dispatch;
	}
	// 821A5634: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 821A5638: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A563C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A5640: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A5644: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5648: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821A564C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A5650: 480000CC  b 0x821a571c
	pc = 0x821A571C; continue 'dispatch;
            }
            0x821A5654 => {
    //   block [0x821A5654..0x821A5670)
	// 821A5654: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A5658: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A565C: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 821A5660: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A5664: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821A5668: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A566C: 40810054  ble 0x821a56c0
	if !ctx.cr[0].gt {
	pc = 0x821A56C0; continue 'dispatch;
	}
	pc = 0x821A5670; continue 'dispatch;
            }
            0x821A5670 => {
    //   block [0x821A5670..0x821A5690)
	// 821A5670: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A5674: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A5678: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821A567C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5680: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 821A5684: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A5688: 41980008  blt cr6, 0x821a5690
	if ctx.cr[6].lt {
	pc = 0x821A5690; continue 'dispatch;
	}
	// 821A568C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x821A5690; continue 'dispatch;
            }
            0x821A5690 => {
    //   block [0x821A5690..0x821A56AC)
	// 821A5690: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A5694: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A5698: 419A0014  beq cr6, 0x821a56ac
	if ctx.cr[6].eq {
	pc = 0x821A56AC; continue 'dispatch;
	}
	// 821A569C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A56A0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A56A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A56A8: 4800000C  b 0x821a56b4
	pc = 0x821A56B4; continue 'dispatch;
            }
            0x821A56AC => {
    //   block [0x821A56AC..0x821A56B4)
	// 821A56AC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A56B0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A56B4; continue 'dispatch;
            }
            0x821A56B4 => {
    //   block [0x821A56B4..0x821A56C0)
	// 821A56B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A56B8: 4199FFB8  bgt cr6, 0x821a5670
	if ctx.cr[6].gt {
	pc = 0x821A5670; continue 'dispatch;
	}
	// 821A56BC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x821A56C0; continue 'dispatch;
            }
            0x821A56C0 => {
    //   block [0x821A56C0..0x821A56DC)
	// 821A56C0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A56C4: 419A0040  beq cr6, 0x821a5704
	if ctx.cr[6].eq {
	pc = 0x821A5704; continue 'dispatch;
	}
	// 821A56C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A56CC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821A56D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A56D4: 41990008  bgt cr6, 0x821a56dc
	if ctx.cr[6].gt {
	pc = 0x821A56DC; continue 'dispatch;
	}
	// 821A56D8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821A56DC; continue 'dispatch;
            }
            0x821A56DC => {
    //   block [0x821A56DC..0x821A5704)
	// 821A56DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A56E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A56E4: 409A0020  bne cr6, 0x821a5704
	if !ctx.cr[6].eq {
	pc = 0x821A5704; continue 'dispatch;
	}
	// 821A56E8: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821A56EC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821A56F0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821A56F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A56F8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821A56FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A5700: 4800001C  b 0x821a571c
	pc = 0x821A571C; continue 'dispatch;
            }
            0x821A5704 => {
    //   block [0x821A5704..0x821A5718)
	// 821A5704: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821A5708: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A570C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821A5710: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A5714: 48000008  b 0x821a571c
	pc = 0x821A571C; continue 'dispatch;
            }
            0x821A5718 => {
    //   block [0x821A5718..0x821A571C)
	// 821A5718: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821A571C; continue 'dispatch;
            }
            0x821A571C => {
    //   block [0x821A571C..0x821A5734)
	// 821A571C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A5720: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5724: 419A014C  beq cr6, 0x821a5870
	if ctx.cr[6].eq {
	pc = 0x821A5870; continue 'dispatch;
	}
	// 821A5728: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821A572C: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 821A5730: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x821A5734; continue 'dispatch;
            }
            0x821A5734 => {
    //   block [0x821A5734..0x821A5870)
	// 821A5734: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821A5738: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A573C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821A5740: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A5744: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821A5748: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A574C: 4082FFE8  bne 0x821a5734
	if !ctx.cr[0].eq {
	pc = 0x821A5734; continue 'dispatch;
	}
	// 821A5750: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A5754: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 821A5758: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 821A575C: 3BCBB730  addi r30, r11, -0x48d0
	ctx.r[30].s64 = ctx.r[11].s64 + -18640;
	// 821A5760: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821A5764: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 821A5768: 38869160  addi r4, r6, -0x6ea0
	ctx.r[4].s64 = ctx.r[6].s64 + -28320;
	// 821A576C: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 821A5770: C3FEDD60  lfs f31, -0x22a0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A5774: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821A5778: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A577C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	pc = 0x821A5870; continue 'dispatch;
            }
            0x821A5870 => {
    //   block [0x821A5870..0x821A59DC)
	// 821A5870: 815C0038  lwz r10, 0x38(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 821A5874: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821A5878: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 821A587C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A5880: 419A00E8  beq cr6, 0x821a5968
	if ctx.cr[6].eq {
	pc = 0x821A5968; continue 'dispatch;
	}
	// 821A5884: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A5888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A588C: 419A0020  beq cr6, 0x821a58ac
	if ctx.cr[6].eq {
	pc = 0x821A58AC; continue 'dispatch;
	}
	// 821A5890: 894B00B3  lbz r10, 0xb3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(179 as u32) ) } as u64;
	// 821A5894: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A5898: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A589C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A58A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A58A4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A58A8: 480000C4  b 0x821a596c
	pc = 0x821A596C; continue 'dispatch;
	// 821A58AC: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A58B0: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A58B4: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 821A58B8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A58BC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821A58C0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A58C4: 40810054  ble 0x821a5918
	if !ctx.cr[0].gt {
	pc = 0x821A5918; continue 'dispatch;
	}
	// 821A58C8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A58CC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A58D0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821A58D4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A58D8: 2F0700B3  cmpwi cr6, r7, 0xb3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 179, &mut ctx.xer);
	// 821A58DC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A58E0: 41980008  blt cr6, 0x821a58e8
	if ctx.cr[6].lt {
	pc = 0x821A58E8; continue 'dispatch;
	}
	// 821A58E4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821A58E8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A58EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A58F0: 419A0014  beq cr6, 0x821a5904
	if ctx.cr[6].eq {
	pc = 0x821A5904; continue 'dispatch;
	}
	// 821A58F4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A58F8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A58FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A5900: 4800000C  b 0x821a590c
	pc = 0x821A590C; continue 'dispatch;
	// 821A5904: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A5908: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821A590C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A5910: 4199FFB8  bgt cr6, 0x821a58c8
	if ctx.cr[6].gt {
	pc = 0x821A58C8; continue 'dispatch;
	}
	// 821A5914: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821A5918: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A591C: 419A003C  beq cr6, 0x821a5958
	if ctx.cr[6].eq {
	pc = 0x821A5958; continue 'dispatch;
	}
	// 821A5920: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5924: 2F0B00B3  cmpwi cr6, r11, 0xb3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 179, &mut ctx.xer);
	// 821A5928: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A592C: 41990008  bgt cr6, 0x821a5934
	if ctx.cr[6].gt {
	pc = 0x821A5934; continue 'dispatch;
	}
	// 821A5930: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821A5934: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A5938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A593C: 409A001C  bne cr6, 0x821a5958
	if !ctx.cr[6].eq {
	pc = 0x821A5958; continue 'dispatch;
	}
	// 821A5940: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821A5944: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A5948: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821A594C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821A5950: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5954: 48000018  b 0x821a596c
	pc = 0x821A596C; continue 'dispatch;
	// 821A5958: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821A595C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A5960: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5964: 48000008  b 0x821a596c
	pc = 0x821A596C; continue 'dispatch;
	// 821A5968: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 821A596C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821A5970: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A5974: 419A0020  beq cr6, 0x821a5994
	if ctx.cr[6].eq {
	pc = 0x821A5994; continue 'dispatch;
	}
	// 821A5978: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 821A597C: 395A0030  addi r10, r26, 0x30
	ctx.r[10].s64 = ctx.r[26].s64 + 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A59E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A59E0 size=124
    let mut pc: u32 = 0x821A59E0;
    'dispatch: loop {
        match pc {
            0x821A59E0 => {
    //   block [0x821A59E0..0x821A5A30)
	// 821A59E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A59E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A59E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A59EC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821A59F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A59F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A59F8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821A59FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A5A00: 997F0038  stb r11, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 821A5A04: 480001CD  bl 0x821a5bd0
	ctx.lr = 0x821A5A08;
	sub_821A5BD0(ctx, base);
	// 821A5A08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A5A0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821A5A10: 48085169  bl 0x8222ab78
	ctx.lr = 0x821A5A14;
	sub_8222AB78(ctx, base);
	// 821A5A14: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 821A5A18: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 821A5A1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A5A20: 480851C1  bl 0x8222abe0
	ctx.lr = 0x821A5A24;
	sub_8222ABE0(ctx, base);
	// 821A5A24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A5A28: 419A0008  beq cr6, 0x821a5a30
	if ctx.cr[6].eq {
	pc = 0x821A5A30; continue 'dispatch;
	}
	// 821A5A2C: DBE30000  stfd f31, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.f[31].u64 ) };
	pc = 0x821A5A30; continue 'dispatch;
            }
            0x821A5A30 => {
    //   block [0x821A5A30..0x821A5A5C)
	// 821A5A30: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A5A34: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A5A38: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A5A3C: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A5A40: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 821A5A44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A5A48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A5A4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A5A50: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A5A54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A5A58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A5A60 size=364
    let mut pc: u32 = 0x821A5A60;
    'dispatch: loop {
        match pc {
            0x821A5A60 => {
    //   block [0x821A5A60..0x821A5AF0)
	// 821A5A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A5A68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5A6C: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821A5A70: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 821A5A74: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821A5A78: 38EA7064  addi r7, r10, 0x7064
	ctx.r[7].s64 = ctx.r[10].s64 + 28772;
	// 821A5A7C: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 821A5A80: 39092390  addi r8, r9, 0x2390
	ctx.r[8].s64 = ctx.r[9].s64 + 9104;
	// 821A5A84: 88CB008D  lbz r6, 0x8d(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(141 as u32) ) } as u64;
	// 821A5A88: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821A5A8C: 1D462008  mulli r10, r6, 0x2008
	ctx.r[10].s32 = ((ctx.r[6].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821A5A90: 80E70008  lwz r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A5A94: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821A5A98: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821A5A9C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821A5AA0: 419A008C  beq cr6, 0x821a5b2c
	if ctx.cr[6].eq {
	pc = 0x821A5B2C; continue 'dispatch;
	}
	// 821A5AA4: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821A5AA8: 810B0080  lwz r8, 0x80(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A5AAC: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821A5AB0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A5AB4: 409A003C  bne cr6, 0x821a5af0
	if !ctx.cr[6].eq {
	pc = 0x821A5AF0; continue 'dispatch;
	}
	// 821A5AB8: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821A5ABC: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821A5AC0: 38AB0078  addi r5, r11, 0x78
	ctx.r[5].s64 = ctx.r[11].s64 + 120;
	// 821A5AC4: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821A5AC8: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821A5ACC: 7CA3512E  stwx r5, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 821A5AD0: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821A5AD4: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821A5AD8: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A5ADC: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821A5AE0: 91260004  stw r9, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821A5AE4: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821A5AE8: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 821A5AEC: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	pc = 0x821A5AF0; continue 'dispatch;
            }
            0x821A5AF0 => {
    //   block [0x821A5AF0..0x821A5B2C)
	// 821A5AF0: 894B008C  lbz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A5AF4: 90EB007C  stw r7, 0x7c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 821A5AF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A5AFC: 409A0030  bne cr6, 0x821a5b2c
	if !ctx.cr[6].eq {
	pc = 0x821A5B2C; continue 'dispatch;
	}
	// 821A5B00: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821A5B04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A5B08: 390B0078  addi r8, r11, 0x78
	ctx.r[8].s64 = ctx.r[11].s64 + 120;
	// 821A5B0C: 994B008C  stb r10, 0x8c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u8 ) };
	// 821A5B10: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821A5B14: 81690DB0  lwz r11, 0xdb0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821A5B18: 38C70DB8  addi r6, r7, 0xdb8
	ctx.r[6].s64 = ctx.r[7].s64 + 3512;
	// 821A5B1C: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821A5B20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A5B24: 91690DB0  stw r11, 0xdb0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 821A5B28: 7D05312E  stwx r8, r5, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32), ctx.r[8].u32) };
	pc = 0x821A5B2C; continue 'dispatch;
            }
            0x821A5B2C => {
    //   block [0x821A5B2C..0x821A5BCC)
	// 821A5B2C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A5B30: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821A5B34: 392B9484  addi r9, r11, -0x6b7c
	ctx.r[9].s64 = ctx.r[11].s64 + -27516;
	// 821A5B38: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 821A5B3C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 821A5B40: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5B44: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821A5B48: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A5B4C: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 821A5B50: C1A9000C  lfs f13, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A5BD0 size=148
    let mut pc: u32 = 0x821A5BD0;
    'dispatch: loop {
        match pc {
            0x821A5BD0 => {
    //   block [0x821A5BD0..0x821A5C20)
	// 821A5BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5BD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A5BD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A5BDC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5BE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A5BE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A5BE8: 389F0048  addi r4, r31, 0x48
	ctx.r[4].s64 = ctx.r[31].s64 + 72;
	// 821A5BEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821A5BF0: 4805AB81  bl 0x82200770
	ctx.lr = 0x821A5BF4;
	sub_82200770(ctx, base);
	// 821A5BF4: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A5BF8: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A5BFC: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821A5C00: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A5C04: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A5C08: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821A5C0C: 913F003C  stw r9, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 821A5C10: 915F0044  stw r10, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	// 821A5C14: 4198000C  blt cr6, 0x821a5c20
	if ctx.cr[6].lt {
	pc = 0x821A5C20; continue 'dispatch;
	}
	// 821A5C18: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A5C1C: 4099000C  ble cr6, 0x821a5c28
	if !ctx.cr[6].gt {
	pc = 0x821A5C28; continue 'dispatch;
	}
	pc = 0x821A5C20; continue 'dispatch;
            }
            0x821A5C20 => {
    //   block [0x821A5C20..0x821A5C28)
	// 821A5C20: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A5C24: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	pc = 0x821A5C28; continue 'dispatch;
            }
            0x821A5C28 => {
    //   block [0x821A5C28..0x821A5C3C)
	// 821A5C28: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 821A5C2C: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821A5C30: 409A000C  bne cr6, 0x821a5c3c
	if !ctx.cr[6].eq {
	pc = 0x821A5C3C; continue 'dispatch;
	}
	// 821A5C34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A5C38: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	pc = 0x821A5C3C; continue 'dispatch;
            }
            0x821A5C3C => {
    //   block [0x821A5C3C..0x821A5C50)
	// 821A5C3C: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A5C40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A5C44: 419A000C  beq cr6, 0x821a5c50
	if ctx.cr[6].eq {
	pc = 0x821A5C50; continue 'dispatch;
	}
	// 821A5C48: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A5C4C: 49113D09  bl 0x832b9954
	ctx.lr = 0x821A5C50;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x821A5C50; continue 'dispatch;
            }
            0x821A5C50 => {
    //   block [0x821A5C50..0x821A5C64)
	// 821A5C50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A5C54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A5C58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A5C5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A5C60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A5C68 size=492
    let mut pc: u32 = 0x821A5C68;
    'dispatch: loop {
        match pc {
            0x821A5C68 => {
    //   block [0x821A5C68..0x821A5D40)
	// 821A5C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5C6C: 48B037A1  bl 0x82ca940c
	ctx.lr = 0x821A5C70;
	sub_82CA93D0(ctx, base);
	// 821A5C70: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821A5C74: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5C78: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821A5C7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A5C80: 816B6AF0  lwz r11, 0x6af0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27376 as u32) ) } as u64;
	// 821A5C84: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821A5C88: 409A00B8  bne cr6, 0x821a5d40
	if !ctx.cr[6].eq {
	pc = 0x821A5D40; continue 'dispatch;
	}
	// 821A5C8C: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821A5C90: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5C94: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821A5C98: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821A5C9C: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821A5CA0: 810A0020  lwz r8, 0x20(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A5CA4: C3E99484  lfs f31, -0x6b7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A5CA8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A5CAC: 80EB0020  lwz r7, 0x20(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A5CB0: 83C80020  lwz r30, 0x20(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A5CB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5CB8: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5CBC: 4864BB6D  bl 0x827f1828
	ctx.lr = 0x821A5CC0;
	sub_827F1828(ctx, base);
	// 821A5CC0: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821A5CC4: 482803B5  bl 0x82426078
	ctx.lr = 0x821A5CC8;
	sub_82426078(ctx, base);
	// 821A5CC8: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821A5CCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5CD0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A5CD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821A5CD8: 80AB0020  lwz r5, 0x20(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A5CDC: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5CE0: 4864BB49  bl 0x827f1828
	ctx.lr = 0x821A5CE4;
	sub_827F1828(ctx, base);
	// 821A5CE4: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 821A5CE8: 48280391  bl 0x82426078
	ctx.lr = 0x821A5CEC;
	sub_82426078(ctx, base);
	// 821A5CEC: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821A5CF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5CF4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A5CF8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821A5CFC: 80EB0020  lwz r7, 0x20(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A5D00: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5D04: 4864BB25  bl 0x827f1828
	ctx.lr = 0x821A5D08;
	sub_827F1828(ctx, base);
	// 821A5D08: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821A5D0C: 4828036D  bl 0x82426078
	ctx.lr = 0x821A5D10;
	sub_82426078(ctx, base);
	// 821A5D10: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821A5D14: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821A5D18: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A5D1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5D20: 80AB0020  lwz r5, 0x20(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A5D24: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5D28: 4864BB01  bl 0x827f1828
	ctx.lr = 0x821A5D2C;
	sub_827F1828(ctx, base);
	// 821A5D2C: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 821A5D30: 48280349  bl 0x82426078
	ctx.lr = 0x821A5D34;
	sub_82426078(ctx, base);
	// 821A5D34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A5D38: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821A5D3C: 48B03720  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A5D40 => {
    //   block [0x821A5D40..0x821A5D80)
	// 821A5D40: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821A5D44: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821A5D48: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A5D4C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A5D50: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5D54: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5D58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A5D5C: 4808645D  bl 0x8222c1b8
	ctx.lr = 0x821A5D60;
	sub_8222C1B8(ctx, base);
	// 821A5D60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A5D64: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A5D68: 419A0018  beq cr6, 0x821a5d80
	if ctx.cr[6].eq {
	pc = 0x821A5D80; continue 'dispatch;
	}
	// 821A5D6C: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A5D70: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A5D74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A5D78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A5D7C: 409A0008  bne cr6, 0x821a5d84
	if !ctx.cr[6].eq {
	pc = 0x821A5D84; continue 'dispatch;
	}
	pc = 0x821A5D80; continue 'dispatch;
            }
            0x821A5D80 => {
    //   block [0x821A5D80..0x821A5D84)
	// 821A5D80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821A5D84; continue 'dispatch;
            }
            0x821A5D84 => {
    //   block [0x821A5D84..0x821A5DCC)
	// 821A5D84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A5D88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5D8C: 419A0040  beq cr6, 0x821a5dcc
	if ctx.cr[6].eq {
	pc = 0x821A5DCC; continue 'dispatch;
	}
	// 821A5D90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A5D94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5D98: 484433B1  bl 0x825e9148
	ctx.lr = 0x821A5D9C;
	sub_825E9148(ctx, base);
	// 821A5D9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A5DA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5DA4: 4811B305  bl 0x822c10a8
	ctx.lr = 0x821A5DA8;
	sub_822C10A8(ctx, base);
	// 821A5DA8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A5DAC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5DB0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A5DB4: 40980018  bge cr6, 0x821a5dcc
	if !ctx.cr[6].lt {
	pc = 0x821A5DCC; continue 'dispatch;
	}
	// 821A5DB8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5DBC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821A5DC0: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A5DC4: 806A0024  lwz r3, 0x24(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A5DC8: 4865C8D1  bl 0x82802698
	ctx.lr = 0x821A5DCC;
	sub_82802698(ctx, base);
	pc = 0x821A5DCC; continue 'dispatch;
            }
            0x821A5DCC => {
    //   block [0x821A5DCC..0x821A5DF4)
	// 821A5DCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A5DD0: 4873FCA9  bl 0x828e5a78
	ctx.lr = 0x821A5DD4;
	sub_828E5A78(ctx, base);
	// 821A5DD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A5DD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A5DDC: 419A0018  beq cr6, 0x821a5df4
	if ctx.cr[6].eq {
	pc = 0x821A5DF4; continue 'dispatch;
	}
	// 821A5DE0: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A5DE4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A5DE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A5DEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A5DF0: 409A0008  bne cr6, 0x821a5df8
	if !ctx.cr[6].eq {
	pc = 0x821A5DF8; continue 'dispatch;
	}
	pc = 0x821A5DF4; continue 'dispatch;
            }
            0x821A5DF4 => {
    //   block [0x821A5DF4..0x821A5DF8)
	// 821A5DF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821A5DF8; continue 'dispatch;
            }
            0x821A5DF8 => {
    //   block [0x821A5DF8..0x821A5E40)
	// 821A5DF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A5DFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5E00: 419A0040  beq cr6, 0x821a5e40
	if ctx.cr[6].eq {
	pc = 0x821A5E40; continue 'dispatch;
	}
	// 821A5E04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A5E08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5E0C: 4844393D  bl 0x825e9748
	ctx.lr = 0x821A5E10;
	sub_825E9748(ctx, base);
	// 821A5E10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A5E14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5E18: 4811B291  bl 0x822c10a8
	ctx.lr = 0x821A5E1C;
	sub_822C10A8(ctx, base);
	// 821A5E1C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A5E20: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A5E24: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A5E28: 40980018  bge cr6, 0x821a5e40
	if !ctx.cr[6].lt {
	pc = 0x821A5E40; continue 'dispatch;
	}
	// 821A5E2C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5E30: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821A5E34: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A5E38: 806A0024  lwz r3, 0x24(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A5E3C: 4865C85D  bl 0x82802698
	ctx.lr = 0x821A5E40;
	sub_82802698(ctx, base);
	pc = 0x821A5E40; continue 'dispatch;
            }
            0x821A5E40 => {
    //   block [0x821A5E40..0x821A5E54)
	// 821A5E40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A5E44: 997E003A  stb r11, 0x3a(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(58 as u32), ctx.r[11].u8 ) };
	// 821A5E48: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A5E4C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821A5E50: 48B0360C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A5E58 size=196
    let mut pc: u32 = 0x821A5E58;
    'dispatch: loop {
        match pc {
            0x821A5E58 => {
    //   block [0x821A5E58..0x821A5E80)
	// 821A5E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5E5C: 48B035AD  bl 0x82ca9408
	ctx.lr = 0x821A5E60;
	sub_82CA93D0(ctx, base);
	// 821A5E60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5E64: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821A5E68: 814B7E8C  lwz r10, 0x7e8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32396 as u32) ) } as u64;
	// 821A5E6C: 354A0001  addic. r10, r10, 1
	ctx.xer.ca = (ctx.r[10].u32 > (!(1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A5E70: 914B7E8C  stw r10, 0x7e8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32396 as u32), ctx.r[10].u32 ) };
	// 821A5E74: 4082000C  bne 0x821a5e80
	if !ctx.cr[0].eq {
	pc = 0x821A5E80; continue 'dispatch;
	}
	// 821A5E78: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A5E7C: 914B7E8C  stw r10, 0x7e8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32396 as u32), ctx.r[10].u32 ) };
	pc = 0x821A5E80; continue 'dispatch;
            }
            0x821A5E80 => {
    //   block [0x821A5E80..0x821A5E9C)
	// 821A5E80: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821A5E84: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A5E88: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821A5E8C: 83EA6ED4  lwz r31, 0x6ed4(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28372 as u32) ) } as u64;
	// 821A5E90: 916A6ED4  stw r11, 0x6ed4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28372 as u32), ctx.r[11].u32 ) };
	// 821A5E94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A5E98: 419A004C  beq cr6, 0x821a5ee4
	if ctx.cr[6].eq {
	pc = 0x821A5EE4; continue 'dispatch;
	}
	pc = 0x821A5E9C; continue 'dispatch;
            }
            0x821A5E9C => {
    //   block [0x821A5E9C..0x821A5ECC)
	// 821A5E9C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821A5EA0: 83BF0020  lwz r29, 0x20(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A5EA4: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A5EA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A5EAC: 9B9F0025  stb r28, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[28].u8 ) };
	// 821A5EB0: 419A001C  beq cr6, 0x821a5ecc
	if ctx.cr[6].eq {
	pc = 0x821A5ECC; continue 'dispatch;
	}
	// 821A5EB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5EB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A5EBC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5EC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A5EC4: 4E800421  bctrl
	ctx.lr = 0x821A5EC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A5EC8: 939F001C  stw r28, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[28].u32 ) };
            }
            0x821A5ECC => {
    //   block [0x821A5ECC..0x821A5EE4)
	// 821A5ECC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821A5ED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5ED4: 488E4AB5  bl 0x82a8a988
	ctx.lr = 0x821A5ED8;
	sub_82A8A988(ctx, base);
	// 821A5ED8: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821A5EDC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821A5EE0: 409AFFBC  bne cr6, 0x821a5e9c
	if !ctx.cr[6].eq {
	pc = 0x821A5E9C; continue 'dispatch;
	}
	pc = 0x821A5EE4; continue 'dispatch;
            }
            0x821A5EE4 => {
    //   block [0x821A5EE4..0x821A5EF4)
	// 821A5EE4: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821A5EE8: 807F6EBC  lwz r3, 0x6ebc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28348 as u32) ) } as u64;
	// 821A5EEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A5EF0: 419A0018  beq cr6, 0x821a5f08
	if ctx.cr[6].eq {
	pc = 0x821A5F08; continue 'dispatch;
	}
	pc = 0x821A5EF4; continue 'dispatch;
            }
            0x821A5EF4 => {
    //   block [0x821A5EF4..0x821A5F08)
	// 821A5EF4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821A5EF8: 488CAEF1  bl 0x82a70de8
	ctx.lr = 0x821A5EFC;
	sub_82A70DE8(ctx, base);
	// 821A5EFC: 807F6EBC  lwz r3, 0x6ebc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28348 as u32) ) } as u64;
	// 821A5F00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A5F04: 409AFFF0  bne cr6, 0x821a5ef4
	if !ctx.cr[6].eq {
	pc = 0x821A5EF4; continue 'dispatch;
	}
	pc = 0x821A5F08; continue 'dispatch;
            }
            0x821A5F08 => {
    //   block [0x821A5F08..0x821A5F1C)
	// 821A5F08: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821A5F0C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821A5F10: 916A6ED8  stw r11, 0x6ed8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28376 as u32), ctx.r[11].u32 ) };
	// 821A5F14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A5F18: 48B03540  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A5F20 size=652
    let mut pc: u32 = 0x821A5F20;
    'dispatch: loop {
        match pc {
            0x821A5F20 => {
    //   block [0x821A5F20..0x821A5F6C)
	// 821A5F20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5F24: 48B034E9  bl 0x82ca940c
	ctx.lr = 0x821A5F28;
	sub_82CA93D0(ctx, base);
	// 821A5F28: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 821A5F2C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821A5F30: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5F34: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 821A5F38: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A5F3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A5F40: 3BCB9484  addi r30, r11, -0x6b7c
	ctx.r[30].s64 = ctx.r[11].s64 + -27516;
	// 821A5F44: 3D20834C  lis r9, -0x7cb4
	ctx.r[9].s64 = -2092171264;
	// 821A5F48: 816A1B28  lwz r11, 0x1b28(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6952 as u32) ) } as u64;
	// 821A5F4C: 556807FE  clrlwi r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821A5F50: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A5F54: 409A0018  bne cr6, 0x821a5f6c
	if !ctx.cr[6].eq {
	pc = 0x821A5F6C; continue 'dispatch;
	}
	// 821A5F58: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821A5F5C: C19E3708  lfs f12, 0x3708(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14088 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A5F60: D1891B24  stfs f12, 0x1b24(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(6948 as u32), tmp.u32 ) };
	// 821A5F64: 916A1B28  stw r11, 0x1b28(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6952 as u32), ctx.r[11].u32 ) };
	// 821A5F68: 48000008  b 0x821a5f70
	pc = 0x821A5F70; continue 'dispatch;
            }
            0x821A5F6C => {
    //   block [0x821A5F6C..0x821A5F70)
	// 821A5F6C: C1891B24  lfs f12, 0x1b24(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6948 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x821A5F70; continue 'dispatch;
            }
            0x821A5F70 => {
    //   block [0x821A5F70..0x821A5FA8)
	// 821A5F70: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821A5F74: C1BEFE50  lfs f13, -0x1b0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-432 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A5F78: C00B0ED4  lfs f0, 0xed4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5F7C: EFEC0032  fmuls f31, f12, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A5F80: EC3F0372  fmuls f1, f31, f13
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A5F84: 480EE195  bl 0x82294118
	ctx.lr = 0x821A5F88;
	sub_82294118(ctx, base);
	// 821A5F88: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 821A5F8C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821A5F90: 392A0320  addi r9, r10, 0x320
	ctx.r[9].s64 = ctx.r[10].s64 + 800;
	// 821A5F94: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A5F98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A5F9C: 419A000C  beq cr6, 0x821a5fa8
	if ctx.cr[6].eq {
	pc = 0x821A5FA8; continue 'dispatch;
	}
	// 821A5FA0: C3DE6A30  lfs f30, 0x6a30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A5FA4: 48000008  b 0x821a5fac
	pc = 0x821A5FAC; continue 'dispatch;
            }
            0x821A5FA8 => {
    //   block [0x821A5FA8..0x821A5FAC)
	// 821A5FA8: C3DE69A8  lfs f30, 0x69a8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27048 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x821A5FAC; continue 'dispatch;
            }
            0x821A5FAC => {
    //   block [0x821A5FAC..0x821A6004)
	// 821A5FAC: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821A5FB0: 480D91D1  bl 0x8227f180
	ctx.lr = 0x821A5FB4;
	sub_8227F180(ctx, base);
	// 821A5FB4: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 821A5FB8: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821A5FBC: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821A5FC0: C01E1FFC  lfs f0, 0x1ffc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5FC4: D3FF00DC  stfs f31, 0xdc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 821A5FC8: 392B1AE0  addi r9, r11, 0x1ae0
	ctx.r[9].s64 = ctx.r[11].s64 + 6880;
	// 821A5FCC: D3DF00E0  stfs f30, 0xe0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 821A5FD0: 816A1AF0  lwz r11, 0x1af0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6896 as u32) ) } as u64;
	// 821A5FD4: 556807FE  clrlwi r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821A5FD8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A5FDC: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A5FE0: D19F00D8  stfs f12, 0xd8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 821A5FE4: 409A0020  bne cr6, 0x821a6004
	if !ctx.cr[6].eq {
	pc = 0x821A6004; continue 'dispatch;
	}
	// 821A5FE8: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 821A5FEC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821A5FF0: 38E8B2C0  addi r7, r8, -0x4d40
	ctx.r[7].s64 = ctx.r[8].s64 + -19776;
	// 821A5FF4: 916A1AF0  stw r11, 0x1af0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6896 as u32), ctx.r[11].u32 ) };
	pc = 0x821A6004; continue 'dispatch;
            }
            0x821A6004 => {
    //   block [0x821A6004..0x821A61AC)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A61B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A61B0 size=180
    let mut pc: u32 = 0x821A61B0;
    'dispatch: loop {
        match pc {
            0x821A61B0 => {
    //   block [0x821A61B0..0x821A6204)
	// 821A61B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A61B4: 48B03259  bl 0x82ca940c
	ctx.lr = 0x821A61B8;
	sub_82CA93D0(ctx, base);
	// 821A61B8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821A61BC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A61C0: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A61C4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821A61C8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821A61CC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A61D0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A61D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A61D8: 419A0080  beq cr6, 0x821a6258
	if ctx.cr[6].eq {
	pc = 0x821A6258; continue 'dispatch;
	}
	// 821A61DC: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 821A61E0: 817E6ABC  lwz r11, 0x6abc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27324 as u32) ) } as u64;
	// 821A61E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A61E8: 419A003C  beq cr6, 0x821a6224
	if ctx.cr[6].eq {
	pc = 0x821A6224; continue 'dispatch;
	}
	// 821A61EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A61F0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A61F4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A61F8: 409A000C  bne cr6, 0x821a6204
	if !ctx.cr[6].eq {
	pc = 0x821A6204; continue 'dispatch;
	}
	// 821A61FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821A6200: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A6204; continue 'dispatch;
            }
            0x821A6204 => {
    //   block [0x821A6204..0x821A6224)
	// 821A6204: 806A0008  lwz r3, 8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A6208: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A620C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6210: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A6214: 4E800421  bctrl
	ctx.lr = 0x821A6218;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A6218: 813E6ABC  lwz r9, 0x6abc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27324 as u32) ) } as u64;
	// 821A621C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821A6220: 4E800421  bctrl
	ctx.lr = 0x821A6224;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A6224 => {
    //   block [0x821A6224..0x821A623C)
	// 821A6224: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6228: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A622C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A6230: 409A000C  bne cr6, 0x821a623c
	if !ctx.cr[6].eq {
	pc = 0x821A623C; continue 'dispatch;
	}
	// 821A6234: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821A6238: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821A623C; continue 'dispatch;
            }
            0x821A623C => {
    //   block [0x821A623C..0x821A6258)
	// 821A623C: 806A0008  lwz r3, 8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A6240: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821A6244: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A6248: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A624C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821A6250: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A6254: 4E800421  bctrl
	ctx.lr = 0x821A6258;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A6258 => {
    //   block [0x821A6258..0x821A6264)
	// 821A6258: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A625C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821A6260: 48B031FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A6268 size=8972
    let mut pc: u32 = 0x821A6268;
    'dispatch: loop {
        match pc {
            0x821A6268 => {
    //   block [0x821A6268..0x821A62B4)
	// 821A6268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A626C: 48B03171  bl 0x82ca93dc
	ctx.lr = 0x821A6270;
	sub_82CA93D0(ctx, base);
	// 821A6270: DBC1FF70  stfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[30].u64 ) };
	// 821A6274: DBE1FF78  stfd f31, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 821A6278: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A627C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821A6280: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821A6284: 7C711B78  mr r17, r3
	ctx.r[17].u64 = ctx.r[3].u64;
	// 821A6288: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 821A628C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821A6290: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A6294: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A6298: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821A629C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A62A0: 419A0014  beq cr6, 0x821a62b4
	if ctx.cr[6].eq {
	pc = 0x821A62B4; continue 'dispatch;
	}
	// 821A62A4: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 821A62A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A62AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A62B0: 409A0008  bne cr6, 0x821a62b8
	if !ctx.cr[6].eq {
	pc = 0x821A62B8; continue 'dispatch;
	}
	pc = 0x821A62B4; continue 'dispatch;
            }
            0x821A62B4 => {
    //   block [0x821A62B4..0x821A62B8)
	// 821A62B4: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A62B8; continue 'dispatch;
            }
            0x821A62B8 => {
    //   block [0x821A62B8..0x821A6308)
	// 821A62B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A62BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A62C0: 409A22A4  bne cr6, 0x821a8564
	if !ctx.cr[6].eq {
	pc = 0x821A8564; continue 'dispatch;
	}
	// 821A62C4: 83D10004  lwz r30, 4(r17)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A62C8: 7E539378  mr r19, r18
	ctx.r[19].u64 = ctx.r[18].u64;
	// 821A62CC: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 821A62D0: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A62D4: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 821A62D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A62DC: 419A00E8  beq cr6, 0x821a63c4
	if ctx.cr[6].eq {
	pc = 0x821A63C4; continue 'dispatch;
	}
	// 821A62E0: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A62E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A62E8: 419A0020  beq cr6, 0x821a6308
	if ctx.cr[6].eq {
	pc = 0x821A6308; continue 'dispatch;
	}
	// 821A62EC: 894B003C  lbz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821A62F0: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A62F4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A62F8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A62FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A6300: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6304: 480000C4  b 0x821a63c8
	pc = 0x821A63C8; continue 'dispatch;
            }
            0x821A6308 => {
    //   block [0x821A6308..0x821A6324)
	// 821A6308: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A630C: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A6310: 92410068  stw r18, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[18].u32 ) };
	// 821A6314: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A6318: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821A631C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A6320: 40810054  ble 0x821a6374
	if !ctx.cr[0].gt {
	pc = 0x821A6374; continue 'dispatch;
	}
	pc = 0x821A6324; continue 'dispatch;
            }
            0x821A6324 => {
    //   block [0x821A6324..0x821A6344)
	// 821A6324: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A6328: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A632C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821A6330: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6334: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 821A6338: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A633C: 41980008  blt cr6, 0x821a6344
	if ctx.cr[6].lt {
	pc = 0x821A6344; continue 'dispatch;
	}
	// 821A6340: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	pc = 0x821A6344; continue 'dispatch;
            }
            0x821A6344 => {
    //   block [0x821A6344..0x821A6360)
	// 821A6344: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A6348: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A634C: 419A0014  beq cr6, 0x821a6360
	if ctx.cr[6].eq {
	pc = 0x821A6360; continue 'dispatch;
	}
	// 821A6350: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A6354: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A6358: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A635C: 4800000C  b 0x821a6368
	pc = 0x821A6368; continue 'dispatch;
            }
            0x821A6360 => {
    //   block [0x821A6360..0x821A6368)
	// 821A6360: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A6364: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A6368; continue 'dispatch;
            }
            0x821A6368 => {
    //   block [0x821A6368..0x821A6374)
	// 821A6368: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A636C: 4199FFB8  bgt cr6, 0x821a6324
	if ctx.cr[6].gt {
	pc = 0x821A6324; continue 'dispatch;
	}
	// 821A6370: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x821A6374; continue 'dispatch;
            }
            0x821A6374 => {
    //   block [0x821A6374..0x821A6390)
	// 821A6374: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A6378: 419A003C  beq cr6, 0x821a63b4
	if ctx.cr[6].eq {
	pc = 0x821A63B4; continue 'dispatch;
	}
	// 821A637C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6380: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 821A6384: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6388: 41990008  bgt cr6, 0x821a6390
	if ctx.cr[6].gt {
	pc = 0x821A6390; continue 'dispatch;
	}
	// 821A638C: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A6390; continue 'dispatch;
            }
            0x821A6390 => {
    //   block [0x821A6390..0x821A63B4)
	// 821A6390: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A6394: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6398: 409A001C  bne cr6, 0x821a63b4
	if !ctx.cr[6].eq {
	pc = 0x821A63B4; continue 'dispatch;
	}
	// 821A639C: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A63A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A63A4: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A63A8: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A63AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A63B0: 48000018  b 0x821a63c8
	pc = 0x821A63C8; continue 'dispatch;
            }
            0x821A63B4 => {
    //   block [0x821A63B4..0x821A63C4)
	// 821A63B4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821A63B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A63BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A63C0: 48000008  b 0x821a63c8
	pc = 0x821A63C8; continue 'dispatch;
            }
            0x821A63C4 => {
    //   block [0x821A63C4..0x821A63C8)
	// 821A63C4: 7E4A9378  mr r10, r18
	ctx.r[10].u64 = ctx.r[18].u64;
	pc = 0x821A63C8; continue 'dispatch;
            }
            0x821A63C8 => {
    //   block [0x821A63C8..0x821A6404)
	// 821A63C8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821A63CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A63D0: 419A0054  beq cr6, 0x821a6424
	if ctx.cr[6].eq {
	pc = 0x821A6424; continue 'dispatch;
	}
	// 821A63D4: 814B00AC  lwz r10, 0xac(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 821A63D8: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 821A63DC: 419A0028  beq cr6, 0x821a6404
	if ctx.cr[6].eq {
	pc = 0x821A6404; continue 'dispatch;
	}
	// 821A63E0: 2F0A0005  cmpwi cr6, r10, 5
	ctx.cr[6].compare_i32(ctx.r[10].s32, 5, &mut ctx.xer);
	// 821A63E4: 419A0020  beq cr6, 0x821a6404
	if ctx.cr[6].eq {
	pc = 0x821A6404; continue 'dispatch;
	}
	// 821A63E8: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 821A63EC: 419A0018  beq cr6, 0x821a6404
	if ctx.cr[6].eq {
	pc = 0x821A6404; continue 'dispatch;
	}
	// 821A63F0: 2F0A0006  cmpwi cr6, r10, 6
	ctx.cr[6].compare_i32(ctx.r[10].s32, 6, &mut ctx.xer);
	// 821A63F4: 419A0010  beq cr6, 0x821a6404
	if ctx.cr[6].eq {
	pc = 0x821A6404; continue 'dispatch;
	}
	// 821A63F8: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821A63FC: 7E4A9378  mr r10, r18
	ctx.r[10].u64 = ctx.r[18].u64;
	// 821A6400: 409A0008  bne cr6, 0x821a6408
	if !ctx.cr[6].eq {
	pc = 0x821A6408; continue 'dispatch;
	}
	pc = 0x821A6404; continue 'dispatch;
            }
            0x821A6404 => {
    //   block [0x821A6404..0x821A6408)
	// 821A6404: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x821A6408; continue 'dispatch;
            }
            0x821A6408 => {
    //   block [0x821A6408..0x821A6424)
	// 821A6408: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821A640C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A6410: 419A0014  beq cr6, 0x821a6424
	if ctx.cr[6].eq {
	pc = 0x821A6424; continue 'dispatch;
	}
	// 821A6414: 896B00BA  lbz r11, 0xba(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(186 as u32) ) } as u64;
	// 821A6418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A641C: 409A0008  bne cr6, 0x821a6424
	if !ctx.cr[6].eq {
	pc = 0x821A6424; continue 'dispatch;
	}
	// 821A6420: 3A600001  li r19, 1
	ctx.r[19].s64 = 1;
	pc = 0x821A6424; continue 'dispatch;
            }
            0x821A6424 => {
    //   block [0x821A6424..0x821A6460)
	// 821A6424: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A6428: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 821A642C: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 821A6430: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A6434: 419A00E8  beq cr6, 0x821a651c
	if ctx.cr[6].eq {
	pc = 0x821A651C; continue 'dispatch;
	}
	// 821A6438: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A643C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6440: 419A0020  beq cr6, 0x821a6460
	if ctx.cr[6].eq {
	pc = 0x821A6460; continue 'dispatch;
	}
	// 821A6444: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821A6448: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A644C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A6450: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A6454: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A6458: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A645C: 480000C4  b 0x821a6520
	pc = 0x821A6520; continue 'dispatch;
            }
            0x821A6460 => {
    //   block [0x821A6460..0x821A647C)
	// 821A6460: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A6464: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A6468: 92410068  stw r18, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[18].u32 ) };
	// 821A646C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A6470: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821A6474: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A6478: 40810054  ble 0x821a64cc
	if !ctx.cr[0].gt {
	pc = 0x821A64CC; continue 'dispatch;
	}
	pc = 0x821A647C; continue 'dispatch;
            }
            0x821A647C => {
    //   block [0x821A647C..0x821A649C)
	// 821A647C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A6480: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A6484: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821A6488: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A648C: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 821A6490: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A6494: 41980008  blt cr6, 0x821a649c
	if ctx.cr[6].lt {
	pc = 0x821A649C; continue 'dispatch;
	}
	// 821A6498: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	pc = 0x821A649C; continue 'dispatch;
            }
            0x821A649C => {
    //   block [0x821A649C..0x821A64B8)
	// 821A649C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A64A0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A64A4: 419A0014  beq cr6, 0x821a64b8
	if ctx.cr[6].eq {
	pc = 0x821A64B8; continue 'dispatch;
	}
	// 821A64A8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A64AC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A64B0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A64B4: 4800000C  b 0x821a64c0
	pc = 0x821A64C0; continue 'dispatch;
            }
            0x821A64B8 => {
    //   block [0x821A64B8..0x821A64C0)
	// 821A64B8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A64BC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A64C0; continue 'dispatch;
            }
            0x821A64C0 => {
    //   block [0x821A64C0..0x821A64CC)
	// 821A64C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A64C4: 4199FFB8  bgt cr6, 0x821a647c
	if ctx.cr[6].gt {
	pc = 0x821A647C; continue 'dispatch;
	}
	// 821A64C8: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x821A64CC; continue 'dispatch;
            }
            0x821A64CC => {
    //   block [0x821A64CC..0x821A64E8)
	// 821A64CC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A64D0: 419A003C  beq cr6, 0x821a650c
	if ctx.cr[6].eq {
	pc = 0x821A650C; continue 'dispatch;
	}
	// 821A64D4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A64D8: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 821A64DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A64E0: 41990008  bgt cr6, 0x821a64e8
	if ctx.cr[6].gt {
	pc = 0x821A64E8; continue 'dispatch;
	}
	// 821A64E4: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A64E8; continue 'dispatch;
            }
            0x821A64E8 => {
    //   block [0x821A64E8..0x821A650C)
	// 821A64E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A64EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A64F0: 409A001C  bne cr6, 0x821a650c
	if !ctx.cr[6].eq {
	pc = 0x821A650C; continue 'dispatch;
	}
	// 821A64F4: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A64F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A64FC: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A6500: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A6504: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6508: 48000018  b 0x821a6520
	pc = 0x821A6520; continue 'dispatch;
            }
            0x821A650C => {
    //   block [0x821A650C..0x821A651C)
	// 821A650C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821A6510: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A6514: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6518: 48000008  b 0x821a6520
	pc = 0x821A6520; continue 'dispatch;
            }
            0x821A651C => {
    //   block [0x821A651C..0x821A6520)
	// 821A651C: 7E4A9378  mr r10, r18
	ctx.r[10].u64 = ctx.r[18].u64;
	pc = 0x821A6520; continue 'dispatch;
            }
            0x821A6520 => {
    //   block [0x821A6520..0x821A6548)
	// 821A6520: 5549063E  clrlwi r9, r10, 0x18
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821A6524: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821A6528: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A652C: 3ACA5E78  addi r22, r10, 0x5e78
	ctx.r[22].s64 = ctx.r[10].s64 + 24184;
	// 821A6530: 419A008C  beq cr6, 0x821a65bc
	if ctx.cr[6].eq {
	pc = 0x821A65BC; continue 'dispatch;
	}
	// 821A6534: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A6538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A653C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821A6540: 409A0008  bne cr6, 0x821a6548
	if !ctx.cr[6].eq {
	pc = 0x821A6548; continue 'dispatch;
	}
	// 821A6544: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x821A6548; continue 'dispatch;
            }
            0x821A6548 => {
    //   block [0x821A6548..0x821A6564)
	// 821A6548: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A654C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6550: 409A0044  bne cr6, 0x821a6594
	if !ctx.cr[6].eq {
	pc = 0x821A6594; continue 'dispatch;
	}
	// 821A6554: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821A6558: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821A655C: 394B0CA0  addi r10, r11, 0xca0
	ctx.r[10].s64 = ctx.r[11].s64 + 3232;
	// 821A6560: 39691470  addi r11, r9, 0x1470
	ctx.r[11].s64 = ctx.r[9].s64 + 5232;
	pc = 0x821A6564; continue 'dispatch;
            }
            0x821A6564 => {
    //   block [0x821A6564..0x821A6588)
	// 821A6564: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6568: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A656C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821A6570: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821A6574: 419A0014  beq cr6, 0x821a6588
	if ctx.cr[6].eq {
	pc = 0x821A6588; continue 'dispatch;
	}
	// 821A6578: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A657C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A6580: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821A6584: 419AFFE0  beq cr6, 0x821a6564
	if ctx.cr[6].eq {
	pc = 0x821A6564; continue 'dispatch;
	}
	pc = 0x821A6588; continue 'dispatch;
            }
            0x821A6588 => {
    //   block [0x821A6588..0x821A6594)
	// 821A6588: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821A658C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821A6590: 4800001C  b 0x821a65ac
	pc = 0x821A65AC; continue 'dispatch;
            }
            0x821A6594 => {
    //   block [0x821A6594..0x821A65AC)
	// 821A6594: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821A6598: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A659C: 388A1470  addi r4, r10, 0x1470
	ctx.r[4].s64 = ctx.r[10].s64 + 5232;
	// 821A65A0: 480C7259  bl 0x8226d7f8
	ctx.lr = 0x821A65A4;
	sub_8226D7F8(ctx, base);
	// 821A65A4: 7C690034  cntlzw r9, r3
	ctx.r[9].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821A65A8: 552BDFFE  rlwinm r11, r9, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	pc = 0x821A65AC; continue 'dispatch;
            }
            0x821A65AC => {
    //   block [0x821A65AC..0x821A65BC)
	// 821A65AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A65B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A65B4: 419A0008  beq cr6, 0x821a65bc
	if ctx.cr[6].eq {
	pc = 0x821A65BC; continue 'dispatch;
	}
	// 821A65B8: 3A600001  li r19, 1
	ctx.r[19].s64 = 1;
	pc = 0x821A65BC; continue 'dispatch;
            }
            0x821A65BC => {
    //   block [0x821A65BC..0x821A65DC)
	// 821A65BC: 81710020  lwz r11, 0x20(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A65C0: 7E5D9378  mr r29, r18
	ctx.r[29].u64 = ctx.r[18].u64;
	// 821A65C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A65C8: 419A0014  beq cr6, 0x821a65dc
	if ctx.cr[6].eq {
	pc = 0x821A65DC; continue 'dispatch;
	}
	// 821A65CC: 81510024  lwz r10, 0x24(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A65D0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821A65D4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A65D8: 40820020  bne 0x821a65f8
	if !ctx.cr[0].eq {
	pc = 0x821A65F8; continue 'dispatch;
	}
	pc = 0x821A65DC; continue 'dispatch;
            }
            0x821A65DC => {
    //   block [0x821A65DC..0x821A65F8)
	// 821A65DC: 81710030  lwz r11, 0x30(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A65E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A65E4: 419A0018  beq cr6, 0x821a65fc
	if ctx.cr[6].eq {
	pc = 0x821A65FC; continue 'dispatch;
	}
	// 821A65E8: 81510034  lwz r10, 0x34(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(52 as u32) ) } as u64;
	// 821A65EC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821A65F0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A65F4: 41820008  beq 0x821a65fc
	if ctx.cr[0].eq {
	pc = 0x821A65FC; continue 'dispatch;
	}
	pc = 0x821A65F8; continue 'dispatch;
            }
            0x821A65F8 => {
    //   block [0x821A65F8..0x821A65FC)
	// 821A65F8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	pc = 0x821A65FC; continue 'dispatch;
            }
            0x821A65FC => {
    //   block [0x821A65FC..0x821A6654)
	// 821A65FC: 8971003D  lbz r11, 0x3d(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[17].u32.wrapping_add(61 as u32) ) } as u64;
	// 821A6600: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6604: 419A0A14  beq cr6, 0x821a7018
	if ctx.cr[6].eq {
	pc = 0x821A7018; continue 'dispatch;
	}
	// 821A6608: 566B063E  clrlwi r11, r19, 0x18
	ctx.r[11].u64 = ctx.r[19].u32 as u64 & 0x000000FFu64;
	// 821A660C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6610: 409A10E0  bne cr6, 0x821a76f0
	if !ctx.cr[6].eq {
	pc = 0x821A76F0; continue 'dispatch;
	}
	// 821A6614: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A6618: 7E579378  mr r23, r18
	ctx.r[23].u64 = ctx.r[18].u64;
	// 821A661C: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 821A6620: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A6624: 419A00F4  beq cr6, 0x821a6718
	if ctx.cr[6].eq {
	pc = 0x821A6718; continue 'dispatch;
	}
	// 821A6628: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A662C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6630: 419A0024  beq cr6, 0x821a6654
	if ctx.cr[6].eq {
	pc = 0x821A6654; continue 'dispatch;
	}
	// 821A6634: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 821A6638: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A663C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A6640: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A6644: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6648: 7D775B78  mr r23, r11
	ctx.r[23].u64 = ctx.r[11].u64;
	// 821A664C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6650: 480000CC  b 0x821a671c
	pc = 0x821A671C; continue 'dispatch;
            }
            0x821A6654 => {
    //   block [0x821A6654..0x821A6670)
	// 821A6654: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A6658: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A665C: 92410068  stw r18, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[18].u32 ) };
	// 821A6660: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A6664: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821A6668: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A666C: 40810054  ble 0x821a66c0
	if !ctx.cr[0].gt {
	pc = 0x821A66C0; continue 'dispatch;
	}
	pc = 0x821A6670; continue 'dispatch;
            }
            0x821A6670 => {
    //   block [0x821A6670..0x821A6690)
	// 821A6670: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A6674: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A6678: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821A667C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6680: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 821A6684: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A6688: 41980008  blt cr6, 0x821a6690
	if ctx.cr[6].lt {
	pc = 0x821A6690; continue 'dispatch;
	}
	// 821A668C: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	pc = 0x821A6690; continue 'dispatch;
            }
            0x821A6690 => {
    //   block [0x821A6690..0x821A66AC)
	// 821A6690: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A6694: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A6698: 419A0014  beq cr6, 0x821a66ac
	if ctx.cr[6].eq {
	pc = 0x821A66AC; continue 'dispatch;
	}
	// 821A669C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A66A0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A66A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A66A8: 4800000C  b 0x821a66b4
	pc = 0x821A66B4; continue 'dispatch;
            }
            0x821A66AC => {
    //   block [0x821A66AC..0x821A66B4)
	// 821A66AC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A66B0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A66B4; continue 'dispatch;
            }
            0x821A66B4 => {
    //   block [0x821A66B4..0x821A66C0)
	// 821A66B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A66B8: 4199FFB8  bgt cr6, 0x821a6670
	if ctx.cr[6].gt {
	pc = 0x821A6670; continue 'dispatch;
	}
	// 821A66BC: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x821A66C0; continue 'dispatch;
            }
            0x821A66C0 => {
    //   block [0x821A66C0..0x821A66DC)
	// 821A66C0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A66C4: 419A0040  beq cr6, 0x821a6704
	if ctx.cr[6].eq {
	pc = 0x821A6704; continue 'dispatch;
	}
	// 821A66C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A66CC: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 821A66D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A66D4: 41990008  bgt cr6, 0x821a66dc
	if ctx.cr[6].gt {
	pc = 0x821A66DC; continue 'dispatch;
	}
	// 821A66D8: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A66DC; continue 'dispatch;
            }
            0x821A66DC => {
    //   block [0x821A66DC..0x821A6704)
	// 821A66DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A66E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A66E4: 409A0020  bne cr6, 0x821a6704
	if !ctx.cr[6].eq {
	pc = 0x821A6704; continue 'dispatch;
	}
	// 821A66E8: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A66EC: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A66F0: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A66F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A66F8: 7D775B78  mr r23, r11
	ctx.r[23].u64 = ctx.r[11].u64;
	// 821A66FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6700: 4800001C  b 0x821a671c
	pc = 0x821A671C; continue 'dispatch;
            }
            0x821A6704 => {
    //   block [0x821A6704..0x821A6718)
	// 821A6704: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821A6708: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A670C: 7D775B78  mr r23, r11
	ctx.r[23].u64 = ctx.r[11].u64;
	// 821A6710: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6714: 48000008  b 0x821a671c
	pc = 0x821A671C; continue 'dispatch;
            }
            0x821A6718 => {
    //   block [0x821A6718..0x821A671C)
	// 821A6718: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A671C; continue 'dispatch;
            }
            0x821A671C => {
    //   block [0x821A671C..0x821A6774)
	// 821A671C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A6720: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6724: 419A1E40  beq cr6, 0x821a8564
	if ctx.cr[6].eq {
	pc = 0x821A8564; continue 'dispatch;
	}
	// 821A6728: 81710054  lwz r11, 0x54(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A672C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6730: 409A074C  bne cr6, 0x821a6e7c
	if !ctx.cr[6].eq {
	pc = 0x821A6E7C; continue 'dispatch;
	}
	// 821A6734: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A6738: 7E5F9378  mr r31, r18
	ctx.r[31].u64 = ctx.r[18].u64;
	// 821A673C: 556AD7FE  rlwinm r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 821A6740: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A6744: 419A00F4  beq cr6, 0x821a6838
	if ctx.cr[6].eq {
	pc = 0x821A6838; continue 'dispatch;
	}
	// 821A6748: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A674C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6750: 419A0024  beq cr6, 0x821a6774
	if ctx.cr[6].eq {
	pc = 0x821A6774; continue 'dispatch;
	}
	// 821A6754: 894B0006  lbz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 821A6758: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A675C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A6760: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A6764: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6768: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821A676C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6770: 480000CC  b 0x821a683c
	pc = 0x821A683C; continue 'dispatch;
            }
            0x821A6774 => {
    //   block [0x821A6774..0x821A6790)
	// 821A6774: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A6778: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A677C: 92410068  stw r18, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[18].u32 ) };
	// 821A6780: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A6784: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821A6788: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A678C: 40810054  ble 0x821a67e0
	if !ctx.cr[0].gt {
	pc = 0x821A67E0; continue 'dispatch;
	}
	pc = 0x821A6790; continue 'dispatch;
            }
            0x821A6790 => {
    //   block [0x821A6790..0x821A67B0)
	// 821A6790: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A6794: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A6798: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821A679C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A67A0: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 821A67A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A67A8: 41980008  blt cr6, 0x821a67b0
	if ctx.cr[6].lt {
	pc = 0x821A67B0; continue 'dispatch;
	}
	// 821A67AC: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	pc = 0x821A67B0; continue 'dispatch;
            }
            0x821A67B0 => {
    //   block [0x821A67B0..0x821A67CC)
	// 821A67B0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A67B4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A67B8: 419A0014  beq cr6, 0x821a67cc
	if ctx.cr[6].eq {
	pc = 0x821A67CC; continue 'dispatch;
	}
	// 821A67BC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A67C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A67C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A67C8: 4800000C  b 0x821a67d4
	pc = 0x821A67D4; continue 'dispatch;
            }
            0x821A67CC => {
    //   block [0x821A67CC..0x821A67D4)
	// 821A67CC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A67D0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A67D4; continue 'dispatch;
            }
            0x821A67D4 => {
    //   block [0x821A67D4..0x821A67E0)
	// 821A67D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A67D8: 4199FFB8  bgt cr6, 0x821a6790
	if ctx.cr[6].gt {
	pc = 0x821A6790; continue 'dispatch;
	}
	// 821A67DC: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x821A67E0; continue 'dispatch;
            }
            0x821A67E0 => {
    //   block [0x821A67E0..0x821A67FC)
	// 821A67E0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A67E4: 419A0040  beq cr6, 0x821a6824
	if ctx.cr[6].eq {
	pc = 0x821A6824; continue 'dispatch;
	}
	// 821A67E8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A67EC: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821A67F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A67F4: 41990008  bgt cr6, 0x821a67fc
	if ctx.cr[6].gt {
	pc = 0x821A67FC; continue 'dispatch;
	}
	// 821A67F8: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A67FC; continue 'dispatch;
            }
            0x821A67FC => {
    //   block [0x821A67FC..0x821A6824)
	// 821A67FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A6800: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6804: 409A0020  bne cr6, 0x821a6824
	if !ctx.cr[6].eq {
	pc = 0x821A6824; continue 'dispatch;
	}
	// 821A6808: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A680C: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A6810: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A6814: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6818: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821A681C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6820: 4800001C  b 0x821a683c
	pc = 0x821A683C; continue 'dispatch;
            }
            0x821A6824 => {
    //   block [0x821A6824..0x821A6838)
	// 821A6824: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821A6828: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A682C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821A6830: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6834: 48000008  b 0x821a683c
	pc = 0x821A683C; continue 'dispatch;
            }
            0x821A6838 => {
    //   block [0x821A6838..0x821A683C)
	// 821A6838: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A683C; continue 'dispatch;
            }
            0x821A683C => {
    //   block [0x821A683C..0x821A6870)
	// 821A683C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A6840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6844: 419A1D20  beq cr6, 0x821a8564
	if ctx.cr[6].eq {
	pc = 0x821A8564; continue 'dispatch;
	}
	// 821A6848: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821A684C: 48078A0D  bl 0x8221f258
	ctx.lr = 0x821A6850;
	sub_8221F258(ctx, base);
	// 821A6850: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A6854: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6858: 3B8BBE04  addi r28, r11, -0x41fc
	ctx.r[28].s64 = ctx.r[11].s64 + -16892;
	// 821A685C: 419A0014  beq cr6, 0x821a6870
	if ctx.cr[6].eq {
	pc = 0x821A6870; continue 'dispatch;
	}
	// 821A6860: C03CF92C  lfs f1, -0x6d4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-1748 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A6864: 480E52DD  bl 0x8228bb40
	ctx.lr = 0x821A6868;
	sub_8228BB40(ctx, base);
	// 821A6868: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821A686C: 48000008  b 0x821a6874
	pc = 0x821A6874; continue 'dispatch;
            }
            0x821A6870 => {
    //   block [0x821A6870..0x821A6874)
	// 821A6870: 7E589378  mr r24, r18
	ctx.r[24].u64 = ctx.r[18].u64;
	pc = 0x821A6874; continue 'dispatch;
            }
            0x821A6874 => {
    //   block [0x821A6874..0x821A6894)
	// 821A6874: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821A6878: 480789E1  bl 0x8221f258
	ctx.lr = 0x821A687C;
	sub_8221F258(ctx, base);
	// 821A687C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6880: 419A0014  beq cr6, 0x821a6894
	if ctx.cr[6].eq {
	pc = 0x821A6894; continue 'dispatch;
	}
	// 821A6884: C03CF92C  lfs f1, -0x6d4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-1748 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A6888: 48082EB1  bl 0x82229738
	ctx.lr = 0x821A688C;
	sub_82229738(ctx, base);
	// 821A688C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821A6890: 48000008  b 0x821a6898
	pc = 0x821A6898; continue 'dispatch;
            }
            0x821A6894 => {
    //   block [0x821A6894..0x821A6898)
	// 821A6894: 7E599378  mr r25, r18
	ctx.r[25].u64 = ctx.r[18].u64;
	pc = 0x821A6898; continue 'dispatch;
            }
            0x821A6898 => {
    //   block [0x821A6898..0x821A68F0)
	// 821A6898: 8171004C  lwz r11, 0x4c(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A689C: 3B71004C  addi r27, r17, 0x4c
	ctx.r[27].s64 = ctx.r[17].s64 + 76;
	// 821A68A0: 835F0094  lwz r26, 0x94(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A68A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A68A8: 409A03A8  bne cr6, 0x821a6c50
	if !ctx.cr[6].eq {
	pc = 0x821A6C50; continue 'dispatch;
	}
	// 821A68AC: 80D10004  lwz r6, 4(r17)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A68B0: 7E5D9378  mr r29, r18
	ctx.r[29].u64 = ctx.r[18].u64;
	// 821A68B4: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A68B8: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 821A68BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A68C0: 419A00F4  beq cr6, 0x821a69b4
	if ctx.cr[6].eq {
	pc = 0x821A69B4; continue 'dispatch;
	}
	// 821A68C4: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A68C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A68CC: 419A0024  beq cr6, 0x821a68f0
	if ctx.cr[6].eq {
	pc = 0x821A68F0; continue 'dispatch;
	}
	// 821A68D0: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821A68D4: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A68D8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A68DC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A68E0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A68E4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821A68E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A68EC: 480000CC  b 0x821a69b8
	pc = 0x821A69B8; continue 'dispatch;
            }
            0x821A68F0 => {
    //   block [0x821A68F0..0x821A690C)
	// 821A68F0: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A68F4: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A68F8: 92410068  stw r18, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[18].u32 ) };
	// 821A68FC: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 821A6900: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821A6904: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A6908: 40810054  ble 0x821a695c
	if !ctx.cr[0].gt {
	pc = 0x821A695C; continue 'dispatch;
	}
	pc = 0x821A690C; continue 'dispatch;
            }
            0x821A690C => {
    //   block [0x821A690C..0x821A692C)
	// 821A690C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A6910: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A6914: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821A6918: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A691C: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 821A6920: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A6924: 41980008  blt cr6, 0x821a692c
	if ctx.cr[6].lt {
	pc = 0x821A692C; continue 'dispatch;
	}
	// 821A6928: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	pc = 0x821A692C; continue 'dispatch;
            }
            0x821A692C => {
    //   block [0x821A692C..0x821A6948)
	// 821A692C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A6930: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A6934: 419A0014  beq cr6, 0x821a6948
	if ctx.cr[6].eq {
	pc = 0x821A6948; continue 'dispatch;
	}
	// 821A6938: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A693C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A6940: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A6944: 4800000C  b 0x821a6950
	pc = 0x821A6950; continue 'dispatch;
            }
            0x821A6948 => {
    //   block [0x821A6948..0x821A6950)
	// 821A6948: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A694C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A6950; continue 'dispatch;
            }
            0x821A6950 => {
    //   block [0x821A6950..0x821A695C)
	// 821A6950: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A6954: 4199FFB8  bgt cr6, 0x821a690c
	if ctx.cr[6].gt {
	pc = 0x821A690C; continue 'dispatch;
	}
	// 821A6958: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x821A695C; continue 'dispatch;
            }
            0x821A695C => {
    //   block [0x821A695C..0x821A6978)
	// 821A695C: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821A6960: 419A0040  beq cr6, 0x821a69a0
	if ctx.cr[6].eq {
	pc = 0x821A69A0; continue 'dispatch;
	}
	// 821A6964: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6968: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 821A696C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6970: 41990008  bgt cr6, 0x821a6978
	if ctx.cr[6].gt {
	pc = 0x821A6978; continue 'dispatch;
	}
	// 821A6974: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A6978; continue 'dispatch;
            }
            0x821A6978 => {
    //   block [0x821A6978..0x821A69A0)
	// 821A6978: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A697C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6980: 409A0020  bne cr6, 0x821a69a0
	if !ctx.cr[6].eq {
	pc = 0x821A69A0; continue 'dispatch;
	}
	// 821A6984: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A6988: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A698C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A6990: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6994: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821A6998: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A699C: 4800001C  b 0x821a69b8
	pc = 0x821A69B8; continue 'dispatch;
            }
            0x821A69A0 => {
    //   block [0x821A69A0..0x821A69B4)
	// 821A69A0: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821A69A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A69A8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821A69AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A69B0: 48000008  b 0x821a69b8
	pc = 0x821A69B8; continue 'dispatch;
            }
            0x821A69B4 => {
    //   block [0x821A69B4..0x821A69B8)
	// 821A69B4: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A69B8; continue 'dispatch;
            }
            0x821A69B8 => {
    //   block [0x821A69B8..0x821A6A04)
	// 821A69B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A69BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A69C0: 419A0290  beq cr6, 0x821a6c50
	if ctx.cr[6].eq {
	pc = 0x821A6C50; continue 'dispatch;
	}
	// 821A69C4: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A69C8: 7E5F9378  mr r31, r18
	ctx.r[31].u64 = ctx.r[18].u64;
	// 821A69CC: 556A3FFE  rlwinm r10, r11, 7, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x01FFFFFFu64;
	// 821A69D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A69D4: 419A00F4  beq cr6, 0x821a6ac8
	if ctx.cr[6].eq {
	pc = 0x821A6AC8; continue 'dispatch;
	}
	// 821A69D8: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A69DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A69E0: 419A0024  beq cr6, 0x821a6a04
	if ctx.cr[6].eq {
	pc = 0x821A6A04; continue 'dispatch;
	}
	// 821A69E4: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 821A69E8: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A69EC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A69F0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A69F4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A69F8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821A69FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6A00: 480000CC  b 0x821a6acc
	pc = 0x821A6ACC; continue 'dispatch;
            }
            0x821A6A04 => {
    //   block [0x821A6A04..0x821A6A20)
	// 821A6A04: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A6A08: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A6A0C: 92410068  stw r18, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[18].u32 ) };
	// 821A6A10: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A6A14: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821A6A18: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A6A1C: 40810054  ble 0x821a6a70
	if !ctx.cr[0].gt {
	pc = 0x821A6A70; continue 'dispatch;
	}
	pc = 0x821A6A20; continue 'dispatch;
            }
            0x821A6A20 => {
    //   block [0x821A6A20..0x821A6A40)
	// 821A6A20: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A6A24: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A6A28: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821A6A2C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6A30: 2F070019  cmpwi cr6, r7, 0x19
	ctx.cr[6].compare_i32(ctx.r[7].s32, 25, &mut ctx.xer);
	// 821A6A34: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A6A38: 41980008  blt cr6, 0x821a6a40
	if ctx.cr[6].lt {
	pc = 0x821A6A40; continue 'dispatch;
	}
	// 821A6A3C: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	pc = 0x821A6A40; continue 'dispatch;
            }
            0x821A6A40 => {
    //   block [0x821A6A40..0x821A6A5C)
	// 821A6A40: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A6A44: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A6A48: 419A0014  beq cr6, 0x821a6a5c
	if ctx.cr[6].eq {
	pc = 0x821A6A5C; continue 'dispatch;
	}
	// 821A6A4C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A6A50: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A6A54: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A6A58: 4800000C  b 0x821a6a64
	pc = 0x821A6A64; continue 'dispatch;
            }
            0x821A6A5C => {
    //   block [0x821A6A5C..0x821A6A64)
	// 821A6A5C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A6A60: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A6A64; continue 'dispatch;
            }
            0x821A6A64 => {
    //   block [0x821A6A64..0x821A6A70)
	// 821A6A64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A6A68: 4199FFB8  bgt cr6, 0x821a6a20
	if ctx.cr[6].gt {
	pc = 0x821A6A20; continue 'dispatch;
	}
	// 821A6A6C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x821A6A70; continue 'dispatch;
            }
            0x821A6A70 => {
    //   block [0x821A6A70..0x821A6A8C)
	// 821A6A70: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A6A74: 419A0040  beq cr6, 0x821a6ab4
	if ctx.cr[6].eq {
	pc = 0x821A6AB4; continue 'dispatch;
	}
	// 821A6A78: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6A7C: 2F0B0019  cmpwi cr6, r11, 0x19
	ctx.cr[6].compare_i32(ctx.r[11].s32, 25, &mut ctx.xer);
	// 821A6A80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6A84: 41990008  bgt cr6, 0x821a6a8c
	if ctx.cr[6].gt {
	pc = 0x821A6A8C; continue 'dispatch;
	}
	// 821A6A88: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A6A8C; continue 'dispatch;
            }
            0x821A6A8C => {
    //   block [0x821A6A8C..0x821A6AB4)
	// 821A6A8C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A6A90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6A94: 409A0020  bne cr6, 0x821a6ab4
	if !ctx.cr[6].eq {
	pc = 0x821A6AB4; continue 'dispatch;
	}
	// 821A6A98: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A6A9C: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A6AA0: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A6AA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6AA8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821A6AAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6AB0: 4800001C  b 0x821a6acc
	pc = 0x821A6ACC; continue 'dispatch;
            }
            0x821A6AB4 => {
    //   block [0x821A6AB4..0x821A6AC8)
	// 821A6AB4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821A6AB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6ABC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821A6AC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6AC4: 48000008  b 0x821a6acc
	pc = 0x821A6ACC; continue 'dispatch;
            }
            0x821A6AC8 => {
    //   block [0x821A6AC8..0x821A6ACC)
	// 821A6AC8: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A6ACC; continue 'dispatch;
            }
            0x821A6ACC => {
    //   block [0x821A6ACC..0x821A6B0C)
	// 821A6ACC: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A6AD0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821A6AD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A6AD8: 3BCBC330  addi r30, r11, -0x3cd0
	ctx.r[30].s64 = ctx.r[11].s64 + -15568;
	// 821A6ADC: 419A0124  beq cr6, 0x821a6c00
	if ctx.cr[6].eq {
	pc = 0x821A6C00; continue 'dispatch;
	}
	// 821A6AE0: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A6AE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6AE8: 419A0038  beq cr6, 0x821a6b20
	if ctx.cr[6].eq {
	pc = 0x821A6B20; continue 'dispatch;
	}
	// 821A6AEC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A6AF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6AF4: 409A0018  bne cr6, 0x821a6b0c
	if !ctx.cr[6].eq {
	pc = 0x821A6B0C; continue 'dispatch;
	}
	// 821A6AF8: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 821A6AFC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821A6B00: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821A6B04: 694B0001  xori r11, r10, 1
	ctx.r[11].u64 = ctx.r[10].u64 ^ 1;
	// 821A6B08: 4800001C  b 0x821a6b24
	pc = 0x821A6B24; continue 'dispatch;
            }
            0x821A6B0C => {
    //   block [0x821A6B0C..0x821A6B20)
	// 821A6B0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6B10: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821A6B14: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821A6B18: 694B0001  xori r11, r10, 1
	ctx.r[11].u64 = ctx.r[10].u64 ^ 1;
	// 821A6B1C: 48000008  b 0x821a6b24
	pc = 0x821A6B24; continue 'dispatch;
            }
            0x821A6B20 => {
    //   block [0x821A6B20..0x821A6B24)
	// 821A6B20: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A6B24; continue 'dispatch;
            }
            0x821A6B24 => {
    //   block [0x821A6B24..0x821A6B4C)
	// 821A6B24: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A6B28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6B2C: 409A00D4  bne cr6, 0x821a6c00
	if !ctx.cr[6].eq {
	pc = 0x821A6C00; continue 'dispatch;
	}
	// 821A6B30: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A6B34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6B38: 419A0014  beq cr6, 0x821a6b4c
	if ctx.cr[6].eq {
	pc = 0x821A6B4C; continue 'dispatch;
	}
	// 821A6B3C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A6B40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6B44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6B48: 409A0008  bne cr6, 0x821a6b50
	if !ctx.cr[6].eq {
	pc = 0x821A6B50; continue 'dispatch;
	}
	pc = 0x821A6B4C; continue 'dispatch;
            }
            0x821A6B4C => {
    //   block [0x821A6B4C..0x821A6B50)
	// 821A6B4C: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A6B50; continue 'dispatch;
            }
            0x821A6B50 => {
    //   block [0x821A6B50..0x821A6B90)
	// 821A6B50: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A6B54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6B58: 419A0040  beq cr6, 0x821a6b98
	if ctx.cr[6].eq {
	pc = 0x821A6B98; continue 'dispatch;
	}
	// 821A6B5C: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 821A6B60: 480786F9  bl 0x8221f258
	ctx.lr = 0x821A6B64;
	sub_8221F258(ctx, base);
	// 821A6B64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6B68: 419A0028  beq cr6, 0x821a6b90
	if ctx.cr[6].eq {
	pc = 0x821A6B90; continue 'dispatch;
	}
	// 821A6B6C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A6B70: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A6B74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821A6B78: C03CD680  lfs f1, -0x2980(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-10624 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A6B7C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821A6B80: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821A6B84: 480DD0AD  bl 0x82283c30
	ctx.lr = 0x821A6B88;
	sub_82283C30(ctx, base);
	// 821A6B88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A6B8C: 4800006C  b 0x821a6bf8
	pc = 0x821A6BF8; continue 'dispatch;
            }
            0x821A6B90 => {
    //   block [0x821A6B90..0x821A6B98)
	// 821A6B90: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 821A6B94: 48000064  b 0x821a6bf8
	pc = 0x821A6BF8; continue 'dispatch;
            }
            0x821A6B98 => {
    //   block [0x821A6B98..0x821A6BD8)
	// 821A6B98: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A6B9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6BA0: 419A0038  beq cr6, 0x821a6bd8
	if ctx.cr[6].eq {
	pc = 0x821A6BD8; continue 'dispatch;
	}
	// 821A6BA4: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 821A6BA8: 480786B1  bl 0x8221f258
	ctx.lr = 0x821A6BAC;
	sub_8221F258(ctx, base);
	// 821A6BAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6BB0: 419AFFE0  beq cr6, 0x821a6b90
	if ctx.cr[6].eq {
	pc = 0x821A6B90; continue 'dispatch;
	}
	// 821A6BB4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A6BB8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A6BBC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821A6BC0: C03CD680  lfs f1, -0x2980(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-10624 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A6BC4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821A6BC8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821A6BCC: 480DD065  bl 0x82283c30
	ctx.lr = 0x821A6BD0;
	sub_82283C30(ctx, base);
	// 821A6BD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A6BD4: 48000024  b 0x821a6bf8
	pc = 0x821A6BF8; continue 'dispatch;
            }
            0x821A6BD8 => {
    //   block [0x821A6BD8..0x821A6BF8)
	// 821A6BD8: 92410050  stw r18, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[18].u32 ) };
	// 821A6BDC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821A6BE0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A6BE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A6BE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821A6BEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A6BF0: 480DD141  bl 0x82283d30
	ctx.lr = 0x821A6BF4;
	sub_82283D30(ctx, base);
	// 821A6BF4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x821A6BF8; continue 'dispatch;
            }
            0x821A6BF8 => {
    //   block [0x821A6BF8..0x821A6C00)
	// 821A6BF8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821A6BFC: 480CC45D  bl 0x82273058
	ctx.lr = 0x821A6C00;
	sub_82273058(ctx, base);
	pc = 0x821A6C00; continue 'dispatch;
            }
            0x821A6C00 => {
    //   block [0x821A6C00..0x821A6C34)
	// 821A6C00: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6C08: 409A002C  bne cr6, 0x821a6c34
	if !ctx.cr[6].eq {
	pc = 0x821A6C34; continue 'dispatch;
	}
	// 821A6C0C: 92410050  stw r18, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[18].u32 ) };
	// 821A6C10: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821A6C14: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A6C18: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A6C1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821A6C20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A6C24: 480DD10D  bl 0x82283d30
	ctx.lr = 0x821A6C28;
	sub_82283D30(ctx, base);
	// 821A6C28: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821A6C2C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A6C30: 480CC429  bl 0x82273058
	ctx.lr = 0x821A6C34;
	sub_82273058(ctx, base);
	pc = 0x821A6C34; continue 'dispatch;
            }
            0x821A6C34 => {
    //   block [0x821A6C34..0x821A6C48)
	// 821A6C34: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A6C38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6C3C: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 821A6C40: 409A0008  bne cr6, 0x821a6c48
	if !ctx.cr[6].eq {
	pc = 0x821A6C48; continue 'dispatch;
	}
	// 821A6C44: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	pc = 0x821A6C48; continue 'dispatch;
            }
            0x821A6C48 => {
    //   block [0x821A6C48..0x821A6C50)
	// 821A6C48: 38710040  addi r3, r17, 0x40
	ctx.r[3].s64 = ctx.r[17].s64 + 64;
	// 821A6C4C: 480BE555  bl 0x822651a0
	ctx.lr = 0x821A6C50;
	sub_822651A0(ctx, base);
	pc = 0x821A6C50; continue 'dispatch;
            }
            0x821A6C50 => {
    //   block [0x821A6C50..0x821A6CE0)
	// 821A6C50: 81710058  lwz r11, 0x58(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A6C54: 3BB10058  addi r29, r17, 0x58
	ctx.r[29].s64 = ctx.r[17].s64 + 88;
	// 821A6C58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6C5C: 409A0098  bne cr6, 0x821a6cf4
	if !ctx.cr[6].eq {
	pc = 0x821A6CF4; continue 'dispatch;
	}
	// 821A6C60: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821A6C64: 92410078  stw r18, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[18].u32 ) };
	// 821A6C68: 9241007C  stw r18, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[18].u32 ) };
	// 821A6C6C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A6C70: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 821A6C74: 38C0003F  li r6, 0x3f
	ctx.r[6].s64 = 63;
	// 821A6C78: 92410080  stw r18, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[18].u32 ) };
	// 821A6C7C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821A6C80: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 821A6C84: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821A6C88: 9241008C  stw r18, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[18].u32 ) };
	// 821A6C8C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821A6C90: 92410090  stw r18, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[18].u32 ) };
	// 821A6C94: 92410094  stw r18, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[18].u32 ) };
	// 821A6C98: 9A410099  stb r18, 0x99(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(153 as u32), ctx.r[18].u8 ) };
	// 821A6C9C: 924100A0  stw r18, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[18].u32 ) };
	// 821A6CA0: 924100A4  stw r18, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[18].u32 ) };
	// 821A6CA4: 924100A8  stw r18, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[18].u32 ) };
	// 821A6CA8: 924100B0  stw r18, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[18].u32 ) };
	// 821A6CAC: 924100B4  stw r18, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[18].u32 ) };
	// 821A6CB0: 924100B8  stw r18, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[18].u32 ) };
	// 821A6CB4: 486C3205  bl 0x82869eb8
	ctx.lr = 0x821A6CB8;
	sub_82869EB8(ctx, base);
	// 821A6CB8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 821A6CBC: 4807859D  bl 0x8221f258
	ctx.lr = 0x821A6CC0;
	sub_8221F258(ctx, base);
	// 821A6CC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6CC4: 419A001C  beq cr6, 0x821a6ce0
	if ctx.cr[6].eq {
	pc = 0x821A6CE0; continue 'dispatch;
	}
	// 821A6CC8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821A6CCC: 80BB0000  lwz r5, 0(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6CD0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821A6CD4: 485BB105  bl 0x82761dd8
	ctx.lr = 0x821A6CD8;
	sub_82761DD8(ctx, base);
	// 821A6CD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A6CDC: 48000008  b 0x821a6ce4
	pc = 0x821A6CE4; continue 'dispatch;
            }
            0x821A6CE0 => {
    //   block [0x821A6CE0..0x821A6CE4)
	// 821A6CE0: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	pc = 0x821A6CE4; continue 'dispatch;
            }
            0x821A6CE4 => {
    //   block [0x821A6CE4..0x821A6CF4)
	// 821A6CE4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A6CE8: 480CC371  bl 0x82273058
	ctx.lr = 0x821A6CEC;
	sub_82273058(ctx, base);
	// 821A6CEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A6CF0: 48660A61  bl 0x82807750
	ctx.lr = 0x821A6CF4;
	sub_82807750(ctx, base);
	pc = 0x821A6CF4; continue 'dispatch;
            }
            0x821A6CF4 => {
    //   block [0x821A6CF4..0x821A6D14)
	// 821A6CF4: 80710060  lwz r3, 0x60(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(96 as u32) ) } as u64;
	// 821A6CF8: 3BD10060  addi r30, r17, 0x60
	ctx.r[30].s64 = ctx.r[17].s64 + 96;
	// 821A6CFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6D00: 419A0014  beq cr6, 0x821a6d14
	if ctx.cr[6].eq {
	pc = 0x821A6D14; continue 'dispatch;
	}
	// 821A6D04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6D08: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A6D0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A6D10: 4E800421  bctrl
	ctx.lr = 0x821A6D14;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A6D14 => {
    //   block [0x821A6D14..0x821A6D68)
	// 821A6D14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 821A6D18: 48078541  bl 0x8221f258
	ctx.lr = 0x821A6D1C;
	sub_8221F258(ctx, base);
	// 821A6D1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A6D20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A6D24: 419A0044  beq cr6, 0x821a6d68
	if ctx.cr[6].eq {
	pc = 0x821A6D68; continue 'dispatch;
	}
	// 821A6D28: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821A6D2C: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6D30: 485B9D91  bl 0x82760ac0
	ctx.lr = 0x821A6D34;
	sub_82760AC0(ctx, base);
	// 821A6D34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A6D38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A6D3C: 394B4248  addi r10, r11, 0x4248
	ctx.r[10].s64 = ctx.r[11].s64 + 16968;
	// 821A6D40: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A6D44: 480DD225  bl 0x82283f68
	ctx.lr = 0x821A6D48;
	sub_82283F68(ctx, base);
	// 821A6D48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A6D4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A6D50: 485BB2B9  bl 0x82762008
	ctx.lr = 0x821A6D54;
	sub_82762008(ctx, base);
	// 821A6D54: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A6D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A6D5C: 485BB3C5  bl 0x82762120
	ctx.lr = 0x821A6D60;
	sub_82762120(ctx, base);
	// 821A6D60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A6D64: 48000008  b 0x821a6d6c
	pc = 0x821A6D6C; continue 'dispatch;
            }
            0x821A6D68 => {
    //   block [0x821A6D68..0x821A6D6C)
	// 821A6D68: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	pc = 0x821A6D6C; continue 'dispatch;
            }
            0x821A6D6C => {
    //   block [0x821A6D6C..0x821A6DB8)
	// 821A6D6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A6D70: 480CC2E9  bl 0x82273058
	ctx.lr = 0x821A6D74;
	sub_82273058(ctx, base);
	// 821A6D74: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 821A6D78: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 821A6D7C: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6D80: 3900001F  li r8, 0x1f
	ctx.r[8].s64 = 31;
	// 821A6D84: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 821A6D88: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821A6D8C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821A6D90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821A6D94: 483BC325  bl 0x825630b8
	ctx.lr = 0x821A6D98;
	sub_825630B8(ctx, base);
	// 821A6D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A6D9C: 80710054  lwz r3, 0x54(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A6DA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6DA4: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821A6DA8: 419A0078  beq cr6, 0x821a6e20
	if ctx.cr[6].eq {
	pc = 0x821A6E20; continue 'dispatch;
	}
	// 821A6DAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6DB0: 419A0040  beq cr6, 0x821a6df0
	if ctx.cr[6].eq {
	pc = 0x821A6DF0; continue 'dispatch;
	}
	// 821A6DB4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821A6DB8; continue 'dispatch;
            }
            0x821A6DB8 => {
    //   block [0x821A6DB8..0x821A6DEC)
	// 821A6DB8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821A6DBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A6DC0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821A6DC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A6DC8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821A6DCC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A6DD0: 4082FFE8  bne 0x821a6db8
	if !ctx.cr[0].eq {
	pc = 0x821A6DB8; continue 'dispatch;
	}
	// 821A6DD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A6DD8: 409A0014  bne cr6, 0x821a6dec
	if !ctx.cr[6].eq {
	pc = 0x821A6DEC; continue 'dispatch;
	}
	// 821A6DDC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6DE0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6DE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A6DE8: 4E800421  bctrl
	ctx.lr = 0x821A6DEC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A6DEC => {
    //   block [0x821A6DEC..0x821A6DF0)
	// 821A6DEC: 92510054  stw r18, 0x54(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(84 as u32), ctx.r[18].u32 ) };
	pc = 0x821A6DF0; continue 'dispatch;
            }
            0x821A6DF0 => {
    //   block [0x821A6DF0..0x821A6E04)
	// 821A6DF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6DF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6DF8: 91710054  stw r11, 0x54(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821A6DFC: 419A0024  beq cr6, 0x821a6e20
	if ctx.cr[6].eq {
	pc = 0x821A6E20; continue 'dispatch;
	}
	// 821A6E00: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x821A6E04; continue 'dispatch;
            }
            0x821A6E04 => {
    //   block [0x821A6E04..0x821A6E20)
	// 821A6E04: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821A6E08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A6E0C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821A6E10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A6E14: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821A6E18: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A6E1C: 4082FFE8  bne 0x821a6e04
	if !ctx.cr[0].eq {
	pc = 0x821A6E04; continue 'dispatch;
	}
	pc = 0x821A6E20; continue 'dispatch;
            }
            0x821A6E20 => {
    //   block [0x821A6E20..0x821A6E34)
	// 821A6E20: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821A6E24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6E28: 419A173C  beq cr6, 0x821a8564
	if ctx.cr[6].eq {
	pc = 0x821A8564; continue 'dispatch;
	}
	// 821A6E2C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A6E30: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x821A6E34; continue 'dispatch;
            }
            0x821A6E34 => {
    //   block [0x821A6E34..0x821A6E7C)
	// 821A6E34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821A6E38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A6E3C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821A6E40: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A6E44: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821A6E48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A6E4C: 4082FFE8  bne 0x821a6e34
	if !ctx.cr[0].eq {
	pc = 0x821A6E34; continue 'dispatch;
	}
	// 821A6E50: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821A6E54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A6E58: 409A170C  bne cr6, 0x821a8564
	if !ctx.cr[6].eq {
	pc = 0x821A8564; continue 'dispatch;
	}
	// 821A6E5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6E60: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6E64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A6E68: 4E800421  bctrl
	ctx.lr = 0x821A6E6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A6E6C: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 821A6E70: CBC1FF70  lfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821A6E74: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 821A6E78: 48B025B4  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A6E7C => {
    //   block [0x821A6E7C..0x821A6EA0)
	// 821A6E7C: 8071004C  lwz r3, 0x4c(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A6E80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6E84: 419A001C  beq cr6, 0x821a6ea0
	if ctx.cr[6].eq {
	pc = 0x821A6EA0; continue 'dispatch;
	}
	// 821A6E88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6E8C: C0030020  lfs f0, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6E90: EC20F82A  fadds f1, f0, f31
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 821A6E94: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A6E98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A6E9C: 4E800421  bctrl
	ctx.lr = 0x821A6EA0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A6EA0 => {
    //   block [0x821A6EA0..0x821A6EE4)
	// 821A6EA0: 81710004  lwz r11, 4(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6EA4: 7E4A9378  mr r10, r18
	ctx.r[10].u64 = ctx.r[18].u64;
	// 821A6EA8: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A6EAC: 55285FFE  rlwinm r8, r9, 0xb, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x001FFFFFu64;
	// 821A6EB0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A6EB4: 419A00F4  beq cr6, 0x821a6fa8
	if ctx.cr[6].eq {
	pc = 0x821A6FA8; continue 'dispatch;
	}
	// 821A6EB8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A6EBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A6EC0: 419A0024  beq cr6, 0x821a6ee4
	if ctx.cr[6].eq {
	pc = 0x821A6EE4; continue 'dispatch;
	}
	// 821A6EC4: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 821A6EC8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A6ECC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A6ED0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A6ED4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6ED8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821A6EDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6EE0: 480000CC  b 0x821a6fac
	pc = 0x821A6FAC; continue 'dispatch;
            }
            0x821A6EE4 => {
    //   block [0x821A6EE4..0x821A6F00)
	// 821A6EE4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A6EE8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A6EEC: 92410068  stw r18, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[18].u32 ) };
	// 821A6EF0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A6EF4: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821A6EF8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A6EFC: 40810054  ble 0x821a6f50
	if !ctx.cr[0].gt {
	pc = 0x821A6F50; continue 'dispatch;
	}
	pc = 0x821A6F00; continue 'dispatch;
            }
            0x821A6F00 => {
    //   block [0x821A6F00..0x821A6F20)
	// 821A6F00: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A6F04: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A6F08: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821A6F0C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6F10: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 821A6F14: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A6F18: 41980008  blt cr6, 0x821a6f20
	if ctx.cr[6].lt {
	pc = 0x821A6F20; continue 'dispatch;
	}
	// 821A6F1C: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	pc = 0x821A6F20; continue 'dispatch;
            }
            0x821A6F20 => {
    //   block [0x821A6F20..0x821A6F3C)
	// 821A6F20: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A6F24: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A6F28: 419A0014  beq cr6, 0x821a6f3c
	if ctx.cr[6].eq {
	pc = 0x821A6F3C; continue 'dispatch;
	}
	// 821A6F2C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A6F30: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A6F34: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A6F38: 4800000C  b 0x821a6f44
	pc = 0x821A6F44; continue 'dispatch;
            }
            0x821A6F3C => {
    //   block [0x821A6F3C..0x821A6F44)
	// 821A6F3C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A6F40: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A6F44; continue 'dispatch;
            }
            0x821A6F44 => {
    //   block [0x821A6F44..0x821A6F50)
	// 821A6F44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A6F48: 4199FFB8  bgt cr6, 0x821a6f00
	if ctx.cr[6].gt {
	pc = 0x821A6F00; continue 'dispatch;
	}
	// 821A6F4C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x821A6F50; continue 'dispatch;
            }
            0x821A6F50 => {
    //   block [0x821A6F50..0x821A6F6C)
	// 821A6F50: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A6F54: 419A0040  beq cr6, 0x821a6f94
	if ctx.cr[6].eq {
	pc = 0x821A6F94; continue 'dispatch;
	}
	// 821A6F58: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6F5C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 821A6F60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6F64: 41990008  bgt cr6, 0x821a6f6c
	if ctx.cr[6].gt {
	pc = 0x821A6F6C; continue 'dispatch;
	}
	// 821A6F68: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A6F6C; continue 'dispatch;
            }
            0x821A6F6C => {
    //   block [0x821A6F6C..0x821A6F94)
	// 821A6F6C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A6F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6F74: 409A0020  bne cr6, 0x821a6f94
	if !ctx.cr[6].eq {
	pc = 0x821A6F94; continue 'dispatch;
	}
	// 821A6F78: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A6F7C: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A6F80: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A6F84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6F88: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821A6F8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6F90: 4800001C  b 0x821a6fac
	pc = 0x821A6FAC; continue 'dispatch;
            }
            0x821A6F94 => {
    //   block [0x821A6F94..0x821A6FA8)
	// 821A6F94: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821A6F98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6F9C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821A6FA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A6FA4: 48000008  b 0x821a6fac
	pc = 0x821A6FAC; continue 'dispatch;
            }
            0x821A6FA8 => {
    //   block [0x821A6FA8..0x821A6FAC)
	// 821A6FA8: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A6FAC; continue 'dispatch;
            }
            0x821A6FAC => {
    //   block [0x821A6FAC..0x821A6FCC)
	// 821A6FAC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A6FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6FB4: 419A0034  beq cr6, 0x821a6fe8
	if ctx.cr[6].eq {
	pc = 0x821A6FE8; continue 'dispatch;
	}
	// 821A6FB8: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A6FBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6FC0: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 821A6FC4: 409A0008  bne cr6, 0x821a6fcc
	if !ctx.cr[6].eq {
	pc = 0x821A6FCC; continue 'dispatch;
	}
	// 821A6FC8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	pc = 0x821A6FCC; continue 'dispatch;
            }
            0x821A6FCC => {
    //   block [0x821A6FCC..0x821A6FE8)
	// 821A6FCC: 38910040  addi r4, r17, 0x40
	ctx.r[4].s64 = ctx.r[17].s64 + 64;
	// 821A6FD0: 48996E79  bl 0x82b3de48
	ctx.lr = 0x821A6FD4;
	sub_82B3DE48(ctx, base);
	// 821A6FD4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821A6FD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6FDC: 419A000C  beq cr6, 0x821a6fe8
	if ctx.cr[6].eq {
	pc = 0x821A6FE8; continue 'dispatch;
	}
	// 821A6FE0: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821A6FE4: 486C3885  bl 0x8286a868
	ctx.lr = 0x821A6FE8;
	sub_8286A868(ctx, base);
	pc = 0x821A6FE8; continue 'dispatch;
            }
            0x821A6FE8 => {
    //   block [0x821A6FE8..0x821A7018)
	// 821A6FE8: 8971003C  lbz r11, 0x3c(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[17].u32.wrapping_add(60 as u32) ) } as u64;
	// 821A6FEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6FF0: 419A1574  beq cr6, 0x821a8564
	if ctx.cr[6].eq {
	pc = 0x821A8564; continue 'dispatch;
	}
	// 821A6FF4: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 821A6FF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6FFC: 409A1568  bne cr6, 0x821a8564
	if !ctx.cr[6].eq {
	pc = 0x821A8564; continue 'dispatch;
	}
	// 821A7000: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821A7004: 486C3865  bl 0x8286a868
	ctx.lr = 0x821A7008;
	sub_8286A868(ctx, base);
	// 821A7008: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 821A700C: CBC1FF70  lfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821A7010: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 821A7014: 48B02418  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A7018 => {
    //   block [0x821A7018..0x821A7054)
	// 821A7018: 895E0024  lbz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A701C: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 821A7020: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821A7024: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A7028: 419A00E8  beq cr6, 0x821a7110
	if ctx.cr[6].eq {
	pc = 0x821A7110; continue 'dispatch;
	}
	// 821A702C: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A7030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7034: 419A0020  beq cr6, 0x821a7054
	if ctx.cr[6].eq {
	pc = 0x821A7054; continue 'dispatch;
	}
	// 821A7038: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A703C: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A7040: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A7044: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A7048: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A704C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7050: 480000C4  b 0x821a7114
	pc = 0x821A7114; continue 'dispatch;
            }
            0x821A7054 => {
    //   block [0x821A7054..0x821A7070)
	// 821A7054: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A7058: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A705C: 92410068  stw r18, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[18].u32 ) };
	// 821A7060: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A7064: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821A7068: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A706C: 40810054  ble 0x821a70c0
	if !ctx.cr[0].gt {
	pc = 0x821A70C0; continue 'dispatch;
	}
	pc = 0x821A7070; continue 'dispatch;
            }
            0x821A7070 => {
    //   block [0x821A7070..0x821A7090)
	// 821A7070: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A7074: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A7078: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821A707C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7080: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 821A7084: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A7088: 41980008  blt cr6, 0x821a7090
	if ctx.cr[6].lt {
	pc = 0x821A7090; continue 'dispatch;
	}
	// 821A708C: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	pc = 0x821A7090; continue 'dispatch;
            }
            0x821A7090 => {
    //   block [0x821A7090..0x821A70AC)
	// 821A7090: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A7094: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A7098: 419A0014  beq cr6, 0x821a70ac
	if ctx.cr[6].eq {
	pc = 0x821A70AC; continue 'dispatch;
	}
	// 821A709C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A70A0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A70A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A70A8: 4800000C  b 0x821a70b4
	pc = 0x821A70B4; continue 'dispatch;
            }
            0x821A70AC => {
    //   block [0x821A70AC..0x821A70B4)
	// 821A70AC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A70B0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A70B4; continue 'dispatch;
            }
            0x821A70B4 => {
    //   block [0x821A70B4..0x821A70C0)
	// 821A70B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A70B8: 4199FFB8  bgt cr6, 0x821a7070
	if ctx.cr[6].gt {
	pc = 0x821A7070; continue 'dispatch;
	}
	// 821A70BC: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x821A70C0; continue 'dispatch;
            }
            0x821A70C0 => {
    //   block [0x821A70C0..0x821A70DC)
	// 821A70C0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A70C4: 419A003C  beq cr6, 0x821a7100
	if ctx.cr[6].eq {
	pc = 0x821A7100; continue 'dispatch;
	}
	// 821A70C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A70CC: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 821A70D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A70D4: 41990008  bgt cr6, 0x821a70dc
	if ctx.cr[6].gt {
	pc = 0x821A70DC; continue 'dispatch;
	}
	// 821A70D8: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A70DC; continue 'dispatch;
            }
            0x821A70DC => {
    //   block [0x821A70DC..0x821A7100)
	// 821A70DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A70E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A70E4: 409A001C  bne cr6, 0x821a7100
	if !ctx.cr[6].eq {
	pc = 0x821A7100; continue 'dispatch;
	}
	// 821A70E8: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A70EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A70F0: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A70F4: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A70F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A70FC: 48000018  b 0x821a7114
	pc = 0x821A7114; continue 'dispatch;
            }
            0x821A7100 => {
    //   block [0x821A7100..0x821A7110)
	// 821A7100: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821A7104: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A7108: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A710C: 48000008  b 0x821a7114
	pc = 0x821A7114; continue 'dispatch;
            }
            0x821A7110 => {
    //   block [0x821A7110..0x821A7114)
	// 821A7110: 7E4A9378  mr r10, r18
	ctx.r[10].u64 = ctx.r[18].u64;
	pc = 0x821A7114; continue 'dispatch;
            }
            0x821A7114 => {
    //   block [0x821A7114..0x821A7178)
	// 821A7114: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821A7118: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A711C: 419A05F8  beq cr6, 0x821a7714
	if ctx.cr[6].eq {
	pc = 0x821A7714; continue 'dispatch;
	}
	// 821A7120: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A7124: 4BFCD68D  bl 0x821747b0
	ctx.lr = 0x821A7128;
	sub_821747B0(ctx, base);
	// 821A7128: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821A712C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7130: 419A05E4  beq cr6, 0x821a7714
	if ctx.cr[6].eq {
	pc = 0x821A7714; continue 'dispatch;
	}
	// 821A7134: 80D10004  lwz r6, 4(r17)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7138: 7E5A9378  mr r26, r18
	ctx.r[26].u64 = ctx.r[18].u64;
	// 821A713C: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A7140: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 821A7144: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A7148: 419A00F4  beq cr6, 0x821a723c
	if ctx.cr[6].eq {
	pc = 0x821A723C; continue 'dispatch;
	}
	// 821A714C: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A7150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7154: 419A0024  beq cr6, 0x821a7178
	if ctx.cr[6].eq {
	pc = 0x821A7178; continue 'dispatch;
	}
	// 821A7158: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 821A715C: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A7160: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A7164: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A7168: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A716C: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 821A7170: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7174: 480000CC  b 0x821a7240
	pc = 0x821A7240; continue 'dispatch;
            }
            0x821A7178 => {
    //   block [0x821A7178..0x821A7194)
	// 821A7178: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A717C: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A7180: 92410068  stw r18, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[18].u32 ) };
	// 821A7184: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 821A7188: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821A718C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A7190: 40810054  ble 0x821a71e4
	if !ctx.cr[0].gt {
	pc = 0x821A71E4; continue 'dispatch;
	}
	pc = 0x821A7194; continue 'dispatch;
            }
            0x821A7194 => {
    //   block [0x821A7194..0x821A71B4)
	// 821A7194: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A7198: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A719C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821A71A0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A71A4: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 821A71A8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A71AC: 41980008  blt cr6, 0x821a71b4
	if ctx.cr[6].lt {
	pc = 0x821A71B4; continue 'dispatch;
	}
	// 821A71B0: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	pc = 0x821A71B4; continue 'dispatch;
            }
            0x821A71B4 => {
    //   block [0x821A71B4..0x821A71D0)
	// 821A71B4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A71B8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A71BC: 419A0014  beq cr6, 0x821a71d0
	if ctx.cr[6].eq {
	pc = 0x821A71D0; continue 'dispatch;
	}
	// 821A71C0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A71C4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A71C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A71CC: 4800000C  b 0x821a71d8
	pc = 0x821A71D8; continue 'dispatch;
            }
            0x821A71D0 => {
    //   block [0x821A71D0..0x821A71D8)
	// 821A71D0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A71D4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A71D8; continue 'dispatch;
            }
            0x821A71D8 => {
    //   block [0x821A71D8..0x821A71E4)
	// 821A71D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A71DC: 4199FFB8  bgt cr6, 0x821a7194
	if ctx.cr[6].gt {
	pc = 0x821A7194; continue 'dispatch;
	}
	// 821A71E0: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x821A71E4; continue 'dispatch;
            }
            0x821A71E4 => {
    //   block [0x821A71E4..0x821A7200)
	// 821A71E4: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821A71E8: 419A0040  beq cr6, 0x821a7228
	if ctx.cr[6].eq {
	pc = 0x821A7228; continue 'dispatch;
	}
	// 821A71EC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A71F0: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 821A71F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A71F8: 41990008  bgt cr6, 0x821a7200
	if ctx.cr[6].gt {
	pc = 0x821A7200; continue 'dispatch;
	}
	// 821A71FC: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A7200; continue 'dispatch;
            }
            0x821A7200 => {
    //   block [0x821A7200..0x821A7228)
	// 821A7200: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A7204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7208: 409A0020  bne cr6, 0x821a7228
	if !ctx.cr[6].eq {
	pc = 0x821A7228; continue 'dispatch;
	}
	// 821A720C: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A7210: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A7214: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A7218: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A721C: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 821A7220: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7224: 4800001C  b 0x821a7240
	pc = 0x821A7240; continue 'dispatch;
            }
            0x821A7228 => {
    //   block [0x821A7228..0x821A723C)
	// 821A7228: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821A722C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7230: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 821A7234: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7238: 48000008  b 0x821a7240
	pc = 0x821A7240; continue 'dispatch;
            }
            0x821A723C => {
    //   block [0x821A723C..0x821A7240)
	// 821A723C: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A7240; continue 'dispatch;
            }
            0x821A7240 => {
    //   block [0x821A7240..0x821A7298)
	// 821A7240: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A7244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7248: 419A131C  beq cr6, 0x821a8564
	if ctx.cr[6].eq {
	pc = 0x821A8564; continue 'dispatch;
	}
	// 821A724C: 81710054  lwz r11, 0x54(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A7250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7254: 409A0478  bne cr6, 0x821a76cc
	if !ctx.cr[6].eq {
	pc = 0x821A76CC; continue 'dispatch;
	}
	// 821A7258: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A725C: 7E5E9378  mr r30, r18
	ctx.r[30].u64 = ctx.r[18].u64;
	// 821A7260: 556AD7FE  rlwinm r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 821A7264: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A7268: 419A00F4  beq cr6, 0x821a735c
	if ctx.cr[6].eq {
	pc = 0x821A735C; continue 'dispatch;
	}
	// 821A726C: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A7270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7274: 419A0024  beq cr6, 0x821a7298
	if ctx.cr[6].eq {
	pc = 0x821A7298; continue 'dispatch;
	}
	// 821A7278: 894B0006  lbz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 821A727C: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A7280: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A7284: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A7288: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A728C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A7290: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7294: 480000CC  b 0x821a7360
	pc = 0x821A7360; continue 'dispatch;
            }
            0x821A7298 => {
    //   block [0x821A7298..0x821A72B4)
	// 821A7298: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A729C: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A72A0: 92410068  stw r18, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[18].u32 ) };
	// 821A72A4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A72A8: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821A72AC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A72B0: 40810054  ble 0x821a7304
	if !ctx.cr[0].gt {
	pc = 0x821A7304; continue 'dispatch;
	}
	pc = 0x821A72B4; continue 'dispatch;
            }
            0x821A72B4 => {
    //   block [0x821A72B4..0x821A72D4)
	// 821A72B4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A72B8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A72BC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821A72C0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A72C4: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 821A72C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A72CC: 41980008  blt cr6, 0x821a72d4
	if ctx.cr[6].lt {
	pc = 0x821A72D4; continue 'dispatch;
	}
	// 821A72D0: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	pc = 0x821A72D4; continue 'dispatch;
            }
            0x821A72D4 => {
    //   block [0x821A72D4..0x821A72F0)
	// 821A72D4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A72D8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A72DC: 419A0014  beq cr6, 0x821a72f0
	if ctx.cr[6].eq {
	pc = 0x821A72F0; continue 'dispatch;
	}
	// 821A72E0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A72E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A72E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A72EC: 4800000C  b 0x821a72f8
	pc = 0x821A72F8; continue 'dispatch;
            }
            0x821A72F0 => {
    //   block [0x821A72F0..0x821A72F8)
	// 821A72F0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A72F4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A72F8; continue 'dispatch;
            }
            0x821A72F8 => {
    //   block [0x821A72F8..0x821A7304)
	// 821A72F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A72FC: 4199FFB8  bgt cr6, 0x821a72b4
	if ctx.cr[6].gt {
	pc = 0x821A72B4; continue 'dispatch;
	}
	// 821A7300: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x821A7304; continue 'dispatch;
            }
            0x821A7304 => {
    //   block [0x821A7304..0x821A7320)
	// 821A7304: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A7308: 419A0040  beq cr6, 0x821a7348
	if ctx.cr[6].eq {
	pc = 0x821A7348; continue 'dispatch;
	}
	// 821A730C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7310: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821A7314: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7318: 41990008  bgt cr6, 0x821a7320
	if ctx.cr[6].gt {
	pc = 0x821A7320; continue 'dispatch;
	}
	// 821A731C: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A7320; continue 'dispatch;
            }
            0x821A7320 => {
    //   block [0x821A7320..0x821A7348)
	// 821A7320: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A7324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7328: 409A0020  bne cr6, 0x821a7348
	if !ctx.cr[6].eq {
	pc = 0x821A7348; continue 'dispatch;
	}
	// 821A732C: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A7330: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A7334: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A7338: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A733C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A7340: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7344: 4800001C  b 0x821a7360
	pc = 0x821A7360; continue 'dispatch;
            }
            0x821A7348 => {
    //   block [0x821A7348..0x821A735C)
	// 821A7348: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821A734C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7350: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A7354: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7358: 48000008  b 0x821a7360
	pc = 0x821A7360; continue 'dispatch;
            }
            0x821A735C => {
    //   block [0x821A735C..0x821A7360)
	// 821A735C: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A7360; continue 'dispatch;
            }
            0x821A7360 => {
    //   block [0x821A7360..0x821A7394)
	// 821A7360: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A7364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7368: 419A11FC  beq cr6, 0x821a8564
	if ctx.cr[6].eq {
	pc = 0x821A8564; continue 'dispatch;
	}
	// 821A736C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821A7370: 48077EE9  bl 0x8221f258
	ctx.lr = 0x821A7374;
	sub_8221F258(ctx, base);
	// 821A7374: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A7378: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A737C: 3BEBBE04  addi r31, r11, -0x41fc
	ctx.r[31].s64 = ctx.r[11].s64 + -16892;
	// 821A7380: 419A0014  beq cr6, 0x821a7394
	if ctx.cr[6].eq {
	pc = 0x821A7394; continue 'dispatch;
	}
	// 821A7384: C03FF92C  lfs f1, -0x6d4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1748 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A7388: 480E47B9  bl 0x8228bb40
	ctx.lr = 0x821A738C;
	sub_8228BB40(ctx, base);
	// 821A738C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821A7390: 48000008  b 0x821a7398
	pc = 0x821A7398; continue 'dispatch;
            }
            0x821A7394 => {
    //   block [0x821A7394..0x821A7398)
	// 821A7394: 7E5B9378  mr r27, r18
	ctx.r[27].u64 = ctx.r[18].u64;
	pc = 0x821A7398; continue 'dispatch;
            }
            0x821A7398 => {
    //   block [0x821A7398..0x821A73B8)
	// 821A7398: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821A739C: 48077EBD  bl 0x8221f258
	ctx.lr = 0x821A73A0;
	sub_8221F258(ctx, base);
	// 821A73A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A73A4: 419A0014  beq cr6, 0x821a73b8
	if ctx.cr[6].eq {
	pc = 0x821A73B8; continue 'dispatch;
	}
	// 821A73A8: C03FF92C  lfs f1, -0x6d4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1748 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A73AC: 4808238D  bl 0x82229738
	ctx.lr = 0x821A73B0;
	sub_82229738(ctx, base);
	// 821A73B0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821A73B4: 48000008  b 0x821a73bc
	pc = 0x821A73BC; continue 'dispatch;
            }
            0x821A73B8 => {
    //   block [0x821A73B8..0x821A73BC)
	// 821A73B8: 7E5C9378  mr r28, r18
	ctx.r[28].u64 = ctx.r[18].u64;
	pc = 0x821A73BC; continue 'dispatch;
            }
            0x821A73BC => {
    //   block [0x821A73BC..0x821A7414)
	// 821A73BC: 8171004C  lwz r11, 0x4c(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A73C0: 3BF1004C  addi r31, r17, 0x4c
	ctx.r[31].s64 = ctx.r[17].s64 + 76;
	// 821A73C4: 83BE0094  lwz r29, 0x94(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A73C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A73CC: 409A0134  bne cr6, 0x821a7500
	if !ctx.cr[6].eq {
	pc = 0x821A7500; continue 'dispatch;
	}
	// 821A73D0: 81710004  lwz r11, 4(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A73D4: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 821A73D8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A73DC: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 821A73E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A73E4: 419A00F4  beq cr6, 0x821a74d8
	if ctx.cr[6].eq {
	pc = 0x821A74D8; continue 'dispatch;
	}
	// 821A73E8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A73EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A73F0: 419A0024  beq cr6, 0x821a7414
	if ctx.cr[6].eq {
	pc = 0x821A7414; continue 'dispatch;
	}
	// 821A73F4: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 821A73F8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A73FC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A7400: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A7404: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7408: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A740C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7410: 480000CC  b 0x821a74dc
	pc = 0x821A74DC; continue 'dispatch;
            }
            0x821A7414 => {
    //   block [0x821A7414..0x821A7430)
	// 821A7414: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A7418: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A741C: 92410068  stw r18, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[18].u32 ) };
	// 821A7420: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821A7424: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821A7428: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A742C: 40810054  ble 0x821a7480
	if !ctx.cr[0].gt {
	pc = 0x821A7480; continue 'dispatch;
	}
	pc = 0x821A7430; continue 'dispatch;
            }
            0x821A7430 => {
    //   block [0x821A7430..0x821A7450)
	// 821A7430: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821A7434: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A7438: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821A743C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7440: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 821A7444: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A7448: 41980008  blt cr6, 0x821a7450
	if ctx.cr[6].lt {
	pc = 0x821A7450; continue 'dispatch;
	}
	// 821A744C: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	pc = 0x821A7450; continue 'dispatch;
            }
            0x821A7450 => {
    //   block [0x821A7450..0x821A746C)
	// 821A7450: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821A7454: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A7458: 419A0014  beq cr6, 0x821a746c
	if ctx.cr[6].eq {
	pc = 0x821A746C; continue 'dispatch;
	}
	// 821A745C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A7460: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A7464: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A7468: 4800000C  b 0x821a7474
	pc = 0x821A7474; continue 'dispatch;
            }
            0x821A746C => {
    //   block [0x821A746C..0x821A7474)
	// 821A746C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821A7470: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821A7474; continue 'dispatch;
            }
            0x821A7474 => {
    //   block [0x821A7474..0x821A7480)
	// 821A7474: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A7478: 4199FFB8  bgt cr6, 0x821a7430
	if ctx.cr[6].gt {
	pc = 0x821A7430; continue 'dispatch;
	}
	// 821A747C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x821A7480; continue 'dispatch;
            }
            0x821A7480 => {
    //   block [0x821A7480..0x821A749C)
	// 821A7480: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A7484: 419A0040  beq cr6, 0x821a74c4
	if ctx.cr[6].eq {
	pc = 0x821A74C4; continue 'dispatch;
	}
	// 821A7488: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A748C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 821A7490: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7494: 41990008  bgt cr6, 0x821a749c
	if ctx.cr[6].gt {
	pc = 0x821A749C; continue 'dispatch;
	}
	// 821A7498: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A749C; continue 'dispatch;
            }
            0x821A749C => {
    //   block [0x821A749C..0x821A74C4)
	// 821A749C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A74A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A74A4: 409A0020  bne cr6, 0x821a74c4
	if !ctx.cr[6].eq {
	pc = 0x821A74C4; continue 'dispatch;
	}
	// 821A74A8: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A74AC: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A74B0: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A74B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A74B8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A74BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A74C0: 4800001C  b 0x821a74dc
	pc = 0x821A74DC; continue 'dispatch;
            }
            0x821A74C4 => {
    //   block [0x821A74C4..0x821A74D8)
	// 821A74C4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821A74C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A74CC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A74D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A74D4: 48000008  b 0x821a74dc
	pc = 0x821A74DC; continue 'dispatch;
            }
            0x821A74D8 => {
    //   block [0x821A74D8..0x821A74DC)
	// 821A74D8: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A74DC; continue 'dispatch;
            }
            0x821A74DC => {
    //   block [0x821A74DC..0x821A7500)
	// 821A74DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A74E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A74E4: 419A001C  beq cr6, 0x821a7500
	if ctx.cr[6].eq {
	pc = 0x821A7500; continue 'dispatch;
	}
	// 821A74E8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821A74EC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A74F0: 38ABC334  addi r5, r11, -0x3ccc
	ctx.r[5].s64 = ctx.r[11].s64 + -15564;
	// 821A74F4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A74F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A74FC: 4801AAB5  bl 0x821c1fb0
	ctx.lr = 0x821A7500;
	sub_821C1FB0(ctx, base);
	pc = 0x821A7500; continue 'dispatch;
            }
            0x821A7500 => {
    //   block [0x821A7500..0x821A7558)
	// 821A7500: 81710058  lwz r11, 0x58(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A7504: 3BD10058  addi r30, r17, 0x58
	ctx.r[30].s64 = ctx.r[17].s64 + 88;
	// 821A7508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A750C: 409A0060  bne cr6, 0x821a756c
	if !ctx.cr[6].eq {
	pc = 0x821A756C; continue 'dispatch;
	}
	// 821A7510: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A7514: 485BA675  bl 0x82761b88
	ctx.lr = 0x821A7518;
	sub_82761B88(ctx, base);
	// 821A7518: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A751C: 38C0003F  li r6, 0x3f
	ctx.r[6].s64 = 63;
	// 821A7520: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821A7524: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821A7528: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821A752C: 486C298D  bl 0x82869eb8
	ctx.lr = 0x821A7530;
	sub_82869EB8(ctx, base);
	// 821A7530: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 821A7534: 48077D25  bl 0x8221f258
	ctx.lr = 0x821A7538;
	sub_8221F258(ctx, base);
	// 821A7538: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A753C: 419A001C  beq cr6, 0x821a7558
	if ctx.cr[6].eq {
	pc = 0x821A7558; continue 'dispatch;
	}
	// 821A7540: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821A7544: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7548: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821A754C: 485BA88D  bl 0x82761dd8
	ctx.lr = 0x821A7550;
	sub_82761DD8(ctx, base);
	// 821A7550: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A7554: 48000008  b 0x821a755c
	pc = 0x821A755C; continue 'dispatch;
            }
            0x821A7558 => {
    //   block [0x821A7558..0x821A755C)
	// 821A7558: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	pc = 0x821A755C; continue 'dispatch;
            }
            0x821A755C => {
    //   block [0x821A755C..0x821A756C)
	// 821A755C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A7560: 480CBAF9  bl 0x82273058
	ctx.lr = 0x821A7564;
	sub_82273058(ctx, base);
	// 821A7564: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A7568: 486601E9  bl 0x82807750
	ctx.lr = 0x821A756C;
	sub_82807750(ctx, base);
	pc = 0x821A756C; continue 'dispatch;
            }
            0x821A756C => {
    //   block [0x821A756C..0x821A758C)
	// 821A756C: 80710060  lwz r3, 0x60(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(96 as u32) ) } as u64;
	// 821A7570: 3BF10060  addi r31, r17, 0x60
	ctx.r[31].s64 = ctx.r[17].s64 + 96;
	// 821A7574: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A7578: 419A0014  beq cr6, 0x821a758c
	if ctx.cr[6].eq {
	pc = 0x821A758C; continue 'dispatch;
	}
	// 821A757C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7580: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A7584: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A7588: 4E800421  bctrl
	ctx.lr = 0x821A758C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A758C => {
    //   block [0x821A758C..0x821A75B4)
	// 821A758C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 821A7590: 48077CC9  bl 0x8221f258
	ctx.lr = 0x821A7594;
	sub_8221F258(ctx, base);
	// 821A7594: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A7598: 419A001C  beq cr6, 0x821a75b4
	if ctx.cr[6].eq {
	pc = 0x821A75B4; continue 'dispatch;
	}
	// 821A759C: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A75A0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821A75A4: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821A75A8: 485BA931  bl 0x82761ed8
	ctx.lr = 0x821A75AC;
	sub_82761ED8(ctx, base);
	// 821A75AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A75B0: 48000008  b 0x821a75b8
	pc = 0x821A75B8; continue 'dispatch;
            }
            0x821A75B4 => {
    //   block [0x821A75B4..0x821A75B8)
	// 821A75B4: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	pc = 0x821A75B8; continue 'dispatch;
            }
            0x821A75B8 => {
    //   block [0x821A75B8..0x821A7608)
	// 821A75B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A75BC: 480CBA9D  bl 0x82273058
	ctx.lr = 0x821A75C0;
	sub_82273058(ctx, base);
	// 821A75C0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821A75C4: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 821A75C8: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A75CC: 3900001F  li r8, 0x1f
	ctx.r[8].s64 = 31;
	// 821A75D0: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 821A75D4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821A75D8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821A75DC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 821A75E0: 483BBAD9  bl 0x825630b8
	ctx.lr = 0x821A75E4;
	sub_825630B8(ctx, base);
	// 821A75E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A75E8: 81710054  lwz r11, 0x54(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A75EC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A75F0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A75F4: 419A007C  beq cr6, 0x821a7670
	if ctx.cr[6].eq {
	pc = 0x821A7670; continue 'dispatch;
	}
	// 821A75F8: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821A75FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A7600: 419A0040  beq cr6, 0x821a7640
	if ctx.cr[6].eq {
	pc = 0x821A7640; continue 'dispatch;
	}
	// 821A7604: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821A7608; continue 'dispatch;
            }
            0x821A7608 => {
    //   block [0x821A7608..0x821A763C)
	// 821A7608: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821A760C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A7610: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821A7614: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A7618: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821A761C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A7620: 4082FFE8  bne 0x821a7608
	if !ctx.cr[0].eq {
	pc = 0x821A7608; continue 'dispatch;
	}
	// 821A7624: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A7628: 409A0014  bne cr6, 0x821a763c
	if !ctx.cr[6].eq {
	pc = 0x821A763C; continue 'dispatch;
	}
	// 821A762C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7630: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7634: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A7638: 4E800421  bctrl
	ctx.lr = 0x821A763C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A763C => {
    //   block [0x821A763C..0x821A7640)
	// 821A763C: 92510054  stw r18, 0x54(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(84 as u32), ctx.r[18].u32 ) };
	pc = 0x821A7640; continue 'dispatch;
            }
            0x821A7640 => {
    //   block [0x821A7640..0x821A7654)
	// 821A7640: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7648: 91710054  stw r11, 0x54(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821A764C: 419A0024  beq cr6, 0x821a7670
	if ctx.cr[6].eq {
	pc = 0x821A7670; continue 'dispatch;
	}
	// 821A7650: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x821A7654; continue 'dispatch;
            }
            0x821A7654 => {
    //   block [0x821A7654..0x821A7670)
	// 821A7654: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821A7658: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A765C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821A7660: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A7664: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821A7668: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A766C: 4082FFE8  bne 0x821a7654
	if !ctx.cr[0].eq {
	pc = 0x821A7654; continue 'dispatch;
	}
	pc = 0x821A7670; continue 'dispatch;
            }
            0x821A7670 => {
    //   block [0x821A7670..0x821A7684)
	// 821A7670: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821A7674: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7678: 419A0EEC  beq cr6, 0x821a8564
	if ctx.cr[6].eq {
	pc = 0x821A8564; continue 'dispatch;
	}
	// 821A767C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A7680: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x821A7684; continue 'dispatch;
            }
            0x821A7684 => {
    //   block [0x821A7684..0x821A76CC)
	// 821A7684: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821A7688: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A768C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821A7690: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A7694: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821A7698: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A769C: 4082FFE8  bne 0x821a7684
	if !ctx.cr[0].eq {
	pc = 0x821A7684; continue 'dispatch;
	}
	// 821A76A0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821A76A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A76A8: 409A0EBC  bne cr6, 0x821a8564
	if !ctx.cr[6].eq {
	pc = 0x821A8564; continue 'dispatch;
	}
	// 821A76AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A76B0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A76B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A76B8: 4E800421  bctrl
	ctx.lr = 0x821A76BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A76BC: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 821A76C0: CBC1FF70  lfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821A76C4: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 821A76C8: 48B01D64  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A76CC => {
    //   block [0x821A76CC..0x821A76F0)
	// 821A76CC: 8071004C  lwz r3, 0x4c(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A76D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A76D4: 419A001C  beq cr6, 0x821a76f0
	if ctx.cr[6].eq {
	pc = 0x821A76F0; continue 'dispatch;
	}
	// 821A76D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A76DC: C0030020  lfs f0, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A76E0: EC20F82A  fadds f1, f0, f31
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 821A76E4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A76E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A76EC: 4E800421  bctrl
	ctx.lr = 0x821A76F0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A76F0 => {
    //   block [0x821A76F0..0x821A7714)
	// 821A76F0: 8971003C  lbz r11, 0x3c(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[17].u32.wrapping_add(60 as u32) ) } as u64;
	// 821A76F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A76F8: 419A0E6C  beq cr6, 0x821a8564
	if ctx.cr[6].eq {
	pc = 0x821A8564; continue 'dispatch;
	}
	// 821A76FC: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821A7700: 486C3169  bl 0x8286a868
	ctx.lr = 0x821A7704;
	sub_8286A868(ctx, base);
	// 821A7704: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 821A7708: CBC1FF70  lfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821A770C: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 821A7710: 48B01D1C  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A7714 => {
    //   block [0x821A7714..0x821A7760)
	// 821A7714: 83F10004  lwz r31, 4(r17)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7718: 7E549378  mr r20, r18
	ctx.r[20].u64 = ctx.r[18].u64;
	// 821A771C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A7720: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 821A7724: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A7728: 419A00A8  beq cr6, 0x821a77d0
	if ctx.cr[6].eq {
	pc = 0x821A77D0; continue 'dispatch;
	}
	// 821A772C: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A7730: 39400013  li r10, 0x13
	ctx.r[10].s64 = 19;
	// 821A7734: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821A7738: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A773C: 419A0024  beq cr6, 0x821a7760
	if ctx.cr[6].eq {
	pc = 0x821A7760; continue 'dispatch;
	}
	// 821A7740: 896B0013  lbz r11, 0x13(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 821A7744: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A7748: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821A774C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A7750: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7754: 7D745B78  mr r20, r11
	ctx.r[20].u64 = ctx.r[11].u64;
	// 821A7758: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A775C: 48000078  b 0x821a77d4
	pc = 0x821A77D4; continue 'dispatch;
            }
            0x821A7760 => {
    //   block [0x821A7760..0x821A7794)
	// 821A7760: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 821A7764: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821A7768: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821A776C: 48161145  bl 0x823088b0
	ctx.lr = 0x821A7770;
	sub_823088B0(ctx, base);
	// 821A7770: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A7774: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A7778: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A777C: 419A0040  beq cr6, 0x821a77bc
	if ctx.cr[6].eq {
	pc = 0x821A77BC; continue 'dispatch;
	}
	// 821A7780: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7784: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 821A7788: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A778C: 41990008  bgt cr6, 0x821a7794
	if ctx.cr[6].gt {
	pc = 0x821A7794; continue 'dispatch;
	}
	// 821A7790: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A7794; continue 'dispatch;
            }
            0x821A7794 => {
    //   block [0x821A7794..0x821A77BC)
	// 821A7794: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A7798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A779C: 409A0020  bne cr6, 0x821a77bc
	if !ctx.cr[6].eq {
	pc = 0x821A77BC; continue 'dispatch;
	}
	// 821A77A0: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A77A4: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A77A8: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A77AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A77B0: 7D745B78  mr r20, r11
	ctx.r[20].u64 = ctx.r[11].u64;
	// 821A77B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A77B8: 4800001C  b 0x821a77d4
	pc = 0x821A77D4; continue 'dispatch;
            }
            0x821A77BC => {
    //   block [0x821A77BC..0x821A77D0)
	// 821A77BC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821A77C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A77C4: 7D745B78  mr r20, r11
	ctx.r[20].u64 = ctx.r[11].u64;
	// 821A77C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A77CC: 48000008  b 0x821a77d4
	pc = 0x821A77D4; continue 'dispatch;
            }
            0x821A77D0 => {
    //   block [0x821A77D0..0x821A77D4)
	// 821A77D0: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A77D4; continue 'dispatch;
            }
            0x821A77D4 => {
    //   block [0x821A77D4..0x821A7834)
	// 821A77D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A77D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A77DC: 419A0D88  beq cr6, 0x821a8564
	if ctx.cr[6].eq {
	pc = 0x821A8564; continue 'dispatch;
	}
	// 821A77E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A77E4: 57BE063E  clrlwi r30, r29, 0x18
	ctx.r[30].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 821A77E8: 3AABBE04  addi r21, r11, -0x41fc
	ctx.r[21].s64 = ctx.r[11].s64 + -16892;
	// 821A77EC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A77F0: C3D5D680  lfs f30, -0x2980(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-10624 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A77F4: 409A0040  bne cr6, 0x821a7834
	if !ctx.cr[6].eq {
	pc = 0x821A7834; continue 'dispatch;
	}
	// 821A77F8: 566B063E  clrlwi r11, r19, 0x18
	ctx.r[11].u64 = ctx.r[19].u32 as u64 & 0x000000FFu64;
	// 821A77FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7800: 409A0034  bne cr6, 0x821a7834
	if !ctx.cr[6].eq {
	pc = 0x821A7834; continue 'dispatch;
	}
	// 821A7804: C195D68C  lfs f12, -0x2974(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-10612 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A7808: 3BF10044  addi r31, r17, 0x44
	ctx.r[31].s64 = ctx.r[17].s64 + 68;
	// 821A780C: C1B10044  lfs f13, 0x44(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7810: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 821A7814: 40980058  bge cr6, 0x821a786c
	if !ctx.cr[6].lt {
	pc = 0x821A786C; continue 'dispatch;
	}
	// 821A7818: C015D4D4  lfs f0, -0x2b2c(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-11052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A781C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821A7820: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A7824: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821A7828: D3C10068  stfs f30, 0x68(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821A782C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 821A7830: 48000030  b 0x821a7860
	pc = 0x821A7860; continue 'dispatch;
            }
            0x821A7834 => {
    //   block [0x821A7834..0x821A7860)
	// 821A7834: C1910044  lfs f12, 0x44(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A7838: 3BF10044  addi r31, r17, 0x44
	ctx.r[31].s64 = ctx.r[17].s64 + 68;
	// 821A783C: FF0CF000  fcmpu cr6, f12, f30
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[30].f64);
	// 821A7840: 4099002C  ble cr6, 0x821a786c
	if !ctx.cr[6].gt {
	pc = 0x821A786C; continue 'dispatch;
	}
	// 821A7844: C015D4D4  lfs f0, -0x2b2c(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-11052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7848: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 821A784C: C1B5D68C  lfs f13, -0x2974(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-10612 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7850: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A7854: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821A7858: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821A785C: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x821A7860; continue 'dispatch;
            }
            0x821A7860 => {
    //   block [0x821A7860..0x821A786C)
	// 821A7860: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A7864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A7868: 4BFC9C91  bl 0x821714f8
	ctx.lr = 0x821A786C;
	sub_821714F8(ctx, base);
	pc = 0x821A786C; continue 'dispatch;
            }
            0x821A786C => {
    //   block [0x821A786C..0x821A78C0)
	// 821A786C: 8071004C  lwz r3, 0x4c(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A7870: 3AF1004C  addi r23, r17, 0x4c
	ctx.r[23].s64 = ctx.r[17].s64 + 76;
	// 821A7874: 7E5C9378  mr r28, r18
	ctx.r[28].u64 = ctx.r[18].u64;
	// 821A7878: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A787C: 419A00A8  beq cr6, 0x821a7924
	if ctx.cr[6].eq {
	pc = 0x821A7924; continue 'dispatch;
	}
	// 821A7880: C0030020  lfs f0, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7884: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7888: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 821A788C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A7890: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A7894: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A7898: 4E800421  bctrl
	ctx.lr = 0x821A789C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A789C: 80770000  lwz r3, 0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A78A0: C0230028  lfs f1, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A78A4: 4812BDA5  bl 0x822d3648
	ctx.lr = 0x821A78A8;
	sub_822D3648(ctx, base);
	// 821A78A8: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 821A78AC: 41980014  blt cr6, 0x821a78c0
	if ctx.cr[6].lt {
	pc = 0x821A78C0; continue 'dispatch;
	}
	// 821A78B0: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821A78B4: 486C2FB5  bl 0x8286a868
	ctx.lr = 0x821A78B8;
	sub_8286A868(ctx, base);
	// 821A78B8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821A78BC: 48000068  b 0x821a7924
	pc = 0x821A7924; continue 'dispatch;
            }
            0x821A78C0 => {
    //   block [0x821A78C0..0x821A7910)
	// 821A78C0: 80770000  lwz r3, 0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A78C4: C015D4C8  lfs f0, -0x2b38(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-11064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A78C8: ECFF002A  fadds f7, f31, f0
	ctx.f[7].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 821A78CC: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A78D0: 4812BD79  bl 0x822d3648
	ctx.lr = 0x821A78D4;
	sub_822D3648(ctx, base);
	// 821A78D4: FF070800  fcmpu cr6, f7, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[1].f64);
	// 821A78D8: 41980038  blt cr6, 0x821a7910
	if ctx.cr[6].lt {
	pc = 0x821A7910; continue 'dispatch;
	}
	// 821A78DC: 80770000  lwz r3, 0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A78E0: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A78E4: 4812BD65  bl 0x822d3648
	ctx.lr = 0x821A78E8;
	sub_822D3648(ctx, base);
	// 821A78E8: EDA1F828  fsubs f13, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[1].f64 - ctx.f[31].f64) as f32) as f64);
	// 821A78EC: C0150000  lfs f0, 0(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A78F0: 81710054  lwz r11, 0x54(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A78F4: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A78F8: C16B0014  lfs f11, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A78FC: D16B0018  stfs f11, 0x18(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A7900: ED4D0032  fmuls f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A7904: ED2A0332  fmuls f9, f10, f12
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 821A7908: D12B0014  stfs f9, 0x14(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A790C: 48000018  b 0x821a7924
	pc = 0x821A7924; continue 'dispatch;
            }
            0x821A7910 => {
    //   block [0x821A7910..0x821A7924)
	// 821A7910: 81710054  lwz r11, 0x54(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A7914: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7918: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A791C: D1AB0018  stfs f13, 0x18(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A7920: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x821A7924; continue 'dispatch;
            }
            0x821A7924 => {
    //   block [0x821A7924..0x821A7970)
	// 821A7924: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821A7928: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821A792C: 3AC00006  li r22, 6
	ctx.r[22].s64 = 6;
	// 821A7930: 3B600015  li r27, 0x15
	ctx.r[27].s64 = 21;
	// 821A7934: 3B400019  li r26, 0x19
	ctx.r[26].s64 = 25;
	// 821A7938: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A793C: 3B2AC334  addi r25, r10, -0x3ccc
	ctx.r[25].s64 = ctx.r[10].s64 + -15564;
	// 821A7940: 3B0BC330  addi r24, r11, -0x3cd0
	ctx.r[24].s64 = ctx.r[11].s64 + -15568;
	// 821A7944: 409A060C  bne cr6, 0x821a7f50
	if !ctx.cr[6].eq {
	pc = 0x821A7F50; continue 'dispatch;
	}
	// 821A7948: 566B063E  clrlwi r11, r19, 0x18
	ctx.r[11].u64 = ctx.r[19].u32 as u64 & 0x000000FFu64;
	// 821A794C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7950: 409A0600  bne cr6, 0x821a7f50
	if !ctx.cr[6].eq {
	pc = 0x821A7F50; continue 'dispatch;
	}
	// 821A7954: 81710030  lwz r11, 0x30(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A795C: 419A0014  beq cr6, 0x821a7970
	if ctx.cr[6].eq {
	pc = 0x821A7970; continue 'dispatch;
	}
	// 821A7960: 81510034  lwz r10, 0x34(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(52 as u32) ) } as u64;
	// 821A7964: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821A7968: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A796C: 408205E4  bne 0x821a7f50
	if !ctx.cr[0].eq {
	pc = 0x821A7F50; continue 'dispatch;
	}
	pc = 0x821A7970; continue 'dispatch;
            }
            0x821A7970 => {
    //   block [0x821A7970..0x821A79D0)
	// 821A7970: 8971003C  lbz r11, 0x3c(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[17].u32.wrapping_add(60 as u32) ) } as u64;
	// 821A7974: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7978: 409A05D8  bne cr6, 0x821a7f50
	if !ctx.cr[6].eq {
	pc = 0x821A7F50; continue 'dispatch;
	}
	// 821A797C: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7980: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7984: 409A05CC  bne cr6, 0x821a7f50
	if !ctx.cr[6].eq {
	pc = 0x821A7F50; continue 'dispatch;
	}
	// 821A7988: 83F10004  lwz r31, 4(r17)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A798C: 7E5D9378  mr r29, r18
	ctx.r[29].u64 = ctx.r[18].u64;
	// 821A7990: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A7994: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 821A7998: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A799C: 419A00A4  beq cr6, 0x821a7a40
	if ctx.cr[6].eq {
	pc = 0x821A7A40; continue 'dispatch;
	}
	// 821A79A0: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A79A4: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 821A79A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A79AC: 419A0024  beq cr6, 0x821a79d0
	if ctx.cr[6].eq {
	pc = 0x821A79D0; continue 'dispatch;
	}
	// 821A79B0: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821A79B4: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A79B8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821A79BC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A79C0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A79C4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821A79C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A79CC: 48000078  b 0x821a7a44
	pc = 0x821A7A44; continue 'dispatch;
            }
            0x821A79D0 => {
    //   block [0x821A79D0..0x821A7A04)
	// 821A79D0: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 821A79D4: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 821A79D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821A79DC: 48160ED5  bl 0x823088b0
	ctx.lr = 0x821A79E0;
	sub_823088B0(ctx, base);
	// 821A79E0: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A79E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A79E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A79EC: 419A0040  beq cr6, 0x821a7a2c
	if ctx.cr[6].eq {
	pc = 0x821A7A2C; continue 'dispatch;
	}
	// 821A79F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A79F4: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 821A79F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A79FC: 41990008  bgt cr6, 0x821a7a04
	if ctx.cr[6].gt {
	pc = 0x821A7A04; continue 'dispatch;
	}
	// 821A7A00: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A7A04; continue 'dispatch;
            }
            0x821A7A04 => {
    //   block [0x821A7A04..0x821A7A2C)
	// 821A7A04: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A7A08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7A0C: 409A0020  bne cr6, 0x821a7a2c
	if !ctx.cr[6].eq {
	pc = 0x821A7A2C; continue 'dispatch;
	}
	// 821A7A10: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A7A14: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A7A18: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A7A1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7A20: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821A7A24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7A28: 4800001C  b 0x821a7a44
	pc = 0x821A7A44; continue 'dispatch;
            }
            0x821A7A2C => {
    //   block [0x821A7A2C..0x821A7A40)
	// 821A7A2C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821A7A30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7A34: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821A7A38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7A3C: 48000008  b 0x821a7a44
	pc = 0x821A7A44; continue 'dispatch;
            }
            0x821A7A40 => {
    //   block [0x821A7A40..0x821A7A44)
	// 821A7A40: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A7A44; continue 'dispatch;
            }
            0x821A7A44 => {
    //   block [0x821A7A44..0x821A7A94)
	// 821A7A44: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A7A48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7A4C: 419A01EC  beq cr6, 0x821a7c38
	if ctx.cr[6].eq {
	pc = 0x821A7C38; continue 'dispatch;
	}
	// 821A7A50: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A7A54: 7E5E9378  mr r30, r18
	ctx.r[30].u64 = ctx.r[18].u64;
	// 821A7A58: 556A3FFE  rlwinm r10, r11, 7, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x01FFFFFFu64;
	// 821A7A5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A7A60: 419A00A4  beq cr6, 0x821a7b04
	if ctx.cr[6].eq {
	pc = 0x821A7B04; continue 'dispatch;
	}
	// 821A7A64: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A7A68: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 821A7A6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7A70: 419A0024  beq cr6, 0x821a7a94
	if ctx.cr[6].eq {
	pc = 0x821A7A94; continue 'dispatch;
	}
	// 821A7A74: 896B0019  lbz r11, 0x19(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 821A7A78: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A7A7C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821A7A80: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A7A84: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7A88: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A7A8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7A90: 48000078  b 0x821a7b08
	pc = 0x821A7B08; continue 'dispatch;
            }
            0x821A7A94 => {
    //   block [0x821A7A94..0x821A7AC8)
	// 821A7A94: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 821A7A98: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 821A7A9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821A7AA0: 48160E11  bl 0x823088b0
	ctx.lr = 0x821A7AA4;
	sub_823088B0(ctx, base);
	// 821A7AA4: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A7AA8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A7AAC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A7AB0: 419A0040  beq cr6, 0x821a7af0
	if ctx.cr[6].eq {
	pc = 0x821A7AF0; continue 'dispatch;
	}
	// 821A7AB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7AB8: 2F0B0019  cmpwi cr6, r11, 0x19
	ctx.cr[6].compare_i32(ctx.r[11].s32, 25, &mut ctx.xer);
	// 821A7ABC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7AC0: 41990008  bgt cr6, 0x821a7ac8
	if ctx.cr[6].gt {
	pc = 0x821A7AC8; continue 'dispatch;
	}
	// 821A7AC4: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A7AC8; continue 'dispatch;
            }
            0x821A7AC8 => {
    //   block [0x821A7AC8..0x821A7AF0)
	// 821A7AC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A7ACC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7AD0: 409A0020  bne cr6, 0x821a7af0
	if !ctx.cr[6].eq {
	pc = 0x821A7AF0; continue 'dispatch;
	}
	// 821A7AD4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A7AD8: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A7ADC: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A7AE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7AE4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A7AE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7AEC: 4800001C  b 0x821a7b08
	pc = 0x821A7B08; continue 'dispatch;
            }
            0x821A7AF0 => {
    //   block [0x821A7AF0..0x821A7B04)
	// 821A7AF0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821A7AF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7AF8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A7AFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7B00: 48000008  b 0x821a7b08
	pc = 0x821A7B08; continue 'dispatch;
            }
            0x821A7B04 => {
    //   block [0x821A7B04..0x821A7B08)
	// 821A7B04: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A7B08; continue 'dispatch;
            }
            0x821A7B08 => {
    //   block [0x821A7B08..0x821A7B44)
	// 821A7B08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A7B0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7B10: 419A00C4  beq cr6, 0x821a7bd4
	if ctx.cr[6].eq {
	pc = 0x821A7BD4; continue 'dispatch;
	}
	// 821A7B14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A7B18: 480C33E1  bl 0x8226aef8
	ctx.lr = 0x821A7B1C;
	sub_8226AEF8(ctx, base);
	// 821A7B1C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821A7B20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7B24: 409A00B0  bne cr6, 0x821a7bd4
	if !ctx.cr[6].eq {
	pc = 0x821A7BD4; continue 'dispatch;
	}
	// 821A7B28: 897E0018  lbz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A7B2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7B30: 419A0014  beq cr6, 0x821a7b44
	if ctx.cr[6].eq {
	pc = 0x821A7B44; continue 'dispatch;
	}
	// 821A7B34: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A7B38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7B3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7B40: 409A0008  bne cr6, 0x821a7b48
	if !ctx.cr[6].eq {
	pc = 0x821A7B48; continue 'dispatch;
	}
	pc = 0x821A7B44; continue 'dispatch;
            }
            0x821A7B44 => {
    //   block [0x821A7B44..0x821A7B48)
	// 821A7B44: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A7B48; continue 'dispatch;
            }
            0x821A7B48 => {
    //   block [0x821A7B48..0x821A7B88)
	// 821A7B48: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A7B4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7B50: 419A0038  beq cr6, 0x821a7b88
	if ctx.cr[6].eq {
	pc = 0x821A7B88; continue 'dispatch;
	}
	// 821A7B54: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 821A7B58: 48077701  bl 0x8221f258
	ctx.lr = 0x821A7B5C;
	sub_8221F258(ctx, base);
	// 821A7B5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A7B60: 419A0068  beq cr6, 0x821a7bc8
	if ctx.cr[6].eq {
	pc = 0x821A7BC8; continue 'dispatch;
	}
	// 821A7B64: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A7B68: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A7B6C: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 821A7B70: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821A7B74: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821A7B78: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 821A7B7C: 480DC0B5  bl 0x82283c30
	ctx.lr = 0x821A7B80;
	sub_82283C30(ctx, base);
	// 821A7B80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A7B84: 48000048  b 0x821a7bcc
	pc = 0x821A7BCC; continue 'dispatch;
            }
            0x821A7B88 => {
    //   block [0x821A7B88..0x821A7BC8)
	// 821A7B88: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A7B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7B90: 419A0044  beq cr6, 0x821a7bd4
	if ctx.cr[6].eq {
	pc = 0x821A7BD4; continue 'dispatch;
	}
	// 821A7B94: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 821A7B98: 480776C1  bl 0x8221f258
	ctx.lr = 0x821A7B9C;
	sub_8221F258(ctx, base);
	// 821A7B9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A7BA0: 419A0028  beq cr6, 0x821a7bc8
	if ctx.cr[6].eq {
	pc = 0x821A7BC8; continue 'dispatch;
	}
	// 821A7BA4: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A7BA8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A7BAC: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 821A7BB0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821A7BB4: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821A7BB8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 821A7BBC: 480DC075  bl 0x82283c30
	ctx.lr = 0x821A7BC0;
	sub_82283C30(ctx, base);
	// 821A7BC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A7BC4: 48000008  b 0x821a7bcc
	pc = 0x821A7BCC; continue 'dispatch;
            }
            0x821A7BC8 => {
    //   block [0x821A7BC8..0x821A7BCC)
	// 821A7BC8: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	pc = 0x821A7BCC; continue 'dispatch;
            }
            0x821A7BCC => {
    //   block [0x821A7BCC..0x821A7BD4)
	// 821A7BCC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 821A7BD0: 480CB489  bl 0x82273058
	ctx.lr = 0x821A7BD4;
	sub_82273058(ctx, base);
	pc = 0x821A7BD4; continue 'dispatch;
            }
            0x821A7BD4 => {
    //   block [0x821A7BD4..0x821A7C24)
	// 821A7BD4: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7BD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7BDC: 409A005C  bne cr6, 0x821a7c38
	if !ctx.cr[6].eq {
	pc = 0x821A7C38; continue 'dispatch;
	}
	// 821A7BE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A7BE4: 480C3315  bl 0x8226aef8
	ctx.lr = 0x821A7BE8;
	sub_8226AEF8(ctx, base);
	// 821A7BE8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821A7BEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A7BF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7BF4: 419A0030  beq cr6, 0x821a7c24
	if ctx.cr[6].eq {
	pc = 0x821A7C24; continue 'dispatch;
	}
	// 821A7BF8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821A7BFC: 48279655  bl 0x82421250
	ctx.lr = 0x821A7C00;
	sub_82421250(ctx, base);
	// 821A7C00: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821A7C04: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A7C08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7C0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A7C10: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821A7C14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A7C18: 409A0018  bne cr6, 0x821a7c30
	if !ctx.cr[6].eq {
	pc = 0x821A7C30; continue 'dispatch;
	}
	// 821A7C1C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821A7C20: 48000014  b 0x821a7c34
	pc = 0x821A7C34; continue 'dispatch;
            }
            0x821A7C24 => {
    //   block [0x821A7C24..0x821A7C30)
	// 821A7C24: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A7C28: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A7C2C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	pc = 0x821A7C30; continue 'dispatch;
            }
            0x821A7C30 => {
    //   block [0x821A7C30..0x821A7C34)
	// 821A7C30: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	pc = 0x821A7C34; continue 'dispatch;
            }
            0x821A7C34 => {
    //   block [0x821A7C34..0x821A7C38)
	// 821A7C34: 4801A37D  bl 0x821c1fb0
	ctx.lr = 0x821A7C38;
	sub_821C1FB0(ctx, base);
	pc = 0x821A7C38; continue 'dispatch;
            }
            0x821A7C38 => {
    //   block [0x821A7C38..0x821A7CA0)
	// 821A7C38: 80770000  lwz r3, 0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7C3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A7C40: 419A0310  beq cr6, 0x821a7f50
	if ctx.cr[6].eq {
	pc = 0x821A7F50; continue 'dispatch;
	}
	// 821A7C44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7C48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821A7C4C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A7C50: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A7C54: 4E800421  bctrl
	ctx.lr = 0x821A7C58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A7C58: 7E5E9378  mr r30, r18
	ctx.r[30].u64 = ctx.r[18].u64;
	// 821A7C5C: 83F10004  lwz r31, 4(r17)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7C60: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A7C64: 5528D7FE  rlwinm r8, r9, 0x1a, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 821A7C68: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A7C6C: 419A00A4  beq cr6, 0x821a7d10
	if ctx.cr[6].eq {
	pc = 0x821A7D10; continue 'dispatch;
	}
	// 821A7C70: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A7C74: 92C10068  stw r22, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[22].u32 ) };
	// 821A7C78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7C7C: 419A0024  beq cr6, 0x821a7ca0
	if ctx.cr[6].eq {
	pc = 0x821A7CA0; continue 'dispatch;
	}
	// 821A7C80: 896B0006  lbz r11, 6(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 821A7C84: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A7C88: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821A7C8C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A7C90: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7C94: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A7C98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7C9C: 48000078  b 0x821a7d14
	pc = 0x821A7D14; continue 'dispatch;
            }
            0x821A7CA0 => {
    //   block [0x821A7CA0..0x821A7CD4)
	// 821A7CA0: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 821A7CA4: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 821A7CA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821A7CAC: 48160C05  bl 0x823088b0
	ctx.lr = 0x821A7CB0;
	sub_823088B0(ctx, base);
	// 821A7CB0: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A7CB4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A7CB8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A7CBC: 419A0040  beq cr6, 0x821a7cfc
	if ctx.cr[6].eq {
	pc = 0x821A7CFC; continue 'dispatch;
	}
	// 821A7CC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7CC4: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821A7CC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7CCC: 41990008  bgt cr6, 0x821a7cd4
	if ctx.cr[6].gt {
	pc = 0x821A7CD4; continue 'dispatch;
	}
	// 821A7CD0: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A7CD4; continue 'dispatch;
            }
            0x821A7CD4 => {
    //   block [0x821A7CD4..0x821A7CFC)
	// 821A7CD4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A7CD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7CDC: 409A0020  bne cr6, 0x821a7cfc
	if !ctx.cr[6].eq {
	pc = 0x821A7CFC; continue 'dispatch;
	}
	// 821A7CE0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A7CE4: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A7CE8: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A7CEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7CF0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A7CF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7CF8: 4800001C  b 0x821a7d14
	pc = 0x821A7D14; continue 'dispatch;
            }
            0x821A7CFC => {
    //   block [0x821A7CFC..0x821A7D10)
	// 821A7CFC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821A7D00: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7D04: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A7D08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7D0C: 48000008  b 0x821a7d14
	pc = 0x821A7D14; continue 'dispatch;
            }
            0x821A7D10 => {
    //   block [0x821A7D10..0x821A7D14)
	// 821A7D10: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A7D14; continue 'dispatch;
            }
            0x821A7D14 => {
    //   block [0x821A7D14..0x821A7D40)
	// 821A7D14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A7D18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7D1C: 419A0234  beq cr6, 0x821a7f50
	if ctx.cr[6].eq {
	pc = 0x821A7F50; continue 'dispatch;
	}
	// 821A7D20: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821A7D24: 48077535  bl 0x8221f258
	ctx.lr = 0x821A7D28;
	sub_8221F258(ctx, base);
	// 821A7D28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A7D2C: 419A0014  beq cr6, 0x821a7d40
	if ctx.cr[6].eq {
	pc = 0x821A7D40; continue 'dispatch;
	}
	// 821A7D30: C035F92C  lfs f1, -0x6d4(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-1748 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A7D34: 480E3E0D  bl 0x8228bb40
	ctx.lr = 0x821A7D38;
	sub_8228BB40(ctx, base);
	// 821A7D38: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821A7D3C: 48000008  b 0x821a7d44
	pc = 0x821A7D44; continue 'dispatch;
            }
            0x821A7D40 => {
    //   block [0x821A7D40..0x821A7D44)
	// 821A7D40: 7E5C9378  mr r28, r18
	ctx.r[28].u64 = ctx.r[18].u64;
	pc = 0x821A7D44; continue 'dispatch;
            }
            0x821A7D44 => {
    //   block [0x821A7D44..0x821A7D64)
	// 821A7D44: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821A7D48: 48077511  bl 0x8221f258
	ctx.lr = 0x821A7D4C;
	sub_8221F258(ctx, base);
	// 821A7D4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A7D50: 419A0014  beq cr6, 0x821a7d64
	if ctx.cr[6].eq {
	pc = 0x821A7D64; continue 'dispatch;
	}
	// 821A7D54: C035F92C  lfs f1, -0x6d4(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-1748 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A7D58: 480819E1  bl 0x82229738
	ctx.lr = 0x821A7D5C;
	sub_82229738(ctx, base);
	// 821A7D5C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A7D60: 48000008  b 0x821a7d68
	pc = 0x821A7D68; continue 'dispatch;
            }
            0x821A7D64 => {
    //   block [0x821A7D64..0x821A7D68)
	// 821A7D64: 7E5D9378  mr r29, r18
	ctx.r[29].u64 = ctx.r[18].u64;
	pc = 0x821A7D68; continue 'dispatch;
            }
            0x821A7D68 => {
    //   block [0x821A7D68..0x821A7DC0)
	// 821A7D68: 81710058  lwz r11, 0x58(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A7D6C: 3BF10058  addi r31, r17, 0x58
	ctx.r[31].s64 = ctx.r[17].s64 + 88;
	// 821A7D70: 80BE0094  lwz r5, 0x94(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A7D74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7D78: 409A005C  bne cr6, 0x821a7dd4
	if !ctx.cr[6].eq {
	pc = 0x821A7DD4; continue 'dispatch;
	}
	// 821A7D7C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A7D80: 485B9E09  bl 0x82761b88
	ctx.lr = 0x821A7D84;
	sub_82761B88(ctx, base);
	// 821A7D84: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A7D88: 38C0003F  li r6, 0x3f
	ctx.r[6].s64 = 63;
	// 821A7D8C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821A7D90: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821A7D94: 486C2125  bl 0x82869eb8
	ctx.lr = 0x821A7D98;
	sub_82869EB8(ctx, base);
	// 821A7D98: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 821A7D9C: 480774BD  bl 0x8221f258
	ctx.lr = 0x821A7DA0;
	sub_8221F258(ctx, base);
	// 821A7DA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A7DA4: 419A001C  beq cr6, 0x821a7dc0
	if ctx.cr[6].eq {
	pc = 0x821A7DC0; continue 'dispatch;
	}
	// 821A7DA8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821A7DAC: 80B70000  lwz r5, 0(r23)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7DB0: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821A7DB4: 485BA025  bl 0x82761dd8
	ctx.lr = 0x821A7DB8;
	sub_82761DD8(ctx, base);
	// 821A7DB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A7DBC: 48000008  b 0x821a7dc4
	pc = 0x821A7DC4; continue 'dispatch;
            }
            0x821A7DC0 => {
    //   block [0x821A7DC0..0x821A7DC4)
	// 821A7DC0: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	pc = 0x821A7DC4; continue 'dispatch;
            }
            0x821A7DC4 => {
    //   block [0x821A7DC4..0x821A7DD4)
	// 821A7DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A7DC8: 480CB291  bl 0x82273058
	ctx.lr = 0x821A7DCC;
	sub_82273058(ctx, base);
	// 821A7DCC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A7DD0: 4865F981  bl 0x82807750
	ctx.lr = 0x821A7DD4;
	sub_82807750(ctx, base);
	pc = 0x821A7DD4; continue 'dispatch;
            }
            0x821A7DD4 => {
    //   block [0x821A7DD4..0x821A7DF4)
	// 821A7DD4: 80710060  lwz r3, 0x60(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(96 as u32) ) } as u64;
	// 821A7DD8: 3BD10060  addi r30, r17, 0x60
	ctx.r[30].s64 = ctx.r[17].s64 + 96;
	// 821A7DDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A7DE0: 419A0014  beq cr6, 0x821a7df4
	if ctx.cr[6].eq {
	pc = 0x821A7DF4; continue 'dispatch;
	}
	// 821A7DE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7DE8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A7DEC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A7DF0: 4E800421  bctrl
	ctx.lr = 0x821A7DF4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A7DF4 => {
    //   block [0x821A7DF4..0x821A7E1C)
	// 821A7DF4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 821A7DF8: 48077461  bl 0x8221f258
	ctx.lr = 0x821A7DFC;
	sub_8221F258(ctx, base);
	// 821A7DFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A7E00: 419A001C  beq cr6, 0x821a7e1c
	if ctx.cr[6].eq {
	pc = 0x821A7E1C; continue 'dispatch;
	}
	// 821A7E04: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7E08: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821A7E0C: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821A7E10: 485BA0C9  bl 0x82761ed8
	ctx.lr = 0x821A7E14;
	sub_82761ED8(ctx, base);
	// 821A7E14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A7E18: 48000008  b 0x821a7e20
	pc = 0x821A7E20; continue 'dispatch;
            }
            0x821A7E1C => {
    //   block [0x821A7E1C..0x821A7E20)
	// 821A7E1C: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	pc = 0x821A7E20; continue 'dispatch;
            }
            0x821A7E20 => {
    //   block [0x821A7E20..0x821A7E78)
	// 821A7E20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A7E24: 480CB235  bl 0x82273058
	ctx.lr = 0x821A7E28;
	sub_82273058(ctx, base);
	// 821A7E28: 83F10054  lwz r31, 0x54(r17)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A7E2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A7E30: 409A0104  bne cr6, 0x821a7f34
	if !ctx.cr[6].eq {
	pc = 0x821A7F34; continue 'dispatch;
	}
	// 821A7E34: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 821A7E38: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7E3C: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 821A7E40: 3900001F  li r8, 0x1f
	ctx.r[8].s64 = 31;
	// 821A7E44: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 821A7E48: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821A7E4C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821A7E50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821A7E54: 483BB265  bl 0x825630b8
	ctx.lr = 0x821A7E58;
	sub_825630B8(ctx, base);
	// 821A7E58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A7E5C: 80710054  lwz r3, 0x54(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A7E60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7E64: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821A7E68: 419A0078  beq cr6, 0x821a7ee0
	if ctx.cr[6].eq {
	pc = 0x821A7EE0; continue 'dispatch;
	}
	// 821A7E6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A7E70: 419A0040  beq cr6, 0x821a7eb0
	if ctx.cr[6].eq {
	pc = 0x821A7EB0; continue 'dispatch;
	}
	// 821A7E74: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821A7E78; continue 'dispatch;
            }
            0x821A7E78 => {
    //   block [0x821A7E78..0x821A7EAC)
	// 821A7E78: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821A7E7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A7E80: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821A7E84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A7E88: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821A7E8C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A7E90: 4082FFE8  bne 0x821a7e78
	if !ctx.cr[0].eq {
	pc = 0x821A7E78; continue 'dispatch;
	}
	// 821A7E94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A7E98: 409A0014  bne cr6, 0x821a7eac
	if !ctx.cr[6].eq {
	pc = 0x821A7EAC; continue 'dispatch;
	}
	// 821A7E9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7EA0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7EA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A7EA8: 4E800421  bctrl
	ctx.lr = 0x821A7EAC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A7EAC => {
    //   block [0x821A7EAC..0x821A7EB0)
	// 821A7EAC: 92510054  stw r18, 0x54(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(84 as u32), ctx.r[18].u32 ) };
	pc = 0x821A7EB0; continue 'dispatch;
            }
            0x821A7EB0 => {
    //   block [0x821A7EB0..0x821A7EC4)
	// 821A7EB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7EB8: 91710054  stw r11, 0x54(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821A7EBC: 419A0024  beq cr6, 0x821a7ee0
	if ctx.cr[6].eq {
	pc = 0x821A7EE0; continue 'dispatch;
	}
	// 821A7EC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x821A7EC4; continue 'dispatch;
            }
            0x821A7EC4 => {
    //   block [0x821A7EC4..0x821A7EE0)
	// 821A7EC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821A7EC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A7ECC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821A7ED0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A7ED4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821A7ED8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A7EDC: 4082FFE8  bne 0x821a7ec4
	if !ctx.cr[0].eq {
	pc = 0x821A7EC4; continue 'dispatch;
	}
	pc = 0x821A7EE0; continue 'dispatch;
            }
            0x821A7EE0 => {
    //   block [0x821A7EE0..0x821A7EF4)
	// 821A7EE0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A7EE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7EE8: 419A0064  beq cr6, 0x821a7f4c
	if ctx.cr[6].eq {
	pc = 0x821A7F4C; continue 'dispatch;
	}
	// 821A7EEC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A7EF0: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x821A7EF4; continue 'dispatch;
            }
            0x821A7EF4 => {
    //   block [0x821A7EF4..0x821A7F2C)
	// 821A7EF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821A7EF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A7EFC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821A7F00: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A7F04: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821A7F08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A7F0C: 4082FFE8  bne 0x821a7ef4
	if !ctx.cr[0].eq {
	pc = 0x821A7EF4; continue 'dispatch;
	}
	// 821A7F10: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821A7F14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A7F18: 409A0014  bne cr6, 0x821a7f2c
	if !ctx.cr[6].eq {
	pc = 0x821A7F2C; continue 'dispatch;
	}
	// 821A7F1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7F20: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7F24: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A7F28: 4E800421  bctrl
	ctx.lr = 0x821A7F2C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A7F2C => {
    //   block [0x821A7F2C..0x821A7F34)
	// 821A7F2C: 92410058  stw r18, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[18].u32 ) };
	// 821A7F30: 4800001C  b 0x821a7f4c
	pc = 0x821A7F4C; continue 'dispatch;
            }
            0x821A7F34 => {
    //   block [0x821A7F34..0x821A7F4C)
	// 821A7F34: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821A7F38: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7F3C: 480B7C25  bl 0x8225fb60
	ctx.lr = 0x821A7F40;
	sub_8225FB60(ctx, base);
	// 821A7F40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A7F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A7F48: 483BAC91  bl 0x82562bd8
	ctx.lr = 0x821A7F4C;
	sub_82562BD8(ctx, base);
	pc = 0x821A7F4C; continue 'dispatch;
            }
            0x821A7F4C => {
    //   block [0x821A7F4C..0x821A7F50)
	// 821A7F4C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x821A7F50; continue 'dispatch;
            }
            0x821A7F50 => {
    //   block [0x821A7F50..0x821A7F78)
	// 821A7F50: 566B063E  clrlwi r11, r19, 0x18
	ctx.r[11].u64 = ctx.r[19].u32 as u64 & 0x000000FFu64;
	// 821A7F54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7F58: 409A05D4  bne cr6, 0x821a852c
	if !ctx.cr[6].eq {
	pc = 0x821A852C; continue 'dispatch;
	}
	// 821A7F5C: 81710030  lwz r11, 0x30(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7F60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7F64: 419A0014  beq cr6, 0x821a7f78
	if ctx.cr[6].eq {
	pc = 0x821A7F78; continue 'dispatch;
	}
	// 821A7F68: 81510034  lwz r10, 0x34(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(52 as u32) ) } as u64;
	// 821A7F6C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821A7F70: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A7F74: 408205B8  bne 0x821a852c
	if !ctx.cr[0].eq {
	pc = 0x821A852C; continue 'dispatch;
	}
	pc = 0x821A7F78; continue 'dispatch;
            }
            0x821A7F78 => {
    //   block [0x821A7F78..0x821A7FD8)
	// 821A7F78: 8971003C  lbz r11, 0x3c(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[17].u32.wrapping_add(60 as u32) ) } as u64;
	// 821A7F7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7F80: 409A05AC  bne cr6, 0x821a852c
	if !ctx.cr[6].eq {
	pc = 0x821A852C; continue 'dispatch;
	}
	// 821A7F84: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7F88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7F8C: 409A05A0  bne cr6, 0x821a852c
	if !ctx.cr[6].eq {
	pc = 0x821A852C; continue 'dispatch;
	}
	// 821A7F90: 83F10004  lwz r31, 4(r17)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7F94: 7E5D9378  mr r29, r18
	ctx.r[29].u64 = ctx.r[18].u64;
	// 821A7F98: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A7F9C: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 821A7FA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A7FA4: 419A00A4  beq cr6, 0x821a8048
	if ctx.cr[6].eq {
	pc = 0x821A8048; continue 'dispatch;
	}
	// 821A7FA8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A7FAC: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 821A7FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7FB4: 419A0024  beq cr6, 0x821a7fd8
	if ctx.cr[6].eq {
	pc = 0x821A7FD8; continue 'dispatch;
	}
	// 821A7FB8: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821A7FBC: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A7FC0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821A7FC4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A7FC8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7FCC: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821A7FD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A7FD4: 48000078  b 0x821a804c
	pc = 0x821A804C; continue 'dispatch;
            }
            0x821A7FD8 => {
    //   block [0x821A7FD8..0x821A800C)
	// 821A7FD8: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 821A7FDC: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 821A7FE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821A7FE4: 481608CD  bl 0x823088b0
	ctx.lr = 0x821A7FE8;
	sub_823088B0(ctx, base);
	// 821A7FE8: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A7FEC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A7FF0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A7FF4: 419A0040  beq cr6, 0x821a8034
	if ctx.cr[6].eq {
	pc = 0x821A8034; continue 'dispatch;
	}
	// 821A7FF8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7FFC: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 821A8000: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A8004: 41990008  bgt cr6, 0x821a800c
	if ctx.cr[6].gt {
	pc = 0x821A800C; continue 'dispatch;
	}
	// 821A8008: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A800C; continue 'dispatch;
            }
            0x821A800C => {
    //   block [0x821A800C..0x821A8034)
	// 821A800C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A8010: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8014: 409A0020  bne cr6, 0x821a8034
	if !ctx.cr[6].eq {
	pc = 0x821A8034; continue 'dispatch;
	}
	// 821A8018: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A801C: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A8020: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A8024: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8028: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821A802C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A8030: 4800001C  b 0x821a804c
	pc = 0x821A804C; continue 'dispatch;
            }
            0x821A8034 => {
    //   block [0x821A8034..0x821A8048)
	// 821A8034: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821A8038: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A803C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821A8040: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A8044: 48000008  b 0x821a804c
	pc = 0x821A804C; continue 'dispatch;
            }
            0x821A8048 => {
    //   block [0x821A8048..0x821A804C)
	// 821A8048: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A804C; continue 'dispatch;
            }
            0x821A804C => {
    //   block [0x821A804C..0x821A809C)
	// 821A804C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A8050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8054: 419A01BC  beq cr6, 0x821a8210
	if ctx.cr[6].eq {
	pc = 0x821A8210; continue 'dispatch;
	}
	// 821A8058: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A805C: 7E5E9378  mr r30, r18
	ctx.r[30].u64 = ctx.r[18].u64;
	// 821A8060: 556A3FFE  rlwinm r10, r11, 7, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x01FFFFFFu64;
	// 821A8064: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A8068: 419A00A4  beq cr6, 0x821a810c
	if ctx.cr[6].eq {
	pc = 0x821A810C; continue 'dispatch;
	}
	// 821A806C: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A8070: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 821A8074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8078: 419A0024  beq cr6, 0x821a809c
	if ctx.cr[6].eq {
	pc = 0x821A809C; continue 'dispatch;
	}
	// 821A807C: 896B0019  lbz r11, 0x19(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 821A8080: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A8084: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821A8088: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A808C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8090: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A8094: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A8098: 48000078  b 0x821a8110
	pc = 0x821A8110; continue 'dispatch;
            }
            0x821A809C => {
    //   block [0x821A809C..0x821A80D0)
	// 821A809C: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 821A80A0: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 821A80A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821A80A8: 48160809  bl 0x823088b0
	ctx.lr = 0x821A80AC;
	sub_823088B0(ctx, base);
	// 821A80AC: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A80B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A80B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A80B8: 419A0040  beq cr6, 0x821a80f8
	if ctx.cr[6].eq {
	pc = 0x821A80F8; continue 'dispatch;
	}
	// 821A80BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A80C0: 2F0B0019  cmpwi cr6, r11, 0x19
	ctx.cr[6].compare_i32(ctx.r[11].s32, 25, &mut ctx.xer);
	// 821A80C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A80C8: 41990008  bgt cr6, 0x821a80d0
	if ctx.cr[6].gt {
	pc = 0x821A80D0; continue 'dispatch;
	}
	// 821A80CC: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A80D0; continue 'dispatch;
            }
            0x821A80D0 => {
    //   block [0x821A80D0..0x821A80F8)
	// 821A80D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A80D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A80D8: 409A0020  bne cr6, 0x821a80f8
	if !ctx.cr[6].eq {
	pc = 0x821A80F8; continue 'dispatch;
	}
	// 821A80DC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A80E0: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A80E4: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A80E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A80EC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A80F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A80F4: 4800001C  b 0x821a8110
	pc = 0x821A8110; continue 'dispatch;
            }
            0x821A80F8 => {
    //   block [0x821A80F8..0x821A810C)
	// 821A80F8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821A80FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8100: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A8104: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A8108: 48000008  b 0x821a8110
	pc = 0x821A8110; continue 'dispatch;
            }
            0x821A810C => {
    //   block [0x821A810C..0x821A8110)
	// 821A810C: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A8110; continue 'dispatch;
            }
            0x821A8110 => {
    //   block [0x821A8110..0x821A814C)
	// 821A8110: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A8114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8118: 419A00C8  beq cr6, 0x821a81e0
	if ctx.cr[6].eq {
	pc = 0x821A81E0; continue 'dispatch;
	}
	// 821A811C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A8120: 480C2DD9  bl 0x8226aef8
	ctx.lr = 0x821A8124;
	sub_8226AEF8(ctx, base);
	// 821A8124: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821A8128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A812C: 409A00B4  bne cr6, 0x821a81e0
	if !ctx.cr[6].eq {
	pc = 0x821A81E0; continue 'dispatch;
	}
	// 821A8130: 897E0018  lbz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A8134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8138: 419A0014  beq cr6, 0x821a814c
	if ctx.cr[6].eq {
	pc = 0x821A814C; continue 'dispatch;
	}
	// 821A813C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A8140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8144: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A8148: 409A0008  bne cr6, 0x821a8150
	if !ctx.cr[6].eq {
	pc = 0x821A8150; continue 'dispatch;
	}
	pc = 0x821A814C; continue 'dispatch;
            }
            0x821A814C => {
    //   block [0x821A814C..0x821A8150)
	// 821A814C: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A8150; continue 'dispatch;
            }
            0x821A8150 => {
    //   block [0x821A8150..0x821A8198)
	// 821A8150: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A8154: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 821A8158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A815C: 419A003C  beq cr6, 0x821a8198
	if ctx.cr[6].eq {
	pc = 0x821A8198; continue 'dispatch;
	}
	// 821A8160: 480770F9  bl 0x8221f258
	ctx.lr = 0x821A8164;
	sub_8221F258(ctx, base);
	// 821A8164: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A8168: 419A0068  beq cr6, 0x821a81d0
	if ctx.cr[6].eq {
	pc = 0x821A81D0; continue 'dispatch;
	}
	// 821A816C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A8170: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A8174: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 821A8178: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821A817C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821A8180: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 821A8184: 480DBAAD  bl 0x82283c30
	ctx.lr = 0x821A8188;
	sub_82283C30(ctx, base);
	// 821A8188: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A818C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 821A8190: 480CAEC9  bl 0x82273058
	ctx.lr = 0x821A8194;
	sub_82273058(ctx, base);
	// 821A8194: 4800007C  b 0x821a8210
	pc = 0x821A8210; continue 'dispatch;
            }
            0x821A8198 => {
    //   block [0x821A8198..0x821A81D0)
	// 821A8198: 480770C1  bl 0x8221f258
	ctx.lr = 0x821A819C;
	sub_8221F258(ctx, base);
	// 821A819C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A81A0: 419A0030  beq cr6, 0x821a81d0
	if ctx.cr[6].eq {
	pc = 0x821A81D0; continue 'dispatch;
	}
	// 821A81A4: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A81A8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A81AC: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 821A81B0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821A81B4: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821A81B8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 821A81BC: 480DBA75  bl 0x82283c30
	ctx.lr = 0x821A81C0;
	sub_82283C30(ctx, base);
	// 821A81C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A81C4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 821A81C8: 480CAE91  bl 0x82273058
	ctx.lr = 0x821A81CC;
	sub_82273058(ctx, base);
	// 821A81CC: 48000044  b 0x821a8210
	pc = 0x821A8210; continue 'dispatch;
            }
            0x821A81D0 => {
    //   block [0x821A81D0..0x821A81E0)
	// 821A81D0: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 821A81D4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 821A81D8: 480CAE81  bl 0x82273058
	ctx.lr = 0x821A81DC;
	sub_82273058(ctx, base);
	// 821A81DC: 48000034  b 0x821a8210
	pc = 0x821A8210; continue 'dispatch;
            }
            0x821A81E0 => {
    //   block [0x821A81E0..0x821A820C)
	// 821A81E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A81E4: 480C2D15  bl 0x8226aef8
	ctx.lr = 0x821A81E8;
	sub_8226AEF8(ctx, base);
	// 821A81E8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821A81EC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A81F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A81F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A81F8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821A81FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A8200: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821A8204: 409A0008  bne cr6, 0x821a820c
	if !ctx.cr[6].eq {
	pc = 0x821A820C; continue 'dispatch;
	}
	// 821A8208: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	pc = 0x821A820C; continue 'dispatch;
            }
            0x821A820C => {
    //   block [0x821A820C..0x821A8210)
	// 821A820C: 48019DA5  bl 0x821c1fb0
	ctx.lr = 0x821A8210;
	sub_821C1FB0(ctx, base);
	pc = 0x821A8210; continue 'dispatch;
            }
            0x821A8210 => {
    //   block [0x821A8210..0x821A8278)
	// 821A8210: 80770000  lwz r3, 0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A8214: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A8218: 419A0314  beq cr6, 0x821a852c
	if ctx.cr[6].eq {
	pc = 0x821A852C; continue 'dispatch;
	}
	// 821A821C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A8220: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821A8224: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A8228: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A822C: 4E800421  bctrl
	ctx.lr = 0x821A8230;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A8230: 7E5E9378  mr r30, r18
	ctx.r[30].u64 = ctx.r[18].u64;
	// 821A8234: 83F10004  lwz r31, 4(r17)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8238: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A823C: 5528D7FE  rlwinm r8, r9, 0x1a, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 821A8240: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A8244: 419A00A4  beq cr6, 0x821a82e8
	if ctx.cr[6].eq {
	pc = 0x821A82E8; continue 'dispatch;
	}
	// 821A8248: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A824C: 92C10068  stw r22, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[22].u32 ) };
	// 821A8250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8254: 419A0024  beq cr6, 0x821a8278
	if ctx.cr[6].eq {
	pc = 0x821A8278; continue 'dispatch;
	}
	// 821A8258: 896B0006  lbz r11, 6(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 821A825C: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821A8260: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821A8264: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A8268: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A826C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A8270: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A8274: 48000078  b 0x821a82ec
	pc = 0x821A82EC; continue 'dispatch;
            }
            0x821A8278 => {
    //   block [0x821A8278..0x821A82AC)
	// 821A8278: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 821A827C: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 821A8280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821A8284: 4816062D  bl 0x823088b0
	ctx.lr = 0x821A8288;
	sub_823088B0(ctx, base);
	// 821A8288: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821A828C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A8290: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A8294: 419A0040  beq cr6, 0x821a82d4
	if ctx.cr[6].eq {
	pc = 0x821A82D4; continue 'dispatch;
	}
	// 821A8298: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A829C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821A82A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A82A4: 41990008  bgt cr6, 0x821a82ac
	if ctx.cr[6].gt {
	pc = 0x821A82AC; continue 'dispatch;
	}
	// 821A82A8: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A82AC; continue 'dispatch;
            }
            0x821A82AC => {
    //   block [0x821A82AC..0x821A82D4)
	// 821A82AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A82B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A82B4: 409A0020  bne cr6, 0x821a82d4
	if !ctx.cr[6].eq {
	pc = 0x821A82D4; continue 'dispatch;
	}
	// 821A82B8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A82BC: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A82C0: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A82C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A82C8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A82CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A82D0: 4800001C  b 0x821a82ec
	pc = 0x821A82EC; continue 'dispatch;
            }
            0x821A82D4 => {
    //   block [0x821A82D4..0x821A82E8)
	// 821A82D4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821A82D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A82DC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A82E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A82E4: 48000008  b 0x821a82ec
	pc = 0x821A82EC; continue 'dispatch;
            }
            0x821A82E8 => {
    //   block [0x821A82E8..0x821A82EC)
	// 821A82E8: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A82EC; continue 'dispatch;
            }
            0x821A82EC => {
    //   block [0x821A82EC..0x821A8318)
	// 821A82EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A82F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A82F4: 419A0238  beq cr6, 0x821a852c
	if ctx.cr[6].eq {
	pc = 0x821A852C; continue 'dispatch;
	}
	// 821A82F8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821A82FC: 48076F5D  bl 0x8221f258
	ctx.lr = 0x821A8300;
	sub_8221F258(ctx, base);
	// 821A8300: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A8304: 419A0014  beq cr6, 0x821a8318
	if ctx.cr[6].eq {
	pc = 0x821A8318; continue 'dispatch;
	}
	// 821A8308: C035F92C  lfs f1, -0x6d4(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-1748 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A830C: 480E3835  bl 0x8228bb40
	ctx.lr = 0x821A8310;
	sub_8228BB40(ctx, base);
	// 821A8310: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821A8314: 48000008  b 0x821a831c
	pc = 0x821A831C; continue 'dispatch;
            }
            0x821A8318 => {
    //   block [0x821A8318..0x821A831C)
	// 821A8318: 7E5C9378  mr r28, r18
	ctx.r[28].u64 = ctx.r[18].u64;
	pc = 0x821A831C; continue 'dispatch;
            }
            0x821A831C => {
    //   block [0x821A831C..0x821A833C)
	// 821A831C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821A8320: 48076F39  bl 0x8221f258
	ctx.lr = 0x821A8324;
	sub_8221F258(ctx, base);
	// 821A8324: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A8328: 419A0014  beq cr6, 0x821a833c
	if ctx.cr[6].eq {
	pc = 0x821A833C; continue 'dispatch;
	}
	// 821A832C: C035F92C  lfs f1, -0x6d4(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-1748 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A8330: 48081409  bl 0x82229738
	ctx.lr = 0x821A8334;
	sub_82229738(ctx, base);
	// 821A8334: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A8338: 48000008  b 0x821a8340
	pc = 0x821A8340; continue 'dispatch;
            }
            0x821A833C => {
    //   block [0x821A833C..0x821A8340)
	// 821A833C: 7E5D9378  mr r29, r18
	ctx.r[29].u64 = ctx.r[18].u64;
	pc = 0x821A8340; continue 'dispatch;
            }
            0x821A8340 => {
    //   block [0x821A8340..0x821A8398)
	// 821A8340: 81710058  lwz r11, 0x58(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A8344: 3BF10058  addi r31, r17, 0x58
	ctx.r[31].s64 = ctx.r[17].s64 + 88;
	// 821A8348: 80BE0094  lwz r5, 0x94(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A834C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8350: 409A005C  bne cr6, 0x821a83ac
	if !ctx.cr[6].eq {
	pc = 0x821A83AC; continue 'dispatch;
	}
	// 821A8354: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A8358: 485B9831  bl 0x82761b88
	ctx.lr = 0x821A835C;
	sub_82761B88(ctx, base);
	// 821A835C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A8360: 38C0003F  li r6, 0x3f
	ctx.r[6].s64 = 63;
	// 821A8364: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821A8368: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821A836C: 486C1B4D  bl 0x82869eb8
	ctx.lr = 0x821A8370;
	sub_82869EB8(ctx, base);
	// 821A8370: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 821A8374: 48076EE5  bl 0x8221f258
	ctx.lr = 0x821A8378;
	sub_8221F258(ctx, base);
	// 821A8378: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A837C: 419A001C  beq cr6, 0x821a8398
	if ctx.cr[6].eq {
	pc = 0x821A8398; continue 'dispatch;
	}
	// 821A8380: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821A8384: 80B70000  lwz r5, 0(r23)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A8388: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821A838C: 485B9A4D  bl 0x82761dd8
	ctx.lr = 0x821A8390;
	sub_82761DD8(ctx, base);
	// 821A8390: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A8394: 48000008  b 0x821a839c
	pc = 0x821A839C; continue 'dispatch;
            }
            0x821A8398 => {
    //   block [0x821A8398..0x821A839C)
	// 821A8398: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	pc = 0x821A839C; continue 'dispatch;
            }
            0x821A839C => {
    //   block [0x821A839C..0x821A83AC)
	// 821A839C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A83A0: 480CACB9  bl 0x82273058
	ctx.lr = 0x821A83A4;
	sub_82273058(ctx, base);
	// 821A83A4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A83A8: 4865F3A9  bl 0x82807750
	ctx.lr = 0x821A83AC;
	sub_82807750(ctx, base);
	pc = 0x821A83AC; continue 'dispatch;
            }
            0x821A83AC => {
    //   block [0x821A83AC..0x821A83CC)
	// 821A83AC: 80710060  lwz r3, 0x60(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(96 as u32) ) } as u64;
	// 821A83B0: 3BD10060  addi r30, r17, 0x60
	ctx.r[30].s64 = ctx.r[17].s64 + 96;
	// 821A83B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A83B8: 419A0014  beq cr6, 0x821a83cc
	if ctx.cr[6].eq {
	pc = 0x821A83CC; continue 'dispatch;
	}
	// 821A83BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A83C0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A83C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A83C8: 4E800421  bctrl
	ctx.lr = 0x821A83CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A83CC => {
    //   block [0x821A83CC..0x821A83F4)
	// 821A83CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 821A83D0: 48076E89  bl 0x8221f258
	ctx.lr = 0x821A83D4;
	sub_8221F258(ctx, base);
	// 821A83D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A83D8: 419A001C  beq cr6, 0x821a83f4
	if ctx.cr[6].eq {
	pc = 0x821A83F4; continue 'dispatch;
	}
	// 821A83DC: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A83E0: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821A83E4: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821A83E8: 485B9AF1  bl 0x82761ed8
	ctx.lr = 0x821A83EC;
	sub_82761ED8(ctx, base);
	// 821A83EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A83F0: 48000008  b 0x821a83f8
	pc = 0x821A83F8; continue 'dispatch;
            }
            0x821A83F4 => {
    //   block [0x821A83F4..0x821A83F8)
	// 821A83F4: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	pc = 0x821A83F8; continue 'dispatch;
            }
            0x821A83F8 => {
    //   block [0x821A83F8..0x821A8454)
	// 821A83F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A83FC: 480CAC5D  bl 0x82273058
	ctx.lr = 0x821A8400;
	sub_82273058(ctx, base);
	// 821A8400: 83F10054  lwz r31, 0x54(r17)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A8404: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A8408: 409A0108  bne cr6, 0x821a8510
	if !ctx.cr[6].eq {
	pc = 0x821A8510; continue 'dispatch;
	}
	// 821A840C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 821A8410: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A8414: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 821A8418: 3900001F  li r8, 0x1f
	ctx.r[8].s64 = 31;
	// 821A841C: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 821A8420: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821A8424: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821A8428: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 821A842C: 483BAC8D  bl 0x825630b8
	ctx.lr = 0x821A8430;
	sub_825630B8(ctx, base);
	// 821A8430: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A8434: 81710054  lwz r11, 0x54(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A8438: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A843C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A8440: 419A007C  beq cr6, 0x821a84bc
	if ctx.cr[6].eq {
	pc = 0x821A84BC; continue 'dispatch;
	}
	// 821A8444: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821A8448: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A844C: 419A0040  beq cr6, 0x821a848c
	if ctx.cr[6].eq {
	pc = 0x821A848C; continue 'dispatch;
	}
	// 821A8450: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821A8454; continue 'dispatch;
            }
            0x821A8454 => {
    //   block [0x821A8454..0x821A8488)
	// 821A8454: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821A8458: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A845C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821A8460: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A8464: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821A8468: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A846C: 4082FFE8  bne 0x821a8454
	if !ctx.cr[0].eq {
	pc = 0x821A8454; continue 'dispatch;
	}
	// 821A8470: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A8474: 409A0014  bne cr6, 0x821a8488
	if !ctx.cr[6].eq {
	pc = 0x821A8488; continue 'dispatch;
	}
	// 821A8478: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A847C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8480: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A8484: 4E800421  bctrl
	ctx.lr = 0x821A8488;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A8488 => {
    //   block [0x821A8488..0x821A848C)
	// 821A8488: 92510054  stw r18, 0x54(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(84 as u32), ctx.r[18].u32 ) };
	pc = 0x821A848C; continue 'dispatch;
            }
            0x821A848C => {
    //   block [0x821A848C..0x821A84A0)
	// 821A848C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A8490: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8494: 91710054  stw r11, 0x54(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821A8498: 419A0024  beq cr6, 0x821a84bc
	if ctx.cr[6].eq {
	pc = 0x821A84BC; continue 'dispatch;
	}
	// 821A849C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x821A84A0; continue 'dispatch;
            }
            0x821A84A0 => {
    //   block [0x821A84A0..0x821A84BC)
	// 821A84A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821A84A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A84A8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821A84AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A84B0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821A84B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A84B8: 4082FFE8  bne 0x821a84a0
	if !ctx.cr[0].eq {
	pc = 0x821A84A0; continue 'dispatch;
	}
	pc = 0x821A84BC; continue 'dispatch;
            }
            0x821A84BC => {
    //   block [0x821A84BC..0x821A84D0)
	// 821A84BC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A84C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A84C4: 419A0064  beq cr6, 0x821a8528
	if ctx.cr[6].eq {
	pc = 0x821A8528; continue 'dispatch;
	}
	// 821A84C8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821A84CC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x821A84D0; continue 'dispatch;
            }
            0x821A84D0 => {
    //   block [0x821A84D0..0x821A8508)
	// 821A84D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821A84D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A84D8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821A84DC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A84E0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821A84E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821A84E8: 4082FFE8  bne 0x821a84d0
	if !ctx.cr[0].eq {
	pc = 0x821A84D0; continue 'dispatch;
	}
	// 821A84EC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821A84F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A84F4: 409A0014  bne cr6, 0x821a8508
	if !ctx.cr[6].eq {
	pc = 0x821A8508; continue 'dispatch;
	}
	// 821A84F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A84FC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8500: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A8504: 4E800421  bctrl
	ctx.lr = 0x821A8508;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A8508 => {
    //   block [0x821A8508..0x821A8510)
	// 821A8508: 9241005C  stw r18, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[18].u32 ) };
	// 821A850C: 4800001C  b 0x821a8528
	pc = 0x821A8528; continue 'dispatch;
            }
            0x821A8510 => {
    //   block [0x821A8510..0x821A8528)
	// 821A8510: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821A8514: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A8518: 480B7649  bl 0x8225fb60
	ctx.lr = 0x821A851C;
	sub_8225FB60(ctx, base);
	// 821A851C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A8520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A8524: 483BA6B5  bl 0x82562bd8
	ctx.lr = 0x821A8528;
	sub_82562BD8(ctx, base);
	pc = 0x821A8528; continue 'dispatch;
            }
            0x821A8528 => {
    //   block [0x821A8528..0x821A852C)
	// 821A8528: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x821A852C; continue 'dispatch;
            }
            0x821A852C => {
    //   block [0x821A852C..0x821A8550)
	// 821A852C: 81710060  lwz r11, 0x60(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(96 as u32) ) } as u64;
	// 821A8530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8534: 409A001C  bne cr6, 0x821a8550
	if !ctx.cr[6].eq {
	pc = 0x821A8550; continue 'dispatch;
	}
	// 821A8538: 80910054  lwz r4, 0x54(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A853C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A8540: 419A0010  beq cr6, 0x821a8550
	if ctx.cr[6].eq {
	pc = 0x821A8550; continue 'dispatch;
	}
	// 821A8544: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A8548: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 821A854C: 483BADFD  bl 0x82563348
	ctx.lr = 0x821A8550;
	sub_82563348(ctx, base);
	pc = 0x821A8550; continue 'dispatch;
            }
            0x821A8550 => {
    //   block [0x821A8550..0x821A8564)
	// 821A8550: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 821A8554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8558: 419A000C  beq cr6, 0x821a8564
	if ctx.cr[6].eq {
	pc = 0x821A8564; continue 'dispatch;
	}
	// 821A855C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821A8560: 486C1301  bl 0x82869860
	ctx.lr = 0x821A8564;
	sub_82869860(ctx, base);
	pc = 0x821A8564; continue 'dispatch;
            }
            0x821A8564 => {
    //   block [0x821A8564..0x821A8574)
	// 821A8564: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 821A8568: CBC1FF70  lfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821A856C: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 821A8570: 48B00EBC  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A8578 size=1548
    let mut pc: u32 = 0x821A8578;
    'dispatch: loop {
        match pc {
            0x821A8578 => {
    //   block [0x821A8578..0x821A8B84)
	// 821A8578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A857C: 48B00E89  bl 0x82ca9404
	ctx.lr = 0x821A8580;
	sub_82CA93D0(ctx, base);
	// 821A8580: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A8B88 size=144
    let mut pc: u32 = 0x821A8B88;
    'dispatch: loop {
        match pc {
            0x821A8B88 => {
    //   block [0x821A8B88..0x821A8C18)
	// 821A8B88: 548B463E  srwi r11, r4, 0x18
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shr(24);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A8B8C: 5489C63E  rlwinm r9, r4, 0x18, 0x18, 0x1f
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 821A8B90: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821A8B94: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A8B98: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 821A8B9C: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A8BA0: 548A863E  rlwinm r10, r4, 0x10, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	// 821A8BA4: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 821A8BA8: F941FFF8  std r10, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[10].u64 ) };
	// 821A8BAC: C981FFF8  lfd f12, -8(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A8BB0: F961FFF8  std r11, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u64 ) };
	// 821A8BB4: C961FFF8  lfd f11, -8(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A8BB8: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 821A8BBC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821A8BC0: FD40069C  fcfid f10, f0
	ctx.f[10].f64 = (ctx.f[0].s64 as f64);
	// 821A8BC4: C00A16C8  lfs f0, 0x16c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8BC8: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821A8BCC: 3980000F  li r12, 0xf
	ctx.r[12].s64 = 15;
	// 821A8BD0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A8BD4: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821A8BD8: 798C0F86  sldi r12, r12, 0x21
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(33);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 821A8BDC: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821A8BE0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821A8BE4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A8BE8: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A8BEC: D16328E8  stfs f11, 0x28e8(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10472 as u32), tmp.u32 ) };
	// 821A8BF0: ED6A0032  fmuls f11, f10, f0
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A8BF4: D16328E4  stfs f11, 0x28e4(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10468 as u32), tmp.u32 ) };
	// 821A8BF8: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A8BFC: D18328E0  stfs f12, 0x28e0(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10464 as u32), tmp.u32 ) };
	// 821A8C00: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A8C04: D00328EC  stfs f0, 0x28ec(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10476 as u32), tmp.u32 ) };
	// 821A8C08: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821A8C0C: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821A8C10: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821A8C14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A8C18 size=164
    let mut pc: u32 = 0x821A8C18;
    'dispatch: loop {
        match pc {
            0x821A8C18 => {
    //   block [0x821A8C18..0x821A8C4C)
	// 821A8C18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A8C1C: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 821A8C20: C181001C  lfs f12, 0x1c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A8C24: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 821A8C28: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8C2C: C1AAFF8C  lfs f13, -0x74(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A8C30: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A8C34: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821A8C38: 409A0014  bne cr6, 0x821a8c4c
	if !ctx.cr[6].eq {
	pc = 0x821A8C4C; continue 'dispatch;
	}
	// 821A8C3C: C1832A54  lfs f12, 0x2a54(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10836 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A8C40: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A8C44: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 821A8C48: 419A0008  beq cr6, 0x821a8c50
	if ctx.cr[6].eq {
	pc = 0x821A8C50; continue 'dispatch;
	}
	pc = 0x821A8C4C; continue 'dispatch;
            }
            0x821A8C4C => {
    //   block [0x821A8C4C..0x821A8C50)
	// 821A8C4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x821A8C50; continue 'dispatch;
            }
            0x821A8C50 => {
    //   block [0x821A8C50..0x821A8C74)
	// 821A8C50: 81632948  lwz r11, 0x2948(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10568 as u32) ) } as u64;
	// 821A8C54: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821A8C58: 514B5D28  rlwimi r11, r10, 0xb, 0x14, 0x14
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(11) as u64) & 0x0000000000000800) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFF7FF);
	// 821A8C5C: 91632948  stw r11, 0x2948(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10568 as u32), ctx.r[11].u32 ) };
	// 821A8C60: 409A0014  bne cr6, 0x821a8c74
	if !ctx.cr[6].eq {
	pc = 0x821A8C74; continue 'dispatch;
	}
	// 821A8C64: C1832A5C  lfs f12, 0x2a5c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10844 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A8C68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A8C6C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 821A8C70: 419A0008  beq cr6, 0x821a8c78
	if ctx.cr[6].eq {
	pc = 0x821A8C78; continue 'dispatch;
	}
	pc = 0x821A8C74; continue 'dispatch;
            }
            0x821A8C74 => {
    //   block [0x821A8C74..0x821A8C78)
	// 821A8C74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x821A8C78; continue 'dispatch;
            }
            0x821A8C78 => {
    //   block [0x821A8C78..0x821A8CBC)
	// 821A8C78: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821A8C7C: D1A32A50  stfs f13, 0x2a50(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10832 as u32), tmp.u32 ) };
	// 821A8C80: 514B64E6  rlwimi r11, r10, 0xc, 0x13, 0x13
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(12) as u64) & 0x0000000000001000) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFEFFF);
	// 821A8C84: D1A32A58  stfs f13, 0x2a58(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10840 as u32), tmp.u32 ) };
	// 821A8C88: 798C6FE6  rldicr r12, r12, 0x2d, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(45) & 0xFFFFFFFFFFFFFFFF;
	// 821A8C8C: 91632948  stw r11, 0x2948(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10568 as u32), ctx.r[11].u32 ) };
	// 821A8C90: E9630020  ld r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	// 821A8C94: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821A8C98: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821A8C9C: F9630020  std r11, 0x20(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 821A8CA0: 798C5FE6  rldicr r12, r12, 0x2b, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(43) & 0xFFFFFFFFFFFFFFFF;
	// 821A8CA4: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821A8CA8: F9630020  std r11, 0x20(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 821A8CAC: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821A8CB0: 616B0040  ori r11, r11, 0x40
	ctx.r[11].u64 = ctx.r[11].u64 | 64;
	// 821A8CB4: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821A8CB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A8CC0 size=8
    let mut pc: u32 = 0x821A8CC0;
    'dispatch: loop {
        match pc {
            0x821A8CC0 => {
    //   block [0x821A8CC0..0x821A8CC8)
	// 821A8CC0: 49110EB4  b 0x832b9b74
	sub_832B9B74(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A8CC8 size=528
    let mut pc: u32 = 0x821A8CC8;
    'dispatch: loop {
        match pc {
            0x821A8CC8 => {
    //   block [0x821A8CC8..0x821A8CE4)
	// 821A8CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A8CCC: 48B00731  bl 0x82ca93fc
	ctx.lr = 0x821A8CD0;
	sub_82CA93D0(ctx, base);
	// 821A8CD0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A8CD4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821A8CD8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821A8CDC: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 821A8CE0: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	pc = 0x821A8CE4; continue 'dispatch;
            }
            0x821A8CE4 => {
    //   block [0x821A8CE4..0x821A8CF4)
	// 821A8CE4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A8CE8: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A8CEC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A8CF0: 419A0040  beq cr6, 0x821a8d30
	if ctx.cr[6].eq {
	pc = 0x821A8D30; continue 'dispatch;
	}
	pc = 0x821A8CF4; continue 'dispatch;
            }
            0x821A8CF4 => {
    //   block [0x821A8CF4..0x821A8D14)
	// 821A8CF4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A8CF8: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8CFC: 7F09F800  cmpw cr6, r9, r31
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[31].s32, &mut ctx.xer);
	// 821A8D00: 419A0014  beq cr6, 0x821a8d14
	if ctx.cr[6].eq {
	pc = 0x821A8D14; continue 'dispatch;
	}
	// 821A8D04: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821A8D08: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A8D0C: 409AFFE8  bne cr6, 0x821a8cf4
	if !ctx.cr[6].eq {
	pc = 0x821A8CF4; continue 'dispatch;
	}
	// 821A8D10: 48000020  b 0x821a8d30
	pc = 0x821A8D30; continue 'dispatch;
            }
            0x821A8D14 => {
    //   block [0x821A8D14..0x821A8D30)
	// 821A8D14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A8D18: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8D1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A8D20: 4E800421  bctrl
	ctx.lr = 0x821A8D24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A8D24: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 821A8D28: 409A0008  bne cr6, 0x821a8d30
	if !ctx.cr[6].eq {
	pc = 0x821A8D30; continue 'dispatch;
	}
	// 821A8D2C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
            }
            0x821A8D30 => {
    //   block [0x821A8D30..0x821A8D50)
	// 821A8D30: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821A8D34: 2F1F0004  cmpwi cr6, r31, 4
	ctx.cr[6].compare_i32(ctx.r[31].s32, 4, &mut ctx.xer);
	// 821A8D38: 4198FFAC  blt cr6, 0x821a8ce4
	if ctx.cr[6].lt {
	pc = 0x821A8CE4; continue 'dispatch;
	}
	// 821A8D3C: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 821A8D40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821A8D44: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 821A8D48: 3B2AFECC  addi r25, r10, -0x134
	ctx.r[25].s64 = ctx.r[10].s64 + -308;
	// 821A8D4C: 3B6B2D18  addi r27, r11, 0x2d18
	ctx.r[27].s64 = ctx.r[11].s64 + 11544;
	pc = 0x821A8D50; continue 'dispatch;
            }
            0x821A8D50 => {
    //   block [0x821A8D50..0x821A8D80)
	// 821A8D50: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821A8D54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821A8D58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A8D5C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 821A8D60: 4BFFFF61  bl 0x821a8cc0
	ctx.lr = 0x821A8D64;
	sub_821A8CC0(ctx, base);
	// 821A8D64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A8D68: 409A0024  bne cr6, 0x821a8d8c
	if !ctx.cr[6].eq {
	pc = 0x821A8D8C; continue 'dispatch;
	}
	// 821A8D6C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A8D70: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A8D74: 409A000C  bne cr6, 0x821a8d80
	if !ctx.cr[6].eq {
	pc = 0x821A8D80; continue 'dispatch;
	}
	// 821A8D78: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 821A8D7C: 48000010  b 0x821a8d8c
	pc = 0x821A8D8C; continue 'dispatch;
            }
            0x821A8D80 => {
    //   block [0x821A8D80..0x821A8D8C)
	// 821A8D80: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 821A8D84: 409A0008  bne cr6, 0x821a8d8c
	if !ctx.cr[6].eq {
	pc = 0x821A8D8C; continue 'dispatch;
	}
	// 821A8D88: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	pc = 0x821A8D8C; continue 'dispatch;
            }
            0x821A8D8C => {
    //   block [0x821A8D8C..0x821A8D9C)
	// 821A8D8C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A8D90: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A8D94: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A8D98: 419A0060  beq cr6, 0x821a8df8
	if ctx.cr[6].eq {
	pc = 0x821A8DF8; continue 'dispatch;
	}
	pc = 0x821A8D9C; continue 'dispatch;
            }
            0x821A8D9C => {
    //   block [0x821A8D9C..0x821A8DBC)
	// 821A8D9C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A8DA0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8DA4: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 821A8DA8: 419A0014  beq cr6, 0x821a8dbc
	if ctx.cr[6].eq {
	pc = 0x821A8DBC; continue 'dispatch;
	}
	// 821A8DAC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821A8DB0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A8DB4: 409AFFE8  bne cr6, 0x821a8d9c
	if !ctx.cr[6].eq {
	pc = 0x821A8D9C; continue 'dispatch;
	}
	// 821A8DB8: 48000040  b 0x821a8df8
	pc = 0x821A8DF8; continue 'dispatch;
            }
            0x821A8DBC => {
    //   block [0x821A8DBC..0x821A8DF8)
	// 821A8DBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A8DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A8DC4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8DC8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A8DCC: 4E800421  bctrl
	ctx.lr = 0x821A8DD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A8DD0: 7F03E800  cmpw cr6, r3, r29
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[29].s32, &mut ctx.xer);
	// 821A8DD4: 419A0024  beq cr6, 0x821a8df8
	if ctx.cr[6].eq {
	pc = 0x821A8DF8; continue 'dispatch;
	}
	// 821A8DD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A8DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A8DE0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8DE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A8DE8: 4E800421  bctrl
	ctx.lr = 0x821A8DEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A8DEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A8DF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821A8DF4: 4885646D  bl 0x829ff260
	ctx.lr = 0x821A8DF8;
	sub_829FF260(ctx, base);
            }
            0x821A8DF8 => {
    //   block [0x821A8DF8..0x821A8E08)
	// 821A8DF8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A8DFC: 813C000C  lwz r9, 0xc(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A8E00: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A8E04: 419A0020  beq cr6, 0x821a8e24
	if ctx.cr[6].eq {
	pc = 0x821A8E24; continue 'dispatch;
	}
	pc = 0x821A8E08; continue 'dispatch;
            }
            0x821A8E08 => {
    //   block [0x821A8E08..0x821A8E24)
	// 821A8E08: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A8E0C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8E10: 7F08F000  cmpw cr6, r8, r30
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[30].s32, &mut ctx.xer);
	// 821A8E14: 419A0014  beq cr6, 0x821a8e28
	if ctx.cr[6].eq {
	pc = 0x821A8E28; continue 'dispatch;
	}
	// 821A8E18: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821A8E1C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A8E20: 409AFFE8  bne cr6, 0x821a8e08
	if !ctx.cr[6].eq {
	pc = 0x821A8E08; continue 'dispatch;
	}
	pc = 0x821A8E24; continue 'dispatch;
            }
            0x821A8E24 => {
    //   block [0x821A8E24..0x821A8E28)
	// 821A8E24: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x821A8E28; continue 'dispatch;
            }
            0x821A8E28 => {
    //   block [0x821A8E28..0x821A8E78)
	// 821A8E28: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821A8E2C: 419A0098  beq cr6, 0x821a8ec4
	if ctx.cr[6].eq {
	pc = 0x821A8EC4; continue 'dispatch;
	}
	// 821A8E30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A8E34: 409A0090  bne cr6, 0x821a8ec4
	if !ctx.cr[6].eq {
	pc = 0x821A8EC4; continue 'dispatch;
	}
	// 821A8E38: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 821A8E3C: 419A0088  beq cr6, 0x821a8ec4
	if ctx.cr[6].eq {
	pc = 0x821A8EC4; continue 'dispatch;
	}
	// 821A8E40: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 821A8E44: 409A0080  bne cr6, 0x821a8ec4
	if !ctx.cr[6].eq {
	pc = 0x821A8EC4; continue 'dispatch;
	}
	// 821A8E48: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 821A8E4C: 4807640D  bl 0x8221f258
	ctx.lr = 0x821A8E50;
	sub_8221F258(ctx, base);
	// 821A8E50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A8E54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A8E58: 419A0060  beq cr6, 0x821a8eb8
	if ctx.cr[6].eq {
	pc = 0x821A8EB8; continue 'dispatch;
	}
	// 821A8E5C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821A8E60: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 821A8E64: 933F0000  stw r25, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 821A8E68: 480763F1  bl 0x8221f258
	ctx.lr = 0x821A8E6C;
	sub_8221F258(ctx, base);
	// 821A8E6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A8E70: 419A0008  beq cr6, 0x821a8e78
	if ctx.cr[6].eq {
	pc = 0x821A8E78; continue 'dispatch;
	}
	// 821A8E74: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x821A8E78; continue 'dispatch;
            }
            0x821A8E78 => {
    //   block [0x821A8E78..0x821A8E84)
	// 821A8E78: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A8E7C: 41820008  beq 0x821a8e84
	if ctx.cr[0].eq {
	pc = 0x821A8E84; continue 'dispatch;
	}
	// 821A8E80: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x821A8E84; continue 'dispatch;
            }
            0x821A8E84 => {
    //   block [0x821A8E84..0x821A8EB8)
	// 821A8E84: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 821A8E88: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 821A8E8C: 935F0010  stw r26, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 821A8E90: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 821A8E94: 939F0014  stw r28, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 821A8E98: 482D83A9  bl 0x82481240
	ctx.lr = 0x821A8E9C;
	sub_82481240(ctx, base);
	// 821A8E9C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 821A8EA0: 480763B9  bl 0x8221f258
	ctx.lr = 0x821A8EA4;
	sub_8221F258(ctx, base);
	// 821A8EA4: 907F005C  stw r3, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 821A8EA8: B3430000  sth r26, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[26].u16 ) };
	// 821A8EAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A8EB0: B3430002  sth r26, 2(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[26].u16 ) };
	// 821A8EB4: 48000008  b 0x821a8ebc
	pc = 0x821A8EBC; continue 'dispatch;
            }
            0x821A8EB8 => {
    //   block [0x821A8EB8..0x821A8EBC)
	// 821A8EB8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	pc = 0x821A8EBC; continue 'dispatch;
            }
            0x821A8EBC => {
    //   block [0x821A8EBC..0x821A8EC4)
	// 821A8EBC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821A8EC0: 48856249  bl 0x829ff108
	ctx.lr = 0x821A8EC4;
	sub_829FF108(ctx, base);
	pc = 0x821A8EC4; continue 'dispatch;
            }
            0x821A8EC4 => {
    //   block [0x821A8EC4..0x821A8ED8)
	// 821A8EC4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821A8EC8: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 821A8ECC: 4198FE84  blt cr6, 0x821a8d50
	if ctx.cr[6].lt {
	pc = 0x821A8D50; continue 'dispatch;
	}
	// 821A8ED0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821A8ED4: 48B00578  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A8ED8 size=228
    let mut pc: u32 = 0x821A8ED8;
    'dispatch: loop {
        match pc {
            0x821A8ED8 => {
    //   block [0x821A8ED8..0x821A8FBC)
	// 821A8ED8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8EDC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 821A8EE0: 39230020  addi r9, r3, 0x20
	ctx.r[9].s64 = ctx.r[3].s64 + 32;
	// 821A8EE4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A8FC0 size=328
    let mut pc: u32 = 0x821A8FC0;
    'dispatch: loop {
        match pc {
            0x821A8FC0 => {
    //   block [0x821A8FC0..0x821A9034)
	// 821A8FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A8FC4: 48B00449  bl 0x82ca940c
	ctx.lr = 0x821A8FC8;
	sub_82CA93D0(ctx, base);
	// 821A8FC8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821A8FCC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A8FD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A8FD4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821A8FD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821A8FDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A8FE0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A8FE4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8FE8: 516A083C  rlwimi r10, r11, 1, 0, 0x1e
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[10].u64 & 0xFFFFFFFF00000001);
	// 821A8FEC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821A8FF0: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A8FF4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8FF8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821A8FFC: 4E800421  bctrl
	ctx.lr = 0x821A9000;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A9000: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 821A9004: 409A00F8  bne cr6, 0x821a90fc
	if !ctx.cr[6].eq {
	pc = 0x821A90FC; continue 'dispatch;
	}
	// 821A9008: C81F02D8  lfd f0, 0x2d8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) };
	// 821A900C: 397F02D0  addi r11, r31, 0x2d0
	ctx.r[11].s64 = ctx.r[31].s64 + 720;
	// 821A9010: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821A9014: 40990020  ble cr6, 0x821a9034
	if !ctx.cr[6].gt {
	pc = 0x821A9034; continue 'dispatch;
	}
	// 821A9018: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821A901C: D80B0000  stfd f0, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.f[0].u64 ) };
	// 821A9020: DBEB0008  stfd f31, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.f[31].u64 ) };
	// 821A9024: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A9028: C009D5C8  lfs f0, -0x2a38(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A902C: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A9030: 48000008  b 0x821a9038
	pc = 0x821A9038; continue 'dispatch;
            }
            0x821A9034 => {
    //   block [0x821A9034..0x821A9038)
	// 821A9034: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821A9038; continue 'dispatch;
            }
            0x821A9038 => {
    //   block [0x821A9038..0x821A9050)
	// 821A9038: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821A903C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9040: 419A0010  beq cr6, 0x821a9050
	if ctx.cr[6].eq {
	pc = 0x821A9050; continue 'dispatch;
	}
	// 821A9044: 389F01D0  addi r4, r31, 0x1d0
	ctx.r[4].s64 = ctx.r[31].s64 + 464;
	// 821A9048: 387F0250  addi r3, r31, 0x250
	ctx.r[3].s64 = ctx.r[31].s64 + 592;
	// 821A904C: 4BFFFE8D  bl 0x821a8ed8
	ctx.lr = 0x821A9050;
	sub_821A8ED8(ctx, base);
	pc = 0x821A9050; continue 'dispatch;
            }
            0x821A9050 => {
    //   block [0x821A9050..0x821A90C4)
	// 821A9050: 897E0065  lbz r11, 0x65(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(101 as u32) ) } as u64;
	// 821A9054: 3BBF01D0  addi r29, r31, 0x1d0
	ctx.r[29].s64 = ctx.r[31].s64 + 464;
	// 821A9058: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A905C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A9060: 997F00A0  stb r11, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[11].u8 ) };
	// 821A9064: C01E0060  lfs f0, 0x60(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A9068: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A906C: 895E0064  lbz r10, 0x64(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 821A9070: 995F00A1  stb r10, 0xa1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(161 as u32), ctx.r[10].u8 ) };
	// 821A9074: 893E0066  lbz r9, 0x66(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(102 as u32) ) } as u64;
	// 821A9078: 993F00A2  stb r9, 0xa2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(162 as u32), ctx.r[9].u8 ) };
	// 821A907C: C1BE0054  lfs f13, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A9080: D1BF00A8  stfs f13, 0xa8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821A9084: C19E0058  lfs f12, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A9088: D19F00AC  stfs f12, 0xac(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821A908C: C17E005C  lfs f11, 0x5c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A9090: D17F00B0  stfs f11, 0xb0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A9094: 811E0074  lwz r8, 0x74(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 821A9098: 911F05D0  stw r8, 0x5d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1488 as u32), ctx.r[8].u32 ) };
	// 821A909C: 80FE0078  lwz r7, 0x78(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) } as u64;
	// 821A90A0: 90FF05D4  stw r7, 0x5d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1492 as u32), ctx.r[7].u32 ) };
	// 821A90A4: 80DE007C  lwz r6, 0x7c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 821A90A8: 90DF05D8  stw r6, 0x5d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1496 as u32), ctx.r[6].u32 ) };
	// 821A90AC: 4BFFFE2D  bl 0x821a8ed8
	ctx.lr = 0x821A90B0;
	sub_821A8ED8(ctx, base);
	// 821A90B0: 88BE0067  lbz r5, 0x67(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(103 as u32) ) } as u64;
	// 821A90B4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A90B8: 409A000C  bne cr6, 0x821a90c4
	if !ctx.cr[6].eq {
	pc = 0x821A90C4; continue 'dispatch;
	}
	// 821A90BC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821A90C0: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	pc = 0x821A90C4; continue 'dispatch;
            }
            0x821A90C4 => {
    //   block [0x821A90C4..0x821A90E0)
	// 821A90C4: 817F0254  lwz r11, 0x254(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 821A90C8: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821A90CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A90D0: 409A0010  bne cr6, 0x821a90e0
	if !ctx.cr[6].eq {
	pc = 0x821A90E0; continue 'dispatch;
	}
	// 821A90D4: 897E0067  lbz r11, 0x67(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(103 as u32) ) } as u64;
	// 821A90D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A90DC: 409A0010  bne cr6, 0x821a90ec
	if !ctx.cr[6].eq {
	pc = 0x821A90EC; continue 'dispatch;
	}
	pc = 0x821A90E0; continue 'dispatch;
            }
            0x821A90E0 => {
    //   block [0x821A90E0..0x821A90EC)
	// 821A90E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A90E4: 387F0250  addi r3, r31, 0x250
	ctx.r[3].s64 = ctx.r[31].s64 + 592;
	// 821A90E8: 4BFFFDF1  bl 0x821a8ed8
	ctx.lr = 0x821A90EC;
	sub_821A8ED8(ctx, base);
	pc = 0x821A90EC; continue 'dispatch;
            }
            0x821A90EC => {
    //   block [0x821A90EC..0x821A90FC)
	// 821A90EC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A90F0: 7D6A58F8  nor r10, r11, r11
	ctx.r[10].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 821A90F4: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821A90F8: 993F0048  stb r9, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[9].u8 ) };
	pc = 0x821A90FC; continue 'dispatch;
            }
            0x821A90FC => {
    //   block [0x821A90FC..0x821A9108)
	// 821A90FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A9100: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821A9104: 48B00358  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A9108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A9108 size=292
    let mut pc: u32 = 0x821A9108;
    'dispatch: loop {
        match pc {
            0x821A9108 => {
    //   block [0x821A9108..0x821A9138)
	// 821A9108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A910C: 48B002FD  bl 0x82ca9408
	ctx.lr = 0x821A9110;
	sub_82CA93D0(ctx, base);
	// 821A9110: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A9114: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A9118: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821A911C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821A9120: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 821A9124: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A9128: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 821A912C: 4198000C  blt cr6, 0x821a9138
	if ctx.cr[6].lt {
	pc = 0x821A9138; continue 'dispatch;
	}
	// 821A9130: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A9134: 48000008  b 0x821a913c
	pc = 0x821A913C; continue 'dispatch;
            }
            0x821A9138 => {
    //   block [0x821A9138..0x821A913C)
	// 821A9138: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821A913C; continue 'dispatch;
            }
            0x821A913C => {
    //   block [0x821A913C..0x821A9154)
	// 821A913C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A9140: 4198002C  blt cr6, 0x821a916c
	if ctx.cr[6].lt {
	pc = 0x821A916C; continue 'dispatch;
	}
	// 821A9144: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 821A9148: 4198000C  blt cr6, 0x821a9154
	if ctx.cr[6].lt {
	pc = 0x821A9154; continue 'dispatch;
	}
	// 821A914C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A9150: 48000008  b 0x821a9158
	pc = 0x821A9158; continue 'dispatch;
            }
            0x821A9154 => {
    //   block [0x821A9154..0x821A9158)
	// 821A9154: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821A9158; continue 'dispatch;
            }
            0x821A9158 => {
    //   block [0x821A9158..0x821A916C)
	// 821A9158: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A915C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A9160: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821A9164: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A9168: 41990008  bgt cr6, 0x821a9170
	if ctx.cr[6].gt {
	pc = 0x821A9170; continue 'dispatch;
	}
	pc = 0x821A916C; continue 'dispatch;
            }
            0x821A916C => {
    //   block [0x821A916C..0x821A9170)
	// 821A916C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821A9170; continue 'dispatch;
            }
            0x821A9170 => {
    //   block [0x821A9170..0x821A918C)
	// 821A9170: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A9174: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9178: 419A0034  beq cr6, 0x821a91ac
	if ctx.cr[6].eq {
	pc = 0x821A91AC; continue 'dispatch;
	}
	// 821A917C: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 821A9180: 4198000C  blt cr6, 0x821a918c
	if ctx.cr[6].lt {
	pc = 0x821A918C; continue 'dispatch;
	}
	// 821A9184: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A9188: 48000008  b 0x821a9190
	pc = 0x821A9190; continue 'dispatch;
            }
            0x821A918C => {
    //   block [0x821A918C..0x821A9190)
	// 821A918C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821A9190; continue 'dispatch;
            }
            0x821A9190 => {
    //   block [0x821A9190..0x821A91AC)
	// 821A9190: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821A9194: 7CABE850  subf r5, r11, r29
	ctx.r[5].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 821A9198: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A919C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A91A0: 4BFE5861  bl 0x8218ea00
	ctx.lr = 0x821A91A4;
	sub_8218EA00(ctx, base);
	// 821A91A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A91A8: 48B002B0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A91AC => {
    //   block [0x821A91AC..0x821A91DC)
	// 821A91AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A91B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A91B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A91B8: 48000079  bl 0x821a9230
	ctx.lr = 0x821A91BC;
	sub_821A9230(ctx, base);
	// 821A91BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821A91C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A91C4: 419A005C  beq cr6, 0x821a9220
	if ctx.cr[6].eq {
	pc = 0x821A9220; continue 'dispatch;
	}
	// 821A91C8: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A91CC: 2B040010  cmplwi cr6, r4, 0x10
	ctx.cr[6].compare_u32(ctx.r[4].u32, 16 as u32, &mut ctx.xer);
	// 821A91D0: 4198000C  blt cr6, 0x821a91dc
	if ctx.cr[6].lt {
	pc = 0x821A91DC; continue 'dispatch;
	}
	// 821A91D4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A91D8: 48000008  b 0x821a91e0
	pc = 0x821A91E0; continue 'dispatch;
            }
            0x821A91DC => {
    //   block [0x821A91DC..0x821A91E0)
	// 821A91DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x821A91E0; continue 'dispatch;
            }
            0x821A91E0 => {
    //   block [0x821A91E0..0x821A9214)
	// 821A91E0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821A91E4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821A91E8: 48B00D69  bl 0x82ca9f50
	ctx.lr = 0x821A91EC;
	sub_82CA9F50(ctx, base);
	// 821A91EC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A91F0: 939F0014  stw r28, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 821A91F4: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 821A91F8: 4198001C  blt cr6, 0x821a9214
	if ctx.cr[6].lt {
	pc = 0x821A9214; continue 'dispatch;
	}
	// 821A91FC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A9200: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A9204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A9208: 7D4BE1AE  stbx r10, r11, r28
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[10].u8) };
	// 821A920C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A9210: 48B00248  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A9214 => {
    //   block [0x821A9214..0x821A9220)
	// 821A9214: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821A9218: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A921C: 7D4BE1AE  stbx r10, r11, r28
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[10].u8) };
	pc = 0x821A9220; continue 'dispatch;
            }
            0x821A9220 => {
    //   block [0x821A9220..0x821A922C)
	// 821A9220: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A9224: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A9228: 48B00230  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A9230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A9230 size=220
    let mut pc: u32 = 0x821A9230;
    'dispatch: loop {
        match pc {
            0x821A9230 => {
    //   block [0x821A9230..0x821A9258)
	// 821A9230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A9234: 48B001D5  bl 0x82ca9408
	ctx.lr = 0x821A9238;
	sub_82CA93D0(ctx, base);
	// 821A9238: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A923C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821A9240: 3960FFFE  li r11, -2
	ctx.r[11].s64 = -2;
	// 821A9244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A9248: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821A924C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A9250: 40990008  ble cr6, 0x821a9258
	if !ctx.cr[6].gt {
	pc = 0x821A9258; continue 'dispatch;
	}
	// 821A9254: 48B2E7DD  bl 0x82cd7a30
	ctx.lr = 0x821A9258;
	sub_82CD7A30(ctx, base);
	pc = 0x821A9258; continue 'dispatch;
            }
            0x821A9258 => {
    //   block [0x821A9258..0x821A928C)
	// 821A9258: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A925C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A9260: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821A9264: 40980028  bge cr6, 0x821a928c
	if !ctx.cr[6].lt {
	pc = 0x821A928C; continue 'dispatch;
	}
	// 821A9268: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A926C: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A9270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A9274: 4800009D  bl 0x821a9310
	ctx.lr = 0x821A9278;
	sub_821A9310(ctx, base);
	// 821A9278: 7D7EE010  subfc r11, r30, r28
	ctx.xer.ca = ctx.r[28].u32 >= ctx.r[30].u32;
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 821A927C: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A9280: 554307FE  clrlwi r3, r10, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821A9284: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A9288: 48B001D0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A928C => {
    //   block [0x821A928C..0x821A92B0)
	// 821A928C: 57AA063E  clrlwi r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 821A9290: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A9294: 419A0040  beq cr6, 0x821a92d4
	if ctx.cr[6].eq {
	pc = 0x821A92D4; continue 'dispatch;
	}
	// 821A9298: 2B1E0010  cmplwi cr6, r30, 0x10
	ctx.cr[6].compare_u32(ctx.r[30].u32, 16 as u32, &mut ctx.xer);
	// 821A929C: 40980038  bge cr6, 0x821a92d4
	if !ctx.cr[6].lt {
	pc = 0x821A92D4; continue 'dispatch;
	}
	// 821A92A0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A92A4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A92A8: 40980008  bge cr6, 0x821a92b0
	if !ctx.cr[6].lt {
	pc = 0x821A92B0; continue 'dispatch;
	}
	// 821A92AC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821A92B0; continue 'dispatch;
            }
            0x821A92B0 => {
    //   block [0x821A92B0..0x821A92D4)
	// 821A92B0: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 821A92B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821A92B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A92BC: 481489AD  bl 0x822f1c68
	ctx.lr = 0x821A92C0;
	sub_822F1C68(ctx, base);
	// 821A92C0: 7D7EE010  subfc r11, r30, r28
	ctx.xer.ca = ctx.r[28].u32 >= ctx.r[30].u32;
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 821A92C4: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A92C8: 554307FE  clrlwi r3, r10, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821A92CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A92D0: 48B00188  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A92D4 => {
    //   block [0x821A92D4..0x821A92F0)
	// 821A92D4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A92D8: 409A0020  bne cr6, 0x821a92f8
	if !ctx.cr[6].eq {
	pc = 0x821A92F8; continue 'dispatch;
	}
	// 821A92DC: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 821A92E0: 939F0014  stw r28, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 821A92E4: 4198000C  blt cr6, 0x821a92f0
	if ctx.cr[6].lt {
	pc = 0x821A92F0; continue 'dispatch;
	}
	// 821A92E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A92EC: 48000008  b 0x821a92f4
	pc = 0x821A92F4; continue 'dispatch;
            }
            0x821A92F0 => {
    //   block [0x821A92F0..0x821A92F4)
	// 821A92F0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x821A92F4; continue 'dispatch;
            }
            0x821A92F4 => {
    //   block [0x821A92F4..0x821A92F8)
	// 821A92F4: 9B8B0000  stb r28, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	pc = 0x821A92F8; continue 'dispatch;
            }
            0x821A92F8 => {
    //   block [0x821A92F8..0x821A930C)
	// 821A92F8: 7D7EE010  subfc r11, r30, r28
	ctx.xer.ca = ctx.r[28].u32 >= ctx.r[30].u32;
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 821A92FC: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A9300: 554307FE  clrlwi r3, r10, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821A9304: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A9308: 48B00150  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A9310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A9310 size=228
    let mut pc: u32 = 0x821A9310;
    'dispatch: loop {
        match pc {
            0x821A9310 => {
    //   block [0x821A9310..0x821A933C)
	// 821A9310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A9314: 48B000F1  bl 0x82ca9404
	ctx.lr = 0x821A9318;
	sub_82CA93D0(ctx, base);
	// 821A9318: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A931C: 609F000F  ori r31, r4, 0xf
	ctx.r[31].u64 = ctx.r[4].u64 | 15;
	// 821A9320: 3960FFFE  li r11, -2
	ctx.r[11].s64 = -2;
	// 821A9324: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A9328: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821A932C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A9330: 4099000C  ble cr6, 0x821a933c
	if !ctx.cr[6].gt {
	pc = 0x821A933C; continue 'dispatch;
	}
	// 821A9334: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821A9338: 4800002C  b 0x821a9364
	pc = 0x821A9364; continue 'dispatch;
            }
            0x821A933C => {
    //   block [0x821A933C..0x821A9364)
	// 821A933C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A9340: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 821A9344: 556AF87E  srwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A9348: 7D1F4B96  divwu r8, r31, r9
	ctx.r[8].u32 = ctx.r[31].u32 / ctx.r[9].u32;
	// 821A934C: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A9350: 40980014  bge cr6, 0x821a9364
	if !ctx.cr[6].lt {
	pc = 0x821A9364; continue 'dispatch;
	}
	// 821A9354: 212AFFFE  subfic r9, r10, -2
	ctx.xer.ca = ctx.r[10].u32 <= -2 as u32;
	ctx.r[9].s64 = (-2 as i64) - ctx.r[10].s64;
	// 821A9358: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A935C: 41990008  bgt cr6, 0x821a9364
	if ctx.cr[6].gt {
	pc = 0x821A9364; continue 'dispatch;
	}
	// 821A9360: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821A9364; continue 'dispatch;
            }
            0x821A9364 => {
    //   block [0x821A9364..0x821A9394)
	// 821A9364: 3B9F0001  addi r28, r31, 1
	ctx.r[28].s64 = ctx.r[31].s64 + 1;
	// 821A9368: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821A936C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821A9370: 48000089  bl 0x821a93f8
	ctx.lr = 0x821A9374;
	sub_821A93F8(ctx, base);
	// 821A9374: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A9378: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821A937C: 419A002C  beq cr6, 0x821a93a8
	if ctx.cr[6].eq {
	pc = 0x821A93A8; continue 'dispatch;
	}
	// 821A9380: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A9384: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 821A9388: 4198000C  blt cr6, 0x821a9394
	if ctx.cr[6].lt {
	pc = 0x821A9394; continue 'dispatch;
	}
	// 821A938C: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A9390: 48000008  b 0x821a9398
	pc = 0x821A9398; continue 'dispatch;
            }
            0x821A9394 => {
    //   block [0x821A9394..0x821A9398)
	// 821A9394: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	pc = 0x821A9398; continue 'dispatch;
            }
            0x821A9398 => {
    //   block [0x821A9398..0x821A93A8)
	// 821A9398: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 821A939C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A93A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A93A4: 48B00BAD  bl 0x82ca9f50
	ctx.lr = 0x821A93A8;
	sub_82CA9F50(ctx, base);
	pc = 0x821A93A8; continue 'dispatch;
            }
            0x821A93A8 => {
    //   block [0x821A93A8..0x821A93BC)
	// 821A93A8: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A93AC: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 821A93B0: 4198000C  blt cr6, 0x821a93bc
	if ctx.cr[6].lt {
	pc = 0x821A93BC; continue 'dispatch;
	}
	// 821A93B4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A93B8: 48072981  bl 0x8221bd38
	ctx.lr = 0x821A93BC;
	sub_8221BD38(ctx, base);
	pc = 0x821A93BC; continue 'dispatch;
            }
            0x821A93BC => {
    //   block [0x821A93BC..0x821A93E8)
	// 821A93BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A93C0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 821A93C4: 995E0004  stb r10, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 821A93C8: 2B1F0010  cmplwi cr6, r31, 0x10
	ctx.cr[6].compare_u32(ctx.r[31].u32, 16 as u32, &mut ctx.xer);
	// 821A93CC: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821A93D0: 93FE0018  stw r31, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 821A93D4: 937E0014  stw r27, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[27].u32 ) };
	// 821A93D8: 41980010  blt cr6, 0x821a93e8
	if ctx.cr[6].lt {
	pc = 0x821A93E8; continue 'dispatch;
	}
	// 821A93DC: 7D5DD9AE  stbx r10, r29, r27
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[27].u32), ctx.r[10].u8) };
	// 821A93E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A93E4: 48B00070  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x821A93E8 => {
    //   block [0x821A93E8..0x821A93F4)
	// 821A93E8: 7D4BD9AE  stbx r10, r11, r27
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[10].u8) };
	// 821A93EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A93F0: 48B00064  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A93F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A93F8 size=112
    let mut pc: u32 = 0x821A93F8;
    'dispatch: loop {
        match pc {
            0x821A93F8 => {
    //   block [0x821A93F8..0x821A944C)
	// 821A93F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A93FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A9400: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A9404: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A9408: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A940C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A9410: 419A003C  beq cr6, 0x821a944c
	if ctx.cr[6].eq {
	pc = 0x821A944C; continue 'dispatch;
	}
	// 821A9414: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821A9418: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 821A941C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 821A9420: 4098002C  bge cr6, 0x821a944c
	if !ctx.cr[6].lt {
	pc = 0x821A944C; continue 'dispatch;
	}
	// 821A9424: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A9428: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A942C: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 821A9430: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821A9434: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821A9438: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821A943C: 481489E5  bl 0x822f1e20
	ctx.lr = 0x821A9440;
	sub_822F1E20(ctx, base);
	// 821A9440: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821A9444: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 821A9448: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x821A944C; continue 'dispatch;
            }
            0x821A944C => {
    //   block [0x821A944C..0x821A9468)
	// 821A944C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A9450: 48075E09  bl 0x8221f258
	ctx.lr = 0x821A9454;
	sub_8221F258(ctx, base);
	// 821A9454: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A9458: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A945C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A9460: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A9464: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A9478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A9478 size=2996
    let mut pc: u32 = 0x821A9478;
    'dispatch: loop {
        match pc {
            0x821A9478 => {
    //   block [0x821A9478..0x821AA02C)
	// 821A9478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A947C: 48AFFF7D  bl 0x82ca93f8
	ctx.lr = 0x821A9480;
	sub_82CA93D0(ctx, base);
	// 821A9480: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 821A9484: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 821A9488: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AA030 size=76
    let mut pc: u32 = 0x821AA030;
    'dispatch: loop {
        match pc {
            0x821AA030 => {
    //   block [0x821AA030..0x821AA07C)
	// 821AA030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AA038: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AA03C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AA040: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA044: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821AA048: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821AA04C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AA050: 48082E81  bl 0x8222ced0
	ctx.lr = 0x821AA054;
	sub_8222CED0(ctx, base);
	// 821AA054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AA058: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AA05C: 4804279D  bl 0x821ec7f8
	ctx.lr = 0x821AA060;
	sub_821EC7F8(ctx, base);
	// 821AA060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AA064: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AA068: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA06C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA070: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821AA074: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AA078: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AA080 size=516
    let mut pc: u32 = 0x821AA080;
    'dispatch: loop {
        match pc {
            0x821AA080 => {
    //   block [0x821AA080..0x821AA0E0)
	// 821AA080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA084: 48AFF389  bl 0x82ca940c
	ctx.lr = 0x821AA088;
	sub_82CA93D0(ctx, base);
	// 821AA088: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821AA08C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA090: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 821AA094: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AA098: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AA09C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821AA0A0: 815D6AB8  lwz r10, 0x6ab8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821AA0A4: C00B9490  lfs f0, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA0A8: D01E01B4  stfs f0, 0x1b4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 821AA0AC: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA0B0: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821AA0B4: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA0B8: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA0BC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 821AA0C0: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821AA0C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA0C8: 419A001C  beq cr6, 0x821aa0e4
	if ctx.cr[6].eq {
	pc = 0x821AA0E4; continue 'dispatch;
	}
	// 821AA0CC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA0D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AA0D4: 419A000C  beq cr6, 0x821aa0e0
	if ctx.cr[6].eq {
	pc = 0x821AA0E0; continue 'dispatch;
	}
	// 821AA0D8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AA0DC: 4800000C  b 0x821aa0e8
	pc = 0x821AA0E8; continue 'dispatch;
            }
            0x821AA0E0 => {
    //   block [0x821AA0E0..0x821AA0E4)
	// 821AA0E0: 4BFE9D59  bl 0x82193e38
	ctx.lr = 0x821AA0E4;
	sub_82193E38(ctx, base);
	pc = 0x821AA0E4; continue 'dispatch;
            }
            0x821AA0E4 => {
    //   block [0x821AA0E4..0x821AA0E8)
	// 821AA0E4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x821AA0E8; continue 'dispatch;
            }
            0x821AA0E8 => {
    //   block [0x821AA0E8..0x821AA124)
	// 821AA0E8: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821AA0EC: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821AA0F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AA0F4: 419A00F4  beq cr6, 0x821aa1e8
	if ctx.cr[6].eq {
	pc = 0x821AA1E8; continue 'dispatch;
	}
	// 821AA0F8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AA0FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AA100: 419A0024  beq cr6, 0x821aa124
	if ctx.cr[6].eq {
	pc = 0x821AA124; continue 'dispatch;
	}
	// 821AA104: 894A0080  lbz r10, 0x80(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AA108: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AA10C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821AA110: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AA114: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA118: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AA11C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AA120: 480000CC  b 0x821aa1ec
	pc = 0x821AA1EC; continue 'dispatch;
            }
            0x821AA124 => {
    //   block [0x821AA124..0x821AA140)
	// 821AA124: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AA128: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AA12C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821AA130: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AA134: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AA138: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AA13C: 40810054  ble 0x821aa190
	if !ctx.cr[0].gt {
	pc = 0x821AA190; continue 'dispatch;
	}
	pc = 0x821AA140; continue 'dispatch;
            }
            0x821AA140 => {
    //   block [0x821AA140..0x821AA160)
	// 821AA140: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AA144: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AA148: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AA14C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA150: 2F070080  cmpwi cr6, r7, 0x80
	ctx.cr[6].compare_i32(ctx.r[7].s32, 128, &mut ctx.xer);
	// 821AA154: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AA158: 41980008  blt cr6, 0x821aa160
	if ctx.cr[6].lt {
	pc = 0x821AA160; continue 'dispatch;
	}
	// 821AA15C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x821AA160; continue 'dispatch;
            }
            0x821AA160 => {
    //   block [0x821AA160..0x821AA17C)
	// 821AA160: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AA164: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AA168: 419A0014  beq cr6, 0x821aa17c
	if ctx.cr[6].eq {
	pc = 0x821AA17C; continue 'dispatch;
	}
	// 821AA16C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AA170: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AA174: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AA178: 4800000C  b 0x821aa184
	pc = 0x821AA184; continue 'dispatch;
            }
            0x821AA17C => {
    //   block [0x821AA17C..0x821AA184)
	// 821AA17C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AA180: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AA184; continue 'dispatch;
            }
            0x821AA184 => {
    //   block [0x821AA184..0x821AA190)
	// 821AA184: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AA188: 4199FFB8  bgt cr6, 0x821aa140
	if ctx.cr[6].gt {
	pc = 0x821AA140; continue 'dispatch;
	}
	// 821AA18C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821AA190; continue 'dispatch;
            }
            0x821AA190 => {
    //   block [0x821AA190..0x821AA1AC)
	// 821AA190: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AA194: 419A0040  beq cr6, 0x821aa1d4
	if ctx.cr[6].eq {
	pc = 0x821AA1D4; continue 'dispatch;
	}
	// 821AA198: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA19C: 2F0B0080  cmpwi cr6, r11, 0x80
	ctx.cr[6].compare_i32(ctx.r[11].s32, 128, &mut ctx.xer);
	// 821AA1A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AA1A4: 41990008  bgt cr6, 0x821aa1ac
	if ctx.cr[6].gt {
	pc = 0x821AA1AC; continue 'dispatch;
	}
	// 821AA1A8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x821AA1AC; continue 'dispatch;
            }
            0x821AA1AC => {
    //   block [0x821AA1AC..0x821AA1D4)
	// 821AA1AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AA1B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA1B4: 409A0020  bne cr6, 0x821aa1d4
	if !ctx.cr[6].eq {
	pc = 0x821AA1D4; continue 'dispatch;
	}
	// 821AA1B8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AA1BC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AA1C0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AA1C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA1C8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AA1CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AA1D0: 4800001C  b 0x821aa1ec
	pc = 0x821AA1EC; continue 'dispatch;
            }
            0x821AA1D4 => {
    //   block [0x821AA1D4..0x821AA1E8)
	// 821AA1D4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AA1D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA1DC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AA1E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AA1E4: 48000008  b 0x821aa1ec
	pc = 0x821AA1EC; continue 'dispatch;
            }
            0x821AA1E8 => {
    //   block [0x821AA1E8..0x821AA1EC)
	// 821AA1E8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x821AA1EC; continue 'dispatch;
            }
            0x821AA1EC => {
    //   block [0x821AA1EC..0x821AA220)
	// 821AA1EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AA1F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA1F4: 419A002C  beq cr6, 0x821aa220
	if ctx.cr[6].eq {
	pc = 0x821AA220; continue 'dispatch;
	}
	// 821AA1F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821AA1FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AA200: 4802E309  bl 0x821d8508
	ctx.lr = 0x821AA204;
	sub_821D8508(ctx, base);
	// 821AA204: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AA208: 419A0018  beq cr6, 0x821aa220
	if ctx.cr[6].eq {
	pc = 0x821AA220; continue 'dispatch;
	}
	// 821AA20C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821AA210: C1BE01B4  lfs f13, 0x1b4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(436 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AA214: C00B91F8  lfs f0, -0x6e08(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA218: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AA21C: D19E01B4  stfs f12, 0x1b4(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(436 as u32), tmp.u32 ) };
	pc = 0x821AA220; continue 'dispatch;
            }
            0x821AA220 => {
    //   block [0x821AA220..0x821AA284)
	// 821AA220: 817D6AB8  lwz r11, 0x6ab8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821AA224: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821AA228: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA22C: C00A9040  lfs f0, -0x6fc0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28608 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA230: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821AA234: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA238: 80C70014  lwz r6, 0x14(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AA23C: C1A60004  lfs f13, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AA240: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AA244: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AA248: 4808FC69  bl 0x82239eb0
	ctx.lr = 0x821AA24C;
	sub_82239EB0(ctx, base);
	// 821AA24C: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821AA250: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AA254: FFE06210  fabs f31, f12
	ctx.f[31].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 821AA258: 4808FD39  bl 0x82239f90
	ctx.lr = 0x821AA25C;
	sub_82239F90(ctx, base);
	// 821AA25C: FD600818  frsp f11, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821AA260: 3CA08332  lis r5, -0x7cce
	ctx.r[5].s64 = -2093875200;
	// 821AA264: C15E01B4  lfs f10, 0x1b4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(436 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821AA268: C00591FC  lfs f0, -0x6e04(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-28164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA26C: ED205FFA  fmadds f9, f0, f31, f11
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 821AA270: ED0902B2  fmuls f8, f9, f10
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 821AA274: D11E01B4  stfs f8, 0x1b4(r30)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 821AA278: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AA27C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821AA280: 48AFF1DC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AA288 size=364
    let mut pc: u32 = 0x821AA288;
    'dispatch: loop {
        match pc {
            0x821AA288 => {
    //   block [0x821AA288..0x821AA2C4)
	// 821AA288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA28C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AA290: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AA294: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA298: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AA29C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA2A0: 48000159  bl 0x821aa3f8
	ctx.lr = 0x821AA2A4;
	sub_821AA3F8(ctx, base);
	// 821AA2A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AA2A8: 419A001C  beq cr6, 0x821aa2c4
	if ctx.cr[6].eq {
	pc = 0x821AA2C4; continue 'dispatch;
	}
	// 821AA2AC: 8863001D  lbz r3, 0x1d(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(29 as u32) ) } as u64;
	// 821AA2B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AA2B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA2B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA2BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AA2C0: 4E800020  blr
	return;
            }
            0x821AA2C4 => {
    //   block [0x821AA2C4..0x821AA2FC)
	// 821AA2C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA2C8: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821AA2CC: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821AA2D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AA2D4: 419A0108  beq cr6, 0x821aa3dc
	if ctx.cr[6].eq {
	pc = 0x821AA3DC; continue 'dispatch;
	}
	// 821AA2D8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AA2DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AA2E0: 419A001C  beq cr6, 0x821aa2fc
	if ctx.cr[6].eq {
	pc = 0x821AA2FC; continue 'dispatch;
	}
	// 821AA2E4: 894A0021  lbz r10, 0x21(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 821AA2E8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AA2EC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821AA2F0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AA2F4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA2F8: 480000B4  b 0x821aa3ac
	pc = 0x821AA3AC; continue 'dispatch;
            }
            0x821AA2FC => {
    //   block [0x821AA2FC..0x821AA31C)
	// 821AA2FC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AA300: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AA304: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AA308: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821AA30C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AA310: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AA314: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AA318: 40810054  ble 0x821aa36c
	if !ctx.cr[0].gt {
	pc = 0x821AA36C; continue 'dispatch;
	}
	pc = 0x821AA31C; continue 'dispatch;
            }
            0x821AA31C => {
    //   block [0x821AA31C..0x821AA33C)
	// 821AA31C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AA320: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AA324: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AA328: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA32C: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821AA330: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AA334: 41980008  blt cr6, 0x821aa33c
	if ctx.cr[6].lt {
	pc = 0x821AA33C; continue 'dispatch;
	}
	// 821AA338: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821AA33C; continue 'dispatch;
            }
            0x821AA33C => {
    //   block [0x821AA33C..0x821AA358)
	// 821AA33C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AA340: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AA344: 419A0014  beq cr6, 0x821aa358
	if ctx.cr[6].eq {
	pc = 0x821AA358; continue 'dispatch;
	}
	// 821AA348: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AA34C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AA350: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AA354: 4800000C  b 0x821aa360
	pc = 0x821AA360; continue 'dispatch;
            }
            0x821AA358 => {
    //   block [0x821AA358..0x821AA360)
	// 821AA358: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AA35C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AA360; continue 'dispatch;
            }
            0x821AA360 => {
    //   block [0x821AA360..0x821AA36C)
	// 821AA360: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AA364: 4199FFB8  bgt cr6, 0x821aa31c
	if ctx.cr[6].gt {
	pc = 0x821AA31C; continue 'dispatch;
	}
	// 821AA368: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821AA36C; continue 'dispatch;
            }
            0x821AA36C => {
    //   block [0x821AA36C..0x821AA388)
	// 821AA36C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AA370: 419A0034  beq cr6, 0x821aa3a4
	if ctx.cr[6].eq {
	pc = 0x821AA3A4; continue 'dispatch;
	}
	// 821AA374: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA378: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 821AA37C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AA380: 41990008  bgt cr6, 0x821aa388
	if ctx.cr[6].gt {
	pc = 0x821AA388; continue 'dispatch;
	}
	// 821AA384: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AA388; continue 'dispatch;
            }
            0x821AA388 => {
    //   block [0x821AA388..0x821AA3A4)
	// 821AA388: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AA38C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA390: 409A0014  bne cr6, 0x821aa3a4
	if !ctx.cr[6].eq {
	pc = 0x821AA3A4; continue 'dispatch;
	}
	// 821AA394: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AA398: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AA39C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AA3A0: 48000008  b 0x821aa3a8
	pc = 0x821AA3A8; continue 'dispatch;
            }
            0x821AA3A4 => {
    //   block [0x821AA3A4..0x821AA3A8)
	// 821AA3A4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x821AA3A8; continue 'dispatch;
            }
            0x821AA3A8 => {
    //   block [0x821AA3A8..0x821AA3AC)
	// 821AA3A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821AA3AC; continue 'dispatch;
            }
            0x821AA3AC => {
    //   block [0x821AA3AC..0x821AA3DC)
	// 821AA3AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA3B0: 419A002C  beq cr6, 0x821aa3dc
	if ctx.cr[6].eq {
	pc = 0x821AA3DC; continue 'dispatch;
	}
	// 821AA3B4: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AA3B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AA3BC: 419A0020  beq cr6, 0x821aa3dc
	if ctx.cr[6].eq {
	pc = 0x821AA3DC; continue 'dispatch;
	}
	// 821AA3C0: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 821AA3C4: 4803E7CD  bl 0x821e8b90
	ctx.lr = 0x821AA3C8;
	sub_821E8B90(ctx, base);
	// 821AA3C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AA3CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA3D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA3D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AA3D8: 4E800020  blr
	return;
            }
            0x821AA3DC => {
    //   block [0x821AA3DC..0x821AA3F4)
	// 821AA3DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AA3E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AA3E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA3E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA3EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AA3F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AA3F8 size=480
    let mut pc: u32 = 0x821AA3F8;
    'dispatch: loop {
        match pc {
            0x821AA3F8 => {
    //   block [0x821AA3F8..0x821AA44C)
	// 821AA3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA3FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AA400: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AA404: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AA408: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA40C: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821AA410: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821AA414: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821AA418: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AA41C: 419A00F8  beq cr6, 0x821aa514
	if ctx.cr[6].eq {
	pc = 0x821AA514; continue 'dispatch;
	}
	// 821AA420: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AA424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA428: 419A0024  beq cr6, 0x821aa44c
	if ctx.cr[6].eq {
	pc = 0x821AA44C; continue 'dispatch;
	}
	// 821AA42C: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 821AA430: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AA434: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821AA438: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AA43C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA440: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AA444: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AA448: 480000D0  b 0x821aa518
	pc = 0x821AA518; continue 'dispatch;
            }
            0x821AA44C => {
    //   block [0x821AA44C..0x821AA46C)
	// 821AA44C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AA450: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AA454: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AA458: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821AA45C: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AA460: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AA464: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AA468: 40810054  ble 0x821aa4bc
	if !ctx.cr[0].gt {
	pc = 0x821AA4BC; continue 'dispatch;
	}
	pc = 0x821AA46C; continue 'dispatch;
            }
            0x821AA46C => {
    //   block [0x821AA46C..0x821AA48C)
	// 821AA46C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AA470: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AA474: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AA478: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA47C: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821AA480: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AA484: 41980008  blt cr6, 0x821aa48c
	if ctx.cr[6].lt {
	pc = 0x821AA48C; continue 'dispatch;
	}
	// 821AA488: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821AA48C; continue 'dispatch;
            }
            0x821AA48C => {
    //   block [0x821AA48C..0x821AA4A8)
	// 821AA48C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AA490: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AA494: 419A0014  beq cr6, 0x821aa4a8
	if ctx.cr[6].eq {
	pc = 0x821AA4A8; continue 'dispatch;
	}
	// 821AA498: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AA49C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AA4A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AA4A4: 4800000C  b 0x821aa4b0
	pc = 0x821AA4B0; continue 'dispatch;
            }
            0x821AA4A8 => {
    //   block [0x821AA4A8..0x821AA4B0)
	// 821AA4A8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AA4AC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AA4B0; continue 'dispatch;
            }
            0x821AA4B0 => {
    //   block [0x821AA4B0..0x821AA4BC)
	// 821AA4B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AA4B4: 4199FFB8  bgt cr6, 0x821aa46c
	if ctx.cr[6].gt {
	pc = 0x821AA46C; continue 'dispatch;
	}
	// 821AA4B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821AA4BC; continue 'dispatch;
            }
            0x821AA4BC => {
    //   block [0x821AA4BC..0x821AA4D8)
	// 821AA4BC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AA4C0: 419A0040  beq cr6, 0x821aa500
	if ctx.cr[6].eq {
	pc = 0x821AA500; continue 'dispatch;
	}
	// 821AA4C4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA4C8: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 821AA4CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AA4D0: 41990008  bgt cr6, 0x821aa4d8
	if ctx.cr[6].gt {
	pc = 0x821AA4D8; continue 'dispatch;
	}
	// 821AA4D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AA4D8; continue 'dispatch;
            }
            0x821AA4D8 => {
    //   block [0x821AA4D8..0x821AA500)
	// 821AA4D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AA4DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA4E0: 409A0020  bne cr6, 0x821aa500
	if !ctx.cr[6].eq {
	pc = 0x821AA500; continue 'dispatch;
	}
	// 821AA4E4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AA4E8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AA4EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AA4F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA4F4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AA4F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AA4FC: 4800001C  b 0x821aa518
	pc = 0x821AA518; continue 'dispatch;
            }
            0x821AA500 => {
    //   block [0x821AA500..0x821AA514)
	// 821AA500: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AA504: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA508: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AA50C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AA510: 48000008  b 0x821aa518
	pc = 0x821AA518; continue 'dispatch;
            }
            0x821AA514 => {
    //   block [0x821AA514..0x821AA518)
	// 821AA514: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AA518; continue 'dispatch;
            }
            0x821AA518 => {
    //   block [0x821AA518..0x821AA53C)
	// 821AA518: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AA51C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA520: 419A009C  beq cr6, 0x821aa5bc
	if ctx.cr[6].eq {
	pc = 0x821AA5BC; continue 'dispatch;
	}
	// 821AA524: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AA528: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AA52C: 419A0010  beq cr6, 0x821aa53c
	if ctx.cr[6].eq {
	pc = 0x821AA53C; continue 'dispatch;
	}
	// 821AA530: 38800016  li r4, 0x16
	ctx.r[4].s64 = 22;
	// 821AA534: 4803E65D  bl 0x821e8b90
	ctx.lr = 0x821AA538;
	sub_821E8B90(ctx, base);
	// 821AA538: 48000008  b 0x821aa540
	pc = 0x821AA540; continue 'dispatch;
            }
            0x821AA53C => {
    //   block [0x821AA53C..0x821AA540)
	// 821AA53C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821AA540; continue 'dispatch;
            }
            0x821AA540 => {
    //   block [0x821AA540..0x821AA5BC)
	// 821AA540: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821AA544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA548: 419A0074  beq cr6, 0x821aa5bc
	if ctx.cr[6].eq {
	pc = 0x821AA5BC; continue 'dispatch;
	}
	// 821AA54C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AA550: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AA554: 419A0068  beq cr6, 0x821aa5bc
	if ctx.cr[6].eq {
	pc = 0x821AA5BC; continue 'dispatch;
	}
	// 821AA558: 4801D8C1  bl 0x821c7e18
	ctx.lr = 0x821AA55C;
	sub_821C7E18(ctx, base);
	// 821AA55C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821AA560: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA564: 419A0058  beq cr6, 0x821aa5bc
	if ctx.cr[6].eq {
	pc = 0x821AA5BC; continue 'dispatch;
	}
	// 821AA568: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821AA56C: 83DF0014  lwz r30, 0x14(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AA570: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821AA574: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA578: 806A0080  lwz r3, 0x80(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AA57C: 480CA965  bl 0x82274ee0
	ctx.lr = 0x821AA580;
	sub_82274EE0(ctx, base);
	// 821AA580: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AA584: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AA588: 419A0034  beq cr6, 0x821aa5bc
	if ctx.cr[6].eq {
	pc = 0x821AA5BC; continue 'dispatch;
	}
	// 821AA58C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA590: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AA594: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821AA598: 4E800421  bctrl
	ctx.lr = 0x821AA59C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AA59C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821AA5A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AA5A4: 419A0018  beq cr6, 0x821aa5bc
	if ctx.cr[6].eq {
	pc = 0x821AA5BC; continue 'dispatch;
	}
	// 821AA5A8: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 821AA5AC: 809E0024  lwz r4, 0x24(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AA5B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AA5B4: 4822DABD  bl 0x823d8070
	ctx.lr = 0x821AA5B8;
	sub_823D8070(ctx, base);
	// 821AA5B8: 48000008  b 0x821aa5c0
	pc = 0x821AA5C0; continue 'dispatch;
            }
            0x821AA5BC => {
    //   block [0x821AA5BC..0x821AA5C0)
	// 821AA5BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821AA5C0; continue 'dispatch;
            }
            0x821AA5C0 => {
    //   block [0x821AA5C0..0x821AA5D8)
	// 821AA5C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AA5C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA5C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA5CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821AA5D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AA5D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AA5F0 size=356
    let mut pc: u32 = 0x821AA5F0;
    'dispatch: loop {
        match pc {
            0x821AA5F0 => {
    //   block [0x821AA5F0..0x821AA640)
	// 821AA5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA5F4: 48AFEE0D  bl 0x82ca9400
	ctx.lr = 0x821AA5F8;
	sub_82CA93D0(ctx, base);
	// 821AA5F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA5FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821AA600: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AA604: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821AA608: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821AA60C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AA610: 48037599  bl 0x821e1ba8
	ctx.lr = 0x821AA614;
	sub_821E1BA8(ctx, base);
	// 821AA614: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AA618: 3B5E0018  addi r26, r30, 0x18
	ctx.r[26].s64 = ctx.r[30].s64 + 24;
	// 821AA61C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 821AA620: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 821AA624: 3B600003  li r27, 3
	ctx.r[27].s64 = 3;
	// 821AA628: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA62C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AA630: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AA634: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821AA638: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AA63C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821AA640; continue 'dispatch;
            }
            0x821AA640 => {
    //   block [0x821AA640..0x821AA654)
	// 821AA640: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA644: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821AA648: 419A000C  beq cr6, 0x821aa654
	if ctx.cr[6].eq {
	pc = 0x821AA654; continue 'dispatch;
	}
	// 821AA64C: 7F1CD040  cmplw cr6, r28, r26
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821AA650: 419A0008  beq cr6, 0x821aa658
	if ctx.cr[6].eq {
	pc = 0x821AA658; continue 'dispatch;
	}
	pc = 0x821AA654; continue 'dispatch;
            }
            0x821AA654 => {
    //   block [0x821AA654..0x821AA658)
	// 821AA654: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821AA658; continue 'dispatch;
            }
            0x821AA658 => {
    //   block [0x821AA658..0x821AA66C)
	// 821AA658: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AA65C: 419A00EC  beq cr6, 0x821aa748
	if ctx.cr[6].eq {
	pc = 0x821AA748; continue 'dispatch;
	}
	// 821AA660: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821AA664: 409A0008  bne cr6, 0x821aa66c
	if !ctx.cr[6].eq {
	pc = 0x821AA66C; continue 'dispatch;
	}
	// 821AA668: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821AA66C; continue 'dispatch;
            }
            0x821AA66C => {
    //   block [0x821AA66C..0x821AA67C)
	// 821AA66C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA670: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AA674: 409A0008  bne cr6, 0x821aa67c
	if !ctx.cr[6].eq {
	pc = 0x821AA67C; continue 'dispatch;
	}
	// 821AA678: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821AA67C; continue 'dispatch;
            }
            0x821AA67C => {
    //   block [0x821AA67C..0x821AA6B8)
	// 821AA67C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA680: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 821AA684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA688: 419A00B8  beq cr6, 0x821aa740
	if ctx.cr[6].eq {
	pc = 0x821AA740; continue 'dispatch;
	}
	// 821AA68C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA690: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AA694: 419A00A8  beq cr6, 0x821aa73c
	if ctx.cr[6].eq {
	pc = 0x821AA73C; continue 'dispatch;
	}
	// 821AA698: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AA69C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821AA6A0: 419A0018  beq cr6, 0x821aa6b8
	if ctx.cr[6].eq {
	pc = 0x821AA6B8; continue 'dispatch;
	}
	// 821AA6A4: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821AA6A8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA6AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AA6B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AA6B4: 409A0008  bne cr6, 0x821aa6bc
	if !ctx.cr[6].eq {
	pc = 0x821AA6BC; continue 'dispatch;
	}
	pc = 0x821AA6B8; continue 'dispatch;
            }
            0x821AA6B8 => {
    //   block [0x821AA6B8..0x821AA6BC)
	// 821AA6B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AA6BC; continue 'dispatch;
            }
            0x821AA6BC => {
    //   block [0x821AA6BC..0x821AA724)
	// 821AA6BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AA6C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA6C4: 419A0060  beq cr6, 0x821aa724
	if ctx.cr[6].eq {
	pc = 0x821AA724; continue 'dispatch;
	}
	// 821AA6C8: 7FAB07B4  extsw r11, r29
	ctx.r[11].s64 = ctx.r[29].s32 as i64;
	// 821AA6CC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AA6D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AA6D4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AA6D8: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AA6DC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821AA6E0: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821AA6E4: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AA6E8: 936A0004  stw r27, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 821AA6EC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AA6F0: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821AA6F4: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821AA6F8: 481F88C9  bl 0x823a2fc0
	ctx.lr = 0x821AA6FC;
	sub_823A2FC0(ctx, base);
	// 821AA6FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AA700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AA704: 388BFFE8  addi r4, r11, -0x18
	ctx.r[4].s64 = ctx.r[11].s64 + -24;
	// 821AA708: 38CBFFF8  addi r6, r11, -8
	ctx.r[6].s64 = ctx.r[11].s64 + -8;
	// 821AA70C: 38ABFFF0  addi r5, r11, -0x10
	ctx.r[5].s64 = ctx.r[11].s64 + -16;
	// 821AA710: 4807E619  bl 0x82228d28
	ctx.lr = 0x821AA714;
	sub_82228D28(ctx, base);
	// 821AA714: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AA718: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821AA71C: 390BFFF0  addi r8, r11, -0x10
	ctx.r[8].s64 = ctx.r[11].s64 + -16;
	// 821AA720: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x821AA724; continue 'dispatch;
            }
            0x821AA724 => {
    //   block [0x821AA724..0x821AA734)
	// 821AA724: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA728: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AA72C: 409A0008  bne cr6, 0x821aa734
	if !ctx.cr[6].eq {
	pc = 0x821AA734; continue 'dispatch;
	}
	// 821AA730: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821AA734; continue 'dispatch;
            }
            0x821AA734 => {
    //   block [0x821AA734..0x821AA73C)
	// 821AA734: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA738: 4BFFFF08  b 0x821aa640
	pc = 0x821AA640; continue 'dispatch;
            }
            0x821AA73C => {
    //   block [0x821AA73C..0x821AA740)
	// 821AA73C: 4BFE96FD  bl 0x82193e38
	ctx.lr = 0x821AA740;
	sub_82193E38(ctx, base);
	pc = 0x821AA740; continue 'dispatch;
            }
            0x821AA740 => {
    //   block [0x821AA740..0x821AA748)
	// 821AA740: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821AA744: 4BFFFF74  b 0x821aa6b8
	pc = 0x821AA6B8; continue 'dispatch;
            }
            0x821AA748 => {
    //   block [0x821AA748..0x821AA754)
	// 821AA748: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AA74C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821AA750: 48AFED00  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AA758 size=40
    let mut pc: u32 = 0x821AA758;
    'dispatch: loop {
        match pc {
            0x821AA758 => {
    //   block [0x821AA758..0x821AA780)
	// 821AA758: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AA75C: C0030084  lfs f0, 0x84(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA760: 396B949C  addi r11, r11, -0x6b64
	ctx.r[11].s64 = ctx.r[11].s64 + -27492;
	// 821AA764: C1AB27D0  lfs f13, 0x27d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AA768: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821AA76C: 41980014  blt cr6, 0x821aa780
	if ctx.cr[6].lt {
		sub_821AA780(ctx, base);
		return;
	}
	// 821AA770: C00B27C8  lfs f0, 0x27c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA774: C1A30038  lfs f13, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AA778: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AA77C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AA780 size=44
    let mut pc: u32 = 0x821AA780;
    'dispatch: loop {
        match pc {
            0x821AA780 => {
    //   block [0x821AA780..0x821AA7AC)
	// 821AA780: C1AB27CC  lfs f13, 0x27cc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AA784: C1630038  lfs f11, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AA788: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821AA78C: 41980020  blt cr6, 0x821aa7ac
	if ctx.cr[6].lt {
		sub_821AA7AC(ctx, base);
		return;
	}
	// 821AA790: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AA794: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 821AA798: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AA79C: C00A0ED0  lfs f0, 0xed0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA7A0: ED4C683C  fnmsubs f10, f12, f0, f13
	ctx.f[10].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AA7A4: EC2B02B2  fmuls f1, f11, f10
	ctx.f[1].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 821AA7A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA7AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AA7AC size=24
    let mut pc: u32 = 0x821AA7AC;
    'dispatch: loop {
        match pc {
            0x821AA7AC => {
    //   block [0x821AA7AC..0x821AA7C4)
	// 821AA7AC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821AA7B0: C18BFFF4  lfs f12, -0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA7B4: C1AA10C8  lfs f13, 0x10c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4296 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AA7B8: ED40637C  fnmsubs f10, f0, f13, f12
	ctx.f[10].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 821AA7BC: EC2B02B2  fmuls f1, f11, f10
	ctx.f[1].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 821AA7C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AA7C8 size=436
    let mut pc: u32 = 0x821AA7C8;
    'dispatch: loop {
        match pc {
            0x821AA7C8 => {
    //   block [0x821AA7C8..0x821AA81C)
	// 821AA7C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA7CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AA7D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AA7D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA7D8: 81630084  lwz r11, 0x84(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 821AA7DC: 3BE30080  addi r31, r3, 0x80
	ctx.r[31].s64 = ctx.r[3].s64 + 128;
	// 821AA7E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA7E4: 419A0038  beq cr6, 0x821aa81c
	if ctx.cr[6].eq {
	pc = 0x821AA81C; continue 'dispatch;
	}
	// 821AA7E8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA7EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AA7F0: 419A007C  beq cr6, 0x821aa86c
	if ctx.cr[6].eq {
	pc = 0x821AA86C; continue 'dispatch;
	}
	// 821AA7F4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AA7F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA7FC: 419A0020  beq cr6, 0x821aa81c
	if ctx.cr[6].eq {
	pc = 0x821AA81C; continue 'dispatch;
	}
	// 821AA800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AA804: 4BFC9635  bl 0x82173e38
	ctx.lr = 0x821AA808;
	sub_82173E38(ctx, base);
	// 821AA808: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821AA80C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA810: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AA814: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AA818: 409A0008  bne cr6, 0x821aa820
	if !ctx.cr[6].eq {
	pc = 0x821AA820; continue 'dispatch;
	}
	pc = 0x821AA81C; continue 'dispatch;
            }
            0x821AA81C => {
    //   block [0x821AA81C..0x821AA820)
	// 821AA81C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AA820; continue 'dispatch;
            }
            0x821AA820 => {
    //   block [0x821AA820..0x821AA86C)
	// 821AA820: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AA824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA828: 419A013C  beq cr6, 0x821aa964
	if ctx.cr[6].eq {
	pc = 0x821AA964; continue 'dispatch;
	}
	// 821AA82C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AA830: 4BFC9609  bl 0x82173e38
	ctx.lr = 0x821AA834;
	sub_82173E38(ctx, base);
	// 821AA834: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821AA838: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 821AA83C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AA840: 419A00F8  beq cr6, 0x821aa938
	if ctx.cr[6].eq {
	pc = 0x821AA938; continue 'dispatch;
	}
	// 821AA844: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AA848: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA84C: 419A002C  beq cr6, 0x821aa878
	if ctx.cr[6].eq {
	pc = 0x821AA878; continue 'dispatch;
	}
	// 821AA850: 894B003B  lbz r10, 0x3b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(59 as u32) ) } as u64;
	// 821AA854: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AA858: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821AA85C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AA860: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AA864: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA868: 480000D8  b 0x821aa940
	pc = 0x821AA940; continue 'dispatch;
            }
            0x821AA86C => {
    //   block [0x821AA86C..0x821AA878)
	// 821AA86C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AA870: 4BFE95C9  bl 0x82193e38
	ctx.lr = 0x821AA874;
	sub_82193E38(ctx, base);
	// 821AA874: 4BFFFFA8  b 0x821aa81c
	pc = 0x821AA81C; continue 'dispatch;
            }
            0x821AA878 => {
    //   block [0x821AA878..0x821AA898)
	// 821AA878: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AA87C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AA880: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AA884: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821AA888: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AA88C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AA890: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AA894: 40810054  ble 0x821aa8e8
	if !ctx.cr[0].gt {
	pc = 0x821AA8E8; continue 'dispatch;
	}
	pc = 0x821AA898; continue 'dispatch;
            }
            0x821AA898 => {
    //   block [0x821AA898..0x821AA8B8)
	// 821AA898: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AA89C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AA8A0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AA8A4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA8A8: 2F07003B  cmpwi cr6, r7, 0x3b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 59, &mut ctx.xer);
	// 821AA8AC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AA8B0: 41980008  blt cr6, 0x821aa8b8
	if ctx.cr[6].lt {
	pc = 0x821AA8B8; continue 'dispatch;
	}
	// 821AA8B4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821AA8B8; continue 'dispatch;
            }
            0x821AA8B8 => {
    //   block [0x821AA8B8..0x821AA8D4)
	// 821AA8B8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AA8BC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AA8C0: 419A0014  beq cr6, 0x821aa8d4
	if ctx.cr[6].eq {
	pc = 0x821AA8D4; continue 'dispatch;
	}
	// 821AA8C4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AA8C8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AA8CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AA8D0: 4800000C  b 0x821aa8dc
	pc = 0x821AA8DC; continue 'dispatch;
            }
            0x821AA8D4 => {
    //   block [0x821AA8D4..0x821AA8DC)
	// 821AA8D4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AA8D8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AA8DC; continue 'dispatch;
            }
            0x821AA8DC => {
    //   block [0x821AA8DC..0x821AA8E8)
	// 821AA8DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AA8E0: 4199FFB8  bgt cr6, 0x821aa898
	if ctx.cr[6].gt {
	pc = 0x821AA898; continue 'dispatch;
	}
	// 821AA8E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821AA8E8; continue 'dispatch;
            }
            0x821AA8E8 => {
    //   block [0x821AA8E8..0x821AA904)
	// 821AA8E8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AA8EC: 419A003C  beq cr6, 0x821aa928
	if ctx.cr[6].eq {
	pc = 0x821AA928; continue 'dispatch;
	}
	// 821AA8F0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA8F4: 2F0B003B  cmpwi cr6, r11, 0x3b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 59, &mut ctx.xer);
	// 821AA8F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AA8FC: 41990008  bgt cr6, 0x821aa904
	if ctx.cr[6].gt {
	pc = 0x821AA904; continue 'dispatch;
	}
	// 821AA900: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AA904; continue 'dispatch;
            }
            0x821AA904 => {
    //   block [0x821AA904..0x821AA928)
	// 821AA904: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AA908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA90C: 409A001C  bne cr6, 0x821aa928
	if !ctx.cr[6].eq {
	pc = 0x821AA928; continue 'dispatch;
	}
	// 821AA910: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AA914: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AA918: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AA91C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AA920: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA924: 4800001C  b 0x821aa940
	pc = 0x821AA940; continue 'dispatch;
            }
            0x821AA928 => {
    //   block [0x821AA928..0x821AA938)
	// 821AA928: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AA92C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AA930: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA934: 4800000C  b 0x821aa940
	pc = 0x821AA940; continue 'dispatch;
            }
            0x821AA938 => {
    //   block [0x821AA938..0x821AA940)
	// 821AA938: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AA93C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821AA940; continue 'dispatch;
            }
            0x821AA940 => {
    //   block [0x821AA940..0x821AA964)
	// 821AA940: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821AA944: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AA948: 419A001C  beq cr6, 0x821aa964
	if ctx.cr[6].eq {
	pc = 0x821AA964; continue 'dispatch;
	}
	// 821AA94C: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA950: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AA954: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA958: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA95C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AA960: 4E800020  blr
	return;
            }
            0x821AA964 => {
    //   block [0x821AA964..0x821AA97C)
	// 821AA964: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AA968: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AA96C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA970: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA974: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AA978: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AA980 size=260
    let mut pc: u32 = 0x821AA980;
    'dispatch: loop {
        match pc {
            0x821AA980 => {
    //   block [0x821AA980..0x821AAA84)
	// 821AA980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AA988: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AA98C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AA990: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AAA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AAA88 size=2504
    let mut pc: u32 = 0x821AAA88;
    'dispatch: loop {
        match pc {
            0x821AAA88 => {
    //   block [0x821AAA88..0x821AAAD0)
	// 821AAA88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AAA8C: 48AFE96D  bl 0x82ca93f8
	ctx.lr = 0x821AAA90;
	sub_82CA93D0(ctx, base);
	// 821AAA90: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 821AAA94: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 821AAA98: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AAA9C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821AAAA0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821AAAA4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821AAAA8: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 821AAAAC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821AAAB0: 48205F89  bl 0x823b0a38
	ctx.lr = 0x821AAAB4;
	sub_823B0A38(ctx, base);
	// 821AAAB4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821AAAB8: 392BAA9C  addi r9, r11, -0x5564
	ctx.r[9].s64 = ctx.r[11].s64 + -21860;
	// 821AAABC: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAAC0: 80E90008  lwz r7, 8(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AAAC4: 7D0A3850  subf r8, r10, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 821AAAC8: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AAACC: 4081003C  ble 0x821aab08
	if !ctx.cr[0].gt {
	pc = 0x821AAB08; continue 'dispatch;
	}
	pc = 0x821AAAD0; continue 'dispatch;
            }
            0x821AAAD0 => {
    //   block [0x821AAAD0..0x821AAAF8)
	// 821AAAD0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AAAD4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AAAD8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821AAADC: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAAE0: 7F061840  cmplw cr6, r6, r3
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821AAAE4: 40980014  bge cr6, 0x821aaaf8
	if !ctx.cr[6].lt {
	pc = 0x821AAAF8; continue 'dispatch;
	}
	// 821AAAE8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AAAEC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AAAF0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AAAF4: 4800000C  b 0x821aab00
	pc = 0x821AAB00; continue 'dispatch;
            }
            0x821AAAF8 => {
    //   block [0x821AAAF8..0x821AAB00)
	// 821AAAF8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AAAFC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AAB00; continue 'dispatch;
            }
            0x821AAB00 => {
    //   block [0x821AAB00..0x821AAB08)
	// 821AAB00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AAB04: 4199FFCC  bgt cr6, 0x821aaad0
	if ctx.cr[6].gt {
	pc = 0x821AAAD0; continue 'dispatch;
	}
	pc = 0x821AAB08; continue 'dispatch;
            }
            0x821AAB08 => {
    //   block [0x821AAB08..0x821AAB6C)
	// 821AAB08: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AAB0C: 419A0934  beq cr6, 0x821ab440
	if ctx.cr[6].eq {
	pc = 0x821AB440; continue 'dispatch;
	}
	// 821AAB10: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAB14: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AAB18: 41980928  blt cr6, 0x821ab440
	if ctx.cr[6].lt {
	pc = 0x821AB440; continue 'dispatch;
	}
	// 821AAB1C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821AAB20: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821AAB24: 3B6A0004  addi r27, r10, 4
	ctx.r[27].s64 = ctx.r[10].s64 + 4;
	// 821AAB28: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 821AAB2C: 480C1BD5  bl 0x8226c700
	ctx.lr = 0x821AAB30;
	sub_8226C700(ctx, base);
	// 821AAB30: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AAB34: 556A27FE  rlwinm r10, r11, 4, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 821AAB38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AAB3C: 419A00F4  beq cr6, 0x821aac30
	if ctx.cr[6].eq {
	pc = 0x821AAC30; continue 'dispatch;
	}
	// 821AAB40: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AAB44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAB48: 419A0024  beq cr6, 0x821aab6c
	if ctx.cr[6].eq {
	pc = 0x821AAB6C; continue 'dispatch;
	}
	// 821AAB4C: 894B001C  lbz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AAB50: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AAB54: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821AAB58: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AAB5C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAB60: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 821AAB64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AAB68: 480000CC  b 0x821aac34
	pc = 0x821AAC34; continue 'dispatch;
            }
            0x821AAB6C => {
    //   block [0x821AAB6C..0x821AAB88)
	// 821AAB6C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AAB70: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AAB74: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 821AAB78: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AAB7C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AAB80: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AAB84: 40810054  ble 0x821aabd8
	if !ctx.cr[0].gt {
	pc = 0x821AABD8; continue 'dispatch;
	}
	pc = 0x821AAB88; continue 'dispatch;
            }
            0x821AAB88 => {
    //   block [0x821AAB88..0x821AABA8)
	// 821AAB88: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AAB8C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AAB90: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AAB94: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAB98: 2F07001C  cmpwi cr6, r7, 0x1c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 28, &mut ctx.xer);
	// 821AAB9C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AABA0: 41980008  blt cr6, 0x821aaba8
	if ctx.cr[6].lt {
	pc = 0x821AABA8; continue 'dispatch;
	}
	// 821AABA4: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x821AABA8; continue 'dispatch;
            }
            0x821AABA8 => {
    //   block [0x821AABA8..0x821AABC4)
	// 821AABA8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AABAC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AABB0: 419A0014  beq cr6, 0x821aabc4
	if ctx.cr[6].eq {
	pc = 0x821AABC4; continue 'dispatch;
	}
	// 821AABB4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AABB8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AABBC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AABC0: 4800000C  b 0x821aabcc
	pc = 0x821AABCC; continue 'dispatch;
            }
            0x821AABC4 => {
    //   block [0x821AABC4..0x821AABCC)
	// 821AABC4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AABC8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AABCC; continue 'dispatch;
            }
            0x821AABCC => {
    //   block [0x821AABCC..0x821AABD8)
	// 821AABCC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AABD0: 4199FFB8  bgt cr6, 0x821aab88
	if ctx.cr[6].gt {
	pc = 0x821AAB88; continue 'dispatch;
	}
	// 821AABD4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821AABD8; continue 'dispatch;
            }
            0x821AABD8 => {
    //   block [0x821AABD8..0x821AABF4)
	// 821AABD8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AABDC: 419A0040  beq cr6, 0x821aac1c
	if ctx.cr[6].eq {
	pc = 0x821AAC1C; continue 'dispatch;
	}
	// 821AABE0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AABE4: 2F0B001C  cmpwi cr6, r11, 0x1c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 28, &mut ctx.xer);
	// 821AABE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AABEC: 41990008  bgt cr6, 0x821aabf4
	if ctx.cr[6].gt {
	pc = 0x821AABF4; continue 'dispatch;
	}
	// 821AABF0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AABF4; continue 'dispatch;
            }
            0x821AABF4 => {
    //   block [0x821AABF4..0x821AAC1C)
	// 821AABF4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AABF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AABFC: 409A0020  bne cr6, 0x821aac1c
	if !ctx.cr[6].eq {
	pc = 0x821AAC1C; continue 'dispatch;
	}
	// 821AAC00: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AAC04: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AAC08: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AAC0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAC10: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 821AAC14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AAC18: 4800001C  b 0x821aac34
	pc = 0x821AAC34; continue 'dispatch;
            }
            0x821AAC1C => {
    //   block [0x821AAC1C..0x821AAC30)
	// 821AAC1C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AAC20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAC24: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 821AAC28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AAC2C: 48000008  b 0x821aac34
	pc = 0x821AAC34; continue 'dispatch;
            }
            0x821AAC30 => {
    //   block [0x821AAC30..0x821AAC34)
	// 821AAC30: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AAC34; continue 'dispatch;
            }
            0x821AAC34 => {
    //   block [0x821AAC34..0x821AAC6C)
	// 821AAC34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AAC38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAC3C: 419A0804  beq cr6, 0x821ab440
	if ctx.cr[6].eq {
	pc = 0x821AB440; continue 'dispatch;
	}
	// 821AAC40: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821AAC44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AAC48: 4810DB89  bl 0x822b87d0
	ctx.lr = 0x821AAC4C;
	sub_822B87D0(ctx, base);
	// 821AAC4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821AAC50: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821AAC54: 419A0018  beq cr6, 0x821aac6c
	if ctx.cr[6].eq {
	pc = 0x821AAC6C; continue 'dispatch;
	}
	// 821AAC58: 897D0090  lbz r11, 0x90(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 821AAC5C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AAC60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AAC64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AAC68: 409A0008  bne cr6, 0x821aac70
	if !ctx.cr[6].eq {
	pc = 0x821AAC70; continue 'dispatch;
	}
	pc = 0x821AAC6C; continue 'dispatch;
            }
            0x821AAC6C => {
    //   block [0x821AAC6C..0x821AAC70)
	// 821AAC6C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AAC70; continue 'dispatch;
            }
            0x821AAC70 => {
    //   block [0x821AAC70..0x821AACB8)
	// 821AAC70: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AAC74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAC78: 419A0260  beq cr6, 0x821aaed8
	if ctx.cr[6].eq {
	pc = 0x821AAED8; continue 'dispatch;
	}
	// 821AAC7C: 815D0038  lwz r10, 0x38(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AAC80: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821AAC84: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 821AAC88: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AAC8C: 419A00E8  beq cr6, 0x821aad74
	if ctx.cr[6].eq {
	pc = 0x821AAD74; continue 'dispatch;
	}
	// 821AAC90: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AAC94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAC98: 419A0020  beq cr6, 0x821aacb8
	if ctx.cr[6].eq {
	pc = 0x821AACB8; continue 'dispatch;
	}
	// 821AAC9C: 894B00B3  lbz r10, 0xb3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(179 as u32) ) } as u64;
	// 821AACA0: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AACA4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821AACA8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AACAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AACB0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AACB4: 480000C4  b 0x821aad78
	pc = 0x821AAD78; continue 'dispatch;
            }
            0x821AACB8 => {
    //   block [0x821AACB8..0x821AACD4)
	// 821AACB8: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AACBC: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AACC0: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 821AACC4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AACC8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AACCC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AACD0: 40810054  ble 0x821aad24
	if !ctx.cr[0].gt {
	pc = 0x821AAD24; continue 'dispatch;
	}
	pc = 0x821AACD4; continue 'dispatch;
            }
            0x821AACD4 => {
    //   block [0x821AACD4..0x821AACF4)
	// 821AACD4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AACD8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AACDC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AACE0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AACE4: 2F0700B3  cmpwi cr6, r7, 0xb3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 179, &mut ctx.xer);
	// 821AACE8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AACEC: 41980008  blt cr6, 0x821aacf4
	if ctx.cr[6].lt {
	pc = 0x821AACF4; continue 'dispatch;
	}
	// 821AACF0: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x821AACF4; continue 'dispatch;
            }
            0x821AACF4 => {
    //   block [0x821AACF4..0x821AAD10)
	// 821AACF4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AACF8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AACFC: 419A0014  beq cr6, 0x821aad10
	if ctx.cr[6].eq {
	pc = 0x821AAD10; continue 'dispatch;
	}
	// 821AAD00: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AAD04: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AAD08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AAD0C: 4800000C  b 0x821aad18
	pc = 0x821AAD18; continue 'dispatch;
            }
            0x821AAD10 => {
    //   block [0x821AAD10..0x821AAD18)
	// 821AAD10: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AAD14: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AAD18; continue 'dispatch;
            }
            0x821AAD18 => {
    //   block [0x821AAD18..0x821AAD24)
	// 821AAD18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AAD1C: 4199FFB8  bgt cr6, 0x821aacd4
	if ctx.cr[6].gt {
	pc = 0x821AACD4; continue 'dispatch;
	}
	// 821AAD20: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821AAD24; continue 'dispatch;
            }
            0x821AAD24 => {
    //   block [0x821AAD24..0x821AAD40)
	// 821AAD24: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AAD28: 419A003C  beq cr6, 0x821aad64
	if ctx.cr[6].eq {
	pc = 0x821AAD64; continue 'dispatch;
	}
	// 821AAD2C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAD30: 2F0B00B3  cmpwi cr6, r11, 0xb3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 179, &mut ctx.xer);
	// 821AAD34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AAD38: 41990008  bgt cr6, 0x821aad40
	if ctx.cr[6].gt {
	pc = 0x821AAD40; continue 'dispatch;
	}
	// 821AAD3C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AAD40; continue 'dispatch;
            }
            0x821AAD40 => {
    //   block [0x821AAD40..0x821AAD64)
	// 821AAD40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AAD44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAD48: 409A001C  bne cr6, 0x821aad64
	if !ctx.cr[6].eq {
	pc = 0x821AAD64; continue 'dispatch;
	}
	// 821AAD4C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AAD50: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AAD54: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AAD58: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AAD5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAD60: 48000018  b 0x821aad78
	pc = 0x821AAD78; continue 'dispatch;
            }
            0x821AAD64 => {
    //   block [0x821AAD64..0x821AAD74)
	// 821AAD64: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AAD68: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AAD6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAD70: 48000008  b 0x821aad78
	pc = 0x821AAD78; continue 'dispatch;
            }
            0x821AAD74 => {
    //   block [0x821AAD74..0x821AAD78)
	// 821AAD74: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x821AAD78; continue 'dispatch;
            }
            0x821AAD78 => {
    //   block [0x821AAD78..0x821AADDC)
	// 821AAD78: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821AAD7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AAD80: 419A0158  beq cr6, 0x821aaed8
	if ctx.cr[6].eq {
	pc = 0x821AAED8; continue 'dispatch;
	}
	// 821AAD84: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AAD88: 483B6699  bl 0x82561420
	ctx.lr = 0x821AAD8C;
	sub_82561420(ctx, base);
	// 821AAD8C: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 821AAD90: 409A0148  bne cr6, 0x821aaed8
	if !ctx.cr[6].eq {
	pc = 0x821AAED8; continue 'dispatch;
	}
	// 821AAD94: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821AAD98: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 821AAD9C: 480C1965  bl 0x8226c700
	ctx.lr = 0x821AADA0;
	sub_8226C700(ctx, base);
	// 821AADA0: 89630024  lbz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AADA4: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821AADA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AADAC: 419A00F4  beq cr6, 0x821aaea0
	if ctx.cr[6].eq {
	pc = 0x821AAEA0; continue 'dispatch;
	}
	// 821AADB0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AADB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AADB8: 419A0024  beq cr6, 0x821aaddc
	if ctx.cr[6].eq {
	pc = 0x821AADDC; continue 'dispatch;
	}
	// 821AADBC: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821AADC0: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AADC4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821AADC8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AADCC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AADD0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AADD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AADD8: 480000CC  b 0x821aaea4
	pc = 0x821AAEA4; continue 'dispatch;
            }
            0x821AADDC => {
    //   block [0x821AADDC..0x821AADF8)
	// 821AADDC: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AADE0: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AADE4: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 821AADE8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AADEC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AADF0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AADF4: 40810054  ble 0x821aae48
	if !ctx.cr[0].gt {
	pc = 0x821AAE48; continue 'dispatch;
	}
	pc = 0x821AADF8; continue 'dispatch;
            }
            0x821AADF8 => {
    //   block [0x821AADF8..0x821AAE18)
	// 821AADF8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AADFC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AAE00: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AAE04: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAE08: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 821AAE0C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AAE10: 41980008  blt cr6, 0x821aae18
	if ctx.cr[6].lt {
	pc = 0x821AAE18; continue 'dispatch;
	}
	// 821AAE14: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x821AAE18; continue 'dispatch;
            }
            0x821AAE18 => {
    //   block [0x821AAE18..0x821AAE34)
	// 821AAE18: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AAE1C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AAE20: 419A0014  beq cr6, 0x821aae34
	if ctx.cr[6].eq {
	pc = 0x821AAE34; continue 'dispatch;
	}
	// 821AAE24: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AAE28: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AAE2C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AAE30: 4800000C  b 0x821aae3c
	pc = 0x821AAE3C; continue 'dispatch;
            }
            0x821AAE34 => {
    //   block [0x821AAE34..0x821AAE3C)
	// 821AAE34: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AAE38: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AAE3C; continue 'dispatch;
            }
            0x821AAE3C => {
    //   block [0x821AAE3C..0x821AAE48)
	// 821AAE3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AAE40: 4199FFB8  bgt cr6, 0x821aadf8
	if ctx.cr[6].gt {
	pc = 0x821AADF8; continue 'dispatch;
	}
	// 821AAE44: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821AAE48; continue 'dispatch;
            }
            0x821AAE48 => {
    //   block [0x821AAE48..0x821AAE64)
	// 821AAE48: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AAE4C: 419A0040  beq cr6, 0x821aae8c
	if ctx.cr[6].eq {
	pc = 0x821AAE8C; continue 'dispatch;
	}
	// 821AAE50: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAE54: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 821AAE58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AAE5C: 41990008  bgt cr6, 0x821aae64
	if ctx.cr[6].gt {
	pc = 0x821AAE64; continue 'dispatch;
	}
	// 821AAE60: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AAE64; continue 'dispatch;
            }
            0x821AAE64 => {
    //   block [0x821AAE64..0x821AAE8C)
	// 821AAE64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AAE68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAE6C: 409A0020  bne cr6, 0x821aae8c
	if !ctx.cr[6].eq {
	pc = 0x821AAE8C; continue 'dispatch;
	}
	// 821AAE70: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AAE74: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AAE78: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AAE7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAE80: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AAE84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AAE88: 4800001C  b 0x821aaea4
	pc = 0x821AAEA4; continue 'dispatch;
            }
            0x821AAE8C => {
    //   block [0x821AAE8C..0x821AAEA0)
	// 821AAE8C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AAE90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAE94: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AAE98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AAE9C: 48000008  b 0x821aaea4
	pc = 0x821AAEA4; continue 'dispatch;
            }
            0x821AAEA0 => {
    //   block [0x821AAEA0..0x821AAEA4)
	// 821AAEA0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AAEA4; continue 'dispatch;
            }
            0x821AAEA4 => {
    //   block [0x821AAEA4..0x821AAED8)
	// 821AAEA4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AAEA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAEAC: 419A002C  beq cr6, 0x821aaed8
	if ctx.cr[6].eq {
	pc = 0x821AAED8; continue 'dispatch;
	}
	// 821AAEB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821AAEB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AAEB8: 4834FB01  bl 0x824fa9b8
	ctx.lr = 0x821AAEBC;
	sub_824FA9B8(ctx, base);
	// 821AAEBC: 48205B7D  bl 0x823b0a38
	ctx.lr = 0x821AAEC0;
	sub_823B0A38(ctx, base);
	// 821AAEC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821AAEC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AAEC8: 48350621  bl 0x824fb4e8
	ctx.lr = 0x821AAECC;
	sub_824FB4E8(ctx, base);
	// 821AAECC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821AAED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AAED4: 48069F05  bl 0x82214dd8
	ctx.lr = 0x821AAED8;
	sub_82214DD8(ctx, base);
	pc = 0x821AAED8; continue 'dispatch;
            }
            0x821AAED8 => {
    //   block [0x821AAED8..0x821AAF24)
	// 821AAED8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821AAEDC: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 821AAEE0: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 821AAEE4: 480C181D  bl 0x8226c700
	ctx.lr = 0x821AAEE8;
	sub_8226C700(ctx, base);
	// 821AAEE8: 89630030  lbz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAEEC: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821AAEF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AAEF4: 419A00F0  beq cr6, 0x821aafe4
	if ctx.cr[6].eq {
	pc = 0x821AAFE4; continue 'dispatch;
	}
	// 821AAEF8: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AAEFC: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AAF00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAF04: 419A0020  beq cr6, 0x821aaf24
	if ctx.cr[6].eq {
	pc = 0x821AAF24; continue 'dispatch;
	}
	// 821AAF08: 896B0078  lbz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 821AAF0C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821AAF10: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AAF14: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAF18: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AAF1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AAF20: 480000C8  b 0x821aafe8
	pc = 0x821AAFE8; continue 'dispatch;
            }
            0x821AAF24 => {
    //   block [0x821AAF24..0x821AAF3C)
	// 821AAF24: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AAF28: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 821AAF2C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AAF30: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821AAF34: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AAF38: 40810054  ble 0x821aaf8c
	if !ctx.cr[0].gt {
	pc = 0x821AAF8C; continue 'dispatch;
	}
	pc = 0x821AAF3C; continue 'dispatch;
            }
            0x821AAF3C => {
    //   block [0x821AAF3C..0x821AAF5C)
	// 821AAF3C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AAF40: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AAF44: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AAF48: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAF4C: 2F070078  cmpwi cr6, r7, 0x78
	ctx.cr[6].compare_i32(ctx.r[7].s32, 120, &mut ctx.xer);
	// 821AAF50: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AAF54: 41980008  blt cr6, 0x821aaf5c
	if ctx.cr[6].lt {
	pc = 0x821AAF5C; continue 'dispatch;
	}
	// 821AAF58: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x821AAF5C; continue 'dispatch;
            }
            0x821AAF5C => {
    //   block [0x821AAF5C..0x821AAF78)
	// 821AAF5C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AAF60: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AAF64: 419A0014  beq cr6, 0x821aaf78
	if ctx.cr[6].eq {
	pc = 0x821AAF78; continue 'dispatch;
	}
	// 821AAF68: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AAF6C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AAF70: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AAF74: 4800000C  b 0x821aaf80
	pc = 0x821AAF80; continue 'dispatch;
            }
            0x821AAF78 => {
    //   block [0x821AAF78..0x821AAF80)
	// 821AAF78: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AAF7C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AAF80; continue 'dispatch;
            }
            0x821AAF80 => {
    //   block [0x821AAF80..0x821AAF8C)
	// 821AAF80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AAF84: 4199FFB8  bgt cr6, 0x821aaf3c
	if ctx.cr[6].gt {
	pc = 0x821AAF3C; continue 'dispatch;
	}
	// 821AAF88: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x821AAF8C; continue 'dispatch;
            }
            0x821AAF8C => {
    //   block [0x821AAF8C..0x821AAFA8)
	// 821AAF8C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AAF90: 419A0040  beq cr6, 0x821aafd0
	if ctx.cr[6].eq {
	pc = 0x821AAFD0; continue 'dispatch;
	}
	// 821AAF94: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAF98: 2F0B0078  cmpwi cr6, r11, 0x78
	ctx.cr[6].compare_i32(ctx.r[11].s32, 120, &mut ctx.xer);
	// 821AAF9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AAFA0: 41990008  bgt cr6, 0x821aafa8
	if ctx.cr[6].gt {
	pc = 0x821AAFA8; continue 'dispatch;
	}
	// 821AAFA4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AAFA8; continue 'dispatch;
            }
            0x821AAFA8 => {
    //   block [0x821AAFA8..0x821AAFD0)
	// 821AAFA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AAFAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAFB0: 409A0020  bne cr6, 0x821aafd0
	if !ctx.cr[6].eq {
	pc = 0x821AAFD0; continue 'dispatch;
	}
	// 821AAFB4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821AAFB8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AAFBC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AAFC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAFC4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AAFC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AAFCC: 4800001C  b 0x821aafe8
	pc = 0x821AAFE8; continue 'dispatch;
            }
            0x821AAFD0 => {
    //   block [0x821AAFD0..0x821AAFE4)
	// 821AAFD0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AAFD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAFD8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AAFDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AAFE0: 48000008  b 0x821aafe8
	pc = 0x821AAFE8; continue 'dispatch;
            }
            0x821AAFE4 => {
    //   block [0x821AAFE4..0x821AAFE8)
	// 821AAFE4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AAFE8; continue 'dispatch;
            }
            0x821AAFE8 => {
    //   block [0x821AAFE8..0x821AB008)
	// 821AAFE8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AAFEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAFF0: 419A001C  beq cr6, 0x821ab00c
	if ctx.cr[6].eq {
	pc = 0x821AB00C; continue 'dispatch;
	}
	// 821AAFF4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AAFF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AAFFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AB000: 41990008  bgt cr6, 0x821ab008
	if ctx.cr[6].gt {
	pc = 0x821AB008; continue 'dispatch;
	}
	// 821AB004: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AB008; continue 'dispatch;
            }
            0x821AB008 => {
    //   block [0x821AB008..0x821AB00C)
	// 821AB008: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x821AB00C; continue 'dispatch;
            }
            0x821AB00C => {
    //   block [0x821AB00C..0x821AB028)
	// 821AB00C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821AB010: 419A0018  beq cr6, 0x821ab028
	if ctx.cr[6].eq {
	pc = 0x821AB028; continue 'dispatch;
	}
	// 821AB014: 897D0090  lbz r11, 0x90(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 821AB018: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AB01C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AB020: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AB024: 409A0008  bne cr6, 0x821ab02c
	if !ctx.cr[6].eq {
	pc = 0x821AB02C; continue 'dispatch;
	}
	pc = 0x821AB028; continue 'dispatch;
            }
            0x821AB028 => {
    //   block [0x821AB028..0x821AB02C)
	// 821AB028: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AB02C; continue 'dispatch;
            }
            0x821AB02C => {
    //   block [0x821AB02C..0x821AB080)
	// 821AB02C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AB030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB034: 419A040C  beq cr6, 0x821ab440
	if ctx.cr[6].eq {
	pc = 0x821AB440; continue 'dispatch;
	}
	// 821AB038: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821AB03C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821AB040: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AB044: 4812AF15  bl 0x822d5f58
	ctx.lr = 0x821AB048;
	sub_822D5F58(ctx, base);
	// 821AB048: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 821AB04C: 4807420D  bl 0x8221f258
	ctx.lr = 0x821AB050;
	sub_8221F258(ctx, base);
	// 821AB050: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AB054: 419A002C  beq cr6, 0x821ab080
	if ctx.cr[6].eq {
	pc = 0x821AB080; continue 'dispatch;
	}
	// 821AB058: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821AB05C: 88F80031  lbz r7, 0x31(r24)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(49 as u32) ) } as u64;
	// 821AB060: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821AB064: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821AB068: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821AB06C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AB070: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821AB074: 484D9C55  bl 0x82684cc8
	ctx.lr = 0x821AB078;
	sub_82684CC8(ctx, base);
	// 821AB078: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AB07C: 48000008  b 0x821ab084
	pc = 0x821AB084; continue 'dispatch;
            }
            0x821AB080 => {
    //   block [0x821AB080..0x821AB084)
	// 821AB080: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	pc = 0x821AB084; continue 'dispatch;
            }
            0x821AB084 => {
    //   block [0x821AB084..0x821AB0C0)
	// 821AB084: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 821AB088: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AB08C: 419A0034  beq cr6, 0x821ab0c0
	if ctx.cr[6].eq {
	pc = 0x821AB0C0; continue 'dispatch;
	}
	// 821AB090: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 821AB094: 480741C5  bl 0x8221f258
	ctx.lr = 0x821AB098;
	sub_8221F258(ctx, base);
	// 821AB098: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AB09C: 419A0024  beq cr6, 0x821ab0c0
	if ctx.cr[6].eq {
	pc = 0x821AB0C0; continue 'dispatch;
	}
	// 821AB0A0: 3D608269  lis r11, -0x7d97
	ctx.r[11].s64 = -2107047936;
	// 821AB0A4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 821AB0A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AB0AC: 392B82D8  addi r9, r11, -0x7d28
	ctx.r[9].s64 = ctx.r[11].s64 + -32040;
	// 821AB0B0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821AB0B4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AB0B8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AB0BC: 48000008  b 0x821ab0c4
	pc = 0x821AB0C4; continue 'dispatch;
            }
            0x821AB0C0 => {
    //   block [0x821AB0C0..0x821AB0C4)
	// 821AB0C0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AB0C4; continue 'dispatch;
            }
            0x821AB0C4 => {
    //   block [0x821AB0C4..0x821AB0D8)
	// 821AB0C4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821AB0C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB0CC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 821AB0D0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821AB0D4: 419A0020  beq cr6, 0x821ab0f4
	if ctx.cr[6].eq {
	pc = 0x821AB0F4; continue 'dispatch;
	}
	pc = 0x821AB0D8; continue 'dispatch;
            }
            0x821AB0D8 => {
    //   block [0x821AB0D8..0x821AB0F4)
	// 821AB0D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821AB0DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821AB0E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821AB0E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AB0E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821AB0EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821AB0F0: 4082FFE8  bne 0x821ab0d8
	if !ctx.cr[0].eq {
	pc = 0x821AB0D8; continue 'dispatch;
	}
	pc = 0x821AB0F4; continue 'dispatch;
            }
            0x821AB0F4 => {
    //   block [0x821AB0F4..0x821AB160)
	// 821AB0F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821AB0F8: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 821AB0FC: 4800CA1D  bl 0x821b7b18
	ctx.lr = 0x821AB100;
	sub_821B7B18(ctx, base);
	// 821AB100: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821AB104: 3878000C  addi r3, r24, 0xc
	ctx.r[3].s64 = ctx.r[24].s64 + 12;
	// 821AB108: 484B38A1  bl 0x8265e9a8
	ctx.lr = 0x821AB10C;
	sub_8265E9A8(ctx, base);
	// 821AB10C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821AB110: 4800CA09  bl 0x821b7b18
	ctx.lr = 0x821AB114;
	sub_821B7B18(ctx, base);
	// 821AB114: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821AB118: 38780040  addi r3, r24, 0x40
	ctx.r[3].s64 = ctx.r[24].s64 + 64;
	// 821AB11C: 480BA085  bl 0x822651a0
	ctx.lr = 0x821AB120;
	sub_822651A0(ctx, base);
	// 821AB120: 817D0038  lwz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AB124: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821AB128: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 821AB12C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AB130: 419A00F0  beq cr6, 0x821ab220
	if ctx.cr[6].eq {
	pc = 0x821AB220; continue 'dispatch;
	}
	// 821AB134: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AB138: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AB13C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB140: 419A0020  beq cr6, 0x821ab160
	if ctx.cr[6].eq {
	pc = 0x821AB160; continue 'dispatch;
	}
	// 821AB144: 896B00B3  lbz r11, 0xb3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(179 as u32) ) } as u64;
	// 821AB148: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821AB14C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AB150: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB154: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821AB158: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AB15C: 480000C8  b 0x821ab224
	pc = 0x821AB224; continue 'dispatch;
            }
            0x821AB160 => {
    //   block [0x821AB160..0x821AB178)
	// 821AB160: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AB164: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 821AB168: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AB16C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821AB170: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AB174: 40810054  ble 0x821ab1c8
	if !ctx.cr[0].gt {
	pc = 0x821AB1C8; continue 'dispatch;
	}
	pc = 0x821AB178; continue 'dispatch;
            }
            0x821AB178 => {
    //   block [0x821AB178..0x821AB198)
	// 821AB178: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AB17C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AB180: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AB184: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB188: 2F0700B3  cmpwi cr6, r7, 0xb3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 179, &mut ctx.xer);
	// 821AB18C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AB190: 41980008  blt cr6, 0x821ab198
	if ctx.cr[6].lt {
	pc = 0x821AB198; continue 'dispatch;
	}
	// 821AB194: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x821AB198; continue 'dispatch;
            }
            0x821AB198 => {
    //   block [0x821AB198..0x821AB1B4)
	// 821AB198: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AB19C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AB1A0: 419A0014  beq cr6, 0x821ab1b4
	if ctx.cr[6].eq {
	pc = 0x821AB1B4; continue 'dispatch;
	}
	// 821AB1A4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AB1A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AB1AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AB1B0: 4800000C  b 0x821ab1bc
	pc = 0x821AB1BC; continue 'dispatch;
            }
            0x821AB1B4 => {
    //   block [0x821AB1B4..0x821AB1BC)
	// 821AB1B4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AB1B8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AB1BC; continue 'dispatch;
            }
            0x821AB1BC => {
    //   block [0x821AB1BC..0x821AB1C8)
	// 821AB1BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AB1C0: 4199FFB8  bgt cr6, 0x821ab178
	if ctx.cr[6].gt {
	pc = 0x821AB178; continue 'dispatch;
	}
	// 821AB1C4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x821AB1C8; continue 'dispatch;
            }
            0x821AB1C8 => {
    //   block [0x821AB1C8..0x821AB1E4)
	// 821AB1C8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AB1CC: 419A0040  beq cr6, 0x821ab20c
	if ctx.cr[6].eq {
	pc = 0x821AB20C; continue 'dispatch;
	}
	// 821AB1D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB1D4: 2F0B00B3  cmpwi cr6, r11, 0xb3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 179, &mut ctx.xer);
	// 821AB1D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AB1DC: 41990008  bgt cr6, 0x821ab1e4
	if ctx.cr[6].gt {
	pc = 0x821AB1E4; continue 'dispatch;
	}
	// 821AB1E0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AB1E4; continue 'dispatch;
            }
            0x821AB1E4 => {
    //   block [0x821AB1E4..0x821AB20C)
	// 821AB1E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AB1E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB1EC: 409A0020  bne cr6, 0x821ab20c
	if !ctx.cr[6].eq {
	pc = 0x821AB20C; continue 'dispatch;
	}
	// 821AB1F0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821AB1F4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AB1F8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AB1FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB200: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821AB204: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AB208: 4800001C  b 0x821ab224
	pc = 0x821AB224; continue 'dispatch;
            }
            0x821AB20C => {
    //   block [0x821AB20C..0x821AB220)
	// 821AB20C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AB210: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB214: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821AB218: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AB21C: 48000008  b 0x821ab224
	pc = 0x821AB224; continue 'dispatch;
            }
            0x821AB220 => {
    //   block [0x821AB220..0x821AB224)
	// 821AB220: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AB224; continue 'dispatch;
            }
            0x821AB224 => {
    //   block [0x821AB224..0x821AB258)
	// 821AB224: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AB228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB22C: 419A0214  beq cr6, 0x821ab440
	if ctx.cr[6].eq {
	pc = 0x821AB440; continue 'dispatch;
	}
	// 821AB230: 80D80004  lwz r6, 4(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB234: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 821AB238: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 821AB23C: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 821AB240: 81260018  lwz r9, 0x18(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 821AB244: 80A6001C  lwz r5, 0x1c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AB248: 7D492850  subf r10, r9, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[9].s64;
	// 821AB24C: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821AB250: 7D6A5BD7  divw. r11, r10, r11
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AB254: 4081005C  ble 0x821ab2b0
	if !ctx.cr[0].gt {
	pc = 0x821AB2B0; continue 'dispatch;
	}
	pc = 0x821AB258; continue 'dispatch;
            }
            0x821AB258 => {
    //   block [0x821AB258..0x821AB280)
	// 821AB258: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AB25C: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AB260: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821AB264: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AB268: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821AB26C: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB270: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 821AB274: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AB278: 41980008  blt cr6, 0x821ab280
	if ctx.cr[6].lt {
	pc = 0x821AB280; continue 'dispatch;
	}
	// 821AB27C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x821AB280; continue 'dispatch;
            }
            0x821AB280 => {
    //   block [0x821AB280..0x821AB29C)
	// 821AB280: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AB284: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AB288: 419A0014  beq cr6, 0x821ab29c
	if ctx.cr[6].eq {
	pc = 0x821AB29C; continue 'dispatch;
	}
	// 821AB28C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821AB290: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 821AB294: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AB298: 4800000C  b 0x821ab2a4
	pc = 0x821AB2A4; continue 'dispatch;
            }
            0x821AB29C => {
    //   block [0x821AB29C..0x821AB2A4)
	// 821AB29C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821AB2A0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x821AB2A4; continue 'dispatch;
            }
            0x821AB2A4 => {
    //   block [0x821AB2A4..0x821AB2B0)
	// 821AB2A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AB2A8: 4199FFB0  bgt cr6, 0x821ab258
	if ctx.cr[6].gt {
	pc = 0x821AB258; continue 'dispatch;
	}
	// 821AB2AC: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	pc = 0x821AB2B0; continue 'dispatch;
            }
            0x821AB2B0 => {
    //   block [0x821AB2B0..0x821AB2CC)
	// 821AB2B0: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821AB2B4: 419A0034  beq cr6, 0x821ab2e8
	if ctx.cr[6].eq {
	pc = 0x821AB2E8; continue 'dispatch;
	}
	// 821AB2B8: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB2BC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821AB2C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AB2C4: 41990008  bgt cr6, 0x821ab2cc
	if ctx.cr[6].gt {
	pc = 0x821AB2CC; continue 'dispatch;
	}
	// 821AB2C8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AB2CC; continue 'dispatch;
            }
            0x821AB2CC => {
    //   block [0x821AB2CC..0x821AB2E8)
	// 821AB2CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AB2D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB2D4: 409A0014  bne cr6, 0x821ab2e8
	if !ctx.cr[6].eq {
	pc = 0x821AB2E8; continue 'dispatch;
	}
	// 821AB2D8: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821AB2DC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AB2E0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AB2E4: 48000008  b 0x821ab2ec
	pc = 0x821AB2EC; continue 'dispatch;
            }
            0x821AB2E8 => {
    //   block [0x821AB2E8..0x821AB2EC)
	// 821AB2E8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x821AB2EC; continue 'dispatch;
            }
            0x821AB2EC => {
    //   block [0x821AB2EC..0x821AB304)
	// 821AB2EC: 8146001C  lwz r10, 0x1c(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AB2F0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AB2F4: 419A0010  beq cr6, 0x821ab304
	if ctx.cr[6].eq {
	pc = 0x821AB304; continue 'dispatch;
	}
	// 821AB2F8: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB2FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AB300: 48000008  b 0x821ab308
	pc = 0x821AB308; continue 'dispatch;
            }
            0x821AB304 => {
    //   block [0x821AB304..0x821AB308)
	// 821AB304: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AB308; continue 'dispatch;
            }
            0x821AB308 => {
    //   block [0x821AB308..0x821AB360)
	// 821AB308: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AB30C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB310: 419A0130  beq cr6, 0x821ab440
	if ctx.cr[6].eq {
	pc = 0x821AB440; continue 'dispatch;
	}
	// 821AB314: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821AB318: C3E40014  lfs f31, 0x14(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821AB31C: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 821AB320: 480C13E1  bl 0x8226c700
	ctx.lr = 0x821AB324;
	sub_8226C700(ctx, base);
	// 821AB324: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821AB328: 556A3FFE  rlwinm r10, r11, 7, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x01FFFFFFu64;
	// 821AB32C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AB330: 419A00F0  beq cr6, 0x821ab420
	if ctx.cr[6].eq {
	pc = 0x821AB420; continue 'dispatch;
	}
	// 821AB334: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AB338: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AB33C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB340: 419A0020  beq cr6, 0x821ab360
	if ctx.cr[6].eq {
	pc = 0x821AB360; continue 'dispatch;
	}
	// 821AB344: 896B0039  lbz r11, 0x39(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 821AB348: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821AB34C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AB350: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB354: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AB358: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AB35C: 480000C8  b 0x821ab424
	pc = 0x821AB424; continue 'dispatch;
            }
            0x821AB360 => {
    //   block [0x821AB360..0x821AB378)
	// 821AB360: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AB364: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 821AB368: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AB36C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821AB370: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AB374: 40810054  ble 0x821ab3c8
	if !ctx.cr[0].gt {
	pc = 0x821AB3C8; continue 'dispatch;
	}
	pc = 0x821AB378; continue 'dispatch;
            }
            0x821AB378 => {
    //   block [0x821AB378..0x821AB398)
	// 821AB378: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AB37C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AB380: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AB384: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB388: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 821AB38C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AB390: 41980008  blt cr6, 0x821ab398
	if ctx.cr[6].lt {
	pc = 0x821AB398; continue 'dispatch;
	}
	// 821AB394: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x821AB398; continue 'dispatch;
            }
            0x821AB398 => {
    //   block [0x821AB398..0x821AB3B4)
	// 821AB398: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AB39C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AB3A0: 419A0014  beq cr6, 0x821ab3b4
	if ctx.cr[6].eq {
	pc = 0x821AB3B4; continue 'dispatch;
	}
	// 821AB3A4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AB3A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AB3AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AB3B0: 4800000C  b 0x821ab3bc
	pc = 0x821AB3BC; continue 'dispatch;
            }
            0x821AB3B4 => {
    //   block [0x821AB3B4..0x821AB3BC)
	// 821AB3B4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AB3B8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AB3BC; continue 'dispatch;
            }
            0x821AB3BC => {
    //   block [0x821AB3BC..0x821AB3C8)
	// 821AB3BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AB3C0: 4199FFB8  bgt cr6, 0x821ab378
	if ctx.cr[6].gt {
	pc = 0x821AB378; continue 'dispatch;
	}
	// 821AB3C4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x821AB3C8; continue 'dispatch;
            }
            0x821AB3C8 => {
    //   block [0x821AB3C8..0x821AB3E4)
	// 821AB3C8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AB3CC: 419A0040  beq cr6, 0x821ab40c
	if ctx.cr[6].eq {
	pc = 0x821AB40C; continue 'dispatch;
	}
	// 821AB3D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB3D4: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 821AB3D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AB3DC: 41990008  bgt cr6, 0x821ab3e4
	if ctx.cr[6].gt {
	pc = 0x821AB3E4; continue 'dispatch;
	}
	// 821AB3E0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AB3E4; continue 'dispatch;
            }
            0x821AB3E4 => {
    //   block [0x821AB3E4..0x821AB40C)
	// 821AB3E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AB3E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB3EC: 409A0020  bne cr6, 0x821ab40c
	if !ctx.cr[6].eq {
	pc = 0x821AB40C; continue 'dispatch;
	}
	// 821AB3F0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821AB3F4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AB3F8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AB3FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB400: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AB404: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AB408: 4800001C  b 0x821ab424
	pc = 0x821AB424; continue 'dispatch;
            }
            0x821AB40C => {
    //   block [0x821AB40C..0x821AB420)
	// 821AB40C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AB410: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB414: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AB418: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AB41C: 48000008  b 0x821ab424
	pc = 0x821AB424; continue 'dispatch;
            }
            0x821AB420 => {
    //   block [0x821AB420..0x821AB424)
	// 821AB420: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AB424; continue 'dispatch;
            }
            0x821AB424 => {
    //   block [0x821AB424..0x821AB43C)
	// 821AB424: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AB428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB42C: 419A0010  beq cr6, 0x821ab43c
	if ctx.cr[6].eq {
	pc = 0x821AB43C; continue 'dispatch;
	}
	// 821AB430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AB434: 48339EED  bl 0x824e5320
	ctx.lr = 0x821AB438;
	sub_824E5320(ctx, base);
	// 821AB438: EFE107F2  fmuls f31, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x821AB43C; continue 'dispatch;
            }
            0x821AB43C => {
    //   block [0x821AB43C..0x821AB440)
	// 821AB43C: D3FE0014  stfs f31, 0x14(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x821AB440; continue 'dispatch;
            }
            0x821AB440 => {
    //   block [0x821AB440..0x821AB450)
	// 821AB440: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821AB444: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821AB448: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821AB44C: 48AFDFFC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AB450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AB450 size=144
    let mut pc: u32 = 0x821AB450;
    'dispatch: loop {
        match pc {
            0x821AB450 => {
    //   block [0x821AB450..0x821AB464)
	// 821AB450: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821AB454: 40990010  ble cr6, 0x821ab464
	if !ctx.cr[6].gt {
	pc = 0x821AB464; continue 'dispatch;
	}
	// 821AB458: 2F040015  cmpwi cr6, r4, 0x15
	ctx.cr[6].compare_i32(ctx.r[4].s32, 21, &mut ctx.xer);
	// 821AB45C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AB460: 40990008  ble cr6, 0x821ab468
	if !ctx.cr[6].gt {
	pc = 0x821AB468; continue 'dispatch;
	}
	pc = 0x821AB464; continue 'dispatch;
            }
            0x821AB464 => {
    //   block [0x821AB464..0x821AB468)
	// 821AB464: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AB468; continue 'dispatch;
            }
            0x821AB468 => {
    //   block [0x821AB468..0x821AB488)
	// 821AB468: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AB46C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB470: 409A0068  bne cr6, 0x821ab4d8
	if !ctx.cr[6].eq {
	pc = 0x821AB4D8; continue 'dispatch;
	}
	// 821AB474: 2F040026  cmpwi cr6, r4, 0x26
	ctx.cr[6].compare_i32(ctx.r[4].s32, 38, &mut ctx.xer);
	// 821AB478: 41980010  blt cr6, 0x821ab488
	if ctx.cr[6].lt {
	pc = 0x821AB488; continue 'dispatch;
	}
	// 821AB47C: 2F040027  cmpwi cr6, r4, 0x27
	ctx.cr[6].compare_i32(ctx.r[4].s32, 39, &mut ctx.xer);
	// 821AB480: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AB484: 40990008  ble cr6, 0x821ab48c
	if !ctx.cr[6].gt {
	pc = 0x821AB48C; continue 'dispatch;
	}
	pc = 0x821AB488; continue 'dispatch;
            }
            0x821AB488 => {
    //   block [0x821AB488..0x821AB48C)
	// 821AB488: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AB48C; continue 'dispatch;
            }
            0x821AB48C => {
    //   block [0x821AB48C..0x821AB4AC)
	// 821AB48C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AB490: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB494: 409A0044  bne cr6, 0x821ab4d8
	if !ctx.cr[6].eq {
	pc = 0x821AB4D8; continue 'dispatch;
	}
	// 821AB498: 2F040028  cmpwi cr6, r4, 0x28
	ctx.cr[6].compare_i32(ctx.r[4].s32, 40, &mut ctx.xer);
	// 821AB49C: 41980010  blt cr6, 0x821ab4ac
	if ctx.cr[6].lt {
	pc = 0x821AB4AC; continue 'dispatch;
	}
	// 821AB4A0: 2F040031  cmpwi cr6, r4, 0x31
	ctx.cr[6].compare_i32(ctx.r[4].s32, 49, &mut ctx.xer);
	// 821AB4A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AB4A8: 40990008  ble cr6, 0x821ab4b0
	if !ctx.cr[6].gt {
	pc = 0x821AB4B0; continue 'dispatch;
	}
	pc = 0x821AB4AC; continue 'dispatch;
            }
            0x821AB4AC => {
    //   block [0x821AB4AC..0x821AB4B0)
	// 821AB4AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AB4B0; continue 'dispatch;
            }
            0x821AB4B0 => {
    //   block [0x821AB4B0..0x821AB4D8)
	// 821AB4B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AB4B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB4B8: 409A0020  bne cr6, 0x821ab4d8
	if !ctx.cr[6].eq {
	pc = 0x821AB4D8; continue 'dispatch;
	}
	// 821AB4BC: 2F040024  cmpwi cr6, r4, 0x24
	ctx.cr[6].compare_i32(ctx.r[4].s32, 36, &mut ctx.xer);
	// 821AB4C0: 419A0018  beq cr6, 0x821ab4d8
	if ctx.cr[6].eq {
	pc = 0x821AB4D8; continue 'dispatch;
	}
	// 821AB4C4: 2F040025  cmpwi cr6, r4, 0x25
	ctx.cr[6].compare_i32(ctx.r[4].s32, 37, &mut ctx.xer);
	// 821AB4C8: 419A0010  beq cr6, 0x821ab4d8
	if ctx.cr[6].eq {
	pc = 0x821AB4D8; continue 'dispatch;
	}
	// 821AB4CC: 2F040036  cmpwi cr6, r4, 0x36
	ctx.cr[6].compare_i32(ctx.r[4].s32, 54, &mut ctx.xer);
	// 821AB4D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AB4D4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x821AB4D8; continue 'dispatch;
            }
            0x821AB4D8 => {
    //   block [0x821AB4D8..0x821AB4E0)
	// 821AB4D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AB4DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AB4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AB4E0 size=148
    let mut pc: u32 = 0x821AB4E0;
    'dispatch: loop {
        match pc {
            0x821AB4E0 => {
    //   block [0x821AB4E0..0x821AB560)
	// 821AB4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AB4E4: 48AFDF29  bl 0x82ca940c
	ctx.lr = 0x821AB4E8;
	sub_82CA93D0(ctx, base);
	// 821AB4E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AB4EC: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 821AB4F0: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 821AB4F4: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 821AB4F8: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 821AB4FC: 3941006C  addi r10, r1, 0x6c
	ctx.r[10].s64 = ctx.r[1].s64 + 108;
	// 821AB500: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 821AB504: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821AB508: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821AB50C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821AB510: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AB514: 480CCC25  bl 0x82278138
	ctx.lr = 0x821AB518;
	sub_82278138(ctx, base);
	// 821AB518: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821AB51C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AB520: 419A0040  beq cr6, 0x821ab560
	if ctx.cr[6].eq {
	pc = 0x821AB560; continue 'dispatch;
	}
	// 821AB524: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821AB528: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AB52C: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB530: 396B6F08  addi r11, r11, 0x6f08
	ctx.r[11].s64 = ctx.r[11].s64 + 28424;
	// 821AB534: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB538: 554A0E7C  rlwinm r10, r10, 1, 0x19, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 821AB53C: 80C10060  lwz r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821AB540: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 821AB544: 7D6749D6  mullw r11, r7, r9
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AB548: 7D4A28AE  lbzx r10, r10, r5
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 821AB54C: 7D4A41D6  mullw r10, r10, r8
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821AB550: 554AE8FE  srwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AB554: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AB558: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 821AB55C: 48000008  b 0x821ab564
	pc = 0x821AB564; continue 'dispatch;
            }
            0x821AB560 => {
    //   block [0x821AB560..0x821AB564)
	// 821AB560: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	pc = 0x821AB564; continue 'dispatch;
            }
            0x821AB564 => {
    //   block [0x821AB564..0x821AB574)
	// 821AB564: 913D0000  stw r9, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821AB568: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821AB56C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821AB570: 48AFDEEC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AB578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AB578 size=136
    let mut pc: u32 = 0x821AB578;
    'dispatch: loop {
        match pc {
            0x821AB578 => {
    //   block [0x821AB578..0x821AB600)
	// 821AB578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AB57C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AB580: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AB584: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AB588: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821AB58C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AB590: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 821AB594: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AB598: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AB59C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821AB5A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AB5A4: 4BFE8895  bl 0x82193e38
	ctx.lr = 0x821AB5A8;
	sub_82193E38(ctx, base);
	// 821AB5A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821AB5AC: 387F014C  addi r3, r31, 0x14c
	ctx.r[3].s64 = ctx.r[31].s64 + 332;
	// 821AB5B0: 48326919  bl 0x824d1ec8
	ctx.lr = 0x821AB5B4;
	sub_824D1EC8(ctx, base);
	// 821AB5B4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 821AB5B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AB5BC: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 821AB5C0: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 821AB5C4: 4BFE8875  bl 0x82193e38
	ctx.lr = 0x821AB5C8;
	sub_82193E38(ctx, base);
	// 821AB5C8: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 821AB5CC: 38C004B0  li r6, 0x4b0
	ctx.r[6].s64 = 1200;
	// 821AB5D0: 38A004C0  li r5, 0x4c0
	ctx.r[5].s64 = 1216;
	// 821AB5D4: 388004D0  li r4, 0x4d0
	ctx.r[4].s64 = 1232;
	// 821AB5D8: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 821AB5DC: 907F009C  stw r3, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[3].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AB600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AB600 size=1176
    let mut pc: u32 = 0x821AB600;
    'dispatch: loop {
        match pc {
            0x821AB600 => {
    //   block [0x821AB600..0x821AB628)
	// 821AB600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AB604: 48AFDDE9  bl 0x82ca93ec
	ctx.lr = 0x821AB608;
	sub_82CA93D0(ctx, base);
	// 821AB608: DBC1FF90  stfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 821AB60C: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 821AB610: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AB614: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 821AB618: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 821AB61C: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 821AB620: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 821AB624: 409A0018  bne cr6, 0x821ab63c
	if !ctx.cr[6].eq {
	pc = 0x821AB63C; continue 'dispatch;
	}
	pc = 0x821AB628; continue 'dispatch;
            }
            0x821AB628 => {
    //   block [0x821AB628..0x821AB63C)
	// 821AB628: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AB62C: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 821AB630: CBC1FF90  lfd f30, -0x70(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 821AB634: CBE1FF98  lfd f31, -0x68(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 821AB638: 48AFDE04  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821AB63C => {
    //   block [0x821AB63C..0x821AB688)
	// 821AB63C: 817500B0  lwz r11, 0xb0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(176 as u32) ) } as u64;
	// 821AB640: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821AB644: 4198FFE4  blt cr6, 0x821ab628
	if ctx.cr[6].lt {
	pc = 0x821AB628; continue 'dispatch;
	}
	// 821AB648: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 821AB64C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821AB650: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 821AB654: 3AE00008  li r23, 8
	ctx.r[23].s64 = 8;
	// 821AB658: 393606B0  addi r9, r22, 0x6b0
	ctx.r[9].s64 = ctx.r[22].s64 + 1712;
	// 821AB65C: 817F0364  lwz r11, 0x364(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821AB660: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 821AB664: 814A10C0  lwz r10, 0x10c0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4288 as u32) ) } as u64;
	// 821AB668: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 821AB66C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821AB670: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 821AB674: E8640010  ld r3, 0x10(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	// 821AB678: 646B0008  oris r11, r3, 8
	ctx.r[11].u64 = ctx.r[3].u64 | 524288;
	// 821AB67C: 914570B8  stw r10, 0x70b8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 821AB680: F9640010  std r11, 0x10(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821AB684: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x821AB688; continue 'dispatch;
            }
            0x821AB688 => {
    //   block [0x821AB688..0x821AB6E4)
	// 821AB688: E9690000  ld r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821AB68C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821AB690: F9680000  std r11, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821AB694: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 821AB698: 4200FFF0  bdnz 0x821ab688
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821AB688; continue 'dispatch;
	}
	// 821AB69C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821AB6A0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821AB6A4: 480C562D  bl 0x82270cd0
	ctx.lr = 0x821AB6A8;
	sub_82270CD0(ctx, base);
	// 821AB6A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821AB6AC: 38600162  li r3, 0x162
	ctx.r[3].s64 = 354;
	// 821AB6B0: 4801CA61  bl 0x821c8110
	ctx.lr = 0x821AB6B4;
	sub_821C8110(ctx, base);
	// 821AB6B4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821AB6B8: E96B1760  ld r11, 0x1760(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5984 as u32) ) };
	// 821AB6BC: 796A0004  rldicr r10, r11, 0, 0
	ctx.r[10].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 821AB6C0: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 821AB6C4: 419A0020  beq cr6, 0x821ab6e4
	if ctx.cr[6].eq {
	pc = 0x821AB6E4; continue 'dispatch;
	}
	// 821AB6C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AB6CC: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821AB6D0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821AB6D4: 78E7FFE6  rldicr r7, r7, 0x3f, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821AB6D8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821AB6DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821AB6E0: 4806F1A1  bl 0x8221a880
	ctx.lr = 0x821AB6E4;
	sub_8221A880(ctx, base);
	pc = 0x821AB6E4; continue 'dispatch;
            }
            0x821AB6E4 => {
    //   block [0x821AB6E4..0x821ABA98)
	// 821AB6E4: 39600690  li r11, 0x690
	ctx.r[11].s64 = 1680;
	// 821AB6E8: 38600126  li r3, 0x126
	ctx.r[3].s64 = 294;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ABA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ABA98 size=452
    let mut pc: u32 = 0x821ABA98;
    'dispatch: loop {
        match pc {
            0x821ABA98 => {
    //   block [0x821ABA98..0x821ABAE0)
	// 821ABA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ABA9C: 48AFD969  bl 0x82ca9404
	ctx.lr = 0x821ABAA0;
	sub_82CA93D0(ctx, base);
	// 821ABAA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ABAA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821ABAA8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821ABAAC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821ABAB0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821ABAB4: 3BEBF9E4  addi r31, r11, -0x61c
	ctx.r[31].s64 = ctx.r[11].s64 + -1564;
	// 821ABAB8: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 821ABABC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821ABAC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821ABAC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821ABAC8: 488A7091  bl 0x82a52b58
	ctx.lr = 0x821ABACC;
	sub_82A52B58(ctx, base);
	// 821ABACC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821ABAD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ABAD4: 419A000C  beq cr6, 0x821abae0
	if ctx.cr[6].eq {
	pc = 0x821ABAE0; continue 'dispatch;
	}
	// 821ABAD8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821ABADC: 419A0008  beq cr6, 0x821abae4
	if ctx.cr[6].eq {
	pc = 0x821ABAE4; continue 'dispatch;
	}
	pc = 0x821ABAE0; continue 'dispatch;
            }
            0x821ABAE0 => {
    //   block [0x821ABAE0..0x821ABAE4)
	// 821ABAE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821ABAE4; continue 'dispatch;
            }
            0x821ABAE4 => {
    //   block [0x821ABAE4..0x821ABB00)
	// 821ABAE4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ABAE8: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821ABAEC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821ABAF0: 419A005C  beq cr6, 0x821abb4c
	if ctx.cr[6].eq {
	pc = 0x821ABB4C; continue 'dispatch;
	}
	// 821ABAF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ABAF8: 409A0008  bne cr6, 0x821abb00
	if !ctx.cr[6].eq {
	pc = 0x821ABB00; continue 'dispatch;
	}
	// 821ABAFC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821ABB00; continue 'dispatch;
            }
            0x821ABB00 => {
    //   block [0x821ABB00..0x821ABB10)
	// 821ABB00: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ABB04: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821ABB08: 409A0008  bne cr6, 0x821abb10
	if !ctx.cr[6].eq {
	pc = 0x821ABB10; continue 'dispatch;
	}
	// 821ABB0C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821ABB10; continue 'dispatch;
            }
            0x821ABB10 => {
    //   block [0x821ABB10..0x821ABB24)
	// 821ABB10: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821ABB14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ABB18: 419A0138  beq cr6, 0x821abc50
	if ctx.cr[6].eq {
	pc = 0x821ABC50; continue 'dispatch;
	}
	// 821ABB1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821ABB20: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x821ABB24; continue 'dispatch;
            }
            0x821ABB24 => {
    //   block [0x821ABB24..0x821ABB4C)
	// 821ABB24: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821ABB28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ABB2C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821ABB30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821ABB34: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821ABB38: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ABB3C: 4082FFE8  bne 0x821abb24
	if !ctx.cr[0].eq {
	pc = 0x821ABB24; continue 'dispatch;
	}
	// 821ABB40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821ABB44: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821ABB48: 48AFD90C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x821ABB4C => {
    //   block [0x821ABB4C..0x821ABB6C)
	// 821ABB4C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 821ABB50: 48073709  bl 0x8221f258
	ctx.lr = 0x821ABB54;
	sub_8221F258(ctx, base);
	// 821ABB54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ABB58: 419A0014  beq cr6, 0x821abb6c
	if ctx.cr[6].eq {
	pc = 0x821ABB6C; continue 'dispatch;
	}
	// 821ABB5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821ABB60: 488CE099  bl 0x82a79bf8
	ctx.lr = 0x821ABB64;
	sub_82A79BF8(ctx, base);
	// 821ABB64: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821ABB68: 48000008  b 0x821abb70
	pc = 0x821ABB70; continue 'dispatch;
            }
            0x821ABB6C => {
    //   block [0x821ABB6C..0x821ABB70)
	// 821ABB6C: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	pc = 0x821ABB70; continue 'dispatch;
            }
            0x821ABB70 => {
    //   block [0x821ABB70..0x821ABB80)
	// 821ABB70: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ABB74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ABB78: 419A003C  beq cr6, 0x821abbb4
	if ctx.cr[6].eq {
	pc = 0x821ABBB4; continue 'dispatch;
	}
	// 821ABB7C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821ABB80; continue 'dispatch;
            }
            0x821ABB80 => {
    //   block [0x821ABB80..0x821ABBB4)
	// 821ABB80: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821ABB84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ABB88: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821ABB8C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821ABB90: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821ABB94: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ABB98: 4082FFE8  bne 0x821abb80
	if !ctx.cr[0].eq {
	pc = 0x821ABB80; continue 'dispatch;
	}
	// 821ABB9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ABBA0: 409A0014  bne cr6, 0x821abbb4
	if !ctx.cr[6].eq {
	pc = 0x821ABBB4; continue 'dispatch;
	}
	// 821ABBA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ABBA8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ABBAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821ABBB0: 4E800421  bctrl
	ctx.lr = 0x821ABBB4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821ABBB4 => {
    //   block [0x821ABBB4..0x821ABBE8)
	// 821ABBB4: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 821ABBB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821ABBBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821ABBC0: 488A6981  bl 0x82a52540
	ctx.lr = 0x821ABBC4;
	sub_82A52540(ctx, base);
	// 821ABBC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ABBC8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ABBCC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ABBD0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821ABBD4: 419A007C  beq cr6, 0x821abc50
	if ctx.cr[6].eq {
	pc = 0x821ABC50; continue 'dispatch;
	}
	// 821ABBD8: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821ABBDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ABBE0: 419A0040  beq cr6, 0x821abc20
	if ctx.cr[6].eq {
	pc = 0x821ABC20; continue 'dispatch;
	}
	// 821ABBE4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821ABBE8; continue 'dispatch;
            }
            0x821ABBE8 => {
    //   block [0x821ABBE8..0x821ABC1C)
	// 821ABBE8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821ABBEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ABBF0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821ABBF4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821ABBF8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821ABBFC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ABC00: 4082FFE8  bne 0x821abbe8
	if !ctx.cr[0].eq {
	pc = 0x821ABBE8; continue 'dispatch;
	}
	// 821ABC04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ABC08: 409A0014  bne cr6, 0x821abc1c
	if !ctx.cr[6].eq {
	pc = 0x821ABC1C; continue 'dispatch;
	}
	// 821ABC0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ABC10: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ABC14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821ABC18: 4E800421  bctrl
	ctx.lr = 0x821ABC1C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821ABC1C => {
    //   block [0x821ABC1C..0x821ABC20)
	// 821ABC1C: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x821ABC20; continue 'dispatch;
            }
            0x821ABC20 => {
    //   block [0x821ABC20..0x821ABC34)
	// 821ABC20: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ABC24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ABC28: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821ABC2C: 419A0024  beq cr6, 0x821abc50
	if ctx.cr[6].eq {
	pc = 0x821ABC50; continue 'dispatch;
	}
	// 821ABC30: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x821ABC34; continue 'dispatch;
            }
            0x821ABC34 => {
    //   block [0x821ABC34..0x821ABC50)
	// 821ABC34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821ABC38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ABC3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821ABC40: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821ABC44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821ABC48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ABC4C: 4082FFE8  bne 0x821abc34
	if !ctx.cr[0].eq {
	pc = 0x821ABC34; continue 'dispatch;
	}
	pc = 0x821ABC50; continue 'dispatch;
            }
            0x821ABC50 => {
    //   block [0x821ABC50..0x821ABC5C)
	// 821ABC50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821ABC54: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821ABC58: 48AFD7FC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ABC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821ABC60 size=656
    let mut pc: u32 = 0x821ABC60;
    'dispatch: loop {
        match pc {
            0x821ABC60 => {
    //   block [0x821ABC60..0x821ABCC0)
	// 821ABC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ABC64: 48AFD785  bl 0x82ca93e8
	ctx.lr = 0x821ABC68;
	sub_82CA93D0(ctx, base);
	// 821ABC68: DBE1FF90  stfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 821ABC6C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ABC70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821ABC74: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821ABC78: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 821ABC7C: 7E96A378  mr r22, r20
	ctx.r[22].u64 = ctx.r[20].u64;
	// 821ABC80: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 821ABC84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ABC88: 917C0080  stw r11, 0x80(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821ABC8C: 409A008C  bne cr6, 0x821abd18
	if !ctx.cr[6].eq {
	pc = 0x821ABD18; continue 'dispatch;
	}
	// 821ABC90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821ABC94: 488CEEB5  bl 0x82a7ab48
	ctx.lr = 0x821ABC98;
	sub_82A7AB48(ctx, base);
	// 821ABC98: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821ABC9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821ABCA0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821ABCA4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821ABCA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821ABCAC: 48072E45  bl 0x8221eaf0
	ctx.lr = 0x821ABCB0;
	sub_8221EAF0(ctx, base);
	// 821ABCB0: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821ABCB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821ABCB8: 419A0044  beq cr6, 0x821abcfc
	if ctx.cr[6].eq {
	pc = 0x821ABCFC; continue 'dispatch;
	}
	// 821ABCBC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x821ABCC0; continue 'dispatch;
            }
            0x821ABCC0 => {
    //   block [0x821ABCC0..0x821ABCFC)
	// 821ABCC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821ABCC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ABCC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821ABCCC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821ABCD0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821ABCD4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ABCD8: 4082FFE8  bne 0x821abcc0
	if !ctx.cr[0].eq {
	pc = 0x821ABCC0; continue 'dispatch;
	}
	// 821ABCDC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821ABCE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ABCE4: 409A0018  bne cr6, 0x821abcfc
	if !ctx.cr[6].eq {
	pc = 0x821ABCFC; continue 'dispatch;
	}
	// 821ABCE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ABCEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821ABCF0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ABCF4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821ABCF8: 4E800421  bctrl
	ctx.lr = 0x821ABCFC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821ABCFC => {
    //   block [0x821ABCFC..0x821ABD18)
	// 821ABCFC: 817C0080  lwz r11, 0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 821ABD00: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821ABD04: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821ABD08: 917C0080  stw r11, 0x80(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821ABD0C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821ABD10: CBE1FF90  lfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 821ABD14: 48AFD724  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x821ABD18 => {
    //   block [0x821ABD18..0x821ABDA8)
	// 821ABD18: 3BDC0010  addi r30, r28, 0x10
	ctx.r[30].s64 = ctx.r[28].s64 + 16;
	// 821ABD1C: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821ABD20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821ABD24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821ABD28: 48AFDC89  bl 0x82ca99b0
	ctx.lr = 0x821ABD2C;
	sub_82CA99B0(ctx, base);
	// 821ABD2C: 817C0080  lwz r11, 0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 821ABD30: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 821ABD34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ABD38: 7EBAAB78  mr r26, r21
	ctx.r[26].u64 = ctx.r[21].u64;
	// 821ABD3C: 409901A4  ble cr6, 0x821abee0
	if !ctx.cr[6].gt {
	pc = 0x821ABEE0; continue 'dispatch;
	}
	// 821ABD40: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821ABD44: 3D007FFF  lis r8, 0x7fff
	ctx.r[8].s64 = 2147418112;
	// 821ABD48: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821ABD4C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821ABD50: 3BBC0070  addi r29, r28, 0x70
	ctx.r[29].s64 = ctx.r[28].s64 + 112;
	// 821ABD54: C3E99490  lfs f31, -0x6b70(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821ABD58: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 821ABD5C: 6119FFFF  ori r25, r8, 0xffff
	ctx.r[25].u64 = ctx.r[8].u64 | 65535;
	// 821ABD60: 3B0B9180  addi r24, r11, -0x6e80
	ctx.r[24].s64 = ctx.r[11].s64 + -28288;
	// 821ABD64: 3AEA9170  addi r23, r10, -0x6e90
	ctx.r[23].s64 = ctx.r[10].s64 + -28304;
	// 821ABD68: C01FFFF4  lfs f0, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABD6C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 821ABD70: D01DFFE0  stfs f0, -0x20(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 821ABD74: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ABD78: 7D690774  extsb r9, r11
	ctx.r[9].s64 = ctx.r[11].s8 as i64;
	// 821ABD7C: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 821ABD80: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821ABD84: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 821ABD88: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821ABD8C: D17D0000  stfs f11, 0(r29)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821ABD90: 40990018  ble cr6, 0x821abda8
	if !ctx.cr[6].gt {
	pc = 0x821ABDA8; continue 'dispatch;
	}
	// 821ABD94: C01FFFF4  lfs f0, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABD98: C1BDFFDC  lfs f13, -0x24(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABD9C: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABDA0: ED7F6024  fdivs f11, f31, f12
	ctx.f[11].f64 = ((ctx.f[31].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABDA4: D17DFFEC  stfs f11, -0x14(r29)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-20 as u32), tmp.u32 ) };
	pc = 0x821ABDA8; continue 'dispatch;
            }
            0x821ABDA8 => {
    //   block [0x821ABDA8..0x821ABE80)
	// 821ABDA8: 389FFFF0  addi r4, r31, -0x10
	ctx.r[4].s64 = ctx.r[31].s64 + -16;
	// 821ABDAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821ABDB0: 4BFFFCE9  bl 0x821aba98
	ctx.lr = 0x821ABDB4;
	sub_821ABA98(ctx, base);
	// 821ABDB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821ABDB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821ABDBC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821ABDC0: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821ABDC4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821ABDC8: 48072D29  bl 0x8221eaf0
	ctx.lr = 0x821ABDCC;
	sub_8221EAF0(ctx, base);
	// 821ABDCC: 907DFF90  stw r3, -0x70(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-112 as u32), ctx.r[3].u32 ) };
	// 821ABDD0: 891F0000  lbz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ABDD4: 813B0054  lwz r9, 0x54(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 821ABDD8: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 821ABDDC: 7D470774  extsb r7, r10
	ctx.r[7].s64 = ctx.r[10].s8 as i64;
	// 821ABDE0: 7D0B0774  extsb r11, r8
	ctx.r[11].s64 = ctx.r[8].s8 as i64;
	// 821ABDE4: 7CC9C850  subf r6, r9, r25
	ctx.r[6].s64 = ctx.r[25].s64 - ctx.r[9].s64;
	// 821ABDE8: 7CA75850  subf r5, r7, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 821ABDEC: 7CC40034  cntlzw r4, r6
	ctx.r[4].u64 = if ctx.r[6].u32 == 0 { 32 } else { ctx.r[6].u32.leading_zeros() as u64 };
	// 821ABDF0: 7CA3FE70  srawi r3, r5, 0x1f
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[5].s32 >> 31) as i64;
	// 821ABDF4: 548ADFFE  rlwinm r10, r4, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 821ABDF8: 7C692838  and r9, r3, r5
	ctx.r[9].u64 = ctx.r[3].u64 & ctx.r[5].u64;
	// 821ABDFC: 69480001  xori r8, r10, 1
	ctx.r[8].u64 = ctx.r[10].u64 ^ 1;
	// 821ABE00: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821ABE04: 7D16B038  and r22, r8, r22
	ctx.r[22].u64 = ctx.r[8].u64 & ctx.r[22].u64;
	// 821ABE08: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 821ABE0C: 40990074  ble cr6, 0x821abe80
	if !ctx.cr[6].gt {
	pc = 0x821ABE80; continue 'dispatch;
	}
	// 821ABE10: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	pc = 0x821ABE80; continue 'dispatch;
            }
            0x821ABE80 => {
    //   block [0x821ABE80..0x821ABEE0)
	// 821ABE80: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 821ABE84: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821ABE88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ABE8C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821ABE90: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821ABE94: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821ABE98: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ABE9C: 4082FFE8  bne 0x821abe84
	if !ctx.cr[0].eq {
	pc = 0x821ABE84; continue 'dispatch;
	}
	// 821ABEA0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821ABEA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ABEA8: 409A0018  bne cr6, 0x821abec0
	if !ctx.cr[6].eq {
	pc = 0x821ABEC0; continue 'dispatch;
	}
	// 821ABEAC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ABEB0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821ABEB4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ABEB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821ABEBC: 4E800421  bctrl
	ctx.lr = 0x821ABEC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821ABEC0: 817C0080  lwz r11, 0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 821ABEC4: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 821ABEC8: 3BFF0018  addi r31, r31, 0x18
	ctx.r[31].s64 = ctx.r[31].s64 + 24;
	// 821ABECC: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 821ABED0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821ABED4: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821ABED8: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821ABEDC: 4198FE8C  blt cr6, 0x821abd68
	if ctx.cr[6].lt {
	pc = 0x821ABD68; continue 'dispatch;
	}
            }
            0x821ABEE0 => {
    //   block [0x821ABEE0..0x821ABEF0)
	// 821ABEE0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821ABEE4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821ABEE8: CBE1FF90  lfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 821ABEEC: 48AFD54C  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ABEF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821ABEF0 size=228
    let mut pc: u32 = 0x821ABEF0;
    'dispatch: loop {
        match pc {
            0x821ABEF0 => {
    //   block [0x821ABEF0..0x821ABF78)
	// 821ABEF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ABEF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ABEF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821ABEFC: DBA1FFD8  stfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[29].u64 ) };
	// 821ABF00: DBC1FFE0  stfd f30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 821ABF04: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821ABF08: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ABF0C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821ABF10: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821ABF14: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 821ABF18: FFE01890  fmr f31, f3
	ctx.f[31].f64 = ctx.f[3].f64;
	// 821ABF1C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821ABF20: 419A0094  beq cr6, 0x821abfb4
	if ctx.cr[6].eq {
	pc = 0x821ABFB4; continue 'dispatch;
	}
	// 821ABF24: 48035FC5  bl 0x821e1ee8
	ctx.lr = 0x821ABF28;
	sub_821E1EE8(ctx, base);
	// 821ABF28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ABF2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821ABF30: 419A0084  beq cr6, 0x821abfb4
	if ctx.cr[6].eq {
	pc = 0x821ABFB4; continue 'dispatch;
	}
	// 821ABF34: 81670008  lwz r11, 8(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 821ABF38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ABF3C: 419A0078  beq cr6, 0x821abfb4
	if ctx.cr[6].eq {
	pc = 0x821ABFB4; continue 'dispatch;
	}
	// 821ABF40: 816B013C  lwz r11, 0x13c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(316 as u32) ) } as u64;
	// 821ABF44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ABF48: 419A006C  beq cr6, 0x821abfb4
	if ctx.cr[6].eq {
	pc = 0x821ABFB4; continue 'dispatch;
	}
	// 821ABF4C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ABF50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ABF54: 419A0060  beq cr6, 0x821abfb4
	if ctx.cr[6].eq {
	pc = 0x821ABFB4; continue 'dispatch;
	}
	// 821ABF58: 480711A1  bl 0x8221d0f8
	ctx.lr = 0x821ABF5C;
	sub_8221D0F8(ctx, base);
	// 821ABF5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ABF60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ABF64: 419A0014  beq cr6, 0x821abf78
	if ctx.cr[6].eq {
	pc = 0x821ABF78; continue 'dispatch;
	}
	// 821ABF68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821ABF6C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821ABF70: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821ABF74: 4BFEEDBD  bl 0x8219ad30
	ctx.lr = 0x821ABF78;
	sub_8219AD30(ctx, base);
	pc = 0x821ABF78; continue 'dispatch;
            }
            0x821ABF78 => {
    //   block [0x821ABF78..0x821ABFB4)
	// 821ABF78: D3A10060  stfs f29, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821ABF7C: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 821ABF80: DBE10068  stfd f31, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[31].u64 ) };
	// 821ABF84: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821ABF88: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821ABF8C: 386B504C  addi r3, r11, 0x504c
	ctx.r[3].s64 = ctx.r[11].s64 + 20556;
	// 821ABF90: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821ABF94: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ABF98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821ABF9C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821ABFA0: 480FF3D9  bl 0x822ab378
	ctx.lr = 0x821ABFA4;
	sub_822AB378(ctx, base);
	// 821ABFA4: 807F0218  lwz r3, 0x218(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) } as u64;
	// 821ABFA8: 4BFE1C71  bl 0x8218dc18
	ctx.lr = 0x821ABFAC;
	sub_8218DC18(ctx, base);
	// 821ABFAC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821ABFB0: 995F0214  stb r10, 0x214(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[10].u8 ) };
	pc = 0x821ABFB4; continue 'dispatch;
            }
            0x821ABFB4 => {
    //   block [0x821ABFB4..0x821ABFD4)
	// 821ABFB4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821ABFB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ABFBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ABFC0: CBA1FFD8  lfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821ABFC4: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821ABFC8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821ABFCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ABFD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ABFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821ABFD8 size=1532
    let mut pc: u32 = 0x821ABFD8;
    'dispatch: loop {
        match pc {
            0x821ABFD8 => {
    //   block [0x821ABFD8..0x821AC004)
	// 821ABFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ABFDC: 48AFD421  bl 0x82ca93fc
	ctx.lr = 0x821ABFE0;
	sub_82CA93D0(ctx, base);
	// 821ABFE0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821ABFE4: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ABFE8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821ABFEC: 3B9A0074  addi r28, r26, 0x74
	ctx.r[28].s64 = ctx.r[26].s64 + 116;
	// 821ABFF0: 817A0078  lwz r11, 0x78(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(120 as u32) ) } as u64;
	// 821ABFF4: 815A007C  lwz r10, 0x7c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(124 as u32) ) } as u64;
	// 821ABFF8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821ABFFC: 40990008  ble cr6, 0x821ac004
	if !ctx.cr[6].gt {
	pc = 0x821AC004; continue 'dispatch;
	}
	// 821AC000: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821AC004; continue 'dispatch;
            }
            0x821AC004 => {
    //   block [0x821AC004..0x821AC018)
	// 821AC004: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC008: 811C0004  lwz r8, 4(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC00C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AC010: 40990008  ble cr6, 0x821ac018
	if !ctx.cr[6].gt {
	pc = 0x821AC018; continue 'dispatch;
	}
	// 821AC014: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821AC018; continue 'dispatch;
            }
            0x821AC018 => {
    //   block [0x821AC018..0x821AC01C)
	// 821AC018: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	pc = 0x821AC01C; continue 'dispatch;
            }
            0x821AC01C => {
    //   block [0x821AC01C..0x821AC028)
	// 821AC01C: 7F1CE040  cmplw cr6, r28, r28
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821AC020: 419A0008  beq cr6, 0x821ac028
	if ctx.cr[6].eq {
	pc = 0x821AC028; continue 'dispatch;
	}
	// 821AC024: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821AC028; continue 'dispatch;
            }
            0x821AC028 => {
    //   block [0x821AC028..0x821AC03C)
	// 821AC028: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AC02C: 419A002C  beq cr6, 0x821ac058
	if ctx.cr[6].eq {
	pc = 0x821AC058; continue 'dispatch;
	}
	// 821AC030: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC034: 41980008  blt cr6, 0x821ac03c
	if ctx.cr[6].lt {
	pc = 0x821AC03C; continue 'dispatch;
	}
	// 821AC038: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821AC03C; continue 'dispatch;
            }
            0x821AC03C => {
    //   block [0x821AC03C..0x821AC050)
	// 821AC03C: 9B2B0010  stb r25, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[25].u8 ) };
	// 821AC040: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC044: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC048: 41980008  blt cr6, 0x821ac050
	if ctx.cr[6].lt {
	pc = 0x821AC050; continue 'dispatch;
	}
	// 821AC04C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821AC050; continue 'dispatch;
            }
            0x821AC050 => {
    //   block [0x821AC050..0x821AC058)
	// 821AC050: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 821AC054: 4BFFFFC8  b 0x821ac01c
	pc = 0x821AC01C; continue 'dispatch;
            }
            0x821AC058 => {
    //   block [0x821AC058..0x821AC0B0)
	// 821AC058: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821AC05C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 821AC060: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821AC064: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AC068: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821AC06C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC070: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC074: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 821AC078: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821AC07C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC080: 419A0168  beq cr6, 0x821ac1e8
	if ctx.cr[6].eq {
	pc = 0x821AC1E8; continue 'dispatch;
	}
	// 821AC084: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC088: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AC08C: 419A0158  beq cr6, 0x821ac1e4
	if ctx.cr[6].eq {
	pc = 0x821AC1E4; continue 'dispatch;
	}
	// 821AC090: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AC094: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AC098: 419A0018  beq cr6, 0x821ac0b0
	if ctx.cr[6].eq {
	pc = 0x821AC0B0; continue 'dispatch;
	}
	// 821AC09C: 896A0090  lbz r11, 0x90(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 821AC0A0: 55690672  rlwinm r9, r11, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AC0A4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821AC0A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AC0AC: 409A0008  bne cr6, 0x821ac0b4
	if !ctx.cr[6].eq {
	pc = 0x821AC0B4; continue 'dispatch;
	}
	pc = 0x821AC0B0; continue 'dispatch;
            }
            0x821AC0B0 => {
    //   block [0x821AC0B0..0x821AC0B4)
	// 821AC0B0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AC0B4; continue 'dispatch;
            }
            0x821AC0B4 => {
    //   block [0x821AC0B4..0x821AC1E4)
	// 821AC0B4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821AC0B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AC0BC: 3BC99484  addi r30, r9, -0x6b7c
	ctx.r[30].s64 = ctx.r[9].s64 + -27516;
	// 821AC0C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC0C4: C3E99484  lfs f31, -0x6b7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821AC0C8: 419A025C  beq cr6, 0x821ac324
	if ctx.cr[6].eq {
	pc = 0x821AC324; continue 'dispatch;
	}
	// 821AC0CC: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 821AC0D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821AC0D4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC0D8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AC0DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821AC0E0: 4E800421  bctrl
	ctx.lr = 0x821AC0E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AC0E4: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821AC0E8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821AC0EC: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
            }
            0x821AC1E4 => {
    //   block [0x821AC1E4..0x821AC1E8)
	// 821AC1E4: 4BFE7C55  bl 0x82193e38
	ctx.lr = 0x821AC1E8;
	sub_82193E38(ctx, base);
	pc = 0x821AC1E8; continue 'dispatch;
            }
            0x821AC1E8 => {
    //   block [0x821AC1E8..0x821AC324)
	// 821AC1E8: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 821AC1EC: 4BFFFEC4  b 0x821ac0b0
	pc = 0x821AC0B0; continue 'dispatch;
	// 821AC1F0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821AC1F4: C01E000C  lfs f0, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC1F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AC1FC: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821AC200: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821AC204: 93210080  stw r25, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[25].u32 ) };
	// 821AC208: 9BA10090  stb r29, 0x90(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u8 ) };
	// 821AC20C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 821AC210: 4839C591  bl 0x825487a0
	ctx.lr = 0x821AC214;
	sub_825487A0(ctx, base);
	// 821AC214: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC21C: 419A0028  beq cr6, 0x821ac244
	if ctx.cr[6].eq {
	pc = 0x821AC244; continue 'dispatch;
	}
	// 821AC220: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821AC224: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 821AC228: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821AC22C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821AC230: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821AC234: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AC238: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821AC23C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821AC240: 4082FFE8  bne 0x821ac228
	if !ctx.cr[0].eq {
	pc = 0x821AC228; continue 'dispatch;
	}
	// 821AC244: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AC248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC24C: 419A0048  beq cr6, 0x821ac294
	if ctx.cr[6].eq {
	pc = 0x821AC294; continue 'dispatch;
	}
	// 821AC250: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821AC254: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 821AC258: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821AC25C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821AC260: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821AC264: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821AC268: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821AC26C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821AC270: 4082FFE8  bne 0x821ac258
	if !ctx.cr[0].eq {
	pc = 0x821AC258; continue 'dispatch;
	}
	// 821AC274: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821AC278: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AC27C: 409A0014  bne cr6, 0x821ac290
	if !ctx.cr[6].eq {
	pc = 0x821AC290; continue 'dispatch;
	}
	// 821AC280: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC284: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC288: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821AC28C: 4E800421  bctrl
	ctx.lr = 0x821AC290;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AC290: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 821AC294: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC298: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 821AC29C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC2A0: 409A000C  bne cr6, 0x821ac2ac
	if !ctx.cr[6].eq {
	pc = 0x821AC2AC; continue 'dispatch;
	}
	// 821AC2A4: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 821AC2A8: 48000010  b 0x821ac2b8
	pc = 0x821AC2B8; continue 'dispatch;
	// 821AC2AC: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC2B0: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821AC2B4: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 821AC2B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC2BC: 419A0034  beq cr6, 0x821ac2f0
	if ctx.cr[6].eq {
	pc = 0x821AC2F0; continue 'dispatch;
	}
	// 821AC2C0: 811C000C  lwz r8, 0xc(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AC2C4: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 821AC2C8: 7CC74BD6  divw r6, r7, r9
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[9].s32;
	// 821AC2CC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AC2D0: 40980020  bge cr6, 0x821ac2f0
	if !ctx.cr[6].lt {
	pc = 0x821AC2F0; continue 'dispatch;
	}
	// 821AC2D4: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 821AC2D8: 809C0008  lwz r4, 8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC2DC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821AC2E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AC2E4: 4839E5FD  bl 0x8254a8e0
	ctx.lr = 0x821AC2E8;
	sub_8254A8E0(ctx, base);
	// 821AC2E8: 907C0008  stw r3, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821AC2EC: 48000030  b 0x821ac31c
	pc = 0x821AC31C; continue 'dispatch;
	// 821AC2F0: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC2F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC2F8: 40990008  ble cr6, 0x821ac300
	if !ctx.cr[6].gt {
	pc = 0x821AC300; continue 'dispatch;
	}
	// 821AC2FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC300: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 821AC304: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 821AC308: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AC30C: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 821AC310: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821AC314: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 821AC318: 4839E4E1  bl 0x8254a7f8
	ctx.lr = 0x821AC31C;
	sub_8254A7F8(ctx, base);
	// 821AC31C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821AC320: 48085999  bl 0x82231cb8
	ctx.lr = 0x821AC324;
	sub_82231CB8(ctx, base);
            }
            0x821AC324 => {
    //   block [0x821AC324..0x821AC5D4)
	// 821AC324: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC328: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC32C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AC330: 40990008  ble cr6, 0x821ac338
	if !ctx.cr[6].gt {
	pc = 0x821AC338; continue 'dispatch;
	}
	// 821AC334: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC338: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 821AC33C: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 821AC340: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC344: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC348: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AC34C: E9210070  ld r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 821AC350: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 821AC354: 40990008  ble cr6, 0x821ac35c
	if !ctx.cr[6].gt {
	pc = 0x821AC35C; continue 'dispatch;
	}
	// 821AC358: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC35C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 821AC360: 3F608332  lis r27, -0x7cce
	ctx.r[27].s64 = -2093875200;
	// 821AC364: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 821AC368: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 821AC36C: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 821AC370: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821AC374: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821AC378: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AC37C: 419A0010  beq cr6, 0x821ac38c
	if ctx.cr[6].eq {
	pc = 0x821AC38C; continue 'dispatch;
	}
	// 821AC380: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 821AC384: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC388: 419A0008  beq cr6, 0x821ac390
	if ctx.cr[6].eq {
	pc = 0x821AC390; continue 'dispatch;
	}
	// 821AC38C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC390: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821AC394: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC398: 419A0230  beq cr6, 0x821ac5c8
	if ctx.cr[6].eq {
	pc = 0x821AC5C8; continue 'dispatch;
	}
	// 821AC39C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AC3A0: 409A0008  bne cr6, 0x821ac3a8
	if !ctx.cr[6].eq {
	pc = 0x821AC3A8; continue 'dispatch;
	}
	// 821AC3A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC3A8: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC3AC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC3B0: 41980008  blt cr6, 0x821ac3b8
	if ctx.cr[6].lt {
	pc = 0x821AC3B8; continue 'dispatch;
	}
	// 821AC3B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC3B8: 890B0010  lbz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AC3BC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AC3C0: 419A0090  beq cr6, 0x821ac450
	if ctx.cr[6].eq {
	pc = 0x821AC450; continue 'dispatch;
	}
	// 821AC3C4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC3C8: 4198000C  blt cr6, 0x821ac3d4
	if ctx.cr[6].lt {
	pc = 0x821AC3D4; continue 'dispatch;
	}
	// 821AC3CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC3D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC3D4: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AC3D8: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC3DC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821AC3E0: 409800E8  bge cr6, 0x821ac4c8
	if !ctx.cr[6].lt {
	pc = 0x821AC4C8; continue 'dispatch;
	}
	// 821AC3E4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC3E8: 4198000C  blt cr6, 0x821ac3f4
	if ctx.cr[6].lt {
	pc = 0x821AC3F4; continue 'dispatch;
	}
	// 821AC3EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC3F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC3F4: C1BA0084  lfs f13, 0x84(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AC3F8: C99B9660  lfd f12, -0x69a0(r27)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(-27040 as u32) ) };
	// 821AC3FC: FD6D0332  fmul f11, f13, f12
	ctx.f[11].f64 = ctx.f[13].f64 * ctx.f[12].f64;
	// 821AC400: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821AC404: FD205824  fdiv f9, f0, f11
	ctx.f[9].f64 = ctx.f[0].f64 / ctx.f[11].f64;
	// 821AC408: FD09502A  fadd f8, f9, f10
	ctx.f[8].f64 = ctx.f[9].f64 + ctx.f[10].f64;
	// 821AC40C: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 821AC410: D0EB000C  stfs f7, 0xc(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AC414: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC418: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC41C: 4198000C  blt cr6, 0x821ac428
	if ctx.cr[6].lt {
	pc = 0x821AC428; continue 'dispatch;
	}
	// 821AC420: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC424: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC428: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC42C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AC430: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821AC434: 40990094  ble cr6, 0x821ac4c8
	if !ctx.cr[6].gt {
	pc = 0x821AC4C8; continue 'dispatch;
	}
	// 821AC438: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC43C: 4198000C  blt cr6, 0x821ac448
	if ctx.cr[6].lt {
	pc = 0x821AC448; continue 'dispatch;
	}
	// 821AC440: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC444: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC448: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AC44C: 4800007C  b 0x821ac4c8
	pc = 0x821AC4C8; continue 'dispatch;
	// 821AC450: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC454: 41980008  blt cr6, 0x821ac45c
	if ctx.cr[6].lt {
	pc = 0x821AC45C; continue 'dispatch;
	}
	// 821AC458: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC45C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC460: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821AC464: 40990064  ble cr6, 0x821ac4c8
	if !ctx.cr[6].gt {
	pc = 0x821AC4C8; continue 'dispatch;
	}
	// 821AC468: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC46C: 4198000C  blt cr6, 0x821ac478
	if ctx.cr[6].lt {
	pc = 0x821AC478; continue 'dispatch;
	}
	// 821AC470: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC474: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC478: C01A0088  lfs f0, 0x88(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC47C: C9BB9660  lfd f13, -0x69a0(r27)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(-27040 as u32) ) };
	// 821AC480: FD800372  fmul f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 * ctx.f[13].f64;
	// 821AC484: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AC488: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821AC48C: FD2B6024  fdiv f9, f11, f12
	ctx.f[9].f64 = ctx.f[11].f64 / ctx.f[12].f64;
	// 821AC490: FD0A4828  fsub f8, f10, f9
	ctx.f[8].f64 = ctx.f[10].f64 - ctx.f[9].f64;
	// 821AC494: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 821AC498: D0EB000C  stfs f7, 0xc(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AC49C: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC4A0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC4A4: 41980008  blt cr6, 0x821ac4ac
	if ctx.cr[6].lt {
	pc = 0x821AC4AC; continue 'dispatch;
	}
	// 821AC4A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC4AC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC4B0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821AC4B4: 40980014  bge cr6, 0x821ac4c8
	if !ctx.cr[6].lt {
	pc = 0x821AC4C8; continue 'dispatch;
	}
	// 821AC4B8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC4BC: 41980008  blt cr6, 0x821ac4c4
	if ctx.cr[6].lt {
	pc = 0x821AC4C4; continue 'dispatch;
	}
	// 821AC4C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC4C4: D3EB000C  stfs f31, 0xc(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AC4C8: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC4CC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC4D0: 41980008  blt cr6, 0x821ac4d8
	if ctx.cr[6].lt {
	pc = 0x821AC4D8; continue 'dispatch;
	}
	// 821AC4D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC4D8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC4DC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821AC4E0: 419900D0  bgt cr6, 0x821ac5b0
	if ctx.cr[6].gt {
	pc = 0x821AC5B0; continue 'dispatch;
	}
	// 821AC4E4: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC4E8: 3BEB0014  addi r31, r11, 0x14
	ctx.r[31].s64 = ctx.r[11].s64 + 20;
	// 821AC4EC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821AC4F0: 419A0020  beq cr6, 0x821ac510
	if ctx.cr[6].eq {
	pc = 0x821AC510; continue 'dispatch;
	}
	// 821AC4F4: 7FBF5850  subf r29, r31, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 821AC4F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821AC4FC: 7C7DFA14  add r3, r29, r31
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 821AC500: 4839F091  bl 0x8254b590
	ctx.lr = 0x821AC504;
	sub_8254B590(ctx, base);
	// 821AC504: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 821AC508: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821AC50C: 409AFFEC  bne cr6, 0x821ac4f8
	if !ctx.cr[6].eq {
	pc = 0x821AC4F8; continue 'dispatch;
	}
	// 821AC510: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC514: 3BFEFFEC  addi r31, r30, -0x14
	ctx.r[31].s64 = ctx.r[30].s64 + -20;
	// 821AC518: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821AC51C: 419A0058  beq cr6, 0x821ac574
	if ctx.cr[6].eq {
	pc = 0x821AC574; continue 'dispatch;
	}
	// 821AC520: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC524: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AC528: 419A0040  beq cr6, 0x821ac568
	if ctx.cr[6].eq {
	pc = 0x821AC568; continue 'dispatch;
	}
	// 821AC52C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 821AC530: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821AC534: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821AC538: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821AC53C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AC540: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821AC544: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821AC548: 4082FFE8  bne 0x821ac530
	if !ctx.cr[0].eq {
	pc = 0x821AC530; continue 'dispatch;
	}
	// 821AC54C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AC550: 409A0014  bne cr6, 0x821ac564
	if !ctx.cr[6].eq {
	pc = 0x821AC564; continue 'dispatch;
	}
	// 821AC554: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC558: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC55C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821AC560: 4E800421  bctrl
	ctx.lr = 0x821AC564;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AC564: 933F0000  stw r25, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 821AC568: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 821AC56C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821AC570: 409AFFB0  bne cr6, 0x821ac520
	if !ctx.cr[6].eq {
	pc = 0x821AC520; continue 'dispatch;
	}
	// 821AC574: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC578: E9410060  ld r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821AC57C: 392BFFEC  addi r9, r11, -0x14
	ctx.r[9].s64 = ctx.r[11].s64 + -20;
	// 821AC580: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821AC584: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 821AC588: 552A003E  slwi r10, r9, 0
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AC58C: 811C0004  lwz r8, 4(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC590: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC594: 40990008  ble cr6, 0x821ac59c
	if !ctx.cr[6].gt {
	pc = 0x821AC59C; continue 'dispatch;
	}
	// 821AC598: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC59C: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 821AC5A0: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 821AC5A4: E9410078  ld r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 821AC5A8: F9410070  std r10, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u64 ) };
	// 821AC5AC: 4BFFFDC4  b 0x821ac370
	pc = 0x821AC370; continue 'dispatch;
	// 821AC5B0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC5B4: 41980008  blt cr6, 0x821ac5bc
	if ctx.cr[6].lt {
	pc = 0x821AC5BC; continue 'dispatch;
	}
	// 821AC5B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AC5BC: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 821AC5C0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821AC5C4: 4BFFFDB4  b 0x821ac378
	pc = 0x821AC378; continue 'dispatch;
	// 821AC5C8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821AC5CC: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821AC5D0: 48AFCE7C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AC5D8 size=156
    let mut pc: u32 = 0x821AC5D8;
    'dispatch: loop {
        match pc {
            0x821AC5D8 => {
    //   block [0x821AC5D8..0x821AC674)
	// 821AC5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC5DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AC5E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AC5E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AC5E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC5EC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821AC5F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AC5F4: 3BCB0034  addi r30, r11, 0x34
	ctx.r[30].s64 = ctx.r[11].s64 + 52;
	// 821AC5F8: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 821AC5FC: 389E0008  addi r4, r30, 8
	ctx.r[4].s64 = ctx.r[30].s64 + 8;
	// 821AC600: 894B0034  lbz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821AC604: 995F0000  stb r10, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821AC608: 892B0035  lbz r9, 0x35(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 821AC60C: 993F0001  stb r9, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[9].u8 ) };
	// 821AC610: 890B0036  lbz r8, 0x36(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 821AC614: 991F0002  stb r8, 2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[8].u8 ) };
	// 821AC618: 88EB0037  lbz r7, 0x37(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(55 as u32) ) } as u64;
	// 821AC61C: 98FF0003  stb r7, 3(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(3 as u32), ctx.r[7].u8 ) };
	// 821AC620: 88CB0038  lbz r6, 0x38(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AC624: 98DF0004  stb r6, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u8 ) };
	// 821AC628: 88AB0039  lbz r5, 0x39(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 821AC62C: 98BF0005  stb r5, 5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(5 as u32), ctx.r[5].u8 ) };
	// 821AC630: 48043C11  bl 0x821f0240
	ctx.lr = 0x821AC634;
	sub_821F0240(ctx, base);
	// 821AC634: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 821AC638: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 821AC63C: 48043C05  bl 0x821f0240
	ctx.lr = 0x821AC640;
	sub_821F0240(ctx, base);
	// 821AC640: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 821AC644: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 821AC648: 48043BF9  bl 0x821f0240
	ctx.lr = 0x821AC64C;
	sub_821F0240(ctx, base);
	// 821AC64C: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 821AC650: 389E0014  addi r4, r30, 0x14
	ctx.r[4].s64 = ctx.r[30].s64 + 20;
	// 821AC654: 48043BED  bl 0x821f0240
	ctx.lr = 0x821AC658;
	sub_821F0240(ctx, base);
	// 821AC658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC65C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AC660: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AC664: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AC668: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821AC66C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AC670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AC678 size=564
    let mut pc: u32 = 0x821AC678;
    'dispatch: loop {
        match pc {
            0x821AC678 => {
    //   block [0x821AC678..0x821AC6D0)
	// 821AC678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC67C: 48AFCD8D  bl 0x82ca9408
	ctx.lr = 0x821AC680;
	sub_82CA93D0(ctx, base);
	// 821AC680: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC684: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821AC688: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AC68C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 821AC690: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821AC694: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC698: 419A0038  beq cr6, 0x821ac6d0
	if ctx.cr[6].eq {
	pc = 0x821AC6D0; continue 'dispatch;
	}
	// 821AC69C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AC6A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821AC6A4: 808B008C  lwz r4, 0x8c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AC6A8: 4BFFFF31  bl 0x821ac5d8
	ctx.lr = 0x821AC6AC;
	sub_821AC5D8(ctx, base);
	// 821AC6AC: 8BE30004  lbz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC6B0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 821AC6B4: 48068725  bl 0x82214dd8
	ctx.lr = 0x821AC6B8;
	sub_82214DD8(ctx, base);
	// 821AC6B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821AC6BC: 4806871D  bl 0x82214dd8
	ctx.lr = 0x821AC6C0;
	sub_82214DD8(ctx, base);
	// 821AC6C0: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 821AC6C4: 48068715  bl 0x82214dd8
	ctx.lr = 0x821AC6C8;
	sub_82214DD8(ctx, base);
	// 821AC6C8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821AC6CC: 4806870D  bl 0x82214dd8
	ctx.lr = 0x821AC6D0;
	sub_82214DD8(ctx, base);
	pc = 0x821AC6D0; continue 'dispatch;
            }
            0x821AC6D0 => {
    //   block [0x821AC6D0..0x821AC6F0)
	// 821AC6D0: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821AC6D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC6D8: 409A01CC  bne cr6, 0x821ac8a4
	if !ctx.cr[6].eq {
	pc = 0x821AC8A4; continue 'dispatch;
	}
	// 821AC6DC: 389E00AC  addi r4, r30, 0xac
	ctx.r[4].s64 = ctx.r[30].s64 + 172;
	// 821AC6E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AC6E4: 4BFEC945  bl 0x82199028
	ctx.lr = 0x821AC6E8;
	sub_82199028(ctx, base);
	// 821AC6E8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821AC6EC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x821AC6F0; continue 'dispatch;
            }
            0x821AC6F0 => {
    //   block [0x821AC6F0..0x821AC724)
	// 821AC6F0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AC6F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AC6F8: 419A0168  beq cr6, 0x821ac860
	if ctx.cr[6].eq {
	pc = 0x821AC860; continue 'dispatch;
	}
	// 821AC6FC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821AC700: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821AC704: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821AC708: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AC70C: 40980154  bge cr6, 0x821ac860
	if !ctx.cr[6].lt {
	pc = 0x821AC860; continue 'dispatch;
	}
	// 821AC710: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 821AC714: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AC718: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC71C: 41980008  blt cr6, 0x821ac724
	if ctx.cr[6].lt {
	pc = 0x821AC724; continue 'dispatch;
	}
	// 821AC720: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821AC724; continue 'dispatch;
            }
            0x821AC724 => {
    //   block [0x821AC724..0x821AC73C)
	// 821AC724: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC728: 2F040006  cmpwi cr6, r4, 6
	ctx.cr[6].compare_i32(ctx.r[4].s32, 6, &mut ctx.xer);
	// 821AC72C: 409A0010  bne cr6, 0x821ac73c
	if !ctx.cr[6].eq {
	pc = 0x821AC73C; continue 'dispatch;
	}
	// 821AC730: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821AC734: 409A0008  bne cr6, 0x821ac73c
	if !ctx.cr[6].eq {
	pc = 0x821AC73C; continue 'dispatch;
	}
	// 821AC738: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	pc = 0x821AC73C; continue 'dispatch;
            }
            0x821AC73C => {
    //   block [0x821AC73C..0x821AC76C)
	// 821AC73C: 39440003  addi r10, r4, 3
	ctx.r[10].s64 = ctx.r[4].s64 + 3;
	// 821AC740: 555F103A  slwi r31, r10, 2
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821AC744: 7D3FF02E  lwzx r9, r31, r30
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821AC748: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AC74C: 419A00F8  beq cr6, 0x821ac844
	if ctx.cr[6].eq {
	pc = 0x821AC844; continue 'dispatch;
	}
	// 821AC750: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821AC754: 409A0018  bne cr6, 0x821ac76c
	if !ctx.cr[6].eq {
	pc = 0x821AC76C; continue 'dispatch;
	}
	// 821AC758: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AC75C: 482308CD  bl 0x823dd028
	ctx.lr = 0x821AC760;
	sub_823DD028(ctx, base);
	// 821AC760: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821AC764: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 821AC768: 4BFFFF88  b 0x821ac6f0
	pc = 0x821AC6F0; continue 'dispatch;
            }
            0x821AC76C => {
    //   block [0x821AC76C..0x821AC7A4)
	// 821AC76C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821AC770: 409A0070  bne cr6, 0x821ac7e0
	if !ctx.cr[6].eq {
	pc = 0x821AC7E0; continue 'dispatch;
	}
	// 821AC774: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821AC778: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC77C: 814B0060  lwz r10, 0x60(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 821AC780: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821AC784: 4E800421  bctrl
	ctx.lr = 0x821AC788;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AC788: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821AC78C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AC790: 409A00C4  bne cr6, 0x821ac854
	if !ctx.cr[6].eq {
	pc = 0x821AC854; continue 'dispatch;
	}
	// 821AC794: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821AC798: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AC79C: 419A0008  beq cr6, 0x821ac7a4
	if ctx.cr[6].eq {
	pc = 0x821AC7A4; continue 'dispatch;
	}
	// 821AC7A0: 48529C01  bl 0x826d63a0
	ctx.lr = 0x821AC7A4;
	sub_826D63A0(ctx, base);
            }
            0x821AC7A4 => {
    //   block [0x821AC7A4..0x821AC7E0)
	// 821AC7A4: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821AC7A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821AC7AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC7B0: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AC7B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821AC7B8: 4E800421  bctrl
	ctx.lr = 0x821AC7BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AC7BC: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821AC7C0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821AC7C4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC7C8: 81090064  lwz r8, 0x64(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 821AC7CC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821AC7D0: 4E800421  bctrl
	ctx.lr = 0x821AC7D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AC7D4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821AC7D8: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 821AC7DC: 4BFFFF14  b 0x821ac6f0
	pc = 0x821AC6F0; continue 'dispatch;
            }
            0x821AC7E0 => {
    //   block [0x821AC7E0..0x821AC844)
	// 821AC7E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AC7E4: 409A0070  bne cr6, 0x821ac854
	if !ctx.cr[6].eq {
	pc = 0x821AC854; continue 'dispatch;
	}
	// 821AC7E8: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821AC7EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC7F0: 814B0060  lwz r10, 0x60(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 821AC7F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821AC7F8: 4E800421  bctrl
	ctx.lr = 0x821AC7FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AC7FC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821AC800: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AC804: 419A0050  beq cr6, 0x821ac854
	if ctx.cr[6].eq {
	pc = 0x821AC854; continue 'dispatch;
	}
	// 821AC808: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821AC80C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821AC810: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC814: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AC818: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821AC81C: 4E800421  bctrl
	ctx.lr = 0x821AC820;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AC820: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821AC824: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821AC828: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC82C: 81090064  lwz r8, 0x64(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 821AC830: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821AC834: 4E800421  bctrl
	ctx.lr = 0x821AC838;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AC838: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821AC83C: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 821AC840: 4BFFFEB0  b 0x821ac6f0
	pc = 0x821AC6F0; continue 'dispatch;
            }
            0x821AC844 => {
    //   block [0x821AC844..0x821AC854)
	// 821AC844: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AC848: 409A000C  bne cr6, 0x821ac854
	if !ctx.cr[6].eq {
	pc = 0x821AC854; continue 'dispatch;
	}
	// 821AC84C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AC850: 48230189  bl 0x823dc9d8
	ctx.lr = 0x821AC854;
	sub_823DC9D8(ctx, base);
	pc = 0x821AC854; continue 'dispatch;
            }
            0x821AC854 => {
    //   block [0x821AC854..0x821AC860)
	// 821AC854: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821AC858: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 821AC85C: 4BFFFE94  b 0x821ac6f0
	pc = 0x821AC6F0; continue 'dispatch;
            }
            0x821AC860 => {
    //   block [0x821AC860..0x821AC894)
	// 821AC860: 817E009C  lwz r11, 0x9c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) } as u64;
	// 821AC864: 389E009C  addi r4, r30, 0x9c
	ctx.r[4].s64 = ctx.r[30].s64 + 156;
	// 821AC868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC86C: 419A0028  beq cr6, 0x821ac894
	if ctx.cr[6].eq {
	pc = 0x821AC894; continue 'dispatch;
	}
	// 821AC870: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821AC874: 806B6B08  lwz r3, 0x6b08(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821AC878: 81430038  lwz r10, 0x38(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AC87C: 812A0098  lwz r9, 0x98(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(152 as u32) ) } as u64;
	// 821AC880: 2F09001F  cmpwi cr6, r9, 0x1f
	ctx.cr[6].compare_i32(ctx.r[9].s32, 31, &mut ctx.xer);
	// 821AC884: 409A0010  bne cr6, 0x821ac894
	if !ctx.cr[6].eq {
	pc = 0x821AC894; continue 'dispatch;
	}
	// 821AC888: 481C5AD9  bl 0x82372360
	ctx.lr = 0x821AC88C;
	sub_82372360(ctx, base);
	// 821AC88C: 3960001F  li r11, 0x1f
	ctx.r[11].s64 = 31;
	// 821AC890: 917E0098  stw r11, 0x98(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	pc = 0x821AC894; continue 'dispatch;
            }
            0x821AC894 => {
    //   block [0x821AC894..0x821AC8A4)
	// 821AC894: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AC898: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AC89C: 419A0008  beq cr6, 0x821ac8a4
	if ctx.cr[6].eq {
	pc = 0x821AC8A4; continue 'dispatch;
	}
	// 821AC8A0: 4806F499  bl 0x8221bd38
	ctx.lr = 0x821AC8A4;
	sub_8221BD38(ctx, base);
	pc = 0x821AC8A4; continue 'dispatch;
            }
            0x821AC8A4 => {
    //   block [0x821AC8A4..0x821AC8AC)
	// 821AC8A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AC8A8: 48AFCBB0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AC8B0 size=244
    let mut pc: u32 = 0x821AC8B0;
    'dispatch: loop {
        match pc {
            0x821AC8B0 => {
    //   block [0x821AC8B0..0x821AC91C)
	// 821AC8B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC8B4: 48AFCB55  bl 0x82ca9408
	ctx.lr = 0x821AC8B8;
	sub_82CA93D0(ctx, base);
	// 821AC8B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC8BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AC8C0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821AC8C4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821AC8C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC8CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC8D0: 419A00CC  beq cr6, 0x821ac99c
	if ctx.cr[6].eq {
	pc = 0x821AC99C; continue 'dispatch;
	}
	// 821AC8D4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC8D8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821AC8DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821AC8E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC8E4: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 821AC8E8: 4BFEE199  bl 0x8219aa80
	ctx.lr = 0x821AC8EC;
	sub_8219AA80(ctx, base);
	// 821AC8EC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC8F0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 821AC8F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC8F8: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC8FC: 4807C80D  bl 0x82229108
	ctx.lr = 0x821AC900;
	sub_82229108(ctx, base);
	// 821AC900: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC904: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC908: 419A0014  beq cr6, 0x821ac91c
	if ctx.cr[6].eq {
	pc = 0x821AC91C; continue 'dispatch;
	}
	// 821AC90C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 821AC910: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC918: 4807C7F1  bl 0x82229108
	ctx.lr = 0x821AC91C;
	sub_82229108(ctx, base);
	pc = 0x821AC91C; continue 'dispatch;
            }
            0x821AC91C => {
    //   block [0x821AC91C..0x821AC990)
	// 821AC91C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC920: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC924: 481F669D  bl 0x823a2fc0
	ctx.lr = 0x821AC928;
	sub_823A2FC0(ctx, base);
	// 821AC928: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC92C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AC930: 80DF0020  lwz r6, 0x20(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AC934: 394BFFE8  addi r10, r11, -0x18
	ctx.r[10].s64 = ctx.r[11].s64 + -24;
	// 821AC938: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821AC93C: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 821AC940: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821AC944: 3D0082A2  lis r8, -0x7d5e
	ctx.r[8].s64 = -2103312384;
	// 821AC948: 7CE65850  subf r7, r6, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 821AC94C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821AC950: 38884808  addi r4, r8, 0x4808
	ctx.r[4].s64 = ctx.r[8].s64 + 18440;
	// 821AC954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC958: 7CC65050  subf r6, r6, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 821AC95C: 4BFEDEE5  bl 0x8219a840
	ctx.lr = 0x821AC960;
	sub_8219A840(ctx, base);
	// 821AC960: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821AC964: 419A002C  beq cr6, 0x821ac990
	if ctx.cr[6].eq {
	pc = 0x821AC990; continue 'dispatch;
	}
	// 821AC968: 48A4FEA1  bl 0x82bfc808
	ctx.lr = 0x821AC96C;
	sub_82BFC808(ctx, base);
	// 821AC96C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821AC970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AC974: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821AC978: 48080559  bl 0x8222ced0
	ctx.lr = 0x821AC97C;
	sub_8222CED0(ctx, base);
	// 821AC97C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AC984: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 821AC988: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821AC98C: 4806844D  bl 0x82214dd8
	ctx.lr = 0x821AC990;
	sub_82214DD8(ctx, base);
	pc = 0x821AC990; continue 'dispatch;
            }
            0x821AC990 => {
    //   block [0x821AC990..0x821AC99C)
	// 821AC990: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AC994: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 821AC998: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x821AC99C; continue 'dispatch;
            }
            0x821AC99C => {
    //   block [0x821AC99C..0x821AC9A4)
	// 821AC99C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AC9A0: 48AFCAB8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AC9A8 size=164
    let mut pc: u32 = 0x821AC9A8;
    'dispatch: loop {
        match pc {
            0x821AC9A8 => {
    //   block [0x821AC9A8..0x821AC9FC)
	// 821AC9A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC9AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AC9B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AC9B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AC9B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC9BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821AC9C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AC9C4: 396B2C60  addi r11, r11, 0x2c60
	ctx.r[11].s64 = ctx.r[11].s64 + 11360;
	// 821AC9C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821AC9CC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AC9D0: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AC9D4: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AC9D8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AC9DC: 409A0020  bne cr6, 0x821ac9fc
	if !ctx.cr[6].eq {
	pc = 0x821AC9FC; continue 'dispatch;
	}
	// 821AC9E0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC9E4: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 821AC9E8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 821AC9EC: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC9F0: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AC9F4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AC9F8: 48BA88D1  bl 0x82d552c8
	ctx.lr = 0x821AC9FC;
	sub_82D552C8(ctx, base);
	pc = 0x821AC9FC; continue 'dispatch;
            }
            0x821AC9FC => {
    //   block [0x821AC9FC..0x821ACA30)
	// 821AC9FC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 821ACA00: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 821ACA04: 396B39E0  addi r11, r11, 0x39e0
	ctx.r[11].s64 = ctx.r[11].s64 + 14816;
	// 821ACA08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ACA0C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821ACA10: 419A0020  beq cr6, 0x821aca30
	if ctx.cr[6].eq {
	pc = 0x821ACA30; continue 'dispatch;
	}
	// 821ACA14: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ACA18: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 821ACA1C: 38C0001E  li r6, 0x1e
	ctx.r[6].s64 = 30;
	// 821ACA20: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ACA24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821ACA28: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821ACA2C: 48BA889D  bl 0x82d552c8
	ctx.lr = 0x821ACA30;
	sub_82D552C8(ctx, base);
	pc = 0x821ACA30; continue 'dispatch;
            }
            0x821ACA30 => {
    //   block [0x821ACA30..0x821ACA4C)
	// 821ACA30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821ACA34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821ACA38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ACA3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ACA40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821ACA44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ACA48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ACA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821ACA50 size=104
    let mut pc: u32 = 0x821ACA50;
    'dispatch: loop {
        match pc {
            0x821ACA50 => {
    //   block [0x821ACA50..0x821ACA88)
	// 821ACA50: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821ACA54: 7D032050  subf r8, r3, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 821ACA58: 392B9128  addi r9, r11, -0x6ed8
	ctx.r[9].s64 = ctx.r[11].s64 + -28376;
	// 821ACA5C: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 821ACA60: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821ACA64: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821ACA68: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ACA6C: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821ACA70: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ACA74: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821ACA78: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ACA7C: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821ACA80: 89240058  lbz r9, 0x58(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) } as u64;
	// 821ACA84: 99230058  stb r9, 0x58(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	pc = 0x821ACA88; continue 'dispatch;
            }
            0x821ACA88 => {
    //   block [0x821ACA88..0x821ACAB8)
	// 821ACA88: 7D28582E  lwzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821ACA8C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821ACA90: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821ACA94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821ACA98: 4082FFF0  bne 0x821aca88
	if !ctx.cr[0].eq {
	pc = 0x821ACA88; continue 'dispatch;
	}
	// 821ACA9C: 81640050  lwz r11, 0x50(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(80 as u32) ) } as u64;
	// 821ACAA0: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821ACAA4: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 821ACAA8: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821ACAAC: 89640058  lbz r11, 0x58(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) } as u64;
	// 821ACAB0: 99630058  stb r11, 0x58(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 821ACAB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ACAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ACAB8 size=116
    let mut pc: u32 = 0x821ACAB8;
    'dispatch: loop {
        match pc {
            0x821ACAB8 => {
    //   block [0x821ACAB8..0x821ACADC)
	// 821ACAB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ACABC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ACAC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821ACAC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ACAC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ACACC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ACAD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ACAD4: 419A0044  beq cr6, 0x821acb18
	if ctx.cr[6].eq {
	pc = 0x821ACB18; continue 'dispatch;
	}
	// 821ACAD8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821ACADC; continue 'dispatch;
            }
            0x821ACADC => {
    //   block [0x821ACADC..0x821ACB10)
	// 821ACADC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821ACAE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ACAE4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821ACAE8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821ACAEC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821ACAF0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ACAF4: 4082FFE8  bne 0x821acadc
	if !ctx.cr[0].eq {
	pc = 0x821ACADC; continue 'dispatch;
	}
	// 821ACAF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ACAFC: 409A0014  bne cr6, 0x821acb10
	if !ctx.cr[6].eq {
	pc = 0x821ACB10; continue 'dispatch;
	}
	// 821ACB00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ACB04: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ACB08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821ACB0C: 4E800421  bctrl
	ctx.lr = 0x821ACB10;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821ACB10 => {
    //   block [0x821ACB10..0x821ACB18)
	// 821ACB10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821ACB14: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x821ACB18; continue 'dispatch;
            }
            0x821ACB18 => {
    //   block [0x821ACB18..0x821ACB2C)
	// 821ACB18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821ACB1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ACB20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ACB24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ACB28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ACB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ACB30 size=108
    let mut pc: u32 = 0x821ACB30;
    'dispatch: loop {
        match pc {
            0x821ACB30 => {
    //   block [0x821ACB30..0x821ACB9C)
	// 821ACB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ACB34: 48AFC8D9  bl 0x82ca940c
	ctx.lr = 0x821ACB38;
	sub_82CA93D0(ctx, base);
	// 821ACB38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ACB3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ACB40: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821ACB44: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 821ACB48: 394B17F8  addi r10, r11, 0x17f8
	ctx.r[10].s64 = ctx.r[11].s64 + 6136;
	// 821ACB4C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821ACB50: 480EDD01  bl 0x8229a850
	ctx.lr = 0x821ACB54;
	sub_8229A850(ctx, base);
	// 821ACB54: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 821ACB58: 4816B2F1  bl 0x82317e48
	ctx.lr = 0x821ACB5C;
	sub_82317E48(ctx, base);
	// 821ACB5C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821ACB60: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 821ACB64: 3BA90B7C  addi r29, r9, 0xb7c
	ctx.r[29].s64 = ctx.r[9].s64 + 2940;
	// 821ACB68: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 821ACB6C: 4BFE72CD  bl 0x82193e38
	ctx.lr = 0x821ACB70;
	sub_82193E38(ctx, base);
	// 821ACB70: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821ACB74: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 821ACB78: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 821ACB7C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821ACB80: 4BFE72B9  bl 0x82193e38
	ctx.lr = 0x821ACB84;
	sub_82193E38(ctx, base);
	// 821ACB84: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 821ACB88: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821ACB8C: 38E81848  addi r7, r8, 0x1848
	ctx.r[7].s64 = ctx.r[8].s64 + 6216;
	// 821ACB90: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821ACB94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821ACB98: 48AFC8C4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ACBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ACBA0 size=344
    let mut pc: u32 = 0x821ACBA0;
    'dispatch: loop {
        match pc {
            0x821ACBA0 => {
    //   block [0x821ACBA0..0x821ACBD8)
	// 821ACBA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ACBA4: 48AFC85D  bl 0x82ca9400
	ctx.lr = 0x821ACBA8;
	sub_82CA93D0(ctx, base);
	// 821ACBA8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ACBAC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821ACBB0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821ACBB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ACBB8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821ACBBC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 821ACBC0: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ACBC4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ACBC8: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821ACBCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ACBD0: 409A0044  bne cr6, 0x821acc14
	if !ctx.cr[6].eq {
	pc = 0x821ACC14; continue 'dispatch;
	}
	// 821ACBD4: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821ACBD8; continue 'dispatch;
            }
            0x821ACBD8 => {
    //   block [0x821ACBD8..0x821ACBF0)
	// 821ACBD8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821ACBDC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821ACBE0: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821ACBE4: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 821ACBE8: 41980008  blt cr6, 0x821acbf0
	if ctx.cr[6].lt {
	pc = 0x821ACBF0; continue 'dispatch;
	}
	// 821ACBEC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821ACBF0; continue 'dispatch;
            }
            0x821ACBF0 => {
    //   block [0x821ACBF0..0x821ACC04)
	// 821ACBF0: 555D063E  clrlwi r29, r10, 0x18
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821ACBF4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821ACBF8: 419A000C  beq cr6, 0x821acc04
	if ctx.cr[6].eq {
	pc = 0x821ACC04; continue 'dispatch;
	}
	// 821ACBFC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ACC00: 48000008  b 0x821acc08
	pc = 0x821ACC08; continue 'dispatch;
            }
            0x821ACC04 => {
    //   block [0x821ACC04..0x821ACC08)
	// 821ACC04: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x821ACC08; continue 'dispatch;
            }
            0x821ACC08 => {
    //   block [0x821ACC08..0x821ACC14)
	// 821ACC08: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821ACC0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ACC10: 419AFFC8  beq cr6, 0x821acbd8
	if ctx.cr[6].eq {
	pc = 0x821ACBD8; continue 'dispatch;
	}
	pc = 0x821ACC14; continue 'dispatch;
            }
            0x821ACC14 => {
    //   block [0x821ACC14..0x821ACC74)
	// 821ACC14: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 821ACC18: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821ACC1C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821ACC20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACC24: 419A0054  beq cr6, 0x821acc78
	if ctx.cr[6].eq {
	pc = 0x821ACC78; continue 'dispatch;
	}
	// 821ACC28: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ACC2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821ACC30: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ACC34: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821ACC38: 409A003C  bne cr6, 0x821acc74
	if !ctx.cr[6].eq {
	pc = 0x821ACC74; continue 'dispatch;
	}
	// 821ACC3C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821ACC40: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821ACC44: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821ACC48: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821ACC4C: 489C52AD  bl 0x82b71ef8
	ctx.lr = 0x821ACC50;
	sub_82B71EF8(ctx, base);
	// 821ACC50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821ACC54: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 821ACC58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821ACC5C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ACC60: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ACC64: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821ACC68: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821ACC6C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821ACC70: 48AFC7E0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x821ACC74 => {
    //   block [0x821ACC74..0x821ACC78)
	// 821ACC74: 48907885  bl 0x82ab44f8
	ctx.lr = 0x821ACC78;
	sub_82AB44F8(ctx, base);
	pc = 0x821ACC78; continue 'dispatch;
            }
            0x821ACC78 => {
    //   block [0x821ACC78..0x821ACC94)
	// 821ACC78: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821ACC7C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ACC80: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821ACC84: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821ACC88: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821ACC8C: 41980008  blt cr6, 0x821acc94
	if ctx.cr[6].lt {
	pc = 0x821ACC94; continue 'dispatch;
	}
	// 821ACC90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821ACC94; continue 'dispatch;
            }
            0x821ACC94 => {
    //   block [0x821ACC94..0x821ACCDC)
	// 821ACC94: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ACC98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACC9C: 419A0040  beq cr6, 0x821accdc
	if ctx.cr[6].eq {
	pc = 0x821ACCDC; continue 'dispatch;
	}
	// 821ACCA0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821ACCA4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821ACCA8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821ACCAC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821ACCB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821ACCB4: 489C5245  bl 0x82b71ef8
	ctx.lr = 0x821ACCB8;
	sub_82B71EF8(ctx, base);
	// 821ACCB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821ACCBC: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 821ACCC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821ACCC4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ACCC8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ACCCC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821ACCD0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821ACCD4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821ACCD8: 48AFC778  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x821ACCDC => {
    //   block [0x821ACCDC..0x821ACCF8)
	// 821ACCDC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821ACCE0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821ACCE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821ACCE8: 995F0008  stb r10, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 821ACCEC: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821ACCF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821ACCF4: 48AFC75C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ACCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ACCF8 size=700
    let mut pc: u32 = 0x821ACCF8;
    'dispatch: loop {
        match pc {
            0x821ACCF8 => {
    //   block [0x821ACCF8..0x821ACD1C)
	// 821ACCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ACCFC: 48AFC70D  bl 0x82ca9408
	ctx.lr = 0x821ACD00;
	sub_82CA93D0(ctx, base);
	// 821ACD00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ACD04: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821ACD08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821ACD0C: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ACD10: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821ACD14: 419A0024  beq cr6, 0x821acd38
	if ctx.cr[6].eq {
	pc = 0x821ACD38; continue 'dispatch;
	}
	// 821ACD18: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x821ACD1C; continue 'dispatch;
            }
            0x821ACD1C => {
    //   block [0x821ACD1C..0x821ACD38)
	// 821ACD1C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821ACD20: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ACD24: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821ACD28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821ACD2C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821ACD30: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ACD34: 4082FFE8  bne 0x821acd1c
	if !ctx.cr[0].eq {
	pc = 0x821ACD1C; continue 'dispatch;
	}
	pc = 0x821ACD38; continue 'dispatch;
            }
            0x821ACD38 => {
    //   block [0x821ACD38..0x821ACD50)
	// 821ACD38: 83DD007C  lwz r30, 0x7c(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 821ACD3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821ACD40: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821ACD44: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 821ACD48: 419A0060  beq cr6, 0x821acda8
	if ctx.cr[6].eq {
	pc = 0x821ACDA8; continue 'dispatch;
	}
	// 821ACD4C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x821ACD50; continue 'dispatch;
            }
            0x821ACD50 => {
    //   block [0x821ACD50..0x821ACD6C)
	// 821ACD50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821ACD54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ACD58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821ACD5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821ACD60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821ACD64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ACD68: 4082FFE8  bne 0x821acd50
	if !ctx.cr[0].eq {
	pc = 0x821ACD50; continue 'dispatch;
	}
	pc = 0x821ACD6C; continue 'dispatch;
            }
            0x821ACD6C => {
    //   block [0x821ACD6C..0x821ACDA8)
	// 821ACD6C: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 821ACD70: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ACD74: 7D005828  lwarx r8, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 821ACD78: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 821ACD7C: 7D00592D  stwcx. r8, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821ACD80: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ACD84: 4082FFE8  bne 0x821acd6c
	if !ctx.cr[0].eq {
	pc = 0x821ACD6C; continue 'dispatch;
	}
	// 821ACD88: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821ACD8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ACD90: 409A0018  bne cr6, 0x821acda8
	if !ctx.cr[6].eq {
	pc = 0x821ACDA8; continue 'dispatch;
	}
	// 821ACD94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ACD98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821ACD9C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ACDA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821ACDA4: 4E800421  bctrl
	ctx.lr = 0x821ACDA8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821ACDA8 => {
    //   block [0x821ACDA8..0x821ACDBC)
	// 821ACDA8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821ACDAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821ACDB0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821ACDB4: 419A0024  beq cr6, 0x821acdd8
	if ctx.cr[6].eq {
	pc = 0x821ACDD8; continue 'dispatch;
	}
	// 821ACDB8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x821ACDBC; continue 'dispatch;
            }
            0x821ACDBC => {
    //   block [0x821ACDBC..0x821ACDD8)
	// 821ACDBC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821ACDC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ACDC4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821ACDC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821ACDCC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821ACDD0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ACDD4: 4082FFE8  bne 0x821acdbc
	if !ctx.cr[0].eq {
	pc = 0x821ACDBC; continue 'dispatch;
	}
	pc = 0x821ACDD8; continue 'dispatch;
            }
            0x821ACDD8 => {
    //   block [0x821ACDD8..0x821ACE4C)
	// 821ACDD8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821ACDDC: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 821ACDE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821ACDE4: 4BFFFDBD  bl 0x821acba0
	ctx.lr = 0x821ACDE8;
	sub_821ACBA0(ctx, base);
	// 821ACDE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821ACDEC: 4BFFFCCD  bl 0x821acab8
	ctx.lr = 0x821ACDF0;
	sub_821ACAB8(ctx, base);
	// 821ACDF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821ACDF4: 4BFFFCC5  bl 0x821acab8
	ctx.lr = 0x821ACDF8;
	sub_821ACAB8(ctx, base);
	// 821ACDF8: 897D0241  lbz r11, 0x241(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(577 as u32) ) } as u64;
	// 821ACDFC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821ACE00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACE04: 419A0150  beq cr6, 0x821acf54
	if ctx.cr[6].eq {
	pc = 0x821ACF54; continue 'dispatch;
	}
	// 821ACE08: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ACE0C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821ACE10: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821ACE14: 5528CFFE  rlwinm r8, r9, 0x19, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000007Fu64;
	// 821ACE18: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821ACE1C: 419A00F4  beq cr6, 0x821acf10
	if ctx.cr[6].eq {
	pc = 0x821ACF10; continue 'dispatch;
	}
	// 821ACE20: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821ACE24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ACE28: 419A0024  beq cr6, 0x821ace4c
	if ctx.cr[6].eq {
	pc = 0x821ACE4C; continue 'dispatch;
	}
	// 821ACE2C: 892A0087  lbz r9, 0x87(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(135 as u32) ) } as u64;
	// 821ACE30: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821ACE34: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821ACE38: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821ACE3C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ACE40: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821ACE44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ACE48: 480000CC  b 0x821acf14
	pc = 0x821ACF14; continue 'dispatch;
            }
            0x821ACE4C => {
    //   block [0x821ACE4C..0x821ACE68)
	// 821ACE4C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821ACE50: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821ACE54: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821ACE58: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821ACE5C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821ACE60: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ACE64: 40810054  ble 0x821aceb8
	if !ctx.cr[0].gt {
	pc = 0x821ACEB8; continue 'dispatch;
	}
	pc = 0x821ACE68; continue 'dispatch;
            }
            0x821ACE68 => {
    //   block [0x821ACE68..0x821ACE88)
	// 821ACE68: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821ACE6C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821ACE70: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821ACE74: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ACE78: 2F070087  cmpwi cr6, r7, 0x87
	ctx.cr[6].compare_i32(ctx.r[7].s32, 135, &mut ctx.xer);
	// 821ACE7C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821ACE80: 41980008  blt cr6, 0x821ace88
	if ctx.cr[6].lt {
	pc = 0x821ACE88; continue 'dispatch;
	}
	// 821ACE84: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x821ACE88; continue 'dispatch;
            }
            0x821ACE88 => {
    //   block [0x821ACE88..0x821ACEA4)
	// 821ACE88: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821ACE8C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821ACE90: 419A0014  beq cr6, 0x821acea4
	if ctx.cr[6].eq {
	pc = 0x821ACEA4; continue 'dispatch;
	}
	// 821ACE94: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821ACE98: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821ACE9C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821ACEA0: 4800000C  b 0x821aceac
	pc = 0x821ACEAC; continue 'dispatch;
            }
            0x821ACEA4 => {
    //   block [0x821ACEA4..0x821ACEAC)
	// 821ACEA4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821ACEA8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821ACEAC; continue 'dispatch;
            }
            0x821ACEAC => {
    //   block [0x821ACEAC..0x821ACEB8)
	// 821ACEAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ACEB0: 4199FFB8  bgt cr6, 0x821ace68
	if ctx.cr[6].gt {
	pc = 0x821ACE68; continue 'dispatch;
	}
	// 821ACEB4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821ACEB8; continue 'dispatch;
            }
            0x821ACEB8 => {
    //   block [0x821ACEB8..0x821ACED4)
	// 821ACEB8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821ACEBC: 419A0040  beq cr6, 0x821acefc
	if ctx.cr[6].eq {
	pc = 0x821ACEFC; continue 'dispatch;
	}
	// 821ACEC0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ACEC4: 2F0B0087  cmpwi cr6, r11, 0x87
	ctx.cr[6].compare_i32(ctx.r[11].s32, 135, &mut ctx.xer);
	// 821ACEC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ACECC: 41990008  bgt cr6, 0x821aced4
	if ctx.cr[6].gt {
	pc = 0x821ACED4; continue 'dispatch;
	}
	// 821ACED0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821ACED4; continue 'dispatch;
            }
            0x821ACED4 => {
    //   block [0x821ACED4..0x821ACEFC)
	// 821ACED4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ACED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACEDC: 409A0020  bne cr6, 0x821acefc
	if !ctx.cr[6].eq {
	pc = 0x821ACEFC; continue 'dispatch;
	}
	// 821ACEE0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821ACEE4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821ACEE8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821ACEEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ACEF0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821ACEF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ACEF8: 4800001C  b 0x821acf14
	pc = 0x821ACF14; continue 'dispatch;
            }
            0x821ACEFC => {
    //   block [0x821ACEFC..0x821ACF10)
	// 821ACEFC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821ACF00: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ACF04: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821ACF08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ACF0C: 48000008  b 0x821acf14
	pc = 0x821ACF14; continue 'dispatch;
            }
            0x821ACF10 => {
    //   block [0x821ACF10..0x821ACF14)
	// 821ACF10: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821ACF14; continue 'dispatch;
            }
            0x821ACF14 => {
    //   block [0x821ACF14..0x821ACF50)
	// 821ACF14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ACF18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACF1C: 419A0034  beq cr6, 0x821acf50
	if ctx.cr[6].eq {
	pc = 0x821ACF50; continue 'dispatch;
	}
	// 821ACF20: 816A002C  lwz r11, 0x2c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 821ACF24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACF28: 419A0028  beq cr6, 0x821acf50
	if ctx.cr[6].eq {
	pc = 0x821ACF50; continue 'dispatch;
	}
	// 821ACF2C: 806B0028  lwz r3, 0x28(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821ACF30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ACF34: 419A001C  beq cr6, 0x821acf50
	if ctx.cr[6].eq {
	pc = 0x821ACF50; continue 'dispatch;
	}
	// 821ACF38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ACF3C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821ACF40: 38800064  li r4, 0x64
	ctx.r[4].s64 = 100;
	// 821ACF44: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821ACF48: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821ACF4C: 4E800421  bctrl
	ctx.lr = 0x821ACF50;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821ACF50 => {
    //   block [0x821ACF50..0x821ACF54)
	// 821ACF50: 9BDD0241  stb r30, 0x241(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(577 as u32), ctx.r[30].u8 ) };
	pc = 0x821ACF54; continue 'dispatch;
            }
            0x821ACF54 => {
    //   block [0x821ACF54..0x821ACF70)
	// 821ACF54: 83FD007C  lwz r31, 0x7c(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 821ACF58: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 821ACF5C: 917D007C  stw r11, 0x7c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821ACF60: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ACF64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ACF68: 419A0040  beq cr6, 0x821acfa8
	if ctx.cr[6].eq {
	pc = 0x821ACFA8; continue 'dispatch;
	}
	// 821ACF6C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821ACF70; continue 'dispatch;
            }
            0x821ACF70 => {
    //   block [0x821ACF70..0x821ACFA4)
	// 821ACF70: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821ACF74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ACF78: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821ACF7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821ACF80: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821ACF84: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821ACF88: 4082FFE8  bne 0x821acf70
	if !ctx.cr[0].eq {
	pc = 0x821ACF70; continue 'dispatch;
	}
	// 821ACF8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ACF90: 409A0014  bne cr6, 0x821acfa4
	if !ctx.cr[6].eq {
	pc = 0x821ACFA4; continue 'dispatch;
	}
	// 821ACF94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ACF98: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ACF9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821ACFA0: 4E800421  bctrl
	ctx.lr = 0x821ACFA4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821ACFA4 => {
    //   block [0x821ACFA4..0x821ACFA8)
	// 821ACFA4: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x821ACFA8; continue 'dispatch;
            }
            0x821ACFA8 => {
    //   block [0x821ACFA8..0x821ACFB4)
	// 821ACFA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821ACFAC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821ACFB0: 48AFC4A8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ACFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ACFB8 size=316
    let mut pc: u32 = 0x821ACFB8;
    'dispatch: loop {
        match pc {
            0x821ACFB8 => {
    //   block [0x821ACFB8..0x821AD0D0)
	// 821ACFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ACFBC: 48AFC449  bl 0x82ca9404
	ctx.lr = 0x821ACFC0;
	sub_82CA93D0(ctx, base);
	// 821ACFC0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ACFC4: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821ACFC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821ACFCC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821ACFD0: 807F6E98  lwz r3, 0x6e98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28312 as u32) ) } as u64;
	// 821ACFD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ACFD8: 419A00F8  beq cr6, 0x821ad0d0
	if ctx.cr[6].eq {
	pc = 0x821AD0D0; continue 'dispatch;
	}
	// 821ACFDC: 396001C0  li r11, 0x1c0
	ctx.r[11].s64 = 448;
	// 821ACFE0: 394000D0  li r10, 0xd0
	ctx.r[10].s64 = 208;
	// 821ACFE4: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821ACFE8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	pc = 0x821AD0D0; continue 'dispatch;
            }
            0x821AD0D0 => {
    //   block [0x821AD0D0..0x821AD0F4)
	// 821AD0D0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD0D4: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821AD0D8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821AD0DC: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AD0E0: 806AF9C4  lwz r3, -0x63c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-1596 as u32) ) } as u64;
	// 821AD0E4: 80890008  lwz r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AD0E8: 4BFEA6D1  bl 0x821977b8
	ctx.lr = 0x821AD0EC;
	sub_821977B8(ctx, base);
	// 821AD0EC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AD0F0: 48AFC364  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AD0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AD0F8 size=128
    let mut pc: u32 = 0x821AD0F8;
    'dispatch: loop {
        match pc {
            0x821AD0F8 => {
    //   block [0x821AD0F8..0x821AD178)
	// 821AD0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AD0FC: 48AFC311  bl 0x82ca940c
	ctx.lr = 0x821AD100;
	sub_82CA93D0(ctx, base);
	// 821AD100: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AD104: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821AD108: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AD10C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821AD110: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821AD114: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821AD118: 388B1088  addi r4, r11, 0x1088
	ctx.r[4].s64 = ctx.r[11].s64 + 4232;
	// 821AD11C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AD120: 4807FDB1  bl 0x8222ced0
	ctx.lr = 0x821AD124;
	sub_8222CED0(ctx, base);
	// 821AD124: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821AD128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AD12C: 392A9490  addi r9, r10, -0x6b70
	ctx.r[9].s64 = ctx.r[10].s64 + -27504;
	// 821AD130: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821AD134: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 821AD138: C1AA9490  lfs f13, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AD13C: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821AD140: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AD144: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821AD148: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821AD14C: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821AD150: 48009771  bl 0x821b68c0
	ctx.lr = 0x821AD154;
	sub_821B68C0(ctx, base);
	// 821AD154: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AD158: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821AD15C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821AD160: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 821AD164: 48094FA5  bl 0x82242108
	ctx.lr = 0x821AD168;
	sub_82242108(ctx, base);
	// 821AD168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AD16C: 48067C6D  bl 0x82214dd8
	ctx.lr = 0x821AD170;
	sub_82214DD8(ctx, base);
	// 821AD170: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821AD174: 48AFC2E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AD178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AD178 size=372
    let mut pc: u32 = 0x821AD178;
    'dispatch: loop {
        match pc {
            0x821AD178 => {
    //   block [0x821AD178..0x821AD1A0)
	// 821AD178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AD17C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AD180: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AD184: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821AD188: 419A0018  beq cr6, 0x821ad1a0
	if ctx.cr[6].eq {
	pc = 0x821AD1A0; continue 'dispatch;
	}
	// 821AD18C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821AD190: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD194: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD198: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AD19C: 409A0008  bne cr6, 0x821ad1a4
	if !ctx.cr[6].eq {
	pc = 0x821AD1A4; continue 'dispatch;
	}
	pc = 0x821AD1A0; continue 'dispatch;
            }
            0x821AD1A0 => {
    //   block [0x821AD1A0..0x821AD1A4)
	// 821AD1A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AD1A4; continue 'dispatch;
            }
            0x821AD1A4 => {
    //   block [0x821AD1A4..0x821AD1EC)
	// 821AD1A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AD1A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD1AC: 419A012C  beq cr6, 0x821ad2d8
	if ctx.cr[6].eq {
	pc = 0x821AD2D8; continue 'dispatch;
	}
	// 821AD1B0: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 821AD1B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AD1B8: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821AD1BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AD1C0: 419A00E8  beq cr6, 0x821ad2a8
	if ctx.cr[6].eq {
	pc = 0x821AD2A8; continue 'dispatch;
	}
	// 821AD1C4: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AD1C8: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AD1CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD1D0: 419A001C  beq cr6, 0x821ad1ec
	if ctx.cr[6].eq {
	pc = 0x821AD1EC; continue 'dispatch;
	}
	// 821AD1D4: 896B0041  lbz r11, 0x41(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 821AD1D8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821AD1DC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AD1E0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD1E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AD1E8: 480000C4  b 0x821ad2ac
	pc = 0x821AD2AC; continue 'dispatch;
            }
            0x821AD1EC => {
    //   block [0x821AD1EC..0x821AD208)
	// 821AD1EC: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AD1F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AD1F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AD1F8: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AD1FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821AD200: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD204: 40810054  ble 0x821ad258
	if !ctx.cr[0].gt {
	pc = 0x821AD258; continue 'dispatch;
	}
	pc = 0x821AD208; continue 'dispatch;
            }
            0x821AD208 => {
    //   block [0x821AD208..0x821AD228)
	// 821AD208: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AD20C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AD210: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AD214: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AD218: 2F070041  cmpwi cr6, r7, 0x41
	ctx.cr[6].compare_i32(ctx.r[7].s32, 65, &mut ctx.xer);
	// 821AD21C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AD220: 41980008  blt cr6, 0x821ad228
	if ctx.cr[6].lt {
	pc = 0x821AD228; continue 'dispatch;
	}
	// 821AD224: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821AD228; continue 'dispatch;
            }
            0x821AD228 => {
    //   block [0x821AD228..0x821AD244)
	// 821AD228: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AD22C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AD230: 419A0014  beq cr6, 0x821ad244
	if ctx.cr[6].eq {
	pc = 0x821AD244; continue 'dispatch;
	}
	// 821AD234: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AD238: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AD23C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AD240: 4800000C  b 0x821ad24c
	pc = 0x821AD24C; continue 'dispatch;
            }
            0x821AD244 => {
    //   block [0x821AD244..0x821AD24C)
	// 821AD244: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AD248: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AD24C; continue 'dispatch;
            }
            0x821AD24C => {
    //   block [0x821AD24C..0x821AD258)
	// 821AD24C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD250: 4199FFB8  bgt cr6, 0x821ad208
	if ctx.cr[6].gt {
	pc = 0x821AD208; continue 'dispatch;
	}
	// 821AD254: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821AD258; continue 'dispatch;
            }
            0x821AD258 => {
    //   block [0x821AD258..0x821AD274)
	// 821AD258: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AD25C: 419A003C  beq cr6, 0x821ad298
	if ctx.cr[6].eq {
	pc = 0x821AD298; continue 'dispatch;
	}
	// 821AD260: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AD264: 2F0B0041  cmpwi cr6, r11, 0x41
	ctx.cr[6].compare_i32(ctx.r[11].s32, 65, &mut ctx.xer);
	// 821AD268: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD26C: 41990008  bgt cr6, 0x821ad274
	if ctx.cr[6].gt {
	pc = 0x821AD274; continue 'dispatch;
	}
	// 821AD270: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AD274; continue 'dispatch;
            }
            0x821AD274 => {
    //   block [0x821AD274..0x821AD298)
	// 821AD274: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AD278: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD27C: 409A001C  bne cr6, 0x821ad298
	if !ctx.cr[6].eq {
	pc = 0x821AD298; continue 'dispatch;
	}
	// 821AD280: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AD284: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AD288: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AD28C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AD290: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD294: 48000018  b 0x821ad2ac
	pc = 0x821AD2AC; continue 'dispatch;
            }
            0x821AD298 => {
    //   block [0x821AD298..0x821AD2A8)
	// 821AD298: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AD29C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AD2A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD2A4: 48000008  b 0x821ad2ac
	pc = 0x821AD2AC; continue 'dispatch;
            }
            0x821AD2A8 => {
    //   block [0x821AD2A8..0x821AD2AC)
	// 821AD2A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821AD2AC; continue 'dispatch;
            }
            0x821AD2AC => {
    //   block [0x821AD2AC..0x821AD2D8)
	// 821AD2AC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821AD2B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AD2B4: 419A0024  beq cr6, 0x821ad2d8
	if ctx.cr[6].eq {
	pc = 0x821AD2D8; continue 'dispatch;
	}
	// 821AD2B8: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AD2BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821AD2C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821AD2C4: 4E800421  bctrl
	ctx.lr = 0x821AD2C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AD2C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AD2CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AD2D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AD2D4: 4E800020  blr
	return;
            }
            0x821AD2D8 => {
    //   block [0x821AD2D8..0x821AD2EC)
	// 821AD2D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AD2DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AD2E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AD2E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AD2E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AD2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AD2F0 size=372
    let mut pc: u32 = 0x821AD2F0;
    'dispatch: loop {
        match pc {
            0x821AD2F0 => {
    //   block [0x821AD2F0..0x821AD318)
	// 821AD2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AD2F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AD2F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AD2FC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821AD300: 419A0018  beq cr6, 0x821ad318
	if ctx.cr[6].eq {
	pc = 0x821AD318; continue 'dispatch;
	}
	// 821AD304: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821AD308: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD30C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD310: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AD314: 409A0008  bne cr6, 0x821ad31c
	if !ctx.cr[6].eq {
	pc = 0x821AD31C; continue 'dispatch;
	}
	pc = 0x821AD318; continue 'dispatch;
            }
            0x821AD318 => {
    //   block [0x821AD318..0x821AD31C)
	// 821AD318: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AD31C; continue 'dispatch;
            }
            0x821AD31C => {
    //   block [0x821AD31C..0x821AD364)
	// 821AD31C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AD320: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD324: 419A012C  beq cr6, 0x821ad450
	if ctx.cr[6].eq {
	pc = 0x821AD450; continue 'dispatch;
	}
	// 821AD328: 81440034  lwz r10, 0x34(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 821AD32C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AD330: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821AD334: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AD338: 419A00E8  beq cr6, 0x821ad420
	if ctx.cr[6].eq {
	pc = 0x821AD420; continue 'dispatch;
	}
	// 821AD33C: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AD340: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AD344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD348: 419A001C  beq cr6, 0x821ad364
	if ctx.cr[6].eq {
	pc = 0x821AD364; continue 'dispatch;
	}
	// 821AD34C: 896B0080  lbz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AD350: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821AD354: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AD358: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD35C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AD360: 480000C4  b 0x821ad424
	pc = 0x821AD424; continue 'dispatch;
            }
            0x821AD364 => {
    //   block [0x821AD364..0x821AD380)
	// 821AD364: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AD368: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AD36C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AD370: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AD374: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821AD378: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD37C: 40810054  ble 0x821ad3d0
	if !ctx.cr[0].gt {
	pc = 0x821AD3D0; continue 'dispatch;
	}
	pc = 0x821AD380; continue 'dispatch;
            }
            0x821AD380 => {
    //   block [0x821AD380..0x821AD3A0)
	// 821AD380: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AD384: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AD388: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AD38C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AD390: 2F070080  cmpwi cr6, r7, 0x80
	ctx.cr[6].compare_i32(ctx.r[7].s32, 128, &mut ctx.xer);
	// 821AD394: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AD398: 41980008  blt cr6, 0x821ad3a0
	if ctx.cr[6].lt {
	pc = 0x821AD3A0; continue 'dispatch;
	}
	// 821AD39C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821AD3A0; continue 'dispatch;
            }
            0x821AD3A0 => {
    //   block [0x821AD3A0..0x821AD3BC)
	// 821AD3A0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AD3A4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AD3A8: 419A0014  beq cr6, 0x821ad3bc
	if ctx.cr[6].eq {
	pc = 0x821AD3BC; continue 'dispatch;
	}
	// 821AD3AC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AD3B0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AD3B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AD3B8: 4800000C  b 0x821ad3c4
	pc = 0x821AD3C4; continue 'dispatch;
            }
            0x821AD3BC => {
    //   block [0x821AD3BC..0x821AD3C4)
	// 821AD3BC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AD3C0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AD3C4; continue 'dispatch;
            }
            0x821AD3C4 => {
    //   block [0x821AD3C4..0x821AD3D0)
	// 821AD3C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD3C8: 4199FFB8  bgt cr6, 0x821ad380
	if ctx.cr[6].gt {
	pc = 0x821AD380; continue 'dispatch;
	}
	// 821AD3CC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821AD3D0; continue 'dispatch;
            }
            0x821AD3D0 => {
    //   block [0x821AD3D0..0x821AD3EC)
	// 821AD3D0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AD3D4: 419A003C  beq cr6, 0x821ad410
	if ctx.cr[6].eq {
	pc = 0x821AD410; continue 'dispatch;
	}
	// 821AD3D8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AD3DC: 2F0B0080  cmpwi cr6, r11, 0x80
	ctx.cr[6].compare_i32(ctx.r[11].s32, 128, &mut ctx.xer);
	// 821AD3E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD3E4: 41990008  bgt cr6, 0x821ad3ec
	if ctx.cr[6].gt {
	pc = 0x821AD3EC; continue 'dispatch;
	}
	// 821AD3E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AD3EC; continue 'dispatch;
            }
            0x821AD3EC => {
    //   block [0x821AD3EC..0x821AD410)
	// 821AD3EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AD3F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD3F4: 409A001C  bne cr6, 0x821ad410
	if !ctx.cr[6].eq {
	pc = 0x821AD410; continue 'dispatch;
	}
	// 821AD3F8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AD3FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AD400: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AD404: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AD408: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD40C: 48000018  b 0x821ad424
	pc = 0x821AD424; continue 'dispatch;
            }
            0x821AD410 => {
    //   block [0x821AD410..0x821AD420)
	// 821AD410: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AD414: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AD418: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD41C: 48000008  b 0x821ad424
	pc = 0x821AD424; continue 'dispatch;
            }
            0x821AD420 => {
    //   block [0x821AD420..0x821AD424)
	// 821AD420: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821AD424; continue 'dispatch;
            }
            0x821AD424 => {
    //   block [0x821AD424..0x821AD450)
	// 821AD424: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821AD428: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AD42C: 419A0024  beq cr6, 0x821ad450
	if ctx.cr[6].eq {
	pc = 0x821AD450; continue 'dispatch;
	}
	// 821AD430: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AD434: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821AD438: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821AD43C: 4E800421  bctrl
	ctx.lr = 0x821AD440;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AD440: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AD444: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AD448: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AD44C: 4E800020  blr
	return;
            }
            0x821AD450 => {
    //   block [0x821AD450..0x821AD464)
	// 821AD450: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AD454: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AD458: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AD45C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AD460: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AD468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AD468 size=2276
    let mut pc: u32 = 0x821AD468;
    'dispatch: loop {
        match pc {
            0x821AD468 => {
    //   block [0x821AD468..0x821AD494)
	// 821AD468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AD46C: 48AFBF91  bl 0x82ca93fc
	ctx.lr = 0x821AD470;
	sub_82CA93D0(ctx, base);
	// 821AD470: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AD474: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821AD478: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821AD47C: 817A0364  lwz r11, 0x364(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(868 as u32) ) } as u64;
	// 821AD480: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821AD484: 409A0010  bne cr6, 0x821ad494
	if !ctx.cr[6].eq {
	pc = 0x821AD494; continue 'dispatch;
	}
	// 821AD488: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 821AD48C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD490: 419A08B4  beq cr6, 0x821add44
	if ctx.cr[6].eq {
	pc = 0x821ADD44; continue 'dispatch;
	}
	pc = 0x821AD494; continue 'dispatch;
            }
            0x821AD494 => {
    //   block [0x821AD494..0x821AD4E0)
	// 821AD494: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD498: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821AD49C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 821AD4A0: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 821AD4A4: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821AD4A8: 55491FFE  rlwinm r9, r10, 3, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 821AD4AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AD4B0: 419A00F4  beq cr6, 0x821ad5a4
	if ctx.cr[6].eq {
	pc = 0x821AD5A4; continue 'dispatch;
	}
	// 821AD4B4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AD4B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AD4BC: 419A0024  beq cr6, 0x821ad4e0
	if ctx.cr[6].eq {
	pc = 0x821AD4E0; continue 'dispatch;
	}
	// 821AD4C0: 894A003D  lbz r10, 0x3d(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(61 as u32) ) } as u64;
	// 821AD4C4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AD4C8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821AD4CC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AD4D0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD4D4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AD4D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD4DC: 480000CC  b 0x821ad5a8
	pc = 0x821AD5A8; continue 'dispatch;
            }
            0x821AD4E0 => {
    //   block [0x821AD4E0..0x821AD4FC)
	// 821AD4E0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AD4E4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AD4E8: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 821AD4EC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AD4F0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821AD4F4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD4F8: 40810054  ble 0x821ad54c
	if !ctx.cr[0].gt {
	pc = 0x821AD54C; continue 'dispatch;
	}
	pc = 0x821AD4FC; continue 'dispatch;
            }
            0x821AD4FC => {
    //   block [0x821AD4FC..0x821AD51C)
	// 821AD4FC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AD500: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AD504: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AD508: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AD50C: 2F07003D  cmpwi cr6, r7, 0x3d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 61, &mut ctx.xer);
	// 821AD510: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AD514: 41980008  blt cr6, 0x821ad51c
	if ctx.cr[6].lt {
	pc = 0x821AD51C; continue 'dispatch;
	}
	// 821AD518: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x821AD51C; continue 'dispatch;
            }
            0x821AD51C => {
    //   block [0x821AD51C..0x821AD538)
	// 821AD51C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AD520: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AD524: 419A0014  beq cr6, 0x821ad538
	if ctx.cr[6].eq {
	pc = 0x821AD538; continue 'dispatch;
	}
	// 821AD528: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AD52C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AD530: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AD534: 4800000C  b 0x821ad540
	pc = 0x821AD540; continue 'dispatch;
            }
            0x821AD538 => {
    //   block [0x821AD538..0x821AD540)
	// 821AD538: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AD53C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AD540; continue 'dispatch;
            }
            0x821AD540 => {
    //   block [0x821AD540..0x821AD54C)
	// 821AD540: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD544: 4199FFB8  bgt cr6, 0x821ad4fc
	if ctx.cr[6].gt {
	pc = 0x821AD4FC; continue 'dispatch;
	}
	// 821AD548: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x821AD54C; continue 'dispatch;
            }
            0x821AD54C => {
    //   block [0x821AD54C..0x821AD568)
	// 821AD54C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AD550: 419A0040  beq cr6, 0x821ad590
	if ctx.cr[6].eq {
	pc = 0x821AD590; continue 'dispatch;
	}
	// 821AD554: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AD558: 2F0B003D  cmpwi cr6, r11, 0x3d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 61, &mut ctx.xer);
	// 821AD55C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD560: 41990008  bgt cr6, 0x821ad568
	if ctx.cr[6].gt {
	pc = 0x821AD568; continue 'dispatch;
	}
	// 821AD564: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821AD568; continue 'dispatch;
            }
            0x821AD568 => {
    //   block [0x821AD568..0x821AD590)
	// 821AD568: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AD56C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD570: 409A0020  bne cr6, 0x821ad590
	if !ctx.cr[6].eq {
	pc = 0x821AD590; continue 'dispatch;
	}
	// 821AD574: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821AD578: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AD57C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AD580: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD584: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AD588: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD58C: 4800001C  b 0x821ad5a8
	pc = 0x821AD5A8; continue 'dispatch;
            }
            0x821AD590 => {
    //   block [0x821AD590..0x821AD5A4)
	// 821AD590: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AD594: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD598: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AD59C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD5A0: 48000008  b 0x821ad5a8
	pc = 0x821AD5A8; continue 'dispatch;
            }
            0x821AD5A4 => {
    //   block [0x821AD5A4..0x821AD5A8)
	// 821AD5A4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821AD5A8; continue 'dispatch;
            }
            0x821AD5A8 => {
    //   block [0x821AD5A8..0x821AD5E8)
	// 821AD5A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AD5AC: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 821AD5B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD5B4: 419A0034  beq cr6, 0x821ad5e8
	if ctx.cr[6].eq {
	pc = 0x821AD5E8; continue 'dispatch;
	}
	// 821AD5B8: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821AD5BC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AD5C0: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821AD5C4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD5C8: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AD5CC: 4807EBED  bl 0x8222c1b8
	ctx.lr = 0x821AD5D0;
	sub_8222C1B8(ctx, base);
	// 821AD5D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821AD5D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AD5D8: 4BFEC5E1  bl 0x82199bb8
	ctx.lr = 0x821AD5DC;
	sub_82199BB8(ctx, base);
	// 821AD5DC: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821AD5E0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AD5E4: 409A0128  bne cr6, 0x821ad70c
	if !ctx.cr[6].eq {
	pc = 0x821AD70C; continue 'dispatch;
	}
	pc = 0x821AD5E8; continue 'dispatch;
            }
            0x821AD5E8 => {
    //   block [0x821AD5E8..0x821AD628)
	// 821AD5E8: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD5EC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD5F0: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 821AD5F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AD5F8: 419A00F4  beq cr6, 0x821ad6ec
	if ctx.cr[6].eq {
	pc = 0x821AD6EC; continue 'dispatch;
	}
	// 821AD5FC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AD600: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AD604: 419A0024  beq cr6, 0x821ad628
	if ctx.cr[6].eq {
	pc = 0x821AD628; continue 'dispatch;
	}
	// 821AD608: 894A007A  lbz r10, 0x7a(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(122 as u32) ) } as u64;
	// 821AD60C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AD610: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821AD614: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AD618: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD61C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821AD620: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD624: 480000CC  b 0x821ad6f0
	pc = 0x821AD6F0; continue 'dispatch;
            }
            0x821AD628 => {
    //   block [0x821AD628..0x821AD644)
	// 821AD628: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AD62C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AD630: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 821AD634: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AD638: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821AD63C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD640: 40810054  ble 0x821ad694
	if !ctx.cr[0].gt {
	pc = 0x821AD694; continue 'dispatch;
	}
	pc = 0x821AD644; continue 'dispatch;
            }
            0x821AD644 => {
    //   block [0x821AD644..0x821AD664)
	// 821AD644: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AD648: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AD64C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AD650: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AD654: 2F07007A  cmpwi cr6, r7, 0x7a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 122, &mut ctx.xer);
	// 821AD658: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AD65C: 41980008  blt cr6, 0x821ad664
	if ctx.cr[6].lt {
	pc = 0x821AD664; continue 'dispatch;
	}
	// 821AD660: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x821AD664; continue 'dispatch;
            }
            0x821AD664 => {
    //   block [0x821AD664..0x821AD680)
	// 821AD664: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AD668: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AD66C: 419A0014  beq cr6, 0x821ad680
	if ctx.cr[6].eq {
	pc = 0x821AD680; continue 'dispatch;
	}
	// 821AD670: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AD674: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AD678: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AD67C: 4800000C  b 0x821ad688
	pc = 0x821AD688; continue 'dispatch;
            }
            0x821AD680 => {
    //   block [0x821AD680..0x821AD688)
	// 821AD680: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AD684: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AD688; continue 'dispatch;
            }
            0x821AD688 => {
    //   block [0x821AD688..0x821AD694)
	// 821AD688: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD68C: 4199FFB8  bgt cr6, 0x821ad644
	if ctx.cr[6].gt {
	pc = 0x821AD644; continue 'dispatch;
	}
	// 821AD690: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x821AD694; continue 'dispatch;
            }
            0x821AD694 => {
    //   block [0x821AD694..0x821AD6B0)
	// 821AD694: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AD698: 419A0040  beq cr6, 0x821ad6d8
	if ctx.cr[6].eq {
	pc = 0x821AD6D8; continue 'dispatch;
	}
	// 821AD69C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AD6A0: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 821AD6A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD6A8: 41990008  bgt cr6, 0x821ad6b0
	if ctx.cr[6].gt {
	pc = 0x821AD6B0; continue 'dispatch;
	}
	// 821AD6AC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821AD6B0; continue 'dispatch;
            }
            0x821AD6B0 => {
    //   block [0x821AD6B0..0x821AD6D8)
	// 821AD6B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AD6B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD6B8: 409A0020  bne cr6, 0x821ad6d8
	if !ctx.cr[6].eq {
	pc = 0x821AD6D8; continue 'dispatch;
	}
	// 821AD6BC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821AD6C0: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AD6C4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AD6C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD6CC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821AD6D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD6D4: 4800001C  b 0x821ad6f0
	pc = 0x821AD6F0; continue 'dispatch;
            }
            0x821AD6D8 => {
    //   block [0x821AD6D8..0x821AD6EC)
	// 821AD6D8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AD6DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD6E0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821AD6E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD6E8: 48000008  b 0x821ad6f0
	pc = 0x821AD6F0; continue 'dispatch;
            }
            0x821AD6EC => {
    //   block [0x821AD6EC..0x821AD6F0)
	// 821AD6EC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821AD6F0; continue 'dispatch;
            }
            0x821AD6F0 => {
    //   block [0x821AD6F0..0x821AD70C)
	// 821AD6F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AD6F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD6F8: 419A064C  beq cr6, 0x821add44
	if ctx.cr[6].eq {
	pc = 0x821ADD44; continue 'dispatch;
	}
	// 821AD6FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AD700: 48015319  bl 0x821c2a18
	ctx.lr = 0x821AD704;
	sub_821C2A18(ctx, base);
	// 821AD704: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821AD708: 409A063C  bne cr6, 0x821add44
	if !ctx.cr[6].eq {
	pc = 0x821ADD44; continue 'dispatch;
	}
	pc = 0x821AD70C; continue 'dispatch;
            }
            0x821AD70C => {
    //   block [0x821AD70C..0x821AD764)
	// 821AD70C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD710: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821AD714: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AD718: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821AD71C: 794807E6  rldicr r8, r10, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 821AD720: 7D044B78  or r4, r8, r9
	ctx.r[4].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AD724: 481A160D  bl 0x8234ed30
	ctx.lr = 0x821AD728;
	sub_8234ED30(ctx, base);
	// 821AD728: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 821AD72C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AD730: 48042B11  bl 0x821f0240
	ctx.lr = 0x821AD734;
	sub_821F0240(ctx, base);
	// 821AD734: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 821AD738: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AD73C: 38875DC0  addi r4, r7, 0x5dc0
	ctx.r[4].s64 = ctx.r[7].s64 + 24000;
	// 821AD740: 4802D281  bl 0x821da9c0
	ctx.lr = 0x821AD744;
	sub_821DA9C0(ctx, base);
	// 821AD744: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821AD748: 48067691  bl 0x82214dd8
	ctx.lr = 0x821AD74C;
	sub_82214DD8(ctx, base);
	// 821AD74C: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 821AD750: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 821AD754: 419A0010  beq cr6, 0x821ad764
	if ctx.cr[6].eq {
	pc = 0x821AD764; continue 'dispatch;
	}
	// 821AD758: 817A0364  lwz r11, 0x364(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(868 as u32) ) } as u64;
	// 821AD75C: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821AD760: 419A002C  beq cr6, 0x821ad78c
	if ctx.cr[6].eq {
	pc = 0x821AD78C; continue 'dispatch;
	}
	pc = 0x821AD764; continue 'dispatch;
            }
            0x821AD764 => {
    //   block [0x821AD764..0x821AD78C)
	// 821AD764: 817D6B08  lwz r11, 0x6b08(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821AD768: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821AD76C: 809A0004  lwz r4, 4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD770: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AD774: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AD778: 48010021  bl 0x821bd798
	ctx.lr = 0x821AD77C;
	sub_821BD798(ctx, base);
	// 821AD77C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821AD780: 809A0004  lwz r4, 4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD784: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821AD788: 485F20E1  bl 0x8279f868
	ctx.lr = 0x821AD78C;
	sub_8279F868(ctx, base);
	pc = 0x821AD78C; continue 'dispatch;
            }
            0x821AD78C => {
    //   block [0x821AD78C..0x821AD7FC)
	// 821AD78C: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 821AD790: 419A045C  beq cr6, 0x821adbec
	if ctx.cr[6].eq {
	pc = 0x821ADBEC; continue 'dispatch;
	}
	// 821AD794: 817A0364  lwz r11, 0x364(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(868 as u32) ) } as u64;
	// 821AD798: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821AD79C: 419A0060  beq cr6, 0x821ad7fc
	if ctx.cr[6].eq {
	pc = 0x821AD7FC; continue 'dispatch;
	}
	// 821AD7A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821AD7A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821AD7A8: 388B0AF8  addi r4, r11, 0xaf8
	ctx.r[4].s64 = ctx.r[11].s64 + 2808;
	// 821AD7AC: 48128C5D  bl 0x822d6408
	ctx.lr = 0x821AD7B0;
	sub_822D6408(ctx, base);
	// 821AD7B0: 817D6B08  lwz r11, 0x6b08(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821AD7B4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821AD7B8: 80BA0004  lwz r5, 4(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD7BC: 573E103A  slwi r30, r25, 2
	ctx.r[30].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821AD7C0: 3BEAC00C  addi r31, r10, -0x3ff4
	ctx.r[31].s64 = ctx.r[10].s64 + -16372;
	// 821AD7C4: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 821AD7C8: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AD7CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821AD7D0: 7CFEF82E  lwzx r7, r30, r31
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821AD7D4: 8069001C  lwz r3, 0x1c(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AD7D8: 4822FED9  bl 0x823dd6b0
	ctx.lr = 0x821AD7DC;
	sub_823DD6B0(ctx, base);
	// 821AD7DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821AD7E0: 48019019  bl 0x821c67f8
	ctx.lr = 0x821AD7E4;
	sub_821C67F8(ctx, base);
	// 821AD7E4: 38C07FFF  li r6, 0x7fff
	ctx.r[6].s64 = 32767;
	// 821AD7E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821AD7EC: 7CFEF82E  lwzx r7, r30, r31
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821AD7F0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821AD7F4: 80BA0004  lwz r5, 4(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD7F8: 485F1FB9  bl 0x8279f7b0
	ctx.lr = 0x821AD7FC;
	sub_8279F7B0(ctx, base);
	pc = 0x821AD7FC; continue 'dispatch;
            }
            0x821AD7FC => {
    //   block [0x821AD7FC..0x821AD840)
	// 821AD7FC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD800: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 821AD804: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD808: 552817FE  rlwinm r8, r9, 2, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x3FFFFFFFu64;
	// 821AD80C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AD810: 419A00F4  beq cr6, 0x821ad904
	if ctx.cr[6].eq {
	pc = 0x821AD904; continue 'dispatch;
	}
	// 821AD814: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AD818: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AD81C: 419A0024  beq cr6, 0x821ad840
	if ctx.cr[6].eq {
	pc = 0x821AD840; continue 'dispatch;
	}
	// 821AD820: 894A007E  lbz r10, 0x7e(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(126 as u32) ) } as u64;
	// 821AD824: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AD828: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821AD82C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AD830: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD834: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AD838: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD83C: 480000CC  b 0x821ad908
	pc = 0x821AD908; continue 'dispatch;
            }
            0x821AD840 => {
    //   block [0x821AD840..0x821AD85C)
	// 821AD840: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AD844: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AD848: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 821AD84C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AD850: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821AD854: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD858: 40810054  ble 0x821ad8ac
	if !ctx.cr[0].gt {
	pc = 0x821AD8AC; continue 'dispatch;
	}
	pc = 0x821AD85C; continue 'dispatch;
            }
            0x821AD85C => {
    //   block [0x821AD85C..0x821AD87C)
	// 821AD85C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AD860: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AD864: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AD868: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AD86C: 2F07007E  cmpwi cr6, r7, 0x7e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 126, &mut ctx.xer);
	// 821AD870: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AD874: 41980008  blt cr6, 0x821ad87c
	if ctx.cr[6].lt {
	pc = 0x821AD87C; continue 'dispatch;
	}
	// 821AD878: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x821AD87C; continue 'dispatch;
            }
            0x821AD87C => {
    //   block [0x821AD87C..0x821AD898)
	// 821AD87C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AD880: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AD884: 419A0014  beq cr6, 0x821ad898
	if ctx.cr[6].eq {
	pc = 0x821AD898; continue 'dispatch;
	}
	// 821AD888: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AD88C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AD890: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AD894: 4800000C  b 0x821ad8a0
	pc = 0x821AD8A0; continue 'dispatch;
            }
            0x821AD898 => {
    //   block [0x821AD898..0x821AD8A0)
	// 821AD898: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AD89C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AD8A0; continue 'dispatch;
            }
            0x821AD8A0 => {
    //   block [0x821AD8A0..0x821AD8AC)
	// 821AD8A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD8A4: 4199FFB8  bgt cr6, 0x821ad85c
	if ctx.cr[6].gt {
	pc = 0x821AD85C; continue 'dispatch;
	}
	// 821AD8A8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x821AD8AC; continue 'dispatch;
            }
            0x821AD8AC => {
    //   block [0x821AD8AC..0x821AD8C8)
	// 821AD8AC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AD8B0: 419A0040  beq cr6, 0x821ad8f0
	if ctx.cr[6].eq {
	pc = 0x821AD8F0; continue 'dispatch;
	}
	// 821AD8B4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AD8B8: 2F0B007E  cmpwi cr6, r11, 0x7e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 126, &mut ctx.xer);
	// 821AD8BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD8C0: 41990008  bgt cr6, 0x821ad8c8
	if ctx.cr[6].gt {
	pc = 0x821AD8C8; continue 'dispatch;
	}
	// 821AD8C4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821AD8C8; continue 'dispatch;
            }
            0x821AD8C8 => {
    //   block [0x821AD8C8..0x821AD8F0)
	// 821AD8C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AD8CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD8D0: 409A0020  bne cr6, 0x821ad8f0
	if !ctx.cr[6].eq {
	pc = 0x821AD8F0; continue 'dispatch;
	}
	// 821AD8D4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821AD8D8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AD8DC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AD8E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD8E4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AD8E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD8EC: 4800001C  b 0x821ad908
	pc = 0x821AD908; continue 'dispatch;
            }
            0x821AD8F0 => {
    //   block [0x821AD8F0..0x821AD904)
	// 821AD8F0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AD8F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD8F8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AD8FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD900: 48000008  b 0x821ad908
	pc = 0x821AD908; continue 'dispatch;
            }
            0x821AD904 => {
    //   block [0x821AD904..0x821AD908)
	// 821AD904: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821AD908; continue 'dispatch;
            }
            0x821AD908 => {
    //   block [0x821AD908..0x821AD930)
	// 821AD908: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AD90C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD910: 419A0034  beq cr6, 0x821ad944
	if ctx.cr[6].eq {
	pc = 0x821AD944; continue 'dispatch;
	}
	// 821AD914: 896A0018  lbz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821AD918: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD91C: 419A0014  beq cr6, 0x821ad930
	if ctx.cr[6].eq {
	pc = 0x821AD930; continue 'dispatch;
	}
	// 821AD920: 896A0019  lbz r11, 0x19(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(25 as u32) ) } as u64;
	// 821AD924: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD928: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD92C: 419A0008  beq cr6, 0x821ad934
	if ctx.cr[6].eq {
	pc = 0x821AD934; continue 'dispatch;
	}
	pc = 0x821AD930; continue 'dispatch;
            }
            0x821AD930 => {
    //   block [0x821AD930..0x821AD934)
	// 821AD930: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821AD934; continue 'dispatch;
            }
            0x821AD934 => {
    //   block [0x821AD934..0x821AD944)
	// 821AD934: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AD938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD93C: 419A0008  beq cr6, 0x821ad944
	if ctx.cr[6].eq {
	pc = 0x821AD944; continue 'dispatch;
	}
	// 821AD940: 9B6A0018  stb r27, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	pc = 0x821AD944; continue 'dispatch;
            }
            0x821AD944 => {
    //   block [0x821AD944..0x821AD954)
	// 821AD944: 2F190002  cmpwi cr6, r25, 2
	ctx.cr[6].compare_i32(ctx.r[25].s32, 2, &mut ctx.xer);
	// 821AD948: 419A000C  beq cr6, 0x821ad954
	if ctx.cr[6].eq {
	pc = 0x821AD954; continue 'dispatch;
	}
	// 821AD94C: 2F190001  cmpwi cr6, r25, 1
	ctx.cr[6].compare_i32(ctx.r[25].s32, 1, &mut ctx.xer);
	// 821AD950: 409A03E8  bne cr6, 0x821add38
	if !ctx.cr[6].eq {
	pc = 0x821ADD38; continue 'dispatch;
	}
	pc = 0x821AD954; continue 'dispatch;
            }
            0x821AD954 => {
    //   block [0x821AD954..0x821AD998)
	// 821AD954: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD958: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 821AD95C: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AD960: 55284FFE  rlwinm r8, r9, 9, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x007FFFFFu64;
	// 821AD964: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AD968: 419A00F4  beq cr6, 0x821ada5c
	if ctx.cr[6].eq {
	pc = 0x821ADA5C; continue 'dispatch;
	}
	// 821AD96C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AD970: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AD974: 419A0024  beq cr6, 0x821ad998
	if ctx.cr[6].eq {
	pc = 0x821AD998; continue 'dispatch;
	}
	// 821AD978: 892A0017  lbz r9, 0x17(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(23 as u32) ) } as u64;
	// 821AD97C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AD980: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821AD984: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AD988: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD98C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AD990: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD994: 480000CC  b 0x821ada60
	pc = 0x821ADA60; continue 'dispatch;
            }
            0x821AD998 => {
    //   block [0x821AD998..0x821AD9B4)
	// 821AD998: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AD99C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AD9A0: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 821AD9A4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AD9A8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821AD9AC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD9B0: 40810054  ble 0x821ada04
	if !ctx.cr[0].gt {
	pc = 0x821ADA04; continue 'dispatch;
	}
	pc = 0x821AD9B4; continue 'dispatch;
            }
            0x821AD9B4 => {
    //   block [0x821AD9B4..0x821AD9D4)
	// 821AD9B4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AD9B8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AD9BC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AD9C0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AD9C4: 2F070017  cmpwi cr6, r7, 0x17
	ctx.cr[6].compare_i32(ctx.r[7].s32, 23, &mut ctx.xer);
	// 821AD9C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AD9CC: 41980008  blt cr6, 0x821ad9d4
	if ctx.cr[6].lt {
	pc = 0x821AD9D4; continue 'dispatch;
	}
	// 821AD9D0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x821AD9D4; continue 'dispatch;
            }
            0x821AD9D4 => {
    //   block [0x821AD9D4..0x821AD9F0)
	// 821AD9D4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AD9D8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AD9DC: 419A0014  beq cr6, 0x821ad9f0
	if ctx.cr[6].eq {
	pc = 0x821AD9F0; continue 'dispatch;
	}
	// 821AD9E0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AD9E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AD9E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AD9EC: 4800000C  b 0x821ad9f8
	pc = 0x821AD9F8; continue 'dispatch;
            }
            0x821AD9F0 => {
    //   block [0x821AD9F0..0x821AD9F8)
	// 821AD9F0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AD9F4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AD9F8; continue 'dispatch;
            }
            0x821AD9F8 => {
    //   block [0x821AD9F8..0x821ADA04)
	// 821AD9F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD9FC: 4199FFB8  bgt cr6, 0x821ad9b4
	if ctx.cr[6].gt {
	pc = 0x821AD9B4; continue 'dispatch;
	}
	// 821ADA00: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x821ADA04; continue 'dispatch;
            }
            0x821ADA04 => {
    //   block [0x821ADA04..0x821ADA20)
	// 821ADA04: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821ADA08: 419A0040  beq cr6, 0x821ada48
	if ctx.cr[6].eq {
	pc = 0x821ADA48; continue 'dispatch;
	}
	// 821ADA0C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ADA10: 2F0B0017  cmpwi cr6, r11, 0x17
	ctx.cr[6].compare_i32(ctx.r[11].s32, 23, &mut ctx.xer);
	// 821ADA14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADA18: 41990008  bgt cr6, 0x821ada20
	if ctx.cr[6].gt {
	pc = 0x821ADA20; continue 'dispatch;
	}
	// 821ADA1C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821ADA20; continue 'dispatch;
            }
            0x821ADA20 => {
    //   block [0x821ADA20..0x821ADA48)
	// 821ADA20: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ADA24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADA28: 409A0020  bne cr6, 0x821ada48
	if !ctx.cr[6].eq {
	pc = 0x821ADA48; continue 'dispatch;
	}
	// 821ADA2C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821ADA30: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821ADA34: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821ADA38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADA3C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821ADA40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADA44: 4800001C  b 0x821ada60
	pc = 0x821ADA60; continue 'dispatch;
            }
            0x821ADA48 => {
    //   block [0x821ADA48..0x821ADA5C)
	// 821ADA48: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821ADA4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADA50: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821ADA54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADA58: 48000008  b 0x821ada60
	pc = 0x821ADA60; continue 'dispatch;
            }
            0x821ADA5C => {
    //   block [0x821ADA5C..0x821ADA60)
	// 821ADA5C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821ADA60; continue 'dispatch;
            }
            0x821ADA60 => {
    //   block [0x821ADA60..0x821ADA90)
	// 821ADA60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ADA64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADA68: 419A0028  beq cr6, 0x821ada90
	if ctx.cr[6].eq {
	pc = 0x821ADA90; continue 'dispatch;
	}
	// 821ADA6C: 896A0021  lbz r11, 0x21(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 821ADA70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADA74: 419A001C  beq cr6, 0x821ada90
	if ctx.cr[6].eq {
	pc = 0x821ADA90; continue 'dispatch;
	}
	// 821ADA78: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821ADA7C: 3880003D  li r4, 0x3d
	ctx.r[4].s64 = 61;
	// 821ADA80: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821ADA84: 814B00A8  lwz r10, 0xa8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 821ADA88: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADA8C: 480077D5  bl 0x821b5260
	ctx.lr = 0x821ADA90;
	sub_821B5260(ctx, base);
	pc = 0x821ADA90; continue 'dispatch;
            }
            0x821ADA90 => {
    //   block [0x821ADA90..0x821ADADC)
	// 821ADA90: 2F190001  cmpwi cr6, r25, 1
	ctx.cr[6].compare_i32(ctx.r[25].s32, 1, &mut ctx.xer);
	// 821ADA94: 409A02A4  bne cr6, 0x821add38
	if !ctx.cr[6].eq {
	pc = 0x821ADD38; continue 'dispatch;
	}
	// 821ADA98: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADA9C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821ADAA0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821ADAA4: 55494FFE  rlwinm r9, r10, 9, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x007FFFFFu64;
	// 821ADAA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821ADAAC: 419A00F4  beq cr6, 0x821adba0
	if ctx.cr[6].eq {
	pc = 0x821ADBA0; continue 'dispatch;
	}
	// 821ADAB0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821ADAB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ADAB8: 419A0024  beq cr6, 0x821adadc
	if ctx.cr[6].eq {
	pc = 0x821ADADC; continue 'dispatch;
	}
	// 821ADABC: 892A0017  lbz r9, 0x17(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(23 as u32) ) } as u64;
	// 821ADAC0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821ADAC4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821ADAC8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821ADACC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADAD0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821ADAD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADAD8: 480000CC  b 0x821adba4
	pc = 0x821ADBA4; continue 'dispatch;
            }
            0x821ADADC => {
    //   block [0x821ADADC..0x821ADAF8)
	// 821ADADC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821ADAE0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821ADAE4: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 821ADAE8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821ADAEC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821ADAF0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ADAF4: 40810054  ble 0x821adb48
	if !ctx.cr[0].gt {
	pc = 0x821ADB48; continue 'dispatch;
	}
	pc = 0x821ADAF8; continue 'dispatch;
            }
            0x821ADAF8 => {
    //   block [0x821ADAF8..0x821ADB18)
	// 821ADAF8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821ADAFC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821ADB00: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821ADB04: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ADB08: 2F070017  cmpwi cr6, r7, 0x17
	ctx.cr[6].compare_i32(ctx.r[7].s32, 23, &mut ctx.xer);
	// 821ADB0C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821ADB10: 41980008  blt cr6, 0x821adb18
	if ctx.cr[6].lt {
	pc = 0x821ADB18; continue 'dispatch;
	}
	// 821ADB14: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x821ADB18; continue 'dispatch;
            }
            0x821ADB18 => {
    //   block [0x821ADB18..0x821ADB34)
	// 821ADB18: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821ADB1C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821ADB20: 419A0014  beq cr6, 0x821adb34
	if ctx.cr[6].eq {
	pc = 0x821ADB34; continue 'dispatch;
	}
	// 821ADB24: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821ADB28: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821ADB2C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821ADB30: 4800000C  b 0x821adb3c
	pc = 0x821ADB3C; continue 'dispatch;
            }
            0x821ADB34 => {
    //   block [0x821ADB34..0x821ADB3C)
	// 821ADB34: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821ADB38: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821ADB3C; continue 'dispatch;
            }
            0x821ADB3C => {
    //   block [0x821ADB3C..0x821ADB48)
	// 821ADB3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ADB40: 4199FFB8  bgt cr6, 0x821adaf8
	if ctx.cr[6].gt {
	pc = 0x821ADAF8; continue 'dispatch;
	}
	// 821ADB44: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x821ADB48; continue 'dispatch;
            }
            0x821ADB48 => {
    //   block [0x821ADB48..0x821ADB64)
	// 821ADB48: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821ADB4C: 419A0040  beq cr6, 0x821adb8c
	if ctx.cr[6].eq {
	pc = 0x821ADB8C; continue 'dispatch;
	}
	// 821ADB50: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ADB54: 2F0B0017  cmpwi cr6, r11, 0x17
	ctx.cr[6].compare_i32(ctx.r[11].s32, 23, &mut ctx.xer);
	// 821ADB58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADB5C: 41990008  bgt cr6, 0x821adb64
	if ctx.cr[6].gt {
	pc = 0x821ADB64; continue 'dispatch;
	}
	// 821ADB60: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821ADB64; continue 'dispatch;
            }
            0x821ADB64 => {
    //   block [0x821ADB64..0x821ADB8C)
	// 821ADB64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ADB68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADB6C: 409A0020  bne cr6, 0x821adb8c
	if !ctx.cr[6].eq {
	pc = 0x821ADB8C; continue 'dispatch;
	}
	// 821ADB70: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821ADB74: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821ADB78: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821ADB7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADB80: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821ADB84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADB88: 4800001C  b 0x821adba4
	pc = 0x821ADBA4; continue 'dispatch;
            }
            0x821ADB8C => {
    //   block [0x821ADB8C..0x821ADBA0)
	// 821ADB8C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821ADB90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADB94: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821ADB98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADB9C: 48000008  b 0x821adba4
	pc = 0x821ADBA4; continue 'dispatch;
            }
            0x821ADBA0 => {
    //   block [0x821ADBA0..0x821ADBA4)
	// 821ADBA0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821ADBA4; continue 'dispatch;
            }
            0x821ADBA4 => {
    //   block [0x821ADBA4..0x821ADBEC)
	// 821ADBA4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ADBA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADBAC: 419A018C  beq cr6, 0x821add38
	if ctx.cr[6].eq {
	pc = 0x821ADD38; continue 'dispatch;
	}
	// 821ADBB0: 480E7501  bl 0x822950b0
	ctx.lr = 0x821ADBB4;
	sub_822950B0(ctx, base);
	// 821ADBB4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821ADBB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADBBC: 419A017C  beq cr6, 0x821add38
	if ctx.cr[6].eq {
	pc = 0x821ADD38; continue 'dispatch;
	}
	// 821ADBC0: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821ADBC4: 388000CB  li r4, 0xcb
	ctx.r[4].s64 = 203;
	// 821ADBC8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821ADBCC: 814B00A8  lwz r10, 0xa8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 821ADBD0: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADBD4: 4800768D  bl 0x821b5260
	ctx.lr = 0x821ADBD8;
	sub_821B5260(ctx, base);
	// 821ADBD8: 933A0364  stw r25, 0x364(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(868 as u32), ctx.r[25].u32 ) };
	// 821ADBDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821ADBE0: 480671F9  bl 0x82214dd8
	ctx.lr = 0x821ADBE4;
	sub_82214DD8(ctx, base);
	// 821ADBE4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821ADBE8: 48AFB864  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821ADBEC => {
    //   block [0x821ADBEC..0x821ADC30)
	// 821ADBEC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADBF0: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 821ADBF4: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821ADBF8: 552817FE  rlwinm r8, r9, 2, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x3FFFFFFFu64;
	// 821ADBFC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821ADC00: 419A00F4  beq cr6, 0x821adcf4
	if ctx.cr[6].eq {
	pc = 0x821ADCF4; continue 'dispatch;
	}
	// 821ADC04: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821ADC08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ADC0C: 419A0024  beq cr6, 0x821adc30
	if ctx.cr[6].eq {
	pc = 0x821ADC30; continue 'dispatch;
	}
	// 821ADC10: 892A007E  lbz r9, 0x7e(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(126 as u32) ) } as u64;
	// 821ADC14: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821ADC18: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821ADC1C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821ADC20: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADC24: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821ADC28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADC2C: 480000CC  b 0x821adcf8
	pc = 0x821ADCF8; continue 'dispatch;
            }
            0x821ADC30 => {
    //   block [0x821ADC30..0x821ADC4C)
	// 821ADC30: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821ADC34: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821ADC38: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 821ADC3C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821ADC40: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821ADC44: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ADC48: 40810054  ble 0x821adc9c
	if !ctx.cr[0].gt {
	pc = 0x821ADC9C; continue 'dispatch;
	}
	pc = 0x821ADC4C; continue 'dispatch;
            }
            0x821ADC4C => {
    //   block [0x821ADC4C..0x821ADC6C)
	// 821ADC4C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821ADC50: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821ADC54: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821ADC58: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ADC5C: 2F07007E  cmpwi cr6, r7, 0x7e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 126, &mut ctx.xer);
	// 821ADC60: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821ADC64: 41980008  blt cr6, 0x821adc6c
	if ctx.cr[6].lt {
	pc = 0x821ADC6C; continue 'dispatch;
	}
	// 821ADC68: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x821ADC6C; continue 'dispatch;
            }
            0x821ADC6C => {
    //   block [0x821ADC6C..0x821ADC88)
	// 821ADC6C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821ADC70: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821ADC74: 419A0014  beq cr6, 0x821adc88
	if ctx.cr[6].eq {
	pc = 0x821ADC88; continue 'dispatch;
	}
	// 821ADC78: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821ADC7C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821ADC80: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821ADC84: 4800000C  b 0x821adc90
	pc = 0x821ADC90; continue 'dispatch;
            }
            0x821ADC88 => {
    //   block [0x821ADC88..0x821ADC90)
	// 821ADC88: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821ADC8C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821ADC90; continue 'dispatch;
            }
            0x821ADC90 => {
    //   block [0x821ADC90..0x821ADC9C)
	// 821ADC90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ADC94: 4199FFB8  bgt cr6, 0x821adc4c
	if ctx.cr[6].gt {
	pc = 0x821ADC4C; continue 'dispatch;
	}
	// 821ADC98: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x821ADC9C; continue 'dispatch;
            }
            0x821ADC9C => {
    //   block [0x821ADC9C..0x821ADCB8)
	// 821ADC9C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821ADCA0: 419A0040  beq cr6, 0x821adce0
	if ctx.cr[6].eq {
	pc = 0x821ADCE0; continue 'dispatch;
	}
	// 821ADCA4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ADCA8: 2F0B007E  cmpwi cr6, r11, 0x7e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 126, &mut ctx.xer);
	// 821ADCAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADCB0: 41990008  bgt cr6, 0x821adcb8
	if ctx.cr[6].gt {
	pc = 0x821ADCB8; continue 'dispatch;
	}
	// 821ADCB4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821ADCB8; continue 'dispatch;
            }
            0x821ADCB8 => {
    //   block [0x821ADCB8..0x821ADCE0)
	// 821ADCB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ADCBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADCC0: 409A0020  bne cr6, 0x821adce0
	if !ctx.cr[6].eq {
	pc = 0x821ADCE0; continue 'dispatch;
	}
	// 821ADCC4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821ADCC8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821ADCCC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821ADCD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADCD4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821ADCD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADCDC: 4800001C  b 0x821adcf8
	pc = 0x821ADCF8; continue 'dispatch;
            }
            0x821ADCE0 => {
    //   block [0x821ADCE0..0x821ADCF4)
	// 821ADCE0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821ADCE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADCE8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821ADCEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADCF0: 48000008  b 0x821adcf8
	pc = 0x821ADCF8; continue 'dispatch;
            }
            0x821ADCF4 => {
    //   block [0x821ADCF4..0x821ADCF8)
	// 821ADCF4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821ADCF8; continue 'dispatch;
            }
            0x821ADCF8 => {
    //   block [0x821ADCF8..0x821ADD20)
	// 821ADCF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ADCFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADD00: 419A0038  beq cr6, 0x821add38
	if ctx.cr[6].eq {
	pc = 0x821ADD38; continue 'dispatch;
	}
	// 821ADD04: 896A0018  lbz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821ADD08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADD0C: 419A0014  beq cr6, 0x821add20
	if ctx.cr[6].eq {
	pc = 0x821ADD20; continue 'dispatch;
	}
	// 821ADD10: 896A0019  lbz r11, 0x19(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(25 as u32) ) } as u64;
	// 821ADD14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADD18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADD1C: 419A0008  beq cr6, 0x821add24
	if ctx.cr[6].eq {
	pc = 0x821ADD24; continue 'dispatch;
	}
	pc = 0x821ADD20; continue 'dispatch;
            }
            0x821ADD20 => {
    //   block [0x821ADD20..0x821ADD24)
	// 821ADD20: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821ADD24; continue 'dispatch;
            }
            0x821ADD24 => {
    //   block [0x821ADD24..0x821ADD38)
	// 821ADD24: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ADD28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADD2C: 419A000C  beq cr6, 0x821add38
	if ctx.cr[6].eq {
	pc = 0x821ADD38; continue 'dispatch;
	}
	// 821ADD30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADD34: 996A0018  stb r11, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	pc = 0x821ADD38; continue 'dispatch;
            }
            0x821ADD38 => {
    //   block [0x821ADD38..0x821ADD44)
	// 821ADD38: 933A0364  stw r25, 0x364(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(868 as u32), ctx.r[25].u32 ) };
	// 821ADD3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821ADD40: 48067099  bl 0x82214dd8
	ctx.lr = 0x821ADD44;
	sub_82214DD8(ctx, base);
	pc = 0x821ADD44; continue 'dispatch;
            }
            0x821ADD44 => {
    //   block [0x821ADD44..0x821ADD4C)
	// 821ADD44: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821ADD48: 48AFB704  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ADD50 size=160
    let mut pc: u32 = 0x821ADD50;
    'dispatch: loop {
        match pc {
            0x821ADD50 => {
    //   block [0x821ADD50..0x821ADDF0)
	// 821ADD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ADD54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ADD58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ADD5C: 89630003  lbz r11, 3(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(3 as u32) ) } as u64;
	// 821ADD60: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821ADD64: 89230002  lbz r9, 2(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(2 as u32) ) } as u64;
	// 821ADD68: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 821ADD6C: 5567403E  rotlwi r7, r11, 8
	ctx.r[7].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 821ADD70: 88C30001  lbz r6, 1(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 821ADD74: 88A30000  lbz r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ADD78: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 821ADD7C: 7CE34B78  or r3, r7, r9
	ctx.r[3].u64 = ctx.r[7].u64 | ctx.r[9].u64;
	// 821ADD80: 39681390  addi r11, r8, 0x1390
	ctx.r[11].s64 = ctx.r[8].s64 + 5008;
	// 821ADD84: 5469402E  slwi r9, r3, 8
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821ADD88: 39041350  addi r8, r4, 0x1350
	ctx.r[8].s64 = ctx.r[4].s64 + 4944;
	// 821ADD8C: 7D273378  or r7, r9, r6
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[6].u64;
	// 821ADD90: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821ADD94: 54E7402E  slwi r7, r7, 8
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(8);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ADDF0 size=888
    let mut pc: u32 = 0x821ADDF0;
    'dispatch: loop {
        match pc {
            0x821ADDF0 => {
    //   block [0x821ADDF0..0x821ADE24)
	// 821ADDF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ADDF4: 48AFB611  bl 0x82ca9404
	ctx.lr = 0x821ADDF8;
	sub_82CA93D0(ctx, base);
	// 821ADDF8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ADDFC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821ADE00: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821ADE04: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 821ADE08: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821ADE0C: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821ADE10: 7D6A5A15  add. r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ADE14: 41820010  beq 0x821ade24
	if ctx.cr[0].eq {
	pc = 0x821ADE24; continue 'dispatch;
	}
	// 821ADE18: 83EB000C  lwz r31, 0xc(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821ADE1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821ADE20: 409A0008  bne cr6, 0x821ade28
	if !ctx.cr[6].eq {
	pc = 0x821ADE28; continue 'dispatch;
	}
	pc = 0x821ADE24; continue 'dispatch;
            }
            0x821ADE24 => {
    //   block [0x821ADE24..0x821ADE28)
	// 821ADE24: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	pc = 0x821ADE28; continue 'dispatch;
            }
            0x821ADE28 => {
    //   block [0x821ADE28..0x821ADE54)
	// 821ADE28: 809D002C  lwz r4, 0x2c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 821ADE2C: 807D0028  lwz r3, 0x28(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 821ADE30: 4800DFE1  bl 0x821bbe10
	ctx.lr = 0x821ADE34;
	sub_821BBE10(ctx, base);
	// 821ADE34: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821ADE38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821ADE3C: 419A0018  beq cr6, 0x821ade54
	if ctx.cr[6].eq {
	pc = 0x821ADE54; continue 'dispatch;
	}
	// 821ADE40: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821ADE44: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821ADE48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADE4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ADE50: 409A0008  bne cr6, 0x821ade58
	if !ctx.cr[6].eq {
	pc = 0x821ADE58; continue 'dispatch;
	}
	pc = 0x821ADE54; continue 'dispatch;
            }
            0x821ADE54 => {
    //   block [0x821ADE54..0x821ADE58)
	// 821ADE54: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821ADE58; continue 'dispatch;
            }
            0x821ADE58 => {
    //   block [0x821ADE58..0x821ADE80)
	// 821ADE58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ADE5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADE60: 419A0300  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821ADE64: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821ADE68: 419A0018  beq cr6, 0x821ade80
	if ctx.cr[6].eq {
	pc = 0x821ADE80; continue 'dispatch;
	}
	// 821ADE6C: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 821ADE70: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821ADE74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADE78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ADE7C: 409A0008  bne cr6, 0x821ade84
	if !ctx.cr[6].eq {
	pc = 0x821ADE84; continue 'dispatch;
	}
	pc = 0x821ADE80; continue 'dispatch;
            }
            0x821ADE80 => {
    //   block [0x821ADE80..0x821ADE84)
	// 821ADE80: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821ADE84; continue 'dispatch;
            }
            0x821ADE84 => {
    //   block [0x821ADE84..0x821ADF14)
	// 821ADE84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ADE88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADE8C: 419A02D4  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821ADE90: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821ADE94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ADE98: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 821ADE9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821ADEA0: 4E800421  bctrl
	ctx.lr = 0x821ADEA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821ADEA4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821ADEA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ADEAC: 419A02B4  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821ADEB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821ADEB4: 4BFDFE4D  bl 0x8218dd00
	ctx.lr = 0x821ADEB8;
	sub_8218DD00(ctx, base);
	// 821ADEB8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821ADEBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADEC0: 419A02A0  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821ADEC4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821ADEC8: 894B0068  lbz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 821ADECC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ADED0: 419A0230  beq cr6, 0x821ae100
	if ctx.cr[6].eq {
	pc = 0x821AE100; continue 'dispatch;
	}
	// 821ADED4: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821ADED8: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 821ADEDC: 556A67FE  rlwinm r10, r11, 0xc, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000FFFFFu64;
	// 821ADEE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ADEE4: 419A00F4  beq cr6, 0x821adfd8
	if ctx.cr[6].eq {
	pc = 0x821ADFD8; continue 'dispatch;
	}
	// 821ADEE8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821ADEEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADEF0: 419A0024  beq cr6, 0x821adf14
	if ctx.cr[6].eq {
	pc = 0x821ADF14; continue 'dispatch;
	}
	// 821ADEF4: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821ADEF8: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821ADEFC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821ADF00: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821ADF04: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADF08: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821ADF0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADF10: 480000CC  b 0x821adfdc
	pc = 0x821ADFDC; continue 'dispatch;
            }
            0x821ADF14 => {
    //   block [0x821ADF14..0x821ADF30)
	// 821ADF14: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821ADF18: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821ADF1C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821ADF20: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821ADF24: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821ADF28: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ADF2C: 40810054  ble 0x821adf80
	if !ctx.cr[0].gt {
	pc = 0x821ADF80; continue 'dispatch;
	}
	pc = 0x821ADF30; continue 'dispatch;
            }
            0x821ADF30 => {
    //   block [0x821ADF30..0x821ADF50)
	// 821ADF30: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821ADF34: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821ADF38: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821ADF3C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ADF40: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 821ADF44: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821ADF48: 41980008  blt cr6, 0x821adf50
	if ctx.cr[6].lt {
	pc = 0x821ADF50; continue 'dispatch;
	}
	// 821ADF4C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x821ADF50; continue 'dispatch;
            }
            0x821ADF50 => {
    //   block [0x821ADF50..0x821ADF6C)
	// 821ADF50: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821ADF54: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821ADF58: 419A0014  beq cr6, 0x821adf6c
	if ctx.cr[6].eq {
	pc = 0x821ADF6C; continue 'dispatch;
	}
	// 821ADF5C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821ADF60: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821ADF64: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821ADF68: 4800000C  b 0x821adf74
	pc = 0x821ADF74; continue 'dispatch;
            }
            0x821ADF6C => {
    //   block [0x821ADF6C..0x821ADF74)
	// 821ADF6C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821ADF70: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821ADF74; continue 'dispatch;
            }
            0x821ADF74 => {
    //   block [0x821ADF74..0x821ADF80)
	// 821ADF74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ADF78: 4199FFB8  bgt cr6, 0x821adf30
	if ctx.cr[6].gt {
	pc = 0x821ADF30; continue 'dispatch;
	}
	// 821ADF7C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821ADF80; continue 'dispatch;
            }
            0x821ADF80 => {
    //   block [0x821ADF80..0x821ADF9C)
	// 821ADF80: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821ADF84: 419A0040  beq cr6, 0x821adfc4
	if ctx.cr[6].eq {
	pc = 0x821ADFC4; continue 'dispatch;
	}
	// 821ADF88: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ADF8C: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 821ADF90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADF94: 41990008  bgt cr6, 0x821adf9c
	if ctx.cr[6].gt {
	pc = 0x821ADF9C; continue 'dispatch;
	}
	// 821ADF98: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821ADF9C; continue 'dispatch;
            }
            0x821ADF9C => {
    //   block [0x821ADF9C..0x821ADFC4)
	// 821ADF9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ADFA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADFA4: 409A0020  bne cr6, 0x821adfc4
	if !ctx.cr[6].eq {
	pc = 0x821ADFC4; continue 'dispatch;
	}
	// 821ADFA8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821ADFAC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821ADFB0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821ADFB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADFB8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821ADFBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADFC0: 4800001C  b 0x821adfdc
	pc = 0x821ADFDC; continue 'dispatch;
            }
            0x821ADFC4 => {
    //   block [0x821ADFC4..0x821ADFD8)
	// 821ADFC4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821ADFC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADFCC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821ADFD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADFD4: 48000008  b 0x821adfdc
	pc = 0x821ADFDC; continue 'dispatch;
            }
            0x821ADFD8 => {
    //   block [0x821ADFD8..0x821ADFDC)
	// 821ADFD8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821ADFDC; continue 'dispatch;
            }
            0x821ADFDC => {
    //   block [0x821ADFDC..0x821AE034)
	// 821ADFDC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ADFE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADFE4: 419A017C  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821ADFE8: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 821ADFEC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821ADFF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ADFF4: 419A016C  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821ADFF8: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 821ADFFC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821AE000: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AE004: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AE008: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821AE00C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AE010: 80890070  lwz r4, 0x70(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(112 as u32) ) } as u64;
	// 821AE014: 4807EEBD  bl 0x8222ced0
	ctx.lr = 0x821AE018;
	sub_8222CED0(ctx, base);
	// 821AE018: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE01C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE020: 409A0044  bne cr6, 0x821ae064
	if !ctx.cr[6].eq {
	pc = 0x821AE064; continue 'dispatch;
	}
	// 821AE024: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821AE028: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 821AE02C: 394B0CA0  addi r10, r11, 0xca0
	ctx.r[10].s64 = ctx.r[11].s64 + 3232;
	// 821AE030: 3969206C  addi r11, r9, 0x206c
	ctx.r[11].s64 = ctx.r[9].s64 + 8300;
	pc = 0x821AE034; continue 'dispatch;
            }
            0x821AE034 => {
    //   block [0x821AE034..0x821AE058)
	// 821AE034: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE038: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE03C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821AE040: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821AE044: 419A0014  beq cr6, 0x821ae058
	if ctx.cr[6].eq {
	pc = 0x821AE058; continue 'dispatch;
	}
	// 821AE048: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821AE04C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AE050: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821AE054: 419AFFE0  beq cr6, 0x821ae034
	if ctx.cr[6].eq {
	pc = 0x821AE034; continue 'dispatch;
	}
	pc = 0x821AE058; continue 'dispatch;
            }
            0x821AE058 => {
    //   block [0x821AE058..0x821AE064)
	// 821AE058: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821AE05C: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821AE060: 4800001C  b 0x821ae07c
	pc = 0x821AE07C; continue 'dispatch;
            }
            0x821AE064 => {
    //   block [0x821AE064..0x821AE07C)
	// 821AE064: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 821AE068: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE06C: 388A206C  addi r4, r10, 0x206c
	ctx.r[4].s64 = ctx.r[10].s64 + 8300;
	// 821AE070: 480BF789  bl 0x8226d7f8
	ctx.lr = 0x821AE074;
	sub_8226D7F8(ctx, base);
	// 821AE074: 7C690034  cntlzw r9, r3
	ctx.r[9].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821AE078: 553FDFFE  rlwinm r31, r9, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	pc = 0x821AE07C; continue 'dispatch;
            }
            0x821AE07C => {
    //   block [0x821AE07C..0x821AE0AC)
	// 821AE07C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AE080: 48066D59  bl 0x82214dd8
	ctx.lr = 0x821AE084;
	sub_82214DD8(ctx, base);
	// 821AE084: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821AE088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE08C: 419A00D4  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821AE090: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821AE094: 419A0018  beq cr6, 0x821ae0ac
	if ctx.cr[6].eq {
	pc = 0x821AE0AC; continue 'dispatch;
	}
	// 821AE098: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 821AE09C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AE0A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AE0A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE0A8: 409A0008  bne cr6, 0x821ae0b0
	if !ctx.cr[6].eq {
	pc = 0x821AE0B0; continue 'dispatch;
	}
	pc = 0x821AE0AC; continue 'dispatch;
            }
            0x821AE0AC => {
    //   block [0x821AE0AC..0x821AE0B0)
	// 821AE0AC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821AE0B0; continue 'dispatch;
            }
            0x821AE0B0 => {
    //   block [0x821AE0B0..0x821AE100)
	// 821AE0B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AE0B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE0B8: 419A00A8  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821AE0BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821AE0C0: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821AE0C4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821AE0C8: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 821AE0CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AE0D0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821AE0D4: 480667C5  bl 0x82214898
	ctx.lr = 0x821AE0D8;
	sub_82214898(ctx, base);
	// 821AE0D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821AE0DC: 387E0074  addi r3, r30, 0x74
	ctx.r[3].s64 = ctx.r[30].s64 + 116;
	// 821AE0E0: 48323DE9  bl 0x824d1ec8
	ctx.lr = 0x821AE0E4;
	sub_824D1EC8(ctx, base);
	// 821AE0E4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821AE0E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AE0EC: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 821AE0F0: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821AE0F4: 4BFE5D45  bl 0x82193e38
	ctx.lr = 0x821AE0F8;
	sub_82193E38(ctx, base);
	// 821AE0F8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821AE0FC: 48AFB358  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x821AE100 => {
    //   block [0x821AE100..0x821AE160)
	// 821AE100: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	pc = 0x821AE160; continue 'dispatch;
            }
            0x821AE160 => {
    //   block [0x821AE160..0x821AE168)
	// 821AE160: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821AE164: 48AFB2F0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE168 size=240
    let mut pc: u32 = 0x821AE168;
    'dispatch: loop {
        match pc {
            0x821AE168 => {
    //   block [0x821AE168..0x821AE258)
	// 821AE168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE16C: 48AFB299  bl 0x82ca9404
	ctx.lr = 0x821AE170;
	sub_82CA93D0(ctx, base);
	// 821AE170: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE174: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821AE178: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821AE17C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AE180: 396B2390  addi r11, r11, 0x2390
	ctx.r[11].s64 = ctx.r[11].s64 + 9104;
	// 821AE184: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821AE188: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 821AE18C: 93FD0018  stw r31, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 821AE190: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821AE194: 9BDF009C  stb r30, 0x9c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[30].u8 ) };
	// 821AE198: 38CA7E70  addi r6, r10, 0x7e70
	ctx.r[6].s64 = ctx.r[10].s64 + 32368;
	// 821AE19C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AE1A0: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 821AE1A4: 55451838  slwi r5, r10, 3
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AE1A8: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821AE1AC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 821AE1B0: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AE1B4: 38EB2008  addi r7, r11, 0x2008
	ctx.r[7].s64 = ctx.r[11].s64 + 8200;
	// 821AE1B8: 810B2000  lwz r8, 0x2000(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AE1BC: 814B400C  lwz r10, 0x400c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821AE1C0: 55441838  slwi r4, r10, 3
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AE1C4: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 821AE1C8: 5509083C  slwi r9, r8, 1
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE1CC: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	// 821AE1D0: 912B2000  stw r9, 0x2000(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8192 as u32), ctx.r[9].u32 ) };
	// 821AE1D4: 7CC4392E  stwx r6, r4, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[7].u32), ctx.r[6].u32) };
	// 821AE1D8: 814B400C  lwz r10, 0x400c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821AE1DC: 812B4008  lwz r9, 0x4008(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821AE1E0: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE1E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AE1E8: 912B4008  stw r9, 0x4008(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16392 as u32), ctx.r[9].u32 ) };
	// 821AE1EC: 914B400C  stw r10, 0x400c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16396 as u32), ctx.r[10].u32 ) };
	// 821AE1F0: 480BCE89  bl 0x8226b078
	ctx.lr = 0x821AE1F4;
	sub_8226B078(ctx, base);
	// 821AE1F4: 38BF0088  addi r5, r31, 0x88
	ctx.r[5].s64 = ctx.r[31].s64 + 136;
	// 821AE1F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821AE1FC: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821AE200: 4890D999  bl 0x82abbb98
	ctx.lr = 0x821AE204;
	sub_82ABBB98(ctx, base);
	// 821AE204: 80DF007C  lwz r6, 0x7c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821AE208: 3C608332  lis r3, -0x7cce
	ctx.r[3].s64 = -2093875200;
	// 821AE20C: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 821AE210: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AE214: 38FF00A4  addi r7, r31, 0xa4
	ctx.r[7].s64 = ctx.r[31].s64 + 164;
	// 821AE218: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821AE21C: 91660010  stw r11, 0x10(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821AE220: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AE224: 91660014  stw r11, 0x14(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821AE228: 91660018  stw r11, 0x18(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 821AE22C: 9386001C  stw r28, 0x1c(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28 as u32), ctx.r[28].u32 ) };
	// 821AE230: 91660028  stw r11, 0x28(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 821AE234: 9166002C  stw r11, 0x2c(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 821AE238: 93660034  stw r27, 0x34(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(52 as u32), ctx.r[27].u32 ) };
	// 821AE23C: 994316DE  stb r10, 0x16de(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(5854 as u32), ctx.r[10].u8 ) };
	// 821AE240: 992816DF  stb r9, 0x16df(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(5855 as u32), ctx.r[9].u8 ) };
	// 821AE244: 90FD001C  stw r7, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 821AE248: 9BDD0708  stb r30, 0x708(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(1800 as u32), ctx.r[30].u8 ) };
	// 821AE24C: 9BDD0709  stb r30, 0x709(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(1801 as u32), ctx.r[30].u8 ) };
	// 821AE250: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AE254: 48AFB200  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE258 size=240
    let mut pc: u32 = 0x821AE258;
    'dispatch: loop {
        match pc {
            0x821AE258 => {
    //   block [0x821AE258..0x821AE348)
	// 821AE258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE25C: 48AFB1A9  bl 0x82ca9404
	ctx.lr = 0x821AE260;
	sub_82CA93D0(ctx, base);
	// 821AE260: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE264: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821AE268: 38C0007F  li r6, 0x7f
	ctx.r[6].s64 = 127;
	// 821AE26C: 38ABA99C  addi r5, r11, -0x5664
	ctx.r[5].s64 = ctx.r[11].s64 + -22116;
	// 821AE270: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821AE274: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821AE278: 4BFFFEF1  bl 0x821ae168
	ctx.lr = 0x821AE27C;
	sub_821AE168(ctx, base);
	// 821AE27C: 38DD00A4  addi r6, r29, 0xa4
	ctx.r[6].s64 = ctx.r[29].s64 + 164;
	// 821AE280: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821AE284: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AE288: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821AE28C: 4890D6DD  bl 0x82abb968
	ctx.lr = 0x821AE290;
	sub_82ABB968(ctx, base);
	// 821AE290: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE294: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 821AE298: 354B04C0  addic. r10, r11, 0x4c0
	ctx.xer.ca = (ctx.r[11].u32 > (!(1216 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 1216;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AE29C: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE380 size=252
    let mut pc: u32 = 0x821AE380;
    'dispatch: loop {
        match pc {
            0x821AE380 => {
    //   block [0x821AE380..0x821AE3B0)
	// 821AE380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE384: 48AFB089  bl 0x82ca940c
	ctx.lr = 0x821AE388;
	sub_82CA93D0(ctx, base);
	// 821AE388: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE38C: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 821AE390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AE394: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821AE398: 812A711C  lwz r9, 0x711c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28956 as u32) ) } as u64;
	// 821AE39C: 2B090020  cmplwi cr6, r9, 0x20
	ctx.cr[6].compare_u32(ctx.r[9].u32, 32 as u32, &mut ctx.xer);
	// 821AE3A0: 409A0010  bne cr6, 0x821ae3b0
	if !ctx.cr[6].eq {
	pc = 0x821AE3B0; continue 'dispatch;
	}
	// 821AE3A4: 812B7120  lwz r9, 0x7120(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28960 as u32) ) } as u64;
	// 821AE3A8: 2B090060  cmplwi cr6, r9, 0x60
	ctx.cr[6].compare_u32(ctx.r[9].u32, 96 as u32, &mut ctx.xer);
	// 821AE3AC: 419A002C  beq cr6, 0x821ae3d8
	if ctx.cr[6].eq {
	pc = 0x821AE3D8; continue 'dispatch;
	}
	pc = 0x821AE3B0; continue 'dispatch;
            }
            0x821AE3B0 => {
    //   block [0x821AE3B0..0x821AE3D8)
	// 821AE3B0: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 821AE3B4: 39000060  li r8, 0x60
	ctx.r[8].s64 = 96;
	// 821AE3B8: 912A711C  stw r9, 0x711c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28956 as u32), ctx.r[9].u32 ) };
	// 821AE3BC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 821AE3C0: 910B7120  stw r8, 0x7120(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28960 as u32), ctx.r[8].u32 ) };
	// 821AE3C4: 38C00060  li r6, 0x60
	ctx.r[6].s64 = 96;
	// 821AE3C8: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821AE3CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821AE3D0: 806A0364  lwz r3, 0x364(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 821AE3D4: 4BFEE995  bl 0x8219cd68
	ctx.lr = 0x821AE3D8;
	sub_8219CD68(ctx, base);
	pc = 0x821AE3D8; continue 'dispatch;
            }
            0x821AE3D8 => {
    //   block [0x821AE3D8..0x821AE408)
	// 821AE3D8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE3DC: 38A0001B  li r5, 0x1b
	ctx.r[5].s64 = 27;
	// 821AE3E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AE3E4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AE3E8: 388B0D54  addi r4, r11, 0xd54
	ctx.r[4].s64 = ctx.r[11].s64 + 3412;
	// 821AE3EC: 48046095  bl 0x821f4480
	ctx.lr = 0x821AE3F0;
	sub_821F4480(ctx, base);
	// 821AE3F0: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AE3F4: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821AE3F8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AE3FC: 419A0078  beq cr6, 0x821ae474
	if ctx.cr[6].eq {
	pc = 0x821AE474; continue 'dispatch;
	}
	// 821AE400: 3FA0834C  lis r29, -0x7cb4
	ctx.r[29].s64 = -2092171264;
	// 821AE404: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	pc = 0x821AE408; continue 'dispatch;
            }
            0x821AE408 => {
    //   block [0x821AE408..0x821AE42C)
	// 821AE408: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AE40C: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AE410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE414: 419A0018  beq cr6, 0x821ae42c
	if ctx.cr[6].eq {
	pc = 0x821AE42C; continue 'dispatch;
	}
	// 821AE418: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AE41C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821AE420: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821AE424: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AE428: 41980008  blt cr6, 0x821ae430
	if ctx.cr[6].lt {
	pc = 0x821AE430; continue 'dispatch;
	}
	pc = 0x821AE42C; continue 'dispatch;
            }
            0x821AE42C => {
    //   block [0x821AE42C..0x821AE430)
	// 821AE42C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821AE430; continue 'dispatch;
            }
            0x821AE430 => {
    //   block [0x821AE430..0x821AE454)
	// 821AE430: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AE434: 88FDEC61  lbz r7, -0x139f(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(-5023 as u32) ) } as u64;
	// 821AE438: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AE43C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AE440: 993ECBD2  stb r9, -0x342e(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(-13358 as u32), ctx.r[9].u8 ) };
	// 821AE444: 7FE8582E  lwzx r31, r8, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AE448: 419A000C  beq cr6, 0x821ae454
	if ctx.cr[6].eq {
	pc = 0x821AE454; continue 'dispatch;
	}
	// 821AE44C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AE450: 488BF2C1  bl 0x82a6d710
	ctx.lr = 0x821AE454;
	sub_82A6D710(ctx, base);
	pc = 0x821AE454; continue 'dispatch;
            }
            0x821AE454 => {
    //   block [0x821AE454..0x821AE474)
	// 821AE454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AE458: 488C0241  bl 0x82a6e698
	ctx.lr = 0x821AE45C;
	sub_82A6E698(ctx, base);
	// 821AE45C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AE460: 48051919  bl 0x821ffd78
	ctx.lr = 0x821AE464;
	sub_821FFD78(ctx, base);
	// 821AE464: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AE468: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821AE46C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AE470: 409AFF98  bne cr6, 0x821ae408
	if !ctx.cr[6].eq {
	pc = 0x821AE408; continue 'dispatch;
	}
	pc = 0x821AE474; continue 'dispatch;
            }
            0x821AE474 => {
    //   block [0x821AE474..0x821AE47C)
	// 821AE474: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821AE478: 48AFAFE4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AE480 size=308
    let mut pc: u32 = 0x821AE480;
    'dispatch: loop {
        match pc {
            0x821AE480 => {
    //   block [0x821AE480..0x821AE500)
	// 821AE480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE484: 48AFAF89  bl 0x82ca940c
	ctx.lr = 0x821AE488;
	sub_82CA93D0(ctx, base);
	// 821AE488: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821AE48C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE490: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821AE494: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AE498: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821AE49C: 38A6CC94  addi r5, r6, -0x336c
	ctx.r[5].s64 = ctx.r[6].s64 + -13164;
	// 821AE4A0: 812B6AB8  lwz r9, 0x6ab8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821AE4A4: C01E00D0  lfs f0, 0xd0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE4A8: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821AE4AC: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 821AE4B0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AE4B4: 7D48FE70  srawi r8, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 821AE4B8: 8089000C  lwz r4, 0xc(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AE4BC: 7D075038  and r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[10].u64;
	// 821AE4C0: C046CC94  lfs f2, -0x336c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-13164 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821AE4C4: 7D475050  subf r10, r7, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 821AE4C8: C3E5C7FC  lfs f31, -0x3804(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14340 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821AE4CC: C025C7F0  lfs f1, -0x3810(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14352 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AE4D0: 216A0005  subfic r11, r10, 5
	ctx.xer.ca = ctx.r[10].u32 <= 5 as u32;
	ctx.r[11].s64 = (5 as i64) - ctx.r[10].s64;
	// 821AE4D4: 81240058  lwz r9, 0x58(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) } as u64;
	// 821AE4D8: 7D63FE70  srawi r3, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 821AE4DC: 7C6B5838  and r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 & ctx.r[11].u64;
	// 821AE4E0: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE4E4: 7FAB5214  add r29, r11, r10
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AE4E8: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AE4EC: 480119BD  bl 0x821bfea8
	ctx.lr = 0x821AE4F0;
	sub_821BFEA8(ctx, base);
	// 821AE4F0: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821AE4F4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AE4F8: 419A0008  beq cr6, 0x821ae500
	if ctx.cr[6].eq {
	pc = 0x821AE500; continue 'dispatch;
	}
	// 821AE4FC: C3FE00CC  lfs f31, 0xcc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(204 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x821AE500; continue 'dispatch;
            }
            0x821AE500 => {
    //   block [0x821AE500..0x821AE51C)
	// 821AE500: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 821AE504: 80DE00C4  lwz r6, 0xc4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AE508: 394B003C  addi r10, r11, 0x3c
	ctx.r[10].s64 = ctx.r[11].s64 + 60;
	// 821AE50C: 811E0054  lwz r8, 0x54(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AE510: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AE514: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 821AE518: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821AE51C; continue 'dispatch;
            }
            0x821AE51C => {
    //   block [0x821AE51C..0x821AE528)
	// 821AE51C: 7F0A5040  cmplw cr6, r10, r10
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AE520: 419A0008  beq cr6, 0x821ae528
	if ctx.cr[6].eq {
	pc = 0x821AE528; continue 'dispatch;
	}
	// 821AE524: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821AE528; continue 'dispatch;
            }
            0x821AE528 => {
    //   block [0x821AE528..0x821AE540)
	// 821AE528: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AE52C: 419A0048  beq cr6, 0x821ae574
	if ctx.cr[6].eq {
	pc = 0x821AE574; continue 'dispatch;
	}
	// 821AE530: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE534: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AE538: 409A0008  bne cr6, 0x821ae540
	if !ctx.cr[6].eq {
	pc = 0x821AE540; continue 'dispatch;
	}
	// 821AE53C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821AE540; continue 'dispatch;
            }
            0x821AE540 => {
    //   block [0x821AE540..0x821AE558)
	// 821AE540: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AE544: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821AE548: 419A0018  beq cr6, 0x821ae560
	if ctx.cr[6].eq {
	pc = 0x821AE560; continue 'dispatch;
	}
	// 821AE54C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AE550: 409A0008  bne cr6, 0x821ae558
	if !ctx.cr[6].eq {
	pc = 0x821AE558; continue 'dispatch;
	}
	// 821AE554: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821AE558; continue 'dispatch;
            }
            0x821AE558 => {
    //   block [0x821AE558..0x821AE560)
	// 821AE558: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE55C: 4BFFFFC0  b 0x821ae51c
	pc = 0x821AE51C; continue 'dispatch;
            }
            0x821AE560 => {
    //   block [0x821AE560..0x821AE570)
	// 821AE560: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE564: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AE568: 409A0008  bne cr6, 0x821ae570
	if !ctx.cr[6].eq {
	pc = 0x821AE570; continue 'dispatch;
	}
	// 821AE56C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821AE570; continue 'dispatch;
            }
            0x821AE570 => {
    //   block [0x821AE570..0x821AE574)
	// 821AE570: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x821AE574; continue 'dispatch;
            }
            0x821AE574 => {
    //   block [0x821AE574..0x821AE5B4)
	// 821AE574: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 821AE578: 395D0038  addi r10, r29, 0x38
	ctx.r[10].s64 = ctx.r[29].s64 + 56;
	// 821AE57C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AE580: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AE584: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821AE588: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE58C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821AE590: 7D69F42E  lfsx f11, r9, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AE594: ED4B0332  fmuls f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE598: ED2A07F2  fmuls f9, f10, f31
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AE59C: FD00481E  fctiwz f8, f9
	ctx.f[8].s64 = if ctx.f[9].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[9].f64.trunc() as i32 as i64 };
	// 821AE5A0: D9010050  stfd f8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[8].u64 ) };
	// 821AE5A4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AE5A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AE5AC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821AE5B0: 48AFAEAC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AE5B8 size=32
    let mut pc: u32 = 0x821AE5B8;
    'dispatch: loop {
        match pc {
            0x821AE5B8 => {
    //   block [0x821AE5B8..0x821AE5D8)
	// 821AE5B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE5BC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821AE5C0: 409A0020  bne cr6, 0x821ae5e0
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821AE5E0);
		return;
	}
	// 821AE5C4: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 821AE5C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE5CC: 409A000C  bne cr6, 0x821ae5d8
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821AE5D8);
		return;
	}
	// 821AE5D0: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AE5D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AE5F8 size=12
    let mut pc: u32 = 0x821AE5F8;
    'dispatch: loop {
        match pc {
            0x821AE5F8 => {
    //   block [0x821AE5F8..0x821AE604)
	// 821AE5F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821AE5FC: 386B60C0  addi r3, r11, 0x60c0
	ctx.r[3].s64 = ctx.r[11].s64 + 24768;
	// 821AE600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE608 size=160
    let mut pc: u32 = 0x821AE608;
    'dispatch: loop {
        match pc {
            0x821AE608 => {
    //   block [0x821AE608..0x821AE674)
	// 821AE608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE60C: 48AFADFD  bl 0x82ca9408
	ctx.lr = 0x821AE610;
	sub_82CA93D0(ctx, base);
	// 821AE610: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AE618: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821AE61C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821AE620: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE628: 419A0074  beq cr6, 0x821ae69c
	if ctx.cr[6].eq {
	pc = 0x821AE69C; continue 'dispatch;
	}
	// 821AE62C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AE630: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 821AE634: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AE638: 409A003C  bne cr6, 0x821ae674
	if !ctx.cr[6].eq {
	pc = 0x821AE674; continue 'dispatch;
	}
	// 821AE63C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821AE640: 388BDF68  addi r4, r11, -0x2098
	ctx.r[4].s64 = ctx.r[11].s64 + -8344;
	// 821AE644: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821AE648: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 821AE64C: 480B95D5  bl 0x82267c20
	ctx.lr = 0x821AE650;
	sub_82267C20(ctx, base);
	// 821AE650: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821AE654: 41820020  beq 0x821ae674
	if ctx.cr[0].eq {
	pc = 0x821AE674; continue 'dispatch;
	}
	// 821AE658: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE65C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821AE660: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE664: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821AE668: 808A0010  lwz r4, 0x10(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AE66C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821AE670: 4E800421  bctrl
	ctx.lr = 0x821AE674;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821AE674 => {
    //   block [0x821AE674..0x821AE69C)
	// 821AE674: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE678: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AE67C: 419A0020  beq cr6, 0x821ae69c
	if ctx.cr[6].eq {
	pc = 0x821AE69C; continue 'dispatch;
	}
	// 821AE680: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE684: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AE688: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE68C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AE690: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE694: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AE698: 48000008  b 0x821ae6a0
	pc = 0x821AE6A0; continue 'dispatch;
            }
            0x821AE69C => {
    //   block [0x821AE69C..0x821AE6A0)
	// 821AE69C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821AE6A0; continue 'dispatch;
            }
            0x821AE6A0 => {
    //   block [0x821AE6A0..0x821AE6A8)
	// 821AE6A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AE6A4: 48AFADB4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE6A8 size=124
    let mut pc: u32 = 0x821AE6A8;
    'dispatch: loop {
        match pc {
            0x821AE6A8 => {
    //   block [0x821AE6A8..0x821AE724)
	// 821AE6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE6AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AE6B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AE6B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AE6B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE6BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821AE6C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AE6C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AE6C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE6CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE6D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821AE6D4: 4E800421  bctrl
	ctx.lr = 0x821AE6D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AE6D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AE6DC: 38BE0054  addi r5, r30, 0x54
	ctx.r[5].s64 = ctx.r[30].s64 + 84;
	// 821AE6E0: 389E0050  addi r4, r30, 0x50
	ctx.r[4].s64 = ctx.r[30].s64 + 80;
	// 821AE6E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AE6E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE6EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821AE6F0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE6F4: 7FEBF12E  stwx r31, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[31].u32) };
	// 821AE6F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE6FC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AE700: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821AE704: 4E800421  bctrl
	ctx.lr = 0x821AE708;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AE708: 987E0058  stb r3, 0x58(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[3].u8 ) };
	// 821AE70C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AE710: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AE714: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AE718: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821AE71C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AE720: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AE728 size=240
    let mut pc: u32 = 0x821AE728;
    'dispatch: loop {
        match pc {
            0x821AE728 => {
    //   block [0x821AE728..0x821AE77C)
	// 821AE728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE72C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AE730: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AE734: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE738: 816401AC  lwz r11, 0x1ac(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(428 as u32) ) } as u64;
	// 821AE73C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AE740: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821AE744: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821AE748: 41820064  beq 0x821ae7ac
	if ctx.cr[0].eq {
	pc = 0x821AE7AC; continue 'dispatch;
	}
	// 821AE74C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AE750: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821AE754: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 821AE758: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821AE75C: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE760: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821AE764: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821AE768: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE76C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821AE770: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE774: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821AE778: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x821AE77C; continue 'dispatch;
            }
            0x821AE77C => {
    //   block [0x821AE77C..0x821AE7AC)
	// 821AE77C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821AE780: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 821AE784: 4200FFF8  bdnz 0x821ae77c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821AE77C; continue 'dispatch;
	}
	// 821AE788: 388401C0  addi r4, r4, 0x1c0
	ctx.r[4].s64 = ctx.r[4].s64 + 448;
	// 821AE78C: 990100A8  stb r8, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[8].u8 ) };
	// 821AE790: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821AE794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AE798: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821AE79C: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821AE7A0: 4BFFFF09  bl 0x821ae6a8
	ctx.lr = 0x821AE7A4;
	sub_821AE6A8(ctx, base);
	// 821AE7A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821AE7A8: 48000050  b 0x821ae7f8
	pc = 0x821AE7F8; continue 'dispatch;
            }
            0x821AE7AC => {
    //   block [0x821AE7AC..0x821AE7E4)
	// 821AE7AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AE7B0: 80E40008  lwz r7, 8(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AE7B4: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 821AE7B8: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 821AE7BC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821AE7C0: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 821AE7C4: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AE7C8: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE7CC: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821AE7D0: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE7D4: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821AE7D8: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE7DC: D00100BC  stfs f0, 0xbc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 821AE7E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x821AE7E4; continue 'dispatch;
            }
            0x821AE7E4 => {
    //   block [0x821AE7E4..0x821AE7F8)
	// 821AE7E4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821AE7E8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 821AE7EC: 4200FFF8  bdnz 0x821ae7e4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821AE7E4; continue 'dispatch;
	}
	// 821AE7F0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 821AE7F4: 99010108  stb r8, 0x108(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[8].u8 ) };
	pc = 0x821AE7F8; continue 'dispatch;
            }
            0x821AE7F8 => {
    //   block [0x821AE7F8..0x821AE818)
	// 821AE7F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AE7FC: 4BFFE255  bl 0x821aca50
	ctx.lr = 0x821AE800;
	sub_821ACA50(ctx, base);
	// 821AE800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AE804: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821AE808: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AE80C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AE810: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AE814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE818 size=260
    let mut pc: u32 = 0x821AE818;
    'dispatch: loop {
        match pc {
            0x821AE818 => {
    //   block [0x821AE818..0x821AE874)
	// 821AE818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE81C: 48AFABF1  bl 0x82ca940c
	ctx.lr = 0x821AE820;
	sub_82CA93D0(ctx, base);
	// 821AE820: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE824: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821AE828: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821AE82C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821AE830: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821AE834: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AE838: 4803E1F9  bl 0x821eca30
	ctx.lr = 0x821AE83C;
	sub_821ECA30(ctx, base);
	// 821AE83C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821AE840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE844: 409A0030  bne cr6, 0x821ae874
	if !ctx.cr[6].eq {
	pc = 0x821AE874; continue 'dispatch;
	}
	// 821AE848: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821AE84C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AE850: 816A0034  lwz r11, 0x34(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 821AE854: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821AE858: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AE85C: 419A0018  beq cr6, 0x821ae874
	if ctx.cr[6].eq {
	pc = 0x821AE874; continue 'dispatch;
	}
	// 821AE860: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 821AE864: 48119475  bl 0x822c7cd8
	ctx.lr = 0x821AE868;
	sub_822C7CD8(ctx, base);
	// 821AE868: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821AE86C: 409A0008  bne cr6, 0x821ae874
	if !ctx.cr[6].eq {
	pc = 0x821AE874; continue 'dispatch;
	}
	// 821AE870: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x821AE874; continue 'dispatch;
            }
            0x821AE874 => {
    //   block [0x821AE874..0x821AE890)
	// 821AE874: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821AE878: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821AE87C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AE880: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821AE884: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821AE888: 409A0008  bne cr6, 0x821ae890
	if !ctx.cr[6].eq {
	pc = 0x821AE890; continue 'dispatch;
	}
	// 821AE88C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x821AE890; continue 'dispatch;
            }
            0x821AE890 => {
    //   block [0x821AE890..0x821AE8C4)
	// 821AE890: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821AE894: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AE898: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821AE89C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AE8A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE8A4: 409A0028  bne cr6, 0x821ae8cc
	if !ctx.cr[6].eq {
	pc = 0x821AE8CC; continue 'dispatch;
	}
	// 821AE8A8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AE8AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE8B0: 419A0014  beq cr6, 0x821ae8c4
	if ctx.cr[6].eq {
	pc = 0x821AE8C4; continue 'dispatch;
	}
	// 821AE8B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AE8B8: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821AE8BC: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AE8C0: 4082000C  bne 0x821ae8cc
	if !ctx.cr[0].eq {
	pc = 0x821AE8CC; continue 'dispatch;
	}
	pc = 0x821AE8C4; continue 'dispatch;
            }
            0x821AE8C4 => {
    //   block [0x821AE8C4..0x821AE8CC)
	// 821AE8C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AE8C8: 48000008  b 0x821ae8d0
	pc = 0x821AE8D0; continue 'dispatch;
            }
            0x821AE8CC => {
    //   block [0x821AE8CC..0x821AE8D0)
	// 821AE8CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AE8D0; continue 'dispatch;
            }
            0x821AE8D0 => {
    //   block [0x821AE8D0..0x821AE8E0)
	// 821AE8D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AE8D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE8D8: 409A0008  bne cr6, 0x821ae8e0
	if !ctx.cr[6].eq {
	pc = 0x821AE8E0; continue 'dispatch;
	}
	// 821AE8DC: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	pc = 0x821AE8E0; continue 'dispatch;
            }
            0x821AE8E0 => {
    //   block [0x821AE8E0..0x821AE8F8)
	// 821AE8E0: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 821AE8E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE8E8: 409A0010  bne cr6, 0x821ae8f8
	if !ctx.cr[6].eq {
	pc = 0x821AE8F8; continue 'dispatch;
	}
	// 821AE8EC: 550B063E  clrlwi r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 821AE8F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE8F4: 419A0008  beq cr6, 0x821ae8fc
	if ctx.cr[6].eq {
	pc = 0x821AE8FC; continue 'dispatch;
	}
	pc = 0x821AE8F8; continue 'dispatch;
            }
            0x821AE8F8 => {
    //   block [0x821AE8F8..0x821AE8FC)
	// 821AE8F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x821AE8FC; continue 'dispatch;
            }
            0x821AE8FC => {
    //   block [0x821AE8FC..0x821AE91C)
	// 821AE8FC: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 821AE900: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821AE904: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821AE908: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821AE90C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821AE910: 480E8879  bl 0x82297188
	ctx.lr = 0x821AE914;
	sub_82297188(ctx, base);
	// 821AE914: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AE918: 48AFAB44  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE920 size=184
    let mut pc: u32 = 0x821AE920;
    'dispatch: loop {
        match pc {
            0x821AE920 => {
    //   block [0x821AE920..0x821AE97C)
	// 821AE920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE924: 48AFAAE9  bl 0x82ca940c
	ctx.lr = 0x821AE928;
	sub_82CA93D0(ctx, base);
	// 821AE928: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE92C: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821AE930: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821AE934: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821AE938: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821AE93C: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AE940: 4803E0F1  bl 0x821eca30
	ctx.lr = 0x821AE944;
	sub_821ECA30(ctx, base);
	// 821AE944: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821AE948: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE94C: 409A0030  bne cr6, 0x821ae97c
	if !ctx.cr[6].eq {
	pc = 0x821AE97C; continue 'dispatch;
	}
	// 821AE950: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821AE954: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AE958: 816A0034  lwz r11, 0x34(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 821AE95C: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821AE960: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AE964: 419A0018  beq cr6, 0x821ae97c
	if ctx.cr[6].eq {
	pc = 0x821AE97C; continue 'dispatch;
	}
	// 821AE968: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 821AE96C: 4811936D  bl 0x822c7cd8
	ctx.lr = 0x821AE970;
	sub_822C7CD8(ctx, base);
	// 821AE970: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 821AE974: 409A0008  bne cr6, 0x821ae97c
	if !ctx.cr[6].eq {
	pc = 0x821AE97C; continue 'dispatch;
	}
	// 821AE978: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x821AE97C; continue 'dispatch;
            }
            0x821AE97C => {
    //   block [0x821AE97C..0x821AE998)
	// 821AE97C: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821AE980: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AE984: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AE988: 81090028  lwz r8, 0x28(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 821AE98C: 2F080005  cmpwi cr6, r8, 5
	ctx.cr[6].compare_i32(ctx.r[8].s32, 5, &mut ctx.xer);
	// 821AE990: 409A0008  bne cr6, 0x821ae998
	if !ctx.cr[6].eq {
	pc = 0x821AE998; continue 'dispatch;
	}
	// 821AE994: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x821AE998; continue 'dispatch;
            }
            0x821AE998 => {
    //   block [0x821AE998..0x821AE9B4)
	// 821AE998: 57C9063E  clrlwi r9, r30, 0x18
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 821AE99C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AE9A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AE9A4: 409A0010  bne cr6, 0x821ae9b4
	if !ctx.cr[6].eq {
	pc = 0x821AE9B4; continue 'dispatch;
	}
	// 821AE9A8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821AE9AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE9B0: 419A0008  beq cr6, 0x821ae9b8
	if ctx.cr[6].eq {
	pc = 0x821AE9B8; continue 'dispatch;
	}
	pc = 0x821AE9B4; continue 'dispatch;
            }
            0x821AE9B4 => {
    //   block [0x821AE9B4..0x821AE9B8)
	// 821AE9B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AE9B8; continue 'dispatch;
            }
            0x821AE9B8 => {
    //   block [0x821AE9B8..0x821AE9D8)
	// 821AE9B8: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 821AE9BC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821AE9C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821AE9C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821AE9C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821AE9CC: 480E87BD  bl 0x82297188
	ctx.lr = 0x821AE9D0;
	sub_82297188(ctx, base);
	// 821AE9D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AE9D4: 48AFAA88  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AE9E0 size=444
    let mut pc: u32 = 0x821AE9E0;
    'dispatch: loop {
        match pc {
            0x821AE9E0 => {
    //   block [0x821AE9E0..0x821AEB9C)
	// 821AE9E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE9E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AE9E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AE9EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AE9F0: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AEBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AEBA0 size=660
    let mut pc: u32 = 0x821AEBA0;
    'dispatch: loop {
        match pc {
            0x821AEBA0 => {
    //   block [0x821AEBA0..0x821AEC1C)
	// 821AEBA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AEBA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AEBA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AEBAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AEBB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AEBB4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821AEBB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821AEBBC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821AEBC0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AEBC4: 806A009C  lwz r3, 0x9c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 821AEBC8: 480B5669  bl 0x82264230
	ctx.lr = 0x821AEBCC;
	sub_82264230(ctx, base);
	// 821AEBCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AEBD0: 419A024C  beq cr6, 0x821aee1c
	if ctx.cr[6].eq {
	pc = 0x821AEE1C; continue 'dispatch;
	}
	// 821AEBD4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821AEBD8: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821AEBDC: 480F029D  bl 0x8229ee78
	ctx.lr = 0x821AEBE0;
	sub_8229EE78(ctx, base);
	// 821AEBE0: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821AEBE4: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821AEBE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AEBEC: 419A00F4  beq cr6, 0x821aece0
	if ctx.cr[6].eq {
	pc = 0x821AECE0; continue 'dispatch;
	}
	// 821AEBF0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AEBF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AEBF8: 419A0024  beq cr6, 0x821aec1c
	if ctx.cr[6].eq {
	pc = 0x821AEC1C; continue 'dispatch;
	}
	// 821AEBFC: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 821AEC00: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AEC04: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821AEC08: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AEC0C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AEC10: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AEC14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AEC18: 480000CC  b 0x821aece4
	pc = 0x821AECE4; continue 'dispatch;
            }
            0x821AEC1C => {
    //   block [0x821AEC1C..0x821AEC38)
	// 821AEC1C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AEC20: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AEC24: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821AEC28: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AEC2C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AEC30: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AEC34: 40810054  ble 0x821aec88
	if !ctx.cr[0].gt {
	pc = 0x821AEC88; continue 'dispatch;
	}
	pc = 0x821AEC38; continue 'dispatch;
            }
            0x821AEC38 => {
    //   block [0x821AEC38..0x821AEC58)
	// 821AEC38: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AEC3C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AEC40: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AEC44: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AEC48: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821AEC4C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AEC50: 41980008  blt cr6, 0x821aec58
	if ctx.cr[6].lt {
	pc = 0x821AEC58; continue 'dispatch;
	}
	// 821AEC54: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x821AEC58; continue 'dispatch;
            }
            0x821AEC58 => {
    //   block [0x821AEC58..0x821AEC74)
	// 821AEC58: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AEC5C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AEC60: 419A0014  beq cr6, 0x821aec74
	if ctx.cr[6].eq {
	pc = 0x821AEC74; continue 'dispatch;
	}
	// 821AEC64: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AEC68: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AEC6C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AEC70: 4800000C  b 0x821aec7c
	pc = 0x821AEC7C; continue 'dispatch;
            }
            0x821AEC74 => {
    //   block [0x821AEC74..0x821AEC7C)
	// 821AEC74: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AEC78: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AEC7C; continue 'dispatch;
            }
            0x821AEC7C => {
    //   block [0x821AEC7C..0x821AEC88)
	// 821AEC7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AEC80: 4199FFB8  bgt cr6, 0x821aec38
	if ctx.cr[6].gt {
	pc = 0x821AEC38; continue 'dispatch;
	}
	// 821AEC84: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821AEC88; continue 'dispatch;
            }
            0x821AEC88 => {
    //   block [0x821AEC88..0x821AECA4)
	// 821AEC88: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AEC8C: 419A0040  beq cr6, 0x821aeccc
	if ctx.cr[6].eq {
	pc = 0x821AECCC; continue 'dispatch;
	}
	// 821AEC90: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AEC94: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 821AEC98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AEC9C: 41990008  bgt cr6, 0x821aeca4
	if ctx.cr[6].gt {
	pc = 0x821AECA4; continue 'dispatch;
	}
	// 821AECA0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821AECA4; continue 'dispatch;
            }
            0x821AECA4 => {
    //   block [0x821AECA4..0x821AECCC)
	// 821AECA4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AECA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AECAC: 409A0020  bne cr6, 0x821aeccc
	if !ctx.cr[6].eq {
	pc = 0x821AECCC; continue 'dispatch;
	}
	// 821AECB0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AECB4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AECB8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AECBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AECC0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AECC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AECC8: 4800001C  b 0x821aece4
	pc = 0x821AECE4; continue 'dispatch;
            }
            0x821AECCC => {
    //   block [0x821AECCC..0x821AECE0)
	// 821AECCC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AECD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AECD4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AECD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AECDC: 48000008  b 0x821aece4
	pc = 0x821AECE4; continue 'dispatch;
            }
            0x821AECE0 => {
    //   block [0x821AECE0..0x821AECE4)
	// 821AECE0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821AECE4; continue 'dispatch;
            }
            0x821AECE4 => {
    //   block [0x821AECE4..0x821AED44)
	// 821AECE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AECE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AECEC: 419A0130  beq cr6, 0x821aee1c
	if ctx.cr[6].eq {
	pc = 0x821AEE1C; continue 'dispatch;
	}
	// 821AECF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AECF4: 4866388D  bl 0x82812580
	ctx.lr = 0x821AECF8;
	sub_82812580(ctx, base);
	// 821AECF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AECFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AED00: 419A011C  beq cr6, 0x821aee1c
	if ctx.cr[6].eq {
	pc = 0x821AEE1C; continue 'dispatch;
	}
	// 821AED04: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AED08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AED0C: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821AED10: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AED14: 419A00F4  beq cr6, 0x821aee08
	if ctx.cr[6].eq {
	pc = 0x821AEE08; continue 'dispatch;
	}
	// 821AED18: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AED1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AED20: 419A0024  beq cr6, 0x821aed44
	if ctx.cr[6].eq {
	pc = 0x821AED44; continue 'dispatch;
	}
	// 821AED24: 892A00A2  lbz r9, 0xa2(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(162 as u32) ) } as u64;
	// 821AED28: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AED2C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821AED30: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AED34: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AED38: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821AED3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AED40: 480000CC  b 0x821aee0c
	pc = 0x821AEE0C; continue 'dispatch;
            }
            0x821AED44 => {
    //   block [0x821AED44..0x821AED60)
	// 821AED44: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AED48: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AED4C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821AED50: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AED54: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AED58: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AED5C: 40810054  ble 0x821aedb0
	if !ctx.cr[0].gt {
	pc = 0x821AEDB0; continue 'dispatch;
	}
	pc = 0x821AED60; continue 'dispatch;
            }
            0x821AED60 => {
    //   block [0x821AED60..0x821AED80)
	// 821AED60: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AED64: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AED68: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AED6C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AED70: 2F0700A2  cmpwi cr6, r7, 0xa2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 162, &mut ctx.xer);
	// 821AED74: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AED78: 41980008  blt cr6, 0x821aed80
	if ctx.cr[6].lt {
	pc = 0x821AED80; continue 'dispatch;
	}
	// 821AED7C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x821AED80; continue 'dispatch;
            }
            0x821AED80 => {
    //   block [0x821AED80..0x821AED9C)
	// 821AED80: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AED84: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AED88: 419A0014  beq cr6, 0x821aed9c
	if ctx.cr[6].eq {
	pc = 0x821AED9C; continue 'dispatch;
	}
	// 821AED8C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AED90: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AED94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AED98: 4800000C  b 0x821aeda4
	pc = 0x821AEDA4; continue 'dispatch;
            }
            0x821AED9C => {
    //   block [0x821AED9C..0x821AEDA4)
	// 821AED9C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AEDA0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AEDA4; continue 'dispatch;
            }
            0x821AEDA4 => {
    //   block [0x821AEDA4..0x821AEDB0)
	// 821AEDA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AEDA8: 4199FFB8  bgt cr6, 0x821aed60
	if ctx.cr[6].gt {
	pc = 0x821AED60; continue 'dispatch;
	}
	// 821AEDAC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821AEDB0; continue 'dispatch;
            }
            0x821AEDB0 => {
    //   block [0x821AEDB0..0x821AEDCC)
	// 821AEDB0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AEDB4: 419A0040  beq cr6, 0x821aedf4
	if ctx.cr[6].eq {
	pc = 0x821AEDF4; continue 'dispatch;
	}
	// 821AEDB8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AEDBC: 2F0B00A2  cmpwi cr6, r11, 0xa2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 162, &mut ctx.xer);
	// 821AEDC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AEDC4: 41990008  bgt cr6, 0x821aedcc
	if ctx.cr[6].gt {
	pc = 0x821AEDCC; continue 'dispatch;
	}
	// 821AEDC8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821AEDCC; continue 'dispatch;
            }
            0x821AEDCC => {
    //   block [0x821AEDCC..0x821AEDF4)
	// 821AEDCC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AEDD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AEDD4: 409A0020  bne cr6, 0x821aedf4
	if !ctx.cr[6].eq {
	pc = 0x821AEDF4; continue 'dispatch;
	}
	// 821AEDD8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AEDDC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AEDE0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AEDE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AEDE8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821AEDEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AEDF0: 4800001C  b 0x821aee0c
	pc = 0x821AEE0C; continue 'dispatch;
            }
            0x821AEDF4 => {
    //   block [0x821AEDF4..0x821AEE08)
	// 821AEDF4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AEDF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AEDFC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821AEE00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AEE04: 48000008  b 0x821aee0c
	pc = 0x821AEE0C; continue 'dispatch;
            }
            0x821AEE08 => {
    //   block [0x821AEE08..0x821AEE0C)
	// 821AEE08: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821AEE0C; continue 'dispatch;
            }
            0x821AEE0C => {
    //   block [0x821AEE0C..0x821AEE1C)
	// 821AEE0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AEE10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AEE14: 419A0008  beq cr6, 0x821aee1c
	if ctx.cr[6].eq {
	pc = 0x821AEE1C; continue 'dispatch;
	}
	// 821AEE18: 4BFFFBC9  bl 0x821ae9e0
	ctx.lr = 0x821AEE1C;
	sub_821AE9E0(ctx, base);
	pc = 0x821AEE1C; continue 'dispatch;
            }
            0x821AEE1C => {
    //   block [0x821AEE1C..0x821AEE34)
	// 821AEE1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AEE20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AEE24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AEE28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821AEE2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AEE30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AEE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AEE38 size=284
    let mut pc: u32 = 0x821AEE38;
    'dispatch: loop {
        match pc {
            0x821AEE38 => {
    //   block [0x821AEE38..0x821AEF54)
	// 821AEE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AEE3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AEE40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AEE44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AEE48: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821AEE4C: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AEF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AEF58 size=100
    let mut pc: u32 = 0x821AEF58;
    'dispatch: loop {
        match pc {
            0x821AEF58 => {
    //   block [0x821AEF58..0x821AEFBC)
	// 821AEF58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AEF5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AEF60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AEF64: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AEF68: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821AEF6C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821AEF70: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821AEF74: 38E99150  addi r7, r9, -0x6eb0
	ctx.r[7].s64 = ctx.r[9].s64 + -28336;
	// 821AEF78: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AEF7C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821AEF80: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821AEF84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AEFC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AEFC0 size=56
    let mut pc: u32 = 0x821AEFC0;
    'dispatch: loop {
        match pc {
            0x821AEFC0 => {
    //   block [0x821AEFC0..0x821AEFDC)
	// 821AEFC0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821AEFC4: 419A0018  beq cr6, 0x821aefdc
	if ctx.cr[6].eq {
	pc = 0x821AEFDC; continue 'dispatch;
	}
	// 821AEFC8: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821AEFCC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AEFD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AEFD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AEFD8: 409A0008  bne cr6, 0x821aefe0
	if !ctx.cr[6].eq {
	pc = 0x821AEFE0; continue 'dispatch;
	}
	pc = 0x821AEFDC; continue 'dispatch;
            }
            0x821AEFDC => {
    //   block [0x821AEFDC..0x821AEFE0)
	// 821AEFDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AEFE0; continue 'dispatch;
            }
            0x821AEFE0 => {
    //   block [0x821AEFE0..0x821AEFF8)
	// 821AEFE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AEFE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AEFE8: 419A0010  beq cr6, 0x821aeff8
	if ctx.cr[6].eq {
		sub_821AEFF8(ctx, base);
		return;
	}
	// 821AEFEC: 81640038  lwz r11, 0x38(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AEFF0: 55635FFE  rlwinm r3, r11, 0xb, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 821AEFF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AEFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AEFF8 size=8
    let mut pc: u32 = 0x821AEFF8;
    'dispatch: loop {
        match pc {
            0x821AEFF8 => {
    //   block [0x821AEFF8..0x821AF000)
	// 821AEFF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AEFFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF000 size=56
    let mut pc: u32 = 0x821AF000;
    'dispatch: loop {
        match pc {
            0x821AF000 => {
    //   block [0x821AF000..0x821AF01C)
	// 821AF000: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821AF004: 419A0018  beq cr6, 0x821af01c
	if ctx.cr[6].eq {
	pc = 0x821AF01C; continue 'dispatch;
	}
	// 821AF008: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821AF00C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF010: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF014: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF018: 409A0008  bne cr6, 0x821af020
	if !ctx.cr[6].eq {
	pc = 0x821AF020; continue 'dispatch;
	}
	pc = 0x821AF01C; continue 'dispatch;
            }
            0x821AF01C => {
    //   block [0x821AF01C..0x821AF020)
	// 821AF01C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AF020; continue 'dispatch;
            }
            0x821AF020 => {
    //   block [0x821AF020..0x821AF038)
	// 821AF020: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AF024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF028: 419A0010  beq cr6, 0x821af038
	if ctx.cr[6].eq {
		sub_821AF038(ctx, base);
		return;
	}
	// 821AF02C: 81640034  lwz r11, 0x34(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 821AF030: 5563BFFE  rlwinm r3, r11, 0x17, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000001FFu64;
	// 821AF034: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF038 size=8
    let mut pc: u32 = 0x821AF038;
    'dispatch: loop {
        match pc {
            0x821AF038 => {
    //   block [0x821AF038..0x821AF040)
	// 821AF038: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AF03C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF040 size=56
    let mut pc: u32 = 0x821AF040;
    'dispatch: loop {
        match pc {
            0x821AF040 => {
    //   block [0x821AF040..0x821AF05C)
	// 821AF040: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821AF044: 419A0018  beq cr6, 0x821af05c
	if ctx.cr[6].eq {
	pc = 0x821AF05C; continue 'dispatch;
	}
	// 821AF048: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821AF04C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF050: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF054: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF058: 409A0008  bne cr6, 0x821af060
	if !ctx.cr[6].eq {
	pc = 0x821AF060; continue 'dispatch;
	}
	pc = 0x821AF05C; continue 'dispatch;
            }
            0x821AF05C => {
    //   block [0x821AF05C..0x821AF060)
	// 821AF05C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AF060; continue 'dispatch;
            }
            0x821AF060 => {
    //   block [0x821AF060..0x821AF078)
	// 821AF060: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AF064: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF068: 419A0010  beq cr6, 0x821af078
	if ctx.cr[6].eq {
		sub_821AF078(ctx, base);
		return;
	}
	// 821AF06C: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AF070: 556327FE  rlwinm r3, r11, 4, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 821AF074: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF078 size=8
    let mut pc: u32 = 0x821AF078;
    'dispatch: loop {
        match pc {
            0x821AF078 => {
    //   block [0x821AF078..0x821AF080)
	// 821AF078: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AF07C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AF080 size=108
    let mut pc: u32 = 0x821AF080;
    'dispatch: loop {
        match pc {
            0x821AF080 => {
    //   block [0x821AF080..0x821AF0BC)
	// 821AF080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AF084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AF088: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AF08C: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AF090: C003022C  lfs f0, 0x22c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(556 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF094: ED810028  fsubs f12, f1, f0
	ctx.f[12].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AF098: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AF09C: 392B9484  addi r9, r11, -0x6b7c
	ctx.r[9].s64 = ctx.r[11].s64 + -27516;
	// 821AF0A0: C1AA001C  lfs f13, 0x1c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF0A4: C16A0018  lfs f11, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AF0A8: EC0D5828  fsubs f0, f13, f11
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 821AF0AC: C1A9FE48  lfs f13, -0x1b8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-440 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF0B0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821AF0B4: 40980008  bge cr6, 0x821af0bc
	if !ctx.cr[6].lt {
	pc = 0x821AF0BC; continue 'dispatch;
	}
	// 821AF0B8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x821AF0BC; continue 'dispatch;
            }
            0x821AF0BC => {
    //   block [0x821AF0BC..0x821AF0D8)
	// 821AF0BC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 821AF0C0: 41980018  blt cr6, 0x821af0d8
	if ctx.cr[6].lt {
	pc = 0x821AF0D8; continue 'dispatch;
	}
	// 821AF0C4: 480BA255  bl 0x82269318
	ctx.lr = 0x821AF0C8;
	sub_82269318(ctx, base);
	// 821AF0C8: C0090000  lfs f0, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF0CC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821AF0D0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AF0D4: 40990008  ble cr6, 0x821af0dc
	if !ctx.cr[6].gt {
	pc = 0x821AF0DC; continue 'dispatch;
	}
	pc = 0x821AF0D8; continue 'dispatch;
            }
            0x821AF0D8 => {
    //   block [0x821AF0D8..0x821AF0DC)
	// 821AF0D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821AF0DC; continue 'dispatch;
            }
            0x821AF0DC => {
    //   block [0x821AF0DC..0x821AF0EC)
	// 821AF0DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AF0E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AF0E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AF0E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF0F0 size=332
    let mut pc: u32 = 0x821AF0F0;
    'dispatch: loop {
        match pc {
            0x821AF0F0 => {
    //   block [0x821AF0F0..0x821AF140)
	// 821AF0F0: 89630071  lbz r11, 0x71(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(113 as u32) ) } as u64;
	// 821AF0F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF0F8: 409A0144  bne cr6, 0x821af23c
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821AF23C);
		return;
	}
	// 821AF0FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF100: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AF104: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AF108: 552867FE  rlwinm r8, r9, 0xc, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000FFFFFu64;
	// 821AF10C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AF110: 419A00F8  beq cr6, 0x821af208
	if ctx.cr[6].eq {
	pc = 0x821AF208; continue 'dispatch;
	}
	// 821AF114: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AF118: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF11C: 419A0024  beq cr6, 0x821af140
	if ctx.cr[6].eq {
	pc = 0x821AF140; continue 'dispatch;
	}
	// 821AF120: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AF124: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AF128: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821AF12C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AF130: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF134: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AF138: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF13C: 480000D0  b 0x821af20c
	pc = 0x821AF20C; continue 'dispatch;
            }
            0x821AF140 => {
    //   block [0x821AF140..0x821AF160)
	// 821AF140: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AF144: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AF148: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AF14C: 9121FFF0  stw r9, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 821AF150: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AF154: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 821AF158: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AF15C: 40810054  ble 0x821af1b0
	if !ctx.cr[0].gt {
	pc = 0x821AF1B0; continue 'dispatch;
	}
	pc = 0x821AF160; continue 'dispatch;
            }
            0x821AF160 => {
    //   block [0x821AF160..0x821AF180)
	// 821AF160: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AF164: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF168: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AF16C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AF170: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 821AF174: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AF178: 41980008  blt cr6, 0x821af180
	if ctx.cr[6].lt {
	pc = 0x821AF180; continue 'dispatch;
	}
	// 821AF17C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821AF180; continue 'dispatch;
            }
            0x821AF180 => {
    //   block [0x821AF180..0x821AF19C)
	// 821AF180: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AF184: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF188: 419A0014  beq cr6, 0x821af19c
	if ctx.cr[6].eq {
	pc = 0x821AF19C; continue 'dispatch;
	}
	// 821AF18C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AF190: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AF194: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AF198: 4800000C  b 0x821af1a4
	pc = 0x821AF1A4; continue 'dispatch;
            }
            0x821AF19C => {
    //   block [0x821AF19C..0x821AF1A4)
	// 821AF19C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AF1A0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821AF1A4; continue 'dispatch;
            }
            0x821AF1A4 => {
    //   block [0x821AF1A4..0x821AF1B0)
	// 821AF1A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AF1A8: 4199FFB8  bgt cr6, 0x821af160
	if ctx.cr[6].gt {
	pc = 0x821AF160; continue 'dispatch;
	}
	// 821AF1AC: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	pc = 0x821AF1B0; continue 'dispatch;
            }
            0x821AF1B0 => {
    //   block [0x821AF1B0..0x821AF1CC)
	// 821AF1B0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AF1B4: 419A0040  beq cr6, 0x821af1f4
	if ctx.cr[6].eq {
	pc = 0x821AF1F4; continue 'dispatch;
	}
	// 821AF1B8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AF1BC: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 821AF1C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF1C4: 41990008  bgt cr6, 0x821af1cc
	if ctx.cr[6].gt {
	pc = 0x821AF1CC; continue 'dispatch;
	}
	// 821AF1C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AF1CC; continue 'dispatch;
            }
            0x821AF1CC => {
    //   block [0x821AF1CC..0x821AF1F4)
	// 821AF1CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AF1D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF1D4: 409A0020  bne cr6, 0x821af1f4
	if !ctx.cr[6].eq {
	pc = 0x821AF1F4; continue 'dispatch;
	}
	// 821AF1D8: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AF1DC: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821AF1E0: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821AF1E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF1E8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AF1EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF1F0: 4800001C  b 0x821af20c
	pc = 0x821AF20C; continue 'dispatch;
            }
            0x821AF1F4 => {
    //   block [0x821AF1F4..0x821AF208)
	// 821AF1F4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AF1F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF1FC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AF200: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF204: 48000008  b 0x821af20c
	pc = 0x821AF20C; continue 'dispatch;
            }
            0x821AF208 => {
    //   block [0x821AF208..0x821AF20C)
	// 821AF208: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AF20C; continue 'dispatch;
            }
            0x821AF20C => {
    //   block [0x821AF20C..0x821AF230)
	// 821AF20C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AF210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF214: 419A0028  beq cr6, 0x821af23c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821AF23C);
		return;
	}
	// 821AF218: 816A0028  lwz r11, 0x28(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 821AF21C: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821AF220: 419A0010  beq cr6, 0x821af230
	if ctx.cr[6].eq {
	pc = 0x821AF230; continue 'dispatch;
	}
	// 821AF224: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821AF228: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AF22C: 409A0008  bne cr6, 0x821af234
	if !ctx.cr[6].eq {
	pc = 0x821AF234; continue 'dispatch;
	}
	pc = 0x821AF230; continue 'dispatch;
            }
            0x821AF230 => {
    //   block [0x821AF230..0x821AF234)
	// 821AF230: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821AF234; continue 'dispatch;
            }
            0x821AF234 => {
    //   block [0x821AF234..0x821AF23C)
	// 821AF234: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AF238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AF248 size=2980
    let mut pc: u32 = 0x821AF248;
    'dispatch: loop {
        match pc {
            0x821AF248 => {
    //   block [0x821AF248..0x821AF2F0)
	// 821AF248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AF24C: 48AFA1A9  bl 0x82ca93f4
	ctx.lr = 0x821AF250;
	sub_82CA93D0(ctx, base);
	// 821AF250: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AF254: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821AF258: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821AF25C: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 821AF260: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 821AF264: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 821AF268: 48012789  bl 0x821c19f0
	ctx.lr = 0x821AF26C;
	sub_821C19F0(ctx, base);
	// 821AF26C: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821AF270: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821AF274: 3BEA63A0  addi r31, r10, 0x63a0
	ctx.r[31].s64 = ctx.r[10].s64 + 25504;
	// 821AF278: 3BCB2390  addi r30, r11, 0x2390
	ctx.r[30].s64 = ctx.r[11].s64 + 9104;
	// 821AF27C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821AF280: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 821AF284: 3B8B0DB8  addi r28, r11, 0xdb8
	ctx.r[28].s64 = ctx.r[11].s64 + 3512;
	// 821AF288: 817F1A5C  lwz r11, 0x1a5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6748 as u32) ) } as u64;
	// 821AF28C: 895F1A6D  lbz r10, 0x1a6d(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6765 as u32) ) } as u64;
	// 821AF290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF294: 1D6A2008  mulli r11, r10, 0x2008
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AF298: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF29C: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF2A0: 419A0088  beq cr6, 0x821af328
	if ctx.cr[6].eq {
	pc = 0x821AF328; continue 'dispatch;
	}
	// 821AF2A4: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF2A8: 813F1A60  lwz r9, 0x1a60(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6752 as u32) ) } as u64;
	// 821AF2AC: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821AF2B0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AF2B4: 409A003C  bne cr6, 0x821af2f0
	if !ctx.cr[6].eq {
	pc = 0x821AF2F0; continue 'dispatch;
	}
	// 821AF2B8: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF2BC: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821AF2C0: 38FF1A58  addi r7, r31, 0x1a58
	ctx.r[7].s64 = ctx.r[31].s64 + 6744;
	// 821AF2C4: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821AF2C8: 915F1A60  stw r10, 0x1a60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6752 as u32), ctx.r[10].u32 ) };
	// 821AF2CC: 7CE6592E  stwx r7, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821AF2D0: 815F1A5C  lwz r10, 0x1a5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6748 as u32) ) } as u64;
	// 821AF2D4: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF2D8: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF2DC: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821AF2E0: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821AF2E4: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF2E8: 386A0001  addi r3, r10, 1
	ctx.r[3].s64 = ctx.r[10].s64 + 1;
	// 821AF2EC: 906B2004  stw r3, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	pc = 0x821AF2F0; continue 'dispatch;
            }
            0x821AF2F0 => {
    //   block [0x821AF2F0..0x821AF328)
	// 821AF2F0: 897F1A6C  lbz r11, 0x1a6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6764 as u32) ) } as u64;
	// 821AF2F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AF2F8: 915F1A5C  stw r10, 0x1a5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6748 as u32), ctx.r[10].u32 ) };
	// 821AF2FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF300: 409A0028  bne cr6, 0x821af328
	if !ctx.cr[6].eq {
	pc = 0x821AF328; continue 'dispatch;
	}
	// 821AF304: 817D0DB0  lwz r11, 0xdb0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821AF308: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AF30C: 393F1A58  addi r9, r31, 0x1a58
	ctx.r[9].s64 = ctx.r[31].s64 + 6744;
	// 821AF310: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF314: 995F1A6C  stb r10, 0x1a6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6764 as u32), ctx.r[10].u8 ) };
	// 821AF318: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821AF31C: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF320: 7D28E12E  stwx r9, r8, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	// 821AF324: 48000008  b 0x821af32c
	pc = 0x821AF32C; continue 'dispatch;
            }
            0x821AF328 => {
    //   block [0x821AF328..0x821AF32C)
	// 821AF328: 815D0DB0  lwz r10, 0xdb0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x821AF32C; continue 'dispatch;
            }
            0x821AF32C => {
    //   block [0x821AF32C..0x821AF394)
	// 821AF32C: 897F1A85  lbz r11, 0x1a85(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6789 as u32) ) } as u64;
	// 821AF330: 813F1A74  lwz r9, 0x1a74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6772 as u32) ) } as u64;
	// 821AF334: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AF338: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF33C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 821AF340: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF344: 419A0080  beq cr6, 0x821af3c4
	if ctx.cr[6].eq {
	pc = 0x821AF3C4; continue 'dispatch;
	}
	// 821AF348: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF34C: 811F1A78  lwz r8, 0x1a78(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6776 as u32) ) } as u64;
	// 821AF350: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF354: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF358: 409A003C  bne cr6, 0x821af394
	if !ctx.cr[6].eq {
	pc = 0x821AF394; continue 'dispatch;
	}
	// 821AF35C: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF360: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF364: 38DF1A70  addi r6, r31, 0x1a70
	ctx.r[6].s64 = ctx.r[31].s64 + 6768;
	// 821AF368: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AF36C: 913F1A78  stw r9, 0x1a78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6776 as u32), ctx.r[9].u32 ) };
	// 821AF370: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821AF374: 813F1A74  lwz r9, 0x1a74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6772 as u32) ) } as u64;
	// 821AF378: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF37C: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF380: 7C685A14  add r3, r8, r11
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF384: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF388: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF38C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821AF390: 912B2004  stw r9, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x821AF394; continue 'dispatch;
            }
            0x821AF394 => {
    //   block [0x821AF394..0x821AF3C4)
	// 821AF394: 897F1A84  lbz r11, 0x1a84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6788 as u32) ) } as u64;
	// 821AF398: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AF39C: 913F1A74  stw r9, 0x1a74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6772 as u32), ctx.r[9].u32 ) };
	// 821AF3A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF3A4: 409A0020  bne cr6, 0x821af3c4
	if !ctx.cr[6].eq {
	pc = 0x821AF3C4; continue 'dispatch;
	}
	// 821AF3A8: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF3AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF3B0: 391F1A70  addi r8, r31, 0x1a70
	ctx.r[8].s64 = ctx.r[31].s64 + 6768;
	// 821AF3B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF3B8: 997F1A84  stb r11, 0x1a84(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6788 as u32), ctx.r[11].u8 ) };
	// 821AF3BC: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF3C0: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x821AF3C4; continue 'dispatch;
            }
            0x821AF3C4 => {
    //   block [0x821AF3C4..0x821AF42C)
	// 821AF3C4: 897F1AB5  lbz r11, 0x1ab5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6837 as u32) ) } as u64;
	// 821AF3C8: 813F1AA4  lwz r9, 0x1aa4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6820 as u32) ) } as u64;
	// 821AF3CC: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AF3D0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF3D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AF3D8: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF3DC: 419A0080  beq cr6, 0x821af45c
	if ctx.cr[6].eq {
	pc = 0x821AF45C; continue 'dispatch;
	}
	// 821AF3E0: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF3E4: 811F1AA8  lwz r8, 0x1aa8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6824 as u32) ) } as u64;
	// 821AF3E8: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF3EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF3F0: 409A003C  bne cr6, 0x821af42c
	if !ctx.cr[6].eq {
	pc = 0x821AF42C; continue 'dispatch;
	}
	// 821AF3F4: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF3F8: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF3FC: 38DF1AA0  addi r6, r31, 0x1aa0
	ctx.r[6].s64 = ctx.r[31].s64 + 6816;
	// 821AF400: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AF404: 913F1AA8  stw r9, 0x1aa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6824 as u32), ctx.r[9].u32 ) };
	// 821AF408: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821AF40C: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF410: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF414: 813F1AA4  lwz r9, 0x1aa4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6820 as u32) ) } as u64;
	// 821AF418: 7C685A14  add r3, r8, r11
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF41C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF420: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF424: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821AF428: 912B2004  stw r9, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x821AF42C; continue 'dispatch;
            }
            0x821AF42C => {
    //   block [0x821AF42C..0x821AF45C)
	// 821AF42C: 897F1AB4  lbz r11, 0x1ab4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6836 as u32) ) } as u64;
	// 821AF430: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AF434: 913F1AA4  stw r9, 0x1aa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6820 as u32), ctx.r[9].u32 ) };
	// 821AF438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF43C: 409A0020  bne cr6, 0x821af45c
	if !ctx.cr[6].eq {
	pc = 0x821AF45C; continue 'dispatch;
	}
	// 821AF440: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF444: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF448: 391F1AA0  addi r8, r31, 0x1aa0
	ctx.r[8].s64 = ctx.r[31].s64 + 6816;
	// 821AF44C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF450: 997F1AB4  stb r11, 0x1ab4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6836 as u32), ctx.r[11].u8 ) };
	// 821AF454: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF458: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x821AF45C; continue 'dispatch;
            }
            0x821AF45C => {
    //   block [0x821AF45C..0x821AF4D8)
	// 821AF45C: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821AF460: 88FF1A9D  lbz r7, 0x1a9d(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6813 as u32) ) } as u64;
	// 821AF464: 811F1A8C  lwz r8, 0x1a8c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821AF468: 38CB6FB8  addi r6, r11, 0x6fb8
	ctx.r[6].s64 = ctx.r[11].s64 + 28600;
	// 821AF46C: 1D672008  mulli r11, r7, 0x2008
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AF470: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF474: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF478: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 821AF47C: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821AF480: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF484: 419A0080  beq cr6, 0x821af504
	if ctx.cr[6].eq {
	pc = 0x821AF504; continue 'dispatch;
	}
	// 821AF488: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF48C: 811F1A90  lwz r8, 0x1a90(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6800 as u32) ) } as u64;
	// 821AF490: 7D054838  and r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF494: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821AF498: 409A0040  bne cr6, 0x821af4d8
	if !ctx.cr[6].eq {
	pc = 0x821AF4D8; continue 'dispatch;
	}
	// 821AF49C: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF4A0: 38BF1A88  addi r5, r31, 0x1a88
	ctx.r[5].s64 = ctx.r[31].s64 + 6792;
	// 821AF4A4: 809F1A90  lwz r4, 0x1a90(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6800 as u32) ) } as u64;
	// 821AF4A8: 55031838  slwi r3, r8, 3
	ctx.r[3].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821AF4AC: 7C894B78  or r9, r4, r9
	ctx.r[9].u64 = ctx.r[4].u64 | ctx.r[9].u64;
	// 821AF4B0: 913F1A90  stw r9, 0x1a90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6800 as u32), ctx.r[9].u32 ) };
	// 821AF4B4: 7CA3592E  stwx r5, r3, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AF4B8: 813F1A8C  lwz r9, 0x1a8c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821AF4BC: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF4C0: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF4C4: 7CA85A14  add r5, r8, r11
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF4C8: 91250004  stw r9, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF4CC: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF4D0: 38890001  addi r4, r9, 1
	ctx.r[4].s64 = ctx.r[9].s64 + 1;
	// 821AF4D4: 908B2004  stw r4, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[4].u32 ) };
	pc = 0x821AF4D8; continue 'dispatch;
            }
            0x821AF4D8 => {
    //   block [0x821AF4D8..0x821AF504)
	// 821AF4D8: 893F1A9C  lbz r9, 0x1a9c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6812 as u32) ) } as u64;
	// 821AF4DC: 90FF1A8C  stw r7, 0x1a8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6796 as u32), ctx.r[7].u32 ) };
	// 821AF4E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AF4E4: 409A0020  bne cr6, 0x821af504
	if !ctx.cr[6].eq {
	pc = 0x821AF504; continue 'dispatch;
	}
	// 821AF4E8: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AF4EC: 393F1A88  addi r9, r31, 0x1a88
	ctx.r[9].s64 = ctx.r[31].s64 + 6792;
	// 821AF4F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF4F4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821AF4F8: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF4FC: 991F1A9C  stb r8, 0x1a9c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6812 as u32), ctx.r[8].u8 ) };
	// 821AF500: 7D2BE12E  stwx r9, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	pc = 0x821AF504; continue 'dispatch;
            }
            0x821AF504 => {
    //   block [0x821AF504..0x821AF56C)
	// 821AF504: 897F020D  lbz r11, 0x20d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(525 as u32) ) } as u64;
	// 821AF508: 813F01FC  lwz r9, 0x1fc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 821AF50C: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AF510: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF514: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 821AF518: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF51C: 419A0080  beq cr6, 0x821af59c
	if ctx.cr[6].eq {
	pc = 0x821AF59C; continue 'dispatch;
	}
	// 821AF520: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF524: 811F0200  lwz r8, 0x200(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 821AF528: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF52C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF530: 409A003C  bne cr6, 0x821af56c
	if !ctx.cr[6].eq {
	pc = 0x821AF56C; continue 'dispatch;
	}
	// 821AF534: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF538: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF53C: 38BF01F8  addi r5, r31, 0x1f8
	ctx.r[5].s64 = ctx.r[31].s64 + 504;
	// 821AF540: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AF544: 913F0200  stw r9, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[9].u32 ) };
	// 821AF548: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AF54C: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF550: 813F01FC  lwz r9, 0x1fc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 821AF554: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF558: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF55C: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF560: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF564: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 821AF568: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x821AF56C; continue 'dispatch;
            }
            0x821AF56C => {
    //   block [0x821AF56C..0x821AF59C)
	// 821AF56C: 897F020C  lbz r11, 0x20c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 821AF570: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AF574: 913F01FC  stw r9, 0x1fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), ctx.r[9].u32 ) };
	// 821AF578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF57C: 409A0020  bne cr6, 0x821af59c
	if !ctx.cr[6].eq {
	pc = 0x821AF59C; continue 'dispatch;
	}
	// 821AF580: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF584: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF588: 391F01F8  addi r8, r31, 0x1f8
	ctx.r[8].s64 = ctx.r[31].s64 + 504;
	// 821AF58C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF590: 997F020C  stb r11, 0x20c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[11].u8 ) };
	// 821AF594: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF598: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x821AF59C; continue 'dispatch;
            }
            0x821AF59C => {
    //   block [0x821AF59C..0x821AF604)
	// 821AF59C: 897F0285  lbz r11, 0x285(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(645 as u32) ) } as u64;
	// 821AF5A0: 813F0274  lwz r9, 0x274(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 821AF5A4: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AF5A8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF5AC: 2B0900FF  cmplwi cr6, r9, 0xff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 255 as u32, &mut ctx.xer);
	// 821AF5B0: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF5B4: 419A0080  beq cr6, 0x821af634
	if ctx.cr[6].eq {
	pc = 0x821AF634; continue 'dispatch;
	}
	// 821AF5B8: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF5BC: 811F0278  lwz r8, 0x278(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 821AF5C0: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF5C4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF5C8: 409A003C  bne cr6, 0x821af604
	if !ctx.cr[6].eq {
	pc = 0x821AF604; continue 'dispatch;
	}
	// 821AF5CC: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF5D0: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF5D4: 38BF0270  addi r5, r31, 0x270
	ctx.r[5].s64 = ctx.r[31].s64 + 624;
	// 821AF5D8: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AF5DC: 913F0278  stw r9, 0x278(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), ctx.r[9].u32 ) };
	// 821AF5E0: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AF5E4: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF5E8: 813F0274  lwz r9, 0x274(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 821AF5EC: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF5F0: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF5F4: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF5F8: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF5FC: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 821AF600: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x821AF604; continue 'dispatch;
            }
            0x821AF604 => {
    //   block [0x821AF604..0x821AF634)
	// 821AF604: 897F0284  lbz r11, 0x284(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 821AF608: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 821AF60C: 913F0274  stw r9, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[9].u32 ) };
	// 821AF610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF614: 409A0020  bne cr6, 0x821af634
	if !ctx.cr[6].eq {
	pc = 0x821AF634; continue 'dispatch;
	}
	// 821AF618: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF61C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF620: 391F0270  addi r8, r31, 0x270
	ctx.r[8].s64 = ctx.r[31].s64 + 624;
	// 821AF624: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF628: 997F0284  stb r11, 0x284(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u8 ) };
	// 821AF62C: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF630: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x821AF634; continue 'dispatch;
            }
            0x821AF634 => {
    //   block [0x821AF634..0x821AF69C)
	// 821AF634: 897F02B5  lbz r11, 0x2b5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(693 as u32) ) } as u64;
	// 821AF638: 813F02A4  lwz r9, 0x2a4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(676 as u32) ) } as u64;
	// 821AF63C: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AF640: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF644: 2B0900FF  cmplwi cr6, r9, 0xff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 255 as u32, &mut ctx.xer);
	// 821AF648: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF64C: 419A0080  beq cr6, 0x821af6cc
	if ctx.cr[6].eq {
	pc = 0x821AF6CC; continue 'dispatch;
	}
	// 821AF650: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF654: 811F02A8  lwz r8, 0x2a8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(680 as u32) ) } as u64;
	// 821AF658: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF65C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF660: 409A003C  bne cr6, 0x821af69c
	if !ctx.cr[6].eq {
	pc = 0x821AF69C; continue 'dispatch;
	}
	// 821AF664: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF668: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF66C: 38BF02A0  addi r5, r31, 0x2a0
	ctx.r[5].s64 = ctx.r[31].s64 + 672;
	// 821AF670: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AF674: 913F02A8  stw r9, 0x2a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(680 as u32), ctx.r[9].u32 ) };
	// 821AF678: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AF67C: 813F02A4  lwz r9, 0x2a4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(676 as u32) ) } as u64;
	// 821AF680: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF684: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF688: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF68C: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF690: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF694: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 821AF698: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x821AF69C; continue 'dispatch;
            }
            0x821AF69C => {
    //   block [0x821AF69C..0x821AF6CC)
	// 821AF69C: 897F02B4  lbz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 821AF6A0: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 821AF6A4: 913F02A4  stw r9, 0x2a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(676 as u32), ctx.r[9].u32 ) };
	// 821AF6A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF6AC: 409A0020  bne cr6, 0x821af6cc
	if !ctx.cr[6].eq {
	pc = 0x821AF6CC; continue 'dispatch;
	}
	// 821AF6B0: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF6B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF6B8: 391F02A0  addi r8, r31, 0x2a0
	ctx.r[8].s64 = ctx.r[31].s64 + 672;
	// 821AF6BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF6C0: 997F02B4  stb r11, 0x2b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u8 ) };
	// 821AF6C4: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF6C8: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x821AF6CC; continue 'dispatch;
            }
            0x821AF6CC => {
    //   block [0x821AF6CC..0x821AF740)
	// 821AF6CC: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 821AF6D0: 88FF026D  lbz r7, 0x26d(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(621 as u32) ) } as u64;
	// 821AF6D4: 813F025C  lwz r9, 0x25c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 821AF6D8: 38A86F8C  addi r5, r8, 0x6f8c
	ctx.r[5].s64 = ctx.r[8].s64 + 28556;
	// 821AF6DC: 1D672008  mulli r11, r7, 0x2008
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AF6E0: 80E5001C  lwz r7, 0x1c(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AF6E4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF6E8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AF6EC: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF6F0: 419A007C  beq cr6, 0x821af76c
	if ctx.cr[6].eq {
	pc = 0x821AF76C; continue 'dispatch;
	}
	// 821AF6F4: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF6F8: 811F0260  lwz r8, 0x260(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 821AF6FC: 7D054838  and r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF700: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821AF704: 409A003C  bne cr6, 0x821af740
	if !ctx.cr[6].eq {
	pc = 0x821AF740; continue 'dispatch;
	}
	// 821AF708: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF70C: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF710: 389F0258  addi r4, r31, 0x258
	ctx.r[4].s64 = ctx.r[31].s64 + 600;
	// 821AF714: 54A31838  slwi r3, r5, 3
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821AF718: 913F0260  stw r9, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[9].u32 ) };
	// 821AF71C: 7C83592E  stwx r4, r3, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), ctx.r[4].u32) };
	// 821AF720: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF724: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF728: 813F025C  lwz r9, 0x25c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 821AF72C: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF730: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF734: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF738: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 821AF73C: 90AB2004  stw r5, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	pc = 0x821AF740; continue 'dispatch;
            }
            0x821AF740 => {
    //   block [0x821AF740..0x821AF76C)
	// 821AF740: 897F026C  lbz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 821AF744: 90FF025C  stw r7, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[7].u32 ) };
	// 821AF748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF74C: 409A0020  bne cr6, 0x821af76c
	if !ctx.cr[6].eq {
	pc = 0x821AF76C; continue 'dispatch;
	}
	// 821AF750: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF754: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF758: 391F0258  addi r8, r31, 0x258
	ctx.r[8].s64 = ctx.r[31].s64 + 600;
	// 821AF75C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF760: 997F026C  stb r11, 0x26c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[11].u8 ) };
	// 821AF764: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF768: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x821AF76C; continue 'dispatch;
            }
            0x821AF76C => {
    //   block [0x821AF76C..0x821AF7E0)
	// 821AF76C: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 821AF770: 88FF0255  lbz r7, 0x255(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(597 as u32) ) } as u64;
	// 821AF774: 813F0244  lwz r9, 0x244(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 821AF778: 38A86FFC  addi r5, r8, 0x6ffc
	ctx.r[5].s64 = ctx.r[8].s64 + 28668;
	// 821AF77C: 1D672008  mulli r11, r7, 0x2008
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AF780: 80E50008  lwz r7, 8(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AF784: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF788: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AF78C: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF790: 419A007C  beq cr6, 0x821af80c
	if ctx.cr[6].eq {
	pc = 0x821AF80C; continue 'dispatch;
	}
	// 821AF794: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF798: 811F0248  lwz r8, 0x248(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 821AF79C: 7D054838  and r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF7A0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821AF7A4: 409A003C  bne cr6, 0x821af7e0
	if !ctx.cr[6].eq {
	pc = 0x821AF7E0; continue 'dispatch;
	}
	// 821AF7A8: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF7AC: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF7B0: 389F0240  addi r4, r31, 0x240
	ctx.r[4].s64 = ctx.r[31].s64 + 576;
	// 821AF7B4: 54A31838  slwi r3, r5, 3
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821AF7B8: 913F0248  stw r9, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[9].u32 ) };
	// 821AF7BC: 7C83592E  stwx r4, r3, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), ctx.r[4].u32) };
	// 821AF7C0: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF7C4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF7C8: 813F0244  lwz r9, 0x244(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 821AF7CC: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF7D0: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF7D4: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF7D8: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 821AF7DC: 90AB2004  stw r5, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	pc = 0x821AF7E0; continue 'dispatch;
            }
            0x821AF7E0 => {
    //   block [0x821AF7E0..0x821AF80C)
	// 821AF7E0: 897F0254  lbz r11, 0x254(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 821AF7E4: 90FF0244  stw r7, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[7].u32 ) };
	// 821AF7E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF7EC: 409A0020  bne cr6, 0x821af80c
	if !ctx.cr[6].eq {
	pc = 0x821AF80C; continue 'dispatch;
	}
	// 821AF7F0: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF7F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF7F8: 391F0240  addi r8, r31, 0x240
	ctx.r[8].s64 = ctx.r[31].s64 + 576;
	// 821AF7FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF800: 997F0254  stb r11, 0x254(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[11].u8 ) };
	// 821AF804: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF808: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x821AF80C; continue 'dispatch;
            }
            0x821AF80C => {
    //   block [0x821AF80C..0x821AF874)
	// 821AF80C: 897F002D  lbz r11, 0x2d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 821AF810: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AF814: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AF818: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF81C: 2B09000F  cmplwi cr6, r9, 0xf
	ctx.cr[6].compare_u32(ctx.r[9].u32, 15 as u32, &mut ctx.xer);
	// 821AF820: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF824: 419A0080  beq cr6, 0x821af8a4
	if ctx.cr[6].eq {
	pc = 0x821AF8A4; continue 'dispatch;
	}
	// 821AF828: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF82C: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AF830: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF834: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF838: 409A003C  bne cr6, 0x821af874
	if !ctx.cr[6].eq {
	pc = 0x821AF874; continue 'dispatch;
	}
	// 821AF83C: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF840: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF844: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 821AF848: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AF84C: 913F0020  stw r9, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 821AF850: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AF854: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AF858: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF85C: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF860: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF864: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF868: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF86C: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 821AF870: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x821AF874; continue 'dispatch;
            }
            0x821AF874 => {
    //   block [0x821AF874..0x821AF8A4)
	// 821AF874: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821AF878: 3920000F  li r9, 0xf
	ctx.r[9].s64 = 15;
	// 821AF87C: 913F001C  stw r9, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 821AF880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF884: 409A0020  bne cr6, 0x821af8a4
	if !ctx.cr[6].eq {
	pc = 0x821AF8A4; continue 'dispatch;
	}
	// 821AF888: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF88C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF890: 391F0018  addi r8, r31, 0x18
	ctx.r[8].s64 = ctx.r[31].s64 + 24;
	// 821AF894: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF898: 997F002C  stb r11, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u8 ) };
	// 821AF89C: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF8A0: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x821AF8A4; continue 'dispatch;
            }
            0x821AF8A4 => {
    //   block [0x821AF8A4..0x821AF90C)
	// 821AF8A4: 897F005D  lbz r11, 0x5d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(93 as u32) ) } as u64;
	// 821AF8A8: 813F004C  lwz r9, 0x4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AF8AC: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AF8B0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF8B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AF8B8: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF8BC: 419A0080  beq cr6, 0x821af93c
	if ctx.cr[6].eq {
	pc = 0x821AF93C; continue 'dispatch;
	}
	// 821AF8C0: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF8C4: 811F0050  lwz r8, 0x50(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AF8C8: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF8CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF8D0: 409A003C  bne cr6, 0x821af90c
	if !ctx.cr[6].eq {
	pc = 0x821AF90C; continue 'dispatch;
	}
	// 821AF8D4: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF8D8: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF8DC: 38BF0048  addi r5, r31, 0x48
	ctx.r[5].s64 = ctx.r[31].s64 + 72;
	// 821AF8E0: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AF8E4: 913F0050  stw r9, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821AF8E8: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AF8EC: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF8F0: 813F004C  lwz r9, 0x4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AF8F4: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF8F8: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF8FC: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF900: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF904: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 821AF908: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x821AF90C; continue 'dispatch;
            }
            0x821AF90C => {
    //   block [0x821AF90C..0x821AF93C)
	// 821AF90C: 897F005C  lbz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AF910: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AF914: 913F004C  stw r9, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[9].u32 ) };
	// 821AF918: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF91C: 409A0020  bne cr6, 0x821af93c
	if !ctx.cr[6].eq {
	pc = 0x821AF93C; continue 'dispatch;
	}
	// 821AF920: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF924: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF928: 391F0048  addi r8, r31, 0x48
	ctx.r[8].s64 = ctx.r[31].s64 + 72;
	// 821AF92C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF930: 997F005C  stb r11, 0x5c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u8 ) };
	// 821AF934: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF938: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x821AF93C; continue 'dispatch;
            }
            0x821AF93C => {
    //   block [0x821AF93C..0x821AF9A4)
	// 821AF93C: 897F00D5  lbz r11, 0xd5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(213 as u32) ) } as u64;
	// 821AF940: 813F00C4  lwz r9, 0xc4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AF944: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AF948: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF94C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 821AF950: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF954: 419A0080  beq cr6, 0x821af9d4
	if ctx.cr[6].eq {
	pc = 0x821AF9D4; continue 'dispatch;
	}
	// 821AF958: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF95C: 811F00C8  lwz r8, 0xc8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AF960: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821AF964: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF968: 409A003C  bne cr6, 0x821af9a4
	if !ctx.cr[6].eq {
	pc = 0x821AF9A4; continue 'dispatch;
	}
	// 821AF96C: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF970: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821AF974: 38BF00C0  addi r5, r31, 0xc0
	ctx.r[5].s64 = ctx.r[31].s64 + 192;
	// 821AF978: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AF97C: 913F00C8  stw r9, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[9].u32 ) };
	// 821AF980: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AF984: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF988: 813F00C4  lwz r9, 0xc4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AF98C: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF990: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF994: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF998: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF99C: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 821AF9A0: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x821AF9A4; continue 'dispatch;
            }
            0x821AF9A4 => {
    //   block [0x821AF9A4..0x821AF9D4)
	// 821AF9A4: 897F00D4  lbz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 821AF9A8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AF9AC: 913F00C4  stw r9, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[9].u32 ) };
	// 821AF9B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF9B4: 409A0020  bne cr6, 0x821af9d4
	if !ctx.cr[6].eq {
	pc = 0x821AF9D4; continue 'dispatch;
	}
	// 821AF9B8: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF9BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF9C0: 391F00C0  addi r8, r31, 0xc0
	ctx.r[8].s64 = ctx.r[31].s64 + 192;
	// 821AF9C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF9C8: 997F00D4  stb r11, 0xd4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u8 ) };
	// 821AF9CC: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF9D0: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x821AF9D4; continue 'dispatch;
            }
            0x821AF9D4 => {
    //   block [0x821AF9D4..0x821AFA3C)
	// 821AF9D4: 897F00ED  lbz r11, 0xed(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(237 as u32) ) } as u64;
	// 821AF9D8: 813F00DC  lwz r9, 0xdc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 821AF9DC: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AF9E0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF9E4: 2B090080  cmplwi cr6, r9, 0x80
	ctx.cr[6].compare_u32(ctx.r[9].u32, 128 as u32, &mut ctx.xer);
	// 821AF9E8: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF9EC: 419A0080  beq cr6, 0x821afa6c
	if ctx.cr[6].eq {
	pc = 0x821AFA6C; continue 'dispatch;
	}
	// 821AF9F0: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF9F4: 811F00E0  lwz r8, 0xe0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 821AF9F8: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821AF9FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AFA00: 409A003C  bne cr6, 0x821afa3c
	if !ctx.cr[6].eq {
	pc = 0x821AFA3C; continue 'dispatch;
	}
	// 821AFA04: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFA08: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821AFA0C: 38BF00D8  addi r5, r31, 0xd8
	ctx.r[5].s64 = ctx.r[31].s64 + 216;
	// 821AFA10: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AFA14: 913F00E0  stw r9, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[9].u32 ) };
	// 821AFA18: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AFA1C: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFA20: 813F00DC  lwz r9, 0xdc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 821AFA24: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AFA28: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AFA2C: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AFA30: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFA34: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 821AFA38: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x821AFA3C; continue 'dispatch;
            }
            0x821AFA3C => {
    //   block [0x821AFA3C..0x821AFA6C)
	// 821AFA3C: 897F00EC  lbz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 821AFA40: 39200080  li r9, 0x80
	ctx.r[9].s64 = 128;
	// 821AFA44: 913F00DC  stw r9, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[9].u32 ) };
	// 821AFA48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFA4C: 409A0020  bne cr6, 0x821afa6c
	if !ctx.cr[6].eq {
	pc = 0x821AFA6C; continue 'dispatch;
	}
	// 821AFA50: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AFA54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AFA58: 391F00D8  addi r8, r31, 0xd8
	ctx.r[8].s64 = ctx.r[31].s64 + 216;
	// 821AFA5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AFA60: 997F00EC  stb r11, 0xec(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u8 ) };
	// 821AFA64: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AFA68: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x821AFA6C; continue 'dispatch;
            }
            0x821AFA6C => {
    //   block [0x821AFA6C..0x821AFAE0)
	// 821AFA6C: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 821AFA70: 88FF00A5  lbz r7, 0xa5(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(165 as u32) ) } as u64;
	// 821AFA74: 813F0094  lwz r9, 0x94(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 821AFA78: 38A86F4C  addi r5, r8, 0x6f4c
	ctx.r[5].s64 = ctx.r[8].s64 + 28492;
	// 821AFA7C: 1D672008  mulli r11, r7, 0x2008
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AFA80: 80E50010  lwz r7, 0x10(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AFA84: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AFA88: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AFA8C: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AFA90: 419A007C  beq cr6, 0x821afb0c
	if ctx.cr[6].eq {
	pc = 0x821AFB0C; continue 'dispatch;
	}
	// 821AFA94: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AFA98: 811F0098  lwz r8, 0x98(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 821AFA9C: 7D254038  and r5, r9, r8
	ctx.r[5].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821AFAA0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821AFAA4: 409A003C  bne cr6, 0x821afae0
	if !ctx.cr[6].eq {
	pc = 0x821AFAE0; continue 'dispatch;
	}
	// 821AFAA8: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFAAC: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821AFAB0: 389F0090  addi r4, r31, 0x90
	ctx.r[4].s64 = ctx.r[31].s64 + 144;
	// 821AFAB4: 54A31838  slwi r3, r5, 3
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821AFAB8: 913F0098  stw r9, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[9].u32 ) };
	// 821AFABC: 7C83592E  stwx r4, r3, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), ctx.r[4].u32) };
	// 821AFAC0: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFAC4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AFAC8: 813F0094  lwz r9, 0x94(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 821AFACC: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AFAD0: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AFAD4: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFAD8: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 821AFADC: 90AB2004  stw r5, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	pc = 0x821AFAE0; continue 'dispatch;
            }
            0x821AFAE0 => {
    //   block [0x821AFAE0..0x821AFB0C)
	// 821AFAE0: 897F00A4  lbz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 821AFAE4: 90FF0094  stw r7, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[7].u32 ) };
	// 821AFAE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFAEC: 409A0020  bne cr6, 0x821afb0c
	if !ctx.cr[6].eq {
	pc = 0x821AFB0C; continue 'dispatch;
	}
	// 821AFAF0: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AFAF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AFAF8: 391F0090  addi r8, r31, 0x90
	ctx.r[8].s64 = ctx.r[31].s64 + 144;
	// 821AFAFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AFB00: 997F00A4  stb r11, 0xa4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u8 ) };
	// 821AFB04: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AFB08: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x821AFB0C; continue 'dispatch;
            }
            0x821AFB0C => {
    //   block [0x821AFB0C..0x821AFB80)
	// 821AFB0C: 891F1A9D  lbz r8, 0x1a9d(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6813 as u32) ) } as u64;
	// 821AFB10: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AFB14: 1D682008  mulli r11, r8, 0x2008
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AFB18: 813F1A8C  lwz r9, 0x1a8c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821AFB1C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AFB20: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 821AFB24: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821AFB28: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AFB2C: 419A0080  beq cr6, 0x821afbac
	if ctx.cr[6].eq {
	pc = 0x821AFBAC; continue 'dispatch;
	}
	// 821AFB30: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AFB34: 811F1A90  lwz r8, 0x1a90(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6800 as u32) ) } as u64;
	// 821AFB38: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821AFB3C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821AFB40: 409A0040  bne cr6, 0x821afb80
	if !ctx.cr[6].eq {
	pc = 0x821AFB80; continue 'dispatch;
	}
	// 821AFB44: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFB48: 38DF1A88  addi r6, r31, 0x1a88
	ctx.r[6].s64 = ctx.r[31].s64 + 6792;
	// 821AFB4C: 80BF1A90  lwz r5, 0x1a90(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6800 as u32) ) } as u64;
	// 821AFB50: 55041838  slwi r4, r8, 3
	ctx.r[4].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AFB54: 7D292B78  or r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[5].u64;
	// 821AFB58: 913F1A90  stw r9, 0x1a90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6800 as u32), ctx.r[9].u32 ) };
	// 821AFB5C: 7CC4592E  stwx r6, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821AFB60: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFB64: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AFB68: 813F1A8C  lwz r9, 0x1a8c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821AFB6C: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AFB70: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AFB74: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFB78: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821AFB7C: 90CB2004  stw r6, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x821AFB80; continue 'dispatch;
            }
            0x821AFB80 => {
    //   block [0x821AFB80..0x821AFBAC)
	// 821AFB80: 893F1A9C  lbz r9, 0x1a9c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6812 as u32) ) } as u64;
	// 821AFB84: 90FF1A8C  stw r7, 0x1a8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6796 as u32), ctx.r[7].u32 ) };
	// 821AFB88: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AFB8C: 409A0020  bne cr6, 0x821afbac
	if !ctx.cr[6].eq {
	pc = 0x821AFBAC; continue 'dispatch;
	}
	// 821AFB90: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AFB94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AFB98: 391F1A88  addi r8, r31, 0x1a88
	ctx.r[8].s64 = ctx.r[31].s64 + 6792;
	// 821AFB9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AFBA0: 997F1A9C  stb r11, 0x1a9c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6812 as u32), ctx.r[11].u8 ) };
	// 821AFBA4: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AFBA8: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x821AFBAC; continue 'dispatch;
            }
            0x821AFBAC => {
    //   block [0x821AFBAC..0x821AFC4C)
	// 821AFBAC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821AFBB0: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AFBB4: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 821AFBB8: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AFBBC: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 821AFBC0: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AFBC4: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AFBC8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AFBCC: 808B4E2C  lwz r4, 0x4e2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20012 as u32) ) } as u64;
	// 821AFBD0: 48030819  bl 0x821e03e8
	ctx.lr = 0x821AFBD4;
	sub_821E03E8(ctx, base);
	// 821AFBD4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AFBD8: 48119619  bl 0x822c91f0
	ctx.lr = 0x821AFBDC;
	sub_822C91F0(ctx, base);
	// 821AFBDC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AFBE0: 4BFD32A9  bl 0x82182e88
	ctx.lr = 0x821AFBE4;
	sub_82182E88(ctx, base);
	// 821AFBE4: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AFBE8: 895F005D  lbz r10, 0x5d(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(93 as u32) ) } as u64;
	// 821AFBEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFBF0: 1D6A2008  mulli r11, r10, 0x2008
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AFBF4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AFBF8: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AFBFC: 419A0088  beq cr6, 0x821afc84
	if ctx.cr[6].eq {
	pc = 0x821AFC84; continue 'dispatch;
	}
	// 821AFC00: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AFC04: 813F0050  lwz r9, 0x50(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AFC08: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821AFC0C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AFC10: 409A003C  bne cr6, 0x821afc4c
	if !ctx.cr[6].eq {
	pc = 0x821AFC4C; continue 'dispatch;
	}
	// 821AFC14: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFC18: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821AFC1C: 38FF0048  addi r7, r31, 0x48
	ctx.r[7].s64 = ctx.r[31].s64 + 72;
	// 821AFC20: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821AFC24: 915F0050  stw r10, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821AFC28: 7CE6592E  stwx r7, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821AFC2C: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFC30: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AFC34: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AFC38: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821AFC3C: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821AFC40: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFC44: 386A0001  addi r3, r10, 1
	ctx.r[3].s64 = ctx.r[10].s64 + 1;
	// 821AFC48: 906B2004  stw r3, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	pc = 0x821AFC4C; continue 'dispatch;
            }
            0x821AFC4C => {
    //   block [0x821AFC4C..0x821AFC84)
	// 821AFC4C: 897F005C  lbz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AFC50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AFC54: 915F004C  stw r10, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 821AFC58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFC5C: 409A0028  bne cr6, 0x821afc84
	if !ctx.cr[6].eq {
	pc = 0x821AFC84; continue 'dispatch;
	}
	// 821AFC60: 817D0DB0  lwz r11, 0xdb0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821AFC64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AFC68: 393F0048  addi r9, r31, 0x48
	ctx.r[9].s64 = ctx.r[31].s64 + 72;
	// 821AFC6C: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821AFC70: 995F005C  stb r10, 0x5c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u8 ) };
	// 821AFC74: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821AFC78: 911D0DB0  stw r8, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[8].u32 ) };
	// 821AFC7C: 7D27E12E  stwx r9, r7, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	// 821AFC80: 48000008  b 0x821afc88
	pc = 0x821AFC88; continue 'dispatch;
            }
            0x821AFC84 => {
    //   block [0x821AFC84..0x821AFC88)
	// 821AFC84: 811D0DB0  lwz r8, 0xdb0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x821AFC88; continue 'dispatch;
            }
            0x821AFC88 => {
    //   block [0x821AFC88..0x821AFCF0)
	// 821AFC88: 897F00D5  lbz r11, 0xd5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(213 as u32) ) } as u64;
	// 821AFC8C: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AFC90: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AFC94: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AFC98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AFC9C: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AFCA0: 419A0080  beq cr6, 0x821afd20
	if ctx.cr[6].eq {
	pc = 0x821AFD20; continue 'dispatch;
	}
	// 821AFCA4: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AFCA8: 813F00C8  lwz r9, 0xc8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AFCAC: 7D474838  and r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821AFCB0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AFCB4: 409A003C  bne cr6, 0x821afcf0
	if !ctx.cr[6].eq {
	pc = 0x821AFCF0; continue 'dispatch;
	}
	// 821AFCB8: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFCBC: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821AFCC0: 38DF00C0  addi r6, r31, 0xc0
	ctx.r[6].s64 = ctx.r[31].s64 + 192;
	// 821AFCC4: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AFCC8: 915F00C8  stw r10, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[10].u32 ) };
	// 821AFCCC: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821AFCD0: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFCD4: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AFCD8: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AFCDC: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821AFCE0: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821AFCE4: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFCE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AFCEC: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	pc = 0x821AFCF0; continue 'dispatch;
            }
            0x821AFCF0 => {
    //   block [0x821AFCF0..0x821AFD20)
	// 821AFCF0: 897F00D4  lbz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 821AFCF4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AFCF8: 915F00C4  stw r10, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
	// 821AFCFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFD00: 409A0020  bne cr6, 0x821afd20
	if !ctx.cr[6].eq {
	pc = 0x821AFD20; continue 'dispatch;
	}
	// 821AFD04: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AFD08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AFD0C: 393F00C0  addi r9, r31, 0xc0
	ctx.r[9].s64 = ctx.r[31].s64 + 192;
	// 821AFD10: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821AFD14: 997F00D4  stb r11, 0xd4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u8 ) };
	// 821AFD18: 911D0DB0  stw r8, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[8].u32 ) };
	// 821AFD1C: 7D2AE12E  stwx r9, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	pc = 0x821AFD20; continue 'dispatch;
            }
            0x821AFD20 => {
    //   block [0x821AFD20..0x821AFD88)
	// 821AFD20: 897F002D  lbz r11, 0x2d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 821AFD24: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AFD28: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AFD2C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AFD30: 2B0A000F  cmplwi cr6, r10, 0xf
	ctx.cr[6].compare_u32(ctx.r[10].u32, 15 as u32, &mut ctx.xer);
	// 821AFD34: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AFD38: 419A0080  beq cr6, 0x821afdb8
	if ctx.cr[6].eq {
	pc = 0x821AFDB8; continue 'dispatch;
	}
	// 821AFD3C: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AFD40: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AFD44: 7D474838  and r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821AFD48: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AFD4C: 409A003C  bne cr6, 0x821afd88
	if !ctx.cr[6].eq {
	pc = 0x821AFD88; continue 'dispatch;
	}
	// 821AFD50: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFD54: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821AFD58: 38DF0018  addi r6, r31, 0x18
	ctx.r[6].s64 = ctx.r[31].s64 + 24;
	// 821AFD5C: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AFD60: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821AFD64: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821AFD68: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AFD6C: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFD70: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AFD74: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821AFD78: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821AFD7C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFD80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AFD84: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	pc = 0x821AFD88; continue 'dispatch;
            }
            0x821AFD88 => {
    //   block [0x821AFD88..0x821AFDB8)
	// 821AFD88: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821AFD8C: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	// 821AFD90: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 821AFD94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFD98: 409A0020  bne cr6, 0x821afdb8
	if !ctx.cr[6].eq {
	pc = 0x821AFDB8; continue 'dispatch;
	}
	// 821AFD9C: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AFDA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AFDA4: 38FF0018  addi r7, r31, 0x18
	ctx.r[7].s64 = ctx.r[31].s64 + 24;
	// 821AFDA8: 39480001  addi r10, r8, 1
	ctx.r[10].s64 = ctx.r[8].s64 + 1;
	// 821AFDAC: 997F002C  stb r11, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u8 ) };
	// 821AFDB0: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AFDB4: 7CE9E12E  stwx r7, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[7].u32) };
	pc = 0x821AFDB8; continue 'dispatch;
            }
            0x821AFDB8 => {
    //   block [0x821AFDB8..0x821AFDEC)
	// 821AFDB8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821AFDBC: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AFDC0: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 821AFDC4: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AFDC8: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 821AFDCC: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AFDD0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AFDD4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AFDD8: 808B4E5C  lwz r4, 0x4e5c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20060 as u32) ) } as u64;
	// 821AFDDC: 4803060D  bl 0x821e03e8
	ctx.lr = 0x821AFDE0;
	sub_821E03E8(ctx, base);
	// 821AFDE0: 48047091  bl 0x821f6e70
	ctx.lr = 0x821AFDE4;
	sub_821F6E70(ctx, base);
	// 821AFDE4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AFDE8: 48AF965C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AFDF0 size=164
    let mut pc: u32 = 0x821AFDF0;
    'dispatch: loop {
        match pc {
            0x821AFDF0 => {
    //   block [0x821AFDF0..0x821AFE78)
	// 821AFDF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AFDF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AFDF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AFDFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AFE00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AFE04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AFE08: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 821AFE0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821AFE10: 480144D9  bl 0x821c42e8
	ctx.lr = 0x821AFE14;
	sub_821C42E8(ctx, base);
	// 821AFE14: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821AFE18: 41980060  blt cr6, 0x821afe78
	if ctx.cr[6].lt {
	pc = 0x821AFE78; continue 'dispatch;
	}
	// 821AFE1C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AFE20: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AFE24: 40980054  bge cr6, 0x821afe78
	if !ctx.cr[6].lt {
	pc = 0x821AFE78; continue 'dispatch;
	}
	// 821AFE28: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821AFE2C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 821AFE30: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AFE34: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AFE38: 40980040  bge cr6, 0x821afe78
	if !ctx.cr[6].lt {
	pc = 0x821AFE78; continue 'dispatch;
	}
	// 821AFE3C: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AFE40: 1D63001C  mulli r11, r3, 0x1c
	ctx.r[11].s32 = ((ctx.r[3].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AFE44: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AFE48: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AFE4C: C01F004C  lfs f0, 0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFE50: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AFE54: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AFE58: 7DA95C2E  lfsx f13, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AFE5C: 7D8A5C2E  lfsx f12, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AFE60: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 821AFE64: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821AFE68: 40980010  bge cr6, 0x821afe78
	if !ctx.cr[6].lt {
	pc = 0x821AFE78; continue 'dispatch;
	}
	// 821AFE6C: 7C0A5D2E  stfsx f0, r10, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821AFE70: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AFE74: 48000008  b 0x821afe7c
	pc = 0x821AFE7C; continue 'dispatch;
            }
            0x821AFE78 => {
    //   block [0x821AFE78..0x821AFE7C)
	// 821AFE78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821AFE7C; continue 'dispatch;
            }
            0x821AFE7C => {
    //   block [0x821AFE7C..0x821AFE94)
	// 821AFE7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AFE80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AFE84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AFE88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821AFE8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AFE90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AFE98 size=288
    let mut pc: u32 = 0x821AFE98;
    'dispatch: loop {
        match pc {
            0x821AFE98 => {
    //   block [0x821AFE98..0x821AFFAC)
	// 821AFE98: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 821AFE9C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821AFEA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AFEA4: D021001C  stfs f1, 0x1c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821AFEA8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AFEAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AFEB0: 409900FC  ble cr6, 0x821affac
	if !ctx.cr[6].gt {
	pc = 0x821AFFAC; continue 'dispatch;
	}
	// 821AFEB4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821AFEB8: 39630050  addi r11, r3, 0x50
	ctx.r[11].s64 = ctx.r[3].s64 + 80;
	// 821AFEBC: 390A9490  addi r8, r10, -0x6b70
	ctx.r[8].s64 = ctx.r[10].s64 + -27504;
	// 821AFEC0: C1AA9490  lfs f13, -0x6b70(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AFEC4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821AFEC8: D1A1FFA4  stfs f13, -0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-92 as u32), tmp.u32 ) };
	// 821AFECC: C008FFF4  lfs f0, -0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFED0: 390A91A0  addi r8, r10, -0x6e60
	ctx.r[8].s64 = ctx.r[10].s64 + -28256;
	// 821AFED4: D001FFA0  stfs f0, -0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), tmp.u32 ) };
	// 821AFED8: 3941FFB0  addi r10, r1, -0x50
	ctx.r[10].s64 = ctx.r[1].s64 + -80;
	pc = 0x821AFFAC; continue 'dispatch;
            }
            0x821AFFAC => {
    //   block [0x821AFFAC..0x821AFFB8)
	// 821AFFAC: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AFFB0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821AFFB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AFFB8 size=172
    let mut pc: u32 = 0x821AFFB8;
    'dispatch: loop {
        match pc {
            0x821AFFB8 => {
    //   block [0x821AFFB8..0x821B0064)
	// 821AFFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AFFBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AFFC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AFFC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AFFC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AFFCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821AFFD0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821AFFD4: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 821AFFD8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821AFFDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AFFE0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821AFFE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AFFE8: 4BFE3E51  bl 0x82193e38
	ctx.lr = 0x821AFFEC;
	sub_82193E38(ctx, base);
	// 821AFFEC: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 821AFFF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821AFFF4: 48321ED5  bl 0x824d1ec8
	ctx.lr = 0x821AFFF8;
	sub_824D1EC8(ctx, base);
	// 821AFFF8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821AFFFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B0000: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 821B0004: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821B0008: 4BFE3E31  bl 0x82193e38
	ctx.lr = 0x821B000C;
	sub_82193E38(ctx, base);
	// 821B000C: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 821B0010: 38C00270  li r6, 0x270
	ctx.r[6].s64 = 624;
	// 821B0014: 93DF00A8  stw r30, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 821B0018: 38A7A950  addi r5, r7, -0x56b0
	ctx.r[5].s64 = ctx.r[7].s64 + -22192;
	// 821B001C: 93DF00AC  stw r30, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 821B0020: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821B0024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B0028: 909F0260  stw r4, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[4].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B0068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B0068 size=236
    let mut pc: u32 = 0x821B0068;
    'dispatch: loop {
        match pc {
            0x821B0068 => {
    //   block [0x821B0068..0x821B0154)
	// 821B0068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B006C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B0070: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B0074: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B0078: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B0158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B0158 size=128
    let mut pc: u32 = 0x821B0158;
    'dispatch: loop {
        match pc {
            0x821B0158 => {
    //   block [0x821B0158..0x821B018C)
	// 821B0158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B015C: 48AF92A9  bl 0x82ca9404
	ctx.lr = 0x821B0160;
	sub_82CA93D0(ctx, base);
	// 821B0160: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B0164: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821B0168: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821B016C: 3BCB5008  addi r30, r11, 0x5008
	ctx.r[30].s64 = ctx.r[11].s64 + 20488;
	// 821B0170: 83BB0004  lwz r29, 4(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0174: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0178: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B017C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B0180: 4099000C  ble cr6, 0x821b018c
	if !ctx.cr[6].gt {
	pc = 0x821B018C; continue 'dispatch;
	}
	// 821B0184: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0188: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B018C; continue 'dispatch;
            }
            0x821B018C => {
    //   block [0x821B018C..0x821B0190)
	// 821B018C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	pc = 0x821B0190; continue 'dispatch;
            }
            0x821B0190 => {
    //   block [0x821B0190..0x821B01A4)
	// 821B0190: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B0194: 419A0034  beq cr6, 0x821b01c8
	if ctx.cr[6].eq {
	pc = 0x821B01C8; continue 'dispatch;
	}
	// 821B0198: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B019C: 41980008  blt cr6, 0x821b01a4
	if ctx.cr[6].lt {
	pc = 0x821B01A4; continue 'dispatch;
	}
	// 821B01A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B01A4; continue 'dispatch;
            }
            0x821B01A4 => {
    //   block [0x821B01A4..0x821B01C0)
	// 821B01A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B01A8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B01AC: 4897F9FD  bl 0x82b2fba8
	ctx.lr = 0x821B01B0;
	sub_82B2FBA8(ctx, base);
	// 821B01B0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B01B4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B01B8: 41980008  blt cr6, 0x821b01c0
	if ctx.cr[6].lt {
	pc = 0x821B01C0; continue 'dispatch;
	}
	// 821B01BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B01C0; continue 'dispatch;
            }
            0x821B01C0 => {
    //   block [0x821B01C0..0x821B01C8)
	// 821B01C0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821B01C4: 4BFFFFCC  b 0x821b0190
	pc = 0x821B0190; continue 'dispatch;
            }
            0x821B01C8 => {
    //   block [0x821B01C8..0x821B01D8)
	// 821B01C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B01CC: 480D2155  bl 0x82282320
	ctx.lr = 0x821B01D0;
	sub_82282320(ctx, base);
	// 821B01D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B01D4: 48AF9280  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B01D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B01D8 size=4436
    let mut pc: u32 = 0x821B01D8;
    'dispatch: loop {
        match pc {
            0x821B01D8 => {
    //   block [0x821B01D8..0x821B0268)
	// 821B01D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B01DC: 48AF91F5  bl 0x82ca93d0
	ctx.lr = 0x821B01E0;
	sub_82CA93D0(ctx, base);
	// 821B01E0: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 821B01E4: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B01E8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B01EC: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 821B01F0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B01F4: 3D20811C  lis r9, -0x7ee4
	ctx.r[9].s64 = -2128871424;
	// 821B01F8: 3E008349  lis r16, -0x7cb7
	ctx.r[16].s64 = -2092367872;
	// 821B01FC: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821B0200: 61349DC5  ori r20, r9, 0x9dc5
	ctx.r[20].u64 = ctx.r[9].u64 | 40389;
	// 821B0204: C1B60240  lfs f13, 0x240(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(576 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B0208: C00A9484  lfs f0, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B020C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B0210: 91760258  stw r11, 0x258(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(600 as u32), ctx.r[11].u32 ) };
	// 821B0214: 409A0054  bne cr6, 0x821b0268
	if !ctx.cr[6].eq {
	pc = 0x821B0268; continue 'dispatch;
	}
	// 821B0218: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B021C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0220: 386B8AFC  addi r3, r11, -0x7504
	ctx.r[3].s64 = ctx.r[11].s64 + -29956;
	// 821B0224: 48043B35  bl 0x821f3d58
	ctx.lr = 0x821B0228;
	sub_821F3D58(ctx, base);
	// 821B0228: 81706DA0  lwz r11, 0x6da0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B022C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0230: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821B0234: 4884FC25  bl 0x829ffe58
	ctx.lr = 0x821B0238;
	sub_829FFE58(ctx, base);
	// 821B0238: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B023C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B0240: 419A0028  beq cr6, 0x821b0268
	if ctx.cr[6].eq {
	pc = 0x821B0268; continue 'dispatch;
	}
	// 821B0244: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B0248: 388B8B14  addi r4, r11, -0x74ec
	ctx.r[4].s64 = ctx.r[11].s64 + -29932;
	// 821B024C: 4BFE6935  bl 0x82196b80
	ctx.lr = 0x821B0250;
	sub_82196B80(ctx, base);
	// 821B0250: D036023C  stfs f1, 0x23c(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(572 as u32), tmp.u32 ) };
	// 821B0254: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B0258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B025C: 388A8B24  addi r4, r10, -0x74dc
	ctx.r[4].s64 = ctx.r[10].s64 + -29916;
	// 821B0260: 4BFE6921  bl 0x82196b80
	ctx.lr = 0x821B0264;
	sub_82196B80(ctx, base);
	// 821B0264: D0360240  stfs f1, 0x240(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(576 as u32), tmp.u32 ) };
	pc = 0x821B0268; continue 'dispatch;
            }
            0x821B0268 => {
    //   block [0x821B0268..0x821B0310)
	// 821B0268: 81760234  lwz r11, 0x234(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(564 as u32) ) } as u64;
	// 821B026C: 3BB60234  addi r29, r22, 0x234
	ctx.r[29].s64 = ctx.r[22].s64 + 564;
	// 821B0270: 3A200000  li r17, 0
	ctx.r[17].s64 = 0;
	// 821B0274: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 821B0278: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 821B027C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0280: 419A0214  beq cr6, 0x821b0494
	if ctx.cr[6].eq {
	pc = 0x821B0494; continue 'dispatch;
	}
	// 821B0284: C8099660  lfd f0, -0x69a0(r9)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-27040 as u32) ) };
	// 821B0288: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B028C: C1B60240  lfs f13, 0x240(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(576 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B0290: 81160258  lwz r8, 0x258(r22)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B0294: FD8D0032  fmul f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 821B0298: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821B029C: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 821B02A0: D9410080  stfd f10, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.f[10].u64 ) };
	// 821B02A4: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B02A8: 7CE95214  add r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821B02AC: 7F083800  cmpw cr6, r8, r7
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821B02B0: 409901E4  ble cr6, 0x821b0494
	if !ctx.cr[6].gt {
	pc = 0x821B0494; continue 'dispatch;
	}
	// 821B02B4: 83FC6AB8  lwz r31, 0x6ab8(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B02B8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 821B02BC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B02C0: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B02C4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B02C8: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B02CC: 480B41BD  bl 0x82264488
	ctx.lr = 0x821B02D0;
	sub_82264488(ctx, base);
	// 821B02D0: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B02D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B02D8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B02DC: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 821B02E0: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B02E4: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B02E8: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B02EC: 480B419D  bl 0x82264488
	ctx.lr = 0x821B02F0;
	sub_82264488(ctx, base);
	// 821B02F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B02F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B02F8: 419A0018  beq cr6, 0x821b0310
	if ctx.cr[6].eq {
	pc = 0x821B0310; continue 'dispatch;
	}
	// 821B02FC: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B0300: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B0304: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B0308: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B030C: 409A0008  bne cr6, 0x821b0314
	if !ctx.cr[6].eq {
	pc = 0x821B0314; continue 'dispatch;
	}
	pc = 0x821B0310; continue 'dispatch;
            }
            0x821B0310 => {
    //   block [0x821B0310..0x821B0314)
	// 821B0310: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	pc = 0x821B0314; continue 'dispatch;
            }
            0x821B0314 => {
    //   block [0x821B0314..0x821B03A8)
	// 821B0314: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B0318: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B031C: 419A016C  beq cr6, 0x821b0488
	if ctx.cr[6].eq {
	pc = 0x821B0488; continue 'dispatch;
	}
	// 821B0320: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821B0324: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821B0328: 837D0000  lwz r27, 0(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B032C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0330: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B0334: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B0338: 4E800421  bctrl
	ctx.lr = 0x821B033C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B033C: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B0340: 39000065  li r8, 0x65
	ctx.r[8].s64 = 101;
	// 821B0344: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0348: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821B034C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821B0350: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 821B0354: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B0358: 3880001E  li r4, 0x1e
	ctx.r[4].s64 = 30;
	// 821B035C: 81630058  lwz r11, 0x58(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B0360: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0364: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B0368: 480C9819  bl 0x82279b80
	ctx.lr = 0x821B036C;
	sub_82279B80(ctx, base);
	// 821B036C: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B0370: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821B0374: 55283FFE  rlwinm r8, r9, 7, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x01FFFFFFu64;
	// 821B0378: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B037C: 419A00E8  beq cr6, 0x821b0464
	if ctx.cr[6].eq {
	pc = 0x821B0464; continue 'dispatch;
	}
	// 821B0380: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B0384: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0388: 419A0020  beq cr6, 0x821b03a8
	if ctx.cr[6].eq {
	pc = 0x821B03A8; continue 'dispatch;
	}
	// 821B038C: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 821B0390: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B0394: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B0398: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B039C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B03A0: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B03A4: 480000C4  b 0x821b0468
	pc = 0x821B0468; continue 'dispatch;
            }
            0x821B03A8 => {
    //   block [0x821B03A8..0x821B03C4)
	// 821B03A8: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B03AC: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B03B0: 92210078  stw r17, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[17].u32 ) };
	// 821B03B4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B03B8: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 821B03BC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B03C0: 40810054  ble 0x821b0414
	if !ctx.cr[0].gt {
	pc = 0x821B0414; continue 'dispatch;
	}
	pc = 0x821B03C4; continue 'dispatch;
            }
            0x821B03C4 => {
    //   block [0x821B03C4..0x821B03E4)
	// 821B03C4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B03C8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B03CC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B03D0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B03D4: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 821B03D8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B03DC: 41980008  blt cr6, 0x821b03e4
	if ctx.cr[6].lt {
	pc = 0x821B03E4; continue 'dispatch;
	}
	// 821B03E0: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	pc = 0x821B03E4; continue 'dispatch;
            }
            0x821B03E4 => {
    //   block [0x821B03E4..0x821B0400)
	// 821B03E4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B03E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B03EC: 419A0014  beq cr6, 0x821b0400
	if ctx.cr[6].eq {
	pc = 0x821B0400; continue 'dispatch;
	}
	// 821B03F0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B03F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B03F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B03FC: 4800000C  b 0x821b0408
	pc = 0x821B0408; continue 'dispatch;
            }
            0x821B0400 => {
    //   block [0x821B0400..0x821B0408)
	// 821B0400: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B0404: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821B0408; continue 'dispatch;
            }
            0x821B0408 => {
    //   block [0x821B0408..0x821B0414)
	// 821B0408: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B040C: 4199FFB8  bgt cr6, 0x821b03c4
	if ctx.cr[6].gt {
	pc = 0x821B03C4; continue 'dispatch;
	}
	// 821B0410: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	pc = 0x821B0414; continue 'dispatch;
            }
            0x821B0414 => {
    //   block [0x821B0414..0x821B0430)
	// 821B0414: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B0418: 419A003C  beq cr6, 0x821b0454
	if ctx.cr[6].eq {
	pc = 0x821B0454; continue 'dispatch;
	}
	// 821B041C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0420: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 821B0424: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B0428: 41990008  bgt cr6, 0x821b0430
	if ctx.cr[6].gt {
	pc = 0x821B0430; continue 'dispatch;
	}
	// 821B042C: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	pc = 0x821B0430; continue 'dispatch;
            }
            0x821B0430 => {
    //   block [0x821B0430..0x821B0454)
	// 821B0430: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B0434: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0438: 409A001C  bne cr6, 0x821b0454
	if !ctx.cr[6].eq {
	pc = 0x821B0454; continue 'dispatch;
	}
	// 821B043C: E9610078  ld r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 821B0440: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 821B0444: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B0448: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B044C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B0450: 48000018  b 0x821b0468
	pc = 0x821B0468; continue 'dispatch;
            }
            0x821B0454 => {
    //   block [0x821B0454..0x821B0464)
	// 821B0454: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B0458: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B045C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B0460: 48000008  b 0x821b0468
	pc = 0x821B0468; continue 'dispatch;
            }
            0x821B0464 => {
    //   block [0x821B0464..0x821B0468)
	// 821B0464: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	pc = 0x821B0468; continue 'dispatch;
            }
            0x821B0468 => {
    //   block [0x821B0468..0x821B0488)
	// 821B0468: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B046C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0470: 419A0018  beq cr6, 0x821b0488
	if ctx.cr[6].eq {
	pc = 0x821B0488; continue 'dispatch;
	}
	// 821B0474: 816304E0  lwz r11, 0x4e0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1248 as u32) ) } as u64;
	// 821B0478: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B047C: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 821B0480: 90A304E0  stw r5, 0x4e0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1248 as u32), ctx.r[5].u32 ) };
	// 821B0484: 48328A35  bl 0x824d8eb8
	ctx.lr = 0x821B0488;
	sub_824D8EB8(ctx, base);
	pc = 0x821B0488; continue 'dispatch;
            }
            0x821B0488 => {
    //   block [0x821B0488..0x821B0494)
	// 821B0488: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B048C: 4800768D  bl 0x821b7b18
	ctx.lr = 0x821B0490;
	sub_821B7B18(ctx, base);
	// 821B0490: 923D0000  stw r17, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	pc = 0x821B0494; continue 'dispatch;
            }
            0x821B0494 => {
    //   block [0x821B0494..0x821B050C)
	// 821B0494: 4BFC2705  bl 0x82172b98
	ctx.lr = 0x821B0498;
	sub_82172B98(ctx, base);
	// 821B0498: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B049C: 480EBF55  bl 0x8229c3f0
	ctx.lr = 0x821B04A0;
	sub_8229C3F0(ctx, base);
	// 821B04A0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B04A4: 48124DAD  bl 0x822d5250
	ctx.lr = 0x821B04A8;
	sub_822D5250(ctx, base);
	// 821B04A8: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821B04AC: 92210094  stw r17, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[17].u32 ) };
	// 821B04B0: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821B04B4: 92210098  stw r17, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[17].u32 ) };
	// 821B04B8: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 821B04BC: 9221009C  stw r17, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[17].u32 ) };
	// 821B04C0: 3880001E  li r4, 0x1e
	ctx.r[4].s64 = 30;
	// 821B04C4: 81760258  lwz r11, 0x258(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B04C8: 80F6025C  lwz r7, 0x25c(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(604 as u32) ) } as u64;
	// 821B04CC: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 821B04D0: 9121007C  stw r9, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 821B04D4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 821B04D8: 814A6AB8  lwz r10, 0x6ab8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B04DC: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B04E0: 80680058  lwz r3, 0x58(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B04E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B04E8: 81CB0010  lwz r14, 0x10(r11)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B04EC: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 821B04F0: 91C10058  stw r14, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[14].u32 ) };
	// 821B04F4: 4802717D  bl 0x821d7670
	ctx.lr = 0x821B04F8;
	sub_821D7670(ctx, base);
	// 821B04F8: 80A10094  lwz r5, 0x94(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B04FC: 80C10098  lwz r6, 0x98(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0500: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B0504: 40990008  ble cr6, 0x821b050c
	if !ctx.cr[6].gt {
	pc = 0x821B050C; continue 'dispatch;
	}
	// 821B0508: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B050C; continue 'dispatch;
            }
            0x821B050C => {
    //   block [0x821B050C..0x821B0540)
	// 821B050C: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 821B0510: 80F06DA0  lwz r7, 0x6da0(r16)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B0514: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B0518: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B051C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B0520: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 821B0524: CBE411A8  lfd f31, 0x11a8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(4520 as u32) ) };
	// 821B0528: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B052C: 3DE08349  lis r15, -0x7cb7
	ctx.r[15].s64 = -2092367872;
	// 821B0530: 3B4B8B60  addi r26, r11, -0x74a0
	ctx.r[26].s64 = ctx.r[11].s64 + -29856;
	// 821B0534: 3B2A8B44  addi r25, r10, -0x74bc
	ctx.r[25].s64 = ctx.r[10].s64 + -29884;
	// 821B0538: 3A698B34  addi r19, r9, -0x74cc
	ctx.r[19].s64 = ctx.r[9].s64 + -29900;
	// 821B053C: 3AA8A1C4  addi r21, r8, -0x5e3c
	ctx.r[21].s64 = ctx.r[8].s64 + -24124;
	pc = 0x821B0540; continue 'dispatch;
            }
            0x821B0540 => {
    //   block [0x821B0540..0x821B054C)
	// 821B0540: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B0544: 40990008  ble cr6, 0x821b054c
	if !ctx.cr[6].gt {
	pc = 0x821B054C; continue 'dispatch;
	}
	// 821B0548: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B054C; continue 'dispatch;
            }
            0x821B054C => {
    //   block [0x821B054C..0x821B055C)
	// 821B054C: 7F1E3040  cmplw cr6, r30, r6
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B0550: 419A0270  beq cr6, 0x821b07c0
	if ctx.cr[6].eq {
	pc = 0x821B07C0; continue 'dispatch;
	}
	// 821B0554: 41980008  blt cr6, 0x821b055c
	if ctx.cr[6].lt {
	pc = 0x821B055C; continue 'dispatch;
	}
	// 821B0558: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B055C; continue 'dispatch;
            }
            0x821B055C => {
    //   block [0x821B055C..0x821B0590)
	// 821B055C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0560: 92210074  stw r17, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[17].u32 ) };
	// 821B0564: 836B001C  lwz r27, 0x1c(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B0568: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821B056C: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 821B0570: 419A0030  beq cr6, 0x821b05a0
	if ctx.cr[6].eq {
	pc = 0x821B05A0; continue 'dispatch;
	}
	// 821B0574: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B0578: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B057C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0580: 409A0010  bne cr6, 0x821b0590
	if !ctx.cr[6].eq {
	pc = 0x821B0590; continue 'dispatch;
	}
	// 821B0584: 816F6AC0  lwz r11, 0x6ac0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(27328 as u32) ) } as u64;
	// 821B0588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B058C: 419A0014  beq cr6, 0x821b05a0
	if ctx.cr[6].eq {
	pc = 0x821B05A0; continue 'dispatch;
	}
	pc = 0x821B0590; continue 'dispatch;
            }
            0x821B0590 => {
    //   block [0x821B0590..0x821B05A0)
	// 821B0590: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B0594: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821B0598: 48033CB9  bl 0x821e4250
	ctx.lr = 0x821B059C;
	sub_821E4250(ctx, base);
	// 821B059C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	pc = 0x821B05A0; continue 'dispatch;
            }
            0x821B05A0 => {
    //   block [0x821B05A0..0x821B05CC)
	// 821B05A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821B05A4: 48001F55  bl 0x821b24f8
	ctx.lr = 0x821B05A8;
	sub_821B24F8(ctx, base);
	// 821B05A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B05AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821B05B0: 419A01FC  beq cr6, 0x821b07ac
	if ctx.cr[6].eq {
	pc = 0x821B07AC; continue 'dispatch;
	}
	// 821B05B4: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 821B05B8: 4806ECA1  bl 0x8221f258
	ctx.lr = 0x821B05BC;
	sub_8221F258(ctx, base);
	// 821B05BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B05C0: 419A000C  beq cr6, 0x821b05cc
	if ctx.cr[6].eq {
	pc = 0x821B05CC; continue 'dispatch;
	}
	// 821B05C4: 484697C5  bl 0x82619d88
	ctx.lr = 0x821B05C8;
	sub_82619D88(ctx, base);
	// 821B05C8: 48000008  b 0x821b05d0
	pc = 0x821B05D0; continue 'dispatch;
            }
            0x821B05CC => {
    //   block [0x821B05CC..0x821B05D0)
	// 821B05CC: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	pc = 0x821B05D0; continue 'dispatch;
            }
            0x821B05D0 => {
    //   block [0x821B05D0..0x821B05F0)
	// 821B05D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B05D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B05D8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 821B05DC: 419A0014  beq cr6, 0x821b05f0
	if ctx.cr[6].eq {
	pc = 0x821B05F0; continue 'dispatch;
	}
	// 821B05E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B05E4: 4846D49D  bl 0x8261da80
	ctx.lr = 0x821B05E8;
	sub_8261DA80(ctx, base);
	// 821B05E8: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821B05EC: 48000008  b 0x821b05f4
	pc = 0x821B05F4; continue 'dispatch;
            }
            0x821B05F0 => {
    //   block [0x821B05F0..0x821B05F4)
	// 821B05F0: 92210064  stw r17, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[17].u32 ) };
	pc = 0x821B05F4; continue 'dispatch;
            }
            0x821B05F4 => {
    //   block [0x821B05F4..0x821B0650)
	// 821B05F4: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 821B05F8: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B05FC: 3B9F0010  addi r28, r31, 0x10
	ctx.r[28].s64 = ctx.r[31].s64 + 16;
	// 821B0600: 48043759  bl 0x821f3d58
	ctx.lr = 0x821B0604;
	sub_821F3D58(ctx, base);
	// 821B0604: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0608: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B060C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821B0610: 482001A9  bl 0x823b07b8
	ctx.lr = 0x821B0614;
	sub_823B07B8(ctx, base);
	// 821B0614: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B0618: 3B9F0038  addi r28, r31, 0x38
	ctx.r[28].s64 = ctx.r[31].s64 + 56;
	// 821B061C: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 821B0620: FC0007F2  fmul f0, f0, f31
	ctx.f[0].f64 = ctx.f[0].f64 * ctx.f[31].f64;
	// 821B0624: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821B0628: D9A10080  stfd f13, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.f[13].u64 ) };
	// 821B062C: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B0630: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B0634: 81760258  lwz r11, 0x258(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B0638: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821B063C: 913F0018  stw r9, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 821B0640: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0644: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0648: 41980008  blt cr6, 0x821b0650
	if ctx.cr[6].lt {
	pc = 0x821B0650; continue 'dispatch;
	}
	// 821B064C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0650; continue 'dispatch;
            }
            0x821B0650 => {
    //   block [0x821B0650..0x821B0674)
	// 821B0650: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0654: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B0658: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B065C: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B0660: 913C0004  stw r9, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B0664: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0668: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B066C: 41980008  blt cr6, 0x821b0674
	if ctx.cr[6].lt {
	pc = 0x821B0674; continue 'dispatch;
	}
	// 821B0670: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0674; continue 'dispatch;
            }
            0x821B0674 => {
    //   block [0x821B0674..0x821B0698)
	// 821B0674: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0678: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B067C: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821B0680: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B0684: 913F0044  stw r9, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[9].u32 ) };
	// 821B0688: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B068C: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0690: 41980008  blt cr6, 0x821b0698
	if ctx.cr[6].lt {
	pc = 0x821B0698; continue 'dispatch;
	}
	// 821B0694: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0698; continue 'dispatch;
            }
            0x821B0698 => {
    //   block [0x821B0698..0x821B06B8)
	// 821B0698: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B069C: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 821B06A0: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 821B06A4: 48321825  bl 0x824d1ec8
	ctx.lr = 0x821B06A8;
	sub_824D1EC8(ctx, base);
	// 821B06A8: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B06AC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B06B0: 41980008  blt cr6, 0x821b06b8
	if ctx.cr[6].lt {
	pc = 0x821B06B8; continue 'dispatch;
	}
	// 821B06B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B06B8; continue 'dispatch;
            }
            0x821B06B8 => {
    //   block [0x821B06B8..0x821B0708)
	// 821B06B8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B06BC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 821B06C0: 388B003C  addi r4, r11, 0x3c
	ctx.r[4].s64 = ctx.r[11].s64 + 60;
	// 821B06C4: 48321805  bl 0x824d1ec8
	ctx.lr = 0x821B06C8;
	sub_824D1EC8(ctx, base);
	// 821B06C8: 923F0034  stw r17, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[17].u32 ) };
	// 821B06CC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821B06D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B06D4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B06D8: 4846B799  bl 0x8261be70
	ctx.lr = 0x821B06DC;
	sub_8261BE70(ctx, base);
	// 821B06DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B06E0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 821B06E4: 48029C65  bl 0x821da348
	ctx.lr = 0x821B06E8;
	sub_821DA348(ctx, base);
	// 821B06E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B06EC: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 821B06F0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B06F4: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 821B06F8: 81210098  lwz r9, 0x98(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B06FC: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B0700: 41980008  blt cr6, 0x821b0708
	if ctx.cr[6].lt {
	pc = 0x821B0708; continue 'dispatch;
	}
	// 821B0704: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0708; continue 'dispatch;
            }
            0x821B0708 => {
    //   block [0x821B0708..0x821B0744)
	// 821B0708: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B070C: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 821B0710: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 821B0714: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B0718: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B071C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 821B0720: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B0724: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 821B0728: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B072C: 911F0030  stw r8, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[8].u32 ) };
	// 821B0730: 481FCD39  bl 0x823ad468
	ctx.lr = 0x821B0734;
	sub_823AD468(ctx, base);
	// 821B0734: 80E10098  lwz r7, 0x98(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0738: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821B073C: 41980008  blt cr6, 0x821b0744
	if ctx.cr[6].lt {
	pc = 0x821B0744; continue 'dispatch;
	}
	// 821B0740: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0744; continue 'dispatch;
            }
            0x821B0744 => {
    //   block [0x821B0744..0x821B07AC)
	// 821B0744: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0748: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821B074C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B0750: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B0754: 80AB0018  lwz r5, 0x18(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B0758: 4846B429  bl 0x8261bb80
	ctx.lr = 0x821B075C;
	sub_8261BB80(ctx, base);
	// 821B075C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821B0760: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B0764: 4BFE641D  bl 0x82196b80
	ctx.lr = 0x821B0768;
	sub_82196B80(ctx, base);
	// 821B0768: D03F005C  stfs f1, 0x5c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821B076C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821B0770: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B0774: 4BFE640D  bl 0x82196b80
	ctx.lr = 0x821B0778;
	sub_82196B80(ctx, base);
	// 821B0778: D03F0060  stfs f1, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821B077C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821B0780: 92C10078  stw r22, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[22].u32 ) };
	// 821B0784: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B0788: 81560004  lwz r10, 4(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B078C: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 821B0790: E8810078  ld r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 821B0794: 4846D355  bl 0x8261dae8
	ctx.lr = 0x821B0798;
	sub_8261DAE8(ctx, base);
	// 821B0798: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B079C: 4800737D  bl 0x821b7b18
	ctx.lr = 0x821B07A0;
	sub_821B7B18(ctx, base);
	// 821B07A0: 80C10098  lwz r6, 0x98(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B07A4: 80A10094  lwz r5, 0x94(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B07A8: 80F06DA0  lwz r7, 0x6da0(r16)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	pc = 0x821B07AC; continue 'dispatch;
            }
            0x821B07AC => {
    //   block [0x821B07AC..0x821B07B8)
	// 821B07AC: 7F1E3040  cmplw cr6, r30, r6
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B07B0: 41980008  blt cr6, 0x821b07b8
	if ctx.cr[6].lt {
	pc = 0x821B07B8; continue 'dispatch;
	}
	// 821B07B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B07B8; continue 'dispatch;
            }
            0x821B07B8 => {
    //   block [0x821B07B8..0x821B07C0)
	// 821B07B8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B07BC: 4BFFFD84  b 0x821b0540
	pc = 0x821B0540; continue 'dispatch;
            }
            0x821B07C0 => {
    //   block [0x821B07C0..0x821B0804)
	// 821B07C0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821B07C4: 480013E5  bl 0x821b1ba8
	ctx.lr = 0x821B07C8;
	sub_821B1BA8(ctx, base);
	// 821B07C8: 81760258  lwz r11, 0x258(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B07CC: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821B07D0: 80F6025C  lwz r7, 0x25c(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(604 as u32) ) } as u64;
	// 821B07D4: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821B07D8: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 821B07DC: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 821B07E0: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 821B07E4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 821B07E8: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 821B07EC: 48026E85  bl 0x821d7670
	ctx.lr = 0x821B07F0;
	sub_821D7670(ctx, base);
	// 821B07F0: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B07F4: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B07F8: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B07FC: 40990008  ble cr6, 0x821b0804
	if !ctx.cr[6].gt {
	pc = 0x821B0804; continue 'dispatch;
	}
	// 821B0800: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0804; continue 'dispatch;
            }
            0x821B0804 => {
    //   block [0x821B0804..0x821B0828)
	// 821B0804: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B0808: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821B080C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B0810: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 821B0814: 3E408349  lis r18, -0x7cb7
	ctx.r[18].s64 = -2092367872;
	// 821B0818: 3B2B8B90  addi r25, r11, -0x7470
	ctx.r[25].s64 = ctx.r[11].s64 + -29808;
	// 821B081C: 3B0A8E7C  addi r24, r10, -0x7184
	ctx.r[24].s64 = ctx.r[10].s64 + -29060;
	// 821B0820: 3B498B80  addi r26, r9, -0x7480
	ctx.r[26].s64 = ctx.r[9].s64 + -29824;
	// 821B0824: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	pc = 0x821B0828; continue 'dispatch;
            }
            0x821B0828 => {
    //   block [0x821B0828..0x821B0834)
	// 821B0828: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B082C: 40990008  ble cr6, 0x821b0834
	if !ctx.cr[6].gt {
	pc = 0x821B0834; continue 'dispatch;
	}
	// 821B0830: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0834; continue 'dispatch;
            }
            0x821B0834 => {
    //   block [0x821B0834..0x821B0874)
	// 821B0834: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0838: 419A0314  beq cr6, 0x821b0b4c
	if ctx.cr[6].eq {
	pc = 0x821B0B4C; continue 'dispatch;
	}
	// 821B083C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B0840: 83706DA0  lwz r27, 0x6da0(r16)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B0844: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0848: 48043511  bl 0x821f3d58
	ctx.lr = 0x821B084C;
	sub_821F3D58(ctx, base);
	// 821B084C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0850: 5763003E  slwi r3, r27, 0
	ctx.r[3].u32 = ctx.r[27].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821B0854: 4884F605  bl 0x829ffe58
	ctx.lr = 0x821B0858;
	sub_829FFE58(ctx, base);
	// 821B0858: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B085C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821B0860: 419A02D0  beq cr6, 0x821b0b30
	if ctx.cr[6].eq {
	pc = 0x821B0B30; continue 'dispatch;
	}
	// 821B0864: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0868: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B086C: 41980008  blt cr6, 0x821b0874
	if ctx.cr[6].lt {
	pc = 0x821B0874; continue 'dispatch;
	}
	// 821B0870: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0874; continue 'dispatch;
            }
            0x821B0874 => {
    //   block [0x821B0874..0x821B08BC)
	// 821B0874: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B0878: 814B6AB8  lwz r10, 0x6ab8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B087C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0880: 388B0024  addi r4, r11, 0x24
	ctx.r[4].s64 = ctx.r[11].s64 + 36;
	// 821B0884: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B0888: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B088C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0890: 83C70000  lwz r30, 0(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0894: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B0898: 480B3BF1  bl 0x82264488
	ctx.lr = 0x821B089C;
	sub_82264488(ctx, base);
	// 821B089C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B08A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B08A4: 419A0018  beq cr6, 0x821b08bc
	if ctx.cr[6].eq {
	pc = 0x821B08BC; continue 'dispatch;
	}
	// 821B08A8: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B08AC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B08B0: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821B08B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B08B8: 409A0008  bne cr6, 0x821b08c0
	if !ctx.cr[6].eq {
	pc = 0x821B08C0; continue 'dispatch;
	}
	pc = 0x821B08BC; continue 'dispatch;
            }
            0x821B08BC => {
    //   block [0x821B08BC..0x821B08C0)
	// 821B08BC: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	pc = 0x821B08C0; continue 'dispatch;
            }
            0x821B08C0 => {
    //   block [0x821B08C0..0x821B08EC)
	// 821B08C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B08C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B08C8: 419A0030  beq cr6, 0x821b08f8
	if ctx.cr[6].eq {
	pc = 0x821B08F8; continue 'dispatch;
	}
	// 821B08CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B08D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B08D4: 48081EA5  bl 0x82232778
	ctx.lr = 0x821B08D8;
	sub_82232778(ctx, base);
	// 821B08D8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B08DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B08E0: 419A000C  beq cr6, 0x821b08ec
	if ctx.cr[6].eq {
	pc = 0x821B08EC; continue 'dispatch;
	}
	// 821B08E4: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821B08E8: 48000014  b 0x821b08fc
	pc = 0x821B08FC; continue 'dispatch;
            }
            0x821B08EC => {
    //   block [0x821B08EC..0x821B08F8)
	// 821B08EC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B08F0: 556BFFFE  rlwinm r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821B08F4: 48000008  b 0x821b08fc
	pc = 0x821B08FC; continue 'dispatch;
            }
            0x821B08F8 => {
    //   block [0x821B08F8..0x821B08FC)
	// 821B08F8: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	pc = 0x821B08FC; continue 'dispatch;
            }
            0x821B08FC => {
    //   block [0x821B08FC..0x821B0934)
	// 821B08FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B0900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0904: 419A022C  beq cr6, 0x821b0b30
	if ctx.cr[6].eq {
	pc = 0x821B0B30; continue 'dispatch;
	}
	// 821B0908: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 821B090C: 4806E9B5  bl 0x8221f2c0
	ctx.lr = 0x821B0910;
	sub_8221F2C0(ctx, base);
	// 821B0910: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B0914: 409A0048  bne cr6, 0x821b095c
	if !ctx.cr[6].eq {
	pc = 0x821B095C; continue 'dispatch;
	}
	// 821B0918: 81726F6C  lwz r11, 0x6f6c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28524 as u32) ) } as u64;
	// 821B091C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0920: 419A0014  beq cr6, 0x821b0934
	if ctx.cr[6].eq {
	pc = 0x821B0934; continue 'dispatch;
	}
	// 821B0924: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B0928: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B092C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B0930: 4E800421  bctrl
	ctx.lr = 0x821B0934;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821B0934 => {
    //   block [0x821B0934..0x821B093C)
	// 821B0934: 48B11A75  bl 0x82cc23a8
	ctx.lr = 0x821B0938;
	sub_82CC23A8(ctx, base);
	// 821B0938: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	pc = 0x821B093C; continue 'dispatch;
            }
            0x821B093C => {
    //   block [0x821B093C..0x821B095C)
	// 821B093C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B0940: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B0944: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 821B0948: 419A001C  beq cr6, 0x821b0964
	if ctx.cr[6].eq {
	pc = 0x821B0964; continue 'dispatch;
	}
	// 821B094C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B0950: 4846D131  bl 0x8261da80
	ctx.lr = 0x821B0954;
	sub_8261DA80(ctx, base);
	// 821B0954: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821B0958: 48000010  b 0x821b0968
	pc = 0x821B0968; continue 'dispatch;
            }
            0x821B095C => {
    //   block [0x821B095C..0x821B0964)
	// 821B095C: 4846942D  bl 0x82619d88
	ctx.lr = 0x821B0960;
	sub_82619D88(ctx, base);
	// 821B0960: 4BFFFFDC  b 0x821b093c
	pc = 0x821B093C; continue 'dispatch;
            }
            0x821B0964 => {
    //   block [0x821B0964..0x821B0968)
	// 821B0964: 92210064  stw r17, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[17].u32 ) };
	pc = 0x821B0968; continue 'dispatch;
            }
            0x821B0968 => {
    //   block [0x821B0968..0x821B09AC)
	// 821B0968: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821B096C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0970: 480433E9  bl 0x821f3d58
	ctx.lr = 0x821B0974;
	sub_821F3D58(ctx, base);
	// 821B0974: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0978: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B097C: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 821B0980: 4884FD49  bl 0x82a006c8
	ctx.lr = 0x821B0984;
	sub_82A006C8(ctx, base);
	// 821B0984: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B0988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B098C: 419A0020  beq cr6, 0x821b09ac
	if ctx.cr[6].eq {
	pc = 0x821B09AC; continue 'dispatch;
	}
	// 821B0990: 80706DA0  lwz r3, 0x6da0(r16)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B0994: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0998: 480338B9  bl 0x821e4250
	ctx.lr = 0x821B099C;
	sub_821E4250(ctx, base);
	// 821B099C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B09A0: 419A000C  beq cr6, 0x821b09ac
	if ctx.cr[6].eq {
	pc = 0x821B09AC; continue 'dispatch;
	}
	// 821B09A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B09A8: 4803E689  bl 0x821ef030
	ctx.lr = 0x821B09AC;
	sub_821EF030(ctx, base);
	pc = 0x821B09AC; continue 'dispatch;
            }
            0x821B09AC => {
    //   block [0x821B09AC..0x821B09D4)
	// 821B09AC: 81760258  lwz r11, 0x258(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B09B0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821B09B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B09B8: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821B09BC: 4820EE65  bl 0x823bf820
	ctx.lr = 0x821B09C0;
	sub_823BF820(ctx, base);
	// 821B09C0: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 821B09C4: 81410098  lwz r10, 0x98(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B09C8: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B09CC: 41980008  blt cr6, 0x821b09d4
	if ctx.cr[6].lt {
	pc = 0x821B09D4; continue 'dispatch;
	}
	// 821B09D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B09D4; continue 'dispatch;
            }
            0x821B09D4 => {
    //   block [0x821B09D4..0x821B09F8)
	// 821B09D4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B09D8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B09DC: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 821B09E0: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B09E4: 913F003C  stw r9, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 821B09E8: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B09EC: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B09F0: 41980008  blt cr6, 0x821b09f8
	if ctx.cr[6].lt {
	pc = 0x821B09F8; continue 'dispatch;
	}
	// 821B09F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B09F8; continue 'dispatch;
            }
            0x821B09F8 => {
    //   block [0x821B09F8..0x821B0A1C)
	// 821B09F8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B09FC: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B0A00: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821B0A04: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B0A08: 913F0044  stw r9, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[9].u32 ) };
	// 821B0A0C: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0A10: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0A14: 41980008  blt cr6, 0x821b0a1c
	if ctx.cr[6].lt {
	pc = 0x821B0A1C; continue 'dispatch;
	}
	// 821B0A18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0A1C; continue 'dispatch;
            }
            0x821B0A1C => {
    //   block [0x821B0A1C..0x821B0A48)
	// 821B0A1C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0A20: 3BDF0048  addi r30, r31, 0x48
	ctx.r[30].s64 = ctx.r[31].s64 + 72;
	// 821B0A24: 386B0034  addi r3, r11, 0x34
	ctx.r[3].s64 = ctx.r[11].s64 + 52;
	// 821B0A28: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B0A2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0A30: 419A001C  beq cr6, 0x821b0a4c
	if ctx.cr[6].eq {
	pc = 0x821B0A4C; continue 'dispatch;
	}
	// 821B0A34: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0A38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B0A3C: 419A000C  beq cr6, 0x821b0a48
	if ctx.cr[6].eq {
	pc = 0x821B0A48; continue 'dispatch;
	}
	// 821B0A40: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821B0A44: 4800000C  b 0x821b0a50
	pc = 0x821B0A50; continue 'dispatch;
            }
            0x821B0A48 => {
    //   block [0x821B0A48..0x821B0A4C)
	// 821B0A48: 4BFE33F1  bl 0x82193e38
	ctx.lr = 0x821B0A4C;
	sub_82193E38(ctx, base);
	pc = 0x821B0A4C; continue 'dispatch;
            }
            0x821B0A4C => {
    //   block [0x821B0A4C..0x821B0A50)
	// 821B0A4C: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	pc = 0x821B0A50; continue 'dispatch;
            }
            0x821B0A50 => {
    //   block [0x821B0A50..0x821B0A68)
	// 821B0A50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B0A54: 48063E45  bl 0x82214898
	ctx.lr = 0x821B0A58;
	sub_82214898(ctx, base);
	// 821B0A58: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0A5C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B0A60: 41980008  blt cr6, 0x821b0a68
	if ctx.cr[6].lt {
	pc = 0x821B0A68; continue 'dispatch;
	}
	// 821B0A64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0A68; continue 'dispatch;
            }
            0x821B0A68 => {
    //   block [0x821B0A68..0x821B0A94)
	// 821B0A68: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0A6C: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 821B0A70: 386B003C  addi r3, r11, 0x3c
	ctx.r[3].s64 = ctx.r[11].s64 + 60;
	// 821B0A74: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B0A78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0A7C: 419A001C  beq cr6, 0x821b0a98
	if ctx.cr[6].eq {
	pc = 0x821B0A98; continue 'dispatch;
	}
	// 821B0A80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0A84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B0A88: 419A000C  beq cr6, 0x821b0a94
	if ctx.cr[6].eq {
	pc = 0x821B0A94; continue 'dispatch;
	}
	// 821B0A8C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821B0A90: 4800000C  b 0x821b0a9c
	pc = 0x821B0A9C; continue 'dispatch;
            }
            0x821B0A94 => {
    //   block [0x821B0A94..0x821B0A98)
	// 821B0A94: 4BFE33A5  bl 0x82193e38
	ctx.lr = 0x821B0A98;
	sub_82193E38(ctx, base);
	pc = 0x821B0A98; continue 'dispatch;
            }
            0x821B0A98 => {
    //   block [0x821B0A98..0x821B0A9C)
	// 821B0A98: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	pc = 0x821B0A9C; continue 'dispatch;
            }
            0x821B0A9C => {
    //   block [0x821B0A9C..0x821B0AF0)
	// 821B0A9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B0AA0: 48063DF9  bl 0x82214898
	ctx.lr = 0x821B0AA4;
	sub_82214898(ctx, base);
	// 821B0AA4: 92FF0034  stw r23, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[23].u32 ) };
	// 821B0AA8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B0AAC: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0AB0: 480432A9  bl 0x821f3d58
	ctx.lr = 0x821B0AB4;
	sub_821F3D58(ctx, base);
	// 821B0AB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0AB8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821B0ABC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B0AC0: 4811CA09  bl 0x822cd4c8
	ctx.lr = 0x821B0AC4;
	sub_822CD4C8(ctx, base);
	// 821B0AC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0AC8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 821B0ACC: 4802987D  bl 0x821da348
	ctx.lr = 0x821B0AD0;
	sub_821DA348(ctx, base);
	// 821B0AD0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0AD4: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 821B0AD8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0ADC: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 821B0AE0: 81210098  lwz r9, 0x98(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0AE4: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B0AE8: 41980008  blt cr6, 0x821b0af0
	if ctx.cr[6].lt {
	pc = 0x821B0AF0; continue 'dispatch;
	}
	// 821B0AEC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0AF0; continue 'dispatch;
            }
            0x821B0AF0 => {
    //   block [0x821B0AF0..0x821B0B30)
	// 821B0AF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0AF4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821B0AF8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B0AFC: 92C10078  stw r22, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[22].u32 ) };
	// 821B0B00: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B0B04: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 821B0B08: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B0B0C: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 821B0B10: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B0B14: 911F0030  stw r8, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[8].u32 ) };
	// 821B0B18: 80F60004  lwz r7, 4(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0B1C: 90E1007C  stw r7, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 821B0B20: E8810078  ld r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 821B0B24: 4846CFC5  bl 0x8261dae8
	ctx.lr = 0x821B0B28;
	sub_8261DAE8(ctx, base);
	// 821B0B28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B0B2C: 48006FED  bl 0x821b7b18
	ctx.lr = 0x821B0B30;
	sub_821B7B18(ctx, base);
	pc = 0x821B0B30; continue 'dispatch;
            }
            0x821B0B30 => {
    //   block [0x821B0B30..0x821B0B40)
	// 821B0B30: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0B34: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0B38: 41980008  blt cr6, 0x821b0b40
	if ctx.cr[6].lt {
	pc = 0x821B0B40; continue 'dispatch;
	}
	// 821B0B3C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0B40; continue 'dispatch;
            }
            0x821B0B40 => {
    //   block [0x821B0B40..0x821B0B4C)
	// 821B0B40: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B0B44: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821B0B48: 4BFFFCE0  b 0x821b0828
	pc = 0x821B0828; continue 'dispatch;
            }
            0x821B0B4C => {
    //   block [0x821B0B4C..0x821B0B60)
	// 821B0B4C: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0B50: 40990010  ble cr6, 0x821b0b60
	if !ctx.cr[6].gt {
	pc = 0x821B0B60; continue 'dispatch;
	}
	// 821B0B54: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0B58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0B5C: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	pc = 0x821B0B60; continue 'dispatch;
            }
            0x821B0B60 => {
    //   block [0x821B0B60..0x821B0B68)
	// 821B0B60: 419A0008  beq cr6, 0x821b0b68
	if ctx.cr[6].eq {
	pc = 0x821B0B68; continue 'dispatch;
	}
	// 821B0B64: 90E10098  stw r7, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[7].u32 ) };
	pc = 0x821B0B68; continue 'dispatch;
            }
            0x821B0B68 => {
    //   block [0x821B0B68..0x821B0BA4)
	// 821B0B68: 81760258  lwz r11, 0x258(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B0B6C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821B0B70: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 821B0B74: 80F6025C  lwz r7, 0x25c(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(604 as u32) ) } as u64;
	// 821B0B78: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821B0B7C: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 821B0B80: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 821B0B84: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 821B0B88: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 821B0B8C: 48026AE5  bl 0x821d7670
	ctx.lr = 0x821B0B90;
	sub_821D7670(ctx, base);
	// 821B0B90: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B0B94: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0B98: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0B9C: 40990008  ble cr6, 0x821b0ba4
	if !ctx.cr[6].gt {
	pc = 0x821B0BA4; continue 'dispatch;
	}
	// 821B0BA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0BA4; continue 'dispatch;
            }
            0x821B0BA4 => {
    //   block [0x821B0BA4..0x821B0BC8)
	// 821B0BA4: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821B0BA8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 821B0BAC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821B0BB0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 821B0BB4: 3B200003  li r25, 3
	ctx.r[25].s64 = 3;
	// 821B0BB8: 3F40834A  lis r26, -0x7cb6
	ctx.r[26].s64 = -2092302336;
	// 821B0BBC: 3B09E460  addi r24, r9, -0x1ba0
	ctx.r[24].s64 = ctx.r[9].s64 + -7072;
	// 821B0BC0: 3B6AF0FC  addi r27, r10, -0xf04
	ctx.r[27].s64 = ctx.r[10].s64 + -3844;
	// 821B0BC4: 3AEBF11C  addi r23, r11, -0xee4
	ctx.r[23].s64 = ctx.r[11].s64 + -3812;
	pc = 0x821B0BC8; continue 'dispatch;
            }
            0x821B0BC8 => {
    //   block [0x821B0BC8..0x821B0BD4)
	// 821B0BC8: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0BCC: 40990008  ble cr6, 0x821b0bd4
	if !ctx.cr[6].gt {
	pc = 0x821B0BD4; continue 'dispatch;
	}
	// 821B0BD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0BD4; continue 'dispatch;
            }
            0x821B0BD4 => {
    //   block [0x821B0BD4..0x821B0BE4)
	// 821B0BD4: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0BD8: 419A03F8  beq cr6, 0x821b0fd0
	if ctx.cr[6].eq {
	pc = 0x821B0FD0; continue 'dispatch;
	}
	// 821B0BDC: 41980008  blt cr6, 0x821b0be4
	if ctx.cr[6].lt {
	pc = 0x821B0BE4; continue 'dispatch;
	}
	// 821B0BE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0BE4; continue 'dispatch;
            }
            0x821B0BE4 => {
    //   block [0x821B0BE4..0x821B0C18)
	// 821B0BE4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0BE8: 9221006C  stw r17, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[17].u32 ) };
	// 821B0BEC: 838B001C  lwz r28, 0x1c(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B0BF0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821B0BF4: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 821B0BF8: 419A03C4  beq cr6, 0x821b0fbc
	if ctx.cr[6].eq {
	pc = 0x821B0FBC; continue 'dispatch;
	}
	// 821B0BFC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B0C00: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B0C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0C08: 409A0010  bne cr6, 0x821b0c18
	if !ctx.cr[6].eq {
	pc = 0x821B0C18; continue 'dispatch;
	}
	// 821B0C0C: 816F6AC0  lwz r11, 0x6ac0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(27328 as u32) ) } as u64;
	// 821B0C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0C14: 419A0014  beq cr6, 0x821b0c28
	if ctx.cr[6].eq {
	pc = 0x821B0C28; continue 'dispatch;
	}
	pc = 0x821B0C18; continue 'dispatch;
            }
            0x821B0C18 => {
    //   block [0x821B0C18..0x821B0C28)
	// 821B0C18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B0C1C: 80706DA0  lwz r3, 0x6da0(r16)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B0C20: 48033631  bl 0x821e4250
	ctx.lr = 0x821B0C24;
	sub_821E4250(ctx, base);
	// 821B0C24: 9061006C  stw r3, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[3].u32 ) };
	pc = 0x821B0C28; continue 'dispatch;
            }
            0x821B0C28 => {
    //   block [0x821B0C28..0x821B0C54)
	// 821B0C28: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 821B0C2C: 4806E695  bl 0x8221f2c0
	ctx.lr = 0x821B0C30;
	sub_8221F2C0(ctx, base);
	// 821B0C30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B0C34: 409A01A8  bne cr6, 0x821b0ddc
	if !ctx.cr[6].eq {
	pc = 0x821B0DDC; continue 'dispatch;
	}
	// 821B0C38: 81726F6C  lwz r11, 0x6f6c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28524 as u32) ) } as u64;
	// 821B0C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0C40: 419A0014  beq cr6, 0x821b0c54
	if ctx.cr[6].eq {
	pc = 0x821B0C54; continue 'dispatch;
	}
	// 821B0C44: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B0C48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B0C4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B0C50: 4E800421  bctrl
	ctx.lr = 0x821B0C54;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821B0C54 => {
    //   block [0x821B0C54..0x821B0C5C)
	// 821B0C54: 48B11755  bl 0x82cc23a8
	ctx.lr = 0x821B0C58;
	sub_82CC23A8(ctx, base);
	// 821B0C58: 7E3E8B78  mr r30, r17
	ctx.r[30].u64 = ctx.r[17].u64;
	pc = 0x821B0C5C; continue 'dispatch;
            }
            0x821B0C5C => {
    //   block [0x821B0C5C..0x821B0C94)
	// 821B0C5C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 821B0C60: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B0C64: 419A0034  beq cr6, 0x821b0c98
	if ctx.cr[6].eq {
	pc = 0x821B0C98; continue 'dispatch;
	}
	// 821B0C68: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 821B0C6C: 4806E655  bl 0x8221f2c0
	ctx.lr = 0x821B0C70;
	sub_8221F2C0(ctx, base);
	// 821B0C70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B0C74: 409A0174  bne cr6, 0x821b0de8
	if !ctx.cr[6].eq {
	pc = 0x821B0DE8; continue 'dispatch;
	}
	// 821B0C78: 81726F6C  lwz r11, 0x6f6c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28524 as u32) ) } as u64;
	// 821B0C7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0C80: 419A0014  beq cr6, 0x821b0c94
	if ctx.cr[6].eq {
	pc = 0x821B0C94; continue 'dispatch;
	}
	// 821B0C84: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B0C88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B0C8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B0C90: 4E800421  bctrl
	ctx.lr = 0x821B0C94;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821B0C94 => {
    //   block [0x821B0C94..0x821B0C98)
	// 821B0C94: 48B11715  bl 0x82cc23a8
	ctx.lr = 0x821B0C98;
	sub_82CC23A8(ctx, base);
	pc = 0x821B0C98; continue 'dispatch;
            }
            0x821B0C98 => {
    //   block [0x821B0C98..0x821B0C9C)
	// 821B0C98: 92210074  stw r17, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[17].u32 ) };
	pc = 0x821B0C9C; continue 'dispatch;
            }
            0x821B0C9C => {
    //   block [0x821B0C9C..0x821B0CF8)
	// 821B0C9C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 821B0CA0: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0CA4: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821B0CA8: 480430B1  bl 0x821f3d58
	ctx.lr = 0x821B0CAC;
	sub_821F3D58(ctx, base);
	// 821B0CAC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821B0CB0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821B0CB4: 48001845  bl 0x821b24f8
	ctx.lr = 0x821B0CB8;
	sub_821B24F8(ctx, base);
	// 821B0CB8: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 821B0CBC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B0CC0: 48034D49  bl 0x821e5a08
	ctx.lr = 0x821B0CC4;
	sub_821E5A08(ctx, base);
	// 821B0CC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B0CC8: 419A02E4  beq cr6, 0x821b0fac
	if ctx.cr[6].eq {
	pc = 0x821B0FAC; continue 'dispatch;
	}
	// 821B0CCC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B0CD0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821B0CD4: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821B0CD8: 419A0020  beq cr6, 0x821b0cf8
	if ctx.cr[6].eq {
	pc = 0x821B0CF8; continue 'dispatch;
	}
	// 821B0CDC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B0CE0: 409A0018  bne cr6, 0x821b0cf8
	if !ctx.cr[6].eq {
	pc = 0x821B0CF8; continue 'dispatch;
	}
	// 821B0CE4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0CE8: 817AE454  lwz r11, -0x1bac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 821B0CEC: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B0CF0: 409A0008  bne cr6, 0x821b0cf8
	if !ctx.cr[6].eq {
	pc = 0x821B0CF8; continue 'dispatch;
	}
	// 821B0CF4: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	pc = 0x821B0CF8; continue 'dispatch;
            }
            0x821B0CF8 => {
    //   block [0x821B0CF8..0x821B0D68)
	// 821B0CF8: 80706DA0  lwz r3, 0x6da0(r16)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B0CFC: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0D00: 48033551  bl 0x821e4250
	ctx.lr = 0x821B0D04;
	sub_821E4250(ctx, base);
	// 821B0D04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B0D08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B0D0C: 419A02A0  beq cr6, 0x821b0fac
	if ctx.cr[6].eq {
	pc = 0x821B0FAC; continue 'dispatch;
	}
	// 821B0D10: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 821B0D14: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0D18: 39DE0010  addi r14, r30, 0x10
	ctx.r[14].s64 = ctx.r[30].s64 + 16;
	// 821B0D1C: 4804303D  bl 0x821f3d58
	ctx.lr = 0x821B0D20;
	sub_821F3D58(ctx, base);
	// 821B0D20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B0D28: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 821B0D2C: 481FFA8D  bl 0x823b07b8
	ctx.lr = 0x821B0D30;
	sub_823B07B8(ctx, base);
	// 821B0D30: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B0D34: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 821B0D38: FC0007F2  fmul f0, f0, f31
	ctx.f[0].f64 = ctx.f[0].f64 * ctx.f[31].f64;
	// 821B0D3C: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821B0D40: D9A10088  stfd f13, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.f[13].u64 ) };
	// 821B0D44: 81760258  lwz r11, 0x258(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B0D48: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821B0D4C: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B0D50: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B0D54: 913E0018  stw r9, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 821B0D58: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0D5C: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0D60: 41980008  blt cr6, 0x821b0d68
	if ctx.cr[6].lt {
	pc = 0x821B0D68; continue 'dispatch;
	}
	// 821B0D64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0D68; continue 'dispatch;
            }
            0x821B0D68 => {
    //   block [0x821B0D68..0x821B0D8C)
	// 821B0D68: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0D6C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B0D70: 915E0038  stw r10, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 821B0D74: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B0D78: 913E003C  stw r9, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 821B0D7C: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0D80: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0D84: 41980008  blt cr6, 0x821b0d8c
	if ctx.cr[6].lt {
	pc = 0x821B0D8C; continue 'dispatch;
	}
	// 821B0D88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0D8C; continue 'dispatch;
            }
            0x821B0D8C => {
    //   block [0x821B0D8C..0x821B0DB0)
	// 821B0D8C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0D90: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B0D94: 915E0040  stw r10, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821B0D98: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B0D9C: 913E0044  stw r9, 0x44(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(68 as u32), ctx.r[9].u32 ) };
	// 821B0DA0: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0DA4: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0DA8: 41980008  blt cr6, 0x821b0db0
	if ctx.cr[6].lt {
	pc = 0x821B0DB0; continue 'dispatch;
	}
	// 821B0DAC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0DB0; continue 'dispatch;
            }
            0x821B0DB0 => {
    //   block [0x821B0DB0..0x821B0DDC)
	// 821B0DB0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0DB4: 3BFE0048  addi r31, r30, 0x48
	ctx.r[31].s64 = ctx.r[30].s64 + 72;
	// 821B0DB8: 386B0034  addi r3, r11, 0x34
	ctx.r[3].s64 = ctx.r[11].s64 + 52;
	// 821B0DBC: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B0DC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0DC4: 419A0048  beq cr6, 0x821b0e0c
	if ctx.cr[6].eq {
	pc = 0x821B0E0C; continue 'dispatch;
	}
	// 821B0DC8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0DCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B0DD0: 419A0038  beq cr6, 0x821b0e08
	if ctx.cr[6].eq {
	pc = 0x821B0E08; continue 'dispatch;
	}
	// 821B0DD4: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821B0DD8: 48000038  b 0x821b0e10
	pc = 0x821B0E10; continue 'dispatch;
            }
            0x821B0DDC => {
    //   block [0x821B0DDC..0x821B0DE8)
	// 821B0DDC: 48468FAD  bl 0x82619d88
	ctx.lr = 0x821B0DE0;
	sub_82619D88(ctx, base);
	// 821B0DE0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B0DE4: 4BFFFE78  b 0x821b0c5c
	pc = 0x821B0C5C; continue 'dispatch;
            }
            0x821B0DE8 => {
    //   block [0x821B0DE8..0x821B0E08)
	// 821B0DE8: 3D608262  lis r11, -0x7d9e
	ctx.r[11].s64 = -2107506688;
	// 821B0DEC: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821B0DF0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B0DF4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 821B0DF8: 392BDC58  addi r9, r11, -0x23a8
	ctx.r[9].s64 = ctx.r[11].s64 + -9128;
	// 821B0DFC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B0E00: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B0E04: 4BFFFE98  b 0x821b0c9c
	pc = 0x821B0C9C; continue 'dispatch;
            }
            0x821B0E08 => {
    //   block [0x821B0E08..0x821B0E0C)
	// 821B0E08: 4BFE3031  bl 0x82193e38
	ctx.lr = 0x821B0E0C;
	sub_82193E38(ctx, base);
	pc = 0x821B0E0C; continue 'dispatch;
            }
            0x821B0E0C => {
    //   block [0x821B0E0C..0x821B0E10)
	// 821B0E0C: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	pc = 0x821B0E10; continue 'dispatch;
            }
            0x821B0E10 => {
    //   block [0x821B0E10..0x821B0E28)
	// 821B0E10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B0E14: 48063A85  bl 0x82214898
	ctx.lr = 0x821B0E18;
	sub_82214898(ctx, base);
	// 821B0E18: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0E1C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B0E20: 41980008  blt cr6, 0x821b0e28
	if ctx.cr[6].lt {
	pc = 0x821B0E28; continue 'dispatch;
	}
	// 821B0E24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0E28; continue 'dispatch;
            }
            0x821B0E28 => {
    //   block [0x821B0E28..0x821B0E54)
	// 821B0E28: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0E2C: 3BFE0050  addi r31, r30, 0x50
	ctx.r[31].s64 = ctx.r[30].s64 + 80;
	// 821B0E30: 386B003C  addi r3, r11, 0x3c
	ctx.r[3].s64 = ctx.r[11].s64 + 60;
	// 821B0E34: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B0E38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0E3C: 419A001C  beq cr6, 0x821b0e58
	if ctx.cr[6].eq {
	pc = 0x821B0E58; continue 'dispatch;
	}
	// 821B0E40: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0E44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B0E48: 419A000C  beq cr6, 0x821b0e54
	if ctx.cr[6].eq {
	pc = 0x821B0E54; continue 'dispatch;
	}
	// 821B0E4C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821B0E50: 4800000C  b 0x821b0e5c
	pc = 0x821B0E5C; continue 'dispatch;
            }
            0x821B0E54 => {
    //   block [0x821B0E54..0x821B0E58)
	// 821B0E54: 4BFE2FE5  bl 0x82193e38
	ctx.lr = 0x821B0E58;
	sub_82193E38(ctx, base);
	pc = 0x821B0E58; continue 'dispatch;
            }
            0x821B0E58 => {
    //   block [0x821B0E58..0x821B0E5C)
	// 821B0E58: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	pc = 0x821B0E5C; continue 'dispatch;
            }
            0x821B0E5C => {
    //   block [0x821B0E5C..0x821B0EC4)
	// 821B0E5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B0E60: 48063A39  bl 0x82214898
	ctx.lr = 0x821B0E64;
	sub_82214898(ctx, base);
	// 821B0E64: 933E0034  stw r25, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[25].u32 ) };
	// 821B0E68: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B0E6C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0E70: 3BE10054  addi r31, r1, 0x54
	ctx.r[31].s64 = ctx.r[1].s64 + 84;
	// 821B0E74: 48042EE5  bl 0x821f3d58
	ctx.lr = 0x821B0E78;
	sub_821F3D58(ctx, base);
	// 821B0E78: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821B0E7C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821B0E80: 48001679  bl 0x821b24f8
	ctx.lr = 0x821B0E84;
	sub_821B24F8(ctx, base);
	// 821B0E84: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 821B0E88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B0E8C: 48034B7D  bl 0x821e5a08
	ctx.lr = 0x821B0E90;
	sub_821E5A08(ctx, base);
	// 821B0E90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B0E94: 419A008C  beq cr6, 0x821b0f20
	if ctx.cr[6].eq {
	pc = 0x821B0F20; continue 'dispatch;
	}
	// 821B0E98: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B0E9C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821B0EA0: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821B0EA4: 419A0020  beq cr6, 0x821b0ec4
	if ctx.cr[6].eq {
	pc = 0x821B0EC4; continue 'dispatch;
	}
	// 821B0EA8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B0EAC: 409A0018  bne cr6, 0x821b0ec4
	if !ctx.cr[6].eq {
	pc = 0x821B0EC4; continue 'dispatch;
	}
	// 821B0EB0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0EB4: 817AE454  lwz r11, -0x1bac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 821B0EB8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B0EBC: 409A0008  bne cr6, 0x821b0ec4
	if !ctx.cr[6].eq {
	pc = 0x821B0EC4; continue 'dispatch;
	}
	// 821B0EC0: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	pc = 0x821B0EC4; continue 'dispatch;
            }
            0x821B0EC4 => {
    //   block [0x821B0EC4..0x821B0F20)
	// 821B0EC4: 80F06DA0  lwz r7, 0x6da0(r16)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B0EC8: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0ECC: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821B0ED0: 48033381  bl 0x821e4250
	ctx.lr = 0x821B0ED4;
	sub_821E4250(ctx, base);
	// 821B0ED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B0ED8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B0EDC: 419A0048  beq cr6, 0x821b0f24
	if ctx.cr[6].eq {
	pc = 0x821B0F24; continue 'dispatch;
	}
	// 821B0EE0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B0EE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B0EE8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B0EEC: 4846AF85  bl 0x8261be70
	ctx.lr = 0x821B0EF0;
	sub_8261BE70(ctx, base);
	// 821B0EF0: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821B0EF4: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0EF8: 39C10060  addi r14, r1, 0x60
	ctx.r[14].s64 = ctx.r[1].s64 + 96;
	// 821B0EFC: 48042E5D  bl 0x821f3d58
	ctx.lr = 0x821B0F00;
	sub_821F3D58(ctx, base);
	// 821B0F00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0F04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B0F08: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 821B0F0C: 48034AFD  bl 0x821e5a08
	ctx.lr = 0x821B0F10;
	sub_821E5A08(ctx, base);
	// 821B0F10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B0F14: 419A000C  beq cr6, 0x821b0f20
	if ctx.cr[6].eq {
	pc = 0x821B0F20; continue 'dispatch;
	}
	// 821B0F18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0F1C: 917E001C  stw r11, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	pc = 0x821B0F20; continue 'dispatch;
            }
            0x821B0F20 => {
    //   block [0x821B0F20..0x821B0F24)
	// 821B0F20: 80F06DA0  lwz r7, 0x6da0(r16)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	pc = 0x821B0F24; continue 'dispatch;
            }
            0x821B0F24 => {
    //   block [0x821B0F24..0x821B0F48)
	// 821B0F24: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B0F28: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 821B0F2C: 9221007C  stw r17, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[17].u32 ) };
	// 821B0F30: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B0F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0F38: 409A0010  bne cr6, 0x821b0f48
	if !ctx.cr[6].eq {
	pc = 0x821B0F48; continue 'dispatch;
	}
	// 821B0F3C: 816F6AC0  lwz r11, 0x6ac0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(27328 as u32) ) } as u64;
	// 821B0F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0F44: 419A0014  beq cr6, 0x821b0f58
	if ctx.cr[6].eq {
	pc = 0x821B0F58; continue 'dispatch;
	}
	pc = 0x821B0F48; continue 'dispatch;
            }
            0x821B0F48 => {
    //   block [0x821B0F48..0x821B0F58)
	// 821B0F48: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B0F4C: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821B0F50: 48033301  bl 0x821e4250
	ctx.lr = 0x821B0F54;
	sub_821E4250(ctx, base);
	// 821B0F54: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	pc = 0x821B0F58; continue 'dispatch;
            }
            0x821B0F58 => {
    //   block [0x821B0F58..0x821B0F70)
	// 821B0F58: E9610078  ld r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 821B0F5C: F97E0020  std r11, 0x20(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 821B0F60: 81410098  lwz r10, 0x98(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0F64: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B0F68: 41980008  blt cr6, 0x821b0f70
	if ctx.cr[6].lt {
	pc = 0x821B0F70; continue 'dispatch;
	}
	// 821B0F6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0F70; continue 'dispatch;
            }
            0x821B0F70 => {
    //   block [0x821B0F70..0x821B0FAC)
	// 821B0F70: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0F74: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821B0F78: 92C10080  stw r22, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[22].u32 ) };
	// 821B0F7C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B0F80: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B0F84: 915E0028  stw r10, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 821B0F88: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B0F8C: 913E002C  stw r9, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 821B0F90: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B0F94: 911E0030  stw r8, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[8].u32 ) };
	// 821B0F98: 80F60004  lwz r7, 4(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0F9C: 90E10084  stw r7, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 821B0FA0: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 821B0FA4: 4846CB45  bl 0x8261dae8
	ctx.lr = 0x821B0FA8;
	sub_8261DAE8(ctx, base);
	// 821B0FA8: 81C10058  lwz r14, 0x58(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x821B0FAC; continue 'dispatch;
            }
            0x821B0FAC => {
    //   block [0x821B0FAC..0x821B0FBC)
	// 821B0FAC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821B0FB0: 48006B69  bl 0x821b7b18
	ctx.lr = 0x821B0FB4;
	sub_821B7B18(ctx, base);
	// 821B0FB4: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0FB8: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	pc = 0x821B0FBC; continue 'dispatch;
            }
            0x821B0FBC => {
    //   block [0x821B0FBC..0x821B0FC8)
	// 821B0FBC: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0FC0: 41980008  blt cr6, 0x821b0fc8
	if ctx.cr[6].lt {
	pc = 0x821B0FC8; continue 'dispatch;
	}
	// 821B0FC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B0FC8; continue 'dispatch;
            }
            0x821B0FC8 => {
    //   block [0x821B0FC8..0x821B0FD0)
	// 821B0FC8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821B0FCC: 4BFFFBFC  b 0x821b0bc8
	pc = 0x821B0BC8; continue 'dispatch;
            }
            0x821B0FD0 => {
    //   block [0x821B0FD0..0x821B0FE4)
	// 821B0FD0: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0FD4: 40990010  ble cr6, 0x821b0fe4
	if !ctx.cr[6].gt {
	pc = 0x821B0FE4; continue 'dispatch;
	}
	// 821B0FD8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0FDC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0FE0: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	pc = 0x821B0FE4; continue 'dispatch;
            }
            0x821B0FE4 => {
    //   block [0x821B0FE4..0x821B0FEC)
	// 821B0FE4: 419A0008  beq cr6, 0x821b0fec
	if ctx.cr[6].eq {
	pc = 0x821B0FEC; continue 'dispatch;
	}
	// 821B0FE8: 90E10098  stw r7, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[7].u32 ) };
	pc = 0x821B0FEC; continue 'dispatch;
            }
            0x821B0FEC => {
    //   block [0x821B0FEC..0x821B1028)
	// 821B0FEC: 81760258  lwz r11, 0x258(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B0FF0: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821B0FF4: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821B0FF8: 80F6025C  lwz r7, 0x25c(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(604 as u32) ) } as u64;
	// 821B0FFC: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821B1000: 38800032  li r4, 0x32
	ctx.r[4].s64 = 50;
	// 821B1004: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 821B1008: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 821B100C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821B1010: 48026661  bl 0x821d7670
	ctx.lr = 0x821B1014;
	sub_821D7670(ctx, base);
	// 821B1014: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B1018: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B101C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1020: 40990008  ble cr6, 0x821b1028
	if !ctx.cr[6].gt {
	pc = 0x821B1028; continue 'dispatch;
	}
	// 821B1024: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1028; continue 'dispatch;
            }
            0x821B1028 => {
    //   block [0x821B1028..0x821B1030)
	// 821B1028: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 821B102C: 3B400004  li r26, 4
	ctx.r[26].s64 = 4;
	pc = 0x821B1030; continue 'dispatch;
            }
            0x821B1030 => {
    //   block [0x821B1030..0x821B103C)
	// 821B1030: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1034: 40990008  ble cr6, 0x821b103c
	if !ctx.cr[6].gt {
	pc = 0x821B103C; continue 'dispatch;
	}
	// 821B1038: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B103C; continue 'dispatch;
            }
            0x821B103C => {
    //   block [0x821B103C..0x821B104C)
	// 821B103C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1040: 419A02AC  beq cr6, 0x821b12ec
	if ctx.cr[6].eq {
	pc = 0x821B12EC; continue 'dispatch;
	}
	// 821B1044: 41980008  blt cr6, 0x821b104c
	if ctx.cr[6].lt {
	pc = 0x821B104C; continue 'dispatch;
	}
	// 821B1048: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B104C; continue 'dispatch;
            }
            0x821B104C => {
    //   block [0x821B104C..0x821B1080)
	// 821B104C: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1050: 9221007C  stw r17, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[17].u32 ) };
	// 821B1054: 8369001C  lwz r27, 0x1c(r9)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B1058: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821B105C: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 821B1060: 419A0278  beq cr6, 0x821b12d8
	if ctx.cr[6].eq {
	pc = 0x821B12D8; continue 'dispatch;
	}
	// 821B1064: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B1068: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B106C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1070: 409A0010  bne cr6, 0x821b1080
	if !ctx.cr[6].eq {
	pc = 0x821B1080; continue 'dispatch;
	}
	// 821B1074: 816F6AC0  lwz r11, 0x6ac0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(27328 as u32) ) } as u64;
	// 821B1078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B107C: 419A0014  beq cr6, 0x821b1090
	if ctx.cr[6].eq {
	pc = 0x821B1090; continue 'dispatch;
	}
	pc = 0x821B1080; continue 'dispatch;
            }
            0x821B1080 => {
    //   block [0x821B1080..0x821B1090)
	// 821B1080: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B1084: 80706DA0  lwz r3, 0x6da0(r16)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B1088: 480331C9  bl 0x821e4250
	ctx.lr = 0x821B108C;
	sub_821E4250(ctx, base);
	// 821B108C: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	pc = 0x821B1090; continue 'dispatch;
            }
            0x821B1090 => {
    //   block [0x821B1090..0x821B10BC)
	// 821B1090: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 821B1094: 4806E22D  bl 0x8221f2c0
	ctx.lr = 0x821B1098;
	sub_8221F2C0(ctx, base);
	// 821B1098: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B109C: 409A0114  bne cr6, 0x821b11b0
	if !ctx.cr[6].eq {
	pc = 0x821B11B0; continue 'dispatch;
	}
	// 821B10A0: 81726F6C  lwz r11, 0x6f6c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28524 as u32) ) } as u64;
	// 821B10A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B10A8: 419A0014  beq cr6, 0x821b10bc
	if ctx.cr[6].eq {
	pc = 0x821B10BC; continue 'dispatch;
	}
	// 821B10AC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B10B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B10B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B10B8: 4E800421  bctrl
	ctx.lr = 0x821B10BC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821B10BC => {
    //   block [0x821B10BC..0x821B10C4)
	// 821B10BC: 48B112ED  bl 0x82cc23a8
	ctx.lr = 0x821B10C0;
	sub_82CC23A8(ctx, base);
	// 821B10C0: 7E3F8B78  mr r31, r17
	ctx.r[31].u64 = ctx.r[17].u64;
	pc = 0x821B10C4; continue 'dispatch;
            }
            0x821B10C4 => {
    //   block [0x821B10C4..0x821B10FC)
	// 821B10C4: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 821B10C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B10CC: 419A0034  beq cr6, 0x821b1100
	if ctx.cr[6].eq {
	pc = 0x821B1100; continue 'dispatch;
	}
	// 821B10D0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 821B10D4: 4806E1ED  bl 0x8221f2c0
	ctx.lr = 0x821B10D8;
	sub_8221F2C0(ctx, base);
	// 821B10D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B10DC: 409A00E0  bne cr6, 0x821b11bc
	if !ctx.cr[6].eq {
	pc = 0x821B11BC; continue 'dispatch;
	}
	// 821B10E0: 81726F6C  lwz r11, 0x6f6c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28524 as u32) ) } as u64;
	// 821B10E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B10E8: 419A0014  beq cr6, 0x821b10fc
	if ctx.cr[6].eq {
	pc = 0x821B10FC; continue 'dispatch;
	}
	// 821B10EC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B10F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B10F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B10F8: 4E800421  bctrl
	ctx.lr = 0x821B10FC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821B10FC => {
    //   block [0x821B10FC..0x821B1100)
	// 821B10FC: 48B112AD  bl 0x82cc23a8
	ctx.lr = 0x821B1100;
	sub_82CC23A8(ctx, base);
	pc = 0x821B1100; continue 'dispatch;
            }
            0x821B1100 => {
    //   block [0x821B1100..0x821B1104)
	// 821B1100: 92210074  stw r17, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[17].u32 ) };
	pc = 0x821B1104; continue 'dispatch;
            }
            0x821B1104 => {
    //   block [0x821B1104..0x821B113C)
	// 821B1104: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B1108: 81560258  lwz r10, 0x258(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B110C: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 821B1110: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 821B1114: FC0007F2  fmul f0, f0, f31
	ctx.f[0].f64 = ctx.f[0].f64 * ctx.f[31].f64;
	// 821B1118: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821B111C: D9A10088  stfd f13, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.f[13].u64 ) };
	// 821B1120: 8121008C  lwz r9, 0x8c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B1124: 5528083C  slwi r8, r9, 1
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B1128: 911F0018  stw r8, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 821B112C: 80E10098  lwz r7, 0x98(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B1130: 7F1D3840  cmplw cr6, r29, r7
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821B1134: 41980008  blt cr6, 0x821b113c
	if ctx.cr[6].lt {
	pc = 0x821B113C; continue 'dispatch;
	}
	// 821B1138: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B113C; continue 'dispatch;
            }
            0x821B113C => {
    //   block [0x821B113C..0x821B1160)
	// 821B113C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1140: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B1144: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 821B1148: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B114C: 913F003C  stw r9, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 821B1150: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B1154: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B1158: 41980008  blt cr6, 0x821b1160
	if ctx.cr[6].lt {
	pc = 0x821B1160; continue 'dispatch;
	}
	// 821B115C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1160; continue 'dispatch;
            }
            0x821B1160 => {
    //   block [0x821B1160..0x821B1184)
	// 821B1160: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1164: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B1168: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821B116C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B1170: 913F0044  stw r9, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[9].u32 ) };
	// 821B1174: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B1178: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B117C: 41980008  blt cr6, 0x821b1184
	if ctx.cr[6].lt {
	pc = 0x821B1184; continue 'dispatch;
	}
	// 821B1180: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1184; continue 'dispatch;
            }
            0x821B1184 => {
    //   block [0x821B1184..0x821B11B0)
	// 821B1184: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1188: 3B9F0048  addi r28, r31, 0x48
	ctx.r[28].s64 = ctx.r[31].s64 + 72;
	// 821B118C: 3BCB0034  addi r30, r11, 0x34
	ctx.r[30].s64 = ctx.r[11].s64 + 52;
	// 821B1190: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B1194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1198: 419A0074  beq cr6, 0x821b120c
	if ctx.cr[6].eq {
	pc = 0x821B120C; continue 'dispatch;
	}
	// 821B119C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B11A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B11A4: 419A0038  beq cr6, 0x821b11dc
	if ctx.cr[6].eq {
	pc = 0x821B11DC; continue 'dispatch;
	}
	// 821B11A8: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821B11AC: 48000064  b 0x821b1210
	pc = 0x821B1210; continue 'dispatch;
            }
            0x821B11B0 => {
    //   block [0x821B11B0..0x821B11BC)
	// 821B11B0: 48468BD9  bl 0x82619d88
	ctx.lr = 0x821B11B4;
	sub_82619D88(ctx, base);
	// 821B11B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B11B8: 4BFFFF0C  b 0x821b10c4
	pc = 0x821B10C4; continue 'dispatch;
            }
            0x821B11BC => {
    //   block [0x821B11BC..0x821B11DC)
	// 821B11BC: 3D608262  lis r11, -0x7d9e
	ctx.r[11].s64 = -2107506688;
	// 821B11C0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 821B11C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B11C8: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 821B11CC: 392BDC58  addi r9, r11, -0x23a8
	ctx.r[9].s64 = ctx.r[11].s64 + -9128;
	// 821B11D0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B11D4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B11D8: 4BFFFF2C  b 0x821b1104
	pc = 0x821B1104; continue 'dispatch;
            }
            0x821B11DC => {
    //   block [0x821B11DC..0x821B1208)
	// 821B11DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B11E0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821B11E4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821B11E8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B11EC: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B11F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B11F4: 409A0014  bne cr6, 0x821b1208
	if !ctx.cr[6].eq {
	pc = 0x821B1208; continue 'dispatch;
	}
	// 821B11F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B11FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1200: 409A0008  bne cr6, 0x821b1208
	if !ctx.cr[6].eq {
	pc = 0x821B1208; continue 'dispatch;
	}
	// 821B1204: 4806AB35  bl 0x8221bd38
	ctx.lr = 0x821B1208;
	sub_8221BD38(ctx, base);
	pc = 0x821B1208; continue 'dispatch;
            }
            0x821B1208 => {
    //   block [0x821B1208..0x821B120C)
	// 821B1208: 923E0004  stw r17, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[17].u32 ) };
	pc = 0x821B120C; continue 'dispatch;
            }
            0x821B120C => {
    //   block [0x821B120C..0x821B1210)
	// 821B120C: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	pc = 0x821B1210; continue 'dispatch;
            }
            0x821B1210 => {
    //   block [0x821B1210..0x821B1228)
	// 821B1210: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B1214: 48063685  bl 0x82214898
	ctx.lr = 0x821B1218;
	sub_82214898(ctx, base);
	// 821B1218: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B121C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1220: 41980008  blt cr6, 0x821b1228
	if ctx.cr[6].lt {
	pc = 0x821B1228; continue 'dispatch;
	}
	// 821B1224: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1228; continue 'dispatch;
            }
            0x821B1228 => {
    //   block [0x821B1228..0x821B1280)
	// 821B1228: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B122C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 821B1230: 388B003C  addi r4, r11, 0x3c
	ctx.r[4].s64 = ctx.r[11].s64 + 60;
	// 821B1234: 48320C95  bl 0x824d1ec8
	ctx.lr = 0x821B1238;
	sub_824D1EC8(ctx, base);
	// 821B1238: 935F0034  stw r26, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[26].u32 ) };
	// 821B123C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821B1240: 480012B9  bl 0x821b24f8
	ctx.lr = 0x821B1244;
	sub_821B24F8(ctx, base);
	// 821B1244: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821B1248: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B124C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B1250: 4846AC21  bl 0x8261be70
	ctx.lr = 0x821B1254;
	sub_8261BE70(ctx, base);
	// 821B1254: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B1258: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821B125C: 480290ED  bl 0x821da348
	ctx.lr = 0x821B1260;
	sub_821DA348(ctx, base);
	// 821B1260: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1264: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 821B1268: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B126C: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 821B1270: 81210098  lwz r9, 0x98(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B1274: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B1278: 41980008  blt cr6, 0x821b1280
	if ctx.cr[6].lt {
	pc = 0x821B1280; continue 'dispatch;
	}
	// 821B127C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1280; continue 'dispatch;
            }
            0x821B1280 => {
    //   block [0x821B1280..0x821B12D8)
	// 821B1280: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1284: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B1288: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B128C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B1290: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 821B1294: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B1298: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 821B129C: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B12A0: 911F0030  stw r8, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[8].u32 ) };
	// 821B12A4: 4846A185  bl 0x8261b428
	ctx.lr = 0x821B12A8;
	sub_8261B428(ctx, base);
	// 821B12A8: 987F005A  stb r3, 0x5a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(90 as u32), ctx.r[3].u8 ) };
	// 821B12AC: 92C10080  stw r22, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[22].u32 ) };
	// 821B12B0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821B12B4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B12B8: 80F60004  lwz r7, 4(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B12BC: 90E10084  stw r7, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 821B12C0: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 821B12C4: 4846C825  bl 0x8261dae8
	ctx.lr = 0x821B12C8;
	sub_8261DAE8(ctx, base);
	// 821B12C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821B12CC: 4800684D  bl 0x821b7b18
	ctx.lr = 0x821B12D0;
	sub_821B7B18(ctx, base);
	// 821B12D0: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B12D4: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	pc = 0x821B12D8; continue 'dispatch;
            }
            0x821B12D8 => {
    //   block [0x821B12D8..0x821B12E4)
	// 821B12D8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B12DC: 41980008  blt cr6, 0x821b12e4
	if ctx.cr[6].lt {
	pc = 0x821B12E4; continue 'dispatch;
	}
	// 821B12E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B12E4; continue 'dispatch;
            }
            0x821B12E4 => {
    //   block [0x821B12E4..0x821B12EC)
	// 821B12E4: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821B12E8: 4BFFFD48  b 0x821b1030
	pc = 0x821B1030; continue 'dispatch;
            }
            0x821B12EC => {
    //   block [0x821B12EC..0x821B1320)
	// 821B12EC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B12F0: 4BFC19C1  bl 0x82172cb0
	ctx.lr = 0x821B12F4;
	sub_82172CB0(ctx, base);
	// 821B12F4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B12F8: 48123CB1  bl 0x822d4fa8
	ctx.lr = 0x821B12FC;
	sub_822D4FA8(ctx, base);
	// 821B12FC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B1300: 48123E41  bl 0x822d5140
	ctx.lr = 0x821B1304;
	sub_822D5140(ctx, base);
	// 821B1304: 816E0454  lwz r11, 0x454(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(1108 as u32) ) } as u64;
	// 821B1308: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B130C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B1310: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B1314: 9176025C  stw r11, 0x25c(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(604 as u32), ctx.r[11].u32 ) };
	// 821B1318: 419A0008  beq cr6, 0x821b1320
	if ctx.cr[6].eq {
	pc = 0x821B1320; continue 'dispatch;
	}
	// 821B131C: 4806AA1D  bl 0x8221bd38
	ctx.lr = 0x821B1320;
	sub_8221BD38(ctx, base);
	pc = 0x821B1320; continue 'dispatch;
            }
            0x821B1320 => {
    //   block [0x821B1320..0x821B132C)
	// 821B1320: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 821B1324: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 821B1328: 48AF80F8  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B1330 size=28
    let mut pc: u32 = 0x821B1330;
    'dispatch: loop {
        match pc {
            0x821B1330 => {
    //   block [0x821B1330..0x821B134C)
	// 821B1330: 8163293C  lwz r11, 0x293c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10556 as u32) ) } as u64;
	// 821B1334: 51640038  rlwimi r4, r11, 0, 0, 0x1c
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(0) as u64) & 0x00000000FFFFFFF8) | (ctx.r[4].u64 & 0xFFFFFFFF00000007);
	// 821B1338: 9083293C  stw r4, 0x293c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10556 as u32), ctx.r[4].u32 ) };
	// 821B133C: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821B1340: 616B0200  ori r11, r11, 0x200
	ctx.r[11].u64 = ctx.r[11].u64 | 512;
	// 821B1344: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821B1348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B1350 size=20
    let mut pc: u32 = 0x821B1350;
    'dispatch: loop {
        match pc {
            0x821B1350 => {
    //   block [0x821B1350..0x821B1364)
	// 821B1350: 98832901  stb r4, 0x2901(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(10497 as u32), ctx.r[4].u8 ) };
	// 821B1354: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821B1358: 656B1000  oris r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 268435456;
	// 821B135C: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821B1360: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1368 size=44
    let mut pc: u32 = 0x821B1368;
    'dispatch: loop {
        match pc {
            0x821B1368 => {
    //   block [0x821B1368..0x821B1394)
	// 821B1368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B136C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1370: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1374: 48042A3D  bl 0x821f3db0
	ctx.lr = 0x821B1378;
	sub_821F3DB0(ctx, base);
	// 821B1378: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 821B137C: C80B0ED0  lfd f0, 0xed0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3792 as u32) ) };
	// 821B1380: FC210032  fmul f1, f1, f0
	ctx.f[1].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 821B1384: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B1388: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B138C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B1398 size=380
    let mut pc: u32 = 0x821B1398;
    'dispatch: loop {
        match pc {
            0x821B1398 => {
    //   block [0x821B1398..0x821B13F0)
	// 821B1398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B139C: 48AF8061  bl 0x82ca93fc
	ctx.lr = 0x821B13A0;
	sub_82CA93D0(ctx, base);
	// 821B13A0: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 821B13A4: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821B13A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B13AC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821B13B0: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B13B4: 48000165  bl 0x821b1518
	ctx.lr = 0x821B13B8;
	sub_821B1518(ctx, base);
	// 821B13B8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821B13BC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821B13C0: 419A0144  beq cr6, 0x821b1504
	if ctx.cr[6].eq {
	pc = 0x821B1504; continue 'dispatch;
	}
	// 821B13C4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B13C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B13CC: 40990138  ble cr6, 0x821b1504
	if !ctx.cr[6].gt {
	pc = 0x821B1504; continue 'dispatch;
	}
	// 821B13D0: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B13D4: 4805641D  bl 0x822077f0
	ctx.lr = 0x821B13D8;
	sub_822077F0(ctx, base);
	// 821B13D8: 81650018  lwz r11, 0x18(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B13DC: 3B850014  addi r28, r5, 0x14
	ctx.r[28].s64 = ctx.r[5].s64 + 20;
	// 821B13E0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821B13E4: 3F40820A  lis r26, -0x7df6
	ctx.r[26].s64 = -2113273856;
	// 821B13E8: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821B13EC: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821B13F0; continue 'dispatch;
            }
            0x821B13F0 => {
    //   block [0x821B13F0..0x821B1400)
	// 821B13F0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B13F4: 7F1CE040  cmplw cr6, r28, r28
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B13F8: 419A0008  beq cr6, 0x821b1400
	if ctx.cr[6].eq {
	pc = 0x821B1400; continue 'dispatch;
	}
	// 821B13FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1400; continue 'dispatch;
            }
            0x821B1400 => {
    //   block [0x821B1400..0x821B1418)
	// 821B1400: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1404: 419A0100  beq cr6, 0x821b1504
	if ctx.cr[6].eq {
	pc = 0x821B1504; continue 'dispatch;
	}
	// 821B1408: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B140C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1410: 409A0008  bne cr6, 0x821b1418
	if !ctx.cr[6].eq {
	pc = 0x821B1418; continue 'dispatch;
	}
	// 821B1414: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1418; continue 'dispatch;
            }
            0x821B1418 => {
    //   block [0x821B1418..0x821B1468)
	// 821B1418: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B141C: 3BFD0008  addi r31, r29, 8
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	// 821B1420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1424: 409A00BC  bne cr6, 0x821b14e0
	if !ctx.cr[6].eq {
	pc = 0x821B14E0; continue 'dispatch;
	}
	// 821B1428: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B142C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1430: 419A0038  beq cr6, 0x821b1468
	if ctx.cr[6].eq {
	pc = 0x821B1468; continue 'dispatch;
	}
	// 821B1434: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1438: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B143C: 419A00BC  beq cr6, 0x821b14f8
	if ctx.cr[6].eq {
	pc = 0x821B14F8; continue 'dispatch;
	}
	// 821B1440: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B1444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1448: 419A0020  beq cr6, 0x821b1468
	if ctx.cr[6].eq {
	pc = 0x821B1468; continue 'dispatch;
	}
	// 821B144C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B1450: 4BFC29E9  bl 0x82173e38
	ctx.lr = 0x821B1454;
	sub_82173E38(ctx, base);
	// 821B1454: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B1458: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B145C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B1460: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1464: 409A0008  bne cr6, 0x821b146c
	if !ctx.cr[6].eq {
	pc = 0x821B146C; continue 'dispatch;
	}
	pc = 0x821B1468; continue 'dispatch;
            }
            0x821B1468 => {
    //   block [0x821B1468..0x821B146C)
	// 821B1468: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B146C; continue 'dispatch;
            }
            0x821B146C => {
    //   block [0x821B146C..0x821B149C)
	// 821B146C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1474: 419A006C  beq cr6, 0x821b14e0
	if ctx.cr[6].eq {
	pc = 0x821B14E0; continue 'dispatch;
	}
	// 821B1478: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B147C: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 821B1480: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1484: 41980018  blt cr6, 0x821b149c
	if ctx.cr[6].lt {
	pc = 0x821B149C; continue 'dispatch;
	}
	// 821B1488: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B148C: 480E72AD  bl 0x82298738
	ctx.lr = 0x821B1490;
	sub_82298738(ctx, base);
	// 821B1490: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B1494: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B1498: 409A0008  bne cr6, 0x821b14a0
	if !ctx.cr[6].eq {
	pc = 0x821B14A0; continue 'dispatch;
	}
	pc = 0x821B149C; continue 'dispatch;
            }
            0x821B149C => {
    //   block [0x821B149C..0x821B14A0)
	// 821B149C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B14A0; continue 'dispatch;
            }
            0x821B14A0 => {
    //   block [0x821B14A0..0x821B14E0)
	// 821B14A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B14A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B14A8: 419A0038  beq cr6, 0x821b14e0
	if ctx.cr[6].eq {
	pc = 0x821B14E0; continue 'dispatch;
	}
	// 821B14AC: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B14B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B14B4: EFC007F2  fmuls f30, f0, f31
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B14B8: 486A1D49  bl 0x82853200
	ctx.lr = 0x821B14BC;
	sub_82853200(ctx, base);
	// 821B14BC: EDA1F824  fdivs f13, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[1].f64 / ctx.f[31].f64) as f32) as f64;
	// 821B14C0: C01AD5FC  lfs f0, -0x2a04(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10756 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B14C4: ED9E6828  fsubs f12, f30, f13
	ctx.f[12].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B14C8: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 821B14CC: 41990014  bgt cr6, 0x821b14e0
	if ctx.cr[6].gt {
	pc = 0x821B14E0; continue 'dispatch;
	}
	// 821B14D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B14D4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821B14D8: 483F2EA9  bl 0x825a4380
	ctx.lr = 0x821B14DC;
	sub_825A4380(ctx, base);
	// 821B14DC: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	pc = 0x821B14E0; continue 'dispatch;
            }
            0x821B14E0 => {
    //   block [0x821B14E0..0x821B14F0)
	// 821B14E0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B14E4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B14E8: 409A0008  bne cr6, 0x821b14f0
	if !ctx.cr[6].eq {
	pc = 0x821B14F0; continue 'dispatch;
	}
	// 821B14EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B14F0; continue 'dispatch;
            }
            0x821B14F0 => {
    //   block [0x821B14F0..0x821B14F8)
	// 821B14F0: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B14F4: 4BFFFEFC  b 0x821b13f0
	pc = 0x821B13F0; continue 'dispatch;
            }
            0x821B14F8 => {
    //   block [0x821B14F8..0x821B1504)
	// 821B14F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B14FC: 4BFE293D  bl 0x82193e38
	ctx.lr = 0x821B1500;
	sub_82193E38(ctx, base);
	// 821B1500: 4BFFFF68  b 0x821b1468
	pc = 0x821B1468; continue 'dispatch;
            }
            0x821B1504 => {
    //   block [0x821B1504..0x821B1514)
	// 821B1504: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B1508: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821B150C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821B1510: 48AF7F3C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B1518 size=360
    let mut pc: u32 = 0x821B1518;
    'dispatch: loop {
        match pc {
            0x821B1518 => {
    //   block [0x821B1518..0x821B153C)
	// 821B1518: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B151C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B1520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1524: 419A0018  beq cr6, 0x821b153c
	if ctx.cr[6].eq {
	pc = 0x821B153C; continue 'dispatch;
	}
	// 821B1528: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B152C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821B1530: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B1534: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B1538: 409A0008  bne cr6, 0x821b1540
	if !ctx.cr[6].eq {
	pc = 0x821B1540; continue 'dispatch;
	}
	pc = 0x821B153C; continue 'dispatch;
            }
            0x821B153C => {
    //   block [0x821B153C..0x821B1540)
	// 821B153C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	pc = 0x821B1540; continue 'dispatch;
            }
            0x821B1540 => {
    //   block [0x821B1540..0x821B158C)
	// 821B1540: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B1544: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1548: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821B154C: 892B0028  lbz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B1550: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821B1554: 552807FE  clrlwi r8, r9, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 821B1558: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B155C: 419A00F4  beq cr6, 0x821b1650
	if ctx.cr[6].eq {
	pc = 0x821B1650; continue 'dispatch;
	}
	// 821B1560: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B1564: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1568: 419A0024  beq cr6, 0x821b158c
	if ctx.cr[6].eq {
	pc = 0x821B158C; continue 'dispatch;
	}
	// 821B156C: 894A0038  lbz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B1570: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B1574: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B1578: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B157C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1580: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B1584: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B1588: 480000CC  b 0x821b1654
	pc = 0x821B1654; continue 'dispatch;
            }
            0x821B158C => {
    //   block [0x821B158C..0x821B15A8)
	// 821B158C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B1590: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B1594: 9061FFF0  stw r3, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[3].u32 ) };
	// 821B1598: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B159C: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 821B15A0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B15A4: 40810054  ble 0x821b15f8
	if !ctx.cr[0].gt {
	pc = 0x821B15F8; continue 'dispatch;
	}
	pc = 0x821B15A8; continue 'dispatch;
            }
            0x821B15A8 => {
    //   block [0x821B15A8..0x821B15C8)
	// 821B15A8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B15AC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B15B0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B15B4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B15B8: 2F070038  cmpwi cr6, r7, 0x38
	ctx.cr[6].compare_i32(ctx.r[7].s32, 56, &mut ctx.xer);
	// 821B15BC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B15C0: 41980008  blt cr6, 0x821b15c8
	if ctx.cr[6].lt {
	pc = 0x821B15C8; continue 'dispatch;
	}
	// 821B15C4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x821B15C8; continue 'dispatch;
            }
            0x821B15C8 => {
    //   block [0x821B15C8..0x821B15E4)
	// 821B15C8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B15CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B15D0: 419A0014  beq cr6, 0x821b15e4
	if ctx.cr[6].eq {
	pc = 0x821B15E4; continue 'dispatch;
	}
	// 821B15D4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B15D8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B15DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B15E0: 4800000C  b 0x821b15ec
	pc = 0x821B15EC; continue 'dispatch;
            }
            0x821B15E4 => {
    //   block [0x821B15E4..0x821B15EC)
	// 821B15E4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B15E8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821B15EC; continue 'dispatch;
            }
            0x821B15EC => {
    //   block [0x821B15EC..0x821B15F8)
	// 821B15EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B15F0: 4199FFB8  bgt cr6, 0x821b15a8
	if ctx.cr[6].gt {
	pc = 0x821B15A8; continue 'dispatch;
	}
	// 821B15F4: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	pc = 0x821B15F8; continue 'dispatch;
            }
            0x821B15F8 => {
    //   block [0x821B15F8..0x821B1614)
	// 821B15F8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B15FC: 419A0040  beq cr6, 0x821b163c
	if ctx.cr[6].eq {
	pc = 0x821B163C; continue 'dispatch;
	}
	// 821B1600: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1604: 2F0B0038  cmpwi cr6, r11, 0x38
	ctx.cr[6].compare_i32(ctx.r[11].s32, 56, &mut ctx.xer);
	// 821B1608: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B160C: 41990008  bgt cr6, 0x821b1614
	if ctx.cr[6].gt {
	pc = 0x821B1614; continue 'dispatch;
	}
	// 821B1610: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x821B1614; continue 'dispatch;
            }
            0x821B1614 => {
    //   block [0x821B1614..0x821B163C)
	// 821B1614: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B161C: 409A0020  bne cr6, 0x821b163c
	if !ctx.cr[6].eq {
	pc = 0x821B163C; continue 'dispatch;
	}
	// 821B1620: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B1624: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821B1628: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821B162C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1630: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B1634: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B1638: 4800001C  b 0x821b1654
	pc = 0x821B1654; continue 'dispatch;
            }
            0x821B163C => {
    //   block [0x821B163C..0x821B1650)
	// 821B163C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B1640: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1644: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B1648: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B164C: 48000008  b 0x821b1654
	pc = 0x821B1654; continue 'dispatch;
            }
            0x821B1650 => {
    //   block [0x821B1650..0x821B1654)
	// 821B1650: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x821B1654; continue 'dispatch;
            }
            0x821B1654 => {
    //   block [0x821B1654..0x821B1680)
	// 821B1654: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B165C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821B1660: 816A01E0  lwz r11, 0x1e0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(480 as u32) ) } as u64;
	// 821B1664: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1668: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821B166C: 894B0044  lbz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821B1670: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1674: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821B1678: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821B167C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1680 size=120
    let mut pc: u32 = 0x821B1680;
    'dispatch: loop {
        match pc {
            0x821B1680 => {
    //   block [0x821B1680..0x821B16D8)
	// 821B1680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1688: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B168C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1690: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B1694: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821B1698: 394B0624  addi r10, r11, 0x624
	ctx.r[10].s64 = ctx.r[11].s64 + 1572;
	// 821B169C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B16A0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B16A4: 55690000  rlwinm r9, r11, 0, 0, 0
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B16A8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821B16AC: 409A002C  bne cr6, 0x821b16d8
	if !ctx.cr[6].eq {
	pc = 0x821B16D8; continue 'dispatch;
	}
	// 821B16B0: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 821B16B4: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B16B8: 556B087C  rlwinm r11, r11, 1, 1, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 821B16BC: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B16C0: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 821B16C4: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B16C8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 821B16CC: 54E52834  slwi r5, r7, 5
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(5);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821B16D0: 7C68482E  lwzx r3, r8, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B16D4: 48BA3BF5  bl 0x82d552c8
	ctx.lr = 0x821B16D8;
	sub_82D552C8(ctx, base);
	pc = 0x821B16D8; continue 'dispatch;
            }
            0x821B16D8 => {
    //   block [0x821B16D8..0x821B16F8)
	// 821B16D8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 821B16DC: 394B2B14  addi r10, r11, 0x2b14
	ctx.r[10].s64 = ctx.r[11].s64 + 11028;
	// 821B16E0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B16E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B16E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B16EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B16F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B16F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B16F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B16F8 size=604
    let mut pc: u32 = 0x821B16F8;
    'dispatch: loop {
        match pc {
            0x821B16F8 => {
    //   block [0x821B16F8..0x821B1954)
	// 821B16F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B16FC: 48AF7D11  bl 0x82ca940c
	ctx.lr = 0x821B1700;
	sub_82CA93D0(ctx, base);
	// 821B1700: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1704: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B1708: 396000D0  li r11, 0xd0
	ctx.r[11].s64 = 208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B1958 size=144
    let mut pc: u32 = 0x821B1958;
    'dispatch: loop {
        match pc {
            0x821B1958 => {
    //   block [0x821B1958..0x821B19E8)
	// 821B1958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B195C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1960: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B1964: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1968: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B196C: D0210074  stfs f1, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821B1970: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B1974: 392BAD50  addi r9, r11, -0x52b0
	ctx.r[9].s64 = ctx.r[11].s64 + -21168;
	// 821B1978: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 821B197C: 3BEA91A0  addi r31, r10, -0x6e60
	ctx.r[31].s64 = ctx.r[10].s64 + -28256;
	// 821B1980: 39010074  addi r8, r1, 0x74
	ctx.r[8].s64 = ctx.r[1].s64 + 116;
	// 821B1984: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 821B1988: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B19E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B19E8 size=160
    let mut pc: u32 = 0x821B19E8;
    'dispatch: loop {
        match pc {
            0x821B19E8 => {
    //   block [0x821B19E8..0x821B1A88)
	// 821B19E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B19EC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B19F0: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821B19F4: 7D671670  srawi r7, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821B19F8: 790AFFE6  rldicr r10, r8, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[8].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821B19FC: 7CC70194  addze r6, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[6].s64 = tmp.s64;
	// 821B1A00: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821B1A04: 7CC407B4  extsw r4, r6
	ctx.r[4].s64 = ctx.r[6].s32 as i64;
	// 821B1A08: E9291760  ld r9, 0x1760(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(5984 as u32) ) };
	// 821B1A0C: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 821B1A10: 7D472436  srd r7, r10, r4
	if (ctx.r[4].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[10].u64) >> ((ctx.r[4].u8 & 0x3F) as u32);
	}
	// 821B1A14: 7CE64838  and r6, r7, r9
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[9].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1A88 size=124
    let mut pc: u32 = 0x821B1A88;
    'dispatch: loop {
        match pc {
            0x821B1A88 => {
    //   block [0x821B1A88..0x821B1B04)
	// 821B1A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1A8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1A90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B1A94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1A98: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B1A9C: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821B1AA0: 392BAD50  addi r9, r11, -0x52b0
	ctx.r[9].s64 = ctx.r[11].s64 + -21168;
	// 821B1AA4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821B1AA8: 3BE89160  addi r31, r8, -0x6ea0
	ctx.r[31].s64 = ctx.r[8].s64 + -28320;
	// 821B1AAC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 821B1AB0: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B1B08 size=160
    let mut pc: u32 = 0x821B1B08;
    'dispatch: loop {
        match pc {
            0x821B1B08 => {
    //   block [0x821B1B08..0x821B1BA8)
	// 821B1B08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1B0C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B1B10: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821B1B14: 7D671670  srawi r7, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821B1B18: 790AFFE6  rldicr r10, r8, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[8].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821B1B1C: 7CC70194  addze r6, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[6].s64 = tmp.s64;
	// 821B1B20: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821B1B24: 7CC407B4  extsw r4, r6
	ctx.r[4].s64 = ctx.r[6].s32 as i64;
	// 821B1B28: E9291758  ld r9, 0x1758(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(5976 as u32) ) };
	// 821B1B2C: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 821B1B30: 7D472436  srd r7, r10, r4
	if (ctx.r[4].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[10].u64) >> ((ctx.r[4].u8 & 0x3F) as u32);
	}
	// 821B1B34: 7CE64838  and r6, r7, r9
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[9].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1BA8 size=112
    let mut pc: u32 = 0x821B1BA8;
    'dispatch: loop {
        match pc {
            0x821B1BA8 => {
    //   block [0x821B1BA8..0x821B1BDC)
	// 821B1BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1BAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1BB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B1BB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B1BB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1BBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B1BC0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1BC4: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1BC8: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821B1BCC: 40990010  ble cr6, 0x821b1bdc
	if !ctx.cr[6].gt {
	pc = 0x821B1BDC; continue 'dispatch;
	}
	// 821B1BD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1BD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1BD8: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	pc = 0x821B1BDC; continue 'dispatch;
            }
            0x821B1BDC => {
    //   block [0x821B1BDC..0x821B1BFC)
	// 821B1BDC: 419A0024  beq cr6, 0x821b1c00
	if ctx.cr[6].eq {
	pc = 0x821B1C00; continue 'dispatch;
	}
	// 821B1BE0: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 821B1BE4: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1BE8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821B1BEC: 7FE61A14  add r31, r6, r3
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 821B1BF0: 4081000C  ble 0x821b1bfc
	if !ctx.cr[0].gt {
	pc = 0x821B1BFC; continue 'dispatch;
	}
	// 821B1BF4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821B1BF8: 48AF8431  bl 0x82caa028
	ctx.lr = 0x821B1BFC;
	sub_82CAA028(ctx, base);
	pc = 0x821B1BFC; continue 'dispatch;
            }
            0x821B1BFC => {
    //   block [0x821B1BFC..0x821B1C00)
	// 821B1BFC: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x821B1C00; continue 'dispatch;
            }
            0x821B1C00 => {
    //   block [0x821B1C00..0x821B1C18)
	// 821B1C00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B1C04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B1C08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1C0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B1C10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B1C14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1C18 size=208
    let mut pc: u32 = 0x821B1C18;
    'dispatch: loop {
        match pc {
            0x821B1C18 => {
    //   block [0x821B1C18..0x821B1C48)
	// 821B1C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1C1C: 48AF77E9  bl 0x82ca9404
	ctx.lr = 0x821B1C20;
	sub_82CA93D0(ctx, base);
	// 821B1C20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1C24: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B1C28: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821B1C2C: 817C0080  lwz r11, 0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 821B1C30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1C34: 40990050  ble cr6, 0x821b1c84
	if !ctx.cr[6].gt {
	pc = 0x821B1C84; continue 'dispatch;
	}
	// 821B1C38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B1C3C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 821B1C40: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 821B1C44: 797DFFE6  rldicr r29, r11, 0x3f, 0x3f
	ctx.r[29].u64 = (ctx.r[11].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	pc = 0x821B1C48; continue 'dispatch;
            }
            0x821B1C48 => {
    //   block [0x821B1C48..0x821B1C70)
	// 821B1C48: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821B1C4C: 41980024  blt cr6, 0x821b1c70
	if ctx.cr[6].lt {
	pc = 0x821B1C70; continue 'dispatch;
	}
	// 821B1C50: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 821B1C54: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1C58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B1C5C: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B1C60: 79690020  clrldi r9, r11, 0x20
	ctx.r[9].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821B1C64: 7FA64C36  srd r6, r29, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[29].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 821B1C68: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1C6C: 48005275  bl 0x821b6ee0
	ctx.lr = 0x821B1C70;
	sub_821B6EE0(ctx, base);
	pc = 0x821B1C70; continue 'dispatch;
            }
            0x821B1C70 => {
    //   block [0x821B1C70..0x821B1C84)
	// 821B1C70: 817C0080  lwz r11, 0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 821B1C74: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B1C78: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B1C7C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B1C80: 4198FFC8  blt cr6, 0x821b1c48
	if ctx.cr[6].lt {
	pc = 0x821B1C48; continue 'dispatch;
	}
	pc = 0x821B1C84; continue 'dispatch;
            }
            0x821B1C84 => {
    //   block [0x821B1C84..0x821B1CB4)
	// 821B1C84: 897C0084  lbz r11, 0x84(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B1C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1C8C: 419A0028  beq cr6, 0x821b1cb4
	if ctx.cr[6].eq {
	pc = 0x821B1CB4; continue 'dispatch;
	}
	// 821B1C90: 38DC0010  addi r6, r28, 0x10
	ctx.r[6].s64 = ctx.r[28].s64 + 16;
	// 821B1C94: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821B1C98: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B1C9C: 38600102  li r3, 0x102
	ctx.r[3].s64 = 258;
	// 821B1CA0: 489D2949  bl 0x82b845e8
	ctx.lr = 0x821B1CA4;
	sub_82B845E8(ctx, base);
	// 821B1CA4: 39600070  li r11, 0x70
	ctx.r[11].s64 = 112;
	// 821B1CA8: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	pc = 0x821B1CB4; continue 'dispatch;
            }
            0x821B1CB4 => {
    //   block [0x821B1CB4..0x821B1CE8)
	// 821B1CB4: 817C0080  lwz r11, 0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 821B1CB8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B1CBC: 40990024  ble cr6, 0x821b1ce0
	if !ctx.cr[6].gt {
	pc = 0x821B1CE0; continue 'dispatch;
	}
	// 821B1CC0: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 821B1CC4: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1CE8 size=1272
    let mut pc: u32 = 0x821B1CE8;
    'dispatch: loop {
        match pc {
            0x821B1CE8 => {
    //   block [0x821B1CE8..0x821B1D3C)
	// 821B1CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1CEC: 48AF771D  bl 0x82ca9408
	ctx.lr = 0x821B1CF0;
	sub_82CA93D0(ctx, base);
	// 821B1CF0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1CF4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B1CF8: 3BFC0014  addi r31, r28, 0x14
	ctx.r[31].s64 = ctx.r[28].s64 + 20;
	// 821B1CFC: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B1D00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1D04: 419A0038  beq cr6, 0x821b1d3c
	if ctx.cr[6].eq {
	pc = 0x821B1D3C; continue 'dispatch;
	}
	// 821B1D08: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1D0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1D10: 419A0078  beq cr6, 0x821b1d88
	if ctx.cr[6].eq {
	pc = 0x821B1D88; continue 'dispatch;
	}
	// 821B1D14: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B1D18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1D1C: 419A0020  beq cr6, 0x821b1d3c
	if ctx.cr[6].eq {
	pc = 0x821B1D3C; continue 'dispatch;
	}
	// 821B1D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B1D24: 4BFC2115  bl 0x82173e38
	ctx.lr = 0x821B1D28;
	sub_82173E38(ctx, base);
	// 821B1D28: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B1D2C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B1D30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B1D34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1D38: 409A0008  bne cr6, 0x821b1d40
	if !ctx.cr[6].eq {
	pc = 0x821B1D40; continue 'dispatch;
	}
	pc = 0x821B1D3C; continue 'dispatch;
            }
            0x821B1D3C => {
    //   block [0x821B1D3C..0x821B1D40)
	// 821B1D3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B1D40; continue 'dispatch;
            }
            0x821B1D40 => {
    //   block [0x821B1D40..0x821B1D88)
	// 821B1D40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1D44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1D48: 419A0490  beq cr6, 0x821b21d8
	if ctx.cr[6].eq {
	pc = 0x821B21D8; continue 'dispatch;
	}
	// 821B1D4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B1D50: 4BFC20E9  bl 0x82173e38
	ctx.lr = 0x821B1D54;
	sub_82173E38(ctx, base);
	// 821B1D54: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B1D58: 556AB7FE  rlwinm r10, r11, 0x16, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 821B1D5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1D60: 419A0478  beq cr6, 0x821b21d8
	if ctx.cr[6].eq {
	pc = 0x821B21D8; continue 'dispatch;
	}
	// 821B1D64: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B1D68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1D6C: 419A0028  beq cr6, 0x821b1d94
	if ctx.cr[6].eq {
	pc = 0x821B1D94; continue 'dispatch;
	}
	// 821B1D70: 894B00AA  lbz r10, 0xaa(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(170 as u32) ) } as u64;
	// 821B1D74: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B1D78: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B1D7C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B1D80: 83A90004  lwz r29, 4(r9)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1D84: 480000C0  b 0x821b1e44
	pc = 0x821B1E44; continue 'dispatch;
            }
            0x821B1D88 => {
    //   block [0x821B1D88..0x821B1D94)
	// 821B1D88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B1D8C: 4BFE20AD  bl 0x82193e38
	ctx.lr = 0x821B1D90;
	sub_82193E38(ctx, base);
	// 821B1D90: 4BFFFFAC  b 0x821b1d3c
	pc = 0x821B1D3C; continue 'dispatch;
            }
            0x821B1D94 => {
    //   block [0x821B1D94..0x821B1DB4)
	// 821B1D94: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B1D98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B1D9C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B1DA0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B1DA4: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B1DA8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B1DAC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1DB0: 40810054  ble 0x821b1e04
	if !ctx.cr[0].gt {
	pc = 0x821B1E04; continue 'dispatch;
	}
	pc = 0x821B1DB4; continue 'dispatch;
            }
            0x821B1DB4 => {
    //   block [0x821B1DB4..0x821B1DD4)
	// 821B1DB4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B1DB8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B1DBC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B1DC0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1DC4: 2F0700AA  cmpwi cr6, r7, 0xaa
	ctx.cr[6].compare_i32(ctx.r[7].s32, 170, &mut ctx.xer);
	// 821B1DC8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B1DCC: 41980008  blt cr6, 0x821b1dd4
	if ctx.cr[6].lt {
	pc = 0x821B1DD4; continue 'dispatch;
	}
	// 821B1DD0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821B1DD4; continue 'dispatch;
            }
            0x821B1DD4 => {
    //   block [0x821B1DD4..0x821B1DF0)
	// 821B1DD4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B1DD8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B1DDC: 419A0014  beq cr6, 0x821b1df0
	if ctx.cr[6].eq {
	pc = 0x821B1DF0; continue 'dispatch;
	}
	// 821B1DE0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B1DE4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B1DE8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B1DEC: 4800000C  b 0x821b1df8
	pc = 0x821B1DF8; continue 'dispatch;
            }
            0x821B1DF0 => {
    //   block [0x821B1DF0..0x821B1DF8)
	// 821B1DF0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B1DF4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821B1DF8; continue 'dispatch;
            }
            0x821B1DF8 => {
    //   block [0x821B1DF8..0x821B1E04)
	// 821B1DF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1DFC: 4199FFB8  bgt cr6, 0x821b1db4
	if ctx.cr[6].gt {
	pc = 0x821B1DB4; continue 'dispatch;
	}
	// 821B1E00: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821B1E04; continue 'dispatch;
            }
            0x821B1E04 => {
    //   block [0x821B1E04..0x821B1E20)
	// 821B1E04: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B1E08: 419A0034  beq cr6, 0x821b1e3c
	if ctx.cr[6].eq {
	pc = 0x821B1E3C; continue 'dispatch;
	}
	// 821B1E0C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1E10: 2F0B00AA  cmpwi cr6, r11, 0xaa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 170, &mut ctx.xer);
	// 821B1E14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B1E18: 41990008  bgt cr6, 0x821b1e20
	if ctx.cr[6].gt {
	pc = 0x821B1E20; continue 'dispatch;
	}
	// 821B1E1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B1E20; continue 'dispatch;
            }
            0x821B1E20 => {
    //   block [0x821B1E20..0x821B1E3C)
	// 821B1E20: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1E24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1E28: 409A0014  bne cr6, 0x821b1e3c
	if !ctx.cr[6].eq {
	pc = 0x821B1E3C; continue 'dispatch;
	}
	// 821B1E2C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B1E30: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B1E34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B1E38: 48000008  b 0x821b1e40
	pc = 0x821B1E40; continue 'dispatch;
            }
            0x821B1E3C => {
    //   block [0x821B1E3C..0x821B1E40)
	// 821B1E3C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x821B1E40; continue 'dispatch;
            }
            0x821B1E40 => {
    //   block [0x821B1E40..0x821B1E44)
	// 821B1E40: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821B1E44; continue 'dispatch;
            }
            0x821B1E44 => {
    //   block [0x821B1E44..0x821B1E80)
	// 821B1E44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821B1E48: 419A0390  beq cr6, 0x821b21d8
	if ctx.cr[6].eq {
	pc = 0x821B21D8; continue 'dispatch;
	}
	// 821B1E4C: 817C00C4  lwz r11, 0xc4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(196 as u32) ) } as u64;
	// 821B1E50: 3BFC00C0  addi r31, r28, 0xc0
	ctx.r[31].s64 = ctx.r[28].s64 + 192;
	// 821B1E54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1E58: 419A00D4  beq cr6, 0x821b1f2c
	if ctx.cr[6].eq {
	pc = 0x821B1F2C; continue 'dispatch;
	}
	// 821B1E5C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1E60: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821B1E64: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1E68: 418200C4  beq 0x821b1f2c
	if ctx.cr[0].eq {
	pc = 0x821B1F2C; continue 'dispatch;
	}
	// 821B1E6C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1E70: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B1E74: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1E78: 40990008  ble cr6, 0x821b1e80
	if !ctx.cr[6].gt {
	pc = 0x821B1E80; continue 'dispatch;
	}
	// 821B1E7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1E80; continue 'dispatch;
            }
            0x821B1E80 => {
    //   block [0x821B1E80..0x821B1E88)
	// 821B1E80: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 821B1E84: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	pc = 0x821B1E88; continue 'dispatch;
            }
            0x821B1E88 => {
    //   block [0x821B1E88..0x821B1E8C)
	// 821B1E88: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	pc = 0x821B1E8C; continue 'dispatch;
            }
            0x821B1E8C => {
    //   block [0x821B1E8C..0x821B1EA0)
	// 821B1E8C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1E90: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1E94: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1E98: 40990008  ble cr6, 0x821b1ea0
	if !ctx.cr[6].gt {
	pc = 0x821B1EA0; continue 'dispatch;
	}
	// 821B1E9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1EA0; continue 'dispatch;
            }
            0x821B1EA0 => {
    //   block [0x821B1EA0..0x821B1EB0)
	// 821B1EA0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B1EA4: 419A000C  beq cr6, 0x821b1eb0
	if ctx.cr[6].eq {
	pc = 0x821B1EB0; continue 'dispatch;
	}
	// 821B1EA8: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B1EAC: 419A0008  beq cr6, 0x821b1eb4
	if ctx.cr[6].eq {
	pc = 0x821B1EB4; continue 'dispatch;
	}
	pc = 0x821B1EB0; continue 'dispatch;
            }
            0x821B1EB0 => {
    //   block [0x821B1EB0..0x821B1EB4)
	// 821B1EB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1EB4; continue 'dispatch;
            }
            0x821B1EB4 => {
    //   block [0x821B1EB4..0x821B1EC8)
	// 821B1EB4: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1EB8: 419A0074  beq cr6, 0x821b1f2c
	if ctx.cr[6].eq {
	pc = 0x821B1F2C; continue 'dispatch;
	}
	// 821B1EBC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B1EC0: 409A0008  bne cr6, 0x821b1ec8
	if !ctx.cr[6].eq {
	pc = 0x821B1EC8; continue 'dispatch;
	}
	// 821B1EC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1EC8; continue 'dispatch;
            }
            0x821B1EC8 => {
    //   block [0x821B1EC8..0x821B1ED8)
	// 821B1EC8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1ECC: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1ED0: 41980008  blt cr6, 0x821b1ed8
	if ctx.cr[6].lt {
	pc = 0x821B1ED8; continue 'dispatch;
	}
	// 821B1ED4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1ED8; continue 'dispatch;
            }
            0x821B1ED8 => {
    //   block [0x821B1ED8..0x821B1F14)
	// 821B1ED8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B1EDC: 80850000  lwz r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1EE0: 48619BF1  bl 0x827cbad0
	ctx.lr = 0x821B1EE4;
	sub_827CBAD0(ctx, base);
	// 821B1EE4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B1EE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1EEC: 409A0028  bne cr6, 0x821b1f14
	if !ctx.cr[6].eq {
	pc = 0x821B1F14; continue 'dispatch;
	}
	// 821B1EF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B1EF4: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B1EF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B1EFC: 4816F19D  bl 0x82321098
	ctx.lr = 0x821B1F00;
	sub_82321098(ctx, base);
	// 821B1F00: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821B1F04: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B1F08: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B1F0C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B1F10: 4BFFFF7C  b 0x821b1e8c
	pc = 0x821B1E8C; continue 'dispatch;
            }
            0x821B1F14 => {
    //   block [0x821B1F14..0x821B1F24)
	// 821B1F14: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1F18: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1F1C: 41980008  blt cr6, 0x821b1f24
	if ctx.cr[6].lt {
	pc = 0x821B1F24; continue 'dispatch;
	}
	// 821B1F20: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1F24; continue 'dispatch;
            }
            0x821B1F24 => {
    //   block [0x821B1F24..0x821B1F2C)
	// 821B1F24: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821B1F28: 4BFFFF60  b 0x821b1e88
	pc = 0x821B1E88; continue 'dispatch;
            }
            0x821B1F2C => {
    //   block [0x821B1F2C..0x821B1F60)
	// 821B1F2C: 817C00D4  lwz r11, 0xd4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(212 as u32) ) } as u64;
	// 821B1F30: 3BFC00D0  addi r31, r28, 0xd0
	ctx.r[31].s64 = ctx.r[28].s64 + 208;
	// 821B1F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1F38: 419A00D4  beq cr6, 0x821b200c
	if ctx.cr[6].eq {
	pc = 0x821B200C; continue 'dispatch;
	}
	// 821B1F3C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1F40: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821B1F44: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1F48: 418200C4  beq 0x821b200c
	if ctx.cr[0].eq {
	pc = 0x821B200C; continue 'dispatch;
	}
	// 821B1F4C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1F50: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B1F54: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1F58: 40990008  ble cr6, 0x821b1f60
	if !ctx.cr[6].gt {
	pc = 0x821B1F60; continue 'dispatch;
	}
	// 821B1F5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1F60; continue 'dispatch;
            }
            0x821B1F60 => {
    //   block [0x821B1F60..0x821B1F68)
	// 821B1F60: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 821B1F64: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	pc = 0x821B1F68; continue 'dispatch;
            }
            0x821B1F68 => {
    //   block [0x821B1F68..0x821B1F6C)
	// 821B1F68: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	pc = 0x821B1F6C; continue 'dispatch;
            }
            0x821B1F6C => {
    //   block [0x821B1F6C..0x821B1F80)
	// 821B1F6C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1F70: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1F74: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1F78: 40990008  ble cr6, 0x821b1f80
	if !ctx.cr[6].gt {
	pc = 0x821B1F80; continue 'dispatch;
	}
	// 821B1F7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1F80; continue 'dispatch;
            }
            0x821B1F80 => {
    //   block [0x821B1F80..0x821B1F90)
	// 821B1F80: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B1F84: 419A000C  beq cr6, 0x821b1f90
	if ctx.cr[6].eq {
	pc = 0x821B1F90; continue 'dispatch;
	}
	// 821B1F88: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B1F8C: 419A0008  beq cr6, 0x821b1f94
	if ctx.cr[6].eq {
	pc = 0x821B1F94; continue 'dispatch;
	}
	pc = 0x821B1F90; continue 'dispatch;
            }
            0x821B1F90 => {
    //   block [0x821B1F90..0x821B1F94)
	// 821B1F90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1F94; continue 'dispatch;
            }
            0x821B1F94 => {
    //   block [0x821B1F94..0x821B1FA8)
	// 821B1F94: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1F98: 419A0074  beq cr6, 0x821b200c
	if ctx.cr[6].eq {
	pc = 0x821B200C; continue 'dispatch;
	}
	// 821B1F9C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B1FA0: 409A0008  bne cr6, 0x821b1fa8
	if !ctx.cr[6].eq {
	pc = 0x821B1FA8; continue 'dispatch;
	}
	// 821B1FA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1FA8; continue 'dispatch;
            }
            0x821B1FA8 => {
    //   block [0x821B1FA8..0x821B1FB8)
	// 821B1FA8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1FAC: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1FB0: 41980008  blt cr6, 0x821b1fb8
	if ctx.cr[6].lt {
	pc = 0x821B1FB8; continue 'dispatch;
	}
	// 821B1FB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B1FB8; continue 'dispatch;
            }
            0x821B1FB8 => {
    //   block [0x821B1FB8..0x821B1FF4)
	// 821B1FB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B1FBC: 80850000  lwz r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1FC0: 48619B11  bl 0x827cbad0
	ctx.lr = 0x821B1FC4;
	sub_827CBAD0(ctx, base);
	// 821B1FC4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B1FC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1FCC: 409A0028  bne cr6, 0x821b1ff4
	if !ctx.cr[6].eq {
	pc = 0x821B1FF4; continue 'dispatch;
	}
	// 821B1FD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B1FD4: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B1FD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B1FDC: 4816F0BD  bl 0x82321098
	ctx.lr = 0x821B1FE0;
	sub_82321098(ctx, base);
	// 821B1FE0: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821B1FE4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B1FE8: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B1FEC: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B1FF0: 4BFFFF7C  b 0x821b1f6c
	pc = 0x821B1F6C; continue 'dispatch;
            }
            0x821B1FF4 => {
    //   block [0x821B1FF4..0x821B2004)
	// 821B1FF4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1FF8: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1FFC: 41980008  blt cr6, 0x821b2004
	if ctx.cr[6].lt {
	pc = 0x821B2004; continue 'dispatch;
	}
	// 821B2000: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B2004; continue 'dispatch;
            }
            0x821B2004 => {
    //   block [0x821B2004..0x821B200C)
	// 821B2004: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821B2008: 4BFFFF60  b 0x821b1f68
	pc = 0x821B1F68; continue 'dispatch;
            }
            0x821B200C => {
    //   block [0x821B200C..0x821B2040)
	// 821B200C: 817C00E4  lwz r11, 0xe4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(228 as u32) ) } as u64;
	// 821B2010: 3BFC00E0  addi r31, r28, 0xe0
	ctx.r[31].s64 = ctx.r[28].s64 + 224;
	// 821B2014: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B2018: 419A00D4  beq cr6, 0x821b20ec
	if ctx.cr[6].eq {
	pc = 0x821B20EC; continue 'dispatch;
	}
	// 821B201C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2020: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821B2024: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B2028: 418200C4  beq 0x821b20ec
	if ctx.cr[0].eq {
	pc = 0x821B20EC; continue 'dispatch;
	}
	// 821B202C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2030: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B2034: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2038: 40990008  ble cr6, 0x821b2040
	if !ctx.cr[6].gt {
	pc = 0x821B2040; continue 'dispatch;
	}
	// 821B203C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B2040; continue 'dispatch;
            }
            0x821B2040 => {
    //   block [0x821B2040..0x821B2048)
	// 821B2040: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 821B2044: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	pc = 0x821B2048; continue 'dispatch;
            }
            0x821B2048 => {
    //   block [0x821B2048..0x821B204C)
	// 821B2048: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	pc = 0x821B204C; continue 'dispatch;
            }
            0x821B204C => {
    //   block [0x821B204C..0x821B2060)
	// 821B204C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2050: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2054: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2058: 40990008  ble cr6, 0x821b2060
	if !ctx.cr[6].gt {
	pc = 0x821B2060; continue 'dispatch;
	}
	// 821B205C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B2060; continue 'dispatch;
            }
            0x821B2060 => {
    //   block [0x821B2060..0x821B2070)
	// 821B2060: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B2064: 419A000C  beq cr6, 0x821b2070
	if ctx.cr[6].eq {
	pc = 0x821B2070; continue 'dispatch;
	}
	// 821B2068: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B206C: 419A0008  beq cr6, 0x821b2074
	if ctx.cr[6].eq {
	pc = 0x821B2074; continue 'dispatch;
	}
	pc = 0x821B2070; continue 'dispatch;
            }
            0x821B2070 => {
    //   block [0x821B2070..0x821B2074)
	// 821B2070: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B2074; continue 'dispatch;
            }
            0x821B2074 => {
    //   block [0x821B2074..0x821B2088)
	// 821B2074: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2078: 419A0074  beq cr6, 0x821b20ec
	if ctx.cr[6].eq {
	pc = 0x821B20EC; continue 'dispatch;
	}
	// 821B207C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B2080: 409A0008  bne cr6, 0x821b2088
	if !ctx.cr[6].eq {
	pc = 0x821B2088; continue 'dispatch;
	}
	// 821B2084: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B2088; continue 'dispatch;
            }
            0x821B2088 => {
    //   block [0x821B2088..0x821B2098)
	// 821B2088: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B208C: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2090: 41980008  blt cr6, 0x821b2098
	if ctx.cr[6].lt {
	pc = 0x821B2098; continue 'dispatch;
	}
	// 821B2094: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B2098; continue 'dispatch;
            }
            0x821B2098 => {
    //   block [0x821B2098..0x821B20D4)
	// 821B2098: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B209C: 80850000  lwz r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B20A0: 48619A31  bl 0x827cbad0
	ctx.lr = 0x821B20A4;
	sub_827CBAD0(ctx, base);
	// 821B20A4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B20A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B20AC: 409A0028  bne cr6, 0x821b20d4
	if !ctx.cr[6].eq {
	pc = 0x821B20D4; continue 'dispatch;
	}
	// 821B20B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B20B4: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B20B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B20BC: 4816EFDD  bl 0x82321098
	ctx.lr = 0x821B20C0;
	sub_82321098(ctx, base);
	// 821B20C0: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821B20C4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B20C8: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B20CC: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B20D0: 4BFFFF7C  b 0x821b204c
	pc = 0x821B204C; continue 'dispatch;
            }
            0x821B20D4 => {
    //   block [0x821B20D4..0x821B20E4)
	// 821B20D4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B20D8: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B20DC: 41980008  blt cr6, 0x821b20e4
	if ctx.cr[6].lt {
	pc = 0x821B20E4; continue 'dispatch;
	}
	// 821B20E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B20E4; continue 'dispatch;
            }
            0x821B20E4 => {
    //   block [0x821B20E4..0x821B20EC)
	// 821B20E4: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821B20E8: 4BFFFF60  b 0x821b2048
	pc = 0x821B2048; continue 'dispatch;
            }
            0x821B20EC => {
    //   block [0x821B20EC..0x821B2120)
	// 821B20EC: 817C00F4  lwz r11, 0xf4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(244 as u32) ) } as u64;
	// 821B20F0: 3BFC00F0  addi r31, r28, 0xf0
	ctx.r[31].s64 = ctx.r[28].s64 + 240;
	// 821B20F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B20F8: 419A00D4  beq cr6, 0x821b21cc
	if ctx.cr[6].eq {
	pc = 0x821B21CC; continue 'dispatch;
	}
	// 821B20FC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2100: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821B2104: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B2108: 418200C4  beq 0x821b21cc
	if ctx.cr[0].eq {
	pc = 0x821B21CC; continue 'dispatch;
	}
	// 821B210C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2110: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B2114: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2118: 40990008  ble cr6, 0x821b2120
	if !ctx.cr[6].gt {
	pc = 0x821B2120; continue 'dispatch;
	}
	// 821B211C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B2120; continue 'dispatch;
            }
            0x821B2120 => {
    //   block [0x821B2120..0x821B2128)
	// 821B2120: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 821B2124: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	pc = 0x821B2128; continue 'dispatch;
            }
            0x821B2128 => {
    //   block [0x821B2128..0x821B212C)
	// 821B2128: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	pc = 0x821B212C; continue 'dispatch;
            }
            0x821B212C => {
    //   block [0x821B212C..0x821B2140)
	// 821B212C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2130: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2134: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2138: 40990008  ble cr6, 0x821b2140
	if !ctx.cr[6].gt {
	pc = 0x821B2140; continue 'dispatch;
	}
	// 821B213C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B2140; continue 'dispatch;
            }
            0x821B2140 => {
    //   block [0x821B2140..0x821B2150)
	// 821B2140: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B2144: 419A000C  beq cr6, 0x821b2150
	if ctx.cr[6].eq {
	pc = 0x821B2150; continue 'dispatch;
	}
	// 821B2148: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B214C: 419A0008  beq cr6, 0x821b2154
	if ctx.cr[6].eq {
	pc = 0x821B2154; continue 'dispatch;
	}
	pc = 0x821B2150; continue 'dispatch;
            }
            0x821B2150 => {
    //   block [0x821B2150..0x821B2154)
	// 821B2150: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B2154; continue 'dispatch;
            }
            0x821B2154 => {
    //   block [0x821B2154..0x821B2168)
	// 821B2154: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2158: 419A0074  beq cr6, 0x821b21cc
	if ctx.cr[6].eq {
	pc = 0x821B21CC; continue 'dispatch;
	}
	// 821B215C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B2160: 409A0008  bne cr6, 0x821b2168
	if !ctx.cr[6].eq {
	pc = 0x821B2168; continue 'dispatch;
	}
	// 821B2164: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B2168; continue 'dispatch;
            }
            0x821B2168 => {
    //   block [0x821B2168..0x821B2178)
	// 821B2168: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B216C: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2170: 41980008  blt cr6, 0x821b2178
	if ctx.cr[6].lt {
	pc = 0x821B2178; continue 'dispatch;
	}
	// 821B2174: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B2178; continue 'dispatch;
            }
            0x821B2178 => {
    //   block [0x821B2178..0x821B21B4)
	// 821B2178: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B217C: 80850000  lwz r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2180: 48619951  bl 0x827cbad0
	ctx.lr = 0x821B2184;
	sub_827CBAD0(ctx, base);
	// 821B2184: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B2188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B218C: 409A0028  bne cr6, 0x821b21b4
	if !ctx.cr[6].eq {
	pc = 0x821B21B4; continue 'dispatch;
	}
	// 821B2190: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B2194: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B2198: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B219C: 4816EEFD  bl 0x82321098
	ctx.lr = 0x821B21A0;
	sub_82321098(ctx, base);
	// 821B21A0: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821B21A4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B21A8: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B21AC: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B21B0: 4BFFFF7C  b 0x821b212c
	pc = 0x821B212C; continue 'dispatch;
            }
            0x821B21B4 => {
    //   block [0x821B21B4..0x821B21C4)
	// 821B21B4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B21B8: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B21BC: 41980008  blt cr6, 0x821b21c4
	if ctx.cr[6].lt {
	pc = 0x821B21C4; continue 'dispatch;
	}
	// 821B21C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B21C4; continue 'dispatch;
            }
            0x821B21C4 => {
    //   block [0x821B21C4..0x821B21CC)
	// 821B21C4: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821B21C8: 4BFFFF60  b 0x821b2128
	pc = 0x821B2128; continue 'dispatch;
            }
            0x821B21CC => {
    //   block [0x821B21CC..0x821B21D8)
	// 821B21CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B21D0: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B21D4: 4BFE1675  bl 0x82193848
	ctx.lr = 0x821B21D8;
	sub_82193848(ctx, base);
	pc = 0x821B21D8; continue 'dispatch;
            }
            0x821B21D8 => {
    //   block [0x821B21D8..0x821B21E0)
	// 821B21D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B21DC: 48AF727C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B21E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B21E0 size=156
    let mut pc: u32 = 0x821B21E0;
    'dispatch: loop {
        match pc {
            0x821B21E0 => {
    //   block [0x821B21E0..0x821B2264)
	// 821B21E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B21E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B21E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B21EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B21F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B21F4: 897F0085  lbz r11, 0x85(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(133 as u32) ) } as u64;
	// 821B21F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B21FC: 419A0068  beq cr6, 0x821b2264
	if ctx.cr[6].eq {
	pc = 0x821B2264; continue 'dispatch;
	}
	// 821B2200: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2204: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B2208: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821B220C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2210: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B2214: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821B2218: 4E800421  bctrl
	ctx.lr = 0x821B221C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B221C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821B2220: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 821B2224: C01F0034  lfs f0, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B2228: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821B222C: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B2230: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B2234: 388690F0  addi r4, r6, -0x6f10
	ctx.r[4].s64 = ctx.r[6].s64 + -28432;
            }
            0x821B2264 => {
    //   block [0x821B2264..0x821B227C)
	// 821B2264: 887F0058  lbz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B2268: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B226C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B2270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B2274: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B2278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B2280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B2280 size=272
    let mut pc: u32 = 0x821B2280;
    'dispatch: loop {
        match pc {
            0x821B2280 => {
    //   block [0x821B2280..0x821B22D8)
	// 821B2280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B2284: 48AF7189  bl 0x82ca940c
	ctx.lr = 0x821B2288;
	sub_82CA93D0(ctx, base);
	// 821B2288: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B228C: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 821B2290: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B2294: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B2298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B229C: 419A0074  beq cr6, 0x821b2310
	if ctx.cr[6].eq {
	pc = 0x821B2310; continue 'dispatch;
	}
	// 821B22A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B22A4: 481FE795  bl 0x823b0a38
	ctx.lr = 0x821B22A8;
	sub_823B0A38(ctx, base);
	// 821B22A8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821B22AC: 3BDF0070  addi r30, r31, 0x70
	ctx.r[30].s64 = ctx.r[31].s64 + 112;
	// 821B22B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B22B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B22B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B22BC: 481C31C5  bl 0x82375480
	ctx.lr = 0x821B22C0;
	sub_82375480(ctx, base);
	// 821B22C0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B22C4: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B22C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B22CC: 419A000C  beq cr6, 0x821b22d8
	if ctx.cr[6].eq {
	pc = 0x821B22D8; continue 'dispatch;
	}
	// 821B22D0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B22D4: 419A0008  beq cr6, 0x821b22dc
	if ctx.cr[6].eq {
	pc = 0x821B22DC; continue 'dispatch;
	}
	pc = 0x821B22D8; continue 'dispatch;
            }
            0x821B22D8 => {
    //   block [0x821B22D8..0x821B22DC)
	// 821B22D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B22DC; continue 'dispatch;
            }
            0x821B22DC => {
    //   block [0x821B22DC..0x821B22F4)
	// 821B22DC: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821B22E0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B22E4: 419A002C  beq cr6, 0x821b2310
	if ctx.cr[6].eq {
	pc = 0x821B2310; continue 'dispatch;
	}
	// 821B22E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B22EC: 409A0008  bne cr6, 0x821b22f4
	if !ctx.cr[6].eq {
	pc = 0x821B22F4; continue 'dispatch;
	}
	// 821B22F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B22F4; continue 'dispatch;
            }
            0x821B22F4 => {
    //   block [0x821B22F4..0x821B2304)
	// 821B22F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B22F8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B22FC: 409A0008  bne cr6, 0x821b2304
	if !ctx.cr[6].eq {
	pc = 0x821B2304; continue 'dispatch;
	}
	// 821B2300: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B2304; continue 'dispatch;
            }
            0x821B2304 => {
    //   block [0x821B2304..0x821B2310)
	// 821B2304: C0290010  lfs f1, 0x10(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B2308: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B230C: 48AF7150  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B2310 => {
    //   block [0x821B2310..0x821B2348)
	// 821B2310: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B2314: 481FE725  bl 0x823b0a38
	ctx.lr = 0x821B2318;
	sub_823B0A38(ctx, base);
	// 821B2318: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821B231C: 3BDF0064  addi r30, r31, 0x64
	ctx.r[30].s64 = ctx.r[31].s64 + 100;
	// 821B2320: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B2324: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B2328: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B232C: 481C3155  bl 0x82375480
	ctx.lr = 0x821B2330;
	sub_82375480(ctx, base);
	// 821B2330: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B2334: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 821B2338: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B233C: 419A000C  beq cr6, 0x821b2348
	if ctx.cr[6].eq {
	pc = 0x821B2348; continue 'dispatch;
	}
	// 821B2340: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B2344: 419A0008  beq cr6, 0x821b234c
	if ctx.cr[6].eq {
	pc = 0x821B234C; continue 'dispatch;
	}
	pc = 0x821B2348; continue 'dispatch;
            }
            0x821B2348 => {
    //   block [0x821B2348..0x821B234C)
	// 821B2348: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B234C; continue 'dispatch;
            }
            0x821B234C => {
    //   block [0x821B234C..0x821B2364)
	// 821B234C: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821B2350: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B2354: 419A002C  beq cr6, 0x821b2380
	if ctx.cr[6].eq {
	pc = 0x821B2380; continue 'dispatch;
	}
	// 821B2358: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B235C: 409A0008  bne cr6, 0x821b2364
	if !ctx.cr[6].eq {
	pc = 0x821B2364; continue 'dispatch;
	}
	// 821B2360: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B2364; continue 'dispatch;
            }
            0x821B2364 => {
    //   block [0x821B2364..0x821B2380)
	// 821B2364: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2368: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B236C: 409AFF98  bne cr6, 0x821b2304
	if !ctx.cr[6].eq {
	pc = 0x821B2304; continue 'dispatch;
	}
	// 821B2370: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B2374: C0290010  lfs f1, 0x10(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B2378: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B237C: 48AF70E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B2380 => {
    //   block [0x821B2380..0x821B2390)
	// 821B2380: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B2384: C02B9490  lfs f1, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B2388: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B238C: 48AF70D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B2390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B2390 size=336
    let mut pc: u32 = 0x821B2390;
    'dispatch: loop {
        match pc {
            0x821B2390 => {
    //   block [0x821B2390..0x821B23BC)
	// 821B2390: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B2394: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B2398: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B239C: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B23A0: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821B23A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B23A8: 419A0014  beq cr6, 0x821b23bc
	if ctx.cr[6].eq {
	pc = 0x821B23BC; continue 'dispatch;
	}
	// 821B23AC: 896B0035  lbz r11, 0x35(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 821B23B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B23B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B23B8: 409A0008  bne cr6, 0x821b23c0
	if !ctx.cr[6].eq {
	pc = 0x821B23C0; continue 'dispatch;
	}
	pc = 0x821B23BC; continue 'dispatch;
            }
            0x821B23BC => {
    //   block [0x821B23BC..0x821B23C0)
	// 821B23BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B23C0; continue 'dispatch;
            }
            0x821B23C0 => {
    //   block [0x821B23C0..0x821B2404)
	// 821B23C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B23C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B23C8: 409A0118  bne cr6, 0x821b24e0
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821B24E0);
		return;
	}
	// 821B23CC: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B23D0: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 821B23D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B23D8: 419A00EC  beq cr6, 0x821b24c4
	if ctx.cr[6].eq {
	pc = 0x821B24C4; continue 'dispatch;
	}
	// 821B23DC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B23E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B23E4: 419A0020  beq cr6, 0x821b2404
	if ctx.cr[6].eq {
	pc = 0x821B2404; continue 'dispatch;
	}
	// 821B23E8: 894B005B  lbz r10, 0x5b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(91 as u32) ) } as u64;
	// 821B23EC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B23F0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B23F4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B23F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B23FC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2400: 480000CC  b 0x821b24cc
	pc = 0x821B24CC; continue 'dispatch;
            }
            0x821B2404 => {
    //   block [0x821B2404..0x821B2424)
	// 821B2404: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B2408: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B240C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B2410: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 821B2414: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B2418: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 821B241C: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B2420: 40810054  ble 0x821b2474
	if !ctx.cr[0].gt {
	pc = 0x821B2474; continue 'dispatch;
	}
	pc = 0x821B2424; continue 'dispatch;
            }
            0x821B2424 => {
    //   block [0x821B2424..0x821B2444)
	// 821B2424: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B2428: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B242C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B2430: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2434: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 821B2438: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B243C: 41980008  blt cr6, 0x821b2444
	if ctx.cr[6].lt {
	pc = 0x821B2444; continue 'dispatch;
	}
	// 821B2440: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821B2444; continue 'dispatch;
            }
            0x821B2444 => {
    //   block [0x821B2444..0x821B2460)
	// 821B2444: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B2448: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B244C: 419A0014  beq cr6, 0x821b2460
	if ctx.cr[6].eq {
	pc = 0x821B2460; continue 'dispatch;
	}
	// 821B2450: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B2454: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B2458: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B245C: 4800000C  b 0x821b2468
	pc = 0x821B2468; continue 'dispatch;
            }
            0x821B2460 => {
    //   block [0x821B2460..0x821B2468)
	// 821B2460: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B2464: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821B2468; continue 'dispatch;
            }
            0x821B2468 => {
    //   block [0x821B2468..0x821B2474)
	// 821B2468: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B246C: 4199FFB8  bgt cr6, 0x821b2424
	if ctx.cr[6].gt {
	pc = 0x821B2424; continue 'dispatch;
	}
	// 821B2470: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	pc = 0x821B2474; continue 'dispatch;
            }
            0x821B2474 => {
    //   block [0x821B2474..0x821B2490)
	// 821B2474: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B2478: 419A003C  beq cr6, 0x821b24b4
	if ctx.cr[6].eq {
	pc = 0x821B24B4; continue 'dispatch;
	}
	// 821B247C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2480: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 821B2484: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B2488: 41990008  bgt cr6, 0x821b2490
	if ctx.cr[6].gt {
	pc = 0x821B2490; continue 'dispatch;
	}
	// 821B248C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B2490; continue 'dispatch;
            }
            0x821B2490 => {
    //   block [0x821B2490..0x821B24B4)
	// 821B2490: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B2494: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B2498: 409A001C  bne cr6, 0x821b24b4
	if !ctx.cr[6].eq {
	pc = 0x821B24B4; continue 'dispatch;
	}
	// 821B249C: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B24A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B24A4: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821B24A8: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821B24AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B24B0: 4800001C  b 0x821b24cc
	pc = 0x821B24CC; continue 'dispatch;
            }
            0x821B24B4 => {
    //   block [0x821B24B4..0x821B24C4)
	// 821B24B4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B24B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B24BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B24C0: 4800000C  b 0x821b24cc
	pc = 0x821B24CC; continue 'dispatch;
            }
            0x821B24C4 => {
    //   block [0x821B24C4..0x821B24CC)
	// 821B24C4: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821B24C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821B24CC; continue 'dispatch;
            }
            0x821B24CC => {
    //   block [0x821B24CC..0x821B24E0)
	// 821B24CC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B24D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B24D4: 419A000C  beq cr6, 0x821b24e0
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821B24E0);
		return;
	}
	// 821B24D8: E86B0078  ld r3, 0x78(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) };
	// 821B24DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B24F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B24F8 size=120
    let mut pc: u32 = 0x821B24F8;
    'dispatch: loop {
        match pc {
            0x821B24F8 => {
    //   block [0x821B24F8..0x821B2540)
	// 821B24F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B24FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B2500: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B2504: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2508: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821B250C: 419A0050  beq cr6, 0x821b255c
	if ctx.cr[6].eq {
	pc = 0x821B255C; continue 'dispatch;
	}
	// 821B2510: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2514: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B2518: 409A0044  bne cr6, 0x821b255c
	if !ctx.cr[6].eq {
	pc = 0x821B255C; continue 'dispatch;
	}
	// 821B251C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B2520: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B2524: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B2528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B252C: 409A0014  bne cr6, 0x821b2540
	if !ctx.cr[6].eq {
	pc = 0x821B2540; continue 'dispatch;
	}
	// 821B2530: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B2534: 816B6AC0  lwz r11, 0x6ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27328 as u32) ) } as u64;
	// 821B2538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B253C: 419A0024  beq cr6, 0x821b2560
	if ctx.cr[6].eq {
	pc = 0x821B2560; continue 'dispatch;
	}
	pc = 0x821B2540; continue 'dispatch;
            }
            0x821B2540 => {
    //   block [0x821B2540..0x821B255C)
	// 821B2540: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B2544: 806B6DA0  lwz r3, 0x6da0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B2548: 48031D09  bl 0x821e4250
	ctx.lr = 0x821B254C;
	sub_821E4250(ctx, base);
	// 821B254C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B2550: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B2554: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B2558: 4E800020  blr
	return;
            }
            0x821B255C => {
    //   block [0x821B255C..0x821B2560)
	// 821B255C: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821B2560; continue 'dispatch;
            }
            0x821B2560 => {
    //   block [0x821B2560..0x821B2570)
	// 821B2560: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B2564: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B2568: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B256C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B2570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B2570 size=136
    let mut pc: u32 = 0x821B2570;
    'dispatch: loop {
        match pc {
            0x821B2570 => {
    //   block [0x821B2570..0x821B25A4)
	// 821B2570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B2574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B2578: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B257C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B2580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B2584: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B2588: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B258C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2590: 7F1E2840  cmplw cr6, r30, r5
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821B2594: 40990048  ble cr6, 0x821b25dc
	if !ctx.cr[6].gt {
	pc = 0x821B25DC; continue 'dispatch;
	}
	// 821B2598: 2B1E0020  cmplwi cr6, r30, 0x20
	ctx.cr[6].compare_u32(ctx.r[30].u32, 32 as u32, &mut ctx.xer);
	// 821B259C: 40980008  bge cr6, 0x821b25a4
	if !ctx.cr[6].lt {
	pc = 0x821B25A4; continue 'dispatch;
	}
	// 821B25A0: 3BC00020  li r30, 0x20
	ctx.r[30].s64 = 32;
	pc = 0x821B25A4; continue 'dispatch;
            }
            0x821B25A4 => {
    //   block [0x821B25A4..0x821B25C4)
	// 821B25A4: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 821B25A8: 3940FFFD  li r10, -3
	ctx.r[10].s64 = -3;
	// 821B25AC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B25B0: 41990014  bgt cr6, 0x821b25c4
	if ctx.cr[6].gt {
	pc = 0x821B25C4; continue 'dispatch;
	}
	// 821B25B4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821B25B8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B25BC: 48075265  bl 0x82227820
	ctx.lr = 0x821B25C0;
	sub_82227820(ctx, base);
	// 821B25C0: 48000014  b 0x821b25d4
	pc = 0x821B25D4; continue 'dispatch;
            }
            0x821B25C4 => {
    //   block [0x821B25C4..0x821B25D4)
	// 821B25C4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821B25C8: 388B3AB8  addi r4, r11, 0x3ab8
	ctx.r[4].s64 = ctx.r[11].s64 + 15032;
	// 821B25CC: 4887F8DD  bl 0x82a31ea8
	ctx.lr = 0x821B25D0;
	sub_82A31EA8(ctx, base);
	// 821B25D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821B25D4; continue 'dispatch;
            }
            0x821B25D4 => {
    //   block [0x821B25D4..0x821B25DC)
	// 821B25D4: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821B25D8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x821B25DC; continue 'dispatch;
            }
            0x821B25DC => {
    //   block [0x821B25DC..0x821B25F8)
	// 821B25DC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B25E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B25E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B25E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B25EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B25F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B25F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B25F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B25F8 size=2628
    let mut pc: u32 = 0x821B25F8;
    'dispatch: loop {
        match pc {
            0x821B25F8 => {
    //   block [0x821B25F8..0x821B2640)
	// 821B25F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B25FC: 48AF6DE5  bl 0x82ca93e0
	ctx.lr = 0x821B2600;
	sub_82CA93D0(ctx, base);
	// 821B2600: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B2604: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 821B2608: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B260C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821B2610: 3AEB9490  addi r23, r11, -0x6b70
	ctx.r[23].s64 = ctx.r[11].s64 + -27504;
	// 821B2614: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 821B2618: 81740040  lwz r11, 0x40(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B261C: 7CD33378  mr r19, r6
	ctx.r[19].u64 = ctx.r[6].u64;
	// 821B2620: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 821B2624: 3ACB0024  addi r22, r11, 0x24
	ctx.r[22].s64 = ctx.r[11].s64 + 36;
	// 821B2628: C017FFF4  lfs f0, -0xc(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B262C: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 821B2630: C1AB0030  lfs f13, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B2634: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B2638: 41990008  bgt cr6, 0x821b2640
	if ctx.cr[6].gt {
	pc = 0x821B2640; continue 'dispatch;
	}
	// 821B263C: 7E589378  mr r24, r18
	ctx.r[24].u64 = ctx.r[18].u64;
	pc = 0x821B2640; continue 'dispatch;
            }
            0x821B2640 => {
    //   block [0x821B2640..0x821B303C)
	// 821B2640: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 821B2644: 39410100  addi r10, r1, 0x100
	ctx.r[10].s64 = ctx.r[1].s64 + 256;
	// 821B2648: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 821B264C: 39210110  addi r9, r1, 0x110
	ctx.r[9].s64 = ctx.r[1].s64 + 272;
	// 821B2650: 39010120  addi r8, r1, 0x120
	ctx.r[8].s64 = ctx.r[1].s64 + 288;
	// 821B2654: 92410130  stw r18, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[18].u32 ) };
	// 821B2658: 9A410134  stb r18, 0x134(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[18].u8 ) };
	// 821B265C: 388B0050  addi r4, r11, 0x50
	ctx.r[4].s64 = ctx.r[11].s64 + 80;
	// 821B2660: 1180030A  vcfux v12, v0, 0
	// vcfux/vcuxwfp128: ctx.v[12].f32[i] = ( ctx.v[0].u32[i] as f32 ) * (2.0f32).powi(0);
	for i in 0..4 { ctx.v[12].f32[i] = (ctx.v[0].u32[i] as f32) * (2.0f32).powi(0); }
	// 821B2664: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B3048 size=256
    let mut pc: u32 = 0x821B3048;
    'dispatch: loop {
        match pc {
            0x821B3048 => {
    //   block [0x821B3048..0x821B3088)
	// 821B3048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B304C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B3050: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B3054: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B3058: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B305C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B3060: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B3064: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 821B3068: 3BDF018C  addi r30, r31, 0x18c
	ctx.r[30].s64 = ctx.r[31].s64 + 396;
	// 821B306C: C01F0188  lfs f0, 0x188(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3070: C1BF018C  lfs f13, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3074: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B3078: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B307C: 4199000C  bgt cr6, 0x821b3088
	if ctx.cr[6].gt {
	pc = 0x821B3088; continue 'dispatch;
	}
	// 821B3080: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821B3084: 48000010  b 0x821b3094
	pc = 0x821B3094; continue 'dispatch;
            }
            0x821B3088 => {
    //   block [0x821B3088..0x821B3094)
	// 821B3088: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B308C: EDAC0024  fdivs f13, f12, f0
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 821B3090: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x821B3094; continue 'dispatch;
            }
            0x821B3094 => {
    //   block [0x821B3094..0x821B30B8)
	// 821B3094: C01F0184  lfs f0, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3098: 397F0184  addi r11, r31, 0x184
	ctx.r[11].s64 = ctx.r[31].s64 + 388;
	// 821B309C: C1BF0180  lfs f13, 0x180(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B30A0: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B30A4: 395F0180  addi r10, r31, 0x180
	ctx.r[10].s64 = ctx.r[31].s64 + 384;
	// 821B30A8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B30AC: 4199000C  bgt cr6, 0x821b30b8
	if ctx.cr[6].gt {
	pc = 0x821B30B8; continue 'dispatch;
	}
	// 821B30B0: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B30B4: 48000010  b 0x821b30c4
	pc = 0x821B30C4; continue 'dispatch;
            }
            0x821B30B8 => {
    //   block [0x821B30B8..0x821B30C4)
	// 821B30B8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B30BC: EDAC0024  fdivs f13, f12, f0
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 821B30C0: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x821B30C4; continue 'dispatch;
            }
            0x821B30C4 => {
    //   block [0x821B30C4..0x821B3148)
	// 821B30C4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B3148 size=3688
    let mut pc: u32 = 0x821B3148;
    'dispatch: loop {
        match pc {
            0x821B3148 => {
    //   block [0x821B3148..0x821B31B4)
	// 821B3148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B314C: 48AF62A5  bl 0x82ca93f0
	ctx.lr = 0x821B3150;
	sub_82CA93D0(ctx, base);
	// 821B3150: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B3154: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B3158: F8810120  std r4, 0x120(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[4].u64 ) };
	// 821B315C: F8A10128  std r5, 0x128(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[5].u64 ) };
	// 821B3160: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B3164: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821B3168: 419A0E3C  beq cr6, 0x821b3fa4
	if ctx.cr[6].eq {
	pc = 0x821B3FA4; continue 'dispatch;
	}
	// 821B316C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821B3170: 419A0E34  beq cr6, 0x821b3fa4
	if ctx.cr[6].eq {
	pc = 0x821B3FA4; continue 'dispatch;
	}
	// 821B3174: 817D0100  lwz r11, 0x100(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(256 as u32) ) } as u64;
	// 821B3178: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821B317C: 419A0E28  beq cr6, 0x821b3fa4
	if ctx.cr[6].eq {
	pc = 0x821B3FA4; continue 'dispatch;
	}
	// 821B3180: 817D019C  lwz r11, 0x19c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(412 as u32) ) } as u64;
	// 821B3184: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B3188: 419A0E1C  beq cr6, 0x821b3fa4
	if ctx.cr[6].eq {
	pc = 0x821B3FA4; continue 'dispatch;
	}
	// 821B318C: 81610120  lwz r11, 0x120(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(288 as u32) ) } as u64;
	// 821B3190: 81410124  lwz r10, 0x124(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 821B3194: 81210128  lwz r9, 0x128(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(296 as u32) ) } as u64;
	// 821B3198: 811D009C  lwz r8, 0x9c(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B319C: 917D0054  stw r11, 0x54(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821B31A0: 2F08000A  cmpwi cr6, r8, 0xa
	ctx.cr[6].compare_i32(ctx.r[8].s32, 10, &mut ctx.xer);
	// 821B31A4: 915D0058  stw r10, 0x58(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821B31A8: 913D005C  stw r9, 0x5c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821B31AC: 419A0008  beq cr6, 0x821b31b4
	if ctx.cr[6].eq {
	pc = 0x821B31B4; continue 'dispatch;
	}
	// 821B31B0: 481469C1  bl 0x822f9b70
	ctx.lr = 0x821B31B4;
	sub_822F9B70(ctx, base);
	pc = 0x821B31B4; continue 'dispatch;
            }
            0x821B31B4 => {
    //   block [0x821B31B4..0x821B31D0)
	// 821B31B4: 897D006E  lbz r11, 0x6e(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(110 as u32) ) } as u64;
	// 821B31B8: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821B31BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B31C0: 419A0010  beq cr6, 0x821b31d0
	if ctx.cr[6].eq {
	pc = 0x821B31D0; continue 'dispatch;
	}
	// 821B31C4: 480B2EED  bl 0x822660b0
	ctx.lr = 0x821B31C8;
	sub_822660B0(ctx, base);
	// 821B31C8: 9AFD006E  stb r23, 0x6e(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(110 as u32), ctx.r[23].u8 ) };
	// 821B31CC: 48000008  b 0x821b31d4
	pc = 0x821B31D4; continue 'dispatch;
            }
            0x821B31D0 => {
    //   block [0x821B31D0..0x821B31D4)
	// 821B31D0: 480B2EE1  bl 0x822660b0
	ctx.lr = 0x821B31D4;
	sub_822660B0(ctx, base);
	pc = 0x821B31D4; continue 'dispatch;
            }
            0x821B31D4 => {
    //   block [0x821B31D4..0x821B31F8)
	// 821B31D4: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 821B31D8: 907D0070  stw r3, 0x70(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 821B31DC: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 821B31E0: 81596AB8  lwz r10, 0x6ab8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B31E4: 89386A5E  lbz r9, 0x6a5e(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(27230 as u32) ) } as u64;
	// 821B31E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B31EC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B31F0: 409A0008  bne cr6, 0x821b31f8
	if !ctx.cr[6].eq {
	pc = 0x821B31F8; continue 'dispatch;
	}
	// 821B31F4: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x821B31F8; continue 'dispatch;
            }
            0x821B31F8 => {
    //   block [0x821B31F8..0x821B325C)
	// 821B31F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B31FC: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 821B3200: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 821B3204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3208: 419A02CC  beq cr6, 0x821b34d4
	if ctx.cr[6].eq {
	pc = 0x821B34D4; continue 'dispatch;
	}
	// 821B320C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B3210: 890B0104  lbz r8, 0x104(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 821B3214: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B3218: 409A02BC  bne cr6, 0x821b34d4
	if !ctx.cr[6].eq {
	pc = 0x821B34D4; continue 'dispatch;
	}
	// 821B321C: 92E10084  stw r23, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[23].u32 ) };
	// 821B3220: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821B3224: 92E10088  stw r23, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[23].u32 ) };
	// 821B3228: 38800058  li r4, 0x58
	ctx.r[4].s64 = 88;
	// 821B322C: 92E1008C  stw r23, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[23].u32 ) };
	// 821B3230: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B3234: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B3238: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B323C: 80DD01D8  lwz r6, 0x1d8(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(472 as u32) ) } as u64;
	// 821B3240: 80690010  lwz r3, 0x10(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B3244: 48015FBD  bl 0x821c9200
	ctx.lr = 0x821B3248;
	sub_821C9200(ctx, base);
	// 821B3248: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B324C: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 821B3250: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3254: 40990008  ble cr6, 0x821b325c
	if !ctx.cr[6].gt {
	pc = 0x821B325C; continue 'dispatch;
	}
	// 821B3258: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B325C; continue 'dispatch;
            }
            0x821B325C => {
    //   block [0x821B325C..0x821B3268)
	// 821B325C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B3260: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 821B3264: 3B8B72DC  addi r28, r11, 0x72dc
	ctx.r[28].s64 = ctx.r[11].s64 + 29404;
	pc = 0x821B3268; continue 'dispatch;
            }
            0x821B3268 => {
    //   block [0x821B3268..0x821B3274)
	// 821B3268: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B326C: 40990008  ble cr6, 0x821b3274
	if !ctx.cr[6].gt {
	pc = 0x821B3274; continue 'dispatch;
	}
	// 821B3270: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3274; continue 'dispatch;
            }
            0x821B3274 => {
    //   block [0x821B3274..0x821B3284)
	// 821B3274: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3278: 419A00F8  beq cr6, 0x821b3370
	if ctx.cr[6].eq {
	pc = 0x821B3370; continue 'dispatch;
	}
	// 821B327C: 41980008  blt cr6, 0x821b3284
	if ctx.cr[6].lt {
	pc = 0x821B3284; continue 'dispatch;
	}
	// 821B3280: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3284; continue 'dispatch;
            }
            0x821B3284 => {
    //   block [0x821B3284..0x821B32B8)
	// 821B3284: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3288: 811D01D8  lwz r8, 0x1d8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(472 as u32) ) } as u64;
	// 821B328C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B3290: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821B3294: 409900C8  ble cr6, 0x821b335c
	if !ctx.cr[6].gt {
	pc = 0x821B335C; continue 'dispatch;
	}
	// 821B3298: 917D01D8  stw r11, 0x1d8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 821B329C: 3BDD0170  addi r30, r29, 0x170
	ctx.r[30].s64 = ctx.r[29].s64 + 368;
	// 821B32A0: 9AFD0221  stb r23, 0x221(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(545 as u32), ctx.r[23].u8 ) };
	// 821B32A4: 815D0174  lwz r10, 0x174(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(372 as u32) ) } as u64;
	// 821B32A8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821B32AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B32B0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B32B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821B32B8; continue 'dispatch;
            }
            0x821B32B8 => {
    //   block [0x821B32B8..0x821B32CC)
	// 821B32B8: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B32BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B32C0: 419A000C  beq cr6, 0x821b32cc
	if ctx.cr[6].eq {
	pc = 0x821B32CC; continue 'dispatch;
	}
	// 821B32C4: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B32C8: 419A0008  beq cr6, 0x821b32d0
	if ctx.cr[6].eq {
	pc = 0x821B32D0; continue 'dispatch;
	}
	pc = 0x821B32CC; continue 'dispatch;
            }
            0x821B32CC => {
    //   block [0x821B32CC..0x821B32D0)
	// 821B32CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B32D0; continue 'dispatch;
            }
            0x821B32D0 => {
    //   block [0x821B32D0..0x821B32E4)
	// 821B32D0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B32D4: 419A0080  beq cr6, 0x821b3354
	if ctx.cr[6].eq {
	pc = 0x821B3354; continue 'dispatch;
	}
	// 821B32D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B32DC: 409A0008  bne cr6, 0x821b32e4
	if !ctx.cr[6].eq {
	pc = 0x821B32E4; continue 'dispatch;
	}
	// 821B32E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B32E4; continue 'dispatch;
            }
            0x821B32E4 => {
    //   block [0x821B32E4..0x821B32F4)
	// 821B32E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B32E8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B32EC: 409A0008  bne cr6, 0x821b32f4
	if !ctx.cr[6].eq {
	pc = 0x821B32F4; continue 'dispatch;
	}
	// 821B32F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B32F4; continue 'dispatch;
            }
            0x821B32F4 => {
    //   block [0x821B32F4..0x821B3340)
	// 821B32F4: 83EA0018  lwz r31, 0x18(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B32F8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821B32FC: 92C10060  stw r22, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[22].u32 ) };
	// 821B3300: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3304: E97F0078  ld r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	// 821B3308: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821B330C: 4814BB85  bl 0x822fee90
	ctx.lr = 0x821B3310;
	sub_822FEE90(ctx, base);
	// 821B3310: 3BFF006C  addi r31, r31, 0x6c
	ctx.r[31].s64 = ctx.r[31].s64 + 108;
	// 821B3314: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3318: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 821B331C: 419A0024  beq cr6, 0x821b3340
	if ctx.cr[6].eq {
	pc = 0x821B3340; continue 'dispatch;
	}
	// 821B3320: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3324: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B3328: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 821B332C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B3330: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821B3334: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B3338: 488E4031  bl 0x82a97368
	ctx.lr = 0x821B333C;
	sub_82A97368(ctx, base);
	// 821B333C: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x821B3340; continue 'dispatch;
            }
            0x821B3340 => {
    //   block [0x821B3340..0x821B3354)
	// 821B3340: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B3344: 481617E5  bl 0x82314b28
	ctx.lr = 0x821B3348;
	sub_82314B28(ctx, base);
	// 821B3348: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B334C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B3350: 4BFFFF68  b 0x821b32b8
	pc = 0x821B32B8; continue 'dispatch;
            }
            0x821B3354 => {
    //   block [0x821B3354..0x821B335C)
	// 821B3354: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 821B3358: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	pc = 0x821B335C; continue 'dispatch;
            }
            0x821B335C => {
    //   block [0x821B335C..0x821B3368)
	// 821B335C: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3360: 41980008  blt cr6, 0x821b3368
	if ctx.cr[6].lt {
	pc = 0x821B3368; continue 'dispatch;
	}
	// 821B3364: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3368; continue 'dispatch;
            }
            0x821B3368 => {
    //   block [0x821B3368..0x821B3370)
	// 821B3368: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 821B336C: 4BFFFEFC  b 0x821b3268
	pc = 0x821B3268; continue 'dispatch;
            }
            0x821B3370 => {
    //   block [0x821B3370..0x821B33B0)
	// 821B3370: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821B3374: 4BFFE835  bl 0x821b1ba8
	ctx.lr = 0x821B3378;
	sub_821B1BA8(ctx, base);
	// 821B3378: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B337C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821B3380: 80DD01D8  lwz r6, 0x1d8(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(472 as u32) ) } as u64;
	// 821B3384: 38800059  li r4, 0x59
	ctx.r[4].s64 = 89;
	// 821B3388: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B338C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B3390: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3394: 80690010  lwz r3, 0x10(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B3398: 48015E69  bl 0x821c9200
	ctx.lr = 0x821B339C;
	sub_821C9200(ctx, base);
	// 821B339C: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B33A0: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 821B33A4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B33A8: 40990008  ble cr6, 0x821b33b0
	if !ctx.cr[6].gt {
	pc = 0x821B33B0; continue 'dispatch;
	}
	// 821B33AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B33B0; continue 'dispatch;
            }
            0x821B33B0 => {
    //   block [0x821B33B0..0x821B33BC)
	// 821B33B0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B33B4: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 821B33B8: 3B8B72E8  addi r28, r11, 0x72e8
	ctx.r[28].s64 = ctx.r[11].s64 + 29416;
	pc = 0x821B33BC; continue 'dispatch;
            }
            0x821B33BC => {
    //   block [0x821B33BC..0x821B33C8)
	// 821B33BC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B33C0: 40990008  ble cr6, 0x821b33c8
	if !ctx.cr[6].gt {
	pc = 0x821B33C8; continue 'dispatch;
	}
	// 821B33C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B33C8; continue 'dispatch;
            }
            0x821B33C8 => {
    //   block [0x821B33C8..0x821B33D8)
	// 821B33C8: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B33CC: 419A00F8  beq cr6, 0x821b34c4
	if ctx.cr[6].eq {
	pc = 0x821B34C4; continue 'dispatch;
	}
	// 821B33D0: 41980008  blt cr6, 0x821b33d8
	if ctx.cr[6].lt {
	pc = 0x821B33D8; continue 'dispatch;
	}
	// 821B33D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B33D8; continue 'dispatch;
            }
            0x821B33D8 => {
    //   block [0x821B33D8..0x821B340C)
	// 821B33D8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B33DC: 811D01D8  lwz r8, 0x1d8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(472 as u32) ) } as u64;
	// 821B33E0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B33E4: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821B33E8: 409900C8  ble cr6, 0x821b34b0
	if !ctx.cr[6].gt {
	pc = 0x821B34B0; continue 'dispatch;
	}
	// 821B33EC: 917D01D8  stw r11, 0x1d8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 821B33F0: 3BDD0170  addi r30, r29, 0x170
	ctx.r[30].s64 = ctx.r[29].s64 + 368;
	// 821B33F4: 9ADD0221  stb r22, 0x221(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(545 as u32), ctx.r[22].u8 ) };
	// 821B33F8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821B33FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B3400: 815D0174  lwz r10, 0x174(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(372 as u32) ) } as u64;
	// 821B3404: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3408: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821B340C; continue 'dispatch;
            }
            0x821B340C => {
    //   block [0x821B340C..0x821B3420)
	// 821B340C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3414: 419A000C  beq cr6, 0x821b3420
	if ctx.cr[6].eq {
	pc = 0x821B3420; continue 'dispatch;
	}
	// 821B3418: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B341C: 419A0008  beq cr6, 0x821b3424
	if ctx.cr[6].eq {
	pc = 0x821B3424; continue 'dispatch;
	}
	pc = 0x821B3420; continue 'dispatch;
            }
            0x821B3420 => {
    //   block [0x821B3420..0x821B3424)
	// 821B3420: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3424; continue 'dispatch;
            }
            0x821B3424 => {
    //   block [0x821B3424..0x821B3438)
	// 821B3424: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B3428: 419A0080  beq cr6, 0x821b34a8
	if ctx.cr[6].eq {
	pc = 0x821B34A8; continue 'dispatch;
	}
	// 821B342C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3430: 409A0008  bne cr6, 0x821b3438
	if !ctx.cr[6].eq {
	pc = 0x821B3438; continue 'dispatch;
	}
	// 821B3434: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3438; continue 'dispatch;
            }
            0x821B3438 => {
    //   block [0x821B3438..0x821B3448)
	// 821B3438: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B343C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3440: 409A0008  bne cr6, 0x821b3448
	if !ctx.cr[6].eq {
	pc = 0x821B3448; continue 'dispatch;
	}
	// 821B3444: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3448; continue 'dispatch;
            }
            0x821B3448 => {
    //   block [0x821B3448..0x821B3494)
	// 821B3448: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B344C: 815D0020  lwz r10, 0x20(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B3450: 812B0060  lwz r9, 0x60(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 821B3454: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3458: 409A003C  bne cr6, 0x821b3494
	if !ctx.cr[6].eq {
	pc = 0x821B3494; continue 'dispatch;
	}
	// 821B345C: E94B0078  ld r10, 0x78(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) };
	// 821B3460: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821B3464: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 821B3468: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B346C: 3BEB0078  addi r31, r11, 0x78
	ctx.r[31].s64 = ctx.r[11].s64 + 120;
	// 821B3470: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 821B3474: 4814BA1D  bl 0x822fee90
	ctx.lr = 0x821B3478;
	sub_822FEE90(ctx, base);
	// 821B3478: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B347C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 821B3480: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B3484: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B3488: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821B348C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B3490: 4814D689  bl 0x82300b18
	ctx.lr = 0x821B3494;
	sub_82300B18(ctx, base);
	pc = 0x821B3494; continue 'dispatch;
            }
            0x821B3494 => {
    //   block [0x821B3494..0x821B34A8)
	// 821B3494: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B3498: 48161691  bl 0x82314b28
	ctx.lr = 0x821B349C;
	sub_82314B28(ctx, base);
	// 821B349C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B34A0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B34A4: 4BFFFF68  b 0x821b340c
	pc = 0x821B340C; continue 'dispatch;
            }
            0x821B34A8 => {
    //   block [0x821B34A8..0x821B34B0)
	// 821B34A8: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 821B34AC: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	pc = 0x821B34B0; continue 'dispatch;
            }
            0x821B34B0 => {
    //   block [0x821B34B0..0x821B34BC)
	// 821B34B0: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B34B4: 41980008  blt cr6, 0x821b34bc
	if ctx.cr[6].lt {
	pc = 0x821B34BC; continue 'dispatch;
	}
	// 821B34B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B34BC; continue 'dispatch;
            }
            0x821B34BC => {
    //   block [0x821B34BC..0x821B34C4)
	// 821B34BC: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 821B34C0: 4BFFFEFC  b 0x821b33bc
	pc = 0x821B33BC; continue 'dispatch;
            }
            0x821B34C4 => {
    //   block [0x821B34C4..0x821B34D4)
	// 821B34C4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821B34C8: 48406A99  bl 0x825b9f60
	ctx.lr = 0x821B34CC;
	sub_825B9F60(ctx, base);
	// 821B34CC: 89386A5E  lbz r9, 0x6a5e(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(27230 as u32) ) } as u64;
	// 821B34D0: 81596AB8  lwz r10, 0x6ab8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	pc = 0x821B34D4; continue 'dispatch;
            }
            0x821B34D4 => {
    //   block [0x821B34D4..0x821B3520)
	// 821B34D4: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B34D8: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 821B34DC: 41990AAC  bgt cr6, 0x821b3f88
	if ctx.cr[6].gt {
	pc = 0x821B3F88; continue 'dispatch;
	}
	// 821B34E0: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821B34E4: 398C34F8  addi r12, r12, 0x34f8
	ctx.r[12].s64 = ctx.r[12].s64 + 13560;
	// 821B34E8: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821B34EC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821B34F0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821B34F4: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821B3520; continue 'dispatch;
		},
		1 => {
	pc = 0x821B3678; continue 'dispatch;
		},
		2 => {
	pc = 0x821B3734; continue 'dispatch;
		},
		3 => {
	pc = 0x821B3598; continue 'dispatch;
		},
		4 => {
	pc = 0x821B37C8; continue 'dispatch;
		},
		5 => {
	pc = 0x821B39F8; continue 'dispatch;
		},
		6 => {
	pc = 0x821B3AC4; continue 'dispatch;
		},
		7 => {
	pc = 0x821B3B44; continue 'dispatch;
		},
		8 => {
	pc = 0x821B3D64; continue 'dispatch;
		},
		9 => {
	pc = 0x821B3F24; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821B34F8: 821B3520  lwz r16, 0x3520(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(13600 as u32) ) } as u64;
	// 821B34FC: 821B3678  lwz r16, 0x3678(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(13944 as u32) ) } as u64;
	// 821B3500: 821B3734  lwz r16, 0x3734(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14132 as u32) ) } as u64;
	// 821B3504: 821B3598  lwz r16, 0x3598(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(13720 as u32) ) } as u64;
	// 821B3508: 821B37C8  lwz r16, 0x37c8(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14280 as u32) ) } as u64;
	// 821B350C: 821B39F8  lwz r16, 0x39f8(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14840 as u32) ) } as u64;
	// 821B3510: 821B3AC4  lwz r16, 0x3ac4(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(15044 as u32) ) } as u64;
	// 821B3514: 821B3B44  lwz r16, 0x3b44(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(15172 as u32) ) } as u64;
	// 821B3518: 821B3D64  lwz r16, 0x3d64(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(15716 as u32) ) } as u64;
	// 821B351C: 821B3F24  lwz r16, 0x3f24(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16164 as u32) ) } as u64;
            }
            0x821B3520 => {
    //   block [0x821B3520..0x821B353C)
	// 821B3520: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B3524: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B3528: 419A0014  beq cr6, 0x821b353c
	if ctx.cr[6].eq {
	pc = 0x821B353C; continue 'dispatch;
	}
	// 821B352C: 92FD00A0  stw r23, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[23].u32 ) };
	// 821B3530: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B3534: 386B1D08  addi r3, r11, 0x1d08
	ctx.r[3].s64 = ctx.r[11].s64 + 7432;
	// 821B3538: 4BFBFB39  bl 0x82173070
	ctx.lr = 0x821B353C;
	sub_82173070(ctx, base);
	pc = 0x821B353C; continue 'dispatch;
            }
            0x821B353C => {
    //   block [0x821B353C..0x821B3584)
	// 821B353C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B3540: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3544: 4814AA7D  bl 0x822fdfc0
	ctx.lr = 0x821B3548;
	sub_822FDFC0(ctx, base);
	// 821B3548: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B354C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3550: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B3554: 419A015C  beq cr6, 0x821b36b0
	if ctx.cr[6].eq {
	pc = 0x821B36B0; continue 'dispatch;
	}
	// 821B3558: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B355C: 419A0030  beq cr6, 0x821b358c
	if ctx.cr[6].eq {
	pc = 0x821B358C; continue 'dispatch;
	}
	// 821B3560: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3564: 409A0020  bne cr6, 0x821b3584
	if !ctx.cr[6].eq {
	pc = 0x821B3584; continue 'dispatch;
	}
	// 821B3568: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B356C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B3570: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3574: 48149C3D  bl 0x822fd1b0
	ctx.lr = 0x821B3578;
	sub_822FD1B0(ctx, base);
	// 821B3578: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B357C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3580: 48AF5EC0  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3584 => {
    //   block [0x821B3584..0x821B358C)
	// 821B3584: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 821B3588: 917D009C  stw r11, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	pc = 0x821B358C; continue 'dispatch;
            }
            0x821B358C => {
    //   block [0x821B358C..0x821B3598)
	// 821B358C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3590: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3594: 48AF5EAC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3598 => {
    //   block [0x821B3598..0x821B35A8)
	// 821B3598: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B359C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B35A0: 409A0008  bne cr6, 0x821b35a8
	if !ctx.cr[6].eq {
	pc = 0x821B35A8; continue 'dispatch;
	}
	// 821B35A4: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x821B35A8; continue 'dispatch;
            }
            0x821B35A8 => {
    //   block [0x821B35A8..0x821B35E0)
	// 821B35A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B35AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B35B0: 419A00BC  beq cr6, 0x821b366c
	if ctx.cr[6].eq {
	pc = 0x821B366C; continue 'dispatch;
	}
	// 821B35B4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B35B8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B35BC: 814B0138  lwz r10, 0x138(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(312 as u32) ) } as u64;
	// 821B35C0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B35C4: 409900A8  ble cr6, 0x821b366c
	if !ctx.cr[6].gt {
	pc = 0x821B366C; continue 'dispatch;
	}
	// 821B35C8: 814B0134  lwz r10, 0x134(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(308 as u32) ) } as u64;
	// 821B35CC: 816B0130  lwz r11, 0x130(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) } as u64;
	// 821B35D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B35D4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821B35D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821B35DC: 419A0020  beq cr6, 0x821b35fc
	if ctx.cr[6].eq {
	pc = 0x821B35FC; continue 'dispatch;
	}
	pc = 0x821B35E0; continue 'dispatch;
            }
            0x821B35E0 => {
    //   block [0x821B35E0..0x821B35FC)
	// 821B35E0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 821B35E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B35E8: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 821B35EC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821B35F0: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B35F4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B35F8: 4082FFE8  bne 0x821b35e0
	if !ctx.cr[0].eq {
	pc = 0x821B35E0; continue 'dispatch;
	}
	pc = 0x821B35FC; continue 'dispatch;
            }
            0x821B35FC => {
    //   block [0x821B35FC..0x821B3620)
	// 821B35FC: 894B504D  lbz r10, 0x504d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20557 as u32) ) } as u64;
	// 821B3600: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B3604: 419A001C  beq cr6, 0x821b3620
	if ctx.cr[6].eq {
	pc = 0x821B3620; continue 'dispatch;
	}
	// 821B3608: 80AB5050  lwz r5, 0x5050(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20560 as u32) ) } as u64;
	// 821B360C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B3610: 419A0010  beq cr6, 0x821b3620
	if ctx.cr[6].eq {
	pc = 0x821B3620; continue 'dispatch;
	}
	// 821B3614: 388B4C4C  addi r4, r11, 0x4c4c
	ctx.r[4].s64 = ctx.r[11].s64 + 19532;
	// 821B3618: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B361C: 4814B345  bl 0x822fe960
	ctx.lr = 0x821B3620;
	sub_822FE960(ctx, base);
	pc = 0x821B3620; continue 'dispatch;
            }
            0x821B3620 => {
    //   block [0x821B3620..0x821B3660)
	// 821B3620: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3624: 48146FF5  bl 0x822fa618
	ctx.lr = 0x821B3628;
	sub_822FA618(ctx, base);
	// 821B3628: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B362C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B3630: 419A0034  beq cr6, 0x821b3664
	if ctx.cr[6].eq {
	pc = 0x821B3664; continue 'dispatch;
	}
	// 821B3634: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3638: 409A0028  bne cr6, 0x821b3660
	if !ctx.cr[6].eq {
	pc = 0x821B3660; continue 'dispatch;
	}
	// 821B363C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B3640: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B3644: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3648: 48149B69  bl 0x822fd1b0
	ctx.lr = 0x821B364C;
	sub_822FD1B0(ctx, base);
	// 821B364C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B3650: 480044C9  bl 0x821b7b18
	ctx.lr = 0x821B3654;
	sub_821B7B18(ctx, base);
	// 821B3654: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3658: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B365C: 48AF5DE4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3660 => {
    //   block [0x821B3660..0x821B3664)
	// 821B3660: 92DD009C  stw r22, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[22].u32 ) };
	pc = 0x821B3664; continue 'dispatch;
            }
            0x821B3664 => {
    //   block [0x821B3664..0x821B366C)
	// 821B3664: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B3668: 480044B1  bl 0x821b7b18
	ctx.lr = 0x821B366C;
	sub_821B7B18(ctx, base);
	pc = 0x821B366C; continue 'dispatch;
            }
            0x821B366C => {
    //   block [0x821B366C..0x821B3678)
	// 821B366C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3670: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3674: 48AF5DCC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3678 => {
    //   block [0x821B3678..0x821B3694)
	// 821B3678: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B367C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B3680: 419A0014  beq cr6, 0x821b3694
	if ctx.cr[6].eq {
	pc = 0x821B3694; continue 'dispatch;
	}
	// 821B3684: 92DD00A0  stw r22, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[22].u32 ) };
	// 821B3688: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B368C: 386B1D30  addi r3, r11, 0x1d30
	ctx.r[3].s64 = ctx.r[11].s64 + 7472;
	// 821B3690: 4BFBF9E1  bl 0x82173070
	ctx.lr = 0x821B3694;
	sub_82173070(ctx, base);
	pc = 0x821B3694; continue 'dispatch;
            }
            0x821B3694 => {
    //   block [0x821B3694..0x821B36AC)
	// 821B3694: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B3698: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B369C: 4814A925  bl 0x822fdfc0
	ctx.lr = 0x821B36A0;
	sub_822FDFC0(ctx, base);
	// 821B36A0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B36A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B36A8: 409A0020  bne cr6, 0x821b36c8
	if !ctx.cr[6].eq {
	pc = 0x821B36C8; continue 'dispatch;
	}
	pc = 0x821B36AC; continue 'dispatch;
            }
            0x821B36AC => {
    //   block [0x821B36AC..0x821B36B0)
	// 821B36AC: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	pc = 0x821B36B0; continue 'dispatch;
            }
            0x821B36B0 => {
    //   block [0x821B36B0..0x821B36C8)
	// 821B36B0: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B36B4: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 821B36B8: 419A08F0  beq cr6, 0x821b3fa8
	if ctx.cr[6].eq {
	pc = 0x821B3FA8; continue 'dispatch;
	}
	// 821B36BC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 821B36C0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B36C4: 48AF5D7C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B36C8 => {
    //   block [0x821B36C8..0x821B36F0)
	// 821B36C8: 481201A1  bl 0x822d3868
	ctx.lr = 0x821B36CC;
	sub_822D3868(ctx, base);
	// 821B36CC: 89630007  lbz r11, 7(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(7 as u32) ) } as u64;
	// 821B36D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B36D4: 409A001C  bne cr6, 0x821b36f0
	if !ctx.cr[6].eq {
	pc = 0x821B36F0; continue 'dispatch;
	}
	// 821B36D8: 48120191  bl 0x822d3868
	ctx.lr = 0x821B36DC;
	sub_822D3868(ctx, base);
	// 821B36DC: 816300B4  lwz r11, 0xb4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) } as u64;
	// 821B36E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B36E4: 4198000C  blt cr6, 0x821b36f0
	if ctx.cr[6].lt {
	pc = 0x821B36F0; continue 'dispatch;
	}
	// 821B36E8: 48120181  bl 0x822d3868
	ctx.lr = 0x821B36EC;
	sub_822D3868(ctx, base);
	// 821B36EC: 481A8F55  bl 0x8235c640
	ctx.lr = 0x821B36F0;
	sub_8235C640(ctx, base);
	pc = 0x821B36F0; continue 'dispatch;
            }
            0x821B36F0 => {
    //   block [0x821B36F0..0x821B3720)
	// 821B36F0: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B36F4: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821B36F8: 419A0030  beq cr6, 0x821b3728
	if ctx.cr[6].eq {
	pc = 0x821B3728; continue 'dispatch;
	}
	// 821B36FC: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3700: 409A0020  bne cr6, 0x821b3720
	if !ctx.cr[6].eq {
	pc = 0x821B3720; continue 'dispatch;
	}
	// 821B3704: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B3708: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B370C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3710: 48149AA1  bl 0x822fd1b0
	ctx.lr = 0x821B3714;
	sub_822FD1B0(ctx, base);
	// 821B3714: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3718: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B371C: 48AF5D24  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3720 => {
    //   block [0x821B3720..0x821B3728)
	// 821B3720: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821B3724: 917D009C  stw r11, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	pc = 0x821B3728; continue 'dispatch;
            }
            0x821B3728 => {
    //   block [0x821B3728..0x821B3734)
	// 821B3728: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B372C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3730: 48AF5D10  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3734 => {
    //   block [0x821B3734..0x821B3754)
	// 821B3734: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B3738: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821B373C: 419A0018  beq cr6, 0x821b3754
	if ctx.cr[6].eq {
	pc = 0x821B3754; continue 'dispatch;
	}
	// 821B3740: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821B3744: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B3748: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821B374C: 386A1D5C  addi r3, r10, 0x1d5c
	ctx.r[3].s64 = ctx.r[10].s64 + 7516;
	// 821B3750: 4BFBF921  bl 0x82173070
	ctx.lr = 0x821B3754;
	sub_82173070(ctx, base);
	pc = 0x821B3754; continue 'dispatch;
            }
            0x821B3754 => {
    //   block [0x821B3754..0x821B3794)
	// 821B3754: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B3758: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B375C: 4814A865  bl 0x822fdfc0
	ctx.lr = 0x821B3760;
	sub_822FDFC0(ctx, base);
	// 821B3760: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B3764: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3768: 419AFF44  beq cr6, 0x821b36ac
	if ctx.cr[6].eq {
	pc = 0x821B36AC; continue 'dispatch;
	}
	// 821B376C: 481200FD  bl 0x822d3868
	ctx.lr = 0x821B3770;
	sub_822D3868(ctx, base);
	// 821B3770: 896300BA  lbz r11, 0xba(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(186 as u32) ) } as u64;
	// 821B3774: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3778: 409A0028  bne cr6, 0x821b37a0
	if !ctx.cr[6].eq {
	pc = 0x821B37A0; continue 'dispatch;
	}
	// 821B377C: 481200ED  bl 0x822d3868
	ctx.lr = 0x821B3780;
	sub_822D3868(ctx, base);
	// 821B3780: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B3784: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821B3788: 419A000C  beq cr6, 0x821b3794
	if ctx.cr[6].eq {
	pc = 0x821B3794; continue 'dispatch;
	}
	// 821B378C: 481200DD  bl 0x822d3868
	ctx.lr = 0x821B3790;
	sub_822D3868(ctx, base);
	// 821B3790: 481A8F99  bl 0x8235c728
	ctx.lr = 0x821B3794;
	sub_8235C728(ctx, base);
	pc = 0x821B3794; continue 'dispatch;
            }
            0x821B3794 => {
    //   block [0x821B3794..0x821B37A0)
	// 821B3794: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3798: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B379C: 48AF5CA4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B37A0 => {
    //   block [0x821B37A0..0x821B37C8)
	// 821B37A0: 817D0144  lwz r11, 0x144(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(324 as u32) ) } as u64;
	// 821B37A4: 815D0070  lwz r10, 0x70(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) } as u64;
	// 821B37A8: 392B4E20  addi r9, r11, 0x4e20
	ctx.r[9].s64 = ctx.r[11].s64 + 20000;
	// 821B37AC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B37B0: 4198FDDC  blt cr6, 0x821b358c
	if ctx.cr[6].lt {
	pc = 0x821B358C; continue 'dispatch;
	}
	// 821B37B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B37B8: 48147051  bl 0x822fa808
	ctx.lr = 0x821B37BC;
	sub_822FA808(ctx, base);
	// 821B37BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B37C0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B37C4: 48AF5C7C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B37C8 => {
    //   block [0x821B37C8..0x821B37E8)
	// 821B37C8: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B37CC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B37D0: 419A0018  beq cr6, 0x821b37e8
	if ctx.cr[6].eq {
	pc = 0x821B37E8; continue 'dispatch;
	}
	// 821B37D4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 821B37D8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B37DC: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821B37E0: 386A1D88  addi r3, r10, 0x1d88
	ctx.r[3].s64 = ctx.r[10].s64 + 7560;
	// 821B37E4: 4BFBF88D  bl 0x82173070
	ctx.lr = 0x821B37E8;
	sub_82173070(ctx, base);
	pc = 0x821B37E8; continue 'dispatch;
            }
            0x821B37E8 => {
    //   block [0x821B37E8..0x821B3868)
	// 821B37E8: 817D0124  lwz r11, 0x124(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(292 as u32) ) } as u64;
	// 821B37EC: 3B7D0124  addi r27, r29, 0x124
	ctx.r[27].s64 = ctx.r[29].s64 + 292;
	// 821B37F0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821B37F4: 409A0088  bne cr6, 0x821b387c
	if !ctx.cr[6].eq {
	pc = 0x821B387C; continue 'dispatch;
	}
	// 821B37F8: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 821B37FC: 387D0080  addi r3, r29, 0x80
	ctx.r[3].s64 = ctx.r[29].s64 + 128;
	// 821B3800: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 821B3804: 419A0078  beq cr6, 0x821b387c
	if ctx.cr[6].eq {
	pc = 0x821B387C; continue 'dispatch;
	}
	// 821B3808: 48B0F619  bl 0x82cc2e20
	ctx.lr = 0x821B380C;
	sub_82CC2E20(ctx, base);
	// 821B380C: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 821B3810: 2B0B0012  cmplwi cr6, r11, 0x12
	ctx.cr[6].compare_u32(ctx.r[11].u32, 18 as u32, &mut ctx.xer);
	// 821B3814: 409A0068  bne cr6, 0x821b387c
	if !ctx.cr[6].eq {
	pc = 0x821B387C; continue 'dispatch;
	}
	// 821B3818: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B381C: 386B1DB8  addi r3, r11, 0x1db8
	ctx.r[3].s64 = ctx.r[11].s64 + 7608;
	// 821B3820: 4BFBF851  bl 0x82173070
	ctx.lr = 0x821B3824;
	sub_82173070(ctx, base);
	// 821B3824: 3FE08332  lis r31, -0x7cce
	ctx.r[31].s64 = -2093875200;
	// 821B3828: 807F9684  lwz r3, -0x697c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-27004 as u32) ) } as u64;
	// 821B382C: 48B0EF85  bl 0x82cc27b0
	ctx.lr = 0x821B3830;
	sub_82CC27B0(ctx, base);
	// 821B3830: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B3834: 917F9684  stw r11, -0x697c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-27004 as u32), ctx.r[11].u32 ) };
	// 821B3838: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B383C: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821B3840: 419A0030  beq cr6, 0x821b3870
	if ctx.cr[6].eq {
	pc = 0x821B3870; continue 'dispatch;
	}
	// 821B3844: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3848: 409A0020  bne cr6, 0x821b3868
	if !ctx.cr[6].eq {
	pc = 0x821B3868; continue 'dispatch;
	}
	// 821B384C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B3850: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B3854: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3858: 48149959  bl 0x822fd1b0
	ctx.lr = 0x821B385C;
	sub_822FD1B0(ctx, base);
	// 821B385C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3860: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3864: 48AF5BDC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3868 => {
    //   block [0x821B3868..0x821B3870)
	// 821B3868: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 821B386C: 917D009C  stw r11, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	pc = 0x821B3870; continue 'dispatch;
            }
            0x821B3870 => {
    //   block [0x821B3870..0x821B387C)
	// 821B3870: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3874: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3878: 48AF5BC8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B387C => {
    //   block [0x821B387C..0x821B38B0)
	// 821B387C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3880: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3884: 4814A73D  bl 0x822fdfc0
	ctx.lr = 0x821B3888;
	sub_822FDFC0(ctx, base);
	// 821B3888: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B388C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3890: 419AFE1C  beq cr6, 0x821b36ac
	if ctx.cr[6].eq {
	pc = 0x821B36AC; continue 'dispatch;
	}
	// 821B3894: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 821B3898: 3BDD0080  addi r30, r29, 0x80
	ctx.r[30].s64 = ctx.r[29].s64 + 128;
	// 821B389C: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 821B38A0: 409A0010  bne cr6, 0x821b38b0
	if !ctx.cr[6].eq {
	pc = 0x821B38B0; continue 'dispatch;
	}
	// 821B38A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B38A8: 386B1E00  addi r3, r11, 0x1e00
	ctx.r[3].s64 = ctx.r[11].s64 + 7680;
	// 821B38AC: 4BFBF7C5  bl 0x82173070
	ctx.lr = 0x821B38B0;
	sub_82173070(ctx, base);
	pc = 0x821B38B0; continue 'dispatch;
            }
            0x821B38B0 => {
    //   block [0x821B38B0..0x821B38CC)
	// 821B38B0: 3FE08332  lis r31, -0x7cce
	ctx.r[31].s64 = -2093875200;
	// 821B38B4: 807F9684  lwz r3, -0x697c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-27004 as u32) ) } as u64;
	// 821B38B8: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 821B38BC: 419A0010  beq cr6, 0x821b38cc
	if ctx.cr[6].eq {
	pc = 0x821B38CC; continue 'dispatch;
	}
	// 821B38C0: 48B0EEF1  bl 0x82cc27b0
	ctx.lr = 0x821B38C4;
	sub_82CC27B0(ctx, base);
	// 821B38C4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B38C8: 917F9684  stw r11, -0x697c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-27004 as u32), ctx.r[11].u32 ) };
	pc = 0x821B38CC; continue 'dispatch;
            }
            0x821B38CC => {
    //   block [0x821B38CC..0x821B3908)
	// 821B38CC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B38D0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821B38D4: 409A0034  bne cr6, 0x821b3908
	if !ctx.cr[6].eq {
	pc = 0x821B3908; continue 'dispatch;
	}
	// 821B38D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B38DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B38E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B38E4: 48B0F49D  bl 0x82cc2d80
	ctx.lr = 0x821B38E8;
	sub_82CC2D80(ctx, base);
	// 821B38E8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821B38EC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B38F0: 419A0018  beq cr6, 0x821b3908
	if ctx.cr[6].eq {
	pc = 0x821B3908; continue 'dispatch;
	}
	// 821B38F4: 38800013  li r4, 0x13
	ctx.r[4].s64 = 19;
	// 821B38F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B38FC: 481498B5  bl 0x822fd1b0
	ctx.lr = 0x821B3900;
	sub_822FD1B0(ctx, base);
	// 821B3900: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3904: 48AF5B3C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3908 => {
    //   block [0x821B3908..0x821B3940)
	// 821B3908: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B390C: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3910: 386B1E10  addi r3, r11, 0x1e10
	ctx.r[3].s64 = ctx.r[11].s64 + 7696;
	// 821B3914: 4BFBF75D  bl 0x82173070
	ctx.lr = 0x821B3918;
	sub_82173070(ctx, base);
	// 821B3918: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B391C: 386A1E24  addi r3, r10, 0x1e24
	ctx.r[3].s64 = ctx.r[10].s64 + 7716;
	// 821B3920: 4BFBF751  bl 0x82173070
	ctx.lr = 0x821B3924;
	sub_82173070(ctx, base);
	// 821B3924: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3928: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 821B392C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B3930: 40990044  ble cr6, 0x821b3974
	if !ctx.cr[6].gt {
	pc = 0x821B3974; continue 'dispatch;
	}
	// 821B3934: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B3938: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 821B393C: 3B8B1E38  addi r28, r11, 0x1e38
	ctx.r[28].s64 = ctx.r[11].s64 + 7736;
	pc = 0x821B3940; continue 'dispatch;
            }
            0x821B3940 => {
    //   block [0x821B3940..0x821B3974)
	// 821B3940: 817D0120  lwz r11, 0x120(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(288 as u32) ) } as u64;
	// 821B3944: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B3948: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B394C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821B3950: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 821B3954: 80EB0024  lwz r7, 0x24(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B3958: E8CB0000  ld r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B395C: 4BFBF715  bl 0x82173070
	ctx.lr = 0x821B3960;
	sub_82173070(ctx, base);
	// 821B3960: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3964: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B3968: 3BDE00C4  addi r30, r30, 0xc4
	ctx.r[30].s64 = ctx.r[30].s64 + 196;
	// 821B396C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3970: 4198FFD0  blt cr6, 0x821b3940
	if ctx.cr[6].lt {
	pc = 0x821B3940; continue 'dispatch;
	}
	pc = 0x821B3974; continue 'dispatch;
            }
            0x821B3974 => {
    //   block [0x821B3974..0x821B39A8)
	// 821B3974: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B3978: 386B0C88  addi r3, r11, 0xc88
	ctx.r[3].s64 = ctx.r[11].s64 + 3208;
	// 821B397C: 4BFBF6F5  bl 0x82173070
	ctx.lr = 0x821B3980;
	sub_82173070(ctx, base);
	// 821B3980: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3984: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3988: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B398C: 4099001C  ble cr6, 0x821b39a8
	if !ctx.cr[6].gt {
	pc = 0x821B39A8; continue 'dispatch;
	}
	// 821B3990: 48146FF9  bl 0x822fa988
	ctx.lr = 0x821B3994;
	sub_822FA988(ctx, base);
	// 821B3994: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3998: 48147909  bl 0x822fb2a0
	ctx.lr = 0x821B399C;
	sub_822FB2A0(ctx, base);
	// 821B399C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B39A0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B39A4: 48AF5A9C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B39A8 => {
    //   block [0x821B39A8..0x821B39F8)
	// 821B39A8: 48146FE1  bl 0x822fa988
	ctx.lr = 0x821B39AC;
	sub_822FA988(ctx, base);
	// 821B39AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B39B0: 481478F1  bl 0x822fb2a0
	ctx.lr = 0x821B39B4;
	sub_822FB2A0(ctx, base);
	// 821B39B4: 807D0120  lwz r3, 0x120(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(288 as u32) ) } as u64;
	// 821B39B8: 48068381  bl 0x8221bd38
	ctx.lr = 0x821B39BC;
	sub_8221BD38(ctx, base);
	// 821B39BC: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B39C0: 92FD0120  stw r23, 0x120(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(288 as u32), ctx.r[23].u32 ) };
	// 821B39C4: 9AFD0128  stb r23, 0x128(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(296 as u32), ctx.r[23].u8 ) };
	// 821B39C8: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821B39CC: 9ADD01A1  stb r22, 0x1a1(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(417 as u32), ctx.r[22].u8 ) };
	// 821B39D0: 419AFEA0  beq cr6, 0x821b3870
	if ctx.cr[6].eq {
	pc = 0x821B3870; continue 'dispatch;
	}
	// 821B39D4: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B39D8: 409AFE90  bne cr6, 0x821b3868
	if !ctx.cr[6].eq {
	pc = 0x821B3868; continue 'dispatch;
	}
	// 821B39DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B39E0: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B39E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B39E8: 481497C9  bl 0x822fd1b0
	ctx.lr = 0x821B39EC;
	sub_822FD1B0(ctx, base);
	// 821B39EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B39F0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B39F4: 48AF5A4C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B39F8 => {
    //   block [0x821B39F8..0x821B3A18)
	// 821B39F8: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B39FC: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821B3A00: 419A0018  beq cr6, 0x821b3a18
	if ctx.cr[6].eq {
	pc = 0x821B3A18; continue 'dispatch;
	}
	// 821B3A04: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821B3A08: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B3A0C: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821B3A10: 386A1E60  addi r3, r10, 0x1e60
	ctx.r[3].s64 = ctx.r[10].s64 + 7776;
	// 821B3A14: 4BFBF65D  bl 0x82173070
	ctx.lr = 0x821B3A18;
	sub_82173070(ctx, base);
	pc = 0x821B3A18; continue 'dispatch;
            }
            0x821B3A18 => {
    //   block [0x821B3A18..0x821B3A60)
	// 821B3A18: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B3A1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3A20: 409A0054  bne cr6, 0x821b3a74
	if !ctx.cr[6].eq {
	pc = 0x821B3A74; continue 'dispatch;
	}
	// 821B3A24: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B3A28: 386B1E8C  addi r3, r11, 0x1e8c
	ctx.r[3].s64 = ctx.r[11].s64 + 7820;
	// 821B3A2C: 4BFBF645  bl 0x82173070
	ctx.lr = 0x821B3A30;
	sub_82173070(ctx, base);
	// 821B3A30: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B3A34: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821B3A38: 419A0030  beq cr6, 0x821b3a68
	if ctx.cr[6].eq {
	pc = 0x821B3A68; continue 'dispatch;
	}
	// 821B3A3C: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3A40: 409A0020  bne cr6, 0x821b3a60
	if !ctx.cr[6].eq {
	pc = 0x821B3A60; continue 'dispatch;
	}
	// 821B3A44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B3A48: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B3A4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3A50: 48149761  bl 0x822fd1b0
	ctx.lr = 0x821B3A54;
	sub_822FD1B0(ctx, base);
	// 821B3A54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3A58: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3A5C: 48AF59E4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3A60 => {
    //   block [0x821B3A60..0x821B3A68)
	// 821B3A60: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 821B3A64: 917D009C  stw r11, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	pc = 0x821B3A68; continue 'dispatch;
            }
            0x821B3A68 => {
    //   block [0x821B3A68..0x821B3A74)
	// 821B3A68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3A6C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3A70: 48AF59D0  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3A74 => {
    //   block [0x821B3A74..0x821B3AB4)
	// 821B3A74: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3A78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3A7C: 4814A545  bl 0x822fdfc0
	ctx.lr = 0x821B3A80;
	sub_822FDFC0(ctx, base);
	// 821B3A80: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B3A84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3A88: 419AFC24  beq cr6, 0x821b36ac
	if ctx.cr[6].eq {
	pc = 0x821B36AC; continue 'dispatch;
	}
	// 821B3A8C: 897D0129  lbz r11, 0x129(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(297 as u32) ) } as u64;
	// 821B3A90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3A94: 895D0128  lbz r10, 0x128(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(296 as u32) ) } as u64;
	// 821B3A98: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3A9C: 40980018  bge cr6, 0x821b3ab4
	if !ctx.cr[6].lt {
	pc = 0x821B3AB4; continue 'dispatch;
	}
	// 821B3AA0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3AA4: 481470BD  bl 0x822fab60
	ctx.lr = 0x821B3AA8;
	sub_822FAB60(ctx, base);
	// 821B3AA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3AAC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3AB0: 48AF5990  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3AB4 => {
    //   block [0x821B3AB4..0x821B3AC4)
	// 821B3AB4: 481474E5  bl 0x822faf98
	ctx.lr = 0x821B3AB8;
	sub_822FAF98(ctx, base);
	// 821B3AB8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3ABC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3AC0: 48AF5980  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3AC4 => {
    //   block [0x821B3AC4..0x821B3AE4)
	// 821B3AC4: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B3AC8: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821B3ACC: 419A0018  beq cr6, 0x821b3ae4
	if ctx.cr[6].eq {
	pc = 0x821B3AE4; continue 'dispatch;
	}
	// 821B3AD0: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 821B3AD4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B3AD8: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821B3ADC: 386A1E9C  addi r3, r10, 0x1e9c
	ctx.r[3].s64 = ctx.r[10].s64 + 7836;
	// 821B3AE0: 4BFBF591  bl 0x82173070
	ctx.lr = 0x821B3AE4;
	sub_82173070(ctx, base);
	pc = 0x821B3AE4; continue 'dispatch;
            }
            0x821B3AE4 => {
    //   block [0x821B3AE4..0x821B3B2C)
	// 821B3AE4: 817D0178  lwz r11, 0x178(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(376 as u32) ) } as u64;
	// 821B3AE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3AEC: 419A0048  beq cr6, 0x821b3b34
	if ctx.cr[6].eq {
	pc = 0x821B3B34; continue 'dispatch;
	}
	// 821B3AF0: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B3AF4: 39400022  li r10, 0x22
	ctx.r[10].s64 = 34;
	// 821B3AF8: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821B3AFC: 915D00A4  stw r10, 0xa4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 821B3B00: 419A0034  beq cr6, 0x821b3b34
	if ctx.cr[6].eq {
	pc = 0x821B3B34; continue 'dispatch;
	}
	// 821B3B04: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3B08: 409A0024  bne cr6, 0x821b3b2c
	if !ctx.cr[6].eq {
	pc = 0x821B3B2C; continue 'dispatch;
	}
	// 821B3B0C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B3B10: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B3B14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3B18: 48149699  bl 0x822fd1b0
	ctx.lr = 0x821B3B1C;
	sub_822FD1B0(ctx, base);
	// 821B3B1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3B20: 48146529  bl 0x822fa048
	ctx.lr = 0x821B3B24;
	sub_822FA048(ctx, base);
	// 821B3B24: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3B28: 48AF5918  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3B2C => {
    //   block [0x821B3B2C..0x821B3B34)
	// 821B3B2C: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 821B3B30: 917D009C  stw r11, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	pc = 0x821B3B34; continue 'dispatch;
            }
            0x821B3B34 => {
    //   block [0x821B3B34..0x821B3B44)
	// 821B3B34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3B38: 48146511  bl 0x822fa048
	ctx.lr = 0x821B3B3C;
	sub_822FA048(ctx, base);
	// 821B3B3C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3B40: 48AF5900  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3B44 => {
    //   block [0x821B3B44..0x821B3B64)
	// 821B3B44: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B3B48: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821B3B4C: 419A0018  beq cr6, 0x821b3b64
	if ctx.cr[6].eq {
	pc = 0x821B3B64; continue 'dispatch;
	}
	// 821B3B50: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 821B3B54: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B3B58: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821B3B5C: 386A1EC8  addi r3, r10, 0x1ec8
	ctx.r[3].s64 = ctx.r[10].s64 + 7880;
	// 821B3B60: 4BFBF511  bl 0x82173070
	ctx.lr = 0x821B3B64;
	sub_82173070(ctx, base);
	pc = 0x821B3B64; continue 'dispatch;
            }
            0x821B3B64 => {
    //   block [0x821B3B64..0x821B3BA8)
	// 821B3B64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3B68: 48148F31  bl 0x822fca98
	ctx.lr = 0x821B3B6C;
	sub_822FCA98(ctx, base);
	// 821B3B6C: 817D0068  lwz r11, 0x68(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 821B3B70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B3B74: 419801B4  blt cr6, 0x821b3d28
	if ctx.cr[6].lt {
	pc = 0x821B3D28; continue 'dispatch;
	}
	// 821B3B78: 92E10074  stw r23, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[23].u32 ) };
	// 821B3B7C: 92E10078  stw r23, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[23].u32 ) };
	// 821B3B80: 92E1007C  stw r23, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[23].u32 ) };
	// 821B3B84: 480B252D  bl 0x822660b0
	ctx.lr = 0x821B3B88;
	sub_822660B0(ctx, base);
	// 821B3B88: 817D0174  lwz r11, 0x174(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(372 as u32) ) } as u64;
	// 821B3B8C: 3BFD0170  addi r31, r29, 0x170
	ctx.r[31].s64 = ctx.r[29].s64 + 368;
	// 821B3B90: 813D0068  lwz r9, 0x68(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 821B3B94: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 821B3B98: 7FC91850  subf r30, r9, r3
	ctx.r[30].s64 = ctx.r[3].s64 - ctx.r[9].s64;
	// 821B3B9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3BA0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821B3BA4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x821B3BA8; continue 'dispatch;
            }
            0x821B3BA8 => {
    //   block [0x821B3BA8..0x821B3BBC)
	// 821B3BA8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3BAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B3BB0: 419A000C  beq cr6, 0x821b3bbc
	if ctx.cr[6].eq {
	pc = 0x821B3BBC; continue 'dispatch;
	}
	// 821B3BB4: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B3BB8: 419A0008  beq cr6, 0x821b3bc0
	if ctx.cr[6].eq {
	pc = 0x821B3BC0; continue 'dispatch;
	}
	pc = 0x821B3BBC; continue 'dispatch;
            }
            0x821B3BBC => {
    //   block [0x821B3BBC..0x821B3BC0)
	// 821B3BBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3BC0; continue 'dispatch;
            }
            0x821B3BC0 => {
    //   block [0x821B3BC0..0x821B3BD4)
	// 821B3BC0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B3BC4: 419A00F0  beq cr6, 0x821b3cb4
	if ctx.cr[6].eq {
	pc = 0x821B3CB4; continue 'dispatch;
	}
	// 821B3BC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B3BCC: 409A0008  bne cr6, 0x821b3bd4
	if !ctx.cr[6].eq {
	pc = 0x821B3BD4; continue 'dispatch;
	}
	// 821B3BD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3BD4; continue 'dispatch;
            }
            0x821B3BD4 => {
    //   block [0x821B3BD4..0x821B3BE4)
	// 821B3BD4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3BD8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3BDC: 409A0008  bne cr6, 0x821b3be4
	if !ctx.cr[6].eq {
	pc = 0x821B3BE4; continue 'dispatch;
	}
	// 821B3BE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3BE4; continue 'dispatch;
            }
            0x821B3BE4 => {
    //   block [0x821B3BE4..0x821B3C04)
	// 821B3BE4: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B3BE8: 810902E8  lwz r8, 0x2e8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(744 as u32) ) } as u64;
	// 821B3BEC: 7F08F040  cmplw cr6, r8, r30
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B3BF0: 419900B0  bgt cr6, 0x821b3ca0
	if ctx.cr[6].gt {
	pc = 0x821B3CA0; continue 'dispatch;
	}
	// 821B3BF4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3BF8: 92C10090  stw r22, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[22].u32 ) };
	// 821B3BFC: 409A0008  bne cr6, 0x821b3c04
	if !ctx.cr[6].eq {
	pc = 0x821B3C04; continue 'dispatch;
	}
	// 821B3C00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3C04; continue 'dispatch;
            }
            0x821B3C04 => {
    //   block [0x821B3C04..0x821B3C58)
	// 821B3C04: E96B0010  ld r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B3C08: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 821B3C0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3C10: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 821B3C14: 4814B27D  bl 0x822fee90
	ctx.lr = 0x821B3C18;
	sub_822FEE90(ctx, base);
	// 821B3C18: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B3C1C: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821B3C20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3C24: 419A005C  beq cr6, 0x821b3c80
	if ctx.cr[6].eq {
	pc = 0x821B3C80; continue 'dispatch;
	}
	// 821B3C28: 8121007C  lwz r9, 0x7c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821B3C2C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821B3C30: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 821B3C34: 7D091E70  srawi r9, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821B3C38: 7CE81E70  srawi r8, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 821B3C3C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B3C40: 40980034  bge cr6, 0x821b3c74
	if !ctx.cr[6].lt {
	pc = 0x821B3C74; continue 'dispatch;
	}
	// 821B3C44: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821B3C48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B3C4C: 419A000C  beq cr6, 0x821b3c58
	if ctx.cr[6].eq {
	pc = 0x821B3C58; continue 'dispatch;
	}
	// 821B3C50: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B3C54: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	pc = 0x821B3C58; continue 'dispatch;
            }
            0x821B3C58 => {
    //   block [0x821B3C58..0x821B3C74)
	// 821B3C58: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821B3C5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B3C60: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 821B3C64: 48160EC5  bl 0x82314b28
	ctx.lr = 0x821B3C68;
	sub_82314B28(ctx, base);
	// 821B3C68: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B3C6C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B3C70: 4BFFFF38  b 0x821b3ba8
	pc = 0x821B3BA8; continue 'dispatch;
            }
            0x821B3C74 => {
    //   block [0x821B3C74..0x821B3C80)
	// 821B3C74: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3C78: 40990008  ble cr6, 0x821b3c80
	if !ctx.cr[6].gt {
	pc = 0x821B3C80; continue 'dispatch;
	}
	// 821B3C7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3C80; continue 'dispatch;
            }
            0x821B3C80 => {
    //   block [0x821B3C80..0x821B3CA0)
	// 821B3C80: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 821B3C84: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821B3C88: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821B3C8C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821B3C90: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821B3C94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B3C98: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B3C9C: 482E9F1D  bl 0x8249dbb8
	ctx.lr = 0x821B3CA0;
	sub_8249DBB8(ctx, base);
	pc = 0x821B3CA0; continue 'dispatch;
            }
            0x821B3CA0 => {
    //   block [0x821B3CA0..0x821B3CB4)
	// 821B3CA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B3CA4: 48160E85  bl 0x82314b28
	ctx.lr = 0x821B3CA8;
	sub_82314B28(ctx, base);
	// 821B3CA8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B3CAC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B3CB0: 4BFFFEF8  b 0x821b3ba8
	pc = 0x821B3BA8; continue 'dispatch;
            }
            0x821B3CB4 => {
    //   block [0x821B3CB4..0x821B3CC8)
	// 821B3CB4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B3CB8: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821B3CBC: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3CC0: 40990008  ble cr6, 0x821b3cc8
	if !ctx.cr[6].gt {
	pc = 0x821B3CC8; continue 'dispatch;
	}
	// 821B3CC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3CC8; continue 'dispatch;
            }
            0x821B3CC8 => {
    //   block [0x821B3CC8..0x821B3CCC)
	// 821B3CC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x821B3CCC; continue 'dispatch;
            }
            0x821B3CCC => {
    //   block [0x821B3CCC..0x821B3CD8)
	// 821B3CCC: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3CD0: 40990008  ble cr6, 0x821b3cd8
	if !ctx.cr[6].gt {
	pc = 0x821B3CD8; continue 'dispatch;
	}
	// 821B3CD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3CD8; continue 'dispatch;
            }
            0x821B3CD8 => {
    //   block [0x821B3CD8..0x821B3CE8)
	// 821B3CD8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3CDC: 419A0034  beq cr6, 0x821b3d10
	if ctx.cr[6].eq {
	pc = 0x821B3D10; continue 'dispatch;
	}
	// 821B3CE0: 41980008  blt cr6, 0x821b3ce8
	if ctx.cr[6].lt {
	pc = 0x821B3CE8; continue 'dispatch;
	}
	// 821B3CE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3CE8; continue 'dispatch;
            }
            0x821B3CE8 => {
    //   block [0x821B3CE8..0x821B3D04)
	// 821B3CE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3CEC: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 821B3CF0: 4814AFF1  bl 0x822fece0
	ctx.lr = 0x821B3CF4;
	sub_822FECE0(ctx, base);
	// 821B3CF4: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821B3CF8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3CFC: 41980008  blt cr6, 0x821b3d04
	if ctx.cr[6].lt {
	pc = 0x821B3D04; continue 'dispatch;
	}
	// 821B3D00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3D04; continue 'dispatch;
            }
            0x821B3D04 => {
    //   block [0x821B3D04..0x821B3D10)
	// 821B3D04: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B3D08: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821B3D0C: 4BFFFFC0  b 0x821b3ccc
	pc = 0x821B3CCC; continue 'dispatch;
            }
            0x821B3D10 => {
    //   block [0x821B3D10..0x821B3D1C)
	// 821B3D10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B3D14: 419A0008  beq cr6, 0x821b3d1c
	if ctx.cr[6].eq {
	pc = 0x821B3D1C; continue 'dispatch;
	}
	// 821B3D18: 48068021  bl 0x8221bd38
	ctx.lr = 0x821B3D1C;
	sub_8221BD38(ctx, base);
	pc = 0x821B3D1C; continue 'dispatch;
            }
            0x821B3D1C => {
    //   block [0x821B3D1C..0x821B3D28)
	// 821B3D1C: 92E10074  stw r23, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[23].u32 ) };
	// 821B3D20: 92E10078  stw r23, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[23].u32 ) };
	// 821B3D24: 92E1007C  stw r23, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[23].u32 ) };
	pc = 0x821B3D28; continue 'dispatch;
            }
            0x821B3D28 => {
    //   block [0x821B3D28..0x821B3D58)
	// 821B3D28: 817D0060  lwz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 821B3D2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B3D30: 41980028  blt cr6, 0x821b3d58
	if ctx.cr[6].lt {
	pc = 0x821B3D58; continue 'dispatch;
	}
	// 821B3D34: 480B237D  bl 0x822660b0
	ctx.lr = 0x821B3D38;
	sub_822660B0(ctx, base);
	// 821B3D38: 817D0074  lwz r11, 0x74(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B3D3C: 815D0060  lwz r10, 0x60(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 821B3D40: 7D2B1850  subf r9, r11, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821B3D44: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3D48: 41980010  blt cr6, 0x821b3d58
	if ctx.cr[6].lt {
	pc = 0x821B3D58; continue 'dispatch;
	}
	// 821B3D4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3D50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3D54: 48149035  bl 0x822fcd88
	ctx.lr = 0x821B3D58;
	sub_822FCD88(ctx, base);
	pc = 0x821B3D58; continue 'dispatch;
            }
            0x821B3D58 => {
    //   block [0x821B3D58..0x821B3D64)
	// 821B3D58: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 821B3D5C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3D60: 48AF56E0  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3D64 => {
    //   block [0x821B3D64..0x821B3D84)
	// 821B3D64: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B3D68: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821B3D6C: 419A0018  beq cr6, 0x821b3d84
	if ctx.cr[6].eq {
	pc = 0x821B3D84; continue 'dispatch;
	}
	// 821B3D70: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 821B3D74: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B3D78: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821B3D7C: 386A1E9C  addi r3, r10, 0x1e9c
	ctx.r[3].s64 = ctx.r[10].s64 + 7836;
	// 821B3D80: 4BFBF2F1  bl 0x82173070
	ctx.lr = 0x821B3D84;
	sub_82173070(ctx, base);
	pc = 0x821B3D84; continue 'dispatch;
            }
            0x821B3D84 => {
    //   block [0x821B3D84..0x821B3DBC)
	// 821B3D84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3D88: 481462C1  bl 0x822fa048
	ctx.lr = 0x821B3D8C;
	sub_822FA048(ctx, base);
	// 821B3D8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B3D90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3D94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3D98: 4814A229  bl 0x822fdfc0
	ctx.lr = 0x821B3D9C;
	sub_822FDFC0(ctx, base);
	// 821B3D9C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B3DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3DA4: 419A0164  beq cr6, 0x821b3f08
	if ctx.cr[6].eq {
	pc = 0x821B3F08; continue 'dispatch;
	}
	// 821B3DA8: 81596AB8  lwz r10, 0x6ab8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B3DAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B3DB0: 419A000C  beq cr6, 0x821b3dbc
	if ctx.cr[6].eq {
	pc = 0x821B3DBC; continue 'dispatch;
	}
	// 821B3DB4: 89786A5E  lbz r11, 0x6a5e(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(27230 as u32) ) } as u64;
	// 821B3DB8: 48000008  b 0x821b3dc0
	pc = 0x821B3DC0; continue 'dispatch;
            }
            0x821B3DBC => {
    //   block [0x821B3DBC..0x821B3DC0)
	// 821B3DBC: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x821B3DC0; continue 'dispatch;
            }
            0x821B3DC0 => {
    //   block [0x821B3DC0..0x821B3E0C)
	// 821B3DC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B3DC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3DC8: 419A0140  beq cr6, 0x821b3f08
	if ctx.cr[6].eq {
	pc = 0x821B3F08; continue 'dispatch;
	}
	// 821B3DCC: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B3DD0: 894B0104  lbz r10, 0x104(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 821B3DD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B3DD8: 409A0130  bne cr6, 0x821b3f08
	if !ctx.cr[6].eq {
	pc = 0x821B3F08; continue 'dispatch;
	}
	// 821B3DDC: 897D01C8  lbz r11, 0x1c8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(456 as u32) ) } as u64;
	// 821B3DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3DE4: 409A00F0  bne cr6, 0x821b3ed4
	if !ctx.cr[6].eq {
	pc = 0x821B3ED4; continue 'dispatch;
	}
	// 821B3DE8: 897D01C9  lbz r11, 0x1c9(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(457 as u32) ) } as u64;
	// 821B3DEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3DF0: 409A00E4  bne cr6, 0x821b3ed4
	if !ctx.cr[6].eq {
	pc = 0x821B3ED4; continue 'dispatch;
	}
	// 821B3DF4: 815D0174  lwz r10, 0x174(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(372 as u32) ) } as u64;
	// 821B3DF8: 3BFD0170  addi r31, r29, 0x170
	ctx.r[31].s64 = ctx.r[29].s64 + 368;
	// 821B3DFC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821B3E00: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B3E04: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3E08: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821B3E0C; continue 'dispatch;
            }
            0x821B3E0C => {
    //   block [0x821B3E0C..0x821B3E20)
	// 821B3E0C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3E10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3E14: 419A000C  beq cr6, 0x821b3e20
	if ctx.cr[6].eq {
	pc = 0x821B3E20; continue 'dispatch;
	}
	// 821B3E18: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B3E1C: 419A0008  beq cr6, 0x821b3e24
	if ctx.cr[6].eq {
	pc = 0x821B3E24; continue 'dispatch;
	}
	pc = 0x821B3E20; continue 'dispatch;
            }
            0x821B3E20 => {
    //   block [0x821B3E20..0x821B3E24)
	// 821B3E20: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3E24; continue 'dispatch;
            }
            0x821B3E24 => {
    //   block [0x821B3E24..0x821B3E50)
	// 821B3E24: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B3E28: 419A0080  beq cr6, 0x821b3ea8
	if ctx.cr[6].eq {
	pc = 0x821B3EA8; continue 'dispatch;
	}
	// 821B3E2C: 893D01C8  lbz r9, 0x1c8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(456 as u32) ) } as u64;
	// 821B3E30: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B3E34: 409A0074  bne cr6, 0x821b3ea8
	if !ctx.cr[6].eq {
	pc = 0x821B3EA8; continue 'dispatch;
	}
	// 821B3E38: 893D01C9  lbz r9, 0x1c9(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(457 as u32) ) } as u64;
	// 821B3E3C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B3E40: 409A0068  bne cr6, 0x821b3ea8
	if !ctx.cr[6].eq {
	pc = 0x821B3EA8; continue 'dispatch;
	}
	// 821B3E44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3E48: 409A0008  bne cr6, 0x821b3e50
	if !ctx.cr[6].eq {
	pc = 0x821B3E50; continue 'dispatch;
	}
	// 821B3E4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3E50; continue 'dispatch;
            }
            0x821B3E50 => {
    //   block [0x821B3E50..0x821B3E60)
	// 821B3E50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3E54: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3E58: 409A0008  bne cr6, 0x821b3e60
	if !ctx.cr[6].eq {
	pc = 0x821B3E60; continue 'dispatch;
	}
	// 821B3E5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3E60; continue 'dispatch;
            }
            0x821B3E60 => {
    //   block [0x821B3E60..0x821B3E7C)
	// 821B3E60: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B3E64: 89090068  lbz r8, 0x68(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(104 as u32) ) } as u64;
	// 821B3E68: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B3E6C: 409A0028  bne cr6, 0x821b3e94
	if !ctx.cr[6].eq {
	pc = 0x821B3E94; continue 'dispatch;
	}
	// 821B3E70: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3E74: 409A0008  bne cr6, 0x821b3e7c
	if !ctx.cr[6].eq {
	pc = 0x821B3E7C; continue 'dispatch;
	}
	// 821B3E78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3E7C; continue 'dispatch;
            }
            0x821B3E7C => {
    //   block [0x821B3E7C..0x821B3E94)
	// 821B3E7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3E80: 808A0018  lwz r4, 0x18(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B3E84: 4814A795  bl 0x822fe618
	ctx.lr = 0x821B3E88;
	sub_822FE618(ctx, base);
	// 821B3E88: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821B3E8C: 41980008  blt cr6, 0x821b3e94
	if ctx.cr[6].lt {
	pc = 0x821B3E94; continue 'dispatch;
	}
	// 821B3E90: 9ADD01C8  stb r22, 0x1c8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(456 as u32), ctx.r[22].u8 ) };
	pc = 0x821B3E94; continue 'dispatch;
            }
            0x821B3E94 => {
    //   block [0x821B3E94..0x821B3EA8)
	// 821B3E94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B3E98: 48160C91  bl 0x82314b28
	ctx.lr = 0x821B3E9C;
	sub_82314B28(ctx, base);
	// 821B3E9C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B3EA0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B3EA4: 4BFFFF68  b 0x821b3e0c
	pc = 0x821B3E0C; continue 'dispatch;
            }
            0x821B3EA8 => {
    //   block [0x821B3EA8..0x821B3EB4)
	// 821B3EA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B3EAC: 409A0008  bne cr6, 0x821b3eb4
	if !ctx.cr[6].eq {
	pc = 0x821B3EB4; continue 'dispatch;
	}
	// 821B3EB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B3EB4; continue 'dispatch;
            }
            0x821B3EB4 => {
    //   block [0x821B3EB4..0x821B3EC4)
	// 821B3EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3EB8: 419A000C  beq cr6, 0x821b3ec4
	if ctx.cr[6].eq {
	pc = 0x821B3EC4; continue 'dispatch;
	}
	// 821B3EBC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B3EC0: 419A003C  beq cr6, 0x821b3efc
	if ctx.cr[6].eq {
	pc = 0x821B3EFC; continue 'dispatch;
	}
	pc = 0x821B3EC4; continue 'dispatch;
            }
            0x821B3EC4 => {
    //   block [0x821B3EC4..0x821B3ED4)
	// 821B3EC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3EC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B3ECC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3ED0: 48AF5570  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3ED4 => {
    //   block [0x821B3ED4..0x821B3EFC)
	// 821B3ED4: 897D01C9  lbz r11, 0x1c9(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(457 as u32) ) } as u64;
	// 821B3ED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3EDC: 409A0020  bne cr6, 0x821b3efc
	if !ctx.cr[6].eq {
	pc = 0x821B3EFC; continue 'dispatch;
	}
	// 821B3EE0: 9AFD01C8  stb r23, 0x1c8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(456 as u32), ctx.r[23].u8 ) };
	// 821B3EE4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3EE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3EEC: 4814A84D  bl 0x822fe738
	ctx.lr = 0x821B3EF0;
	sub_822FE738(ctx, base);
	// 821B3EF0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821B3EF4: 41980008  blt cr6, 0x821b3efc
	if ctx.cr[6].lt {
	pc = 0x821B3EFC; continue 'dispatch;
	}
	// 821B3EF8: 9ADD01C9  stb r22, 0x1c9(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(457 as u32), ctx.r[22].u8 ) };
	pc = 0x821B3EFC; continue 'dispatch;
            }
            0x821B3EFC => {
    //   block [0x821B3EFC..0x821B3F08)
	// 821B3EFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B3F00: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3F04: 48AF553C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3F08 => {
    //   block [0x821B3F08..0x821B3F24)
	// 821B3F08: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B3F0C: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 821B3F10: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3F14: 419A0094  beq cr6, 0x821b3fa8
	if ctx.cr[6].eq {
	pc = 0x821B3FA8; continue 'dispatch;
	}
	// 821B3F18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B3F1C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3F20: 48AF5520  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3F24 => {
    //   block [0x821B3F24..0x821B3F70)
	// 821B3F24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B3F28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3F2C: 4814A095  bl 0x822fdfc0
	ctx.lr = 0x821B3F30;
	sub_822FDFC0(ctx, base);
	// 821B3F30: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B3F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3F38: 419A0040  beq cr6, 0x821b3f78
	if ctx.cr[6].eq {
	pc = 0x821B3F78; continue 'dispatch;
	}
	// 821B3F3C: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B3F40: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821B3F44: 419A0034  beq cr6, 0x821b3f78
	if ctx.cr[6].eq {
	pc = 0x821B3F78; continue 'dispatch;
	}
	// 821B3F48: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3F4C: 409A0024  bne cr6, 0x821b3f70
	if !ctx.cr[6].eq {
	pc = 0x821B3F70; continue 'dispatch;
	}
	// 821B3F50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B3F54: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B3F58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3F5C: 48149255  bl 0x822fd1b0
	ctx.lr = 0x821B3F60;
	sub_822FD1B0(ctx, base);
	// 821B3F60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3F64: 481460E5  bl 0x822fa048
	ctx.lr = 0x821B3F68;
	sub_822FA048(ctx, base);
	// 821B3F68: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3F6C: 48AF54D4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3F70 => {
    //   block [0x821B3F70..0x821B3F78)
	// 821B3F70: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 821B3F74: 917D009C  stw r11, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	pc = 0x821B3F78; continue 'dispatch;
            }
            0x821B3F78 => {
    //   block [0x821B3F78..0x821B3F88)
	// 821B3F78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3F7C: 481460CD  bl 0x822fa048
	ctx.lr = 0x821B3F80;
	sub_822FA048(ctx, base);
	// 821B3F80: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3F84: 48AF54BC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3F88 => {
    //   block [0x821B3F88..0x821B3FA4)
	// 821B3F88: 815D00A0  lwz r10, 0xa0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B3F8C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B3F90: 419A0014  beq cr6, 0x821b3fa4
	if ctx.cr[6].eq {
	pc = 0x821B3FA4; continue 'dispatch;
	}
	// 821B3F94: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821B3F98: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B3F9C: 386B1EF0  addi r3, r11, 0x1ef0
	ctx.r[3].s64 = ctx.r[11].s64 + 7920;
	// 821B3FA0: 4BFBF0D1  bl 0x82173070
	ctx.lr = 0x821B3FA4;
	sub_82173070(ctx, base);
	pc = 0x821B3FA4; continue 'dispatch;
            }
            0x821B3FA4 => {
    //   block [0x821B3FA4..0x821B3FA8)
	// 821B3FA4: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	pc = 0x821B3FA8; continue 'dispatch;
            }
            0x821B3FA8 => {
    //   block [0x821B3FA8..0x821B3FB0)
	// 821B3FA8: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3FAC: 48AF5494  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B3FB0 size=108
    let mut pc: u32 = 0x821B3FB0;
    'dispatch: loop {
        match pc {
            0x821B3FB0 => {
    //   block [0x821B3FB0..0x821B3FE4)
	// 821B3FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B3FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B3FB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B3FBC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B3FC0: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B3FC4: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 821B3FC8: 419A001C  beq cr6, 0x821b3fe4
	if ctx.cr[6].eq {
	pc = 0x821B3FE4; continue 'dispatch;
	}
	// 821B3FCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B3FD0: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821B3FD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B3FD8: 394B113C  addi r10, r11, 0x113c
	ctx.r[10].s64 = ctx.r[11].s64 + 4412;
	// 821B3FDC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821B3FE0: 48000024  b 0x821b4004
	pc = 0x821B4004; continue 'dispatch;
            }
            0x821B3FE4 => {
    //   block [0x821B3FE4..0x821B4004)
	// 821B3FE4: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B3FE8: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 821B3FEC: 419A0020  beq cr6, 0x821b400c
	if ctx.cr[6].eq {
	pc = 0x821B400C; continue 'dispatch;
	}
	// 821B3FF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B3FF4: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 821B3FF8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 821B3FFC: 394B113C  addi r10, r11, 0x113c
	ctx.r[10].s64 = ctx.r[11].s64 + 4412;
	// 821B4000: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	pc = 0x821B4004; continue 'dispatch;
            }
            0x821B4004 => {
    //   block [0x821B4004..0x821B400C)
	// 821B4004: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821B4008: 48076AC1  bl 0x8222aac8
	ctx.lr = 0x821B400C;
	sub_8222AAC8(ctx, base);
	pc = 0x821B400C; continue 'dispatch;
            }
            0x821B400C => {
    //   block [0x821B400C..0x821B401C)
	// 821B400C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B4010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B4014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B4018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B4020 size=240
    let mut pc: u32 = 0x821B4020;
    'dispatch: loop {
        match pc {
            0x821B4020 => {
    //   block [0x821B4020..0x821B4084)
	// 821B4020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4024: 48AF53E5  bl 0x82ca9408
	ctx.lr = 0x821B4028;
	sub_82CA93D0(ctx, base);
	// 821B4028: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B402C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B4030: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B4034: 3BDF0018  addi r30, r31, 0x18
	ctx.r[30].s64 = ctx.r[31].s64 + 24;
	// 821B4038: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821B403C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821B4040: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 821B4044: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B4048: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B404C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 821B4050: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B4054: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 821B4058: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821B405C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B4060: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4064: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821B4068: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B406C: 482983BD  bl 0x8244c428
	ctx.lr = 0x821B4070;
	sub_8244C428(ctx, base);
	// 821B4070: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B4078: 419A000C  beq cr6, 0x821b4084
	if ctx.cr[6].eq {
	pc = 0x821B4084; continue 'dispatch;
	}
	// 821B407C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B4080: 419A0008  beq cr6, 0x821b4088
	if ctx.cr[6].eq {
	pc = 0x821B4088; continue 'dispatch;
	}
	pc = 0x821B4084; continue 'dispatch;
            }
            0x821B4084 => {
    //   block [0x821B4084..0x821B4088)
	// 821B4084: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B4088; continue 'dispatch;
            }
            0x821B4088 => {
    //   block [0x821B4088..0x821B40A0)
	// 821B4088: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B408C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B4090: 419A0010  beq cr6, 0x821b40a0
	if ctx.cr[6].eq {
	pc = 0x821B40A0; continue 'dispatch;
	}
	// 821B4094: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B4098: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B409C: 48AF53BC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B40A0 => {
    //   block [0x821B40A0..0x821B40F0)
	// 821B40A0: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B40A4: 3BDF003C  addi r30, r31, 0x3c
	ctx.r[30].s64 = ctx.r[31].s64 + 60;
	// 821B40A8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821B40AC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821B40B0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B40B4: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 821B40B8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 821B40BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B40C0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B40C4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B40C8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821B40CC: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821B40D0: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B40D4: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B40D8: 48298351  bl 0x8244c428
	ctx.lr = 0x821B40DC;
	sub_8244C428(ctx, base);
	// 821B40DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B40E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B40E4: 419A000C  beq cr6, 0x821b40f0
	if ctx.cr[6].eq {
	pc = 0x821B40F0; continue 'dispatch;
	}
	// 821B40E8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B40EC: 419A0008  beq cr6, 0x821b40f4
	if ctx.cr[6].eq {
	pc = 0x821B40F4; continue 'dispatch;
	}
	pc = 0x821B40F0; continue 'dispatch;
            }
            0x821B40F0 => {
    //   block [0x821B40F0..0x821B40F4)
	// 821B40F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x821B40F4; continue 'dispatch;
            }
            0x821B40F4 => {
    //   block [0x821B40F4..0x821B4110)
	// 821B40F4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B40F8: 7D4BF850  subf r10, r11, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 821B40FC: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 821B4100: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821B4104: 69030001  xori r3, r8, 1
	ctx.r[3].u64 = ctx.r[8].u64 ^ 1;
	// 821B4108: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B410C: 48AF534C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4140 size=836
    let mut pc: u32 = 0x821B4140;
    'dispatch: loop {
        match pc {
            0x821B4140 => {
    //   block [0x821B4140..0x821B4214)
	// 821B4140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4144: 48AF5291  bl 0x82ca93d4
	ctx.lr = 0x821B4148;
	sub_82CA93D0(ctx, base);
	// 821B4148: DBC1FF60  stfd f30, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[30].u64 ) };
	// 821B414C: DBE1FF68  stfd f31, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[31].u64 ) };
	// 821B4150: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4154: 7CB02B78  mr r16, r5
	ctx.r[16].u64 = ctx.r[5].u64;
	// 821B4158: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821B415C: 7C912378  mr r17, r4
	ctx.r[17].u64 = ctx.r[4].u64;
	// 821B4160: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821B4164: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821B4168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B416C: 81700000  lwz r11, 0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4170: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B4174: 4804C16D  bl 0x822002e0
	ctx.lr = 0x821B4178;
	sub_822002E0(ctx, base);
	// 821B4178: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B417C: 81E10054  lwz r15, 0x54(r1)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B4180: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B4184: 419A02A8  beq cr6, 0x821b442c
	if ctx.cr[6].eq {
	pc = 0x821B442C; continue 'dispatch;
	}
	// 821B4188: 93810084  stw r28, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[28].u32 ) };
	// 821B418C: 388F0024  addi r4, r15, 0x24
	ctx.r[4].s64 = ctx.r[15].s64 + 36;
	// 821B4190: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 821B4194: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821B4198: 9381008C  stw r28, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[28].u32 ) };
	// 821B419C: 4803C155  bl 0x821f02f0
	ctx.lr = 0x821B41A0;
	sub_821F02F0(ctx, base);
	// 821B41A0: 816F0038  lwz r11, 0x38(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B41A4: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 821B41A8: C16F0034  lfs f11, 0x34(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B41AC: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 821B41B0: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 821B41B4: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 821B41B8: 82C10084  lwz r22, 0x84(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B41BC: 82A10088  lwz r21, 0x88(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 821B41C0: 7CF6A850  subf r7, r22, r21
	ctx.r[7].s64 = ctx.r[21].s64 - ctx.r[22].s64;
	// 821B41C4: 7D6753D7  divw. r11, r7, r10
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B41C8: C8010068  lfd f0, 0x68(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821B41CC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821B41D0: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B41D4: EFEC5824  fdivs f31, f12, f11
	ctx.f[31].f64 = ((ctx.f[12].f64 / ctx.f[11].f64) as f32) as f64;
	// 821B41D8: 41820234  beq 0x821b440c
	if ctx.cr[0].eq {
	pc = 0x821B440C; continue 'dispatch;
	}
	// 821B41DC: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821B41E0: 7D745B78  mr r20, r11
	ctx.r[20].u64 = ctx.r[11].u64;
	// 821B41E4: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821B41E8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 821B41EC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821B41F0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821B41F4: C3C79490  lfs f30, -0x6b70(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B41F8: 7EDBB378  mr r27, r22
	ctx.r[27].u64 = ctx.r[22].u64;
	// 821B41FC: 3E40834A  lis r18, -0x7cb6
	ctx.r[18].s64 = -2092302336;
	// 821B4200: 3E60834A  lis r19, -0x7cb6
	ctx.r[19].s64 = -2092302336;
	// 821B4204: 3AE87088  addi r23, r8, 0x7088
	ctx.r[23].s64 = ctx.r[8].s64 + 28808;
	// 821B4208: 3B49FFDF  addi r26, r9, -0x21
	ctx.r[26].s64 = ctx.r[9].s64 + -33;
	// 821B420C: 3B2AB748  addi r25, r10, -0x48b8
	ctx.r[25].s64 = ctx.r[10].s64 + -18616;
	// 821B4210: 3B0BB74C  addi r24, r11, -0x48b4
	ctx.r[24].s64 = ctx.r[11].s64 + -18612;
	pc = 0x821B4214; continue 'dispatch;
            }
            0x821B4214 => {
    //   block [0x821B4214..0x821B4238)
	// 821B4214: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 821B4218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B421C: 4803C025  bl 0x821f0240
	ctx.lr = 0x821B4220;
	sub_821F0240(ctx, base);
	// 821B4220: 8173B760  lwz r11, -0x48a0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(-18592 as u32) ) } as u64;
	// 821B4224: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B4228: 409A0010  bne cr6, 0x821b4238
	if !ctx.cr[6].eq {
	pc = 0x821B4238; continue 'dispatch;
	}
	// 821B422C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821B4230: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821B4234: 4800000C  b 0x821b4240
	pc = 0x821B4240; continue 'dispatch;
            }
            0x821B4238 => {
    //   block [0x821B4238..0x821B4240)
	// 821B4238: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B423C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821B4240; continue 'dispatch;
            }
            0x821B4240 => {
    //   block [0x821B4240..0x821B4254)
	// 821B4240: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B4244: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B4248: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821B424C: 419A0008  beq cr6, 0x821b4254
	if ctx.cr[6].eq {
	pc = 0x821B4254; continue 'dispatch;
	}
	// 821B4250: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821B4254; continue 'dispatch;
            }
            0x821B4254 => {
    //   block [0x821B4254..0x821B42E8)
	// 821B4254: 48AF5E9D  bl 0x82caa0f0
	ctx.lr = 0x821B4258;
	sub_82CAA0F0(ctx, base);
	// 821B4258: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821B425C: 409A0178  bne cr6, 0x821b43d4
	if !ctx.cr[6].eq {
	pc = 0x821B43D4; continue 'dispatch;
	}
	// 821B4260: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B4264: 4855FCAD  bl 0x82713f10
	ctx.lr = 0x821B4268;
	sub_82713F10(ctx, base);
	// 821B4268: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 821B426C: 409A0168  bne cr6, 0x821b43d4
	if !ctx.cr[6].eq {
	pc = 0x821B43D4; continue 'dispatch;
	}
	// 821B4270: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B4274: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821B4278: 4803BFC9  bl 0x821f0240
	ctx.lr = 0x821B427C;
	sub_821F0240(ctx, base);
	// 821B427C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821B4280: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821B4284: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821B4288: 480325C1  bl 0x821e6848
	ctx.lr = 0x821B428C;
	sub_821E6848(ctx, base);
	// 821B428C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821B4290: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B4294: 4803BFAD  bl 0x821f0240
	ctx.lr = 0x821B4298;
	sub_821F0240(ctx, base);
	// 821B4298: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 821B429C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821B42A0: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 821B42A4: 92A10064  stw r21, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	// 821B42A8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 821B42AC: 92C1006C  stw r22, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[22].u32 ) };
	// 821B42B0: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B42B4: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821B42B8: 48565179  bl 0x82719430
	ctx.lr = 0x821B42BC;
	sub_82719430(ctx, base);
	// 821B42BC: 83E10074  lwz r31, 0x74(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B42C0: 7F1FA840  cmplw cr6, r31, r21
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[21].u32, &mut ctx.xer);
	// 821B42C4: 419A0108  beq cr6, 0x821b43cc
	if ctx.cr[6].eq {
	pc = 0x821B43CC; continue 'dispatch;
	}
	// 821B42C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B42CC: 4855FD9D  bl 0x82714068
	ctx.lr = 0x821B42D0;
	sub_82714068(ctx, base);
	// 821B42D0: 8172B758  lwz r11, -0x48a8(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-18600 as u32) ) } as u64;
	// 821B42D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B42D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B42DC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821B42E0: 419A0008  beq cr6, 0x821b42e8
	if ctx.cr[6].eq {
	pc = 0x821B42E8; continue 'dispatch;
	}
	// 821B42E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821B42E8; continue 'dispatch;
            }
            0x821B42E8 => {
    //   block [0x821B42E8..0x821B42F8)
	// 821B42E8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821B42EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B42F0: 419A0008  beq cr6, 0x821b42f8
	if ctx.cr[6].eq {
	pc = 0x821B42F8; continue 'dispatch;
	}
	// 821B42F4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821B42F8; continue 'dispatch;
            }
            0x821B42F8 => {
    //   block [0x821B42F8..0x821B4320)
	// 821B42F8: 480324D1  bl 0x821e67c8
	ctx.lr = 0x821B42FC;
	sub_821E67C8(ctx, base);
	// 821B42FC: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821B4300: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4304: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B4308: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B430C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B4310: 694B0001  xori r11, r10, 1
	ctx.r[11].u64 = ctx.r[10].u64 ^ 1;
	// 821B4314: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B4318: 40980008  bge cr6, 0x821b4320
	if !ctx.cr[6].lt {
	pc = 0x821B4320; continue 'dispatch;
	}
	// 821B431C: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	pc = 0x821B4320; continue 'dispatch;
            }
            0x821B4320 => {
    //   block [0x821B4320..0x821B4358)
	// 821B4320: ED9EF824  fdivs f12, f30, f31
	ctx.f[12].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 821B4324: 81100000  lwz r8, 0(r16)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4328: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 821B432C: D3E100A0  stfs f31, 0xa0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 821B4330: 93C10090  stw r30, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 821B4334: 394100B4  addi r10, r1, 0xb4
	ctx.r[10].s64 = ctx.r[1].s64 + 180;
	// 821B4338: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 821B433C: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 821B4340: 910100B0  stw r8, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[8].u32 ) };
	// 821B4344: ED6D0332  fmuls f11, f13, f12
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B4348: D1610098  stfs f11, 0x98(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 821B434C: ED4C0032  fmuls f10, f12, f0
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B4350: D141009C  stfs f10, 0x9c(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 821B4354: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821B4358; continue 'dispatch;
            }
            0x821B4358 => {
    //   block [0x821B4358..0x821B4388)
	// 821B4358: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B435C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821B4360: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B4364: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821B4368: 4200FFF0  bdnz 0x821b4358
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B4358; continue 'dispatch;
	}
	// 821B436C: 81710004  lwz r11, 4(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4370: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821B4374: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 821B4378: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B437C: 894B0025  lbz r10, 0x25(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 821B4380: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B4384: 409A0038  bne cr6, 0x821b43bc
	if !ctx.cr[6].eq {
	pc = 0x821B43BC; continue 'dispatch;
	}
	pc = 0x821B4388; continue 'dispatch;
            }
            0x821B4388 => {
    //   block [0x821B4388..0x821B43AC)
	// 821B4388: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B438C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 821B4390: 7D2A4010  subfc r9, r10, r8
	ctx.xer.ca = ctx.r[8].u32 >= ctx.r[10].u32;
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 821B4394: 7CE94910  subfe r7, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821B4398: 54E507FE  clrlwi r5, r7, 0x1f
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 821B439C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B43A0: 419A000C  beq cr6, 0x821b43ac
	if ctx.cr[6].eq {
	pc = 0x821B43AC; continue 'dispatch;
	}
	// 821B43A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B43A8: 48000008  b 0x821b43b0
	pc = 0x821B43B0; continue 'dispatch;
            }
            0x821B43AC => {
    //   block [0x821B43AC..0x821B43B0)
	// 821B43AC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x821B43B0; continue 'dispatch;
            }
            0x821B43B0 => {
    //   block [0x821B43B0..0x821B43BC)
	// 821B43B0: 894B0025  lbz r10, 0x25(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 821B43B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B43B8: 419AFFD0  beq cr6, 0x821b4388
	if ctx.cr[6].eq {
	pc = 0x821B4388; continue 'dispatch;
	}
	pc = 0x821B43BC; continue 'dispatch;
            }
            0x821B43BC => {
    //   block [0x821B43BC..0x821B43CC)
	// 821B43BC: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 821B43C0: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 821B43C4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821B43C8: 48563891  bl 0x82717c58
	ctx.lr = 0x821B43CC;
	sub_82717C58(ctx, base);
	pc = 0x821B43CC; continue 'dispatch;
            }
            0x821B43CC => {
    //   block [0x821B43CC..0x821B43D4)
	// 821B43CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821B43D0: 48060A09  bl 0x82214dd8
	ctx.lr = 0x821B43D4;
	sub_82214DD8(ctx, base);
	pc = 0x821B43D4; continue 'dispatch;
            }
            0x821B43D4 => {
    //   block [0x821B43D4..0x821B43E0)
	// 821B43D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B43D8: 48012391  bl 0x821c6768
	ctx.lr = 0x821B43DC;
	sub_821C6768(ctx, base);
	// 821B43DC: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	pc = 0x821B43E0; continue 'dispatch;
            }
            0x821B43E0 => {
    //   block [0x821B43E0..0x821B440C)
	// 821B43E0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B43E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B43E8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B43EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B43F0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B43F4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B43F8: 4082FFE8  bne 0x821b43e0
	if !ctx.cr[0].eq {
	pc = 0x821B43E0; continue 'dispatch;
	}
	// 821B43FC: 3694FFFF  addic. r20, r20, -1
	ctx.xer.ca = (ctx.r[20].u32 > (!(-1 as u32)));
	ctx.r[20].s64 = ctx.r[20].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 821B4400: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821B4404: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 821B4408: 4082FE0C  bne 0x821b4214
	if !ctx.cr[0].eq {
	pc = 0x821B4214; continue 'dispatch;
	}
	pc = 0x821B440C; continue 'dispatch;
            }
            0x821B440C => {
    //   block [0x821B440C..0x821B442C)
	// 821B440C: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 821B4410: 419A001C  beq cr6, 0x821b442c
	if ctx.cr[6].eq {
	pc = 0x821B442C; continue 'dispatch;
	}
	// 821B4414: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821B4418: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 821B441C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B4420: 483B25F1  bl 0x82566a10
	ctx.lr = 0x821B4424;
	sub_82566A10(ctx, base);
	// 821B4424: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B4428: 48067911  bl 0x8221bd38
	ctx.lr = 0x821B442C;
	sub_8221BD38(ctx, base);
	pc = 0x821B442C; continue 'dispatch;
            }
            0x821B442C => {
    //   block [0x821B442C..0x821B4438)
	// 821B442C: 2B0F0000  cmplwi cr6, r15, 0
	ctx.cr[6].compare_u32(ctx.r[15].u32, 0 as u32, &mut ctx.xer);
	// 821B4430: 419A0044  beq cr6, 0x821b4474
	if ctx.cr[6].eq {
	pc = 0x821B4474; continue 'dispatch;
	}
	// 821B4434: 396F0004  addi r11, r15, 4
	ctx.r[11].s64 = ctx.r[15].s64 + 4;
	pc = 0x821B4438; continue 'dispatch;
            }
            0x821B4438 => {
    //   block [0x821B4438..0x821B4474)
	// 821B4438: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821B443C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4440: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821B4444: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821B4448: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B444C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4450: 4082FFE8  bne 0x821b4438
	if !ctx.cr[0].eq {
	pc = 0x821B4438; continue 'dispatch;
	}
	// 821B4454: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821B4458: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B445C: 409A0018  bne cr6, 0x821b4474
	if !ctx.cr[6].eq {
	pc = 0x821B4474; continue 'dispatch;
	}
	// 821B4460: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4464: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 821B4468: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B446C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4470: 4E800421  bctrl
	ctx.lr = 0x821B4474;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821B4474 => {
    //   block [0x821B4474..0x821B4484)
	// 821B4474: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 821B4478: CBC1FF60  lfd f30, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 821B447C: CBE1FF68  lfd f31, -0x98(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821B4480: 48AF4FA4  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4488 size=188
    let mut pc: u32 = 0x821B4488;
    'dispatch: loop {
        match pc {
            0x821B4488 => {
    //   block [0x821B4488..0x821B4544)
	// 821B4488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B448C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B4490: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B4494: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B4498: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821B449C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B44A0: 3FC0820A  lis r30, -0x7df6
	ctx.r[30].s64 = -2113273856;
	// 821B44A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B44A8: 397E9484  addi r11, r30, -0x6b7c
	ctx.r[11].s64 = ctx.r[30].s64 + -27516;
	// 821B44AC: C00BFE50  lfs f0, -0x1b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B44B0: EFE10032  fmuls f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B44B4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B44B8: 48085AD9  bl 0x82239f90
	ctx.lr = 0x821B44BC;
	sub_82239F90(ctx, base);
	// 821B44BC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B44C0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821B44C4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B44C8: 480859E9  bl 0x82239eb0
	ctx.lr = 0x821B44CC;
	sub_82239EB0(ctx, base);
	// 821B44CC: 38E1005C  addi r7, r1, 0x5c
	ctx.r[7].s64 = ctx.r[1].s64 + 92;
	// 821B44D0: C01E9484  lfs f0, -0x6b7c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B44D4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821B44D8: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821B44DC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821B44E0: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B44E4: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 821B44E8: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B44EC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821B44F0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4548 size=308
    let mut pc: u32 = 0x821B4548;
    'dispatch: loop {
        match pc {
            0x821B4548 => {
    //   block [0x821B4548..0x821B467C)
	// 821B4548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B454C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B4550: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B4554: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 821B4558: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821B455C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4560: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B4564: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821B4568: 48085A29  bl 0x82239f90
	ctx.lr = 0x821B456C;
	sub_82239F90(ctx, base);
	// 821B456C: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B4570: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821B4574: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821B4578: 48085939  bl 0x82239eb0
	ctx.lr = 0x821B457C;
	sub_82239EB0(ctx, base);
	// 821B457C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B4580: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821B4584: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B4588: FDA0F850  fneg f13, f31
	ctx.f[13].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 821B458C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B4590: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 821B4594: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821B4598: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821B459C: C1AB9490  lfs f13, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B45A0: 38E1005C  addi r7, r1, 0x5c
	ctx.r[7].s64 = ctx.r[1].s64 + 92;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4680 size=436
    let mut pc: u32 = 0x821B4680;
    'dispatch: loop {
        match pc {
            0x821B4680 => {
    //   block [0x821B4680..0x821B4834)
	// 821B4680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4684: 48AF4D89  bl 0x82ca940c
	ctx.lr = 0x821B4688;
	sub_82CA93D0(ctx, base);
	// 821B4688: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B468C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B4690: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821B4694: 38EB9484  addi r7, r11, -0x6b7c
	ctx.r[7].s64 = ctx.r[11].s64 + -27516;
	// 821B4698: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821B469C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B46A0: 38A99160  addi r5, r9, -0x6ea0
	ctx.r[5].s64 = ctx.r[9].s64 + -28320;
	// 821B46A4: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 821B46A8: C007000C  lfs f0, 0xc(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B46AC: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B46B0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B46B4: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4838 size=228
    let mut pc: u32 = 0x821B4838;
    'dispatch: loop {
        match pc {
            0x821B4838 => {
    //   block [0x821B4838..0x821B491C)
	// 821B4838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B483C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B4840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B4844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B4848: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B484C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B4850: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 821B4854: 390BB480  addi r8, r11, -0x4b80
	ctx.r[8].s64 = ctx.r[11].s64 + -19328;
	// 821B4858: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821B485C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 821B4860: C00BB480  lfs f0, -0x4b80(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4864: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B4868: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B486C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 821B4870: C1A8E010  lfs f13, -0x1ff0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4874: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B4878: C008E004  lfs f0, -0x1ffc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B487C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821B4880: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B4920 size=552
    let mut pc: u32 = 0x821B4920;
    'dispatch: loop {
        match pc {
            0x821B4920 => {
    //   block [0x821B4920..0x821B4B48)
	// 821B4920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4924: 48AF4AE1  bl 0x82ca9404
	ctx.lr = 0x821B4928;
	sub_82CA93D0(ctx, base);
	// 821B4928: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821B492C: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 821B4930: 48E520A5  bl 0x830069d4
	ctx.lr = 0x821B4934;
	sub_83006760(ctx, base);
	// 821B4934: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4B48 size=236
    let mut pc: u32 = 0x821B4B48;
    'dispatch: loop {
        match pc {
            0x821B4B48 => {
    //   block [0x821B4B48..0x821B4C34)
	// 821B4B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4B4C: 48AF48C1  bl 0x82ca940c
	ctx.lr = 0x821B4B50;
	sub_82CA93D0(ctx, base);
	// 821B4B50: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 821B4B54: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821B4B58: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4B5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B4B60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B4B64: C01F0288  lfs f0, 0x288(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(648 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4B68: C1BF0208  lfs f13, 0x208(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4B6C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B4B70: C17F028C  lfs f11, 0x28c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(652 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B4B74: C15F020C  lfs f10, 0x20c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B4B78: CBEB0D30  lfd f31, 0xd30(r11)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3376 as u32) ) };
	// 821B4B7C: ED2A5828  fsubs f9, f10, f11
	ctx.f[9].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821B4B80: ED0C007A  fmadds f8, f12, f1, f0
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 821B4B84: EFC9587A  fmadds f30, f9, f1, f11
	ctx.f[30].f64 = (((ctx.f[9].f64 * ctx.f[1].f64 + ctx.f[11].f64) as f32) as f64);
	// 821B4B88: FCE807F2  fmul f7, f8, f31
	ctx.f[7].f64 = ctx.f[8].f64 * ctx.f[31].f64;
	// 821B4B8C: FC203818  frsp f1, f7
	ctx.f[1].f64 = (ctx.f[7].f64 as f32) as f64;
	// 821B4B90: 480DF589  bl 0x82294118
	ctx.lr = 0x821B4B94;
	sub_82294118(ctx, base);
	// 821B4B94: FCC00818  frsp f6, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[6].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B4B98: 3FC0820A  lis r30, -0x7df6
	ctx.r[30].s64 = -2113273856;
	// 821B4B9C: FCBE07F2  fmul f5, f30, f31
	ctx.f[5].f64 = ctx.f[30].f64 * ctx.f[31].f64;
	// 821B4BA0: 3BBE9490  addi r29, r30, -0x6b70
	ctx.r[29].s64 = ctx.r[30].s64 + -27504;
	// 821B4BA4: C3FD1FF0  lfs f31, 0x1ff0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8176 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B4BA8: EC8607F2  fmuls f4, f6, f31
	ctx.f[4].f64 = (((ctx.f[6].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B4BAC: D09F00B8  stfs f4, 0xb8(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821B4BB0: FC202818  frsp f1, f5
	ctx.f[1].f64 = (ctx.f[5].f64 as f32) as f64;
	// 821B4BB4: 480DF565  bl 0x82294118
	ctx.lr = 0x821B4BB8;
	sub_82294118(ctx, base);
	// 821B4BB8: C07F0204  lfs f3, 0x204(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(516 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821B4BBC: C01F0200  lfs f0, 0x200(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4BC0: FD600818  frsp f11, f1
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B4BC4: ED430028  fsubs f10, f3, f0
	ctx.f[10].f64 = (((ctx.f[3].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B4BC8: C13F00B8  lfs f9, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821B4BCC: C1BDFFF4  lfs f13, -0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4BD0: 387F0110  addi r3, r31, 0x110
	ctx.r[3].s64 = ctx.r[31].s64 + 272;
	// 821B4BD4: EC3F4824  fdivs f1, f31, f9
	ctx.f[1].f64 = ((ctx.f[31].f64 / ctx.f[9].f64) as f32) as f64;
	// 821B4BD8: C19E9490  lfs f12, -0x6b70(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B4BDC: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821B4BE0: FD206890  fmr f9, f13
	ctx.f[9].f64 = ctx.f[13].f64;
	// 821B4BE4: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821B4BE8: FD006890  fmr f8, f13
	ctx.f[8].f64 = ctx.f[13].f64;
	// 821B4BEC: FCE06890  fmr f7, f13
	ctx.f[7].f64 = ctx.f[13].f64;
	// 821B4BF0: FCA06890  fmr f5, f13
	ctx.f[5].f64 = ctx.f[13].f64;
	// 821B4BF4: FC806890  fmr f4, f13
	ctx.f[4].f64 = ctx.f[13].f64;
	// 821B4BF8: FC406890  fmr f2, f13
	ctx.f[2].f64 = ctx.f[13].f64;
	// 821B4BFC: ECCB07F2  fmuls f6, f11, f31
	ctx.f[6].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B4C00: D0DF00BC  stfs f6, 0xbc(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 821B4C04: ED635024  fdivs f11, f3, f10
	ctx.f[11].f64 = ((ctx.f[3].f64 / ctx.f[10].f64) as f32) as f64;
	// 821B4C08: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	// 821B4C0C: FC606890  fmr f3, f13
	ctx.f[3].f64 = ctx.f[13].f64;
	// 821B4C10: ECDF3024  fdivs f6, f31, f6
	ctx.f[6].f64 = ((ctx.f[31].f64 / ctx.f[6].f64) as f32) as f64;
	// 821B4C14: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 821B4C18: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821B4C1C: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821B4C20: 4BFE8A71  bl 0x8219d690
	ctx.lr = 0x821B4C24;
	sub_8219D690(ctx, base);
	// 821B4C24: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821B4C28: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821B4C2C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821B4C30: 48AF482C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B4C38 size=904
    let mut pc: u32 = 0x821B4C38;
    'dispatch: loop {
        match pc {
            0x821B4C38 => {
    //   block [0x821B4C38..0x821B4C90)
	// 821B4C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4C3C: 48AF47D1  bl 0x82ca940c
	ctx.lr = 0x821B4C40;
	sub_82CA93D0(ctx, base);
	// 821B4C40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4C44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B4C48: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B4C4C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821B4C50: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4C54: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B4C58: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 821B4C5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B4C60: 419A00F4  beq cr6, 0x821b4d54
	if ctx.cr[6].eq {
	pc = 0x821B4D54; continue 'dispatch;
	}
	// 821B4C64: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B4C68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B4C6C: 419A0024  beq cr6, 0x821b4c90
	if ctx.cr[6].eq {
	pc = 0x821B4C90; continue 'dispatch;
	}
	// 821B4C70: 892A0013  lbz r9, 0x13(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 821B4C74: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B4C78: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821B4C7C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B4C80: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4C84: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B4C88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B4C8C: 480000CC  b 0x821b4d58
	pc = 0x821B4D58; continue 'dispatch;
            }
            0x821B4C90 => {
    //   block [0x821B4C90..0x821B4CAC)
	// 821B4C90: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B4C94: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B4C98: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821B4C9C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B4CA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B4CA4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B4CA8: 40810054  ble 0x821b4cfc
	if !ctx.cr[0].gt {
	pc = 0x821B4CFC; continue 'dispatch;
	}
	pc = 0x821B4CAC; continue 'dispatch;
            }
            0x821B4CAC => {
    //   block [0x821B4CAC..0x821B4CCC)
	// 821B4CAC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B4CB0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B4CB4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B4CB8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4CBC: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 821B4CC0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B4CC4: 41980008  blt cr6, 0x821b4ccc
	if ctx.cr[6].lt {
	pc = 0x821B4CCC; continue 'dispatch;
	}
	// 821B4CC8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x821B4CCC; continue 'dispatch;
            }
            0x821B4CCC => {
    //   block [0x821B4CCC..0x821B4CE8)
	// 821B4CCC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B4CD0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B4CD4: 419A0014  beq cr6, 0x821b4ce8
	if ctx.cr[6].eq {
	pc = 0x821B4CE8; continue 'dispatch;
	}
	// 821B4CD8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B4CDC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B4CE0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B4CE4: 4800000C  b 0x821b4cf0
	pc = 0x821B4CF0; continue 'dispatch;
            }
            0x821B4CE8 => {
    //   block [0x821B4CE8..0x821B4CF0)
	// 821B4CE8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B4CEC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821B4CF0; continue 'dispatch;
            }
            0x821B4CF0 => {
    //   block [0x821B4CF0..0x821B4CFC)
	// 821B4CF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B4CF4: 4199FFB8  bgt cr6, 0x821b4cac
	if ctx.cr[6].gt {
	pc = 0x821B4CAC; continue 'dispatch;
	}
	// 821B4CF8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821B4CFC; continue 'dispatch;
            }
            0x821B4CFC => {
    //   block [0x821B4CFC..0x821B4D18)
	// 821B4CFC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B4D00: 419A0040  beq cr6, 0x821b4d40
	if ctx.cr[6].eq {
	pc = 0x821B4D40; continue 'dispatch;
	}
	// 821B4D04: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4D08: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 821B4D0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B4D10: 41990008  bgt cr6, 0x821b4d18
	if ctx.cr[6].gt {
	pc = 0x821B4D18; continue 'dispatch;
	}
	// 821B4D14: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821B4D18; continue 'dispatch;
            }
            0x821B4D18 => {
    //   block [0x821B4D18..0x821B4D40)
	// 821B4D18: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B4D1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B4D20: 409A0020  bne cr6, 0x821b4d40
	if !ctx.cr[6].eq {
	pc = 0x821B4D40; continue 'dispatch;
	}
	// 821B4D24: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B4D28: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B4D2C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B4D30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4D34: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B4D38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B4D3C: 4800001C  b 0x821b4d58
	pc = 0x821B4D58; continue 'dispatch;
            }
            0x821B4D40 => {
    //   block [0x821B4D40..0x821B4D54)
	// 821B4D40: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B4D44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4D48: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B4D4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B4D50: 48000008  b 0x821b4d58
	pc = 0x821B4D58; continue 'dispatch;
            }
            0x821B4D54 => {
    //   block [0x821B4D54..0x821B4D58)
	// 821B4D54: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821B4D58; continue 'dispatch;
            }
            0x821B4D58 => {
    //   block [0x821B4D58..0x821B4D8C)
	// 821B4D58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B4D5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B4D60: 419A0188  beq cr6, 0x821b4ee8
	if ctx.cr[6].eq {
	pc = 0x821B4EE8; continue 'dispatch;
	}
	// 821B4D64: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B4D68: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821B4D6C: 419A005C  beq cr6, 0x821b4dc8
	if ctx.cr[6].eq {
	pc = 0x821B4DC8; continue 'dispatch;
	}
	// 821B4D70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B4D74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4D78: 480F92A9  bl 0x822ae020
	ctx.lr = 0x821B4D7C;
	sub_822AE020(ctx, base);
	// 821B4D7C: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B4D80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4D84: 419A0040  beq cr6, 0x821b4dc4
	if ctx.cr[6].eq {
	pc = 0x821B4DC4; continue 'dispatch;
	}
	// 821B4D88: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821B4D8C; continue 'dispatch;
            }
            0x821B4D8C => {
    //   block [0x821B4D8C..0x821B4DC0)
	// 821B4D8C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B4D90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4D94: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B4D98: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B4D9C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B4DA0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4DA4: 4082FFE8  bne 0x821b4d8c
	if !ctx.cr[0].eq {
	pc = 0x821B4D8C; continue 'dispatch;
	}
	// 821B4DA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B4DAC: 409A0014  bne cr6, 0x821b4dc0
	if !ctx.cr[6].eq {
	pc = 0x821B4DC0; continue 'dispatch;
	}
	// 821B4DB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4DB4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4DB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4DBC: 4E800421  bctrl
	ctx.lr = 0x821B4DC0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821B4DC0 => {
    //   block [0x821B4DC0..0x821B4DC4)
	// 821B4DC0: 93BE0018  stw r29, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	pc = 0x821B4DC4; continue 'dispatch;
            }
            0x821B4DC4 => {
    //   block [0x821B4DC4..0x821B4DC8)
	// 821B4DC4: 93BE0018  stw r29, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	pc = 0x821B4DC8; continue 'dispatch;
            }
            0x821B4DC8 => {
    //   block [0x821B4DC8..0x821B4DF0)
	// 821B4DC8: 809E001C  lwz r4, 0x1c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B4DCC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821B4DD0: 419A005C  beq cr6, 0x821b4e2c
	if ctx.cr[6].eq {
	pc = 0x821B4E2C; continue 'dispatch;
	}
	// 821B4DD4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B4DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4DDC: 480F9245  bl 0x822ae020
	ctx.lr = 0x821B4DE0;
	sub_822AE020(ctx, base);
	// 821B4DE0: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B4DE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4DE8: 419A0040  beq cr6, 0x821b4e28
	if ctx.cr[6].eq {
	pc = 0x821B4E28; continue 'dispatch;
	}
	// 821B4DEC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821B4DF0; continue 'dispatch;
            }
            0x821B4DF0 => {
    //   block [0x821B4DF0..0x821B4E24)
	// 821B4DF0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B4DF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4DF8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B4DFC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B4E00: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B4E04: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4E08: 4082FFE8  bne 0x821b4df0
	if !ctx.cr[0].eq {
	pc = 0x821B4DF0; continue 'dispatch;
	}
	// 821B4E0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B4E10: 409A0014  bne cr6, 0x821b4e24
	if !ctx.cr[6].eq {
	pc = 0x821B4E24; continue 'dispatch;
	}
	// 821B4E14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4E18: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4E1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4E20: 4E800421  bctrl
	ctx.lr = 0x821B4E24;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821B4E24 => {
    //   block [0x821B4E24..0x821B4E28)
	// 821B4E24: 93BE001C  stw r29, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	pc = 0x821B4E28; continue 'dispatch;
            }
            0x821B4E28 => {
    //   block [0x821B4E28..0x821B4E2C)
	// 821B4E28: 93BE001C  stw r29, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	pc = 0x821B4E2C; continue 'dispatch;
            }
            0x821B4E2C => {
    //   block [0x821B4E2C..0x821B4E54)
	// 821B4E2C: 809E0020  lwz r4, 0x20(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B4E30: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821B4E34: 419A005C  beq cr6, 0x821b4e90
	if ctx.cr[6].eq {
	pc = 0x821B4E90; continue 'dispatch;
	}
	// 821B4E38: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B4E3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4E40: 480F91E1  bl 0x822ae020
	ctx.lr = 0x821B4E44;
	sub_822AE020(ctx, base);
	// 821B4E44: 807E0020  lwz r3, 0x20(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B4E48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4E4C: 419A0040  beq cr6, 0x821b4e8c
	if ctx.cr[6].eq {
	pc = 0x821B4E8C; continue 'dispatch;
	}
	// 821B4E50: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821B4E54; continue 'dispatch;
            }
            0x821B4E54 => {
    //   block [0x821B4E54..0x821B4E88)
	// 821B4E54: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B4E58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4E5C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B4E60: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B4E64: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B4E68: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4E6C: 4082FFE8  bne 0x821b4e54
	if !ctx.cr[0].eq {
	pc = 0x821B4E54; continue 'dispatch;
	}
	// 821B4E70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B4E74: 409A0014  bne cr6, 0x821b4e88
	if !ctx.cr[6].eq {
	pc = 0x821B4E88; continue 'dispatch;
	}
	// 821B4E78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4E7C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4E80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4E84: 4E800421  bctrl
	ctx.lr = 0x821B4E88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821B4E88 => {
    //   block [0x821B4E88..0x821B4E8C)
	// 821B4E88: 93BE0020  stw r29, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	pc = 0x821B4E8C; continue 'dispatch;
            }
            0x821B4E8C => {
    //   block [0x821B4E8C..0x821B4E90)
	// 821B4E8C: 93BE0020  stw r29, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	pc = 0x821B4E90; continue 'dispatch;
            }
            0x821B4E90 => {
    //   block [0x821B4E90..0x821B4EBC)
	// 821B4E90: 807E0044  lwz r3, 0x44(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 821B4E94: 3BFE0044  addi r31, r30, 0x44
	ctx.r[31].s64 = ctx.r[30].s64 + 68;
	// 821B4E98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4E9C: 419A0020  beq cr6, 0x821b4ebc
	if ctx.cr[6].eq {
	pc = 0x821B4EBC; continue 'dispatch;
	}
	// 821B4EA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4EA4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B4EA8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4EAC: 4E800421  bctrl
	ctx.lr = 0x821B4EB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4EB4: 48002C65  bl 0x821b7b18
	ctx.lr = 0x821B4EB8;
	sub_821B7B18(ctx, base);
	// 821B4EB8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x821B4EBC => {
    //   block [0x821B4EBC..0x821B4EE8)
	// 821B4EBC: 807E004C  lwz r3, 0x4c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B4EC0: 3BFE004C  addi r31, r30, 0x4c
	ctx.r[31].s64 = ctx.r[30].s64 + 76;
	// 821B4EC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4EC8: 419A0020  beq cr6, 0x821b4ee8
	if ctx.cr[6].eq {
	pc = 0x821B4EE8; continue 'dispatch;
	}
	// 821B4ECC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4ED0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B4ED4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4ED8: 4E800421  bctrl
	ctx.lr = 0x821B4EDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4EDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4EE0: 48002C39  bl 0x821b7b18
	ctx.lr = 0x821B4EE4;
	sub_821B7B18(ctx, base);
	// 821B4EE4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x821B4EE8 => {
    //   block [0x821B4EE8..0x821B4F14)
	// 821B4EE8: 807E002C  lwz r3, 0x2c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B4EEC: 3BFE002C  addi r31, r30, 0x2c
	ctx.r[31].s64 = ctx.r[30].s64 + 44;
	// 821B4EF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4EF4: 419A0020  beq cr6, 0x821b4f14
	if ctx.cr[6].eq {
	pc = 0x821B4F14; continue 'dispatch;
	}
	// 821B4EF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4EFC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B4F00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4F04: 4E800421  bctrl
	ctx.lr = 0x821B4F08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4F0C: 48002C0D  bl 0x821b7b18
	ctx.lr = 0x821B4F10;
	sub_821B7B18(ctx, base);
	// 821B4F10: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x821B4F14 => {
    //   block [0x821B4F14..0x821B4F40)
	// 821B4F14: 807E0034  lwz r3, 0x34(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 821B4F18: 3BFE0034  addi r31, r30, 0x34
	ctx.r[31].s64 = ctx.r[30].s64 + 52;
	// 821B4F1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4F20: 419A0020  beq cr6, 0x821b4f40
	if ctx.cr[6].eq {
	pc = 0x821B4F40; continue 'dispatch;
	}
	// 821B4F24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4F28: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B4F2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4F30: 4E800421  bctrl
	ctx.lr = 0x821B4F34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4F38: 48002BE1  bl 0x821b7b18
	ctx.lr = 0x821B4F3C;
	sub_821B7B18(ctx, base);
	// 821B4F3C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x821B4F40 => {
    //   block [0x821B4F40..0x821B4F6C)
	// 821B4F40: 807E0024  lwz r3, 0x24(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B4F44: 3BFE0024  addi r31, r30, 0x24
	ctx.r[31].s64 = ctx.r[30].s64 + 36;
	// 821B4F48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4F4C: 419A0020  beq cr6, 0x821b4f6c
	if ctx.cr[6].eq {
	pc = 0x821B4F6C; continue 'dispatch;
	}
	// 821B4F50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4F54: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B4F58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4F5C: 4E800421  bctrl
	ctx.lr = 0x821B4F60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4F60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4F64: 48002BB5  bl 0x821b7b18
	ctx.lr = 0x821B4F68;
	sub_821B7B18(ctx, base);
	// 821B4F68: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x821B4F6C => {
    //   block [0x821B4F6C..0x821B4F98)
	// 821B4F6C: 807E003C  lwz r3, 0x3c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B4F70: 3BFE003C  addi r31, r30, 0x3c
	ctx.r[31].s64 = ctx.r[30].s64 + 60;
	// 821B4F74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4F78: 419A0020  beq cr6, 0x821b4f98
	if ctx.cr[6].eq {
	pc = 0x821B4F98; continue 'dispatch;
	}
	// 821B4F7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4F80: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B4F84: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4F88: 4E800421  bctrl
	ctx.lr = 0x821B4F8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4F8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4F90: 48002B89  bl 0x821b7b18
	ctx.lr = 0x821B4F94;
	sub_821B7B18(ctx, base);
	// 821B4F94: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x821B4F98 => {
    //   block [0x821B4F98..0x821B4FC0)
	// 821B4F98: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4F9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4FA0: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B4FA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4FA8: 4E800421  bctrl
	ctx.lr = 0x821B4FAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4FAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B4FB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4FB4: 480D3735  bl 0x822886e8
	ctx.lr = 0x821B4FB8;
	sub_822886E8(ctx, base);
	// 821B4FB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B4FBC: 48AF44A0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B4FC0 size=380
    let mut pc: u32 = 0x821B4FC0;
    'dispatch: loop {
        match pc {
            0x821B4FC0 => {
    //   block [0x821B4FC0..0x821B4FF4)
	// 821B4FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4FC4: 48AF4449  bl 0x82ca940c
	ctx.lr = 0x821B4FC8;
	sub_82CA93D0(ctx, base);
	// 821B4FC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4FCC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B4FD0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821B4FD4: 3BFD0008  addi r31, r29, 8
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	// 821B4FD8: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B4FDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4FE0: 419A0014  beq cr6, 0x821b4ff4
	if ctx.cr[6].eq {
	pc = 0x821B4FF4; continue 'dispatch;
	}
	// 821B4FE4: 480E2355  bl 0x82297338
	ctx.lr = 0x821B4FE8;
	sub_82297338(ctx, base);
	// 821B4FE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4FEC: 48002B2D  bl 0x821b7b18
	ctx.lr = 0x821B4FF0;
	sub_821B7B18(ctx, base);
	// 821B4FF0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x821B4FF4; continue 'dispatch;
            }
            0x821B4FF4 => {
    //   block [0x821B4FF4..0x821B5038)
	// 821B4FF4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4FF8: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821B4FFC: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B5000: 55289FFE  rlwinm r8, r9, 0x13, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00001FFFu64;
	// 821B5004: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B5008: 419A00F4  beq cr6, 0x821b50fc
	if ctx.cr[6].eq {
	pc = 0x821B50FC; continue 'dispatch;
	}
	// 821B500C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B5010: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B5014: 419A0024  beq cr6, 0x821b5038
	if ctx.cr[6].eq {
	pc = 0x821B5038; continue 'dispatch;
	}
	// 821B5018: 892A006D  lbz r9, 0x6d(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(109 as u32) ) } as u64;
	// 821B501C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B5020: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821B5024: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B5028: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B502C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B5030: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B5034: 480000CC  b 0x821b5100
	pc = 0x821B5100; continue 'dispatch;
            }
            0x821B5038 => {
    //   block [0x821B5038..0x821B5054)
	// 821B5038: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B503C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B5040: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821B5044: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B5048: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B504C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B5050: 40810054  ble 0x821b50a4
	if !ctx.cr[0].gt {
	pc = 0x821B50A4; continue 'dispatch;
	}
	pc = 0x821B5054; continue 'dispatch;
            }
            0x821B5054 => {
    //   block [0x821B5054..0x821B5074)
	// 821B5054: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B5058: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B505C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B5060: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5064: 2F07006D  cmpwi cr6, r7, 0x6d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 109, &mut ctx.xer);
	// 821B5068: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B506C: 41980008  blt cr6, 0x821b5074
	if ctx.cr[6].lt {
	pc = 0x821B5074; continue 'dispatch;
	}
	// 821B5070: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x821B5074; continue 'dispatch;
            }
            0x821B5074 => {
    //   block [0x821B5074..0x821B5090)
	// 821B5074: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B5078: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B507C: 419A0014  beq cr6, 0x821b5090
	if ctx.cr[6].eq {
	pc = 0x821B5090; continue 'dispatch;
	}
	// 821B5080: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B5084: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B5088: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B508C: 4800000C  b 0x821b5098
	pc = 0x821B5098; continue 'dispatch;
            }
            0x821B5090 => {
    //   block [0x821B5090..0x821B5098)
	// 821B5090: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B5094: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821B5098; continue 'dispatch;
            }
            0x821B5098 => {
    //   block [0x821B5098..0x821B50A4)
	// 821B5098: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B509C: 4199FFB8  bgt cr6, 0x821b5054
	if ctx.cr[6].gt {
	pc = 0x821B5054; continue 'dispatch;
	}
	// 821B50A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821B50A4; continue 'dispatch;
            }
            0x821B50A4 => {
    //   block [0x821B50A4..0x821B50C0)
	// 821B50A4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B50A8: 419A0040  beq cr6, 0x821b50e8
	if ctx.cr[6].eq {
	pc = 0x821B50E8; continue 'dispatch;
	}
	// 821B50AC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B50B0: 2F0B006D  cmpwi cr6, r11, 0x6d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 109, &mut ctx.xer);
	// 821B50B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B50B8: 41990008  bgt cr6, 0x821b50c0
	if ctx.cr[6].gt {
	pc = 0x821B50C0; continue 'dispatch;
	}
	// 821B50BC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821B50C0; continue 'dispatch;
            }
            0x821B50C0 => {
    //   block [0x821B50C0..0x821B50E8)
	// 821B50C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B50C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B50C8: 409A0020  bne cr6, 0x821b50e8
	if !ctx.cr[6].eq {
	pc = 0x821B50E8; continue 'dispatch;
	}
	// 821B50CC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B50D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B50D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B50D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B50DC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B50E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B50E4: 4800001C  b 0x821b5100
	pc = 0x821B5100; continue 'dispatch;
            }
            0x821B50E8 => {
    //   block [0x821B50E8..0x821B50FC)
	// 821B50E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B50EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B50F0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B50F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B50F8: 48000008  b 0x821b5100
	pc = 0x821B5100; continue 'dispatch;
            }
            0x821B50FC => {
    //   block [0x821B50FC..0x821B5100)
	// 821B50FC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821B5100; continue 'dispatch;
            }
            0x821B5100 => {
    //   block [0x821B5100..0x821B5120)
	// 821B5100: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B5104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5108: 419A0018  beq cr6, 0x821b5120
	if ctx.cr[6].eq {
	pc = 0x821B5120; continue 'dispatch;
	}
	// 821B510C: 816A0050  lwz r11, 0x50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B5110: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B5114: 419A000C  beq cr6, 0x821b5120
	if ctx.cr[6].eq {
	pc = 0x821B5120; continue 'dispatch;
	}
	// 821B5118: 93CA0050  stw r30, 0x50(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821B511C: 93CA005C  stw r30, 0x5c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	pc = 0x821B5120; continue 'dispatch;
            }
            0x821B5120 => {
    //   block [0x821B5120..0x821B513C)
	// 821B5120: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5124: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B5128: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B512C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B5130: 4E800421  bctrl
	ctx.lr = 0x821B5134;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B5134: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B5138: 48AF4324  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B5140 size=204
    let mut pc: u32 = 0x821B5140;
    'dispatch: loop {
        match pc {
            0x821B5140 => {
    //   block [0x821B5140..0x821B5160)
	// 821B5140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5144: 48AF42B1  bl 0x82ca93f4
	ctx.lr = 0x821B5148;
	sub_82CA93D0(ctx, base);
	// 821B5148: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B514C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821B5150: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821B5154: 3B0B02B0  addi r24, r11, 0x2b0
	ctx.r[24].s64 = ctx.r[11].s64 + 688;
	// 821B5158: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 821B515C: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	pc = 0x821B5160; continue 'dispatch;
            }
            0x821B5160 => {
    //   block [0x821B5160..0x821B5174)
	// 821B5160: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5164: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5168: 419A000C  beq cr6, 0x821b5174
	if ctx.cr[6].eq {
	pc = 0x821B5174; continue 'dispatch;
	}
	// 821B516C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B5170: 489B13C1  bl 0x82b66530
	ctx.lr = 0x821B5174;
	sub_82B66530(ctx, base);
	pc = 0x821B5174; continue 'dispatch;
            }
            0x821B5174 => {
    //   block [0x821B5174..0x821B51B0)
	// 821B5174: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821B5178: 39780050  addi r11, r24, 0x50
	ctx.r[11].s64 = ctx.r[24].s64 + 80;
	// 821B517C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821B5180: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B5184: 4198FFDC  blt cr6, 0x821b5160
	if ctx.cr[6].lt {
	pc = 0x821B5160; continue 'dispatch;
	}
	// 821B5188: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821B518C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 821B5190: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B5194: 3BE00010  li r31, 0x10
	ctx.r[31].s64 = 16;
	// 821B5198: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 821B519C: 3B200004  li r25, 4
	ctx.r[25].s64 = 4;
	// 821B51A0: 793DFFE6  rldicr r29, r9, 0x3f, 0x3f
	ctx.r[29].u64 = (ctx.r[9].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821B51A4: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 821B51A8: 3B4A02A0  addi r26, r10, 0x2a0
	ctx.r[26].s64 = ctx.r[10].s64 + 672;
	// 821B51AC: 3B8BB0BC  addi r28, r11, -0x4f44
	ctx.r[28].s64 = ctx.r[11].s64 + -20292;
	pc = 0x821B51B0; continue 'dispatch;
            }
            0x821B51B0 => {
    //   block [0x821B51B0..0x821B51CC)
	// 821B51B0: 7D7ED02E  lwzx r11, r30, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 821B51B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B51B8: 419A003C  beq cr6, 0x821b51f4
	if ctx.cr[6].eq {
	pc = 0x821B51F4; continue 'dispatch;
	}
	// 821B51BC: 2B1F0010  cmplwi cr6, r31, 0x10
	ctx.cr[6].compare_u32(ctx.r[31].u32, 16 as u32, &mut ctx.xer);
	// 821B51C0: 39780040  addi r11, r24, 0x40
	ctx.r[11].s64 = ctx.r[24].s64 + 64;
	// 821B51C4: 41980008  blt cr6, 0x821b51cc
	if ctx.cr[6].lt {
	pc = 0x821B51CC; continue 'dispatch;
	}
	// 821B51C8: 397A0040  addi r11, r26, 0x40
	ctx.r[11].s64 = ctx.r[26].s64 + 64;
	pc = 0x821B51CC; continue 'dispatch;
            }
            0x821B51CC => {
    //   block [0x821B51CC..0x821B51F4)
	// 821B51CC: 7EFE592E  stwx r23, r30, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), ctx.r[23].u32) };
	// 821B51D0: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821B51D4: 41980020  blt cr6, 0x821b51f4
	if ctx.cr[6].lt {
	pc = 0x821B51F4; continue 'dispatch;
	}
	// 821B51D8: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 821B51DC: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B51E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B51E4: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B51E8: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821B51EC: 7FA65436  srd r6, r29, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[29].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821B51F0: 48001CF1  bl 0x821b6ee0
	ctx.lr = 0x821B51F4;
	sub_821B6EE0(ctx, base);
	pc = 0x821B51F4; continue 'dispatch;
            }
            0x821B51F4 => {
    //   block [0x821B51F4..0x821B520C)
	// 821B51F4: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 821B51F8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B51FC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B5200: 4082FFB0  bne 0x821b51b0
	if !ctx.cr[0].eq {
	pc = 0x821B51B0; continue 'dispatch;
	}
	// 821B5204: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B5208: 48AF423C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B5210 size=76
    let mut pc: u32 = 0x821B5210;
    'dispatch: loop {
        match pc {
            0x821B5210 => {
    //   block [0x821B5210..0x821B525C)
	// 821B5210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B5218: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B521C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B5224: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5228: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B522C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B5230: 4E800421  bctrl
	ctx.lr = 0x821B5234;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B5234: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B523C: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B5240: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821B5244: 4E800421  bctrl
	ctx.lr = 0x821B5248;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B5248: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B524C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B5250: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B5254: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B5258: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B5260 size=236
    let mut pc: u32 = 0x821B5260;
    'dispatch: loop {
        match pc {
            0x821B5260 => {
    //   block [0x821B5260..0x821B52B8)
	// 821B5260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B5268: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B526C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B5270: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5274: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B5278: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B527C: 48298F4D  bl 0x8244e1c8
	ctx.lr = 0x821B5280;
	sub_8244E1C8(ctx, base);
	// 821B5280: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B5284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5288: 419A00A8  beq cr6, 0x821b5330
	if ctx.cr[6].eq {
	pc = 0x821B5330; continue 'dispatch;
	}
	// 821B528C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B5290: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B5294: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5298: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B529C: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821B52A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B52A4: 419A0014  beq cr6, 0x821b52b8
	if ctx.cr[6].eq {
	pc = 0x821B52B8; continue 'dispatch;
	}
	// 821B52A8: 896B0035  lbz r11, 0x35(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 821B52AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B52B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B52B4: 409A0008  bne cr6, 0x821b52bc
	if !ctx.cr[6].eq {
	pc = 0x821B52BC; continue 'dispatch;
	}
	pc = 0x821B52B8; continue 'dispatch;
            }
            0x821B52B8 => {
    //   block [0x821B52B8..0x821B52BC)
	// 821B52B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B52BC; continue 'dispatch;
            }
            0x821B52BC => {
    //   block [0x821B52BC..0x821B52D8)
	// 821B52BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B52C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B52C4: 419A006C  beq cr6, 0x821b5330
	if ctx.cr[6].eq {
	pc = 0x821B5330; continue 'dispatch;
	}
	// 821B52C8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B52CC: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B52D0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B52D4: 419A0020  beq cr6, 0x821b52f4
	if ctx.cr[6].eq {
	pc = 0x821B52F4; continue 'dispatch;
	}
	pc = 0x821B52D8; continue 'dispatch;
            }
            0x821B52D8 => {
    //   block [0x821B52D8..0x821B52F4)
	// 821B52D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B52DC: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B52E0: 7F08F800  cmpw cr6, r8, r31
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[31].s32, &mut ctx.xer);
	// 821B52E4: 419A0044  beq cr6, 0x821b5328
	if ctx.cr[6].eq {
	pc = 0x821B5328; continue 'dispatch;
	}
	// 821B52E8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821B52EC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B52F0: 409AFFE8  bne cr6, 0x821b52d8
	if !ctx.cr[6].eq {
	pc = 0x821B52D8; continue 'dispatch;
	}
	pc = 0x821B52F4; continue 'dispatch;
            }
            0x821B52F4 => {
    //   block [0x821B52F4..0x821B52F8)
	// 821B52F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B52F8; continue 'dispatch;
            }
            0x821B52F8 => {
    //   block [0x821B52F8..0x821B5328)
	// 821B52F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B52FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5300: 409A0030  bne cr6, 0x821b5330
	if !ctx.cr[6].eq {
	pc = 0x821B5330; continue 'dispatch;
	}
	// 821B5304: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B5308: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B530C: 480F4145  bl 0x822a9450
	ctx.lr = 0x821B5310;
	sub_822A9450(ctx, base);
	// 821B5310: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B5314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5318: 409A0018  bne cr6, 0x821b5330
	if !ctx.cr[6].eq {
	pc = 0x821B5330; continue 'dispatch;
	}
	// 821B531C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B5320: 4BFE5B71  bl 0x8219ae90
	ctx.lr = 0x821B5324;
	sub_8219AE90(ctx, base);
	// 821B5324: 48000010  b 0x821b5334
	pc = 0x821B5334; continue 'dispatch;
            }
            0x821B5328 => {
    //   block [0x821B5328..0x821B5330)
	// 821B5328: 896A002C  lbz r11, 0x2c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B532C: 4BFFFFCC  b 0x821b52f8
	pc = 0x821B52F8; continue 'dispatch;
            }
            0x821B5330 => {
    //   block [0x821B5330..0x821B5334)
	// 821B5330: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821B5334; continue 'dispatch;
            }
            0x821B5334 => {
    //   block [0x821B5334..0x821B534C)
	// 821B5334: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B5338: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B533C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B5340: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B5344: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B5348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B5350 size=320
    let mut pc: u32 = 0x821B5350;
    'dispatch: loop {
        match pc {
            0x821B5350 => {
    //   block [0x821B5350..0x821B5394)
	// 821B5350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5354: 48AF40A9  bl 0x82ca93fc
	ctx.lr = 0x821B5358;
	sub_82CA93D0(ctx, base);
	// 821B5358: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B535C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B5360: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B5364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5368: 409A0120  bne cr6, 0x821b5488
	if !ctx.cr[6].eq {
	pc = 0x821B5488; continue 'dispatch;
	}
	// 821B536C: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821B5370: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 821B5374: 3B6B6EC8  addi r27, r11, 0x6ec8
	ctx.r[27].s64 = ctx.r[11].s64 + 28360;
	// 821B5378: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B537C: 9B3F0039  stb r25, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[25].u8 ) };
	// 821B5380: 3BDF003C  addi r30, r31, 0x3c
	ctx.r[30].s64 = ctx.r[31].s64 + 60;
	// 821B5384: 9B3F003A  stb r25, 0x3a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(58 as u32), ctx.r[25].u8 ) };
	// 821B5388: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 821B538C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821B5390: 3B4B7088  addi r26, r11, 0x7088
	ctx.r[26].s64 = ctx.r[11].s64 + 28808;
	pc = 0x821B5394; continue 'dispatch;
            }
            0x821B5394 => {
    //   block [0x821B5394..0x821B53C0)
	// 821B5394: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821B5398: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B539C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B53A0: 48077B31  bl 0x8222ced0
	ctx.lr = 0x821B53A4;
	sub_8222CED0(ctx, base);
	// 821B53A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B53A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B53AC: 4800015D  bl 0x821b5508
	ctx.lr = 0x821B53B0;
	sub_821B5508(ctx, base);
	// 821B53B0: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821B53B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B53B8: 480113B1  bl 0x821c6768
	ctx.lr = 0x821B53BC;
	sub_821C6768(ctx, base);
	// 821B53BC: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x821B53C0; continue 'dispatch;
            }
            0x821B53C0 => {
    //   block [0x821B53C0..0x821B53F0)
	// 821B53C0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B53C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B53C8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B53CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B53D0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B53D4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B53D8: 4082FFE8  bne 0x821b53c0
	if !ctx.cr[0].eq {
	pc = 0x821B53C0; continue 'dispatch;
	}
	// 821B53DC: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B53E0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821B53E4: 2F08FFFF  cmpwi cr6, r8, -1
	ctx.cr[6].compare_i32(ctx.r[8].s32, -1, &mut ctx.xer);
	// 821B53E8: 409A0008  bne cr6, 0x821b53f0
	if !ctx.cr[6].eq {
	pc = 0x821B53F0; continue 'dispatch;
	}
	// 821B53EC: 9B9F0039  stb r28, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[28].u8 ) };
	pc = 0x821B53F0; continue 'dispatch;
            }
            0x821B53F0 => {
    //   block [0x821B53F0..0x821B5414)
	// 821B53F0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821B53F4: 397B0014  addi r11, r27, 0x14
	ctx.r[11].s64 = ctx.r[27].s64 + 20;
	// 821B53F8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B53FC: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B5400: 4198FF94  blt cr6, 0x821b5394
	if ctx.cr[6].lt {
	pc = 0x821B5394; continue 'dispatch;
	}
	// 821B5404: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821B5408: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 821B540C: 3B6B6EDC  addi r27, r11, 0x6edc
	ctx.r[27].s64 = ctx.r[11].s64 + 28380;
	// 821B5410: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	pc = 0x821B5414; continue 'dispatch;
            }
            0x821B5414 => {
    //   block [0x821B5414..0x821B5440)
	// 821B5414: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821B5418: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B541C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B5420: 48077AB1  bl 0x8222ced0
	ctx.lr = 0x821B5424;
	sub_8222CED0(ctx, base);
	// 821B5424: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B5428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B542C: 480000DD  bl 0x821b5508
	ctx.lr = 0x821B5430;
	sub_821B5508(ctx, base);
	// 821B5430: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821B5434: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B5438: 48011331  bl 0x821c6768
	ctx.lr = 0x821B543C;
	sub_821C6768(ctx, base);
	// 821B543C: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x821B5440; continue 'dispatch;
            }
            0x821B5440 => {
    //   block [0x821B5440..0x821B5470)
	// 821B5440: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B5444: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B5448: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B544C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B5450: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B5454: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B5458: 4082FFE8  bne 0x821b5440
	if !ctx.cr[0].eq {
	pc = 0x821B5440; continue 'dispatch;
	}
	// 821B545C: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5460: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821B5464: 2F08FFFF  cmpwi cr6, r8, -1
	ctx.cr[6].compare_i32(ctx.r[8].s32, -1, &mut ctx.xer);
	// 821B5468: 409A0008  bne cr6, 0x821b5470
	if !ctx.cr[6].eq {
	pc = 0x821B5470; continue 'dispatch;
	}
	// 821B546C: 9B9F003A  stb r28, 0x3a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(58 as u32), ctx.r[28].u8 ) };
	pc = 0x821B5470; continue 'dispatch;
            }
            0x821B5470 => {
    //   block [0x821B5470..0x821B5488)
	// 821B5470: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821B5474: 397B0018  addi r11, r27, 0x18
	ctx.r[11].s64 = ctx.r[27].s64 + 24;
	// 821B5478: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B547C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B5480: 4198FF94  blt cr6, 0x821b5414
	if ctx.cr[6].lt {
	pc = 0x821B5414; continue 'dispatch;
	}
	// 821B5484: 9B3F0038  stb r25, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[25].u8 ) };
	pc = 0x821B5488; continue 'dispatch;
            }
            0x821B5488 => {
    //   block [0x821B5488..0x821B5490)
	// 821B5488: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B548C: 48AF3FC0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B5490 size=120
    let mut pc: u32 = 0x821B5490;
    'dispatch: loop {
        match pc {
            0x821B5490 => {
    //   block [0x821B5490..0x821B5508)
	// 821B5490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B5498: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B549C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B54A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B54A4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B54A8: C0230028  lfs f1, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B54AC: 4811E19D  bl 0x822d3648
	ctx.lr = 0x821B54B0;
	sub_822D3648(ctx, base);
	// 821B54B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B54B4: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 821B54B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821B54BC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B54C0: C02B9484  lfs f1, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B54C4: 4803F8D5  bl 0x821f4d98
	ctx.lr = 0x821B54C8;
	sub_821F4D98(ctx, base);
	// 821B54C8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B54CC: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 821B54D0: 390A90F0  addi r8, r10, -0x6f10
	ctx.r[8].s64 = ctx.r[10].s64 + -28432;
	// 821B54D4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B5508 size=152
    let mut pc: u32 = 0x821B5508;
    'dispatch: loop {
        match pc {
            0x821B5508 => {
    //   block [0x821B5508..0x821B5538)
	// 821B5508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B550C: 48AF3EFD  bl 0x82ca9408
	ctx.lr = 0x821B5510;
	sub_82CA93D0(ctx, base);
	// 821B5510: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5514: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B5518: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B551C: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B5520: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821B5524: 7D3C1E71  srawi. r28, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821B5528: 41820060  beq 0x821b5588
	if ctx.cr[0].eq {
	pc = 0x821B5588; continue 'dispatch;
	}
	// 821B552C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B5530: 83C40000  lwz r30, 0(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5534: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	pc = 0x821B5538; continue 'dispatch;
            }
            0x821B5538 => {
    //   block [0x821B5538..0x821B554C)
	// 821B5538: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B553C: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B5540: 409A000C  bne cr6, 0x821b554c
	if !ctx.cr[6].eq {
	pc = 0x821B554C; continue 'dispatch;
	}
	// 821B5544: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B5548: 48000024  b 0x821b556c
	pc = 0x821B556C; continue 'dispatch;
            }
            0x821B554C => {
    //   block [0x821B554C..0x821B5568)
	// 821B554C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B5550: 419A0018  beq cr6, 0x821b5568
	if ctx.cr[6].eq {
	pc = 0x821B5568; continue 'dispatch;
	}
	// 821B5554: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B5558: 419A0010  beq cr6, 0x821b5568
	if ctx.cr[6].eq {
	pc = 0x821B5568; continue 'dispatch;
	}
	// 821B555C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B5560: 480B8231  bl 0x8226d790
	ctx.lr = 0x821B5564;
	sub_8226D790(ctx, base);
	// 821B5564: 48000008  b 0x821b556c
	pc = 0x821B556C; continue 'dispatch;
            }
            0x821B5568 => {
    //   block [0x821B5568..0x821B556C)
	// 821B5568: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821B556C; continue 'dispatch;
            }
            0x821B556C => {
    //   block [0x821B556C..0x821B5588)
	// 821B556C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B5570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5574: 409A0020  bne cr6, 0x821b5594
	if !ctx.cr[6].eq {
	pc = 0x821B5594; continue 'dispatch;
	}
	// 821B5578: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821B557C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821B5580: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B5584: 409AFFB4  bne cr6, 0x821b5538
	if !ctx.cr[6].eq {
	pc = 0x821B5538; continue 'dispatch;
	}
	pc = 0x821B5588; continue 'dispatch;
            }
            0x821B5588 => {
    //   block [0x821B5588..0x821B5594)
	// 821B5588: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 821B558C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B5590: 48AF3EC8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B5594 => {
    //   block [0x821B5594..0x821B55A0)
	// 821B5594: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B5598: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B559C: 48AF3EBC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B55A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B55A0 size=140
    let mut pc: u32 = 0x821B55A0;
    'dispatch: loop {
        match pc {
            0x821B55A0 => {
    //   block [0x821B55A0..0x821B5610)
	// 821B55A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B55A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B55A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B55AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B55B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B55B4: 83C30024  lwz r30, 0x24(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B55B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B55BC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B55C0: 419A0050  beq cr6, 0x821b5610
	if ctx.cr[6].eq {
	pc = 0x821B5610; continue 'dispatch;
	}
	// 821B55C4: 38830014  addi r4, r3, 0x14
	ctx.r[4].s64 = ctx.r[3].s64 + 20;
	// 821B55C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B55CC: 4803956D  bl 0x821eeb38
	ctx.lr = 0x821B55D0;
	sub_821EEB38(ctx, base);
	// 821B55D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B55D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B55D8: 481FB4D1  bl 0x823b0aa8
	ctx.lr = 0x821B55DC;
	sub_823B0AA8(ctx, base);
	// 821B55DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B55E0: 4805F7F9  bl 0x82214dd8
	ctx.lr = 0x821B55E4;
	sub_82214DD8(ctx, base);
	// 821B55E4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B55E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B55EC: 388B00AC  addi r4, r11, 0xac
	ctx.r[4].s64 = ctx.r[11].s64 + 172;
	// 821B55F0: 48039549  bl 0x821eeb38
	ctx.lr = 0x821B55F4;
	sub_821EEB38(ctx, base);
	// 821B55F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B55F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B55FC: 481FB4AD  bl 0x823b0aa8
	ctx.lr = 0x821B5600;
	sub_823B0AA8(ctx, base);
	// 821B5600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B5604: 4805F7D5  bl 0x82214dd8
	ctx.lr = 0x821B5608;
	sub_82214DD8(ctx, base);
	// 821B5608: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 821B560C: 48000008  b 0x821b5614
	pc = 0x821B5614; continue 'dispatch;
            }
            0x821B5610 => {
    //   block [0x821B5610..0x821B5614)
	// 821B5610: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821B5614; continue 'dispatch;
            }
            0x821B5614 => {
    //   block [0x821B5614..0x821B562C)
	// 821B5614: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B5618: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B561C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B5620: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B5624: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B5628: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B5638 size=2812
    let mut pc: u32 = 0x821B5638;
    'dispatch: loop {
        match pc {
            0x821B5638 => {
    //   block [0x821B5638..0x821B6134)
	// 821B5638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B563C: 48AF3D95  bl 0x82ca93d0
	ctx.lr = 0x821B5640;
	sub_82CA93D0(ctx, base);
	// 821B5640: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821B5644: 48AF868D  bl 0x82cadcd0
	ctx.lr = 0x821B5648;
	sub_82CADCA0(ctx, base);
	// 821B5648: 3980FF20  li r12, -0xe0
	ctx.r[12].s64 = -224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6138 size=796
    let mut pc: u32 = 0x821B6138;
    'dispatch: loop {
        match pc {
            0x821B6138 => {
    //   block [0x821B6138..0x821B6174)
	// 821B6138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B613C: 48AF32C9  bl 0x82ca9404
	ctx.lr = 0x821B6140;
	sub_82CA93D0(ctx, base);
	// 821B6140: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6144: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B6148: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B614C: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 821B6150: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821B6154: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B6158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B615C: 419A0020  beq cr6, 0x821b617c
	if ctx.cr[6].eq {
	pc = 0x821B617C; continue 'dispatch;
	}
	// 821B6160: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6164: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B6168: 419A000C  beq cr6, 0x821b6174
	if ctx.cr[6].eq {
	pc = 0x821B6174; continue 'dispatch;
	}
	// 821B616C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B6170: 48000010  b 0x821b6180
	pc = 0x821B6180; continue 'dispatch;
            }
            0x821B6174 => {
    //   block [0x821B6174..0x821B617C)
	// 821B6174: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B6178: 4BFDDCC1  bl 0x82193e38
	ctx.lr = 0x821B617C;
	sub_82193E38(ctx, base);
	pc = 0x821B617C; continue 'dispatch;
            }
            0x821B617C => {
    //   block [0x821B617C..0x821B6180)
	// 821B617C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821B6180; continue 'dispatch;
            }
            0x821B6180 => {
    //   block [0x821B6180..0x821B61C0)
	// 821B6180: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B6184: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821B6188: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 821B618C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B6190: 419A00F4  beq cr6, 0x821b6284
	if ctx.cr[6].eq {
	pc = 0x821B6284; continue 'dispatch;
	}
	// 821B6194: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B6198: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B619C: 419A0024  beq cr6, 0x821b61c0
	if ctx.cr[6].eq {
	pc = 0x821B61C0; continue 'dispatch;
	}
	// 821B61A0: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 821B61A4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B61A8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B61AC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B61B0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B61B4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B61B8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B61BC: 480000CC  b 0x821b6288
	pc = 0x821B6288; continue 'dispatch;
            }
            0x821B61C0 => {
    //   block [0x821B61C0..0x821B61DC)
	// 821B61C0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B61C4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B61C8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821B61CC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B61D0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B61D4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B61D8: 40810054  ble 0x821b622c
	if !ctx.cr[0].gt {
	pc = 0x821B622C; continue 'dispatch;
	}
	pc = 0x821B61DC; continue 'dispatch;
            }
            0x821B61DC => {
    //   block [0x821B61DC..0x821B61FC)
	// 821B61DC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B61E0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B61E4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B61E8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B61EC: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 821B61F0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821B61F4: 41980008  blt cr6, 0x821b61fc
	if ctx.cr[6].lt {
	pc = 0x821B61FC; continue 'dispatch;
	}
	// 821B61F8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x821B61FC; continue 'dispatch;
            }
            0x821B61FC => {
    //   block [0x821B61FC..0x821B6218)
	// 821B61FC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B6200: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B6204: 419A0014  beq cr6, 0x821b6218
	if ctx.cr[6].eq {
	pc = 0x821B6218; continue 'dispatch;
	}
	// 821B6208: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B620C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B6210: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B6214: 4800000C  b 0x821b6220
	pc = 0x821B6220; continue 'dispatch;
            }
            0x821B6218 => {
    //   block [0x821B6218..0x821B6220)
	// 821B6218: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B621C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821B6220; continue 'dispatch;
            }
            0x821B6220 => {
    //   block [0x821B6220..0x821B622C)
	// 821B6220: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6224: 4199FFB8  bgt cr6, 0x821b61dc
	if ctx.cr[6].gt {
	pc = 0x821B61DC; continue 'dispatch;
	}
	// 821B6228: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821B622C; continue 'dispatch;
            }
            0x821B622C => {
    //   block [0x821B622C..0x821B6248)
	// 821B622C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B6230: 419A0040  beq cr6, 0x821b6270
	if ctx.cr[6].eq {
	pc = 0x821B6270; continue 'dispatch;
	}
	// 821B6234: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6238: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 821B623C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B6240: 41990008  bgt cr6, 0x821b6248
	if ctx.cr[6].gt {
	pc = 0x821B6248; continue 'dispatch;
	}
	// 821B6244: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821B6248; continue 'dispatch;
            }
            0x821B6248 => {
    //   block [0x821B6248..0x821B6270)
	// 821B6248: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B624C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6250: 409A0020  bne cr6, 0x821b6270
	if !ctx.cr[6].eq {
	pc = 0x821B6270; continue 'dispatch;
	}
	// 821B6254: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B6258: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B625C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B6260: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6264: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B6268: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B626C: 4800001C  b 0x821b6288
	pc = 0x821B6288; continue 'dispatch;
            }
            0x821B6270 => {
    //   block [0x821B6270..0x821B6284)
	// 821B6270: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B6274: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6278: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B627C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B6280: 48000008  b 0x821b6288
	pc = 0x821B6288; continue 'dispatch;
            }
            0x821B6284 => {
    //   block [0x821B6284..0x821B6288)
	// 821B6284: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821B6288; continue 'dispatch;
            }
            0x821B6288 => {
    //   block [0x821B6288..0x821B62C4)
	// 821B6288: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B628C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6290: 419A0034  beq cr6, 0x821b62c4
	if ctx.cr[6].eq {
	pc = 0x821B62C4; continue 'dispatch;
	}
	// 821B6294: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B6298: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821B629C: 388B0E58  addi r4, r11, 0xe58
	ctx.r[4].s64 = ctx.r[11].s64 + 3672;
	// 821B62A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B62A4: 48076C2D  bl 0x8222ced0
	ctx.lr = 0x821B62A8;
	sub_8222CED0(ctx, base);
	// 821B62A8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821B62AC: 38BC0028  addi r5, r28, 0x28
	ctx.r[5].s64 = ctx.r[28].s64 + 40;
	// 821B62B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B62B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B62B8: 48088171  bl 0x8223e428
	ctx.lr = 0x821B62BC;
	sub_8223E428(ctx, base);
	// 821B62BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B62C0: 4805EB19  bl 0x82214dd8
	ctx.lr = 0x821B62C4;
	sub_82214DD8(ctx, base);
	pc = 0x821B62C4; continue 'dispatch;
            }
            0x821B62C4 => {
    //   block [0x821B62C4..0x821B6314)
	// 821B62C4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B62C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B62CC: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B62D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B62D4: 4E800421  bctrl
	ctx.lr = 0x821B62D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B62D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B62DC: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821B62E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B62E4: 419A0030  beq cr6, 0x821b6314
	if ctx.cr[6].eq {
	pc = 0x821B6314; continue 'dispatch;
	}
	// 821B62E8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B62EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B62F0: 419A0078  beq cr6, 0x821b6368
	if ctx.cr[6].eq {
	pc = 0x821B6368; continue 'dispatch;
	}
	// 821B62F4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B62F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B62FC: 419A0018  beq cr6, 0x821b6314
	if ctx.cr[6].eq {
	pc = 0x821B6314; continue 'dispatch;
	}
	// 821B6300: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B6304: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B6308: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B630C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B6310: 409A0008  bne cr6, 0x821b6318
	if !ctx.cr[6].eq {
	pc = 0x821B6318; continue 'dispatch;
	}
            }
            0x821B6314 => {
    //   block [0x821B6314..0x821B6318)
	// 821B6314: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821B6318; continue 'dispatch;
            }
            0x821B6318 => {
    //   block [0x821B6318..0x821B6368)
	// 821B6318: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B631C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6320: 419A0128  beq cr6, 0x821b6448
	if ctx.cr[6].eq {
	pc = 0x821B6448; continue 'dispatch;
	}
	// 821B6324: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B6328: 4BFBE141  bl 0x82174468
	ctx.lr = 0x821B632C;
	sub_82174468(ctx, base);
	// 821B632C: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B6330: 556A97FE  rlwinm r10, r11, 0x12, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00003FFFu64;
	// 821B6334: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B6338: 419A00FC  beq cr6, 0x821b6434
	if ctx.cr[6].eq {
	pc = 0x821B6434; continue 'dispatch;
	}
	// 821B633C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B6340: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B6344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6348: 419A002C  beq cr6, 0x821b6374
	if ctx.cr[6].eq {
	pc = 0x821B6374; continue 'dispatch;
	}
	// 821B634C: 896B006E  lbz r11, 0x6e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(110 as u32) ) } as u64;
	// 821B6350: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821B6354: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B6358: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B635C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B6360: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B6364: 480000D4  b 0x821b6438
	pc = 0x821B6438; continue 'dispatch;
            }
            0x821B6368 => {
    //   block [0x821B6368..0x821B6374)
	// 821B6368: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B636C: 4BFDDACD  bl 0x82193e38
	ctx.lr = 0x821B6370;
	sub_82193E38(ctx, base);
	// 821B6370: 4BFFFFA4  b 0x821b6314
	pc = 0x821B6314; continue 'dispatch;
            }
            0x821B6374 => {
    //   block [0x821B6374..0x821B638C)
	// 821B6374: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B6378: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821B637C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B6380: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B6384: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6388: 40810054  ble 0x821b63dc
	if !ctx.cr[0].gt {
	pc = 0x821B63DC; continue 'dispatch;
	}
	pc = 0x821B638C; continue 'dispatch;
            }
            0x821B638C => {
    //   block [0x821B638C..0x821B63AC)
	// 821B638C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B6390: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B6394: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B6398: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B639C: 2F07006E  cmpwi cr6, r7, 0x6e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 110, &mut ctx.xer);
	// 821B63A0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821B63A4: 41980008  blt cr6, 0x821b63ac
	if ctx.cr[6].lt {
	pc = 0x821B63AC; continue 'dispatch;
	}
	// 821B63A8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x821B63AC; continue 'dispatch;
            }
            0x821B63AC => {
    //   block [0x821B63AC..0x821B63C8)
	// 821B63AC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B63B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B63B4: 419A0014  beq cr6, 0x821b63c8
	if ctx.cr[6].eq {
	pc = 0x821B63C8; continue 'dispatch;
	}
	// 821B63B8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B63BC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B63C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B63C4: 4800000C  b 0x821b63d0
	pc = 0x821B63D0; continue 'dispatch;
            }
            0x821B63C8 => {
    //   block [0x821B63C8..0x821B63D0)
	// 821B63C8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B63CC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821B63D0; continue 'dispatch;
            }
            0x821B63D0 => {
    //   block [0x821B63D0..0x821B63DC)
	// 821B63D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B63D4: 4199FFB8  bgt cr6, 0x821b638c
	if ctx.cr[6].gt {
	pc = 0x821B638C; continue 'dispatch;
	}
	// 821B63D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821B63DC; continue 'dispatch;
            }
            0x821B63DC => {
    //   block [0x821B63DC..0x821B63F8)
	// 821B63DC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B63E0: 419A0040  beq cr6, 0x821b6420
	if ctx.cr[6].eq {
	pc = 0x821B6420; continue 'dispatch;
	}
	// 821B63E4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B63E8: 2F0B006E  cmpwi cr6, r11, 0x6e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 110, &mut ctx.xer);
	// 821B63EC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B63F0: 41990008  bgt cr6, 0x821b63f8
	if ctx.cr[6].gt {
	pc = 0x821B63F8; continue 'dispatch;
	}
	// 821B63F4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821B63F8; continue 'dispatch;
            }
            0x821B63F8 => {
    //   block [0x821B63F8..0x821B6420)
	// 821B63F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B63FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6400: 409A0020  bne cr6, 0x821b6420
	if !ctx.cr[6].eq {
	pc = 0x821B6420; continue 'dispatch;
	}
	// 821B6404: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B6408: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B640C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B6410: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6414: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B6418: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B641C: 4800001C  b 0x821b6438
	pc = 0x821B6438; continue 'dispatch;
            }
            0x821B6420 => {
    //   block [0x821B6420..0x821B6434)
	// 821B6420: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B6424: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6428: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B642C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B6430: 48000008  b 0x821b6438
	pc = 0x821B6438; continue 'dispatch;
            }
            0x821B6434 => {
    //   block [0x821B6434..0x821B6438)
	// 821B6434: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821B6438; continue 'dispatch;
            }
            0x821B6438 => {
    //   block [0x821B6438..0x821B6448)
	// 821B6438: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B643C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6440: 419A0008  beq cr6, 0x821b6448
	if ctx.cr[6].eq {
	pc = 0x821B6448; continue 'dispatch;
	}
	// 821B6444: 9BBF00C0  stb r29, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[29].u8 ) };
	pc = 0x821B6448; continue 'dispatch;
            }
            0x821B6448 => {
    //   block [0x821B6448..0x821B6454)
	// 821B6448: 9B7C0048  stb r27, 0x48(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(72 as u32), ctx.r[27].u8 ) };
	// 821B644C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B6450: 48AF3004  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6458 size=444
    let mut pc: u32 = 0x821B6458;
    'dispatch: loop {
        match pc {
            0x821B6458 => {
    //   block [0x821B6458..0x821B6508)
	// 821B6458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B645C: 48AF2FAD  bl 0x82ca9408
	ctx.lr = 0x821B6460;
	sub_82CA93D0(ctx, base);
	// 821B6460: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6464: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B6468: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821B646C: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 821B6470: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821B6474: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B6478: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821B647C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B6480: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821B6484: 4805E415  bl 0x82214898
	ctx.lr = 0x821B6488;
	sub_82214898(ctx, base);
	// 821B6488: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 821B648C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B6490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B6494: 4831BA35  bl 0x824d1ec8
	ctx.lr = 0x821B6498;
	sub_824D1EC8(ctx, base);
	// 821B6498: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821B649C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B64A0: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 821B64A4: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821B64A8: 4BFDD991  bl 0x82193e38
	ctx.lr = 0x821B64AC;
	sub_82193E38(ctx, base);
	// 821B64AC: 80FD0038  lwz r7, 0x38(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B64B0: 939D003C  stw r28, 0x3c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), ctx.r[28].u32 ) };
	// 821B64B4: 54E6F7FE  rlwinm r6, r7, 0x1e, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 821B64B8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821B64BC: 419A0134  beq cr6, 0x821b65f0
	if ctx.cr[6].eq {
	pc = 0x821B65F0; continue 'dispatch;
	}
	// 821B64C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B64C4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821B64C8: 4BFBD971  bl 0x82173e38
	ctx.lr = 0x821B64CC;
	sub_82173E38(ctx, base);
	// 821B64CC: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B64D0: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 821B64D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B64D8: 419A00F4  beq cr6, 0x821b65cc
	if ctx.cr[6].eq {
	pc = 0x821B65CC; continue 'dispatch;
	}
	// 821B64DC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B64E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B64E4: 419A0024  beq cr6, 0x821b6508
	if ctx.cr[6].eq {
	pc = 0x821B6508; continue 'dispatch;
	}
	// 821B64E8: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 821B64EC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B64F0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B64F4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B64F8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B64FC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B6500: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B6504: 480000CC  b 0x821b65d0
	pc = 0x821B65D0; continue 'dispatch;
            }
            0x821B6508 => {
    //   block [0x821B6508..0x821B6524)
	// 821B6508: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B650C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B6510: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821B6514: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B6518: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B651C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6520: 40810054  ble 0x821b6574
	if !ctx.cr[0].gt {
	pc = 0x821B6574; continue 'dispatch;
	}
	pc = 0x821B6524; continue 'dispatch;
            }
            0x821B6524 => {
    //   block [0x821B6524..0x821B6544)
	// 821B6524: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B6528: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B652C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B6530: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6534: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 821B6538: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B653C: 41980008  blt cr6, 0x821b6544
	if ctx.cr[6].lt {
	pc = 0x821B6544; continue 'dispatch;
	}
	// 821B6540: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x821B6544; continue 'dispatch;
            }
            0x821B6544 => {
    //   block [0x821B6544..0x821B6560)
	// 821B6544: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B6548: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B654C: 419A0014  beq cr6, 0x821b6560
	if ctx.cr[6].eq {
	pc = 0x821B6560; continue 'dispatch;
	}
	// 821B6550: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B6554: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B6558: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B655C: 4800000C  b 0x821b6568
	pc = 0x821B6568; continue 'dispatch;
            }
            0x821B6560 => {
    //   block [0x821B6560..0x821B6568)
	// 821B6560: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B6564: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821B6568; continue 'dispatch;
            }
            0x821B6568 => {
    //   block [0x821B6568..0x821B6574)
	// 821B6568: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B656C: 4199FFB8  bgt cr6, 0x821b6524
	if ctx.cr[6].gt {
	pc = 0x821B6524; continue 'dispatch;
	}
	// 821B6570: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821B6574; continue 'dispatch;
            }
            0x821B6574 => {
    //   block [0x821B6574..0x821B6590)
	// 821B6574: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B6578: 419A0040  beq cr6, 0x821b65b8
	if ctx.cr[6].eq {
	pc = 0x821B65B8; continue 'dispatch;
	}
	// 821B657C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6580: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B6584: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B6588: 41990008  bgt cr6, 0x821b6590
	if ctx.cr[6].gt {
	pc = 0x821B6590; continue 'dispatch;
	}
	// 821B658C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821B6590; continue 'dispatch;
            }
            0x821B6590 => {
    //   block [0x821B6590..0x821B65B8)
	// 821B6590: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B6594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6598: 409A0020  bne cr6, 0x821b65b8
	if !ctx.cr[6].eq {
	pc = 0x821B65B8; continue 'dispatch;
	}
	// 821B659C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B65A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B65A4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B65A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B65AC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B65B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B65B4: 4800001C  b 0x821b65d0
	pc = 0x821B65D0; continue 'dispatch;
            }
            0x821B65B8 => {
    //   block [0x821B65B8..0x821B65CC)
	// 821B65B8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B65BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B65C0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B65C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B65C8: 48000008  b 0x821b65d0
	pc = 0x821B65D0; continue 'dispatch;
            }
            0x821B65CC => {
    //   block [0x821B65CC..0x821B65D0)
	// 821B65CC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821B65D0; continue 'dispatch;
            }
            0x821B65D0 => {
    //   block [0x821B65D0..0x821B65F0)
	// 821B65D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B65D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B65D8: 419A0018  beq cr6, 0x821b65f0
	if ctx.cr[6].eq {
	pc = 0x821B65F0; continue 'dispatch;
	}
	// 821B65DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B65E0: 483BF139  bl 0x82575718
	ctx.lr = 0x821B65E4;
	sub_82575718(ctx, base);
	// 821B65E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B65E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B65EC: 483BBFBD  bl 0x825725a8
	ctx.lr = 0x821B65F0;
	sub_825725A8(ctx, base);
	pc = 0x821B65F0; continue 'dispatch;
            }
            0x821B65F0 => {
    //   block [0x821B65F0..0x821B660C)
	// 821B65F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B65F4: 4855381D  bl 0x82709e10
	ctx.lr = 0x821B65F8;
	sub_82709E10(ctx, base);
	// 821B65F8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B65FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6600: 419A000C  beq cr6, 0x821b660c
	if ctx.cr[6].eq {
	pc = 0x821B660C; continue 'dispatch;
	}
	// 821B6604: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B6608: 4BFFFB31  bl 0x821b6138
	ctx.lr = 0x821B660C;
	sub_821B6138(ctx, base);
	pc = 0x821B660C; continue 'dispatch;
            }
            0x821B660C => {
    //   block [0x821B660C..0x821B6614)
	// 821B660C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B6610: 48AF2E48  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6618 size=68
    let mut pc: u32 = 0x821B6618;
    'dispatch: loop {
        match pc {
            0x821B6618 => {
    //   block [0x821B6618..0x821B665C)
	// 821B6618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B661C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B6620: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6624: 39630050  addi r11, r3, 0x50
	ctx.r[11].s64 = ctx.r[3].s64 + 80;
	// 821B6628: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821B662C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6660 size=204
    let mut pc: u32 = 0x821B6660;
    'dispatch: loop {
        match pc {
            0x821B6660 => {
    //   block [0x821B6660..0x821B6688)
	// 821B6660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B6668: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B666C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6670: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 821B6674: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 821B6678: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B667C: 409A000C  bne cr6, 0x821b6688
	if !ctx.cr[6].eq {
	pc = 0x821B6688; continue 'dispatch;
	}
	// 821B6680: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821B6684: 48000010  b 0x821b6694
	pc = 0x821B6694; continue 'dispatch;
            }
            0x821B6688 => {
    //   block [0x821B6688..0x821B6694)
	// 821B6688: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B668C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821B6690: 7D2943D6  divw r9, r9, r8
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	pc = 0x821B6694; continue 'dispatch;
            }
            0x821B6694 => {
    //   block [0x821B6694..0x821B66D0)
	// 821B6694: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B6698: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821B669C: 7D0A43D6  divw r8, r10, r8
	ctx.r[8].s32 = ctx.r[10].s32 / ctx.r[8].s32;
	// 821B66A0: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B66A4: 40980060  bge cr6, 0x821b6704
	if !ctx.cr[6].lt {
	pc = 0x821B6704; continue 'dispatch;
	}
	// 821B66A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B66AC: 419A0040  beq cr6, 0x821b66ec
	if ctx.cr[6].eq {
	pc = 0x821B66EC; continue 'dispatch;
	}
	// 821B66B0: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B66B4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B66B8: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B66BC: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B66C0: 81460008  lwz r10, 8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B66C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B66C8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821B66CC: 419A0020  beq cr6, 0x821b66ec
	if ctx.cr[6].eq {
	pc = 0x821B66EC; continue 'dispatch;
	}
	pc = 0x821B66D0; continue 'dispatch;
            }
            0x821B66D0 => {
    //   block [0x821B66D0..0x821B66EC)
	// 821B66D0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 821B66D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B66D8: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 821B66DC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821B66E0: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B66E4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B66E8: 4082FFE8  bne 0x821b66d0
	if !ctx.cr[0].eq {
	pc = 0x821B66D0; continue 'dispatch;
	}
	pc = 0x821B66EC; continue 'dispatch;
            }
            0x821B66EC => {
    //   block [0x821B66EC..0x821B6704)
	// 821B66EC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821B66F0: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821B66F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B66F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B66FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6700: 4E800020  blr
	return;
            }
            0x821B6704 => {
    //   block [0x821B6704..0x821B672C)
	// 821B6704: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B6708: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821B670C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821B6710: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821B6714: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B6718: 48014A89  bl 0x821cb1a0
	ctx.lr = 0x821B671C;
	sub_821CB1A0(ctx, base);
	// 821B671C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B6720: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B6724: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6728: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B6730 size=400
    let mut pc: u32 = 0x821B6730;
    'dispatch: loop {
        match pc {
            0x821B6730 => {
    //   block [0x821B6730..0x821B678C)
	// 821B6730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6734: 48AF2CC5  bl 0x82ca93f8
	ctx.lr = 0x821B6738;
	sub_82CA93D0(ctx, base);
	// 821B6738: DBA1FFA0  stfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[29].u64 ) };
	// 821B673C: DBC1FFA8  stfd f30, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 821B6740: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 821B6744: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6748: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B674C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821B6750: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821B6754: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 821B6758: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 821B675C: C1BF0054  lfs f13, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B6760: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B6764: C01F41A0  lfs f0, 0x41a0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16800 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B6768: C19F419C  lfs f12, 0x419c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16796 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B676C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B6770: C17F0050  lfs f11, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B6774: EDAC02F2  fmuls f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 821B6778: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B677C: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821B6780: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B6784: 41980008  blt cr6, 0x821b678c
	if ctx.cr[6].lt {
	pc = 0x821B678C; continue 'dispatch;
	}
	// 821B6788: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	pc = 0x821B678C; continue 'dispatch;
            }
            0x821B678C => {
    //   block [0x821B678C..0x821B67E0)
	// 821B678C: C3CB0000  lfs f30, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B6790: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B6794: D3DF00D0  stfs f30, 0xd0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 821B6798: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821B679C: 3BCB9484  addi r30, r11, -0x6b7c
	ctx.r[30].s64 = ctx.r[11].s64 + -27516;
	// 821B67A0: C01F41A8  lfs f0, 0x41a8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B67A4: 388A15FC  addi r4, r10, 0x15fc
	ctx.r[4].s64 = ctx.r[10].s64 + 5628;
	// 821B67A8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821B67AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B67B0: C3FE000C  lfs f31, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B67B4: EFBF0024  fdivs f29, f31, f0
	ctx.f[29].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 821B67B8: 48076719  bl 0x8222ced0
	ctx.lr = 0x821B67BC;
	sub_8222CED0(ctx, base);
	// 821B67BC: 481FA27D  bl 0x823b0a38
	ctx.lr = 0x821B67C0;
	sub_823B0A38(ctx, base);
	// 821B67C0: 815F00F4  lwz r10, 0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 821B67C4: 80FF00F8  lwz r7, 0xf8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 821B67C8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B67CC: 7D2A3850  subf r9, r10, r7
	ctx.r[9].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 821B67D0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821B67D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B67D8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B67DC: 40810040  ble 0x821b681c
	if !ctx.cr[0].gt {
	pc = 0x821B681C; continue 'dispatch;
	}
	pc = 0x821B67E0; continue 'dispatch;
            }
            0x821B67E0 => {
    //   block [0x821B67E0..0x821B6808)
	// 821B67E0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B67E4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B67E8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B67EC: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B67F0: 7F061840  cmplw cr6, r6, r3
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821B67F4: 40980014  bge cr6, 0x821b6808
	if !ctx.cr[6].lt {
	pc = 0x821B6808; continue 'dispatch;
	}
	// 821B67F8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B67FC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B6800: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B6804: 4800000C  b 0x821b6810
	pc = 0x821B6810; continue 'dispatch;
            }
            0x821B6808 => {
    //   block [0x821B6808..0x821B6810)
	// 821B6808: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B680C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821B6810; continue 'dispatch;
            }
            0x821B6810 => {
    //   block [0x821B6810..0x821B681C)
	// 821B6810: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6814: 4199FFCC  bgt cr6, 0x821b67e0
	if ctx.cr[6].gt {
	pc = 0x821B67E0; continue 'dispatch;
	}
	// 821B6818: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821B681C; continue 'dispatch;
            }
            0x821B681C => {
    //   block [0x821B681C..0x821B6840)
	// 821B681C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821B6820: 419A0020  beq cr6, 0x821b6840
	if ctx.cr[6].eq {
	pc = 0x821B6840; continue 'dispatch;
	}
	// 821B6824: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6828: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B682C: 41980014  blt cr6, 0x821b6840
	if ctx.cr[6].lt {
	pc = 0x821B6840; continue 'dispatch;
	}
	// 821B6830: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B6834: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B6838: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B683C: 48000008  b 0x821b6844
	pc = 0x821B6844; continue 'dispatch;
            }
            0x821B6840 => {
    //   block [0x821B6840..0x821B6844)
	// 821B6840: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	pc = 0x821B6844; continue 'dispatch;
            }
            0x821B6844 => {
    //   block [0x821B6844..0x821B68C0)
	// 821B6844: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B6848: 830B0004  lwz r24, 4(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B684C: 4805E58D  bl 0x82214dd8
	ctx.lr = 0x821B6850;
	sub_82214DD8(ctx, base);
	// 821B6850: D3C10050  stfs f30, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B6854: D3A10054  stfs f29, 0x54(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821B6858: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B685C: F9780014  std r11, 0x14(r24)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[24].u32.wrapping_add(20 as u32), ctx.r[11].u64 ) };
	// 821B6860: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B6864: 9378000C  stw r27, 0xc(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 821B6868: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821B686C: 93580010  stw r26, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 821B6870: C1BF004C  lfs f13, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B6874: D1B8001C  stfs f13, 0x1c(r24)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B6878: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B687C: C19F006C  lfs f12, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B6880: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821B6884: D1980020  stfs f12, 0x20(r24)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B6888: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B688C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821B6890: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821B6894: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821B6898: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821B689C: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821B68A0: 4808B869  bl 0x82242108
	ctx.lr = 0x821B68A4;
	sub_82242108(ctx, base);
	// 821B68A4: 93B8000C  stw r29, 0xc(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 821B68A8: 93B80010  stw r29, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 821B68AC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821B68B0: CBA1FFA0  lfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 821B68B4: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821B68B8: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821B68BC: 48AF2B8C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B68C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B68C0 size=200
    let mut pc: u32 = 0x821B68C0;
    'dispatch: loop {
        match pc {
            0x821B68C0 => {
    //   block [0x821B68C0..0x821B68FC)
	// 821B68C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B68C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B68C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B68CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B68D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B68D4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821B68D8: 481FA161  bl 0x823b0a38
	ctx.lr = 0x821B68DC;
	sub_823B0A38(ctx, base);
	// 821B68DC: 813F00F4  lwz r9, 0xf4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 821B68E0: 80FF00F8  lwz r7, 0xf8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 821B68E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B68E8: 7D493850  subf r10, r9, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 821B68EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B68F0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821B68F4: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B68F8: 40810040  ble 0x821b6938
	if !ctx.cr[0].gt {
	pc = 0x821B6938; continue 'dispatch;
	}
	pc = 0x821B68FC; continue 'dispatch;
            }
            0x821B68FC => {
    //   block [0x821B68FC..0x821B6924)
	// 821B68FC: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B6900: 55481838  slwi r8, r10, 3
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B6904: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821B6908: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B690C: 7F061840  cmplw cr6, r6, r3
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821B6910: 40980014  bge cr6, 0x821b6924
	if !ctx.cr[6].lt {
	pc = 0x821B6924; continue 'dispatch;
	}
	// 821B6914: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821B6918: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821B691C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B6920: 4800000C  b 0x821b692c
	pc = 0x821B692C; continue 'dispatch;
            }
            0x821B6924 => {
    //   block [0x821B6924..0x821B692C)
	// 821B6924: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821B6928: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x821B692C; continue 'dispatch;
            }
            0x821B692C => {
    //   block [0x821B692C..0x821B6938)
	// 821B692C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6930: 4199FFCC  bgt cr6, 0x821b68fc
	if ctx.cr[6].gt {
	pc = 0x821B68FC; continue 'dispatch;
	}
	// 821B6934: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x821B6938; continue 'dispatch;
            }
            0x821B6938 => {
    //   block [0x821B6938..0x821B6970)
	// 821B6938: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821B693C: 419A0034  beq cr6, 0x821b6970
	if ctx.cr[6].eq {
	pc = 0x821B6970; continue 'dispatch;
	}
	// 821B6940: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6944: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B6948: 41980028  blt cr6, 0x821b6970
	if ctx.cr[6].lt {
	pc = 0x821B6970; continue 'dispatch;
	}
	// 821B694C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B6950: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B6954: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B6958: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B695C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B6960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B6964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6968: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B696C: 4E800020  blr
	return;
            }
            0x821B6970 => {
    //   block [0x821B6970..0x821B6988)
	// 821B6970: 80670004  lwz r3, 4(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6974: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B6978: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B697C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6980: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B6984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B6988 size=276
    let mut pc: u32 = 0x821B6988;
    'dispatch: loop {
        match pc {
            0x821B6988 => {
    //   block [0x821B6988..0x821B6A9C)
	// 821B6988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B698C: 48AF2A75  bl 0x82ca9400
	ctx.lr = 0x821B6990;
	sub_82CA93D0(ctx, base);
	// 821B6990: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 821B6994: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821B6998: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B699C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B69A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B69A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B69A8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821B69AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821B69B0: 388B1094  addi r4, r11, 0x1094
	ctx.r[4].s64 = ctx.r[11].s64 + 4244;
	// 821B69B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B69B8: 48076519  bl 0x8222ced0
	ctx.lr = 0x821B69BC;
	sub_8222CED0(ctx, base);
	// 821B69BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B69C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B69C4: 4BFFFEFD  bl 0x821b68c0
	ctx.lr = 0x821B69C8;
	sub_821B68C0(ctx, base);
	// 821B69C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B69CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B69D0: 4805E409  bl 0x82214dd8
	ctx.lr = 0x821B69D4;
	sub_82214DD8(ctx, base);
	// 821B69D4: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821B69D8: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 821B69DC: 38E89490  addi r7, r8, -0x6b70
	ctx.r[7].s64 = ctx.r[8].s64 + -27504;
	// 821B69E0: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 821B69E4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B69E8: 3B610054  addi r27, r1, 0x54
	ctx.r[27].s64 = ctx.r[1].s64 + 84;
	// 821B69EC: C3C89490  lfs f30, -0x6b70(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6AA0 size=104
    let mut pc: u32 = 0x821B6AA0;
    'dispatch: loop {
        match pc {
            0x821B6AA0 => {
    //   block [0x821B6AA0..0x821B6B08)
	// 821B6AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B6AA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B6AAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B6AB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6AB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B6AB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B6ABC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821B6AC0: 392B0B5C  addi r9, r11, 0xb5c
	ctx.r[9].s64 = ctx.r[11].s64 + 2908;
	// 821B6AC4: 390A0B7C  addi r8, r10, 0xb7c
	ctx.r[8].s64 = ctx.r[10].s64 + 2940;
	// 821B6AC8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821B6ACC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B6AD0: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 821B6AD4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 821B6AD8: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 821B6ADC: 4805DDBD  bl 0x82214898
	ctx.lr = 0x821B6AE0;
	sub_82214898(ctx, base);
	// 821B6AE0: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 821B6AE4: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 821B6AE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B6AEC: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 821B6AF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B6AF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B6AF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6AFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B6B00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B6B04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6B08 size=104
    let mut pc: u32 = 0x821B6B08;
    'dispatch: loop {
        match pc {
            0x821B6B08 => {
    //   block [0x821B6B08..0x821B6B3C)
	// 821B6B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6B0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B6B10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B6B14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6B18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B6B1C: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 821B6B20: 48068739  bl 0x8221f258
	ctx.lr = 0x821B6B24;
	sub_8221F258(ctx, base);
	// 821B6B24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B6B28: 419A0014  beq cr6, 0x821b6b3c
	if ctx.cr[6].eq {
	pc = 0x821B6B3C; continue 'dispatch;
	}
	// 821B6B2C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6B30: 4BFFFF71  bl 0x821b6aa0
	ctx.lr = 0x821B6B34;
	sub_821B6AA0(ctx, base);
	// 821B6B34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B6B38: 48000008  b 0x821b6b40
	pc = 0x821B6B40; continue 'dispatch;
            }
            0x821B6B3C => {
    //   block [0x821B6B3C..0x821B6B40)
	// 821B6B3C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x821B6B40; continue 'dispatch;
            }
            0x821B6B40 => {
    //   block [0x821B6B40..0x821B6B70)
	// 821B6B40: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 821B6B44: 480BC515  bl 0x82273058
	ctx.lr = 0x821B6B48;
	sub_82273058(ctx, base);
	// 821B6B48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B6B50: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B6B54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B6B58: 4E800421  bctrl
	ctx.lr = 0x821B6B5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B6B5C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B6B60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B6B64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6B68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B6B6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6B70 size=240
    let mut pc: u32 = 0x821B6B70;
    'dispatch: loop {
        match pc {
            0x821B6B70 => {
    //   block [0x821B6B70..0x821B6C48)
	// 821B6B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6B74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B6B78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B6B7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B6B80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6B84: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821B6B88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B6B8C: 394B0FF0  addi r10, r11, 0xff0
	ctx.r[10].s64 = ctx.r[11].s64 + 4080;
	// 821B6B90: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B6B94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6B98: 419A00B0  beq cr6, 0x821b6c48
	if ctx.cr[6].eq {
	pc = 0x821B6C48; continue 'dispatch;
	}
	// 821B6B9C: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821B6BA0: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821B6BA4: 396B2390  addi r11, r11, 0x2390
	ctx.r[11].s64 = ctx.r[11].s64 + 9104;
	// 821B6BA8: 38EA7E70  addi r7, r10, 0x7e70
	ctx.r[7].s64 = ctx.r[10].s64 + 32368;
	// 821B6BAC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821B6BB0: 38CB2008  addi r6, r11, 0x2008
	ctx.r[6].s64 = ctx.r[11].s64 + 8200;
	// 821B6BB4: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 821B6BB8: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 821B6BBC: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821B6BC0: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 821B6BC4: 55481838  slwi r8, r10, 3
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B6BC8: 38640FFC  addi r3, r4, 0xffc
	ctx.r[3].s64 = ctx.r[4].s64 + 4092;
	// 821B6BCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B6BD0: 7CE8592E  stwx r7, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821B6BD4: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821B6BD8: 810B2000  lwz r8, 0x2000(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821B6BDC: 814B400C  lwz r10, 0x400c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821B6BE0: 555E1838  slwi r30, r10, 3
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821B6BE4: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 821B6BE8: 5509083C  slwi r9, r8, 1
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B6BEC: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	// 821B6BF0: 912B2000  stw r9, 0x2000(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8192 as u32), ctx.r[9].u32 ) };
	// 821B6BF4: 7CFE312E  stwx r7, r30, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[6].u32), ctx.r[7].u32) };
	// 821B6BF8: 814B400C  lwz r10, 0x400c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821B6BFC: 812B4008  lwz r9, 0x4008(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821B6C00: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B6C04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B6C08: 912B4008  stw r9, 0x4008(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16392 as u32), ctx.r[9].u32 ) };
	// 821B6C0C: 914B400C  stw r10, 0x400c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16396 as u32), ctx.r[10].u32 ) };
	// 821B6C10: 83DF06FC  lwz r30, 0x6fc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821B6C14: 90BF06FC  stw r5, 0x6fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1788 as u32), ctx.r[5].u32 ) };
	// 821B6C18: 48086389  bl 0x8223cfa0
	ctx.lr = 0x821B6C1C;
	sub_8223CFA0(ctx, base);
	// 821B6C1C: 93DF06FC  stw r30, 0x6fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1788 as u32), ctx.r[30].u32 ) };
	// 821B6C20: 488B4369  bl 0x82a6af88
	ctx.lr = 0x821B6C24;
	sub_82A6AF88(ctx, base);
	// 821B6C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B6C28: 488B4F79  bl 0x82a6bba0
	ctx.lr = 0x821B6C2C;
	sub_82A6BBA0(ctx, base);
	// 821B6C2C: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 821B6C30: 3CC08332  lis r6, -0x7cce
	ctx.r[6].s64 = -2093875200;
	// 821B6C34: 3886AB2C  addi r4, r6, -0x54d4
	ctx.r[4].s64 = ctx.r[6].s64 + -21716;
	// 821B6C38: 8067F9C0  lwz r3, -0x640(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821B6C3C: 480803E5  bl 0x82237020
	ctx.lr = 0x821B6C40;
	sub_82237020(ctx, base);
	// 821B6C40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B6C44: 4806869D  bl 0x8221f2e0
	ctx.lr = 0x821B6C48;
	sub_8221F2E0(ctx, base);
	pc = 0x821B6C48; continue 'dispatch;
            }
            0x821B6C48 => {
    //   block [0x821B6C48..0x821B6C60)
	// 821B6C48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B6C4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B6C50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6C54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B6C58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B6C5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6C60 size=288
    let mut pc: u32 = 0x821B6C60;
    'dispatch: loop {
        match pc {
            0x821B6C60 => {
    //   block [0x821B6C60..0x821B6CD0)
	// 821B6C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6C64: 48AF279D  bl 0x82ca9400
	ctx.lr = 0x821B6C68;
	sub_82CA93D0(ctx, base);
	// 821B6C68: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6C6C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B6C70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B6C74: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B6C78: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 821B6C7C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B6C80: 419A0050  beq cr6, 0x821b6cd0
	if ctx.cr[6].eq {
	pc = 0x821B6CD0; continue 'dispatch;
	}
	// 821B6C84: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B6C88: 217D0011  subfic r11, r29, 0x11
	ctx.xer.ca = ctx.r[29].u32 <= 17 as u32;
	ctx.r[11].s64 = (17 as i64) - ctx.r[29].s64;
	// 821B6C8C: 80BE001C  lwz r5, 0x1c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B6C90: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 821B6C94: 388B00DE  addi r4, r11, 0xde
	ctx.r[4].s64 = ctx.r[11].s64 + 222;
	// 821B6C98: 5547653E  srwi r7, r10, 0x14
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shr(20);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B6C9C: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B6CA0: 39670200  addi r11, r7, 0x200
	ctx.r[11].s64 = ctx.r[7].s64 + 512;
	// 821B6CA4: 554A00FE  clrlwi r10, r10, 3
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 821B6CA8: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B6CAC: 54871838  slwi r7, r4, 3
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B6CB0: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 821B6CB4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B6CB8: 7CC62850  subf r6, r6, r5
	ctx.r[6].s64 = ctx.r[5].s64 - ctx.r[6].s64;
	// 821B6CBC: 7D67F92E  stwx r11, r7, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u32) };
	// 821B6CC0: 90C906F4  stw r6, 0x6f4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1780 as u32), ctx.r[6].u32 ) };
	// 821B6CC4: E97F0018  ld r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 821B6CC8: 7D6B4378  or r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[8].u64;
	// 821B6CCC: F97F0018  std r11, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	pc = 0x821B6CD0; continue 'dispatch;
            }
            0x821B6CD0 => {
    //   block [0x821B6CD0..0x821B6CF8)
	// 821B6CD0: 397D0C2B  addi r11, r29, 0xc2b
	ctx.r[11].s64 = ctx.r[29].s64 + 3115;
	// 821B6CD4: 557B103A  slwi r27, r11, 2
	ctx.r[27].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 821B6CD8: 7F9BF82E  lwzx r28, r27, r31
	ctx.r[28].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821B6CDC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821B6CE0: 419A0068  beq cr6, 0x821b6d48
	if ctx.cr[6].eq {
	pc = 0x821B6D48; continue 'dispatch;
	}
	// 821B6CE4: 817F2A9C  lwz r11, 0x2a9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10908 as u32) ) } as u64;
	// 821B6CE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6CEC: 419A000C  beq cr6, 0x821b6cf8
	if ctx.cr[6].eq {
	pc = 0x821B6CF8; continue 'dispatch;
	}
	// 821B6CF0: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821B6CF4: 48000054  b 0x821b6d48
	pc = 0x821B6D48; continue 'dispatch;
            }
            0x821B6CF8 => {
    //   block [0x821B6CF8..0x821B6D20)
	// 821B6CF8: 817F2AA0  lwz r11, 0x2aa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10912 as u32) ) } as u64;
	// 821B6CFC: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6D00: 7D6B5039  and. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6D04: 41820044  beq 0x821b6d48
	if ctx.cr[0].eq {
	pc = 0x821B6D48; continue 'dispatch;
	}
	// 821B6D08: 817F34D8  lwz r11, 0x34d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13528 as u32) ) } as u64;
	// 821B6D0C: 807F34D4  lwz r3, 0x34d4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13524 as u32) ) } as u64;
	// 821B6D10: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B6D14: 4198000C  blt cr6, 0x821b6d20
	if ctx.cr[6].lt {
	pc = 0x821B6D20; continue 'dispatch;
	}
	// 821B6D18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B6D1C: 489EAD95  bl 0x82ba1ab0
	ctx.lr = 0x821B6D20;
	sub_82BA1AB0(ctx, base);
	pc = 0x821B6D20; continue 'dispatch;
            }
            0x821B6D20 => {
    //   block [0x821B6D20..0x821B6D48)
	// 821B6D20: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B6D24: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821B6D28: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 821B6D2C: 538BF0BE  rlwimi r11, r28, 0x1e, 2, 0x1f
	ctx.r[11].u64 = (((ctx.r[28].u32).rotate_left(30) as u64) & 0x000000003FFFFFFF) | (ctx.r[11].u64 & 0xFFFFFFFFC0000000);
	// 821B6D30: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B6D34: 556B0080  rlwinm r11, r11, 0, 2, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B6D38: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B6D3C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B6D40: F9630000  std r11, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B6D44: 913F34D4  stw r9, 0x34d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13524 as u32), ctx.r[9].u32 ) };
	pc = 0x821B6D48; continue 'dispatch;
            }
            0x821B6D48 => {
    //   block [0x821B6D48..0x821B6D78)
	// 821B6D48: 7D7FEA14  add r11, r31, r29
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[29].u64;
	// 821B6D4C: 7FDBF92E  stwx r30, r27, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32), ctx.r[30].u32) };
	// 821B6D50: 5749F63E  rlwinm r9, r26, 0x1e, 0x18, 0x1f
	ctx.r[9].u64 = ctx.r[26].u32 as u64 & 0x00000003u64;
	// 821B6D54: 574AF0BF  rlwinm. r10, r26, 0x1e, 2, 0x1f
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B6D58: 992B30F0  stb r9, 0x30f0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12528 as u32), ctx.r[9].u8 ) };
	// 821B6D5C: 4182001C  beq 0x821b6d78
	if ctx.cr[0].eq {
	pc = 0x821B6D78; continue 'dispatch;
	}
	// 821B6D60: 896B2E38  lbz r11, 0x2e38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(11832 as u32) ) } as u64;
	// 821B6D64: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B6D68: 419A0010  beq cr6, 0x821b6d78
	if ctx.cr[6].eq {
	pc = 0x821B6D78; continue 'dispatch;
	}
	// 821B6D6C: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B6D70: 656B0008  oris r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 524288;
	// 821B6D74: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	pc = 0x821B6D78; continue 'dispatch;
            }
            0x821B6D78 => {
    //   block [0x821B6D78..0x821B6D80)
	// 821B6D78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B6D7C: 48AF26D4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6D80 size=172
    let mut pc: u32 = 0x821B6D80;
    'dispatch: loop {
        match pc {
            0x821B6D80 => {
    //   block [0x821B6D80..0x821B6E2C)
	// 821B6D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6D84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B6D88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B6D8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6D90: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 821B6D94: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B6D98: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B6D9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B6DA0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B6DA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B6DA8: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B6DAC: 4BFFFEB5  bl 0x821b6c60
	ctx.lr = 0x821B6DB0;
	sub_821B6C60(ctx, base);
	// 821B6DB0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B6DB4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B6DB8: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B6DBC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B6DC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B6DC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B6DC8: 4BFFFE99  bl 0x821b6c60
	ctx.lr = 0x821B6DCC;
	sub_821B6C60(ctx, base);
	// 821B6DCC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B6DD0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B6DD4: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B6DD8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B6DDC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B6DE0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821B6DE4: 4BFFFE7D  bl 0x821b6c60
	ctx.lr = 0x821B6DE8;
	sub_821B6C60(ctx, base);
	// 821B6DE8: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 821B6DEC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B6DF0: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B6DF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B6DF8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B6DFC: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821B6E00: 4BFFFE61  bl 0x821b6c60
	ctx.lr = 0x821B6E04;
	sub_821B6C60(ctx, base);
	// 821B6E04: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B6E08: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B6E0C: 4BFE5E25  bl 0x8219cc30
	ctx.lr = 0x821B6E10;
	sub_8219CC30(ctx, base);
	// 821B6E10: 48000021  bl 0x821b6e30
	ctx.lr = 0x821B6E14;
	sub_821B6E30(ctx, base);
	// 821B6E14: 4BFFE32D  bl 0x821b5140
	ctx.lr = 0x821B6E18;
	sub_821B5140(ctx, base);
	// 821B6E18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B6E1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B6E20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6E24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B6E28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6E30 size=176
    let mut pc: u32 = 0x821B6E30;
    'dispatch: loop {
        match pc {
            0x821B6E30 => {
    //   block [0x821B6E30..0x821B6E5C)
	// 821B6E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6E34: 48AF25D1  bl 0x82ca9404
	ctx.lr = 0x821B6E38;
	sub_82CA93D0(ctx, base);
	// 821B6E38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6E3C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821B6E40: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B6E44: 3B6B02B0  addi r27, r11, 0x2b0
	ctx.r[27].s64 = ctx.r[11].s64 + 688;
	// 821B6E48: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B6E4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821B6E50: 795EFFE6  rldicr r30, r10, 0x3f, 0x3f
	ctx.r[30].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821B6E54: 3F808336  lis r28, -0x7cca
	ctx.r[28].s64 = -2093613056;
	// 821B6E58: 3BABB0BC  addi r29, r11, -0x4f44
	ctx.r[29].s64 = ctx.r[11].s64 + -20292;
	pc = 0x821B6E5C; continue 'dispatch;
            }
            0x821B6E5C => {
    //   block [0x821B6E5C..0x821B6E84)
	// 821B6E5C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6E60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6E64: 409A0020  bne cr6, 0x821b6e84
	if !ctx.cr[6].eq {
	pc = 0x821B6E84; continue 'dispatch;
	}
	// 821B6E68: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 821B6E6C: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6E70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B6E74: 807C0364  lwz r3, 0x364(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B6E78: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821B6E7C: 7FC65436  srd r6, r30, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[30].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821B6E80: 48000061  bl 0x821b6ee0
	ctx.lr = 0x821B6E84;
	sub_821B6EE0(ctx, base);
	pc = 0x821B6E84; continue 'dispatch;
            }
            0x821B6E84 => {
    //   block [0x821B6E84..0x821B6EA0)
	// 821B6E84: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B6E88: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 821B6E8C: 2B1F0010  cmplwi cr6, r31, 0x10
	ctx.cr[6].compare_u32(ctx.r[31].u32, 16 as u32, &mut ctx.xer);
	// 821B6E90: 4198FFCC  blt cr6, 0x821b6e5c
	if ctx.cr[6].lt {
	pc = 0x821B6E5C; continue 'dispatch;
	}
	// 821B6E94: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821B6E98: 3BE00010  li r31, 0x10
	ctx.r[31].s64 = 16;
	// 821B6E9C: 3B6B02A0  addi r27, r11, 0x2a0
	ctx.r[27].s64 = ctx.r[11].s64 + 672;
	pc = 0x821B6EA0; continue 'dispatch;
            }
            0x821B6EA0 => {
    //   block [0x821B6EA0..0x821B6EC8)
	// 821B6EA0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6EA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6EA8: 409A0020  bne cr6, 0x821b6ec8
	if !ctx.cr[6].eq {
	pc = 0x821B6EC8; continue 'dispatch;
	}
	// 821B6EAC: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 821B6EB0: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6EB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B6EB8: 807C0364  lwz r3, 0x364(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B6EBC: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821B6EC0: 7FC65436  srd r6, r30, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[30].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821B6EC4: 4800001D  bl 0x821b6ee0
	ctx.lr = 0x821B6EC8;
	sub_821B6EE0(ctx, base);
	pc = 0x821B6EC8; continue 'dispatch;
            }
            0x821B6EC8 => {
    //   block [0x821B6EC8..0x821B6EE0)
	// 821B6EC8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B6ECC: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 821B6ED0: 2B1F0014  cmplwi cr6, r31, 0x14
	ctx.cr[6].compare_u32(ctx.r[31].u32, 20 as u32, &mut ctx.xer);
	// 821B6ED4: 4198FFCC  blt cr6, 0x821b6ea0
	if ctx.cr[6].lt {
	pc = 0x821B6EA0; continue 'dispatch;
	}
	// 821B6ED8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B6EDC: 48AF2578  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6EE0 size=380
    let mut pc: u32 = 0x821B6EE0;
    'dispatch: loop {
        match pc {
            0x821B6EE0 => {
    //   block [0x821B6EE0..0x821B6FB0)
	// 821B6EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6EE4: 48AF2505  bl 0x82ca93e8
	ctx.lr = 0x821B6EE8;
	sub_82CA93D0(ctx, base);
	// 821B6EE8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6EEC: 39640C40  addi r11, r4, 0xc40
	ctx.r[11].s64 = ctx.r[4].s64 + 3136;
	// 821B6EF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B6EF4: 557D103A  slwi r29, r11, 2
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821B6EF8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B6EFC: 7F9DF82E  lwzx r28, r29, r31
	ctx.r[28].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821B6F00: 419A00E4  beq cr6, 0x821b6fe4
	if ctx.cr[6].eq {
	pc = 0x821B6FE4; continue 'dispatch;
	}
	// 821B6F04: 83650030  lwz r27, 0x30(r5)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B6F08: 39640030  addi r11, r4, 0x30
	ctx.r[11].s64 = ctx.r[4].s64 + 48;
	// 821B6F0C: 80E50020  lwz r7, 0x20(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B6F10: 5769653E  srwi r9, r27, 0x14
	ctx.r[9].u32 = ctx.r[27].u32.wrapping_shr(20);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B6F14: 8345002C  lwz r26, 0x2c(r5)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B6F18: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821B6F1C: 8325001C  lwz r25, 0x1c(r5)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B6F20: 83050024  lwz r24, 0x24(r5)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B6F24: 82E50028  lwz r23, 0x28(r5)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B6F28: 54EA653E  srwi r10, r7, 0x14
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(20);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B6F2C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821B6F30: 39290200  addi r9, r9, 0x200
	ctx.r[9].s64 = ctx.r[9].s64 + 512;
	// 821B6F34: 394A0200  addi r10, r10, 0x200
	ctx.r[10].s64 = ctx.r[10].s64 + 512;
	// 821B6F38: 54FE00FE  clrlwi r30, r7, 3
	ctx.r[30].u64 = ctx.r[7].u32 as u64 & 0x1FFFFFFFu64;
	// 821B6F3C: 552804E6  rlwinm r8, r9, 0, 0x13, 0x13
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821B6F40: 554304E6  rlwinm r3, r10, 0, 0x13, 0x13
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821B6F44: 82CB0000  lwz r22, 0(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6F48: 7D3F2214  add r9, r31, r4
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[4].u64;
	// 821B6F4C: 808B0010  lwz r4, 0x10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B6F50: 576700EC  rlwinm r7, r27, 0, 3, 0x16
	ctx.r[7].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 821B6F54: 836B0004  lwz r27, 4(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6F58: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 821B6F5C: 82AB000C  lwz r21, 0xc(r11)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B6F60: 828B0014  lwz r20, 0x14(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B6F64: 7CE83A14  add r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 821B6F68: 7C63F214  add r3, r3, r30
	ctx.r[3].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 821B6F6C: 930B0008  stw r24, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 821B6F70: 508A07AA  rlwimi r10, r4, 0, 0x1e, 0x15
	ctx.r[10].u64 = (((ctx.r[4].u32).rotate_left(0) as u64) & 0xFFFFFFFFFFFFFC03) | (ctx.r[10].u64 & 0x00000000000003FC);
	// 821B6F74: 89092EAE  lbz r8, 0x2eae(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(11950 as u32) ) } as u64;
	// 821B6F78: 52D902AA  rlwimi r25, r22, 0, 0xa, 0x15
	ctx.r[25].u64 = (((ctx.r[22].u32).rotate_left(0) as u64) & 0x00000000003FFC00) | (ctx.r[25].u64 & 0xFFFFFFFFFFC003FF);
	// 821B6F7C: 53630528  rlwimi r3, r27, 0, 0x14, 0x14
	ctx.r[3].u64 = (((ctx.r[27].u32).rotate_left(0) as u64) & 0x0000000000000800) | (ctx.r[3].u64 & 0xFFFFFFFFFFFFF7FF);
	// 821B6F80: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821B6F84: 52B70058  rlwimi r23, r21, 0, 1, 0xc
	ctx.r[23].u64 = (((ctx.r[21].u32).rotate_left(0) as u64) & 0x000000007FF80000) | (ctx.r[23].u64 & 0xFFFFFFFF8007FFFF);
	// 821B6F88: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 821B6F8C: 528705FE  rlwimi r7, r20, 0, 0x17, 0x1f
	ctx.r[7].u64 = (((ctx.r[20].u32).rotate_left(0) as u64) & 0x00000000000001FF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFFFE00);
	// 821B6F90: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821B6F94: 5744F73E  rlwinm r4, r26, 0x1e, 0x1c, 0x1f
	ctx.r[4].u64 = ctx.r[26].u32 as u64 & 0x00000003u64;
	// 821B6F98: 92EB000C  stw r23, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[23].u32 ) };
	// 821B6F9C: 90EB0014  stw r7, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 821B6FA0: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B6FA4: 4099000C  ble cr6, 0x821b6fb0
	if !ctx.cr[6].gt {
	pc = 0x821B6FB0; continue 'dispatch;
	}
	// 821B6FA8: 5748003E  slwi r8, r26, 0
	ctx.r[8].u32 = ctx.r[26].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B6FAC: 5508F73E  rlwinm r8, r8, 0x1e, 0x1c, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	pc = 0x821B6FB0; continue 'dispatch;
            }
            0x821B6FB0 => {
    //   block [0x821B6FB0..0x821B6FD0)
	// 821B6FB0: 80E5002C  lwz r7, 0x2c(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B6FB4: 510A16BA  rlwimi r10, r8, 2, 0x1a, 0x1d
	ctx.r[10].u64 = (((ctx.r[8].u32).rotate_left(2) as u64) & 0x000000000000003C) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFC3);
	// 821B6FB8: 89292EC8  lbz r9, 0x2ec8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(11976 as u32) ) } as u64;
	// 821B6FBC: 54E8D73E  rlwinm r8, r7, 0x1a, 0x1c, 0x1f
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x0000003Fu64;
	// 821B6FC0: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821B6FC4: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B6FC8: 40980008  bge cr6, 0x821b6fd0
	if !ctx.cr[6].lt {
	pc = 0x821B6FD0; continue 'dispatch;
	}
	// 821B6FCC: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	pc = 0x821B6FD0; continue 'dispatch;
            }
            0x821B6FD0 => {
    //   block [0x821B6FD0..0x821B6FE4)
	// 821B6FD0: E91F0018  ld r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 821B6FD4: 512A35B2  rlwimi r10, r9, 6, 0x16, 0x19
	ctx.r[10].u64 = (((ctx.r[9].u32).rotate_left(6) as u64) & 0x00000000000003C0) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFC3F);
	// 821B6FD8: 7D093378  or r9, r8, r6
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[6].u64;
	// 821B6FDC: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821B6FE0: F93F0018  std r9, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u64 ) };
	pc = 0x821B6FE4; continue 'dispatch;
            }
            0x821B6FE4 => {
    //   block [0x821B6FE4..0x821B7004)
	// 821B6FE4: 7CBDF92E  stwx r5, r29, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32), ctx.r[5].u32) };
	// 821B6FE8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821B6FEC: 419A0068  beq cr6, 0x821b7054
	if ctx.cr[6].eq {
	pc = 0x821B7054; continue 'dispatch;
	}
	// 821B6FF0: 817F2A9C  lwz r11, 0x2a9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10908 as u32) ) } as u64;
	// 821B6FF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6FF8: 419A000C  beq cr6, 0x821b7004
	if ctx.cr[6].eq {
	pc = 0x821B7004; continue 'dispatch;
	}
	// 821B6FFC: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821B7000: 48000054  b 0x821b7054
	pc = 0x821B7054; continue 'dispatch;
            }
            0x821B7004 => {
    //   block [0x821B7004..0x821B702C)
	// 821B7004: 817F2AA0  lwz r11, 0x2aa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10912 as u32) ) } as u64;
	// 821B7008: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B700C: 7D6B5039  and. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B7010: 41820044  beq 0x821b7054
	if ctx.cr[0].eq {
	pc = 0x821B7054; continue 'dispatch;
	}
	// 821B7014: 817F34D8  lwz r11, 0x34d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13528 as u32) ) } as u64;
	// 821B7018: 807F34D4  lwz r3, 0x34d4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13524 as u32) ) } as u64;
	// 821B701C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B7020: 4198000C  blt cr6, 0x821b702c
	if ctx.cr[6].lt {
	pc = 0x821B702C; continue 'dispatch;
	}
	// 821B7024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B7028: 489EAA89  bl 0x82ba1ab0
	ctx.lr = 0x821B702C;
	sub_82BA1AB0(ctx, base);
	pc = 0x821B702C; continue 'dispatch;
            }
            0x821B702C => {
    //   block [0x821B702C..0x821B7054)
	// 821B702C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B7030: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821B7034: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 821B7038: 538BF0BE  rlwimi r11, r28, 0x1e, 2, 0x1f
	ctx.r[11].u64 = (((ctx.r[28].u32).rotate_left(30) as u64) & 0x000000003FFFFFFF) | (ctx.r[11].u64 & 0xFFFFFFFFC0000000);
	// 821B703C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B7040: 556B0080  rlwinm r11, r11, 0, 2, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B7044: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B7048: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B704C: F9630000  std r11, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B7050: 913F34D4  stw r9, 0x34d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13524 as u32), ctx.r[9].u32 ) };
	pc = 0x821B7054; continue 'dispatch;
            }
            0x821B7054 => {
    //   block [0x821B7054..0x821B705C)
	// 821B7054: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B7058: 48AF23E0  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B7060 size=196
    let mut pc: u32 = 0x821B7060;
    'dispatch: loop {
        match pc {
            0x821B7060 => {
    //   block [0x821B7060..0x821B7088)
	// 821B7060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7064: 48AF23A1  bl 0x82ca9404
	ctx.lr = 0x821B7068;
	sub_82CA93D0(ctx, base);
	// 821B7068: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B706C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821B7070: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821B7074: 3B8B02B0  addi r28, r11, 0x2b0
	ctx.r[28].s64 = ctx.r[11].s64 + 688;
	// 821B7078: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B707C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 821B7080: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 821B7084: 797DFFE6  rldicr r29, r11, 0x3f, 0x3f
	ctx.r[29].u64 = (ctx.r[11].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	pc = 0x821B7088; continue 'dispatch;
            }
            0x821B7088 => {
    //   block [0x821B7088..0x821B70B8)
	// 821B7088: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B708C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7090: 419A0028  beq cr6, 0x821b70b8
	if ctx.cr[6].eq {
	pc = 0x821B70B8; continue 'dispatch;
	}
	// 821B7094: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821B7098: 41980020  blt cr6, 0x821b70b8
	if ctx.cr[6].lt {
	pc = 0x821B70B8; continue 'dispatch;
	}
	// 821B709C: 395F0020  addi r10, r31, 0x20
	ctx.r[10].s64 = ctx.r[31].s64 + 32;
	// 821B70A0: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B70A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B70A8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B70AC: 79490020  clrldi r9, r10, 0x20
	ctx.r[9].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 821B70B0: 7FA64C36  srd r6, r29, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[29].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 821B70B4: 4BFFFE2D  bl 0x821b6ee0
	ctx.lr = 0x821B70B8;
	sub_821B6EE0(ctx, base);
	pc = 0x821B70B8; continue 'dispatch;
            }
            0x821B70B8 => {
    //   block [0x821B70B8..0x821B70DC)
	// 821B70B8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B70BC: 397C0050  addi r11, r28, 0x50
	ctx.r[11].s64 = ctx.r[28].s64 + 80;
	// 821B70C0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B70C4: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B70C8: 4198FFC0  blt cr6, 0x821b7088
	if ctx.cr[6].lt {
	pc = 0x821B7088; continue 'dispatch;
	}
	// 821B70CC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821B70D0: 3BE00010  li r31, 0x10
	ctx.r[31].s64 = 16;
	// 821B70D4: 3BCB02A0  addi r30, r11, 0x2a0
	ctx.r[30].s64 = ctx.r[11].s64 + 672;
	// 821B70D8: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	pc = 0x821B70DC; continue 'dispatch;
            }
            0x821B70DC => {
    //   block [0x821B70DC..0x821B710C)
	// 821B70DC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B70E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B70E4: 419A0028  beq cr6, 0x821b710c
	if ctx.cr[6].eq {
	pc = 0x821B710C; continue 'dispatch;
	}
	// 821B70E8: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821B70EC: 41980020  blt cr6, 0x821b710c
	if ctx.cr[6].lt {
	pc = 0x821B710C; continue 'dispatch;
	}
	// 821B70F0: 395F0020  addi r10, r31, 0x20
	ctx.r[10].s64 = ctx.r[31].s64 + 32;
	// 821B70F4: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B70F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B70FC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7100: 79490020  clrldi r9, r10, 0x20
	ctx.r[9].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 821B7104: 7FA64C36  srd r6, r29, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[29].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 821B7108: 4BFFFDD9  bl 0x821b6ee0
	ctx.lr = 0x821B710C;
	sub_821B6EE0(ctx, base);
	pc = 0x821B710C; continue 'dispatch;
            }
            0x821B710C => {
    //   block [0x821B710C..0x821B7124)
	// 821B710C: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821B7110: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B7114: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B7118: 4082FFC4  bne 0x821b70dc
	if !ctx.cr[0].eq {
	pc = 0x821B70DC; continue 'dispatch;
	}
	// 821B711C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B7120: 48AF2334  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7128 size=196
    let mut pc: u32 = 0x821B7128;
    'dispatch: loop {
        match pc {
            0x821B7128 => {
    //   block [0x821B7128..0x821B71EC)
	// 821B7128: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 821B712C: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 821B7130: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 821B7134: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B7138: 38C1FFE0  addi r6, r1, -0x20
	ctx.r[6].s64 = ctx.r[1].s64 + -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B71F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B71F0 size=160
    let mut pc: u32 = 0x821B71F0;
    'dispatch: loop {
        match pc {
            0x821B71F0 => {
    //   block [0x821B71F0..0x821B724C)
	// 821B71F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B71F4: 48AF2211  bl 0x82ca9404
	ctx.lr = 0x821B71F8;
	sub_82CA93D0(ctx, base);
	// 821B71F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B71FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B7200: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B7204: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7208: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B720C: 4098007C  bge cr6, 0x821b7288
	if !ctx.cr[6].lt {
	pc = 0x821B7288; continue 'dispatch;
	}
	// 821B7210: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 821B7214: 557C003A  rlwinm r28, r11, 0, 0, 0x1d
	ctx.r[28].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B7218: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B721C: 4806803D  bl 0x8221f258
	ctx.lr = 0x821B7220;
	sub_8221F258(ctx, base);
	// 821B7220: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B7224: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7228: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B722C: 4805126D  bl 0x82208498
	ctx.lr = 0x821B7230;
	sub_82208498(ctx, base);
	// 821B7230: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821B7234: 7F7DF1AE  stbx r27, r29, r30
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32), ctx.r[27].u8) };
	// 821B7238: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B723C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B7240: 419A000C  beq cr6, 0x821b724c
	if ctx.cr[6].eq {
	pc = 0x821B724C; continue 'dispatch;
	}
	// 821B7244: 48064AF5  bl 0x8221bd38
	ctx.lr = 0x821B7248;
	sub_8221BD38(ctx, base);
	// 821B7248: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x821B724C; continue 'dispatch;
            }
            0x821B724C => {
    //   block [0x821B724C..0x821B7288)
	// 821B724C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7250: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B7254: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821B7258: 538B083C  rlwimi r11, r28, 1, 0, 0x1e
	ctx.r[11].u64 = (((ctx.r[28].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[11].u64 & 0xFFFFFFFF00000001);
	// 821B725C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821B7260: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821B7264: 7F7DF1AE  stbx r27, r29, r30
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32), ctx.r[27].u8) };
	// 821B7268: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B726C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7270: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B7274: 392B0003  addi r9, r11, 3
	ctx.r[9].s64 = ctx.r[11].s64 + 3;
	// 821B7278: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B727C: 5528003A  rlwinm r8, r9, 0, 0, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821B7280: 7CAB4050  subf r5, r11, r8
	ctx.r[5].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 821B7284: 48AF272D  bl 0x82ca99b0
	ctx.lr = 0x821B7288;
	sub_82CA99B0(ctx, base);
	pc = 0x821B7288; continue 'dispatch;
            }
            0x821B7288 => {
    //   block [0x821B7288..0x821B7290)
	// 821B7288: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B728C: 48AF21C8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7290 size=208
    let mut pc: u32 = 0x821B7290;
    'dispatch: loop {
        match pc {
            0x821B7290 => {
    //   block [0x821B7290..0x821B72BC)
	// 821B7290: F8610010  std r3, 0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 821B7294: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 821B7298: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B729C: 81010014  lwz r8, 0x14(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B72A0: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 821B72A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B72A8: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B72AC: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B72B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B72B4: 41980008  blt cr6, 0x821b72bc
	if ctx.cr[6].lt {
	pc = 0x821B72BC; continue 'dispatch;
	}
	// 821B72B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821B72BC; continue 'dispatch;
            }
            0x821B72BC => {
    //   block [0x821B72BC..0x821B72E0)
	// 821B72BC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B72C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B72C4: 419A001C  beq cr6, 0x821b72e0
	if ctx.cr[6].eq {
	pc = 0x821B72E0; continue 'dispatch;
	}
	// 821B72C8: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B72CC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B72D0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B72D4: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B72D8: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821B72DC: F9280000  std r9, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	pc = 0x821B72E0; continue 'dispatch;
            }
            0x821B72E0 => {
    //   block [0x821B72E0..0x821B72FC)
	// 821B72E0: 81210024  lwz r9, 0x24(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B72E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B72E8: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B72EC: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B72F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B72F4: 41980008  blt cr6, 0x821b72fc
	if ctx.cr[6].lt {
	pc = 0x821B72FC; continue 'dispatch;
	}
	// 821B72F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821B72FC; continue 'dispatch;
            }
            0x821B72FC => {
    //   block [0x821B72FC..0x821B7320)
	// 821B72FC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B7300: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7304: 419A001C  beq cr6, 0x821b7320
	if ctx.cr[6].eq {
	pc = 0x821B7320; continue 'dispatch;
	}
	// 821B7308: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B730C: E8E90000  ld r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821B7310: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B7314: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7318: 90C90004  stw r6, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821B731C: F8EB0000  std r7, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	pc = 0x821B7320; continue 'dispatch;
            }
            0x821B7320 => {
    //   block [0x821B7320..0x821B7338)
	// 821B7320: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7324: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7328: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B732C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B7330: 41980008  blt cr6, 0x821b7338
	if ctx.cr[6].lt {
	pc = 0x821B7338; continue 'dispatch;
	}
	// 821B7334: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821B7338; continue 'dispatch;
            }
            0x821B7338 => {
    //   block [0x821B7338..0x821B7360)
	// 821B7338: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B733C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7340: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821B7344: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7348: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B734C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B7350: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7354: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821B7358: F9280000  std r9, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B735C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B7360 size=260
    let mut pc: u32 = 0x821B7360;
    'dispatch: loop {
        match pc {
            0x821B7360 => {
    //   block [0x821B7360..0x821B7450)
	// 821B7360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7364: 48AF2099  bl 0x82ca93fc
	ctx.lr = 0x821B7368;
	sub_82CA93D0(ctx, base);
	// 821B7368: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B736C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B7370: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821B7374: FBC100B0  std r30, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[30].u64 ) };
	// 821B7378: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B737C: FB8100C0  std r28, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u64 ) };
	// 821B7380: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 821B7384: 832100C4  lwz r25, 0xc4(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 821B7388: 7D6AC850  subf r11, r10, r25
	ctx.r[11].s64 = ctx.r[25].s64 - ctx.r[10].s64;
	// 821B738C: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 821B7390: FBA100B8  std r29, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[29].u64 ) };
	// 821B7394: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 821B7398: 409900B8  ble cr6, 0x821b7450
	if !ctx.cr[6].gt {
	pc = 0x821B7450; continue 'dispatch;
	}
	// 821B739C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B73A0: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 821B73A4: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 821B73A8: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 821B73AC: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 821B73B0: 557F1838  slwi r31, r11, 3
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821B73B4: 557A2036  slwi r26, r11, 4
	ctx.r[26].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 821B73B8: 7F7F5214  add r27, r31, r10
	ctx.r[27].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 821B73BC: 7D1A5214  add r8, r26, r10
	ctx.r[8].u64 = ctx.r[26].u64 + ctx.r[10].u64;
	// 821B73C0: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 821B73C4: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821B73C8: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B73CC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B73D0: 4BFFFEC1  bl 0x821b7290
	ctx.lr = 0x821B73D4;
	sub_821B7290(ctx, base);
	// 821B73D4: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821B73D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B73DC: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 821B73E0: 7CFF5A14  add r7, r31, r11
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 821B73E4: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 821B73E8: 7CDF5850  subf r6, r31, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 821B73EC: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 821B73F0: 90C10054  stw r6, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 821B73F4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B73F8: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B73FC: 4BFFFE95  bl 0x821b7290
	ctx.lr = 0x821B7400;
	sub_821B7290(ctx, base);
	// 821B7400: 7C9AC850  subf r4, r26, r25
	ctx.r[4].s64 = ctx.r[25].s64 - ctx.r[26].s64;
	// 821B7404: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 821B7408: 7FFFC850  subf r31, r31, r25
	ctx.r[31].s64 = ctx.r[25].s64 - ctx.r[31].s64;
	// 821B740C: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 821B7410: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821B7414: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821B7418: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821B741C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B7420: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B7424: 4BFFFE6D  bl 0x821b7290
	ctx.lr = 0x821B7428;
	sub_821B7290(ctx, base);
	// 821B7428: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 821B742C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B7430: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 821B7434: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821B7438: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 821B743C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B7440: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B7444: 4BFFFE4D  bl 0x821b7290
	ctx.lr = 0x821B7448;
	sub_821B7290(ctx, base);
	// 821B7448: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B744C: 48AF2000  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B7450 => {
    //   block [0x821B7450..0x821B7464)
	// 821B7450: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821B7454: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B7458: 4BFFFE39  bl 0x821b7290
	ctx.lr = 0x821B745C;
	sub_821B7290(ctx, base);
	// 821B745C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B7460: 48AF1FEC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


