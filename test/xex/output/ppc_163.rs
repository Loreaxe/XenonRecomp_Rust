pub fn sub_82EC6838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6838 size=196
    let mut pc: u32 = 0x82EC6838;
    'dispatch: loop {
        match pc {
            0x82EC6838 => {
    //   block [0x82EC6838..0x82EC6870)
	// 82EC6838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC683C: 4BDE2BC9  bl 0x82ca9404
	ctx.lr = 0x82EC6840;
	sub_82CA93D0(ctx, base);
	// 82EC6840: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6844: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6848: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC684C: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC6850: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC6854: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC6858: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC685C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC6860: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC6864: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC6868: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC686C: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82EC6870; continue 'dispatch;
            }
            0x82EC6870 => {
    //   block [0x82EC6870..0x82EC689C)
	// 82EC6870: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6874: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6878: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC687C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC6880: 4082FFF0  bne 0x82ec6870
	if !ctx.cr[0].eq {
	pc = 0x82EC6870; continue 'dispatch;
	}
	// 82EC6884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6888: 4BFFFEE9  bl 0x82ec6770
	ctx.lr = 0x82EC688C;
	sub_82EC6770(ctx, base);
	// 82EC688C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6890: 4082000C  bne 0x82ec689c
	if !ctx.cr[0].eq {
	pc = 0x82EC689C; continue 'dispatch;
	}
	// 82EC6894: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC6898: 48000010  b 0x82ec68a8
	pc = 0x82EC68A8; continue 'dispatch;
            }
            0x82EC689C => {
    //   block [0x82EC689C..0x82EC68A8)
	// 82EC689C: 4BFF4ADD  bl 0x82ebb378
	ctx.lr = 0x82EC68A0;
	sub_82EBB378(ctx, base);
	// 82EC68A0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC68A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC68A8; continue 'dispatch;
            }
            0x82EC68A8 => {
    //   block [0x82EC68A8..0x82EC68CC)
	// 82EC68A8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC68AC: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC68B0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC68B4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC68B8: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC68BC: 409A0010  bne cr6, 0x82ec68cc
	if !ctx.cr[6].eq {
	pc = 0x82EC68CC; continue 'dispatch;
	}
	// 82EC68C0: 4BFB9199  bl 0x82e7fa58
	ctx.lr = 0x82EC68C4;
	sub_82E7FA58(ctx, base);
	// 82EC68C4: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC68C8: 4800000C  b 0x82ec68d4
	pc = 0x82EC68D4; continue 'dispatch;
            }
            0x82EC68CC => {
    //   block [0x82EC68CC..0x82EC68D4)
	// 82EC68CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC68D0: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC68D4; continue 'dispatch;
            }
            0x82EC68D4 => {
    //   block [0x82EC68D4..0x82EC68F0)
	// 82EC68D4: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC68D8: 41820018  beq 0x82ec68f0
	if ctx.cr[0].eq {
	pc = 0x82EC68F0; continue 'dispatch;
	}
	// 82EC68DC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC68E0: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC68E4: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC68E8: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC68EC: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC68F0; continue 'dispatch;
            }
            0x82EC68F0 => {
    //   block [0x82EC68F0..0x82EC68FC)
	// 82EC68F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC68F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC68F8: 4BDE2B5C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6900 size=68
    let mut pc: u32 = 0x82EC6900;
    'dispatch: loop {
        match pc {
            0x82EC6900 => {
    //   block [0x82EC6900..0x82EC6944)
	// 82EC6900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6908: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC690C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6910: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC6914: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC6918: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC691C: 4BFFFF1D  bl 0x82ec6838
	ctx.lr = 0x82EC6920;
	sub_82EC6838(ctx, base);
	// 82EC6920: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6928: 396BB230  addi r11, r11, -0x4dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -19920;
	// 82EC692C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC6930: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6934: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6938: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC693C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6940: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC6948 size=272
    let mut pc: u32 = 0x82EC6948;
    'dispatch: loop {
        match pc {
            0x82EC6948 => {
    //   block [0x82EC6948..0x82EC6A50)
	// 82EC6948: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC694C: 396BEF78  addi r11, r11, -0x1088
	ctx.r[11].s64 = ctx.r[11].s64 + -4232;
	// 82EC6950: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6954: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC6958: 419A00F8  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
	pc = 0x82EC6A50; continue 'dispatch;
	}
	// 82EC695C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC6960: 396BE4AC  addi r11, r11, -0x1b54
	ctx.r[11].s64 = ctx.r[11].s64 + -6996;
	// 82EC6964: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6968: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC696C: 419A00E4  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
	pc = 0x82EC6A50; continue 'dispatch;
	}
	// 82EC6970: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC6974: 396BE6D4  addi r11, r11, -0x192c
	ctx.r[11].s64 = ctx.r[11].s64 + -6444;
	// 82EC6978: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC697C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC6980: 419A00D0  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
	pc = 0x82EC6A50; continue 'dispatch;
	}
	// 82EC6984: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC6988: 396BE5C0  addi r11, r11, -0x1a40
	ctx.r[11].s64 = ctx.r[11].s64 + -6720;
	// 82EC698C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6990: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC6994: 419A00BC  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
	pc = 0x82EC6A50; continue 'dispatch;
	}
	// 82EC6998: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC699C: 396BE7E8  addi r11, r11, -0x1818
	ctx.r[11].s64 = ctx.r[11].s64 + -6168;
	// 82EC69A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC69A4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC69A8: 419A00A8  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
	pc = 0x82EC6A50; continue 'dispatch;
	}
	// 82EC69AC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC69B0: 396BE284  addi r11, r11, -0x1d7c
	ctx.r[11].s64 = ctx.r[11].s64 + -7548;
	// 82EC69B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC69B8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC69BC: 419A0094  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
	pc = 0x82EC6A50; continue 'dispatch;
	}
	// 82EC69C0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC69C4: 396BE398  addi r11, r11, -0x1c68
	ctx.r[11].s64 = ctx.r[11].s64 + -7272;
	// 82EC69C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC69CC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC69D0: 419A0080  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
	pc = 0x82EC6A50; continue 'dispatch;
	}
	// 82EC69D4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC69D8: 396BEE60  addi r11, r11, -0x11a0
	ctx.r[11].s64 = ctx.r[11].s64 + -4512;
	// 82EC69DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC69E0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC69E4: 419A006C  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
	pc = 0x82EC6A50; continue 'dispatch;
	}
	// 82EC69E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC69EC: 396BED4C  addi r11, r11, -0x12b4
	ctx.r[11].s64 = ctx.r[11].s64 + -4788;
	// 82EC69F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC69F4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC69F8: 419A0058  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
	pc = 0x82EC6A50; continue 'dispatch;
	}
	// 82EC69FC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC6A00: 396BEC38  addi r11, r11, -0x13c8
	ctx.r[11].s64 = ctx.r[11].s64 + -5064;
	// 82EC6A04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6A08: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC6A0C: 419A0044  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
	pc = 0x82EC6A50; continue 'dispatch;
	}
	// 82EC6A10: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC6A14: 396BEB24  addi r11, r11, -0x14dc
	ctx.r[11].s64 = ctx.r[11].s64 + -5340;
	// 82EC6A18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6A1C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC6A20: 419A0030  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
	pc = 0x82EC6A50; continue 'dispatch;
	}
	// 82EC6A24: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC6A28: 396BEA10  addi r11, r11, -0x15f0
	ctx.r[11].s64 = ctx.r[11].s64 + -5616;
	// 82EC6A2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6A30: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC6A34: 419A001C  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
	pc = 0x82EC6A50; continue 'dispatch;
	}
	// 82EC6A38: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC6A3C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC6A40: 396BE8FC  addi r11, r11, -0x1704
	ctx.r[11].s64 = ctx.r[11].s64 + -5892;
	// 82EC6A44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6A48: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC6A4C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x82EC6A50; continue 'dispatch;
            }
            0x82EC6A50 => {
    //   block [0x82EC6A50..0x82EC6A58)
	// 82EC6A50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC6A54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6A58 size=100
    let mut pc: u32 = 0x82EC6A58;
    'dispatch: loop {
        match pc {
            0x82EC6A58 => {
    //   block [0x82EC6A58..0x82EC6A98)
	// 82EC6A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6A5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6A60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6A64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6A68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6A6C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6A70: 396BB264  addi r11, r11, -0x4d9c
	ctx.r[11].s64 = ctx.r[11].s64 + -19868;
	// 82EC6A74: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC6A78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6A7C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC6A80: 41820018  beq 0x82ec6a98
	if ctx.cr[0].eq {
	pc = 0x82EC6A98; continue 'dispatch;
	}
	// 82EC6A84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6A88: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EC6A8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6A90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC6A94: 4E800421  bctrl
	ctx.lr = 0x82EC6A98;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC6A98 => {
    //   block [0x82EC6A98..0x82EC6ABC)
	// 82EC6A98: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82EC6A9C: 4BFF28E5  bl 0x82eb9380
	ctx.lr = 0x82EC6AA0;
	sub_82EB9380(ctx, base);
	// 82EC6AA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6AA4: 4BFBFC55  bl 0x82e866f8
	ctx.lr = 0x82EC6AA8;
	sub_82E866F8(ctx, base);
	// 82EC6AA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6AAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6AB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6AB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6AB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6AC0 size=120
    let mut pc: u32 = 0x82EC6AC0;
    'dispatch: loop {
        match pc {
            0x82EC6AC0 => {
    //   block [0x82EC6AC0..0x82EC6B00)
	// 82EC6AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6AC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6AC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC6ACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6AD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6AD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC6AD8: 807E006C  lwz r3, 0x6c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC6ADC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6AE0: 41820040  beq 0x82ec6b20
	if ctx.cr[0].eq {
	pc = 0x82EC6B20; continue 'dispatch;
	}
	// 82EC6AE4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6AE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EC6AEC: 816B00A4  lwz r11, 0xa4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC6AF0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC6AF4: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC6AF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC6AFC: 40990024  ble cr6, 0x82ec6b20
	if !ctx.cr[6].gt {
	pc = 0x82EC6B20; continue 'dispatch;
	}
	pc = 0x82EC6B00; continue 'dispatch;
            }
            0x82EC6B00 => {
    //   block [0x82EC6B00..0x82EC6B20)
	// 82EC6B00: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC6B04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC6B08: 4BFC25F1  bl 0x82e890f8
	ctx.lr = 0x82EC6B0C;
	sub_82E890F8(ctx, base);
	// 82EC6B0C: 807E006C  lwz r3, 0x6c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC6B10: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EC6B14: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC6B18: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC6B1C: 4198FFE4  blt cr6, 0x82ec6b00
	if ctx.cr[6].lt {
	pc = 0x82EC6B00; continue 'dispatch;
	}
	pc = 0x82EC6B20; continue 'dispatch;
            }
            0x82EC6B20 => {
    //   block [0x82EC6B20..0x82EC6B38)
	// 82EC6B20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC6B24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6B28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6B2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC6B30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6B34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6B38 size=88
    let mut pc: u32 = 0x82EC6B38;
    'dispatch: loop {
        match pc {
            0x82EC6B38 => {
    //   block [0x82EC6B38..0x82EC6B74)
	// 82EC6B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6B40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC6B44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6B48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6B4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6B50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC6B54: 4BFFFF05  bl 0x82ec6a58
	ctx.lr = 0x82EC6B58;
	sub_82EC6A58(ctx, base);
	// 82EC6B58: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6B5C: 41820018  beq 0x82ec6b74
	if ctx.cr[0].eq {
	pc = 0x82EC6B74; continue 'dispatch;
	}
	// 82EC6B60: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6B68: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC6B6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC6B70: 4E800421  bctrl
	ctx.lr = 0x82EC6B74;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC6B74 => {
    //   block [0x82EC6B74..0x82EC6B90)
	// 82EC6B74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6B78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC6B7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6B80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6B84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC6B88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6B8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6B90 size=120
    let mut pc: u32 = 0x82EC6B90;
    'dispatch: loop {
        match pc {
            0x82EC6B90 => {
    //   block [0x82EC6B90..0x82EC6BF8)
	// 82EC6B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6B94: 4BDE2879  bl 0x82ca940c
	ctx.lr = 0x82EC6B98;
	sub_82CA93D0(ctx, base);
	// 82EC6B98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6B9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6BA0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC6BA4: 4BFBFA35  bl 0x82e865d8
	ctx.lr = 0x82EC6BA8;
	sub_82E865D8(ctx, base);
	// 82EC6BA8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6BAC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EC6BB0: 396BB264  addi r11, r11, -0x4d9c
	ctx.r[11].s64 = ctx.r[11].s64 + -19868;
	// 82EC6BB4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC6BB8: 394AA8F0  addi r10, r10, -0x5710
	ctx.r[10].s64 = ctx.r[10].s64 + -22288;
	// 82EC6BBC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EC6BC0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC6BC4: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82EC6BC8: 915F0054  stw r10, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82EC6BCC: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82EC6BD0: 93DF0060  stw r30, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82EC6BD4: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EC6BD8: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EC6BDC: 83BD00AC  lwz r29, 0xac(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EC6BE0: 4B74FD49  bl 0x82616928
	ctx.lr = 0x82EC6BE4;
	sub_82616928(ctx, base);
	// 82EC6BE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6BE8: 41820010  beq 0x82ec6bf8
	if ctx.cr[0].eq {
	pc = 0x82EC6BF8; continue 'dispatch;
	}
	// 82EC6BEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC6BF0: 4BFC2379  bl 0x82e88f68
	ctx.lr = 0x82EC6BF4;
	sub_82E88F68(ctx, base);
	// 82EC6BF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	pc = 0x82EC6BF8; continue 'dispatch;
            }
            0x82EC6BF8 => {
    //   block [0x82EC6BF8..0x82EC6C08)
	// 82EC6BF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6BFC: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82EC6C00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC6C04: 4BDE2858  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6C08 size=204
    let mut pc: u32 = 0x82EC6C08;
    'dispatch: loop {
        match pc {
            0x82EC6C08 => {
    //   block [0x82EC6C08..0x82EC6CD4)
	// 82EC6C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6C0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6C10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6C14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6C18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6C1C: 4BFFFF75  bl 0x82ec6b90
	ctx.lr = 0x82EC6C20;
	sub_82EC6B90(ctx, base);
	// 82EC6C20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6C24: 395F0084  addi r10, r31, 0x84
	ctx.r[10].s64 = ctx.r[31].s64 + 132;
	// 82EC6C28: 38EBB298  addi r7, r11, -0x4d68
	ctx.r[7].s64 = ctx.r[11].s64 + -19816;
	// 82EC6C2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6C30: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC6C34: 38CBA8F0  addi r6, r11, -0x5710
	ctx.r[6].s64 = ctx.r[11].s64 + -22288;
	// 82EC6C38: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC6C3C: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EC6C40: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 82EC6C44: 390B9128  addi r8, r11, -0x6ed8
	ctx.r[8].s64 = ctx.r[11].s64 + -28376;
	// 82EC6C48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC6C4C: 393F00AC  addi r9, r31, 0xac
	ctx.r[9].s64 = ctx.r[31].s64 + 172;
	// 82EC6C50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6C54: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EC6C58: 90DF0074  stw r6, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[6].u32 ) };
	// 82EC6C5C: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EC6C60: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EC6C64: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EC6C68: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC6C6C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC6C70: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC6C74: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC6C78: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC6C7C: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EC6C80: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EC6C84: 98AA001C  stb r5, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[5].u8 ) };
	// 82EC6C88: 90EA0020  stw r7, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82EC6C8C: 916A0024  stw r11, 0x24(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EC6C90: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC6C94: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC6C98: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC6C9C: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC6CA0: 91690010  stw r11, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC6CA4: 91090014  stw r8, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EC6CA8: 91690018  stw r11, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EC6CAC: 98A9001C  stb r5, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[5].u8 ) };
	// 82EC6CB0: 90E90020  stw r7, 0x20(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82EC6CB4: 91690024  stw r11, 0x24(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EC6CB8: 93FF00A8  stw r31, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 82EC6CBC: 93FF00D0  stw r31, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 82EC6CC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6CC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6CC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6CCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6CD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6CD8 size=312
    let mut pc: u32 = 0x82EC6CD8;
    'dispatch: loop {
        match pc {
            0x82EC6CD8 => {
    //   block [0x82EC6CD8..0x82EC6D04)
	// 82EC6CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6CDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6CE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC6CE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6CE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6CEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC6CF0: 548B077F  clrlwi. r11, r4, 0x1d
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6CF4: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82EC6CF8: 4182000C  beq 0x82ec6d04
	if ctx.cr[0].eq {
	pc = 0x82EC6D04; continue 'dispatch;
	}
	// 82EC6CFC: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82EC6D00: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	pc = 0x82EC6D04; continue 'dispatch;
            }
            0x82EC6D04 => {
    //   block [0x82EC6D04..0x82EC6D24)
	// 82EC6D04: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC6D08: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82EC6D0C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82EC6D10: 409A0014  bne cr6, 0x82ec6d24
	if !ctx.cr[6].eq {
	pc = 0x82EC6D24; continue 'dispatch;
	}
	// 82EC6D14: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC6D18: 419A0038  beq cr6, 0x82ec6d50
	if ctx.cr[6].eq {
	pc = 0x82EC6D50; continue 'dispatch;
	}
	// 82EC6D1C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82EC6D20: 48000030  b 0x82ec6d50
	pc = 0x82EC6D50; continue 'dispatch;
            }
            0x82EC6D24 => {
    //   block [0x82EC6D24..0x82EC6D44)
	// 82EC6D24: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82EC6D28: 409A0028  bne cr6, 0x82ec6d50
	if !ctx.cr[6].eq {
	pc = 0x82EC6D50; continue 'dispatch;
	}
	// 82EC6D2C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC6D30: 40990020  ble cr6, 0x82ec6d50
	if !ctx.cr[6].gt {
	pc = 0x82EC6D50; continue 'dispatch;
	}
	// 82EC6D34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC6D38: 409A0010  bne cr6, 0x82ec6d48
	if !ctx.cr[6].eq {
	pc = 0x82EC6D48; continue 'dispatch;
	}
	// 82EC6D3C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EC6D40: 48000008  b 0x82ec6d48
	pc = 0x82EC6D48; continue 'dispatch;
            }
            0x82EC6D44 => {
    //   block [0x82EC6D44..0x82EC6D48)
	// 82EC6D44: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x82EC6D48; continue 'dispatch;
            }
            0x82EC6D48 => {
    //   block [0x82EC6D48..0x82EC6D50)
	// 82EC6D48: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC6D4C: 4198FFF8  blt cr6, 0x82ec6d44
	if ctx.cr[6].lt {
	pc = 0x82EC6D44; continue 'dispatch;
	}
	pc = 0x82EC6D50; continue 'dispatch;
            }
            0x82EC6D50 => {
    //   block [0x82EC6D50..0x82EC6D64)
	// 82EC6D50: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC6D54: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC6D58: 4099000C  ble cr6, 0x82ec6d64
	if !ctx.cr[6].gt {
	pc = 0x82EC6D64; continue 'dispatch;
	}
	// 82EC6D5C: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC6D60: 48000008  b 0x82ec6d68
	pc = 0x82EC6D68; continue 'dispatch;
            }
            0x82EC6D64 => {
    //   block [0x82EC6D64..0x82EC6D68)
	// 82EC6D64: 915E000C  stw r10, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC6D68; continue 'dispatch;
            }
            0x82EC6D68 => {
    //   block [0x82EC6D68..0x82EC6D7C)
	// 82EC6D68: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC6D6C: 419A0078  beq cr6, 0x82ec6de4
	if ctx.cr[6].eq {
	pc = 0x82EC6DE4; continue 'dispatch;
	}
	// 82EC6D70: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC6D74: 41980008  blt cr6, 0x82ec6d7c
	if ctx.cr[6].lt {
	pc = 0x82EC6D7C; continue 'dispatch;
	}
	// 82EC6D78: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	pc = 0x82EC6D7C; continue 'dispatch;
            }
            0x82EC6D7C => {
    //   block [0x82EC6D7C..0x82EC6DAC)
	// 82EC6D7C: 5563E8FE  srwi r3, r11, 3
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shr(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EC6D80: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC6D84: 4B74FBA5  bl 0x82616928
	ctx.lr = 0x82EC6D88;
	sub_82616928(ctx, base);
	// 82EC6D88: 57EB077E  clrlwi r11, r31, 0x1d
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000007u64;
	// 82EC6D8C: 57E9E8FE  srwi r9, r31, 3
	ctx.r[9].u32 = ctx.r[31].u32.wrapping_shr(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EC6D90: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC6D94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6D98: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EC6D9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC6DA0: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	// 82EC6DA4: 7D4A4A15  add. r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC6DA8: 4182001C  beq 0x82ec6dc4
	if ctx.cr[0].eq {
	pc = 0x82EC6DC4; continue 'dispatch;
	}
	pc = 0x82EC6DAC; continue 'dispatch;
            }
            0x82EC6DAC => {
    //   block [0x82EC6DAC..0x82EC6DC4)
	// 82EC6DAC: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6DB0: 7D2958AE  lbzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC6DB4: 7D2BF9AE  stbx r9, r11, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[9].u8) };
	// 82EC6DB8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC6DBC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC6DC0: 4198FFEC  blt cr6, 0x82ec6dac
	if ctx.cr[6].lt {
	pc = 0x82EC6DAC; continue 'dispatch;
	}
	pc = 0x82EC6DC4; continue 'dispatch;
            }
            0x82EC6DC4 => {
    //   block [0x82EC6DC4..0x82EC6DE0)
	// 82EC6DC4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6DC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6DCC: 41820014  beq 0x82ec6de0
	if ctx.cr[0].eq {
	pc = 0x82EC6DE0; continue 'dispatch;
	}
	// 82EC6DD0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6DD4: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC6DD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC6DDC: 4E800421  bctrl
	ctx.lr = 0x82EC6DE0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC6DE0 => {
    //   block [0x82EC6DE0..0x82EC6DE4)
	// 82EC6DE0: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82EC6DE4; continue 'dispatch;
            }
            0x82EC6DE4 => {
    //   block [0x82EC6DE4..0x82EC6E10)
	// 82EC6DE4: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC6DE8: 556AE8FE  srwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC6DEC: 556B077E  clrlwi r11, r11, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 82EC6DF0: 915E0010  stw r10, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EC6DF4: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EC6DF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC6DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6E04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC6E08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6E0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6E10 size=172
    let mut pc: u32 = 0x82EC6E10;
    'dispatch: loop {
        match pc {
            0x82EC6E10 => {
    //   block [0x82EC6E10..0x82EC6E3C)
	// 82EC6E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6E14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6E18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC6E1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6E20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6E24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6E28: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC6E2C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6E30: 4182000C  beq 0x82ec6e3c
	if ctx.cr[0].eq {
	pc = 0x82EC6E3C; continue 'dispatch;
	}
	// 82EC6E34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC6E38: 4800006C  b 0x82ec6ea4
	pc = 0x82EC6EA4; continue 'dispatch;
            }
            0x82EC6E3C => {
    //   block [0x82EC6E3C..0x82EC6E54)
	// 82EC6E3C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC6E40: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC6E44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC6E48: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EC6E4C: 40990030  ble cr6, 0x82ec6e7c
	if !ctx.cr[6].gt {
	pc = 0x82EC6E7C; continue 'dispatch;
	}
	// 82EC6E50: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	pc = 0x82EC6E54; continue 'dispatch;
            }
            0x82EC6E54 => {
    //   block [0x82EC6E54..0x82EC6E7C)
	// 82EC6E54: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6E58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6E5C: 811F0070  lwz r8, 0x70(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC6E60: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EC6E64: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC6E68: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EC6E6C: 913F0070  stw r9, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82EC6E70: 813F0080  lwz r9, 0x80(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC6E74: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC6E78: 4198FFDC  blt cr6, 0x82ec6e54
	if ctx.cr[6].lt {
	pc = 0x82EC6E54; continue 'dispatch;
	}
	pc = 0x82EC6E7C; continue 'dispatch;
            }
            0x82EC6E7C => {
    //   block [0x82EC6E7C..0x82EC6EA4)
	// 82EC6E7C: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC6E80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC6E84: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82EC6E88: 7FCB21D6  mullw r30, r11, r4
	ctx.r[30].s32 = ((ctx.r[11].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[30].s64 = ctx.r[30].s32 as i64;
	// 82EC6E8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC6E90: 4BFFFE49  bl 0x82ec6cd8
	ctx.lr = 0x82EC6E94;
	sub_82EC6CD8(ctx, base);
	// 82EC6E94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC6E98: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC6E9C: 4BFC214D  bl 0x82e88fe8
	ctx.lr = 0x82EC6EA0;
	sub_82E88FE8(ctx, base);
	// 82EC6EA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82EC6EA4; continue 'dispatch;
            }
            0x82EC6EA4 => {
    //   block [0x82EC6EA4..0x82EC6EBC)
	// 82EC6EA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC6EA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6EAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6EB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC6EB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6EB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC6EC0 size=68
    let mut pc: u32 = 0x82EC6EC0;
    'dispatch: loop {
        match pc {
            0x82EC6EC0 => {
    //   block [0x82EC6EC0..0x82EC6EE0)
	// 82EC6EC0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC6EC4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC6EC8: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC6ECC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6ED0: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC6ED4: 80EA0014  lwz r7, 0x14(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC6ED8: 41820024  beq 0x82ec6efc
	if ctx.cr[0].eq {
	pc = 0x82EC6EFC; continue 'dispatch;
	}
	// 82EC6EDC: 81430078  lwz r10, 0x78(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	pc = 0x82EC6EE0; continue 'dispatch;
            }
            0x82EC6EE0 => {
    //   block [0x82EC6EE0..0x82EC6EFC)
	// 82EC6EE0: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6EE4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6EE8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC6EEC: 81080008  lwz r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC6EF0: 81080014  lwz r8, 0x14(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC6EF4: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82EC6EF8: 4082FFE8  bne 0x82ec6ee0
	if !ctx.cr[0].eq {
	pc = 0x82EC6EE0; continue 'dispatch;
	}
	pc = 0x82EC6EFC; continue 'dispatch;
            }
            0x82EC6EFC => {
    //   block [0x82EC6EFC..0x82EC6F04)
	// 82EC6EFC: 7C6939D6  mullw r3, r9, r7
	ctx.r[3].s32 = ((ctx.r[9].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82EC6F00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6F08 size=224
    let mut pc: u32 = 0x82EC6F08;
    'dispatch: loop {
        match pc {
            0x82EC6F08 => {
    //   block [0x82EC6F08..0x82EC6FAC)
	// 82EC6F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6F0C: 4BDE24F9  bl 0x82ca9404
	ctx.lr = 0x82EC6F10;
	sub_82CA93D0(ctx, base);
	// 82EC6F10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6F14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6F18: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82EC6F1C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EC6F20: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82EC6F24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC6F28: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EC6F2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC6F30: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82EC6F34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC6F38: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82EC6F3C: 4B40C41D  bl 0x822d3358
	ctx.lr = 0x82EC6F40;
	sub_822D3358(ctx, base);
	// 82EC6F40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6F44: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EC6F48: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EC6F4C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC6F50: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EC6F54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6F58: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EC6F5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC6F60: 4E800421  bctrl
	ctx.lr = 0x82EC6F64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC6F64: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EC6F68: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6F6C: 41820070  beq 0x82ec6fdc
	if ctx.cr[0].eq {
	pc = 0x82EC6FDC; continue 'dispatch;
	}
	// 82EC6F70: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6F74: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6F78: 41820064  beq 0x82ec6fdc
	if ctx.cr[0].eq {
	pc = 0x82EC6FDC; continue 'dispatch;
	}
	// 82EC6F7C: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC6F80: 57C9077E  clrlwi r9, r30, 0x1d
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000007u64;
	// 82EC6F84: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EC6F88: 57CBE8FE  srwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shr(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC6F8C: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6F90: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EC6F94: 41820018  beq 0x82ec6fac
	if ctx.cr[0].eq {
	pc = 0x82EC6FAC; continue 'dispatch;
	}
	// 82EC6F98: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EC6F9C: 7CEB50AE  lbzx r7, r11, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EC6FA0: 7D094830  slw r9, r8, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[8].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 82EC6FA4: 7D293B78  or r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[7].u64;
	// 82EC6FA8: 48000014  b 0x82ec6fbc
	pc = 0x82EC6FBC; continue 'dispatch;
            }
            0x82EC6FAC => {
    //   block [0x82EC6FAC..0x82EC6FBC)
	// 82EC6FAC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EC6FB0: 7D0B50AE  lbzx r8, r11, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EC6FB4: 7CE94830  slw r9, r7, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[7].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 82EC6FB8: 7D094878  andc r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 & !ctx.r[9].u64;
	pc = 0x82EC6FBC; continue 'dispatch;
            }
            0x82EC6FBC => {
    //   block [0x82EC6FBC..0x82EC6FDC)
	// 82EC6FBC: 7D2B51AE  stbx r9, r11, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u8) };
	// 82EC6FC0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EC6FC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6FC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC6FCC: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC6FD0: 816B00A8  lwz r11, 0xa8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EC6FD4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC6FD8: 4BFC2121  bl 0x82e890f8
	ctx.lr = 0x82EC6FDC;
	sub_82E890F8(ctx, base);
	pc = 0x82EC6FDC; continue 'dispatch;
            }
            0x82EC6FDC => {
    //   block [0x82EC6FDC..0x82EC6FE8)
	// 82EC6FDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EC6FE0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC6FE4: 4BDE2470  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC6FE8 size=168
    let mut pc: u32 = 0x82EC6FE8;
    'dispatch: loop {
        match pc {
            0x82EC6FE8 => {
    //   block [0x82EC6FE8..0x82EC701C)
	// 82EC6FE8: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EC6FEC: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC6FF0: 41990098  bgt cr6, 0x82ec7088
	if ctx.cr[6].gt {
	pc = 0x82EC7088; continue 'dispatch;
	}
	// 82EC6FF4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC6FF8: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC6FFC: 0CCB0000  twi 6, r11, 0
	// 82EC7000: 7D645B96  divwu r11, r4, r11
	ctx.r[11].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 82EC7004: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7008: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC700C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC7010: 4198000C  blt cr6, 0x82ec701c
	if ctx.cr[6].lt {
	pc = 0x82EC701C; continue 'dispatch;
	}
	// 82EC7014: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC7018: 48000010  b 0x82ec7028
	pc = 0x82EC7028; continue 'dispatch;
            }
            0x82EC701C => {
    //   block [0x82EC701C..0x82EC7028)
	// 82EC701C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7020: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC7024: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x82EC7028; continue 'dispatch;
            }
            0x82EC7028 => {
    //   block [0x82EC7028..0x82EC7060)
	// 82EC7028: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC702C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7030: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC7034: 41820054  beq 0x82ec7088
	if ctx.cr[0].eq {
	pc = 0x82EC7088; continue 'dispatch;
	}
	// 82EC7038: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC703C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC7040: 80A30080  lwz r5, 0x80(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC7044: 7D445B96  divwu r10, r4, r11
	ctx.r[10].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 82EC7048: 0CCB0000  twi 6, r11, 0
	// 82EC704C: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC7050: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82EC7054: 28050000  cmplwi r5, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7058: 41820030  beq 0x82ec7088
	if ctx.cr[0].eq {
	pc = 0x82EC7088; continue 'dispatch;
	}
	// 82EC705C: 81430078  lwz r10, 0x78(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	pc = 0x82EC7060; continue 'dispatch;
            }
            0x82EC7060 => {
    //   block [0x82EC7060..0x82EC7088)
	// 82EC7060: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC7064: 81070008  lwz r8, 8(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7068: 81080018  lwz r8, 0x18(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC706C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EC7070: 41980020  blt cr6, 0x82ec7090
	if ctx.cr[6].lt {
		sub_82EC7090(ctx, base);
		return;
	}
	// 82EC7074: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC7078: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82EC707C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC7080: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EC7084: 4198FFDC  blt cr6, 0x82ec7060
	if ctx.cr[6].lt {
	pc = 0x82EC7060; continue 'dispatch;
	}
	pc = 0x82EC7088; continue 'dispatch;
            }
            0x82EC7088 => {
    //   block [0x82EC7088..0x82EC7090)
	// 82EC7088: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC708C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC7090 size=60
    let mut pc: u32 = 0x82EC7090;
    'dispatch: loop {
        match pc {
            0x82EC7090 => {
    //   block [0x82EC7090..0x82EC70A8)
	// 82EC7090: 81470008  lwz r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7094: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC7098: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC709C: 4198000C  blt cr6, 0x82ec70a8
	if ctx.cr[6].lt {
	pc = 0x82EC70A8; continue 'dispatch;
	}
	// 82EC70A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC70A4: 48000010  b 0x82ec70b4
	pc = 0x82EC70B4; continue 'dispatch;
            }
            0x82EC70A8 => {
    //   block [0x82EC70A8..0x82EC70B4)
	// 82EC70A8: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC70AC: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC70B0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x82EC70B4; continue 'dispatch;
            }
            0x82EC70B4 => {
    //   block [0x82EC70B4..0x82EC70CC)
	// 82EC70B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC70B8: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC70BC: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82EC70C0: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC70C4: 69430001  xori r3, r10, 1
	ctx.r[3].u64 = ctx.r[10].u64 ^ 1;
	// 82EC70C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC70D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC70D0 size=216
    let mut pc: u32 = 0x82EC70D0;
    'dispatch: loop {
        match pc {
            0x82EC70D0 => {
    //   block [0x82EC70D0..0x82EC7148)
	// 82EC70D0: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC70D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC70D8: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
	// 82EC70DC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC70E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC70E4: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82EC70E8: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC70EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC70F0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EC70F4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC70F8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC70FC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EC7100: 4182009C  beq 0x82ec719c
	if ctx.cr[0].eq {
	pc = 0x82EC719C; continue 'dispatch;
	}
	// 82EC7104: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC7108: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82EC710C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC7110: 394B0074  addi r10, r11, 0x74
	ctx.r[10].s64 = ctx.r[11].s64 + 116;
	// 82EC7114: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7118: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC711C: 80C60008  lwz r6, 8(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7120: 80C60004  lwz r6, 4(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7124: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82EC7128: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 82EC712C: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EC7130: 7D293B96  divwu r9, r9, r7
	ctx.r[9].u32 = ctx.r[9].u32 / ctx.r[7].u32;
	// 82EC7134: 7D6959D6  mullw r11, r9, r11
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC7138: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC713C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC7144: 40990058  ble cr6, 0x82ec719c
	if !ctx.cr[6].gt {
	pc = 0x82EC719C; continue 'dispatch;
	}
	pc = 0x82EC7148; continue 'dispatch;
            }
            0x82EC7148 => {
    //   block [0x82EC7148..0x82EC719C)
	// 82EC7148: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC714C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7150: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC7154: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC7158: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC715C: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7160: 91030018  stw r8, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82EC7164: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EC7168: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EC716C: 409A003C  bne cr6, 0x82ec71a8
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82EC71A8);
		return;
	}
	// 82EC7170: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC7174: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7178: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC717C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EC7180: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC7184: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EC7188: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC718C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC7190: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7194: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC7198: 4198FFB0  blt cr6, 0x82ec7148
	if ctx.cr[6].lt {
	pc = 0x82EC7148; continue 'dispatch;
	}
	pc = 0x82EC719C; continue 'dispatch;
            }
            0x82EC719C => {
    //   block [0x82EC719C..0x82EC71A8)
	// 82EC719C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC71A0: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EC71A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC71D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC71D0 size=128
    let mut pc: u32 = 0x82EC71D0;
    'dispatch: loop {
        match pc {
            0x82EC71D0 => {
    //   block [0x82EC71D0..0x82EC7250)
	// 82EC71D0: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC71D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC71D8: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
	// 82EC71DC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC71E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC71E4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EC71E8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC71EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC71F0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EC71F4: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC71F8: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC71FC: 396B0074  addi r11, r11, 0x74
	ctx.r[11].s64 = ctx.r[11].s64 + 116;
	// 82EC7200: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7204: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EC7208: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC720C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7210: 41820040  beq 0x82ec7250
	if ctx.cr[0].eq {
		sub_82EC7250(ctx, base);
		return;
	}
	// 82EC7214: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7218: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82EC721C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7220: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EC7224: 81030010  lwz r8, 0x10(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC7228: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC722C: 7D66582E  lwzx r11, r6, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC7230: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7234: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7238: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC723C: 7D6B3B96  divwu r11, r11, r7
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[7].u32;
	// 82EC7240: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82EC7244: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EC7248: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EC724C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC7250 size=292
    let mut pc: u32 = 0x82EC7250;
    'dispatch: loop {
        match pc {
            0x82EC7250 => {
    //   block [0x82EC7250..0x82EC7260)
	// 82EC7250: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7254: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC7258: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC725C: 48000058  b 0x82ec72b4
	pc = 0x82EC72B4; continue 'dispatch;
            }
            0x82EC7260 => {
    //   block [0x82EC7260..0x82EC72B4)
	// 82EC7260: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7264: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7268: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC726C: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7270: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EC7274: 8129FFFC  lwz r9, -4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EC7278: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC727C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EC7280: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EC7284: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7288: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC728C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7290: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7294: 91230018  stw r9, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EC7298: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EC729C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EC72A0: 409A00D4  bne cr6, 0x82ec7374
	if !ctx.cr[6].eq {
		sub_82EC7374(ctx, base);
		return;
	}
	// 82EC72A4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC72A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC72AC: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC72B0: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x82EC72B4; continue 'dispatch;
            }
            0x82EC72B4 => {
    //   block [0x82EC72B4..0x82EC7314)
	// 82EC72B4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC72B8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC72BC: 4198FFA4  blt cr6, 0x82ec7260
	if ctx.cr[6].lt {
	pc = 0x82EC7260; continue 'dispatch;
	}
	// 82EC72C0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC72C4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC72C8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC72CC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EC72D0: 41820098  beq 0x82ec7368
	if ctx.cr[0].eq {
	pc = 0x82EC7368; continue 'dispatch;
	}
	// 82EC72D4: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC72D8: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82EC72DC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC72E0: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC72E4: 814A0070  lwz r10, 0x70(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC72E8: 80C60008  lwz r6, 8(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC72EC: 80C60004  lwz r6, 4(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC72F0: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82EC72F4: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 82EC72F8: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EC72FC: 7D293B96  divwu r9, r9, r7
	ctx.r[9].u32 = ctx.r[9].u32 / ctx.r[7].u32;
	// 82EC7300: 7D4951D6  mullw r10, r9, r10
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EC7304: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EC7308: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC730C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC7310: 40990058  ble cr6, 0x82ec7368
	if !ctx.cr[6].gt {
	pc = 0x82EC7368; continue 'dispatch;
	}
	pc = 0x82EC7314; continue 'dispatch;
            }
            0x82EC7314 => {
    //   block [0x82EC7314..0x82EC7368)
	// 82EC7314: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7318: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC731C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC7320: 7D2A482E  lwzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC7324: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7328: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC732C: 91030018  stw r8, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82EC7330: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EC7334: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EC7338: 409A0064  bne cr6, 0x82ec739c
	if !ctx.cr[6].eq {
		sub_82EC739C(ctx, base);
		return;
	}
	// 82EC733C: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC7340: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7344: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7348: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EC734C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC7350: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EC7354: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC7358: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC735C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7360: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC7364: 4198FFB0  blt cr6, 0x82ec7314
	if ctx.cr[6].lt {
	pc = 0x82EC7314; continue 'dispatch;
	}
	pc = 0x82EC7368; continue 'dispatch;
            }
            0x82EC7368 => {
    //   block [0x82EC7368..0x82EC7374)
	// 82EC7368: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC736C: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EC7370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7374(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC7374 size=40
    let mut pc: u32 = 0x82EC7374;
    'dispatch: loop {
        match pc {
            0x82EC7374 => {
    //   block [0x82EC7374..0x82EC739C)
	// 82EC7374: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7378: 39000014  li r8, 0x14
	ctx.r[8].s64 = 20;
	// 82EC737C: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC7380: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC7384: 7D6B4396  divwu r11, r11, r8
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[8].u32;
	// 82EC7388: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC738C: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7390: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EC7394: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC7398: 4BFFFEB0  b 0x82ec7248
	sub_82EC71D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC739C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC739C size=20
    let mut pc: u32 = 0x82EC739C;
    'dispatch: loop {
        match pc {
            0x82EC739C => {
    //   block [0x82EC739C..0x82EC73B0)
	// 82EC739C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC73A0: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC73A4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC73A8: 7D6B3B96  divwu r11, r11, r7
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[7].u32;
	// 82EC73AC: 4BFFFFDC  b 0x82ec7388
	sub_82EC7374(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC73B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC73B0 size=60
    let mut pc: u32 = 0x82EC73B0;
    'dispatch: loop {
        match pc {
            0x82EC73B0 => {
    //   block [0x82EC73B0..0x82EC73EC)
	// 82EC73B0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC73B4: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC73B8: 90E30008  stw r7, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82EC73BC: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82EC73C0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC73C4: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC73C8: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC73CC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC73D0: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EC73D4: 40820018  bne 0x82ec73ec
	if !ctx.cr[0].eq {
		sub_82EC73EC(ctx, base);
		return;
	}
	// 82EC73D8: 90E30020  stw r7, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82EC73DC: 90E30018  stw r7, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 82EC73E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC73E4: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EC73E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC73EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC73EC size=208
    let mut pc: u32 = 0x82EC73EC;
    'dispatch: loop {
        match pc {
            0x82EC73EC => {
    //   block [0x82EC73EC..0x82EC7424)
	// 82EC73EC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC73F0: 39000014  li r8, 0x14
	ctx.r[8].s64 = 20;
	// 82EC73F4: 80C30004  lwz r6, 4(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC73F8: 392B0074  addi r9, r11, 0x74
	ctx.r[9].s64 = ctx.r[11].s64 + 116;
	// 82EC73FC: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC7400: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7404: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7408: 7D4A3050  subf r10, r10, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82EC740C: 7D4A4396  divwu r10, r10, r8
	ctx.r[10].u32 = ctx.r[10].u32 / ctx.r[8].u32;
	// 82EC7410: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC7414: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC7418: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC741C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC7420: 40990088  ble cr6, 0x82ec74a8
	if !ctx.cr[6].gt {
	pc = 0x82EC74A8; continue 'dispatch;
	}
	pc = 0x82EC7424; continue 'dispatch;
            }
            0x82EC7424 => {
    //   block [0x82EC7424..0x82EC7464)
	// 82EC7424: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7428: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC742C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC7430: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EC7434: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7438: 4182002C  beq 0x82ec7464
	if ctx.cr[0].eq {
	pc = 0x82EC7464; continue 'dispatch;
	}
	// 82EC743C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7440: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7444: 90C30018  stw r6, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 82EC7448: 54C6003E  slwi r6, r6, 0
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EC744C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EC7450: 409A0034  bne cr6, 0x82ec7484
	if !ctx.cr[6].eq {
	pc = 0x82EC7484; continue 'dispatch;
	}
	// 82EC7454: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC7458: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC745C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC7460: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC7464; continue 'dispatch;
            }
            0x82EC7464 => {
    //   block [0x82EC7464..0x82EC7484)
	// 82EC7464: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7468: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC746C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC7470: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC7474: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7478: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC747C: 4198FFA8  blt cr6, 0x82ec7424
	if ctx.cr[6].lt {
	pc = 0x82EC7424; continue 'dispatch;
	}
	// 82EC7480: 48000028  b 0x82ec74a8
	pc = 0x82EC74A8; continue 'dispatch;
            }
            0x82EC7484 => {
    //   block [0x82EC7484..0x82EC74A8)
	// 82EC7484: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7488: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC748C: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC7490: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC7494: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7498: 7D6B4396  divwu r11, r11, r8
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[8].u32;
	// 82EC749C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EC74A0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC74A4: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC74A8; continue 'dispatch;
            }
            0x82EC74A8 => {
    //   block [0x82EC74A8..0x82EC74BC)
	// 82EC74A8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC74AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC74B0: 419AFF30  beq cr6, 0x82ec73e0
	if ctx.cr[6].eq {
		sub_82EC73B0(ctx, base);
		return;
	}
	// 82EC74B4: 98E3001C  stb r7, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[7].u8 ) };
	// 82EC74B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC74C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC74C0 size=556
    let mut pc: u32 = 0x82EC74C0;
    'dispatch: loop {
        match pc {
            0x82EC74C0 => {
    //   block [0x82EC74C0..0x82EC74F0)
	// 82EC74C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC74C4: 4BDE1F2D  bl 0x82ca93f0
	ctx.lr = 0x82EC74C8;
	sub_82CA93D0(ctx, base);
	// 82EC74C8: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82EC74CC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC74D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC74D4: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82EC74D8: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC74DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC74E0: 408201FC  bne 0x82ec76dc
	if !ctx.cr[0].eq {
	pc = 0x82EC76DC; continue 'dispatch;
	}
	// 82EC74E4: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC74E8: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC74EC: 48000028  b 0x82ec7514
	pc = 0x82EC7514; continue 'dispatch;
            }
            0x82EC74F0 => {
    //   block [0x82EC74F0..0x82EC7514)
	// 82EC74F0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC74F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC74F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC74FC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC7500: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC7504: 4E800421  bctrl
	ctx.lr = 0x82EC7508;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC7508: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC750C: 408201D0  bne 0x82ec76dc
	if !ctx.cr[0].eq {
	pc = 0x82EC76DC; continue 'dispatch;
	}
	// 82EC7510: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
            }
            0x82EC7514 => {
    //   block [0x82EC7514..0x82EC7544)
	// 82EC7514: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7518: 4082FFD8  bne 0x82ec74f0
	if !ctx.cr[0].eq {
	pc = 0x82EC74F0; continue 'dispatch;
	}
	// 82EC751C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7520: 808300A8  lwz r4, 0xa8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EC7524: 4BFBFE2D  bl 0x82e87350
	ctx.lr = 0x82EC7528;
	sub_82E87350(ctx, base);
	// 82EC7528: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EC752C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EC7530: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC7534: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7538: 4082000C  bne 0x82ec7544
	if !ctx.cr[0].eq {
	pc = 0x82EC7544; continue 'dispatch;
	}
	// 82EC753C: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 82EC7540: 4BFFFE71  bl 0x82ec73b0
	ctx.lr = 0x82EC7544;
	sub_82EC73B0(ctx, base);
	pc = 0x82EC7544; continue 'dispatch;
            }
            0x82EC7544 => {
    //   block [0x82EC7544..0x82EC7550)
	// 82EC7544: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7548: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82EC754C: 82EB00A4  lwz r23, 0xa4(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	pc = 0x82EC7550; continue 'dispatch;
            }
            0x82EC7550 => {
    //   block [0x82EC7550..0x82EC7554)
	// 82EC7550: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	pc = 0x82EC7554; continue 'dispatch;
            }
            0x82EC7554 => {
    //   block [0x82EC7554..0x82EC75A4)
	// 82EC7554: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EC7558: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC755C: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7560: 4182017C  beq 0x82ec76dc
	if ctx.cr[0].eq {
	pc = 0x82EC76DC; continue 'dispatch;
	}
	// 82EC7564: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC7568: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC756C: 41820168  beq 0x82ec76d4
	if ctx.cr[0].eq {
	pc = 0x82EC76D4; continue 'dispatch;
	}
	// 82EC7570: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC7574: 3B5F0084  addi r26, r31, 0x84
	ctx.r[26].s64 = ctx.r[31].s64 + 132;
	// 82EC7578: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EC757C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EC7580: 91760000  stw r11, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC7584: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7588: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC758C: 41820018  beq 0x82ec75a4
	if ctx.cr[0].eq {
	pc = 0x82EC75A4; continue 'dispatch;
	}
	// 82EC7590: 815A0018  lwz r10, 0x18(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC7594: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7598: 4182000C  beq 0x82ec75a4
	if ctx.cr[0].eq {
	pc = 0x82EC75A4; continue 'dispatch;
	}
	// 82EC759C: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC75A0: 836A0004  lwz r27, 4(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82EC75A4; continue 'dispatch;
            }
            0x82EC75A4 => {
    //   block [0x82EC75A4..0x82EC75BC)
	// 82EC75A4: 7F18E840  cmplw cr6, r24, r29
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82EC75A8: 419A0054  beq cr6, 0x82ec75fc
	if ctx.cr[6].eq {
	pc = 0x82EC75FC; continue 'dispatch;
	}
	// 82EC75AC: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC75B0: 7FB8EB78  mr r24, r29
	ctx.r[24].u64 = ctx.r[29].u64;
	// 82EC75B4: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC75B8: 4800002C  b 0x82ec75e4
	pc = 0x82EC75E4; continue 'dispatch;
            }
            0x82EC75BC => {
    //   block [0x82EC75BC..0x82EC75E4)
	// 82EC75BC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC75C0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC75C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC75C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC75CC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC75D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC75D4: 4E800421  bctrl
	ctx.lr = 0x82EC75D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC75D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC75DC: 40820014  bne 0x82ec75f0
	if !ctx.cr[0].eq {
	pc = 0x82EC75F0; continue 'dispatch;
	}
	// 82EC75E0: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
            }
            0x82EC75E4 => {
    //   block [0x82EC75E4..0x82EC75F0)
	// 82EC75E4: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC75E8: 4082FFD4  bne 0x82ec75bc
	if !ctx.cr[0].eq {
	pc = 0x82EC75BC; continue 'dispatch;
	}
	// 82EC75EC: 48000008  b 0x82ec75f4
	pc = 0x82EC75F4; continue 'dispatch;
            }
            0x82EC75F0 => {
    //   block [0x82EC75F0..0x82EC75F4)
	// 82EC75F0: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	pc = 0x82EC75F4; continue 'dispatch;
            }
            0x82EC75F4 => {
    //   block [0x82EC75F4..0x82EC75FC)
	// 82EC75F4: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC75F8: 408200B8  bne 0x82ec76b0
	if !ctx.cr[0].eq {
	pc = 0x82EC76B0; continue 'dispatch;
	}
	pc = 0x82EC75FC; continue 'dispatch;
            }
            0x82EC75FC => {
    //   block [0x82EC75FC..0x82EC760C)
	// 82EC75FC: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC7600: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC7604: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7608: 48000030  b 0x82ec7638
	pc = 0x82EC7638; continue 'dispatch;
            }
            0x82EC760C => {
    //   block [0x82EC760C..0x82EC7638)
	// 82EC760C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7610: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82EC7614: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC7618: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC761C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC7620: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC7624: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC7628: 4E800421  bctrl
	ctx.lr = 0x82EC762C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC762C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7630: 40820014  bne 0x82ec7644
	if !ctx.cr[0].eq {
	pc = 0x82EC7644; continue 'dispatch;
	}
	// 82EC7634: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
            }
            0x82EC7638 => {
    //   block [0x82EC7638..0x82EC7644)
	// 82EC7638: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC763C: 4082FFD0  bne 0x82ec760c
	if !ctx.cr[0].eq {
	pc = 0x82EC760C; continue 'dispatch;
	}
	// 82EC7640: 48000008  b 0x82ec7648
	pc = 0x82EC7648; continue 'dispatch;
            }
            0x82EC7644 => {
    //   block [0x82EC7644..0x82EC7648)
	// 82EC7644: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x82EC7648; continue 'dispatch;
            }
            0x82EC7648 => {
    //   block [0x82EC7648..0x82EC7684)
	// 82EC7648: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC764C: 40820064  bne 0x82ec76b0
	if !ctx.cr[0].eq {
	pc = 0x82EC76B0; continue 'dispatch;
	}
	// 82EC7650: 83DF00A4  lwz r30, 0xa4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC7654: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC7658: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC765C: 4BFC1A25  bl 0x82e89080
	ctx.lr = 0x82EC7660;
	sub_82E89080(ctx, base);
	// 82EC7660: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC7664: 7F04B840  cmplw cr6, r4, r23
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82EC7668: 419A001C  beq cr6, 0x82ec7684
	if ctx.cr[6].eq {
	pc = 0x82EC7684; continue 'dispatch;
	}
	// 82EC766C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7670: 4BFBFCE1  bl 0x82e87350
	ctx.lr = 0x82EC7674;
	sub_82E87350(ctx, base);
	// 82EC7674: EDBF0828  fsubs f13, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC7678: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC767C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC7680: 41980030  blt cr6, 0x82ec76b0
	if ctx.cr[6].lt {
	pc = 0x82EC76B0; continue 'dispatch;
	}
	pc = 0x82EC7684; continue 'dispatch;
            }
            0x82EC7684 => {
    //   block [0x82EC7684..0x82EC76B0)
	// 82EC7684: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC7688: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EC768C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EC7690: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC7694: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC7698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC769C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82EC76A0: 4BFFF869  bl 0x82ec6f08
	ctx.lr = 0x82EC76A4;
	sub_82EC6F08(ctx, base);
	// 82EC76A4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC76A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC76AC: 41820028  beq 0x82ec76d4
	if ctx.cr[0].eq {
	pc = 0x82EC76D4; continue 'dispatch;
	}
	pc = 0x82EC76B0; continue 'dispatch;
            }
            0x82EC76B0 => {
    //   block [0x82EC76B0..0x82EC76C8)
	// 82EC76B0: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC76B4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EC76B8: 41820010  beq 0x82ec76c8
	if ctx.cr[0].eq {
	pc = 0x82EC76C8; continue 'dispatch;
	}
	// 82EC76BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC76C0: 4BFFFA11  bl 0x82ec70d0
	ctx.lr = 0x82EC76C4;
	sub_82EC70D0(ctx, base);
	// 82EC76C4: 4BFFFE8C  b 0x82ec7550
	pc = 0x82EC7550; continue 'dispatch;
            }
            0x82EC76C8 => {
    //   block [0x82EC76C8..0x82EC76D4)
	// 82EC76C8: 4BFFFB09  bl 0x82ec71d0
	ctx.lr = 0x82EC76CC;
	sub_82EC71D0(ctx, base);
	// 82EC76CC: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EC76D0: 4BFFFE84  b 0x82ec7554
	pc = 0x82EC7554; continue 'dispatch;
            }
            0x82EC76D4 => {
    //   block [0x82EC76D4..0x82EC76DC)
	// 82EC76D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC76D8: 48000008  b 0x82ec76e0
	pc = 0x82EC76E0; continue 'dispatch;
            }
            0x82EC76DC => {
    //   block [0x82EC76DC..0x82EC76E0)
	// 82EC76DC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC76E0; continue 'dispatch;
            }
            0x82EC76E0 => {
    //   block [0x82EC76E0..0x82EC76EC)
	// 82EC76E0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EC76E4: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82EC76E8: 4BDE1D58  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC76F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC76F0 size=108
    let mut pc: u32 = 0x82EC76F0;
    'dispatch: loop {
        match pc {
            0x82EC76F0 => {
    //   block [0x82EC76F0..0x82EC773C)
	// 82EC76F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC76F4: 4BDE1D19  bl 0x82ca940c
	ctx.lr = 0x82EC76F8;
	sub_82CA93D0(ctx, base);
	// 82EC76F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC76FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC7700: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC7704: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EC7708: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EC770C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC7710: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EC7714: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82EC7718: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC771C: 915F004C  stw r10, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 82EC7720: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC7724: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC7728: 4BFFF8C1  bl 0x82ec6fe8
	ctx.lr = 0x82EC772C;
	sub_82EC6FE8(ctx, base);
	// 82EC772C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7730: 4082000C  bne 0x82ec773c
	if !ctx.cr[0].eq {
	pc = 0x82EC773C; continue 'dispatch;
	}
	// 82EC7734: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC7738: 4800001C  b 0x82ec7754
	pc = 0x82EC7754; continue 'dispatch;
            }
            0x82EC773C => {
    //   block [0x82EC773C..0x82EC7754)
	// 82EC773C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EC7740: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC7744: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EC7748: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC774C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7750: 4BFFF7B9  bl 0x82ec6f08
	ctx.lr = 0x82EC7754;
	sub_82EC6F08(ctx, base);
	pc = 0x82EC7754; continue 'dispatch;
            }
            0x82EC7754 => {
    //   block [0x82EC7754..0x82EC775C)
	// 82EC7754: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC7758: 4BDE1D04  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC7760 size=360
    let mut pc: u32 = 0x82EC7760;
    'dispatch: loop {
        match pc {
            0x82EC7760 => {
    //   block [0x82EC7760..0x82EC777C)
	// 82EC7760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC7768: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC776C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC7770: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7774: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC7778: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	pc = 0x82EC777C; continue 'dispatch;
            }
            0x82EC777C => {
    //   block [0x82EC777C..0x82EC77B0)
	// 82EC777C: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EC7780: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC7784: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7788: 41820048  beq 0x82ec77d0
	if ctx.cr[0].eq {
	pc = 0x82EC77D0; continue 'dispatch;
	}
	// 82EC778C: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EC7790: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7794: 4182001C  beq 0x82ec77b0
	if ctx.cr[0].eq {
	pc = 0x82EC77B0; continue 'dispatch;
	}
	// 82EC7798: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC779C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC77A0: 409A0010  bne cr6, 0x82ec77b0
	if !ctx.cr[6].eq {
	pc = 0x82EC77B0; continue 'dispatch;
	}
	// 82EC77A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC77A8: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 82EC77AC: 4BFFF925  bl 0x82ec70d0
	ctx.lr = 0x82EC77B0;
	sub_82EC70D0(ctx, base);
	pc = 0x82EC77B0; continue 'dispatch;
            }
            0x82EC77B0 => {
    //   block [0x82EC77B0..0x82EC77D0)
	// 82EC77B0: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EC77B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC77B8: 41820018  beq 0x82ec77d0
	if ctx.cr[0].eq {
	pc = 0x82EC77D0; continue 'dispatch;
	}
	// 82EC77BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC77C0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC77C4: 409A000C  bne cr6, 0x82ec77d0
	if !ctx.cr[6].eq {
	pc = 0x82EC77D0; continue 'dispatch;
	}
	// 82EC77C8: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 82EC77CC: 4BFFFA05  bl 0x82ec71d0
	ctx.lr = 0x82EC77D0;
	sub_82EC71D0(ctx, base);
	pc = 0x82EC77D0; continue 'dispatch;
            }
            0x82EC77D0 => {
    //   block [0x82EC77D0..0x82EC7800)
	// 82EC77D0: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EC77D4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC77D8: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC77DC: 41820024  beq 0x82ec7800
	if ctx.cr[0].eq {
	pc = 0x82EC7800; continue 'dispatch;
	}
	// 82EC77E0: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EC77E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC77E8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC77EC: 419AFF90  beq cr6, 0x82ec777c
	if ctx.cr[6].eq {
	pc = 0x82EC777C; continue 'dispatch;
	}
	// 82EC77F0: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EC77F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC77F8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC77FC: 419AFF80  beq cr6, 0x82ec777c
	if ctx.cr[6].eq {
	pc = 0x82EC777C; continue 'dispatch;
	}
	pc = 0x82EC7800; continue 'dispatch;
            }
            0x82EC7800 => {
    //   block [0x82EC7800..0x82EC7834)
	// 82EC7800: 897F00C8  lbz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EC7804: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC7808: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC780C: 41820048  beq 0x82ec7854
	if ctx.cr[0].eq {
	pc = 0x82EC7854; continue 'dispatch;
	}
	// 82EC7810: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EC7814: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7818: 4182001C  beq 0x82ec7834
	if ctx.cr[0].eq {
	pc = 0x82EC7834; continue 'dispatch;
	}
	// 82EC781C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7820: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC7824: 409A0010  bne cr6, 0x82ec7834
	if !ctx.cr[6].eq {
	pc = 0x82EC7834; continue 'dispatch;
	}
	// 82EC7828: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC782C: 387F00AC  addi r3, r31, 0xac
	ctx.r[3].s64 = ctx.r[31].s64 + 172;
	// 82EC7830: 4BFFF8A1  bl 0x82ec70d0
	ctx.lr = 0x82EC7834;
	sub_82EC70D0(ctx, base);
	pc = 0x82EC7834; continue 'dispatch;
            }
            0x82EC7834 => {
    //   block [0x82EC7834..0x82EC7854)
	// 82EC7834: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EC7838: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC783C: 41820018  beq 0x82ec7854
	if ctx.cr[0].eq {
	pc = 0x82EC7854; continue 'dispatch;
	}
	// 82EC7840: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7844: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC7848: 409A000C  bne cr6, 0x82ec7854
	if !ctx.cr[6].eq {
	pc = 0x82EC7854; continue 'dispatch;
	}
	// 82EC784C: 387F00AC  addi r3, r31, 0xac
	ctx.r[3].s64 = ctx.r[31].s64 + 172;
	// 82EC7850: 4BFFF981  bl 0x82ec71d0
	ctx.lr = 0x82EC7854;
	sub_82EC71D0(ctx, base);
	pc = 0x82EC7854; continue 'dispatch;
            }
            0x82EC7854 => {
    //   block [0x82EC7854..0x82EC7884)
	// 82EC7854: 897F00C8  lbz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EC7858: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC785C: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7860: 41820024  beq 0x82ec7884
	if ctx.cr[0].eq {
	pc = 0x82EC7884; continue 'dispatch;
	}
	// 82EC7864: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EC7868: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC786C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC7870: 419AFF90  beq cr6, 0x82ec7800
	if ctx.cr[6].eq {
	pc = 0x82EC7800; continue 'dispatch;
	}
	// 82EC7874: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EC7878: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC787C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC7880: 419AFF80  beq cr6, 0x82ec7800
	if ctx.cr[6].eq {
	pc = 0x82EC7800; continue 'dispatch;
	}
	pc = 0x82EC7884; continue 'dispatch;
            }
            0x82EC7884 => {
    //   block [0x82EC7884..0x82EC78B0)
	// 82EC7884: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC7888: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC788C: 419A0024  beq cr6, 0x82ec78b0
	if ctx.cr[6].eq {
	pc = 0x82EC78B0; continue 'dispatch;
	}
	// 82EC7890: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC7894: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7898: 41820018  beq 0x82ec78b0
	if ctx.cr[0].eq {
	pc = 0x82EC78B0; continue 'dispatch;
	}
	// 82EC789C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC78A0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC78A4: 409A000C  bne cr6, 0x82ec78b0
	if !ctx.cr[6].eq {
	pc = 0x82EC78B0; continue 'dispatch;
	}
	// 82EC78A8: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82EC78AC: 4BFBEC85  bl 0x82e86530
	ctx.lr = 0x82EC78B0;
	sub_82E86530(ctx, base);
	pc = 0x82EC78B0; continue 'dispatch;
            }
            0x82EC78B0 => {
    //   block [0x82EC78B0..0x82EC78C8)
	// 82EC78B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC78B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC78B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC78BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC78C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC78C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC78C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC78C8 size=404
    let mut pc: u32 = 0x82EC78C8;
    'dispatch: loop {
        match pc {
            0x82EC78C8 => {
    //   block [0x82EC78C8..0x82EC793C)
	// 82EC78C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC78CC: 4BDE1B25  bl 0x82ca93f0
	ctx.lr = 0x82EC78D0;
	sub_82CA93D0(ctx, base);
	// 82EC78D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC78D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC78D8: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82EC78DC: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC78E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC78E4: 40820170  bne 0x82ec7a54
	if !ctx.cr[0].eq {
	pc = 0x82EC7A54; continue 'dispatch;
	}
	// 82EC78E8: 81760064  lwz r11, 0x64(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC78EC: 3AE00014  li r23, 0x14
	ctx.r[23].s64 = 20;
	// 82EC78F0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC78F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC78F8: 409A00A0  bne cr6, 0x82ec7998
	if !ctx.cr[6].eq {
	pc = 0x82EC7998; continue 'dispatch;
	}
	// 82EC78FC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7900: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EC7904: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7908: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EC790C: 8156006C  lwz r10, 0x6c(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC7910: 811F0070  lwz r8, 0x70(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC7914: 80FF0080  lwz r7, 0x80(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC7918: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC791C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EC7920: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC7924: 814900A4  lwz r10, 0xa4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC7928: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC792C: 7F0B41D6  mullw r24, r11, r8
	ctx.r[24].s32 = ((ctx.r[11].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[24].s64 = ctx.r[24].s32 as i64;
	// 82EC7930: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EC7934: 40990064  ble cr6, 0x82ec7998
	if !ctx.cr[6].gt {
	pc = 0x82EC7998; continue 'dispatch;
	}
	// 82EC7938: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	pc = 0x82EC793C; continue 'dispatch;
            }
            0x82EC793C => {
    //   block [0x82EC793C..0x82EC7950)
	// 82EC793C: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC7940: 7F2BD02E  lwzx r25, r11, r26
	ctx.r[25].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EC7944: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7948: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC794C: 48000028  b 0x82ec7974
	pc = 0x82EC7974; continue 'dispatch;
            }
            0x82EC7950 => {
    //   block [0x82EC7950..0x82EC7974)
	// 82EC7950: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7954: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC7958: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC795C: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82EC7960: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC7964: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EC7968: 7C8BC214  add r4, r11, r24
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82EC796C: 4BFC178D  bl 0x82e890f8
	ctx.lr = 0x82EC7970;
	sub_82E890F8(ctx, base);
	// 82EC7970: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EC7974; continue 'dispatch;
            }
            0x82EC7974 => {
    //   block [0x82EC7974..0x82EC7998)
	// 82EC7974: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7978: 4082FFD8  bne 0x82ec7950
	if !ctx.cr[0].eq {
	pc = 0x82EC7950; continue 'dispatch;
	}
	// 82EC797C: 81790020  lwz r11, 0x20(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC7980: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EC7984: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC7988: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82EC798C: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EC7990: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC7994: 4198FFA8  blt cr6, 0x82ec793c
	if ctx.cr[6].lt {
	pc = 0x82EC793C; continue 'dispatch;
	}
	pc = 0x82EC7998; continue 'dispatch;
            }
            0x82EC7998 => {
    //   block [0x82EC7998..0x82EC79BC)
	// 82EC7998: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC799C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC79A0: 80FF0080  lwz r7, 0x80(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC79A4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC79A8: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC79AC: 816B00A4  lwz r11, 0xa4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC79B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC79B4: 418200A0  beq 0x82ec7a54
	if ctx.cr[0].eq {
	pc = 0x82EC7A54; continue 'dispatch;
	}
	// 82EC79B8: 811F0078  lwz r8, 0x78(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	pc = 0x82EC79BC; continue 'dispatch;
            }
            0x82EC79BC => {
    //   block [0x82EC79BC..0x82EC79DC)
	// 82EC79BC: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC79C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC79C4: 41820018  beq 0x82ec79dc
	if ctx.cr[0].eq {
	pc = 0x82EC79DC; continue 'dispatch;
	}
	// 82EC79C8: 80D60064  lwz r6, 0x64(r22)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC79CC: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EC79D0: 419A0020  beq cr6, 0x82ec79f0
	if ctx.cr[6].eq {
	pc = 0x82EC79F0; continue 'dispatch;
	}
	// 82EC79D4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC79D8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x82EC79DC; continue 'dispatch;
            }
            0x82EC79DC => {
    //   block [0x82EC79DC..0x82EC79F0)
	// 82EC79DC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC79E0: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EC79E4: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EC79E8: 4198FFD4  blt cr6, 0x82ec79bc
	if ctx.cr[6].lt {
	pc = 0x82EC79BC; continue 'dispatch;
	}
	// 82EC79EC: 48000068  b 0x82ec7a54
	pc = 0x82EC7A54; continue 'dispatch;
            }
            0x82EC79F0 => {
    //   block [0x82EC79F0..0x82EC7A1C)
	// 82EC79F0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC79F4: 81360064  lwz r9, 0x64(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC79F8: 8116006C  lwz r8, 0x6c(r22)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC79FC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7A00: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7A04: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7A08: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7A0C: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82EC7A10: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC7A14: 7FAB5214  add r29, r11, r10
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC7A18: 48000034  b 0x82ec7a4c
	pc = 0x82EC7A4C; continue 'dispatch;
            }
            0x82EC7A1C => {
    //   block [0x82EC7A1C..0x82EC7A4C)
	// 82EC7A1C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7A20: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EC7A24: 815F0070  lwz r10, 0x70(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC7A28: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC7A2C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7A30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7A34: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82EC7A38: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC7A3C: 7D6B51D6  mullw r11, r11, r10
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC7A40: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EC7A44: 4BFC16B5  bl 0x82e890f8
	ctx.lr = 0x82EC7A48;
	sub_82E890F8(ctx, base);
	// 82EC7A48: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EC7A4C; continue 'dispatch;
            }
            0x82EC7A4C => {
    //   block [0x82EC7A4C..0x82EC7A54)
	// 82EC7A4C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7A50: 4082FFCC  bne 0x82ec7a1c
	if !ctx.cr[0].eq {
	pc = 0x82EC7A1C; continue 'dispatch;
	}
	pc = 0x82EC7A54; continue 'dispatch;
            }
            0x82EC7A54 => {
    //   block [0x82EC7A54..0x82EC7A5C)
	// 82EC7A54: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EC7A58: 4BDE19E8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC7A60 size=80
    let mut pc: u32 = 0x82EC7A60;
    'dispatch: loop {
        match pc {
            0x82EC7A60 => {
    //   block [0x82EC7A60..0x82EC7AB0)
	// 82EC7A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC7A68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC7A6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7A70: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC7A74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC7A78: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC7A7C: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EC7A80: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EC7A84: 917F00AC  stw r11, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82EC7A88: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82EC7A8C: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EC7A90: 4BFF18F1  bl 0x82eb9380
	ctx.lr = 0x82EC7A94;
	sub_82EB9380(ctx, base);
	// 82EC7A94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7A98: 4BFFEFC1  bl 0x82ec6a58
	ctx.lr = 0x82EC7A9C;
	sub_82EC6A58(ctx, base);
	// 82EC7A9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC7AA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC7AA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC7AA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC7AAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC7AB0 size=244
    let mut pc: u32 = 0x82EC7AB0;
    'dispatch: loop {
        match pc {
            0x82EC7AB0 => {
    //   block [0x82EC7AB0..0x82EC7ADC)
	// 82EC7AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7AB4: 4BDE1951  bl 0x82ca9404
	ctx.lr = 0x82EC7AB8;
	sub_82CA93D0(ctx, base);
	// 82EC7AB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7ABC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EC7AC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC7AC4: 4BFBEF05  bl 0x82e869c8
	ctx.lr = 0x82EC7AC8;
	sub_82E869C8(ctx, base);
	// 82EC7AC8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC7ACC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC7AD0: 409A000C  bne cr6, 0x82ec7adc
	if !ctx.cr[6].eq {
	pc = 0x82EC7ADC; continue 'dispatch;
	}
	// 82EC7AD4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC7AD8: 48000088  b 0x82ec7b60
	pc = 0x82EC7B60; continue 'dispatch;
            }
            0x82EC7ADC => {
    //   block [0x82EC7ADC..0x82EC7B2C)
	// 82EC7ADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7AE0: 482F4581  bl 0x831bc060
	ctx.lr = 0x82EC7AE4;
	sub_831BC060(ctx, base);
	// 82EC7AE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC7AE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC7AEC: 396BB2D0  addi r11, r11, -0x4d30
	ctx.r[11].s64 = ctx.r[11].s64 + -19760;
	// 82EC7AF0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EC7AF4: 4BDE505D  bl 0x82cacb50
	ctx.lr = 0x82EC7AF8;
	sub_82CACB50(ctx, base);
	// 82EC7AF8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC7AFC: 40820060  bne 0x82ec7b5c
	if !ctx.cr[0].eq {
	pc = 0x82EC7B5C; continue 'dispatch;
	}
	// 82EC7B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7B04: 4BA46205  bl 0x8290dd08
	ctx.lr = 0x82EC7B08;
	sub_8290DD08(ctx, base);
	// 82EC7B08: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82EC7B0C: 41820050  beq 0x82ec7b5c
	if ctx.cr[0].eq {
	pc = 0x82EC7B5C; continue 'dispatch;
	}
	// 82EC7B10: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7B14: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EC7B18: 3BEB0050  addi r31, r11, 0x50
	ctx.r[31].s64 = ctx.r[11].s64 + 80;
	// 82EC7B1C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7B20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC7B24: 40990038  ble cr6, 0x82ec7b5c
	if !ctx.cr[6].gt {
	pc = 0x82EC7B5C; continue 'dispatch;
	}
	// 82EC7B28: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82EC7B2C; continue 'dispatch;
            }
            0x82EC7B2C => {
    //   block [0x82EC7B2C..0x82EC7B5C)
	// 82EC7B2C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7B30: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC7B34: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC7B38: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC7B3C: 4BDE5015  bl 0x82cacb50
	ctx.lr = 0x82EC7B40;
	sub_82CACB50(ctx, base);
	// 82EC7B40: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC7B44: 41820024  beq 0x82ec7b68
	if ctx.cr[0].eq {
	pc = 0x82EC7B68; continue 'dispatch;
	}
	// 82EC7B48: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7B4C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EC7B50: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EC7B54: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC7B58: 4198FFD4  blt cr6, 0x82ec7b2c
	if ctx.cr[6].lt {
	pc = 0x82EC7B2C; continue 'dispatch;
	}
	pc = 0x82EC7B5C; continue 'dispatch;
            }
            0x82EC7B5C => {
    //   block [0x82EC7B5C..0x82EC7B60)
	// 82EC7B5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC7B60; continue 'dispatch;
            }
            0x82EC7B60 => {
    //   block [0x82EC7B60..0x82EC7B68)
	// 82EC7B60: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC7B64: 4BDE18F0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EC7B68 => {
    //   block [0x82EC7B68..0x82EC7BA4)
	// 82EC7B68: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7B6C: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC7B70: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC7B74: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7B78: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82EC7B7C: 4182FFE0  beq 0x82ec7b5c
	if ctx.cr[0].eq {
	pc = 0x82EC7B5C; continue 'dispatch;
	}
	// 82EC7B80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC7B84: 387C0074  addi r3, r28, 0x74
	ctx.r[3].s64 = ctx.r[28].s64 + 116;
	// 82EC7B88: 4BFF1709  bl 0x82eb9290
	ctx.lr = 0x82EC7B8C;
	sub_82EB9290(ctx, base);
	// 82EC7B8C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC7B90: 815C0070  lwz r10, 0x70(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC7B94: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC7B98: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC7B9C: 917C0070  stw r11, 0x70(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EC7BA0: 4BFFFFC0  b 0x82ec7b60
	pc = 0x82EC7B60; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC7BA8 size=284
    let mut pc: u32 = 0x82EC7BA8;
    'dispatch: loop {
        match pc {
            0x82EC7BA8 => {
    //   block [0x82EC7BA8..0x82EC7BEC)
	// 82EC7BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7BAC: 4BDE1861  bl 0x82ca940c
	ctx.lr = 0x82EC7BB0;
	sub_82CA93D0(ctx, base);
	// 82EC7BB0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EC7BB4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC7BB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7BBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC7BC0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC7BC4: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC7BC8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7BCC: 408200E4  bne 0x82ec7cb0
	if !ctx.cr[0].eq {
	pc = 0x82EC7CB0; continue 'dispatch;
	}
	// 82EC7BD0: 4B398DE9  bl 0x822609b8
	ctx.lr = 0x82EC7BD4;
	sub_822609B8(ctx, base);
	// 82EC7BD4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7BD8: C3E3004C  lfs f31, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC7BDC: 816B00A4  lwz r11, 0xa4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC7BE0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC7BE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC7BE8: C3CB0BEC  lfs f30, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x82EC7BEC; continue 'dispatch;
            }
            0x82EC7BEC => {
    //   block [0x82EC7BEC..0x82EC7C3C)
	// 82EC7BEC: 897F00C8  lbz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EC7BF0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC7BF4: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7BF8: 418200B0  beq 0x82ec7ca8
	if ctx.cr[0].eq {
	pc = 0x82EC7CA8; continue 'dispatch;
	}
	// 82EC7BFC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC7C00: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7C04: 4182009C  beq 0x82ec7ca0
	if ctx.cr[0].eq {
	pc = 0x82EC7CA0; continue 'dispatch;
	}
	// 82EC7C08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC7C0C: 3BDF00AC  addi r30, r31, 0xac
	ctx.r[30].s64 = ctx.r[31].s64 + 172;
	// 82EC7C10: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC7C14: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC7C18: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC7C1C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7C20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7C24: 41820018  beq 0x82ec7c3c
	if ctx.cr[0].eq {
	pc = 0x82EC7C3C; continue 'dispatch;
	}
	// 82EC7C28: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC7C2C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7C30: 4182000C  beq 0x82ec7c3c
	if ctx.cr[0].eq {
	pc = 0x82EC7C3C; continue 'dispatch;
	}
	// 82EC7C34: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7C38: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82EC7C3C; continue 'dispatch;
            }
            0x82EC7C3C => {
    //   block [0x82EC7C3C..0x82EC7C84)
	// 82EC7C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7C40: 4B9FAB21  bl 0x828c2760
	ctx.lr = 0x82EC7C44;
	sub_828C2760(ctx, base);
	// 82EC7C44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC7C48: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC7C4C: 4BFC1435  bl 0x82e89080
	ctx.lr = 0x82EC7C50;
	sub_82E89080(ctx, base);
	// 82EC7C50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC7C54: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7C58: 4BFBF6F9  bl 0x82e87350
	ctx.lr = 0x82EC7C5C;
	sub_82E87350(ctx, base);
	// 82EC7C5C: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 82EC7C60: 419A0034  beq cr6, 0x82ec7c94
	if ctx.cr[6].eq {
	pc = 0x82EC7C94; continue 'dispatch;
	}
	// 82EC7C64: EC1F0828  fsubs f0, f31, f1
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC7C68: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC7C6C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC7C70: 40980014  bge cr6, 0x82ec7c84
	if !ctx.cr[6].lt {
	pc = 0x82EC7C84; continue 'dispatch;
	}
	// 82EC7C74: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7C78: C1AB0098  lfs f13, 0x98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC7C7C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC7C80: 41980014  blt cr6, 0x82ec7c94
	if ctx.cr[6].lt {
	pc = 0x82EC7C94; continue 'dispatch;
	}
	pc = 0x82EC7C84; continue 'dispatch;
            }
            0x82EC7C84 => {
    //   block [0x82EC7C84..0x82EC7C94)
	// 82EC7C84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC7C88: 809F00CC  lwz r4, 0xcc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EC7C8C: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC7C90: 4BFC1469  bl 0x82e890f8
	ctx.lr = 0x82EC7C94;
	sub_82E890F8(ctx, base);
	pc = 0x82EC7C94; continue 'dispatch;
            }
            0x82EC7C94 => {
    //   block [0x82EC7C94..0x82EC7CA0)
	// 82EC7C94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC7C98: 4BFFF539  bl 0x82ec71d0
	ctx.lr = 0x82EC7C9C;
	sub_82EC71D0(ctx, base);
	// 82EC7C9C: 4BFFFF50  b 0x82ec7bec
	pc = 0x82EC7BEC; continue 'dispatch;
            }
            0x82EC7CA0 => {
    //   block [0x82EC7CA0..0x82EC7CA8)
	// 82EC7CA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC7CA4: 48000010  b 0x82ec7cb4
	pc = 0x82EC7CB4; continue 'dispatch;
            }
            0x82EC7CA8 => {
    //   block [0x82EC7CA8..0x82EC7CB0)
	// 82EC7CA8: 387F00AC  addi r3, r31, 0xac
	ctx.r[3].s64 = ctx.r[31].s64 + 172;
	// 82EC7CAC: 4BFFF705  bl 0x82ec73b0
	ctx.lr = 0x82EC7CB0;
	sub_82EC73B0(ctx, base);
	pc = 0x82EC7CB0; continue 'dispatch;
            }
            0x82EC7CB0 => {
    //   block [0x82EC7CB0..0x82EC7CB4)
	// 82EC7CB0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC7CB4; continue 'dispatch;
            }
            0x82EC7CB4 => {
    //   block [0x82EC7CB4..0x82EC7CC4)
	// 82EC7CB4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC7CB8: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EC7CBC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC7CC0: 4BDE179C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC7CC8 size=12
    let mut pc: u32 = 0x82EC7CC8;
    'dispatch: loop {
        match pc {
            0x82EC7CC8 => {
    //   block [0x82EC7CC8..0x82EC7CD4)
	// 82EC7CC8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC7CCC: 386BE284  addi r3, r11, -0x1d7c
	ctx.r[3].s64 = ctx.r[11].s64 + -7548;
	// 82EC7CD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC7CD8 size=48
    let mut pc: u32 = 0x82EC7CD8;
    'dispatch: loop {
        match pc {
            0x82EC7CD8 => {
    //   block [0x82EC7CD8..0x82EC7D08)
	// 82EC7CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7CDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC7CE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7CE4: 4BFBF055  bl 0x82e86d38
	ctx.lr = 0x82EC7CE8;
	sub_82E86D38(ctx, base);
	// 82EC7CE8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC7CEC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC7CF0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EC7CF4: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82EC7CF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC7CFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC7D00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC7D04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC7D08 size=92
    let mut pc: u32 = 0x82EC7D08;
    'dispatch: loop {
        match pc {
            0x82EC7D08 => {
    //   block [0x82EC7D08..0x82EC7D58)
	// 82EC7D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7D0C: 4BDE16FD  bl 0x82ca9408
	ctx.lr = 0x82EC7D10;
	sub_82CA93D0(ctx, base);
	// 82EC7D10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7D14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC7D18: 386000D4  li r3, 0xd4
	ctx.r[3].s64 = 212;
	// 82EC7D1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC7D20: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EC7D24: 4B74EC05  bl 0x82616928
	ctx.lr = 0x82EC7D28;
	sub_82616928(ctx, base);
	// 82EC7D28: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC7D2C: 4182002C  beq 0x82ec7d58
	if ctx.cr[0].eq {
	pc = 0x82EC7D58; continue 'dispatch;
	}
	// 82EC7D30: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82EC7D34: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC7D38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC7D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7D40: 4BFFEEC9  bl 0x82ec6c08
	ctx.lr = 0x82EC7D44;
	sub_82EC6C08(ctx, base);
	// 82EC7D44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC7D48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7D4C: 396B2DBC  addi r11, r11, 0x2dbc
	ctx.r[11].s64 = ctx.r[11].s64 + 11708;
	// 82EC7D50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC7D54: 48000008  b 0x82ec7d5c
	pc = 0x82EC7D5C; continue 'dispatch;
            }
            0x82EC7D58 => {
    //   block [0x82EC7D58..0x82EC7D5C)
	// 82EC7D58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC7D5C; continue 'dispatch;
            }
            0x82EC7D5C => {
    //   block [0x82EC7D5C..0x82EC7D64)
	// 82EC7D5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC7D60: 4BDE16F8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC7D68 size=92
    let mut pc: u32 = 0x82EC7D68;
    'dispatch: loop {
        match pc {
            0x82EC7D68 => {
    //   block [0x82EC7D68..0x82EC7DA8)
	// 82EC7D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC7D70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC7D74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC7D78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7D7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC7D80: 4BFBEFB9  bl 0x82e86d38
	ctx.lr = 0x82EC7D84;
	sub_82E86D38(ctx, base);
	// 82EC7D84: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC7D88: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC7D8C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7D90: 388BE284  addi r4, r11, -0x1d7c
	ctx.r[4].s64 = ctx.r[11].s64 + -7548;
	// 82EC7D94: 4BFBF93D  bl 0x82e876d0
	ctx.lr = 0x82EC7D98;
	sub_82E876D0(ctx, base);
	// 82EC7D98: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7D9C: 907F00D8  stw r3, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[3].u32 ) };
	// 82EC7DA0: 40820008  bne 0x82ec7da8
	if !ctx.cr[0].eq {
	pc = 0x82EC7DA8; continue 'dispatch;
	}
	// 82EC7DA4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82EC7DA8; continue 'dispatch;
            }
            0x82EC7DA8 => {
    //   block [0x82EC7DA8..0x82EC7DC4)
	// 82EC7DA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC7DAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC7DB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC7DB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC7DB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC7DBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC7DC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC7DC8 size=560
    let mut pc: u32 = 0x82EC7DC8;
    'dispatch: loop {
        match pc {
            0x82EC7DC8 => {
    //   block [0x82EC7DC8..0x82EC7E7C)
	// 82EC7DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7DCC: 4BDE1625  bl 0x82ca93f0
	ctx.lr = 0x82EC7DD0;
	sub_82CA93D0(ctx, base);
	// 82EC7DD0: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7DD4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC7DD8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC7DDC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EC7DE0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC7DE4: 388BC4B4  addi r4, r11, -0x3b4c
	ctx.r[4].s64 = ctx.r[11].s64 + -15180;
	// 82EC7DE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC7DEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7DF0: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82EC7DF4: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 82EC7DF8: 4B320881  bl 0x821e8678
	ctx.lr = 0x82EC7DFC;
	sub_821E8678(ctx, base);
	// 82EC7DFC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC7E00: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EC7E04: 3BCBC064  addi r30, r11, -0x3f9c
	ctx.r[30].s64 = ctx.r[11].s64 + -16284;
	// 82EC7E08: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC7E0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC7E10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7E14: 4B320865  bl 0x821e8678
	ctx.lr = 0x82EC7E18;
	sub_821E8678(ctx, base);
	// 82EC7E18: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC7E1C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EC7E20: 388BD5FC  addi r4, r11, -0x2a04
	ctx.r[4].s64 = ctx.r[11].s64 + -10756;
	// 82EC7E24: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC7E28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7E2C: 4B32084D  bl 0x821e8678
	ctx.lr = 0x82EC7E30;
	sub_821E8678(ctx, base);
	// 82EC7E30: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EC7E34: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC7E38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC7E3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC7E40: 4B320839  bl 0x821e8678
	ctx.lr = 0x82EC7E44;
	sub_821E8678(ctx, base);
	// 82EC7E44: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC7E48: C01F0034  lfs f0, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7E4C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EC7E50: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC7E54: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EC7E58: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7E5C: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 82EC7E60: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EC7E64: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 82EC7E68: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7E6C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC7E70: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EC7E74: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EC7E78: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EC7E7C; continue 'dispatch;
            }
            0x82EC7E7C => {
    //   block [0x82EC7E7C..0x82EC7EB0)
	// 82EC7E7C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC7E80: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC7E84: 4200FFF8  bdnz 0x82ec7e7c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC7E7C; continue 'dispatch;
	}
	// 82EC7E88: 9AE100D8  stb r23, 0xd8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[23].u8 ) };
	// 82EC7E8C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EC7E90: 419A0020  beq cr6, 0x82ec7eb0
	if ctx.cr[6].eq {
	pc = 0x82EC7EB0; continue 'dispatch;
	}
	// 82EC7E94: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7E98: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EC7E9C: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7EA0: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EC7EA4: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7EA8: 9AE100D8  stb r23, 0xd8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[23].u8 ) };
	// 82EC7EAC: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	pc = 0x82EC7EB0; continue 'dispatch;
            }
            0x82EC7EB0 => {
    //   block [0x82EC7EB0..0x82EC7EDC)
	// 82EC7EB0: C01D0034  lfs f0, 0x34(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7EB4: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 82EC7EB8: D00100E4  stfs f0, 0xe4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EC7EBC: 394100F0  addi r10, r1, 0xf0
	ctx.r[10].s64 = ctx.r[1].s64 + 240;
	// 82EC7EC0: C01D0038  lfs f0, 0x38(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7EC4: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 82EC7EC8: D00100E8  stfs f0, 0xe8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EC7ECC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC7ED0: C01D003C  lfs f0, 0x3c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7ED4: D00100EC  stfs f0, 0xec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EC7ED8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82EC7EDC; continue 'dispatch;
            }
            0x82EC7EDC => {
    //   block [0x82EC7EDC..0x82EC7F10)
	// 82EC7EDC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC7EE0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC7EE4: 4200FFF8  bdnz 0x82ec7edc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC7EDC; continue 'dispatch;
	}
	// 82EC7EE8: 9AE10138  stb r23, 0x138(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[23].u8 ) };
	// 82EC7EEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC7EF0: 419A0020  beq cr6, 0x82ec7f10
	if ctx.cr[6].eq {
	pc = 0x82EC7F10; continue 'dispatch;
	}
	// 82EC7EF4: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7EF8: D00100E4  stfs f0, 0xe4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EC7EFC: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F00: D00100E8  stfs f0, 0xe8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EC7F04: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F08: 9AE10138  stb r23, 0x138(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[23].u8 ) };
	// 82EC7F0C: D00100EC  stfs f0, 0xec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	pc = 0x82EC7F10; continue 'dispatch;
            }
            0x82EC7F10 => {
    //   block [0x82EC7F10..0x82EC7F88)
	// 82EC7F10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC7F14: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82EC7F18: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EC7F1C: 3BCB1890  addi r30, r11, 0x1890
	ctx.r[30].s64 = ctx.r[11].s64 + 6288;
	// 82EC7F20: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EC7F24: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82EC7F28: 4B2E6781  bl 0x821ae6a8
	ctx.lr = 0x82EC7F2C;
	sub_821AE6A8(ctx, base);
	// 82EC7F2C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82EC7F30: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EC7F34: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82EC7F38: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82EC7F3C: 4B2E676D  bl 0x821ae6a8
	ctx.lr = 0x82EC7F40;
	sub_821AE6A8(ctx, base);
	// 82EC7F40: C01F004C  lfs f0, 0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F44: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC7F48: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EC7F4C: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F50: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC7F54: C01F0054  lfs f0, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F58: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC7F5C: 419A005C  beq cr6, 0x82ec7fb8
	if ctx.cr[6].eq {
	pc = 0x82EC7FB8; continue 'dispatch;
	}
	// 82EC7F60: C05B0004  lfs f2, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EC7F64: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82EC7F68: C03B0008  lfs f1, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EC7F6C: 419A001C  beq cr6, 0x82ec7f88
	if ctx.cr[6].eq {
	pc = 0x82EC7F88; continue 'dispatch;
	}
	// 82EC7F70: C01A0004  lfs f0, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F74: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC7F78: C01A0008  lfs f0, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F7C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC7F80: C01A000C  lfs f0, 0xc(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F84: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	pc = 0x82EC7F88; continue 'dispatch;
            }
            0x82EC7F88 => {
    //   block [0x82EC7F88..0x82EC7FA8)
	// 82EC7F88: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EC7F8C: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 82EC7F90: 386100E4  addi r3, r1, 0xe4
	ctx.r[3].s64 = ctx.r[1].s64 + 228;
	// 82EC7F94: 4BFC1B8D  bl 0x82e89b20
	ctx.lr = 0x82EC7F98;
	sub_82E89B20(ctx, base);
	// 82EC7F98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7F9C: 4082001C  bne 0x82ec7fb8
	if !ctx.cr[0].eq {
	pc = 0x82EC7FB8; continue 'dispatch;
	}
	// 82EC7FA0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82EC7FA4: 9AF80000  stb r23, 0(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[23].u8 ) };
	pc = 0x82EC7FA8; continue 'dispatch;
            }
            0x82EC7FA8 => {
    //   block [0x82EC7FA8..0x82EC7FAC)
	// 82EC7FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82EC7FAC; continue 'dispatch;
            }
            0x82EC7FAC => {
    //   block [0x82EC7FAC..0x82EC7FB8)
	// 82EC7FAC: 9BF60000  stb r31, 0(r22)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 82EC7FB0: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 82EC7FB4: 4BDE148C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EC7FB8 => {
    //   block [0x82EC7FB8..0x82EC7FEC)
	// 82EC7FB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC7FBC: 807900D8  lwz r3, 0xd8(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(216 as u32) ) } as u64;
	// 82EC7FC0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82EC7FC4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC7FC8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EC7FCC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EC7FD0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC7FD4: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 82EC7FD8: 4B4093D9  bl 0x822d13b0
	ctx.lr = 0x82EC7FDC;
	sub_822D13B0(ctx, base);
	// 82EC7FDC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC7FE0: 4082000C  bne 0x82ec7fec
	if !ctx.cr[0].eq {
	pc = 0x82EC7FEC; continue 'dispatch;
	}
	// 82EC7FE4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82EC7FE8: 4BFFFFC4  b 0x82ec7fac
	pc = 0x82EC7FAC; continue 'dispatch;
            }
            0x82EC7FEC => {
    //   block [0x82EC7FEC..0x82EC7FF8)
	// 82EC7FEC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC7FF0: 99780000  stb r11, 0(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82EC7FF4: 4BFFFFB4  b 0x82ec7fa8
	pc = 0x82EC7FA8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC7FF8 size=12
    let mut pc: u32 = 0x82EC7FF8;
    'dispatch: loop {
        match pc {
            0x82EC7FF8 => {
    //   block [0x82EC7FF8..0x82EC8004)
	// 82EC7FF8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC7FFC: 386BE398  addi r3, r11, -0x1c68
	ctx.r[3].s64 = ctx.r[11].s64 + -7272;
	// 82EC8000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8008 size=88
    let mut pc: u32 = 0x82EC8008;
    'dispatch: loop {
        match pc {
            0x82EC8008 => {
    //   block [0x82EC8008..0x82EC8044)
	// 82EC8008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC800C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8010: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC8014: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC8018: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC801C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC8020: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC8024: 4BFFFA3D  bl 0x82ec7a60
	ctx.lr = 0x82EC8028;
	sub_82EC7A60(ctx, base);
	// 82EC8028: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC802C: 41820018  beq 0x82ec8044
	if ctx.cr[0].eq {
	pc = 0x82EC8044; continue 'dispatch;
	}
	// 82EC8030: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC8034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8038: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC803C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC8040: 4E800421  bctrl
	ctx.lr = 0x82EC8044;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC8044 => {
    //   block [0x82EC8044..0x82EC8060)
	// 82EC8044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8048: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC804C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC8050: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC8054: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC8058: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC805C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8060 size=100
    let mut pc: u32 = 0x82EC8060;
    'dispatch: loop {
        match pc {
            0x82EC8060 => {
    //   block [0x82EC8060..0x82EC80B8)
	// 82EC8060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8064: 4BDE13A5  bl 0x82ca9408
	ctx.lr = 0x82EC8068;
	sub_82CA93D0(ctx, base);
	// 82EC8068: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC806C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC8070: 386000DC  li r3, 0xdc
	ctx.r[3].s64 = 220;
	// 82EC8074: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC8078: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EC807C: 4B74E8AD  bl 0x82616928
	ctx.lr = 0x82EC8080;
	sub_82616928(ctx, base);
	// 82EC8080: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC8084: 41820034  beq 0x82ec80b8
	if ctx.cr[0].eq {
	pc = 0x82EC80B8; continue 'dispatch;
	}
	// 82EC8088: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82EC808C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC8090: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8098: 4BFFEB71  bl 0x82ec6c08
	ctx.lr = 0x82EC809C;
	sub_82EC6C08(ctx, base);
	// 82EC809C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC80A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC80A4: 396BB2F8  addi r11, r11, -0x4d08
	ctx.r[11].s64 = ctx.r[11].s64 + -19720;
	// 82EC80A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC80AC: 915F00D8  stw r10, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[10].u32 ) };
	// 82EC80B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC80B4: 48000008  b 0x82ec80bc
	pc = 0x82EC80BC; continue 'dispatch;
            }
            0x82EC80B8 => {
    //   block [0x82EC80B8..0x82EC80BC)
	// 82EC80B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC80BC; continue 'dispatch;
            }
            0x82EC80BC => {
    //   block [0x82EC80BC..0x82EC80C4)
	// 82EC80BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC80C0: 4BDE1398  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC80C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC80C8 size=820
    let mut pc: u32 = 0x82EC80C8;
    'dispatch: loop {
        match pc {
            0x82EC80C8 => {
    //   block [0x82EC80C8..0x82EC80E8)
	// 82EC80C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC80CC: 4BDE1341  bl 0x82ca940c
	ctx.lr = 0x82EC80D0;
	sub_82CA93D0(ctx, base);
	// 82EC80D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC80D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC80D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC80DC: 4B75155D  bl 0x82619638
	ctx.lr = 0x82EC80E0;
	sub_82619638(ctx, base);
	// 82EC80E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC80E4: 4182000C  beq 0x82ec80f0
	if ctx.cr[0].eq {
	pc = 0x82EC80F0; continue 'dispatch;
	}
	pc = 0x82EC80E8; continue 'dispatch;
            }
            0x82EC80E8 => {
    //   block [0x82EC80E8..0x82EC80F0)
	// 82EC80E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC80EC: 48000308  b 0x82ec83f4
	pc = 0x82EC83F4; continue 'dispatch;
            }
            0x82EC80F0 => {
    //   block [0x82EC80F0..0x82EC8134)
	// 82EC80F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC80F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC80F8: 3BCBB388  addi r30, r11, -0x4c78
	ctx.r[30].s64 = ctx.r[11].s64 + -19576;
	// 82EC80FC: 482F3F65  bl 0x831bc060
	ctx.lr = 0x82EC8100;
	sub_831BC060(ctx, base);
	// 82EC8100: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8104: 4BDE4A4D  bl 0x82cacb50
	ctx.lr = 0x82EC8108;
	sub_82CACB50(ctx, base);
	// 82EC8108: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC810C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8110: 40820024  bne 0x82ec8134
	if !ctx.cr[0].eq {
	pc = 0x82EC8134; continue 'dispatch;
	}
	// 82EC8114: 4BA45BF5  bl 0x8290dd08
	ctx.lr = 0x82EC8118;
	sub_8290DD08(ctx, base);
	// 82EC8118: 4BDE22A9  bl 0x82caa3c0
	ctx.lr = 0x82EC811C;
	sub_82CAA3C0(ctx, base);
	// 82EC811C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC8120: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8124: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC8128: 4182FFC0  beq 0x82ec80e8
	if ctx.cr[0].eq {
	pc = 0x82EC80E8; continue 'dispatch;
	}
	// 82EC812C: 907D000C  stw r3, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82EC8130: 4BFFFFB8  b 0x82ec80e8
	pc = 0x82EC80E8; continue 'dispatch;
            }
            0x82EC8134 => {
    //   block [0x82EC8134..0x82EC8174)
	// 82EC8134: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8138: 3BCBB378  addi r30, r11, -0x4c88
	ctx.r[30].s64 = ctx.r[11].s64 + -19592;
	// 82EC813C: 482F3F25  bl 0x831bc060
	ctx.lr = 0x82EC8140;
	sub_831BC060(ctx, base);
	// 82EC8140: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8144: 4BDE4A0D  bl 0x82cacb50
	ctx.lr = 0x82EC8148;
	sub_82CACB50(ctx, base);
	// 82EC8148: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC814C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8150: 40820040  bne 0x82ec8190
	if !ctx.cr[0].eq {
	pc = 0x82EC8190; continue 'dispatch;
	}
	// 82EC8154: 4BA45BB5  bl 0x8290dd08
	ctx.lr = 0x82EC8158;
	sub_8290DD08(ctx, base);
	// 82EC8158: 4BDE3A59  bl 0x82cabbb0
	ctx.lr = 0x82EC815C;
	sub_82CABBB0(ctx, base);
	// 82EC815C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8160: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC8164: C00B0A7C  lfs f0, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8168: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC816C: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC8170: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EC8174; continue 'dispatch;
            }
            0x82EC8174 => {
    //   block [0x82EC8174..0x82EC8180)
	// 82EC8174: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC8178: 40990008  ble cr6, 0x82ec8180
	if !ctx.cr[6].gt {
	pc = 0x82EC8180; continue 'dispatch;
	}
	// 82EC817C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EC8180; continue 'dispatch;
            }
            0x82EC8180 => {
    //   block [0x82EC8180..0x82EC8190)
	// 82EC8180: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC8184: 409AFFF0  bne cr6, 0x82ec8174
	if !ctx.cr[6].eq {
	pc = 0x82EC8174; continue 'dispatch;
	}
	// 82EC8188: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC818C: 4BFFFF5C  b 0x82ec80e8
	pc = 0x82EC80E8; continue 'dispatch;
            }
            0x82EC8190 => {
    //   block [0x82EC8190..0x82EC81D0)
	// 82EC8190: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8194: 3BCBB368  addi r30, r11, -0x4c98
	ctx.r[30].s64 = ctx.r[11].s64 + -19608;
	// 82EC8198: 482F3EC9  bl 0x831bc060
	ctx.lr = 0x82EC819C;
	sub_831BC060(ctx, base);
	// 82EC819C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC81A0: 4BDE49B1  bl 0x82cacb50
	ctx.lr = 0x82EC81A4;
	sub_82CACB50(ctx, base);
	// 82EC81A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC81A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC81AC: 40820040  bne 0x82ec81ec
	if !ctx.cr[0].eq {
	pc = 0x82EC81EC; continue 'dispatch;
	}
	// 82EC81B0: 4BA45B59  bl 0x8290dd08
	ctx.lr = 0x82EC81B4;
	sub_8290DD08(ctx, base);
	// 82EC81B4: 4BDE39FD  bl 0x82cabbb0
	ctx.lr = 0x82EC81B8;
	sub_82CABBB0(ctx, base);
	// 82EC81B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC81BC: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC81C0: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC81C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC81C8: D01D0014  stfs f0, 0x14(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC81CC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EC81D0; continue 'dispatch;
            }
            0x82EC81D0 => {
    //   block [0x82EC81D0..0x82EC81DC)
	// 82EC81D0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC81D4: 40990008  ble cr6, 0x82ec81dc
	if !ctx.cr[6].gt {
	pc = 0x82EC81DC; continue 'dispatch;
	}
	// 82EC81D8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EC81DC; continue 'dispatch;
            }
            0x82EC81DC => {
    //   block [0x82EC81DC..0x82EC81EC)
	// 82EC81DC: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC81E0: 409AFFF0  bne cr6, 0x82ec81d0
	if !ctx.cr[6].eq {
	pc = 0x82EC81D0; continue 'dispatch;
	}
	// 82EC81E4: D01D0014  stfs f0, 0x14(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC81E8: 4BFFFF00  b 0x82ec80e8
	pc = 0x82EC80E8; continue 'dispatch;
            }
            0x82EC81EC => {
    //   block [0x82EC81EC..0x82EC822C)
	// 82EC81EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC81F0: 3BCB95B8  addi r30, r11, -0x6a48
	ctx.r[30].s64 = ctx.r[11].s64 + -27208;
	// 82EC81F4: 482F3E6D  bl 0x831bc060
	ctx.lr = 0x82EC81F8;
	sub_831BC060(ctx, base);
	// 82EC81F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC81FC: 4BDE4955  bl 0x82cacb50
	ctx.lr = 0x82EC8200;
	sub_82CACB50(ctx, base);
	// 82EC8200: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8208: 4082006C  bne 0x82ec8274
	if !ctx.cr[0].eq {
	pc = 0x82EC8274; continue 'dispatch;
	}
	// 82EC820C: 4BA45AFD  bl 0x8290dd08
	ctx.lr = 0x82EC8210;
	sub_8290DD08(ctx, base);
	// 82EC8210: 4BDE39A1  bl 0x82cabbb0
	ctx.lr = 0x82EC8214;
	sub_82CABBB0(ctx, base);
	// 82EC8214: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8218: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC821C: C00BBE10  lfs f0, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8220: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8224: D01D001C  stfs f0, 0x1c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC8228: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EC822C; continue 'dispatch;
            }
            0x82EC822C => {
    //   block [0x82EC822C..0x82EC8238)
	// 82EC822C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC8230: 40990008  ble cr6, 0x82ec8238
	if !ctx.cr[6].gt {
	pc = 0x82EC8238; continue 'dispatch;
	}
	// 82EC8234: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EC8238; continue 'dispatch;
            }
            0x82EC8238 => {
    //   block [0x82EC8238..0x82EC825C)
	// 82EC8238: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC823C: 409AFFF0  bne cr6, 0x82ec822c
	if !ctx.cr[6].eq {
	pc = 0x82EC822C; continue 'dispatch;
	}
	// 82EC8240: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC8244: D01D001C  stfs f0, 0x1c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC8248: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC824C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8250: 4182000C  beq 0x82ec825c
	if ctx.cr[0].eq {
	pc = 0x82EC825C; continue 'dispatch;
	}
	// 82EC8254: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8258: 4800000C  b 0x82ec8264
	pc = 0x82EC8264; continue 'dispatch;
            }
            0x82EC825C => {
    //   block [0x82EC825C..0x82EC8264)
	// 82EC825C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8260: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EC8264; continue 'dispatch;
            }
            0x82EC8264 => {
    //   block [0x82EC8264..0x82EC8274)
	// 82EC8264: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC8268: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC826C: D01D001C  stfs f0, 0x1c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC8270: 48000184  b 0x82ec83f4
	pc = 0x82EC83F4; continue 'dispatch;
            }
            0x82EC8274 => {
    //   block [0x82EC8274..0x82EC82B4)
	// 82EC8274: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8278: 3BCBB354  addi r30, r11, -0x4cac
	ctx.r[30].s64 = ctx.r[11].s64 + -19628;
	// 82EC827C: 482F3DE5  bl 0x831bc060
	ctx.lr = 0x82EC8280;
	sub_831BC060(ctx, base);
	// 82EC8280: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8284: 4BDE48CD  bl 0x82cacb50
	ctx.lr = 0x82EC8288;
	sub_82CACB50(ctx, base);
	// 82EC8288: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC828C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8290: 40820070  bne 0x82ec8300
	if !ctx.cr[0].eq {
	pc = 0x82EC8300; continue 'dispatch;
	}
	// 82EC8294: 4BA45A75  bl 0x8290dd08
	ctx.lr = 0x82EC8298;
	sub_8290DD08(ctx, base);
	// 82EC8298: 4BDE3919  bl 0x82cabbb0
	ctx.lr = 0x82EC829C;
	sub_82CABBB0(ctx, base);
	// 82EC829C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC82A0: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC82A4: C00B0AB4  lfs f0, 0xab4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2740 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC82A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC82AC: D01D0018  stfs f0, 0x18(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC82B0: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EC82B4; continue 'dispatch;
            }
            0x82EC82B4 => {
    //   block [0x82EC82B4..0x82EC82C0)
	// 82EC82B4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC82B8: 41980008  blt cr6, 0x82ec82c0
	if ctx.cr[6].lt {
	pc = 0x82EC82C0; continue 'dispatch;
	}
	// 82EC82BC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EC82C0; continue 'dispatch;
            }
            0x82EC82C0 => {
    //   block [0x82EC82C0..0x82EC82E4)
	// 82EC82C0: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC82C4: 409AFFF0  bne cr6, 0x82ec82b4
	if !ctx.cr[6].eq {
	pc = 0x82EC82B4; continue 'dispatch;
	}
	// 82EC82C8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC82CC: D01D0018  stfs f0, 0x18(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC82D0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC82D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC82D8: 4182000C  beq 0x82ec82e4
	if ctx.cr[0].eq {
	pc = 0x82EC82E4; continue 'dispatch;
	}
	// 82EC82DC: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC82E0: 4800000C  b 0x82ec82ec
	pc = 0x82EC82EC; continue 'dispatch;
            }
            0x82EC82E4 => {
    //   block [0x82EC82E4..0x82EC82EC)
	// 82EC82E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC82E8: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EC82EC; continue 'dispatch;
            }
            0x82EC82EC => {
    //   block [0x82EC82EC..0x82EC8300)
	// 82EC82EC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC82F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC82F4: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC82F8: D01D0018  stfs f0, 0x18(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC82FC: 480000F8  b 0x82ec83f4
	pc = 0x82EC83F4; continue 'dispatch;
            }
            0x82EC8300 => {
    //   block [0x82EC8300..0x82EC83DC)
	// 82EC8300: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8304: 3BCBB348  addi r30, r11, -0x4cb8
	ctx.r[30].s64 = ctx.r[11].s64 + -19640;
	// 82EC8308: 482F3D59  bl 0x831bc060
	ctx.lr = 0x82EC830C;
	sub_831BC060(ctx, base);
	// 82EC830C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8310: 4BDE4841  bl 0x82cacb50
	ctx.lr = 0x82EC8314;
	sub_82CACB50(ctx, base);
	// 82EC8314: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8318: 408200D8  bne 0x82ec83f0
	if !ctx.cr[0].eq {
	pc = 0x82EC83F0; continue 'dispatch;
	}
	// 82EC831C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EC8320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8324: 3BCB1694  addi r30, r11, 0x1694
	ctx.r[30].s64 = ctx.r[11].s64 + 5780;
	// 82EC8328: 4BA459E1  bl 0x8290dd08
	ctx.lr = 0x82EC832C;
	sub_8290DD08(ctx, base);
	// 82EC832C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8330: 4BDE4821  bl 0x82cacb50
	ctx.lr = 0x82EC8334;
	sub_82CACB50(ctx, base);
	// 82EC8334: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8338: 418200AC  beq 0x82ec83e4
	if ctx.cr[0].eq {
	pc = 0x82EC83E4; continue 'dispatch;
	}
	// 82EC833C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8344: 3BCB0F40  addi r30, r11, 0xf40
	ctx.r[30].s64 = ctx.r[11].s64 + 3904;
	// 82EC8348: 4BA459C1  bl 0x8290dd08
	ctx.lr = 0x82EC834C;
	sub_8290DD08(ctx, base);
	// 82EC834C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8350: 4BDE4801  bl 0x82cacb50
	ctx.lr = 0x82EC8354;
	sub_82CACB50(ctx, base);
	// 82EC8354: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8358: 4182008C  beq 0x82ec83e4
	if ctx.cr[0].eq {
	pc = 0x82EC83E4; continue 'dispatch;
	}
	// 82EC835C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EC8360: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8364: 3BCBD56C  addi r30, r11, -0x2a94
	ctx.r[30].s64 = ctx.r[11].s64 + -10900;
	// 82EC8368: 4BA459A1  bl 0x8290dd08
	ctx.lr = 0x82EC836C;
	sub_8290DD08(ctx, base);
	// 82EC836C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8370: 4BDE47E1  bl 0x82cacb50
	ctx.lr = 0x82EC8374;
	sub_82CACB50(ctx, base);
	// 82EC8374: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8378: 4182006C  beq 0x82ec83e4
	if ctx.cr[0].eq {
	pc = 0x82EC83E4; continue 'dispatch;
	}
	// 82EC837C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EC8380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8384: 3BCB1698  addi r30, r11, 0x1698
	ctx.r[30].s64 = ctx.r[11].s64 + 5784;
	// 82EC8388: 4BA45981  bl 0x8290dd08
	ctx.lr = 0x82EC838C;
	sub_8290DD08(ctx, base);
	// 82EC838C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8390: 4BDE47C1  bl 0x82cacb50
	ctx.lr = 0x82EC8394;
	sub_82CACB50(ctx, base);
	// 82EC8394: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8398: 41820044  beq 0x82ec83dc
	if ctx.cr[0].eq {
	pc = 0x82EC83DC; continue 'dispatch;
	}
	// 82EC839C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EC83A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC83A4: 3BCB1700  addi r30, r11, 0x1700
	ctx.r[30].s64 = ctx.r[11].s64 + 5888;
	// 82EC83A8: 4BA45961  bl 0x8290dd08
	ctx.lr = 0x82EC83AC;
	sub_8290DD08(ctx, base);
	// 82EC83AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC83B0: 4BDE47A1  bl 0x82cacb50
	ctx.lr = 0x82EC83B4;
	sub_82CACB50(ctx, base);
	// 82EC83B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC83B8: 41820024  beq 0x82ec83dc
	if ctx.cr[0].eq {
	pc = 0x82EC83DC; continue 'dispatch;
	}
	// 82EC83BC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EC83C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC83C4: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82EC83C8: 4BA45941  bl 0x8290dd08
	ctx.lr = 0x82EC83CC;
	sub_8290DD08(ctx, base);
	// 82EC83CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC83D0: 4BDE4781  bl 0x82cacb50
	ctx.lr = 0x82EC83D4;
	sub_82CACB50(ctx, base);
	// 82EC83D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC83D8: 40820018  bne 0x82ec83f0
	if !ctx.cr[0].eq {
	pc = 0x82EC83F0; continue 'dispatch;
	}
	pc = 0x82EC83DC; continue 'dispatch;
            }
            0x82EC83DC => {
    //   block [0x82EC83DC..0x82EC83E4)
	// 82EC83DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC83E0: 48000008  b 0x82ec83e8
	pc = 0x82EC83E8; continue 'dispatch;
            }
            0x82EC83E4 => {
    //   block [0x82EC83E4..0x82EC83E8)
	// 82EC83E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EC83E8; continue 'dispatch;
            }
            0x82EC83E8 => {
    //   block [0x82EC83E8..0x82EC83F0)
	// 82EC83E8: 997D0020  stb r11, 0x20(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[11].u8 ) };
	// 82EC83EC: 4BFFFCFC  b 0x82ec80e8
	pc = 0x82EC80E8; continue 'dispatch;
            }
            0x82EC83F0 => {
    //   block [0x82EC83F0..0x82EC83F4)
	// 82EC83F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC83F4; continue 'dispatch;
            }
            0x82EC83F4 => {
    //   block [0x82EC83F4..0x82EC83FC)
	// 82EC83F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC83F8: 4BDE1064  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC8400 size=228
    let mut pc: u32 = 0x82EC8400;
    'dispatch: loop {
        match pc {
            0x82EC8400 => {
    //   block [0x82EC8400..0x82EC845C)
	// 82EC8400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8408: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC840C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC8410: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8414: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC8418: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EC841C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC8420: 4B2FBEC9  bl 0x821c42e8
	ctx.lr = 0x82EC8424;
	sub_821C42E8(ctx, base);
	// 82EC8424: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC8428: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC842C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC8430: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC8434: 40980098  bge cr6, 0x82ec84cc
	if !ctx.cr[6].lt {
	pc = 0x82EC84CC; continue 'dispatch;
	}
	// 82EC8438: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC843C: 7D6A19D6  mullw r11, r10, r3
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[3].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC8440: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EC8444: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EC8448: 40980084  bge cr6, 0x82ec84cc
	if !ctx.cr[6].lt {
	pc = 0x82EC84CC; continue 'dispatch;
	}
	// 82EC844C: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8450: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC8454: 7D2A3A14  add r9, r10, r7
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82EC8458: 3949000C  addi r10, r9, 0xc
	ctx.r[10].s64 = ctx.r[9].s64 + 12;
	pc = 0x82EC845C; continue 'dispatch;
            }
            0x82EC845C => {
    //   block [0x82EC845C..0x82EC849C)
	// 82EC845C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC8460: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EC8464: 419A0044  beq cr6, 0x82ec84a8
	if ctx.cr[6].eq {
	pc = 0x82EC84A8; continue 'dispatch;
	}
	// 82EC8468: C00AFFF8  lfs f0, -8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC846C: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8470: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC8474: 409A0028  bne cr6, 0x82ec849c
	if !ctx.cr[6].eq {
	pc = 0x82EC849C; continue 'dispatch;
	}
	// 82EC8478: C00AFFFC  lfs f0, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC847C: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8480: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC8484: 409A0018  bne cr6, 0x82ec849c
	if !ctx.cr[6].eq {
	pc = 0x82EC849C; continue 'dispatch;
	}
	// 82EC8488: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC848C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EC8490: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8494: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC8498: 419A0008  beq cr6, 0x82ec84a0
	if ctx.cr[6].eq {
	pc = 0x82EC84A0; continue 'dispatch;
	}
	pc = 0x82EC849C; continue 'dispatch;
            }
            0x82EC849C => {
    //   block [0x82EC849C..0x82EC84A0)
	// 82EC849C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x82EC84A0; continue 'dispatch;
            }
            0x82EC84A0 => {
    //   block [0x82EC84A0..0x82EC84A8)
	// 82EC84A0: 5508063F  clrlwi. r8, r8, 0x18
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EC84A4: 4082001C  bne 0x82ec84c0
	if !ctx.cr[0].eq {
	pc = 0x82EC84C0; continue 'dispatch;
	}
	pc = 0x82EC84A8; continue 'dispatch;
            }
            0x82EC84A8 => {
    //   block [0x82EC84A8..0x82EC84C0)
	// 82EC84A8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC84AC: 39290020  addi r9, r9, 0x20
	ctx.r[9].s64 = ctx.r[9].s64 + 32;
	// 82EC84B0: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82EC84B4: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EC84B8: 4198FFA4  blt cr6, 0x82ec845c
	if ctx.cr[6].lt {
	pc = 0x82EC845C; continue 'dispatch;
	}
	// 82EC84BC: 48000010  b 0x82ec84cc
	pc = 0x82EC84CC; continue 'dispatch;
            }
            0x82EC84C0 => {
    //   block [0x82EC84C0..0x82EC84CC)
	// 82EC84C0: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC84C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC84C8: 7D4B392E  stwx r10, r11, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), ctx.r[10].u32) };
	pc = 0x82EC84CC; continue 'dispatch;
            }
            0x82EC84CC => {
    //   block [0x82EC84CC..0x82EC84E4)
	// 82EC84CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC84D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC84D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC84D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC84DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC84E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC84E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC84E8 size=132
    let mut pc: u32 = 0x82EC84E8;
    'dispatch: loop {
        match pc {
            0x82EC84E8 => {
    //   block [0x82EC84E8..0x82EC8534)
	// 82EC84E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC84EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC84F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC84F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC84F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC84FC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EC8500: 4B2FBDE9  bl 0x821c42e8
	ctx.lr = 0x82EC8504;
	sub_821C42E8(ctx, base);
	// 82EC8504: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC8508: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC850C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC8510: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC8514: 40980044  bge cr6, 0x82ec8558
	if !ctx.cr[6].lt {
	pc = 0x82EC8558; continue 'dispatch;
	}
	// 82EC8518: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC851C: 7D6A19D6  mullw r11, r10, r3
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[3].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC8520: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EC8524: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC8528: 40980030  bge cr6, 0x82ec8558
	if !ctx.cr[6].lt {
	pc = 0x82EC8558; continue 'dispatch;
	}
	// 82EC852C: 55692834  slwi r9, r11, 5
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EC8530: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	pc = 0x82EC8534; continue 'dispatch;
            }
            0x82EC8534 => {
    //   block [0x82EC8534..0x82EC854C)
	// 82EC8534: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8538: 7D0B482E  lwzx r8, r11, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC853C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EC8540: 419A000C  beq cr6, 0x82ec854c
	if ctx.cr[6].eq {
	pc = 0x82EC854C; continue 'dispatch;
	}
	// 82EC8544: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC8548: 7D0B492E  stwx r8, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	pc = 0x82EC854C; continue 'dispatch;
            }
            0x82EC854C => {
    //   block [0x82EC854C..0x82EC8558)
	// 82EC854C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC8550: 39290020  addi r9, r9, 0x20
	ctx.r[9].s64 = ctx.r[9].s64 + 32;
	// 82EC8554: 4082FFE0  bne 0x82ec8534
	if !ctx.cr[0].eq {
	pc = 0x82EC8534; continue 'dispatch;
	}
	pc = 0x82EC8558; continue 'dispatch;
            }
            0x82EC8558 => {
    //   block [0x82EC8558..0x82EC856C)
	// 82EC8558: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC855C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC8560: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC8564: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC8568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC8570 size=208
    let mut pc: u32 = 0x82EC8570;
    'dispatch: loop {
        match pc {
            0x82EC8570 => {
    //   block [0x82EC8570..0x82EC85B4)
	// 82EC8570: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 82EC8574: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82EC8578: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC857C: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC8580: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC8584: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC8588: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC858C: 7CAB49D7  mullw. r5, r11, r9
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82EC8590: 418200A4  beq 0x82ec8634
	if ctx.cr[0].eq {
	pc = 0x82EC8634; continue 'dispatch;
	}
	// 82EC8594: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EC8598: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82EC859C: 38E9DBFC  addi r7, r9, -0x2404
	ctx.r[7].s64 = ctx.r[9].s64 + -9220;
	// 82EC85A0: 3D207FFF  lis r9, 0x7fff
	ctx.r[9].s64 = 2147418112;
	// 82EC85A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EC85A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC85AC: C1A40BEC  lfs f13, 0xbec(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3052 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC85B0: 6128FFFF  ori r8, r9, 0xffff
	ctx.r[8].u64 = ctx.r[9].u64 | 65535;
	pc = 0x82EC85B4; continue 'dispatch;
            }
            0x82EC85B4 => {
    //   block [0x82EC85B4..0x82EC8634)
	// 82EC85B4: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC85B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC85BC: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EC85C0: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 82EC85C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC85C8: 7FC9592E  stwx r30, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u32) };
	// 82EC85CC: C0070000  lfs f0, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC85D0: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC85D4: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EC85D8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EC85DC: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC85E0: C0070004  lfs f0, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC85E4: D0090008  stfs f0, 8(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC85E8: C0070008  lfs f0, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC85EC: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC85F0: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC85F4: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EC85F8: D1A90010  stfs f13, 0x10(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC85FC: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8600: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EC8604: 91090014  stw r8, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EC8608: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC860C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EC8610: 91090018  stw r8, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82EC8614: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8618: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EC861C: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82EC8620: 9089001C  stw r4, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EC8624: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC8628: 7FE9312E  stwx r31, r9, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[6].u32), ctx.r[31].u32) };
	// 82EC862C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC8630: 4198FF84  blt cr6, 0x82ec85b4
	if ctx.cr[6].lt {
	pc = 0x82EC85B4; continue 'dispatch;
	}
	pc = 0x82EC8634; continue 'dispatch;
            }
            0x82EC8634 => {
    //   block [0x82EC8634..0x82EC8640)
	// 82EC8634: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC8638: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82EC863C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC8640 size=4
    let mut pc: u32 = 0x82EC8640;
    'dispatch: loop {
        match pc {
            0x82EC8640 => {
    //   block [0x82EC8640..0x82EC8644)
	// 82EC8640: 4BFFFF30  b 0x82ec8570
	sub_82EC8570(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC8658 size=828
    let mut pc: u32 = 0x82EC8658;
    'dispatch: loop {
        match pc {
            0x82EC8658 => {
    //   block [0x82EC8658..0x82EC86C0)
	// 82EC8658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC865C: 4BDE0D95  bl 0x82ca93f0
	ctx.lr = 0x82EC8660;
	sub_82CA93D0(ctx, base);
	// 82EC8660: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8664: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8668: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC866C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EC8670: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8674: 3D607FFF  lis r11, 0x7fff
	ctx.r[11].s64 = 2147418112;
	// 82EC8678: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC867C: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EC8680: 617BFFFF  ori r27, r11, 0xffff
	ctx.r[27].u64 = ctx.r[11].u64 | 65535;
	// 82EC8684: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC8688: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC868C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC8690: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EC8694: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82EC8698: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82EC869C: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 82EC86A0: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC86A4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC86A8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC86AC: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 82EC86B0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EC86B4: 4098029C  bge cr6, 0x82ec8950
	if !ctx.cr[6].lt {
	pc = 0x82EC8950; continue 'dispatch;
	}
	// 82EC86B8: 82DF0030  lwz r22, 0x30(r31)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EC86BC: 3F008334  lis r24, -0x7ccc
	ctx.r[24].s64 = -2093744128;
	pc = 0x82EC86C0; continue 'dispatch;
            }
            0x82EC86C0 => {
    //   block [0x82EC86C0..0x82EC86D0)
	// 82EC86C0: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EC86C4: 7F0BB000  cmpw cr6, r11, r22
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[22].s32, &mut ctx.xer);
	// 82EC86C8: 40980260  bge cr6, 0x82ec8928
	if !ctx.cr[6].lt {
	pc = 0x82EC8928; continue 'dispatch;
	}
	// 82EC86CC: 835F0034  lwz r26, 0x34(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	pc = 0x82EC86D0; continue 'dispatch;
            }
            0x82EC86D0 => {
    //   block [0x82EC86D0..0x82EC8714)
	// 82EC86D0: 833F0038  lwz r25, 0x38(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EC86D4: 83DF003C  lwz r30, 0x3c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EC86D8: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 82EC86DC: 7F1ED800  cmpw cr6, r30, r27
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82EC86E0: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 82EC86E4: 409A00C8  bne cr6, 0x82ec87ac
	if !ctx.cr[6].eq {
	pc = 0x82EC87AC; continue 'dispatch;
	}
	// 82EC86E8: 92FF003C  stw r23, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[23].u32 ) };
	// 82EC86EC: 81780718  lwz r11, 0x718(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC86F0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC86F4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC86F8: 7D6B51D6  mullw r11, r11, r10
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC86FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC8700: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EC8704: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EC8708: 40990060  ble cr6, 0x82ec8768
	if !ctx.cr[6].gt {
	pc = 0x82EC8768; continue 'dispatch;
	}
	// 82EC870C: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC8710: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82EC8714; continue 'dispatch;
            }
            0x82EC8714 => {
    //   block [0x82EC8714..0x82EC8750)
	// 82EC8714: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EC8718: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC871C: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EC8720: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC8724: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82EC8728: 7FCB0194  addze r30, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[30].s64 = tmp.s64;
	// 82EC872C: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC8730: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EC8734: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC8738: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EC873C: 4B2FB715  bl 0x821c3e50
	ctx.lr = 0x82EC8740;
	sub_821C3E50(ctx, base);
	// 82EC8740: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8744: 4080000C  bge 0x82ec8750
	if !ctx.cr[0].lt {
	pc = 0x82EC8750; continue 'dispatch;
	}
	// 82EC8748: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82EC874C: 48000008  b 0x82ec8754
	pc = 0x82EC8754; continue 'dispatch;
            }
            0x82EC8750 => {
    //   block [0x82EC8750..0x82EC8754)
	// 82EC8750: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	pc = 0x82EC8754; continue 'dispatch;
            }
            0x82EC8754 => {
    //   block [0x82EC8754..0x82EC8768)
	// 82EC8754: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EC8758: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EC875C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EC8760: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EC8764: 4199FFB0  bgt cr6, 0x82ec8714
	if ctx.cr[6].gt {
	pc = 0x82EC8714; continue 'dispatch;
	}
	pc = 0x82EC8768; continue 'dispatch;
            }
            0x82EC8768 => {
    //   block [0x82EC8768..0x82EC879C)
	// 82EC8768: 83DF003C  lwz r30, 0x3c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EC876C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC8770: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC8774: 57C9103A  slwi r9, r30, 2
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EC8778: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC877C: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC8780: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC8784: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC8788: 4B2FB6C9  bl 0x821c3e50
	ctx.lr = 0x82EC878C;
	sub_821C3E50(ctx, base);
	// 82EC878C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8790: 4181000C  bgt 0x82ec879c
	if ctx.cr[0].gt {
	pc = 0x82EC879C; continue 'dispatch;
	}
	// 82EC8794: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82EC8798: 4800000C  b 0x82ec87a4
	pc = 0x82EC87A4; continue 'dispatch;
            }
            0x82EC879C => {
    //   block [0x82EC879C..0x82EC87A4)
	// 82EC879C: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EC87A0: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC87A4; continue 'dispatch;
            }
            0x82EC87A4 => {
    //   block [0x82EC87A4..0x82EC87AC)
	// 82EC87A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC87A8: 997F0048  stb r11, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u8 ) };
	pc = 0x82EC87AC; continue 'dispatch;
            }
            0x82EC87AC => {
    //   block [0x82EC87AC..0x82EC87CC)
	// 82EC87AC: 897F0048  lbz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC87B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC87B4: 418200AC  beq 0x82ec8860
	if ctx.cr[0].eq {
	pc = 0x82EC8860; continue 'dispatch;
	}
	// 82EC87B8: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC87BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC87C0: 41980094  blt cr6, 0x82ec8854
	if ctx.cr[6].lt {
	pc = 0x82EC8854; continue 'dispatch;
	}
	// 82EC87C4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC87C8: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82EC87CC; continue 'dispatch;
            }
            0x82EC87CC => {
    //   block [0x82EC87CC..0x82EC8840)
	// 82EC87CC: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC87D0: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC87D4: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC87D8: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC87DC: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82EC87E0: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC87E4: 7F07D000  cmpw cr6, r7, r26
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82EC87E8: 409A006C  bne cr6, 0x82ec8854
	if !ctx.cr[6].eq {
	pc = 0x82EC8854; continue 'dispatch;
	}
	// 82EC87EC: 80EB0018  lwz r7, 0x18(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC87F0: 7F07C800  cmpw cr6, r7, r25
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[25].s32, &mut ctx.xer);
	// 82EC87F4: 409A0060  bne cr6, 0x82ec8854
	if !ctx.cr[6].eq {
	pc = 0x82EC8854; continue 'dispatch;
	}
	// 82EC87F8: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC87FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EC8800: 419A0040  beq cr6, 0x82ec8840
	if ctx.cr[6].eq {
	pc = 0x82EC8840; continue 'dispatch;
	}
	// 82EC8804: C1AB0004  lfs f13, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8808: C01F004C  lfs f0, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC880C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC8810: C19F0050  lfs f12, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC8814: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8818: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC881C: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC8820: C19F0054  lfs f12, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC8824: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC8828: C17F0058  lfs f11, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC882C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC8830: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC8834: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC8838: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC883C: 41980120  blt cr6, 0x82ec895c
	if ctx.cr[6].lt {
	pc = 0x82EC895C; continue 'dispatch;
	}
	pc = 0x82EC8840; continue 'dispatch;
            }
            0x82EC8840 => {
    //   block [0x82EC8840..0x82EC8854)
	// 82EC8840: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 82EC8844: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82EC8848: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC884C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC8850: 4098FF7C  bge cr6, 0x82ec87cc
	if !ctx.cr[6].lt {
	pc = 0x82EC87CC; continue 'dispatch;
	}
	pc = 0x82EC8854; continue 'dispatch;
            }
            0x82EC8854 => {
    //   block [0x82EC8854..0x82EC8860)
	// 82EC8854: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 82EC8858: 9AFF0048  stb r23, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[23].u8 ) };
	// 82EC885C: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC8860; continue 'dispatch;
            }
            0x82EC8860 => {
    //   block [0x82EC8860..0x82EC8884)
	// 82EC8860: 81780718  lwz r11, 0x718(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC8864: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC8868: 813F0044  lwz r9, 0x44(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC886C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC8870: 7CEB51D6  mullw r7, r11, r10
	ctx.r[7].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82EC8874: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EC8878: 40980094  bge cr6, 0x82ec890c
	if !ctx.cr[6].lt {
	pc = 0x82EC890C; continue 'dispatch;
	}
	// 82EC887C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC8880: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82EC8884; continue 'dispatch;
            }
            0x82EC8884 => {
    //   block [0x82EC8884..0x82EC88F8)
	// 82EC8884: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC8888: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC888C: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC8890: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC8894: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82EC8898: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC889C: 7F06D000  cmpw cr6, r6, r26
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82EC88A0: 409A006C  bne cr6, 0x82ec890c
	if !ctx.cr[6].eq {
	pc = 0x82EC890C; continue 'dispatch;
	}
	// 82EC88A4: 80CB0018  lwz r6, 0x18(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC88A8: 7F06C800  cmpw cr6, r6, r25
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[25].s32, &mut ctx.xer);
	// 82EC88AC: 409A0060  bne cr6, 0x82ec890c
	if !ctx.cr[6].eq {
	pc = 0x82EC890C; continue 'dispatch;
	}
	// 82EC88B0: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC88B4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EC88B8: 419A0040  beq cr6, 0x82ec88f8
	if ctx.cr[6].eq {
	pc = 0x82EC88F8; continue 'dispatch;
	}
	// 82EC88BC: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC88C0: C01F004C  lfs f0, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC88C4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC88C8: C19F0050  lfs f12, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC88CC: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC88D0: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC88D4: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC88D8: C19F0054  lfs f12, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC88DC: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC88E0: C17F0058  lfs f11, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC88E4: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC88E8: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC88EC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC88F0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC88F4: 41980090  blt cr6, 0x82ec8984
	if ctx.cr[6].lt {
	pc = 0x82EC8984; continue 'dispatch;
	}
	pc = 0x82EC88F8; continue 'dispatch;
            }
            0x82EC88F8 => {
    //   block [0x82EC88F8..0x82EC890C)
	// 82EC88F8: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82EC88FC: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82EC8900: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC8904: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EC8908: 4198FF7C  blt cr6, 0x82ec8884
	if ctx.cr[6].lt {
	pc = 0x82EC8884; continue 'dispatch;
	}
	pc = 0x82EC890C; continue 'dispatch;
            }
            0x82EC890C => {
    //   block [0x82EC890C..0x82EC8928)
	// 82EC890C: 39790001  addi r11, r25, 1
	ctx.r[11].s64 = ctx.r[25].s64 + 1;
	// 82EC8910: 937F003C  stw r27, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[27].u32 ) };
	// 82EC8914: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82EC8918: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC891C: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EC8920: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC8924: 4198FDAC  blt cr6, 0x82ec86d0
	if ctx.cr[6].lt {
	pc = 0x82EC86D0; continue 'dispatch;
	}
	pc = 0x82EC8928; continue 'dispatch;
            }
            0x82EC8928 => {
    //   block [0x82EC8928..0x82EC8950)
	// 82EC8928: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EC892C: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EC8930: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC8934: 937F003C  stw r27, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[27].u32 ) };
	// 82EC8938: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82EC893C: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82EC8940: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC8944: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EC8948: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC894C: 4198FD74  blt cr6, 0x82ec86c0
	if ctx.cr[6].lt {
	pc = 0x82EC86C0; continue 'dispatch;
	}
	pc = 0x82EC8950; continue 'dispatch;
            }
            0x82EC8950 => {
    //   block [0x82EC8950..0x82EC8954)
	// 82EC8950: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC8954; continue 'dispatch;
            }
            0x82EC8954 => {
    //   block [0x82EC8954..0x82EC895C)
	// 82EC8954: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EC8958: 4BDE0AE8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EC895C => {
    //   block [0x82EC895C..0x82EC8968)
	// 82EC895C: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC8960: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EC8964: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC8968; continue 'dispatch;
            }
            0x82EC8968 => {
    //   block [0x82EC8968..0x82EC8984)
	// 82EC8968: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC896C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8970: 7D28482E  lwzx r9, r8, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC8974: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82EC8978: 552B2834  slwi r11, r9, 5
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC897C: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC8980: 4BFFFFD4  b 0x82ec8954
	pc = 0x82EC8954; continue 'dispatch;
            }
            0x82EC8984 => {
    //   block [0x82EC8984..0x82EC8994)
	// 82EC8984: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC8988: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EC898C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC8990: 4BFFFFD8  b 0x82ec8968
	pc = 0x82EC8968; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC8998 size=196
    let mut pc: u32 = 0x82EC8998;
    'dispatch: loop {
        match pc {
            0x82EC8998 => {
    //   block [0x82EC8998..0x82EC89F0)
	// 82EC8998: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC899C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC89A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC89A4: 396B1B30  addi r11, r11, 0x1b30
	ctx.r[11].s64 = ctx.r[11].s64 + 6960;
	// 82EC89A8: C00A0A7C  lfs f0, 0xa7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC89AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC89B0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EC89B4: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC89B8: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EC89BC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EC89C0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC89C4: C1AA0BFC  lfs f13, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC89C8: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82EC89CC: D1A30014  stfs f13, 0x14(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC89D0: C1A90C14  lfs f13, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC89D4: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EC89D8: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC89DC: 816A0718  lwz r11, 0x718(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC89E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC89E4: 4182000C  beq 0x82ec89f0
	if ctx.cr[0].eq {
	pc = 0x82EC89F0; continue 'dispatch;
	}
	// 82EC89E8: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC89EC: 48000008  b 0x82ec89f4
	pc = 0x82EC89F4; continue 'dispatch;
            }
            0x82EC89F0 => {
    //   block [0x82EC89F0..0x82EC89F4)
	// 82EC89F0: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	pc = 0x82EC89F4; continue 'dispatch;
            }
            0x82EC89F4 => {
    //   block [0x82EC89F4..0x82EC8A04)
	// 82EC89F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC89F8: 4182000C  beq 0x82ec8a04
	if ctx.cr[0].eq {
	pc = 0x82EC8A04; continue 'dispatch;
	}
	// 82EC89FC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8A00: 48000008  b 0x82ec8a08
	pc = 0x82EC8A08; continue 'dispatch;
            }
            0x82EC8A04 => {
    //   block [0x82EC8A04..0x82EC8A08)
	// 82EC8A04: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EC8A08; continue 'dispatch;
            }
            0x82EC8A08 => {
    //   block [0x82EC8A08..0x82EC8A2C)
	// 82EC8A08: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC8A0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8A10: C00B0C70  lfs f0, 0xc70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8A14: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC8A18: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC8A1C: 816A0718  lwz r11, 0x718(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC8A20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8A24: 41820008  beq 0x82ec8a2c
	if ctx.cr[0].eq {
	pc = 0x82EC8A2C; continue 'dispatch;
	}
	// 82EC8A28: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EC8A2C; continue 'dispatch;
            }
            0x82EC8A2C => {
    //   block [0x82EC8A2C..0x82EC8A5C)
	// 82EC8A2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8A30: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC8A34: C00BBE10  lfs f0, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8A38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8A3C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC8A40: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC8A44: 99430020  stb r10, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 82EC8A48: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8A4C: D003004C  stfs f0, 0x4c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EC8A50: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC8A54: D0030054  stfs f0, 0x54(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC8A58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8A60 size=148
    let mut pc: u32 = 0x82EC8A60;
    'dispatch: loop {
        match pc {
            0x82EC8A60 => {
    //   block [0x82EC8A60..0x82EC8AB8)
	// 82EC8A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8A68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC8A6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC8A70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8A74: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8A78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC8A7C: 396B1B30  addi r11, r11, 0x1b30
	ctx.r[11].s64 = ctx.r[11].s64 + 6960;
	// 82EC8A80: 3D4082ED  lis r10, -0x7d13
	ctx.r[10].s64 = -2098397184;
	// 82EC8A84: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EC8A88: 388A8648  addi r4, r10, -0x79b8
	ctx.r[4].s64 = ctx.r[10].s64 + -31160;
	// 82EC8A8C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC8A90: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC8A94: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC8A98: 4BFBA6D1  bl 0x82e83168
	ctx.lr = 0x82EC8A9C;
	sub_82E83168(ctx, base);
	// 82EC8A9C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8AA0: 3FC08330  lis r30, -0x7cd0
	ctx.r[30].s64 = -2094006272;
	// 82EC8AA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8AA8: 41820010  beq 0x82ec8ab8
	if ctx.cr[0].eq {
	pc = 0x82EC8AB8; continue 'dispatch;
	}
	// 82EC8AAC: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC8AB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC8AB4: 4E800421  bctrl
	ctx.lr = 0x82EC8AB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC8AB8 => {
    //   block [0x82EC8AB8..0x82EC8AD0)
	// 82EC8AB8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC8ABC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8AC0: 41820010  beq 0x82ec8ad0
	if ctx.cr[0].eq {
	pc = 0x82EC8AD0; continue 'dispatch;
	}
	// 82EC8AC4: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC8AC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC8ACC: 4E800421  bctrl
	ctx.lr = 0x82EC8AD0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC8AD0 => {
    //   block [0x82EC8AD0..0x82EC8AF4)
	// 82EC8AD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC8AD4: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC8AD8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC8ADC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC8AE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC8AE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC8AE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC8AEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC8AF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC8AF8 size=328
    let mut pc: u32 = 0x82EC8AF8;
    'dispatch: loop {
        match pc {
            0x82EC8AF8 => {
    //   block [0x82EC8AF8..0x82EC8B1C)
	// 82EC8AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8AFC: 4BDE090D  bl 0x82ca9408
	ctx.lr = 0x82EC8B00;
	sub_82CA93D0(ctx, base);
	// 82EC8B00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8B04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC8B08: 4BFBC8A1  bl 0x82e853a8
	ctx.lr = 0x82EC8B0C;
	sub_82E853A8(ctx, base);
	// 82EC8B0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC8B10: 4082000C  bne 0x82ec8b1c
	if !ctx.cr[0].eq {
	pc = 0x82EC8B1C; continue 'dispatch;
	}
	// 82EC8B14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC8B18: 48000120  b 0x82ec8c38
	pc = 0x82EC8C38; continue 'dispatch;
            }
            0x82EC8B1C => {
    //   block [0x82EC8B1C..0x82EC8B4C)
	// 82EC8B1C: 3F808334  lis r28, -0x7ccc
	ctx.r[28].s64 = -2093744128;
	// 82EC8B20: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC8B24: 3D4007FF  lis r10, 0x7ff
	ctx.r[10].s64 = 134152192;
	// 82EC8B28: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82EC8B2C: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82EC8B30: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC8B34: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC8B38: 7FEB49D6  mullw r31, r11, r9
	ctx.r[31].s32 = ((ctx.r[11].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[31].s64 = ctx.r[31].s32 as i64;
	// 82EC8B3C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC8B40: 57E32834  slwi r3, r31, 5
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EC8B44: 40990008  ble cr6, 0x82ec8b4c
	if !ctx.cr[6].gt {
	pc = 0x82EC8B4C; continue 'dispatch;
	}
	// 82EC8B48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x82EC8B4C; continue 'dispatch;
            }
            0x82EC8B4C => {
    //   block [0x82EC8B4C..0x82EC8B7C)
	// 82EC8B4C: 4B74DDDD  bl 0x82616928
	ctx.lr = 0x82EC8B50;
	sub_82616928(ctx, base);
	// 82EC8B50: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8B54: 41820060  beq 0x82ec8bb4
	if ctx.cr[0].eq {
	pc = 0x82EC8BB4; continue 'dispatch;
	}
	// 82EC8B58: 353FFFFF  addic. r9, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EC8B5C: 41800050  blt 0x82ec8bac
	if ctx.cr[0].lt {
	pc = 0x82EC8BAC; continue 'dispatch;
	}
	// 82EC8B60: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82EC8B64: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EC8B68: 3D407FFF  lis r10, 0x7fff
	ctx.r[10].s64 = 2147418112;
	// 82EC8B6C: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 82EC8B70: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82EC8B74: C1A70BEC  lfs f13, 0xbec(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3052 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8B78: C0080C18  lfs f0, 0xc18(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EC8B7C; continue 'dispatch;
            }
            0x82EC8B7C => {
    //   block [0x82EC8B7C..0x82EC8BAC)
	// 82EC8B7C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC8B80: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EC8B84: 910BFFF4  stw r8, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[8].u32 ) };
	// 82EC8B88: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82EC8B8C: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82EC8B90: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC8B94: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC8B98: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC8B9C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EC8BA0: 93AB0010  stw r29, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82EC8BA4: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82EC8BA8: 4080FFD4  bge 0x82ec8b7c
	if !ctx.cr[0].lt {
	pc = 0x82EC8B7C; continue 'dispatch;
	}
	pc = 0x82EC8BAC; continue 'dispatch;
            }
            0x82EC8BAC => {
    //   block [0x82EC8BAC..0x82EC8BB4)
	// 82EC8BAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC8BB0: 48000008  b 0x82ec8bb8
	pc = 0x82EC8BB8; continue 'dispatch;
            }
            0x82EC8BB4 => {
    //   block [0x82EC8BB4..0x82EC8BB8)
	// 82EC8BB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EC8BB8; continue 'dispatch;
            }
            0x82EC8BB8 => {
    //   block [0x82EC8BB8..0x82EC8BD4)
	// 82EC8BB8: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82EC8BBC: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC8BC0: 57E3103A  slwi r3, r31, 2
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EC8BC4: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82EC8BC8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC8BCC: 40990008  ble cr6, 0x82ec8bd4
	if !ctx.cr[6].gt {
	pc = 0x82EC8BD4; continue 'dispatch;
	}
	// 82EC8BD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x82EC8BD4; continue 'dispatch;
            }
            0x82EC8BD4 => {
    //   block [0x82EC8BD4..0x82EC8BF0)
	// 82EC8BD4: 4B74DD55  bl 0x82616928
	ctx.lr = 0x82EC8BD8;
	sub_82616928(ctx, base);
	// 82EC8BD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC8BDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EC8BE0: 907E0008  stw r3, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82EC8BE4: 419A003C  beq cr6, 0x82ec8c20
	if ctx.cr[6].eq {
	pc = 0x82EC8C20; continue 'dispatch;
	}
	// 82EC8BE8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC8BEC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82EC8BF0; continue 'dispatch;
            }
            0x82EC8BF0 => {
    //   block [0x82EC8BF0..0x82EC8C20)
	// 82EC8BF0: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8BF4: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82EC8BF8: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC8BFC: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82EC8C00: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC8C04: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82EC8C08: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82EC8C0C: 90E8001C  stw r7, 0x1c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 82EC8C10: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC8C14: 7CC9412E  stwx r6, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[6].u32) };
	// 82EC8C18: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC8C1C: 4198FFD4  blt cr6, 0x82ec8bf0
	if ctx.cr[6].lt {
	pc = 0x82EC8BF0; continue 'dispatch;
	}
	pc = 0x82EC8C20; continue 'dispatch;
            }
            0x82EC8C20 => {
    //   block [0x82EC8C20..0x82EC8C38)
	// 82EC8C20: 3D6082ED  lis r11, -0x7d13
	ctx.r[11].s64 = -2098397184;
	// 82EC8C24: 807C0718  lwz r3, 0x718(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC8C28: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC8C2C: 388B8648  addi r4, r11, -0x79b8
	ctx.r[4].s64 = ctx.r[11].s64 + -31160;
	// 82EC8C30: 4BFBA3D9  bl 0x82e83008
	ctx.lr = 0x82EC8C34;
	sub_82E83008(ctx, base);
	// 82EC8C34: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC8C38; continue 'dispatch;
            }
            0x82EC8C38 => {
    //   block [0x82EC8C38..0x82EC8C40)
	// 82EC8C38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC8C3C: 4BDE081C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC8C40 size=340
    let mut pc: u32 = 0x82EC8C40;
    'dispatch: loop {
        match pc {
            0x82EC8C40 => {
    //   block [0x82EC8C40..0x82EC8C94)
	// 82EC8C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8C44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8C48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8C4C: EC00082C  fsqrts f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64).sqrt() as f32) as f64;
	// 82EC8C50: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8C54: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC8C58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8C5C: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC8C60: ED2C0028  fsubs f9, f12, f0
	ctx.f[9].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC8C64: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC8C68: C143001C  lfs f10, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC8C6C: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC8C70: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8C74: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82EC8C78: ED6B5024  fdivs f11, f11, f10
	ctx.f[11].f64 = ((ctx.f[11].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EC8C7C: FD60581E  fctiwz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82EC8C80: 41980014  blt cr6, 0x82ec8c94
	if ctx.cr[6].lt {
	pc = 0x82EC8C94; continue 'dispatch;
	}
	// 82EC8C84: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8C88: 7D605FAE  stfiwx f11, 0, r11
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8C8C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8C90: 48000014  b 0x82ec8ca4
	pc = 0x82EC8CA4; continue 'dispatch;
            }
            0x82EC8C94 => {
    //   block [0x82EC8C94..0x82EC8CA4)
	// 82EC8C94: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8C98: 7D605FAE  stfiwx f11, 0, r11
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8C9C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8CA0: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC8CA4; continue 'dispatch;
            }
            0x82EC8CA4 => {
    //   block [0x82EC8CA4..0x82EC8CC8)
	// 82EC8CA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC8CA8: 91230024  stw r9, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 82EC8CAC: EDAD5024  fdivs f13, f13, f10
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EC8CB0: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82EC8CB4: 41980014  blt cr6, 0x82ec8cc8
	if ctx.cr[6].lt {
	pc = 0x82EC8CC8; continue 'dispatch;
	}
	// 82EC8CB8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8CBC: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8CC0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8CC4: 48000014  b 0x82ec8cd8
	pc = 0x82EC8CD8; continue 'dispatch;
            }
            0x82EC8CC8 => {
    //   block [0x82EC8CC8..0x82EC8CD8)
	// 82EC8CC8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8CCC: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8CD0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8CD4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC8CD8; continue 'dispatch;
            }
            0x82EC8CD8 => {
    //   block [0x82EC8CD8..0x82EC8D00)
	// 82EC8CD8: EDA95024  fdivs f13, f9, f10
	ctx.f[13].f64 = ((ctx.f[9].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EC8CDC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC8CE0: FF090000  fcmpu cr6, f9, f0
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[0].f64);
	// 82EC8CE4: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EC8CE8: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82EC8CEC: 41980014  blt cr6, 0x82ec8d00
	if ctx.cr[6].lt {
	pc = 0x82EC8D00; continue 'dispatch;
	}
	// 82EC8CF0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8CF4: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8CF8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8CFC: 48000014  b 0x82ec8d10
	pc = 0x82EC8D10; continue 'dispatch;
            }
            0x82EC8D00 => {
    //   block [0x82EC8D00..0x82EC8D10)
	// 82EC8D00: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8D04: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8D08: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8D0C: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC8D10; continue 'dispatch;
            }
            0x82EC8D10 => {
    //   block [0x82EC8D10..0x82EC8D34)
	// 82EC8D10: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EC8D14: 9143002C  stw r10, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82EC8D18: EC0C5024  fdivs f0, f12, f10
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EC8D1C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82EC8D20: 41980014  blt cr6, 0x82ec8d34
	if ctx.cr[6].lt {
	pc = 0x82EC8D34; continue 'dispatch;
	}
	// 82EC8D24: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8D28: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8D2C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8D30: 48000014  b 0x82ec8d44
	pc = 0x82EC8D44; continue 'dispatch;
            }
            0x82EC8D34 => {
    //   block [0x82EC8D34..0x82EC8D44)
	// 82EC8D34: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8D38: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8D3C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8D40: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC8D44; continue 'dispatch;
            }
            0x82EC8D44 => {
    //   block [0x82EC8D44..0x82EC8D94)
	// 82EC8D44: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82EC8D48: 91230034  stw r9, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[9].u32 ) };
	// 82EC8D4C: 3D607FFF  lis r11, 0x7fff
	ctx.r[11].s64 = 2147418112;
	// 82EC8D50: 91430038  stw r10, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82EC8D54: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82EC8D58: 91030030  stw r8, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[8].u32 ) };
	// 82EC8D5C: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8D60: D003004C  stfs f0, 0x4c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EC8D64: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8D68: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC8D6C: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8D70: D0030054  stfs f0, 0x54(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC8D74: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82EC8D78: D0230058  stfs f1, 0x58(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC8D7C: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EC8D80: 4BFFF8D9  bl 0x82ec8658
	ctx.lr = 0x82EC8D84;
	sub_82EC8658(ctx, base);
	// 82EC8D84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC8D88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC8D8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC8D90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8D98 size=56
    let mut pc: u32 = 0x82EC8D98;
    'dispatch: loop {
        match pc {
            0x82EC8D98 => {
    //   block [0x82EC8D98..0x82EC8DBC)
	// 82EC8D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8DA0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8DA4: 3860005C  li r3, 0x5c
	ctx.r[3].s64 = 92;
	// 82EC8DA8: 4B74DB81  bl 0x82616928
	ctx.lr = 0x82EC8DAC;
	sub_82616928(ctx, base);
	// 82EC8DAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8DB0: 4182000C  beq 0x82ec8dbc
	if ctx.cr[0].eq {
	pc = 0x82EC8DBC; continue 'dispatch;
	}
	// 82EC8DB4: 4BFFFBE5  bl 0x82ec8998
	ctx.lr = 0x82EC8DB8;
	sub_82EC8998(ctx, base);
	// 82EC8DB8: 48000008  b 0x82ec8dc0
	pc = 0x82EC8DC0; continue 'dispatch;
            }
            0x82EC8DBC => {
    //   block [0x82EC8DBC..0x82EC8DC0)
	// 82EC8DBC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC8DC0; continue 'dispatch;
            }
            0x82EC8DC0 => {
    //   block [0x82EC8DC0..0x82EC8DD0)
	// 82EC8DC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC8DC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC8DC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC8DCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8DD0 size=88
    let mut pc: u32 = 0x82EC8DD0;
    'dispatch: loop {
        match pc {
            0x82EC8DD0 => {
    //   block [0x82EC8DD0..0x82EC8E0C)
	// 82EC8DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8DD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8DD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC8DDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC8DE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8DE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC8DE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC8DEC: 4BFFFC75  bl 0x82ec8a60
	ctx.lr = 0x82EC8DF0;
	sub_82EC8A60(ctx, base);
	// 82EC8DF0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC8DF4: 41820018  beq 0x82ec8e0c
	if ctx.cr[0].eq {
	pc = 0x82EC8E0C; continue 'dispatch;
	}
	// 82EC8DF8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC8DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8E00: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC8E04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC8E08: 4E800421  bctrl
	ctx.lr = 0x82EC8E0C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC8E0C => {
    //   block [0x82EC8E0C..0x82EC8E28)
	// 82EC8E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8E10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC8E14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC8E18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC8E1C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC8E20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC8E24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8E28 size=156
    let mut pc: u32 = 0x82EC8E28;
    'dispatch: loop {
        match pc {
            0x82EC8E28 => {
    //   block [0x82EC8E28..0x82EC8E6C)
	// 82EC8E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8E2C: 4BDE05D5  bl 0x82ca9400
	ctx.lr = 0x82EC8E30;
	sub_82CA93D0(ctx, base);
	// 82EC8E30: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8E34: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC8E38: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EC8E3C: 3BEBC3A0  addi r31, r11, -0x3c60
	ctx.r[31].s64 = ctx.r[11].s64 + -15456;
	// 82EC8E40: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC8E44: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC8E48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC8E4C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82EC8E50: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82EC8E54: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82EC8E58: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 82EC8E5C: 4B31F81D  bl 0x821e8678
	ctx.lr = 0x82EC8E60;
	sub_821E8678(ctx, base);
	// 82EC8E60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8E64: 41820008  beq 0x82ec8e6c
	if ctx.cr[0].eq {
	pc = 0x82EC8E6C; continue 'dispatch;
	}
	// 82EC8E68: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82EC8E6C; continue 'dispatch;
            }
            0x82EC8E6C => {
    //   block [0x82EC8E6C..0x82EC8E88)
	// 82EC8E6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC8E70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC8E74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC8E78: 4B31F801  bl 0x821e8678
	ctx.lr = 0x82EC8E7C;
	sub_821E8678(ctx, base);
	// 82EC8E7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8E80: 41820008  beq 0x82ec8e88
	if ctx.cr[0].eq {
	pc = 0x82EC8E88; continue 'dispatch;
	}
	// 82EC8E84: 83830004  lwz r28, 4(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82EC8E88; continue 'dispatch;
            }
            0x82EC8E88 => {
    //   block [0x82EC8E88..0x82EC8EAC)
	// 82EC8E88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC8E8C: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82EC8E90: 419A001C  beq cr6, 0x82ec8eac
	if ctx.cr[6].eq {
	pc = 0x82EC8EAC; continue 'dispatch;
	}
	// 82EC8E94: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 82EC8E98: 419A0014  beq cr6, 0x82ec8eac
	if ctx.cr[6].eq {
	pc = 0x82EC8EAC; continue 'dispatch;
	}
	// 82EC8E9C: 7F1DE000  cmpw cr6, r29, r28
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82EC8EA0: 419A000C  beq cr6, 0x82ec8eac
	if ctx.cr[6].eq {
	pc = 0x82EC8EAC; continue 'dispatch;
	}
	// 82EC8EA4: 997B0000  stb r11, 0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82EC8EA8: 4800000C  b 0x82ec8eb4
	pc = 0x82EC8EB4; continue 'dispatch;
            }
            0x82EC8EAC => {
    //   block [0x82EC8EAC..0x82EC8EB4)
	// 82EC8EAC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC8EB0: 995B0000  stb r10, 0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	pc = 0x82EC8EB4; continue 'dispatch;
            }
            0x82EC8EB4 => {
    //   block [0x82EC8EB4..0x82EC8EC4)
	// 82EC8EB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC8EB8: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82EC8EBC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC8EC0: 4BDE0590  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC8EC8 size=12
    let mut pc: u32 = 0x82EC8EC8;
    'dispatch: loop {
        match pc {
            0x82EC8EC8 => {
    //   block [0x82EC8EC8..0x82EC8ED4)
	// 82EC8EC8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC8ECC: 386BE5C0  addi r3, r11, -0x1a40
	ctx.r[3].s64 = ctx.r[11].s64 + -6720;
	// 82EC8ED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8ED8 size=92
    let mut pc: u32 = 0x82EC8ED8;
    'dispatch: loop {
        match pc {
            0x82EC8ED8 => {
    //   block [0x82EC8ED8..0x82EC8F28)
	// 82EC8ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8EDC: 4BDE052D  bl 0x82ca9408
	ctx.lr = 0x82EC8EE0;
	sub_82CA93D0(ctx, base);
	// 82EC8EE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8EE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC8EE8: 386000D4  li r3, 0xd4
	ctx.r[3].s64 = 212;
	// 82EC8EEC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC8EF0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EC8EF4: 4B74DA35  bl 0x82616928
	ctx.lr = 0x82EC8EF8;
	sub_82616928(ctx, base);
	// 82EC8EF8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC8EFC: 4182002C  beq 0x82ec8f28
	if ctx.cr[0].eq {
	pc = 0x82EC8F28; continue 'dispatch;
	}
	// 82EC8F00: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82EC8F04: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC8F08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8F10: 4BFFDCF9  bl 0x82ec6c08
	ctx.lr = 0x82EC8F14;
	sub_82EC6C08(ctx, base);
	// 82EC8F14: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8F18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8F1C: 396BB3B4  addi r11, r11, -0x4c4c
	ctx.r[11].s64 = ctx.r[11].s64 + -19532;
	// 82EC8F20: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC8F24: 48000008  b 0x82ec8f2c
	pc = 0x82EC8F2C; continue 'dispatch;
            }
            0x82EC8F28 => {
    //   block [0x82EC8F28..0x82EC8F2C)
	// 82EC8F28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC8F2C; continue 'dispatch;
            }
            0x82EC8F2C => {
    //   block [0x82EC8F2C..0x82EC8F34)
	// 82EC8F2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC8F30: 4BDE0528  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC8F38 size=72
    let mut pc: u32 = 0x82EC8F38;
    'dispatch: loop {
        match pc {
            0x82EC8F38 => {
    //   block [0x82EC8F38..0x82EC8F80)
	// 82EC8F38: C1A40034  lfs f13, 0x34(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8F3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC8F40: C0050034  lfs f0, 0x34(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8F44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC8F48: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC8F4C: C1850038  lfs f12, 0x38(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC8F50: C1A40038  lfs f13, 0x38(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8F54: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC8F58: C164003C  lfs f11, 0x3c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC8F5C: C185003C  lfs f12, 0x3c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC8F60: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC8F64: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC8F68: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC8F6C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC8F70: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC8F74: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC8F78: 99670000  stb r11, 0(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82EC8F7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8F80 size=100
    let mut pc: u32 = 0x82EC8F80;
    'dispatch: loop {
        match pc {
            0x82EC8F80 => {
    //   block [0x82EC8F80..0x82EC8FC0)
	// 82EC8F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8F88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC8F8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8F90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC8F94: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8F98: 396BB408  addi r11, r11, -0x4bf8
	ctx.r[11].s64 = ctx.r[11].s64 + -19448;
	// 82EC8F9C: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC8FA0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8FA4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC8FA8: 41820018  beq 0x82ec8fc0
	if ctx.cr[0].eq {
	pc = 0x82EC8FC0; continue 'dispatch;
	}
	// 82EC8FAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC8FB0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EC8FB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC8FB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC8FBC: 4E800421  bctrl
	ctx.lr = 0x82EC8FC0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC8FC0 => {
    //   block [0x82EC8FC0..0x82EC8FE4)
	// 82EC8FC0: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82EC8FC4: 4BFF03BD  bl 0x82eb9380
	ctx.lr = 0x82EC8FC8;
	sub_82EB9380(ctx, base);
	// 82EC8FC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8FCC: 4BFBD72D  bl 0x82e866f8
	ctx.lr = 0x82EC8FD0;
	sub_82E866F8(ctx, base);
	// 82EC8FD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC8FD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC8FD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC8FDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC8FE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8FE8 size=88
    let mut pc: u32 = 0x82EC8FE8;
    'dispatch: loop {
        match pc {
            0x82EC8FE8 => {
    //   block [0x82EC8FE8..0x82EC9024)
	// 82EC8FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8FF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC8FF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC8FF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8FFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC9000: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC9004: 4BFFFF7D  bl 0x82ec8f80
	ctx.lr = 0x82EC9008;
	sub_82EC8F80(ctx, base);
	// 82EC9008: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC900C: 41820018  beq 0x82ec9024
	if ctx.cr[0].eq {
	pc = 0x82EC9024; continue 'dispatch;
	}
	// 82EC9010: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC9014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC9018: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC901C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC9020: 4E800421  bctrl
	ctx.lr = 0x82EC9024;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC9024 => {
    //   block [0x82EC9024..0x82EC9040)
	// 82EC9024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC9028: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC902C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC9030: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC9034: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC9038: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC903C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC9040 size=80
    let mut pc: u32 = 0x82EC9040;
    'dispatch: loop {
        match pc {
            0x82EC9040 => {
    //   block [0x82EC9040..0x82EC9090)
	// 82EC9040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC9048: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC904C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC9050: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC9054: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC9058: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC905C: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 82EC9060: 917F00B8  stw r11, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82EC9064: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EC9068: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EC906C: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EC9070: 4BFF0311  bl 0x82eb9380
	ctx.lr = 0x82EC9074;
	sub_82EB9380(ctx, base);
	// 82EC9074: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC9078: 4BFFFF09  bl 0x82ec8f80
	ctx.lr = 0x82EC907C;
	sub_82EC8F80(ctx, base);
	// 82EC907C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC9080: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC9084: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC9088: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC908C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC9090 size=204
    let mut pc: u32 = 0x82EC9090;
    'dispatch: loop {
        match pc {
            0x82EC9090 => {
    //   block [0x82EC9090..0x82EC915C)
	// 82EC9090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC9098: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC909C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC90A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC90A4: 480011B5  bl 0x82eca258
	ctx.lr = 0x82EC90A8;
	sub_82ECA258(ctx, base);
	// 82EC90A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC90AC: 395F007C  addi r10, r31, 0x7c
	ctx.r[10].s64 = ctx.r[31].s64 + 124;
	// 82EC90B0: 38EBB43C  addi r7, r11, -0x4bc4
	ctx.r[7].s64 = ctx.r[11].s64 + -19396;
	// 82EC90B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC90B8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC90BC: 38CBA8F0  addi r6, r11, -0x5710
	ctx.r[6].s64 = ctx.r[11].s64 + -22288;
	// 82EC90C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC90C4: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EC90C8: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 82EC90CC: 390B9128  addi r8, r11, -0x6ed8
	ctx.r[8].s64 = ctx.r[11].s64 + -28376;
	// 82EC90D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC90D4: 393F00A4  addi r9, r31, 0xa4
	ctx.r[9].s64 = ctx.r[31].s64 + 164;
	// 82EC90D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC90DC: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EC90E0: 90DF006C  stw r6, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[6].u32 ) };
	// 82EC90E4: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EC90E8: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EC90EC: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EC90F0: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC90F4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC90F8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC90FC: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC9100: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC9104: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EC9108: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EC910C: 98AA001C  stb r5, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[5].u8 ) };
	// 82EC9110: 90EA0020  stw r7, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82EC9114: 916A0024  stw r11, 0x24(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EC9118: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC911C: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC9120: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC9124: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC9128: 91690010  stw r11, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC912C: 91090014  stw r8, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EC9130: 91690018  stw r11, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EC9134: 98A9001C  stb r5, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[5].u8 ) };
	// 82EC9138: 90E90020  stw r7, 0x20(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82EC913C: 91690024  stw r11, 0x24(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EC9140: 93FF00A0  stw r31, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	// 82EC9144: 93FF00C8  stw r31, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[31].u32 ) };
	// 82EC9148: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC914C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC9150: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC9154: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC9158: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9160 size=68
    let mut pc: u32 = 0x82EC9160;
    'dispatch: loop {
        match pc {
            0x82EC9160 => {
    //   block [0x82EC9160..0x82EC9180)
	// 82EC9160: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9164: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC9168: 81630078  lwz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC916C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9170: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9174: 80EA0014  lwz r7, 0x14(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC9178: 41820024  beq 0x82ec919c
	if ctx.cr[0].eq {
	pc = 0x82EC919C; continue 'dispatch;
	}
	// 82EC917C: 81430070  lwz r10, 0x70(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	pc = 0x82EC9180; continue 'dispatch;
            }
            0x82EC9180 => {
    //   block [0x82EC9180..0x82EC919C)
	// 82EC9180: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC9184: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC9188: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC918C: 81080008  lwz r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9190: 81080014  lwz r8, 0x14(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC9194: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82EC9198: 4082FFE8  bne 0x82ec9180
	if !ctx.cr[0].eq {
	pc = 0x82EC9180; continue 'dispatch;
	}
	pc = 0x82EC919C; continue 'dispatch;
            }
            0x82EC919C => {
    //   block [0x82EC919C..0x82EC91A4)
	// 82EC919C: 7C6939D6  mullw r3, r9, r7
	ctx.r[3].s32 = ((ctx.r[9].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82EC91A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC91A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC91A8 size=172
    let mut pc: u32 = 0x82EC91A8;
    'dispatch: loop {
        match pc {
            0x82EC91A8 => {
    //   block [0x82EC91A8..0x82EC9248)
	// 82EC91A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC91AC: 4BDE0259  bl 0x82ca9404
	ctx.lr = 0x82EC91B0;
	sub_82CA93D0(ctx, base);
	// 82EC91B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC91B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC91B8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82EC91BC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EC91C0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82EC91C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC91C8: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EC91CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC91D0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82EC91D4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC91D8: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82EC91DC: 4B40A17D  bl 0x822d3358
	ctx.lr = 0x82EC91E0;
	sub_822D3358(ctx, base);
	// 82EC91E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC91E4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EC91E8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EC91EC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC91F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EC91F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC91F8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EC91FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC9200: 4E800421  bctrl
	ctx.lr = 0x82EC9204;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC9204: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EC9208: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC920C: 4182003C  beq 0x82ec9248
	if ctx.cr[0].eq {
	pc = 0x82EC9248; continue 'dispatch;
	}
	// 82EC9210: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC9214: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9218: 41820030  beq 0x82ec9248
	if ctx.cr[0].eq {
	pc = 0x82EC9248; continue 'dispatch;
	}
	// 82EC921C: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EC9220: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC9224: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC9228: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EC922C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC9230: 7C0B552E  stfsx f0, r11, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82EC9234: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9238: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC923C: 816B00A8  lwz r11, 0xa8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EC9240: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC9244: 4BFBFEB5  bl 0x82e890f8
	ctx.lr = 0x82EC9248;
	sub_82E890F8(ctx, base);
            }
            0x82EC9248 => {
    //   block [0x82EC9248..0x82EC9254)
	// 82EC9248: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EC924C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC9250: 4BDE0204  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9258 size=168
    let mut pc: u32 = 0x82EC9258;
    'dispatch: loop {
        match pc {
            0x82EC9258 => {
    //   block [0x82EC9258..0x82EC928C)
	// 82EC9258: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EC925C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC9260: 41990098  bgt cr6, 0x82ec92f8
	if ctx.cr[6].gt {
	pc = 0x82EC92F8; continue 'dispatch;
	}
	// 82EC9264: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9268: 81630068  lwz r11, 0x68(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC926C: 0CCB0000  twi 6, r11, 0
	// 82EC9270: 7D645B96  divwu r11, r4, r11
	ctx.r[11].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 82EC9274: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9278: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC927C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC9280: 4198000C  blt cr6, 0x82ec928c
	if ctx.cr[6].lt {
	pc = 0x82EC928C; continue 'dispatch;
	}
	// 82EC9284: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC9288: 48000010  b 0x82ec9298
	pc = 0x82EC9298; continue 'dispatch;
            }
            0x82EC928C => {
    //   block [0x82EC928C..0x82EC9298)
	// 82EC928C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9290: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC9294: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x82EC9298; continue 'dispatch;
            }
            0x82EC9298 => {
    //   block [0x82EC9298..0x82EC92D0)
	// 82EC9298: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC929C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC92A0: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC92A4: 41820054  beq 0x82ec92f8
	if ctx.cr[0].eq {
	pc = 0x82EC92F8; continue 'dispatch;
	}
	// 82EC92A8: 81630068  lwz r11, 0x68(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC92AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC92B0: 80A30078  lwz r5, 0x78(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC92B4: 7D445B96  divwu r10, r4, r11
	ctx.r[10].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 82EC92B8: 0CCB0000  twi 6, r11, 0
	// 82EC92BC: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC92C0: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82EC92C4: 28050000  cmplwi r5, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC92C8: 41820030  beq 0x82ec92f8
	if ctx.cr[0].eq {
	pc = 0x82EC92F8; continue 'dispatch;
	}
	// 82EC92CC: 81430070  lwz r10, 0x70(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	pc = 0x82EC92D0; continue 'dispatch;
            }
            0x82EC92D0 => {
    //   block [0x82EC92D0..0x82EC92F8)
	// 82EC92D0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC92D4: 81070008  lwz r8, 8(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC92D8: 81080018  lwz r8, 0x18(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC92DC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EC92E0: 41980020  blt cr6, 0x82ec9300
	if ctx.cr[6].lt {
		sub_82EC9300(ctx, base);
		return;
	}
	// 82EC92E4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC92E8: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82EC92EC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC92F0: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EC92F4: 4198FFDC  blt cr6, 0x82ec92d0
	if ctx.cr[6].lt {
	pc = 0x82EC92D0; continue 'dispatch;
	}
	pc = 0x82EC92F8; continue 'dispatch;
            }
            0x82EC92F8 => {
    //   block [0x82EC92F8..0x82EC9300)
	// 82EC92F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC92FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9300 size=60
    let mut pc: u32 = 0x82EC9300;
    'dispatch: loop {
        match pc {
            0x82EC9300 => {
    //   block [0x82EC9300..0x82EC9318)
	// 82EC9300: 81470008  lwz r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9304: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC9308: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC930C: 4198000C  blt cr6, 0x82ec9318
	if ctx.cr[6].lt {
	pc = 0x82EC9318; continue 'dispatch;
	}
	// 82EC9310: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC9314: 48000010  b 0x82ec9324
	pc = 0x82EC9324; continue 'dispatch;
            }
            0x82EC9318 => {
    //   block [0x82EC9318..0x82EC9324)
	// 82EC9318: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC931C: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC9320: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x82EC9324; continue 'dispatch;
            }
            0x82EC9324 => {
    //   block [0x82EC9324..0x82EC933C)
	// 82EC9324: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9328: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC932C: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82EC9330: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC9334: 69430001  xori r3, r10, 1
	ctx.r[3].u64 = ctx.r[10].u64 ^ 1;
	// 82EC9338: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9340 size=216
    let mut pc: u32 = 0x82EC9340;
    'dispatch: loop {
        match pc {
            0x82EC9340 => {
    //   block [0x82EC9340..0x82EC93B8)
	// 82EC9340: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC9344: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9348: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
	// 82EC934C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9350: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9354: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82EC9358: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC935C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC9360: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EC9364: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9368: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC936C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EC9370: 4182009C  beq 0x82ec940c
	if ctx.cr[0].eq {
	pc = 0x82EC940C; continue 'dispatch;
	}
	// 82EC9374: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC9378: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82EC937C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC9380: 394B006C  addi r10, r11, 0x6c
	ctx.r[10].s64 = ctx.r[11].s64 + 108;
	// 82EC9384: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9388: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC938C: 80C60008  lwz r6, 8(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9390: 80C60004  lwz r6, 4(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9394: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82EC9398: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 82EC939C: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EC93A0: 7D293B96  divwu r9, r9, r7
	ctx.r[9].u32 = ctx.r[9].u32 / ctx.r[7].u32;
	// 82EC93A4: 7D6959D6  mullw r11, r9, r11
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC93A8: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC93AC: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC93B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC93B4: 40990058  ble cr6, 0x82ec940c
	if !ctx.cr[6].gt {
	pc = 0x82EC940C; continue 'dispatch;
	}
	pc = 0x82EC93B8; continue 'dispatch;
            }
            0x82EC93B8 => {
    //   block [0x82EC93B8..0x82EC940C)
	// 82EC93B8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC93BC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC93C0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC93C4: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC93C8: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC93CC: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC93D0: 91030018  stw r8, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82EC93D4: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EC93D8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EC93DC: 409A003C  bne cr6, 0x82ec9418
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82EC9418);
		return;
	}
	// 82EC93E0: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC93E4: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC93E8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC93EC: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EC93F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC93F4: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EC93F8: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC93FC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC9400: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9404: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC9408: 4198FFB0  blt cr6, 0x82ec93b8
	if ctx.cr[6].lt {
	pc = 0x82EC93B8; continue 'dispatch;
	}
	pc = 0x82EC940C; continue 'dispatch;
            }
            0x82EC940C => {
    //   block [0x82EC940C..0x82EC9418)
	// 82EC940C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC9410: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EC9414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9440 size=128
    let mut pc: u32 = 0x82EC9440;
    'dispatch: loop {
        match pc {
            0x82EC9440 => {
    //   block [0x82EC9440..0x82EC94C0)
	// 82EC9440: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC9444: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9448: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
	// 82EC944C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC9454: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EC9458: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC945C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC9460: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EC9464: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC9468: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC946C: 396B006C  addi r11, r11, 0x6c
	ctx.r[11].s64 = ctx.r[11].s64 + 108;
	// 82EC9470: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9474: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EC9478: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC947C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9480: 41820040  beq 0x82ec94c0
	if ctx.cr[0].eq {
		sub_82EC94C0(ctx, base);
		return;
	}
	// 82EC9484: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9488: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82EC948C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9490: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EC9494: 81030010  lwz r8, 0x10(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC9498: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC949C: 7D66582E  lwzx r11, r6, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC94A0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC94A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC94A8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC94AC: 7D6B3B96  divwu r11, r11, r7
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[7].u32;
	// 82EC94B0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82EC94B4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EC94B8: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EC94BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC94C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC94C0 size=292
    let mut pc: u32 = 0x82EC94C0;
    'dispatch: loop {
        match pc {
            0x82EC94C0 => {
    //   block [0x82EC94C0..0x82EC94D0)
	// 82EC94C0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC94C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC94C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC94CC: 48000058  b 0x82ec9524
	pc = 0x82EC9524; continue 'dispatch;
            }
            0x82EC94D0 => {
    //   block [0x82EC94D0..0x82EC9524)
	// 82EC94D0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC94D4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC94D8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC94DC: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC94E0: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EC94E4: 8129FFFC  lwz r9, -4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EC94E8: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC94EC: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EC94F0: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EC94F4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC94F8: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC94FC: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9500: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9504: 91230018  stw r9, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EC9508: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EC950C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EC9510: 409A00D4  bne cr6, 0x82ec95e4
	if !ctx.cr[6].eq {
		sub_82EC95E4(ctx, base);
		return;
	}
	// 82EC9514: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9518: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC951C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC9520: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x82EC9524; continue 'dispatch;
            }
            0x82EC9524 => {
    //   block [0x82EC9524..0x82EC9584)
	// 82EC9524: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9528: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC952C: 4198FFA4  blt cr6, 0x82ec94d0
	if ctx.cr[6].lt {
	pc = 0x82EC94D0; continue 'dispatch;
	}
	// 82EC9530: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9534: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9538: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC953C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EC9540: 41820098  beq 0x82ec95d8
	if ctx.cr[0].eq {
	pc = 0x82EC95D8; continue 'dispatch;
	}
	// 82EC9544: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC9548: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82EC954C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC9550: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9554: 814A0068  lwz r10, 0x68(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC9558: 80C60008  lwz r6, 8(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC955C: 80C60004  lwz r6, 4(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9560: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82EC9564: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 82EC9568: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EC956C: 7D293B96  divwu r9, r9, r7
	ctx.r[9].u32 = ctx.r[9].u32 / ctx.r[7].u32;
	// 82EC9570: 7D4951D6  mullw r10, r9, r10
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EC9574: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EC9578: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC957C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC9580: 40990058  ble cr6, 0x82ec95d8
	if !ctx.cr[6].gt {
	pc = 0x82EC95D8; continue 'dispatch;
	}
	pc = 0x82EC9584; continue 'dispatch;
            }
            0x82EC9584 => {
    //   block [0x82EC9584..0x82EC95D8)
	// 82EC9584: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9588: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC958C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC9590: 7D2A482E  lwzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC9594: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9598: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC959C: 91030018  stw r8, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82EC95A0: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EC95A4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EC95A8: 409A0064  bne cr6, 0x82ec960c
	if !ctx.cr[6].eq {
		sub_82EC960C(ctx, base);
		return;
	}
	// 82EC95AC: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC95B0: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC95B4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC95B8: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EC95BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC95C0: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EC95C4: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC95C8: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC95CC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC95D0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC95D4: 4198FFB0  blt cr6, 0x82ec9584
	if ctx.cr[6].lt {
	pc = 0x82EC9584; continue 'dispatch;
	}
	pc = 0x82EC95D8; continue 'dispatch;
            }
            0x82EC95D8 => {
    //   block [0x82EC95D8..0x82EC95E4)
	// 82EC95D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC95DC: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EC95E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC95E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC95E4 size=40
    let mut pc: u32 = 0x82EC95E4;
    'dispatch: loop {
        match pc {
            0x82EC95E4 => {
    //   block [0x82EC95E4..0x82EC960C)
	// 82EC95E4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC95E8: 39000014  li r8, 0x14
	ctx.r[8].s64 = 20;
	// 82EC95EC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC95F0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC95F4: 7D6B4396  divwu r11, r11, r8
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[8].u32;
	// 82EC95F8: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC95FC: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9600: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EC9604: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC9608: 4BFFFEB0  b 0x82ec94b8
	sub_82EC9440(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC960C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC960C size=20
    let mut pc: u32 = 0x82EC960C;
    'dispatch: loop {
        match pc {
            0x82EC960C => {
    //   block [0x82EC960C..0x82EC9620)
	// 82EC960C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9610: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC9614: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC9618: 7D6B3B96  divwu r11, r11, r7
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[7].u32;
	// 82EC961C: 4BFFFFDC  b 0x82ec95f8
	sub_82EC95E4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9620 size=60
    let mut pc: u32 = 0x82EC9620;
    'dispatch: loop {
        match pc {
            0x82EC9620 => {
    //   block [0x82EC9620..0x82EC965C)
	// 82EC9620: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC9624: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC9628: 90E30008  stw r7, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82EC962C: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82EC9630: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9634: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9638: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC963C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9640: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EC9644: 40820018  bne 0x82ec965c
	if !ctx.cr[0].eq {
		sub_82EC965C(ctx, base);
		return;
	}
	// 82EC9648: 90E30020  stw r7, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82EC964C: 90E30018  stw r7, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 82EC9650: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC9654: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EC9658: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC965C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC965C size=208
    let mut pc: u32 = 0x82EC965C;
    'dispatch: loop {
        match pc {
            0x82EC965C => {
    //   block [0x82EC965C..0x82EC9694)
	// 82EC965C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9660: 39000014  li r8, 0x14
	ctx.r[8].s64 = 20;
	// 82EC9664: 80C30004  lwz r6, 4(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9668: 392B006C  addi r9, r11, 0x6c
	ctx.r[9].s64 = ctx.r[11].s64 + 108;
	// 82EC966C: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC9670: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9674: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9678: 7D4A3050  subf r10, r10, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82EC967C: 7D4A4396  divwu r10, r10, r8
	ctx.r[10].u32 = ctx.r[10].u32 / ctx.r[8].u32;
	// 82EC9680: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC9684: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC9688: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC968C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC9690: 40990088  ble cr6, 0x82ec9718
	if !ctx.cr[6].gt {
	pc = 0x82EC9718; continue 'dispatch;
	}
	pc = 0x82EC9694; continue 'dispatch;
            }
            0x82EC9694 => {
    //   block [0x82EC9694..0x82EC96D4)
	// 82EC9694: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9698: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC969C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC96A0: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EC96A4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC96A8: 4182002C  beq 0x82ec96d4
	if ctx.cr[0].eq {
	pc = 0x82EC96D4; continue 'dispatch;
	}
	// 82EC96AC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC96B0: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC96B4: 90C30018  stw r6, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 82EC96B8: 54C6003E  slwi r6, r6, 0
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EC96BC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EC96C0: 409A0034  bne cr6, 0x82ec96f4
	if !ctx.cr[6].eq {
	pc = 0x82EC96F4; continue 'dispatch;
	}
	// 82EC96C4: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC96C8: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC96CC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC96D0: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC96D4; continue 'dispatch;
            }
            0x82EC96D4 => {
    //   block [0x82EC96D4..0x82EC96F4)
	// 82EC96D4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC96D8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC96DC: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC96E0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC96E4: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC96E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC96EC: 4198FFA8  blt cr6, 0x82ec9694
	if ctx.cr[6].lt {
	pc = 0x82EC9694; continue 'dispatch;
	}
	// 82EC96F0: 48000028  b 0x82ec9718
	pc = 0x82EC9718; continue 'dispatch;
            }
            0x82EC96F4 => {
    //   block [0x82EC96F4..0x82EC9718)
	// 82EC96F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC96F8: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC96FC: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC9700: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC9704: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9708: 7D6B4396  divwu r11, r11, r8
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[8].u32;
	// 82EC970C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EC9710: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC9714: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC9718; continue 'dispatch;
            }
            0x82EC9718 => {
    //   block [0x82EC9718..0x82EC972C)
	// 82EC9718: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC971C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC9720: 419AFF30  beq cr6, 0x82ec9650
	if ctx.cr[6].eq {
		sub_82EC9620(ctx, base);
		return;
	}
	// 82EC9724: 98E3001C  stb r7, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[7].u8 ) };
	// 82EC9728: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC9730 size=556
    let mut pc: u32 = 0x82EC9730;
    'dispatch: loop {
        match pc {
            0x82EC9730 => {
    //   block [0x82EC9730..0x82EC9760)
	// 82EC9730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9734: 4BDDFCBD  bl 0x82ca93f0
	ctx.lr = 0x82EC9738;
	sub_82CA93D0(ctx, base);
	// 82EC9738: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82EC973C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC9740: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC9744: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82EC9748: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC974C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9750: 408201FC  bne 0x82ec994c
	if !ctx.cr[0].eq {
	pc = 0x82EC994C; continue 'dispatch;
	}
	// 82EC9754: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC9758: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC975C: 48000028  b 0x82ec9784
	pc = 0x82EC9784; continue 'dispatch;
            }
            0x82EC9760 => {
    //   block [0x82EC9760..0x82EC9784)
	// 82EC9760: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9764: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC9768: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC976C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC9770: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC9774: 4E800421  bctrl
	ctx.lr = 0x82EC9778;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC9778: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC977C: 408201D0  bne 0x82ec994c
	if !ctx.cr[0].eq {
	pc = 0x82EC994C; continue 'dispatch;
	}
	// 82EC9780: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
            }
            0x82EC9784 => {
    //   block [0x82EC9784..0x82EC97B4)
	// 82EC9784: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9788: 4082FFD8  bne 0x82ec9760
	if !ctx.cr[0].eq {
	pc = 0x82EC9760; continue 'dispatch;
	}
	// 82EC978C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9790: 808300A8  lwz r4, 0xa8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EC9794: 4BFBDBBD  bl 0x82e87350
	ctx.lr = 0x82EC9798;
	sub_82E87350(ctx, base);
	// 82EC9798: 897F0098  lbz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EC979C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EC97A0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC97A4: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC97A8: 4082000C  bne 0x82ec97b4
	if !ctx.cr[0].eq {
	pc = 0x82EC97B4; continue 'dispatch;
	}
	// 82EC97AC: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 82EC97B0: 4BFFFE71  bl 0x82ec9620
	ctx.lr = 0x82EC97B4;
	sub_82EC9620(ctx, base);
	pc = 0x82EC97B4; continue 'dispatch;
            }
            0x82EC97B4 => {
    //   block [0x82EC97B4..0x82EC97C0)
	// 82EC97B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC97B8: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82EC97BC: 82EB00A4  lwz r23, 0xa4(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	pc = 0x82EC97C0; continue 'dispatch;
            }
            0x82EC97C0 => {
    //   block [0x82EC97C0..0x82EC97C4)
	// 82EC97C0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	pc = 0x82EC97C4; continue 'dispatch;
            }
            0x82EC97C4 => {
    //   block [0x82EC97C4..0x82EC9814)
	// 82EC97C4: 897F0098  lbz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EC97C8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC97CC: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC97D0: 4182017C  beq 0x82ec994c
	if ctx.cr[0].eq {
	pc = 0x82EC994C; continue 'dispatch;
	}
	// 82EC97D4: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC97D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC97DC: 41820168  beq 0x82ec9944
	if ctx.cr[0].eq {
	pc = 0x82EC9944; continue 'dispatch;
	}
	// 82EC97E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC97E4: 3B5F007C  addi r26, r31, 0x7c
	ctx.r[26].s64 = ctx.r[31].s64 + 124;
	// 82EC97E8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EC97EC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EC97F0: 91760000  stw r11, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC97F4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC97F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC97FC: 41820018  beq 0x82ec9814
	if ctx.cr[0].eq {
	pc = 0x82EC9814; continue 'dispatch;
	}
	// 82EC9800: 815A0018  lwz r10, 0x18(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC9804: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9808: 4182000C  beq 0x82ec9814
	if ctx.cr[0].eq {
	pc = 0x82EC9814; continue 'dispatch;
	}
	// 82EC980C: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9810: 836A0004  lwz r27, 4(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82EC9814; continue 'dispatch;
            }
            0x82EC9814 => {
    //   block [0x82EC9814..0x82EC982C)
	// 82EC9814: 7F18E840  cmplw cr6, r24, r29
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82EC9818: 419A0054  beq cr6, 0x82ec986c
	if ctx.cr[6].eq {
	pc = 0x82EC986C; continue 'dispatch;
	}
	// 82EC981C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC9820: 7FB8EB78  mr r24, r29
	ctx.r[24].u64 = ctx.r[29].u64;
	// 82EC9824: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9828: 4800002C  b 0x82ec9854
	pc = 0x82EC9854; continue 'dispatch;
            }
            0x82EC982C => {
    //   block [0x82EC982C..0x82EC9854)
	// 82EC982C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9830: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC9834: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC9838: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC983C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC9840: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC9844: 4E800421  bctrl
	ctx.lr = 0x82EC9848;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC9848: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC984C: 40820014  bne 0x82ec9860
	if !ctx.cr[0].eq {
	pc = 0x82EC9860; continue 'dispatch;
	}
	// 82EC9850: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
            }
            0x82EC9854 => {
    //   block [0x82EC9854..0x82EC9860)
	// 82EC9854: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9858: 4082FFD4  bne 0x82ec982c
	if !ctx.cr[0].eq {
	pc = 0x82EC982C; continue 'dispatch;
	}
	// 82EC985C: 48000008  b 0x82ec9864
	pc = 0x82EC9864; continue 'dispatch;
            }
            0x82EC9860 => {
    //   block [0x82EC9860..0x82EC9864)
	// 82EC9860: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	pc = 0x82EC9864; continue 'dispatch;
            }
            0x82EC9864 => {
    //   block [0x82EC9864..0x82EC986C)
	// 82EC9864: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC9868: 408200B8  bne 0x82ec9920
	if !ctx.cr[0].eq {
	pc = 0x82EC9920; continue 'dispatch;
	}
	pc = 0x82EC986C; continue 'dispatch;
            }
            0x82EC986C => {
    //   block [0x82EC986C..0x82EC987C)
	// 82EC986C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC9870: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC9874: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9878: 48000030  b 0x82ec98a8
	pc = 0x82EC98A8; continue 'dispatch;
            }
            0x82EC987C => {
    //   block [0x82EC987C..0x82EC98A8)
	// 82EC987C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9880: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82EC9884: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC9888: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC988C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC9890: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC9894: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC9898: 4E800421  bctrl
	ctx.lr = 0x82EC989C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC989C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC98A0: 40820014  bne 0x82ec98b4
	if !ctx.cr[0].eq {
	pc = 0x82EC98B4; continue 'dispatch;
	}
	// 82EC98A4: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
            }
            0x82EC98A8 => {
    //   block [0x82EC98A8..0x82EC98B4)
	// 82EC98A8: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC98AC: 4082FFD0  bne 0x82ec987c
	if !ctx.cr[0].eq {
	pc = 0x82EC987C; continue 'dispatch;
	}
	// 82EC98B0: 48000008  b 0x82ec98b8
	pc = 0x82EC98B8; continue 'dispatch;
            }
            0x82EC98B4 => {
    //   block [0x82EC98B4..0x82EC98B8)
	// 82EC98B4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x82EC98B8; continue 'dispatch;
            }
            0x82EC98B8 => {
    //   block [0x82EC98B8..0x82EC98F4)
	// 82EC98B8: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC98BC: 40820064  bne 0x82ec9920
	if !ctx.cr[0].eq {
	pc = 0x82EC9920; continue 'dispatch;
	}
	// 82EC98C0: 83DF009C  lwz r30, 0x9c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EC98C4: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC98C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC98CC: 4BFBF7B5  bl 0x82e89080
	ctx.lr = 0x82EC98D0;
	sub_82E89080(ctx, base);
	// 82EC98D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC98D4: 7F04B840  cmplw cr6, r4, r23
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82EC98D8: 419A001C  beq cr6, 0x82ec98f4
	if ctx.cr[6].eq {
	pc = 0x82EC98F4; continue 'dispatch;
	}
	// 82EC98DC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC98E0: 4BFBDA71  bl 0x82e87350
	ctx.lr = 0x82EC98E4;
	sub_82E87350(ctx, base);
	// 82EC98E4: EDBF0828  fsubs f13, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC98E8: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC98EC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC98F0: 41980030  blt cr6, 0x82ec9920
	if ctx.cr[6].lt {
	pc = 0x82EC9920; continue 'dispatch;
	}
	pc = 0x82EC98F4; continue 'dispatch;
            }
            0x82EC98F4 => {
    //   block [0x82EC98F4..0x82EC9920)
	// 82EC98F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC98F8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EC98FC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EC9900: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC9904: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC9908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC990C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82EC9910: 4BFFF899  bl 0x82ec91a8
	ctx.lr = 0x82EC9914;
	sub_82EC91A8(ctx, base);
	// 82EC9914: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC9918: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC991C: 41820028  beq 0x82ec9944
	if ctx.cr[0].eq {
	pc = 0x82EC9944; continue 'dispatch;
	}
	pc = 0x82EC9920; continue 'dispatch;
            }
            0x82EC9920 => {
    //   block [0x82EC9920..0x82EC9938)
	// 82EC9920: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC9924: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EC9928: 41820010  beq 0x82ec9938
	if ctx.cr[0].eq {
	pc = 0x82EC9938; continue 'dispatch;
	}
	// 82EC992C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC9930: 4BFFFA11  bl 0x82ec9340
	ctx.lr = 0x82EC9934;
	sub_82EC9340(ctx, base);
	// 82EC9934: 4BFFFE8C  b 0x82ec97c0
	pc = 0x82EC97C0; continue 'dispatch;
            }
            0x82EC9938 => {
    //   block [0x82EC9938..0x82EC9944)
	// 82EC9938: 4BFFFB09  bl 0x82ec9440
	ctx.lr = 0x82EC993C;
	sub_82EC9440(ctx, base);
	// 82EC993C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EC9940: 4BFFFE84  b 0x82ec97c4
	pc = 0x82EC97C4; continue 'dispatch;
            }
            0x82EC9944 => {
    //   block [0x82EC9944..0x82EC994C)
	// 82EC9944: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC9948: 48000008  b 0x82ec9950
	pc = 0x82EC9950; continue 'dispatch;
            }
            0x82EC994C => {
    //   block [0x82EC994C..0x82EC9950)
	// 82EC994C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC9950; continue 'dispatch;
            }
            0x82EC9950 => {
    //   block [0x82EC9950..0x82EC995C)
	// 82EC9950: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EC9954: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82EC9958: 4BDDFAE8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC9960 size=108
    let mut pc: u32 = 0x82EC9960;
    'dispatch: loop {
        match pc {
            0x82EC9960 => {
    //   block [0x82EC9960..0x82EC99AC)
	// 82EC9960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9964: 4BDDFAA9  bl 0x82ca940c
	ctx.lr = 0x82EC9968;
	sub_82CA93D0(ctx, base);
	// 82EC9968: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC996C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC9970: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC9974: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EC9978: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EC997C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC9980: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EC9984: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82EC9988: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC998C: 915F004C  stw r10, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 82EC9990: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC9994: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC9998: 4BFFF8C1  bl 0x82ec9258
	ctx.lr = 0x82EC999C;
	sub_82EC9258(ctx, base);
	// 82EC999C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC99A0: 4082000C  bne 0x82ec99ac
	if !ctx.cr[0].eq {
	pc = 0x82EC99AC; continue 'dispatch;
	}
	// 82EC99A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC99A8: 4800001C  b 0x82ec99c4
	pc = 0x82EC99C4; continue 'dispatch;
            }
            0x82EC99AC => {
    //   block [0x82EC99AC..0x82EC99C4)
	// 82EC99AC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EC99B0: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC99B4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EC99B8: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC99BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC99C0: 4BFFF7E9  bl 0x82ec91a8
	ctx.lr = 0x82EC99C4;
	sub_82EC91A8(ctx, base);
	pc = 0x82EC99C4; continue 'dispatch;
            }
            0x82EC99C4 => {
    //   block [0x82EC99C4..0x82EC99CC)
	// 82EC99C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC99C8: 4BDDFA94  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC99D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC99D0 size=360
    let mut pc: u32 = 0x82EC99D0;
    'dispatch: loop {
        match pc {
            0x82EC99D0 => {
    //   block [0x82EC99D0..0x82EC99EC)
	// 82EC99D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC99D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC99D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC99DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC99E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC99E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC99E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	pc = 0x82EC99EC; continue 'dispatch;
            }
            0x82EC99EC => {
    //   block [0x82EC99EC..0x82EC9A20)
	// 82EC99EC: 897F0098  lbz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EC99F0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC99F4: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC99F8: 41820048  beq 0x82ec9a40
	if ctx.cr[0].eq {
	pc = 0x82EC9A40; continue 'dispatch;
	}
	// 82EC99FC: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC9A00: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9A04: 4182001C  beq 0x82ec9a20
	if ctx.cr[0].eq {
	pc = 0x82EC9A20; continue 'dispatch;
	}
	// 82EC9A08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9A0C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9A10: 409A0010  bne cr6, 0x82ec9a20
	if !ctx.cr[6].eq {
	pc = 0x82EC9A20; continue 'dispatch;
	}
	// 82EC9A14: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC9A18: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 82EC9A1C: 4BFFF925  bl 0x82ec9340
	ctx.lr = 0x82EC9A20;
	sub_82EC9340(ctx, base);
	pc = 0x82EC9A20; continue 'dispatch;
            }
            0x82EC9A20 => {
    //   block [0x82EC9A20..0x82EC9A40)
	// 82EC9A20: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EC9A24: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9A28: 41820018  beq 0x82ec9a40
	if ctx.cr[0].eq {
	pc = 0x82EC9A40; continue 'dispatch;
	}
	// 82EC9A2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9A30: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9A34: 409A000C  bne cr6, 0x82ec9a40
	if !ctx.cr[6].eq {
	pc = 0x82EC9A40; continue 'dispatch;
	}
	// 82EC9A38: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 82EC9A3C: 4BFFFA05  bl 0x82ec9440
	ctx.lr = 0x82EC9A40;
	sub_82EC9440(ctx, base);
	pc = 0x82EC9A40; continue 'dispatch;
            }
            0x82EC9A40 => {
    //   block [0x82EC9A40..0x82EC9A70)
	// 82EC9A40: 897F0098  lbz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EC9A44: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC9A48: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC9A4C: 41820024  beq 0x82ec9a70
	if ctx.cr[0].eq {
	pc = 0x82EC9A70; continue 'dispatch;
	}
	// 82EC9A50: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC9A54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9A58: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9A5C: 419AFF90  beq cr6, 0x82ec99ec
	if ctx.cr[6].eq {
	pc = 0x82EC99EC; continue 'dispatch;
	}
	// 82EC9A60: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EC9A64: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9A68: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9A6C: 419AFF80  beq cr6, 0x82ec99ec
	if ctx.cr[6].eq {
	pc = 0x82EC99EC; continue 'dispatch;
	}
	pc = 0x82EC9A70; continue 'dispatch;
            }
            0x82EC9A70 => {
    //   block [0x82EC9A70..0x82EC9AA4)
	// 82EC9A70: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EC9A74: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC9A78: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC9A7C: 41820048  beq 0x82ec9ac4
	if ctx.cr[0].eq {
	pc = 0x82EC9AC4; continue 'dispatch;
	}
	// 82EC9A80: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EC9A84: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9A88: 4182001C  beq 0x82ec9aa4
	if ctx.cr[0].eq {
	pc = 0x82EC9AA4; continue 'dispatch;
	}
	// 82EC9A8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9A90: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9A94: 409A0010  bne cr6, 0x82ec9aa4
	if !ctx.cr[6].eq {
	pc = 0x82EC9AA4; continue 'dispatch;
	}
	// 82EC9A98: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC9A9C: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 82EC9AA0: 4BFFF8A1  bl 0x82ec9340
	ctx.lr = 0x82EC9AA4;
	sub_82EC9340(ctx, base);
	pc = 0x82EC9AA4; continue 'dispatch;
            }
            0x82EC9AA4 => {
    //   block [0x82EC9AA4..0x82EC9AC4)
	// 82EC9AA4: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EC9AA8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9AAC: 41820018  beq 0x82ec9ac4
	if ctx.cr[0].eq {
	pc = 0x82EC9AC4; continue 'dispatch;
	}
	// 82EC9AB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9AB4: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9AB8: 409A000C  bne cr6, 0x82ec9ac4
	if !ctx.cr[6].eq {
	pc = 0x82EC9AC4; continue 'dispatch;
	}
	// 82EC9ABC: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 82EC9AC0: 4BFFF981  bl 0x82ec9440
	ctx.lr = 0x82EC9AC4;
	sub_82EC9440(ctx, base);
	pc = 0x82EC9AC4; continue 'dispatch;
            }
            0x82EC9AC4 => {
    //   block [0x82EC9AC4..0x82EC9AF4)
	// 82EC9AC4: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EC9AC8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC9ACC: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC9AD0: 41820024  beq 0x82ec9af4
	if ctx.cr[0].eq {
	pc = 0x82EC9AF4; continue 'dispatch;
	}
	// 82EC9AD4: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EC9AD8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9ADC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9AE0: 419AFF90  beq cr6, 0x82ec9a70
	if ctx.cr[6].eq {
	pc = 0x82EC9A70; continue 'dispatch;
	}
	// 82EC9AE4: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EC9AE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9AEC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9AF0: 419AFF80  beq cr6, 0x82ec9a70
	if ctx.cr[6].eq {
	pc = 0x82EC9A70; continue 'dispatch;
	}
	pc = 0x82EC9AF4; continue 'dispatch;
            }
            0x82EC9AF4 => {
    //   block [0x82EC9AF4..0x82EC9B20)
	// 82EC9AF4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC9AF8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC9AFC: 419A0024  beq cr6, 0x82ec9b20
	if ctx.cr[6].eq {
	pc = 0x82EC9B20; continue 'dispatch;
	}
	// 82EC9B00: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC9B04: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9B08: 41820018  beq 0x82ec9b20
	if ctx.cr[0].eq {
	pc = 0x82EC9B20; continue 'dispatch;
	}
	// 82EC9B0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9B10: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9B14: 409A000C  bne cr6, 0x82ec9b20
	if !ctx.cr[6].eq {
	pc = 0x82EC9B20; continue 'dispatch;
	}
	// 82EC9B18: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82EC9B1C: 4BFBCA15  bl 0x82e86530
	ctx.lr = 0x82EC9B20;
	sub_82E86530(ctx, base);
	pc = 0x82EC9B20; continue 'dispatch;
            }
            0x82EC9B20 => {
    //   block [0x82EC9B20..0x82EC9B38)
	// 82EC9B20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC9B24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC9B28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC9B2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC9B30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC9B34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC9B38 size=404
    let mut pc: u32 = 0x82EC9B38;
    'dispatch: loop {
        match pc {
            0x82EC9B38 => {
    //   block [0x82EC9B38..0x82EC9BAC)
	// 82EC9B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9B3C: 4BDDF8B5  bl 0x82ca93f0
	ctx.lr = 0x82EC9B40;
	sub_82CA93D0(ctx, base);
	// 82EC9B40: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC9B44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC9B48: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82EC9B4C: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC9B50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9B54: 40820170  bne 0x82ec9cc4
	if !ctx.cr[0].eq {
	pc = 0x82EC9CC4; continue 'dispatch;
	}
	// 82EC9B58: 81760064  lwz r11, 0x64(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC9B5C: 3AE00014  li r23, 0x14
	ctx.r[23].s64 = 20;
	// 82EC9B60: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9B64: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC9B68: 409A00A0  bne cr6, 0x82ec9c08
	if !ctx.cr[6].eq {
	pc = 0x82EC9C08; continue 'dispatch;
	}
	// 82EC9B6C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9B70: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EC9B74: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9B78: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EC9B7C: 8156006C  lwz r10, 0x6c(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC9B80: 811F0068  lwz r8, 0x68(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC9B84: 80FF0078  lwz r7, 0x78(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC9B88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9B8C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EC9B90: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC9B94: 814900A4  lwz r10, 0xa4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC9B98: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC9B9C: 7F0B41D6  mullw r24, r11, r8
	ctx.r[24].s32 = ((ctx.r[11].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[24].s64 = ctx.r[24].s32 as i64;
	// 82EC9BA0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EC9BA4: 40990064  ble cr6, 0x82ec9c08
	if !ctx.cr[6].gt {
	pc = 0x82EC9C08; continue 'dispatch;
	}
	// 82EC9BA8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	pc = 0x82EC9BAC; continue 'dispatch;
            }
            0x82EC9BAC => {
    //   block [0x82EC9BAC..0x82EC9BC0)
	// 82EC9BAC: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC9BB0: 7F2BD02E  lwzx r25, r11, r26
	ctx.r[25].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EC9BB4: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9BB8: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9BBC: 48000028  b 0x82ec9be4
	pc = 0x82EC9BE4; continue 'dispatch;
            }
            0x82EC9BC0 => {
    //   block [0x82EC9BC0..0x82EC9BE4)
	// 82EC9BC0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9BC4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC9BC8: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC9BCC: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82EC9BD0: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC9BD4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EC9BD8: 7C8BC214  add r4, r11, r24
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82EC9BDC: 4BFBF51D  bl 0x82e890f8
	ctx.lr = 0x82EC9BE0;
	sub_82E890F8(ctx, base);
	// 82EC9BE0: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EC9BE4; continue 'dispatch;
            }
            0x82EC9BE4 => {
    //   block [0x82EC9BE4..0x82EC9C08)
	// 82EC9BE4: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9BE8: 4082FFD8  bne 0x82ec9bc0
	if !ctx.cr[0].eq {
	pc = 0x82EC9BC0; continue 'dispatch;
	}
	// 82EC9BEC: 81790020  lwz r11, 0x20(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC9BF0: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EC9BF4: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC9BF8: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82EC9BFC: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EC9C00: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC9C04: 4198FFA8  blt cr6, 0x82ec9bac
	if ctx.cr[6].lt {
	pc = 0x82EC9BAC; continue 'dispatch;
	}
	pc = 0x82EC9C08; continue 'dispatch;
            }
            0x82EC9C08 => {
    //   block [0x82EC9C08..0x82EC9C2C)
	// 82EC9C08: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9C0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC9C10: 80FF0078  lwz r7, 0x78(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC9C14: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC9C18: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9C1C: 816B00A4  lwz r11, 0xa4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC9C20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC9C24: 418200A0  beq 0x82ec9cc4
	if ctx.cr[0].eq {
	pc = 0x82EC9CC4; continue 'dispatch;
	}
	// 82EC9C28: 811F0070  lwz r8, 0x70(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	pc = 0x82EC9C2C; continue 'dispatch;
            }
            0x82EC9C2C => {
    //   block [0x82EC9C2C..0x82EC9C4C)
	// 82EC9C2C: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC9C30: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9C34: 41820018  beq 0x82ec9c4c
	if ctx.cr[0].eq {
	pc = 0x82EC9C4C; continue 'dispatch;
	}
	// 82EC9C38: 80D60064  lwz r6, 0x64(r22)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC9C3C: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EC9C40: 419A0020  beq cr6, 0x82ec9c60
	if ctx.cr[6].eq {
	pc = 0x82EC9C60; continue 'dispatch;
	}
	// 82EC9C44: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC9C48: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x82EC9C4C; continue 'dispatch;
            }
            0x82EC9C4C => {
    //   block [0x82EC9C4C..0x82EC9C60)
	// 82EC9C4C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC9C50: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EC9C54: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EC9C58: 4198FFD4  blt cr6, 0x82ec9c2c
	if ctx.cr[6].lt {
	pc = 0x82EC9C2C; continue 'dispatch;
	}
	// 82EC9C5C: 48000068  b 0x82ec9cc4
	pc = 0x82EC9CC4; continue 'dispatch;
            }
            0x82EC9C60 => {
    //   block [0x82EC9C60..0x82EC9C8C)
	// 82EC9C60: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9C64: 81360064  lwz r9, 0x64(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC9C68: 8116006C  lwz r8, 0x6c(r22)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC9C6C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9C70: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9C74: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9C78: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9C7C: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82EC9C80: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC9C84: 7FAB5214  add r29, r11, r10
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC9C88: 48000034  b 0x82ec9cbc
	pc = 0x82EC9CBC; continue 'dispatch;
            }
            0x82EC9C8C => {
    //   block [0x82EC9C8C..0x82EC9CBC)
	// 82EC9C8C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9C90: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EC9C94: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC9C98: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC9C9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9CA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9CA4: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82EC9CA8: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC9CAC: 7D6B51D6  mullw r11, r11, r10
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC9CB0: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EC9CB4: 4BFBF445  bl 0x82e890f8
	ctx.lr = 0x82EC9CB8;
	sub_82E890F8(ctx, base);
	// 82EC9CB8: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EC9CBC; continue 'dispatch;
            }
            0x82EC9CBC => {
    //   block [0x82EC9CBC..0x82EC9CC4)
	// 82EC9CBC: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9CC0: 4082FFCC  bne 0x82ec9c8c
	if !ctx.cr[0].eq {
	pc = 0x82EC9C8C; continue 'dispatch;
	}
	pc = 0x82EC9CC4; continue 'dispatch;
            }
            0x82EC9CC4 => {
    //   block [0x82EC9CC4..0x82EC9CCC)
	// 82EC9CC4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EC9CC8: 4BDDF778  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC9CD0 size=252
    let mut pc: u32 = 0x82EC9CD0;
    'dispatch: loop {
        match pc {
            0x82EC9CD0 => {
    //   block [0x82EC9CD0..0x82EC9D00)
	// 82EC9CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9CD4: 4BDDF739  bl 0x82ca940c
	ctx.lr = 0x82EC9CD8;
	sub_82CA93D0(ctx, base);
	// 82EC9CD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC9CDC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC9CE0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82EC9CE4: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9CE8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82EC9CEC: 409A0014  bne cr6, 0x82ec9d00
	if !ctx.cr[6].eq {
	pc = 0x82EC9D00; continue 'dispatch;
	}
	// 82EC9CF0: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC9CF4: 419A0038  beq cr6, 0x82ec9d2c
	if ctx.cr[6].eq {
	pc = 0x82EC9D2C; continue 'dispatch;
	}
	// 82EC9CF8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC9CFC: 48000030  b 0x82ec9d2c
	pc = 0x82EC9D2C; continue 'dispatch;
            }
            0x82EC9D00 => {
    //   block [0x82EC9D00..0x82EC9D20)
	// 82EC9D00: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82EC9D04: 409A0028  bne cr6, 0x82ec9d2c
	if !ctx.cr[6].eq {
	pc = 0x82EC9D2C; continue 'dispatch;
	}
	// 82EC9D08: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC9D0C: 40990020  ble cr6, 0x82ec9d2c
	if !ctx.cr[6].gt {
	pc = 0x82EC9D2C; continue 'dispatch;
	}
	// 82EC9D10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC9D14: 409A0010  bne cr6, 0x82ec9d24
	if !ctx.cr[6].eq {
	pc = 0x82EC9D24; continue 'dispatch;
	}
	// 82EC9D18: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EC9D1C: 48000008  b 0x82ec9d24
	pc = 0x82EC9D24; continue 'dispatch;
            }
            0x82EC9D20 => {
    //   block [0x82EC9D20..0x82EC9D24)
	// 82EC9D20: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x82EC9D24; continue 'dispatch;
            }
            0x82EC9D24 => {
    //   block [0x82EC9D24..0x82EC9D2C)
	// 82EC9D24: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82EC9D28: 4198FFF8  blt cr6, 0x82ec9d20
	if ctx.cr[6].lt {
	pc = 0x82EC9D20; continue 'dispatch;
	}
	pc = 0x82EC9D2C; continue 'dispatch;
            }
            0x82EC9D2C => {
    //   block [0x82EC9D2C..0x82EC9D40)
	// 82EC9D2C: 83FD000C  lwz r31, 0xc(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9D30: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC9D34: 4099000C  ble cr6, 0x82ec9d40
	if !ctx.cr[6].gt {
	pc = 0x82EC9D40; continue 'dispatch;
	}
	// 82EC9D38: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC9D3C: 48000008  b 0x82ec9d44
	pc = 0x82EC9D44; continue 'dispatch;
            }
            0x82EC9D40 => {
    //   block [0x82EC9D40..0x82EC9D44)
	// 82EC9D40: 909D000C  stw r4, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	pc = 0x82EC9D44; continue 'dispatch;
            }
            0x82EC9D44 => {
    //   block [0x82EC9D44..0x82EC9D58)
	// 82EC9D44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC9D48: 419A007C  beq cr6, 0x82ec9dc4
	if ctx.cr[6].eq {
	pc = 0x82EC9DC4; continue 'dispatch;
	}
	// 82EC9D4C: 7F1F2040  cmplw cr6, r31, r4
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82EC9D50: 41980008  blt cr6, 0x82ec9d58
	if ctx.cr[6].lt {
	pc = 0x82EC9D58; continue 'dispatch;
	}
	// 82EC9D54: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	pc = 0x82EC9D58; continue 'dispatch;
            }
            0x82EC9D58 => {
    //   block [0x82EC9D58..0x82EC9D74)
	// 82EC9D58: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82EC9D5C: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC9D60: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EC9D64: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82EC9D68: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC9D6C: 40990008  ble cr6, 0x82ec9d74
	if !ctx.cr[6].gt {
	pc = 0x82EC9D74; continue 'dispatch;
	}
	// 82EC9D70: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82EC9D74; continue 'dispatch;
            }
            0x82EC9D74 => {
    //   block [0x82EC9D74..0x82EC9D8C)
	// 82EC9D74: 4B74CBB5  bl 0x82616928
	ctx.lr = 0x82EC9D78;
	sub_82616928(ctx, base);
	// 82EC9D78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC9D7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EC9D80: 419A0024  beq cr6, 0x82ec9da4
	if ctx.cr[6].eq {
	pc = 0x82EC9DA4; continue 'dispatch;
	}
	// 82EC9D84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC9D88: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x82EC9D8C; continue 'dispatch;
            }
            0x82EC9D8C => {
    //   block [0x82EC9D8C..0x82EC9DA4)
	// 82EC9D8C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9D90: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC9D94: 7C095C2E  lfsx f0, r9, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC9D98: 7C0BF52E  stfsx f0, r11, r30
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	// 82EC9D9C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EC9DA0: 4082FFEC  bne 0x82ec9d8c
	if !ctx.cr[0].eq {
	pc = 0x82EC9D8C; continue 'dispatch;
	}
	pc = 0x82EC9DA4; continue 'dispatch;
            }
            0x82EC9DA4 => {
    //   block [0x82EC9DA4..0x82EC9DC0)
	// 82EC9DA4: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9DA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9DAC: 41820014  beq 0x82ec9dc0
	if ctx.cr[0].eq {
	pc = 0x82EC9DC0; continue 'dispatch;
	}
	// 82EC9DB0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC9DB4: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC9DB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC9DBC: 4E800421  bctrl
	ctx.lr = 0x82EC9DC0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC9DC0 => {
    //   block [0x82EC9DC0..0x82EC9DC4)
	// 82EC9DC0: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x82EC9DC4; continue 'dispatch;
            }
            0x82EC9DC4 => {
    //   block [0x82EC9DC4..0x82EC9DCC)
	// 82EC9DC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC9DC8: 4BDDF694  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC9DD0 size=244
    let mut pc: u32 = 0x82EC9DD0;
    'dispatch: loop {
        match pc {
            0x82EC9DD0 => {
    //   block [0x82EC9DD0..0x82EC9DFC)
	// 82EC9DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9DD4: 4BDDF631  bl 0x82ca9404
	ctx.lr = 0x82EC9DD8;
	sub_82CA93D0(ctx, base);
	// 82EC9DD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC9DDC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EC9DE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC9DE4: 4BFBCBE5  bl 0x82e869c8
	ctx.lr = 0x82EC9DE8;
	sub_82E869C8(ctx, base);
	// 82EC9DE8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC9DEC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC9DF0: 409A000C  bne cr6, 0x82ec9dfc
	if !ctx.cr[6].eq {
	pc = 0x82EC9DFC; continue 'dispatch;
	}
	// 82EC9DF4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC9DF8: 48000088  b 0x82ec9e80
	pc = 0x82EC9E80; continue 'dispatch;
            }
            0x82EC9DFC => {
    //   block [0x82EC9DFC..0x82EC9E4C)
	// 82EC9DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC9E00: 482F2261  bl 0x831bc060
	ctx.lr = 0x82EC9E04;
	sub_831BC060(ctx, base);
	// 82EC9E04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC9E08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC9E0C: 396BB2D0  addi r11, r11, -0x4d30
	ctx.r[11].s64 = ctx.r[11].s64 + -19760;
	// 82EC9E10: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EC9E14: 4BDE2D3D  bl 0x82cacb50
	ctx.lr = 0x82EC9E18;
	sub_82CACB50(ctx, base);
	// 82EC9E18: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC9E1C: 40820060  bne 0x82ec9e7c
	if !ctx.cr[0].eq {
	pc = 0x82EC9E7C; continue 'dispatch;
	}
	// 82EC9E20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC9E24: 4BA43EE5  bl 0x8290dd08
	ctx.lr = 0x82EC9E28;
	sub_8290DD08(ctx, base);
	// 82EC9E28: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82EC9E2C: 41820050  beq 0x82ec9e7c
	if ctx.cr[0].eq {
	pc = 0x82EC9E7C; continue 'dispatch;
	}
	// 82EC9E30: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9E34: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EC9E38: 3BEB0050  addi r31, r11, 0x50
	ctx.r[31].s64 = ctx.r[11].s64 + 80;
	// 82EC9E3C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9E40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC9E44: 40990038  ble cr6, 0x82ec9e7c
	if !ctx.cr[6].gt {
	pc = 0x82EC9E7C; continue 'dispatch;
	}
	// 82EC9E48: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82EC9E4C; continue 'dispatch;
            }
            0x82EC9E4C => {
    //   block [0x82EC9E4C..0x82EC9E7C)
	// 82EC9E4C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9E50: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC9E54: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC9E58: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC9E5C: 4BDE2CF5  bl 0x82cacb50
	ctx.lr = 0x82EC9E60;
	sub_82CACB50(ctx, base);
	// 82EC9E60: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC9E64: 41820024  beq 0x82ec9e88
	if ctx.cr[0].eq {
	pc = 0x82EC9E88; continue 'dispatch;
	}
	// 82EC9E68: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9E6C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EC9E70: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EC9E74: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC9E78: 4198FFD4  blt cr6, 0x82ec9e4c
	if ctx.cr[6].lt {
	pc = 0x82EC9E4C; continue 'dispatch;
	}
	pc = 0x82EC9E7C; continue 'dispatch;
            }
            0x82EC9E7C => {
    //   block [0x82EC9E7C..0x82EC9E80)
	// 82EC9E7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC9E80; continue 'dispatch;
            }
            0x82EC9E80 => {
    //   block [0x82EC9E80..0x82EC9E88)
	// 82EC9E80: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC9E84: 4BDDF5D0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EC9E88 => {
    //   block [0x82EC9E88..0x82EC9EC4)
	// 82EC9E88: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9E8C: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC9E90: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC9E94: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9E98: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82EC9E9C: 4182FFE0  beq 0x82ec9e7c
	if ctx.cr[0].eq {
	pc = 0x82EC9E7C; continue 'dispatch;
	}
	// 82EC9EA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC9EA4: 387C006C  addi r3, r28, 0x6c
	ctx.r[3].s64 = ctx.r[28].s64 + 108;
	// 82EC9EA8: 4BFEF3E9  bl 0x82eb9290
	ctx.lr = 0x82EC9EAC;
	sub_82EB9290(ctx, base);
	// 82EC9EAC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC9EB0: 815C0068  lwz r10, 0x68(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC9EB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC9EB8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC9EBC: 917C0068  stw r11, 0x68(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EC9EC0: 4BFFFFC0  b 0x82ec9e80
	pc = 0x82EC9E80; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC9EC8 size=284
    let mut pc: u32 = 0x82EC9EC8;
    'dispatch: loop {
        match pc {
            0x82EC9EC8 => {
    //   block [0x82EC9EC8..0x82EC9F0C)
	// 82EC9EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9ECC: 4BDDF541  bl 0x82ca940c
	ctx.lr = 0x82EC9ED0;
	sub_82CA93D0(ctx, base);
	// 82EC9ED0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EC9ED4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC9ED8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC9EDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC9EE0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC9EE4: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC9EE8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9EEC: 408200E4  bne 0x82ec9fd0
	if !ctx.cr[0].eq {
	pc = 0x82EC9FD0; continue 'dispatch;
	}
	// 82EC9EF0: 4B396AC9  bl 0x822609b8
	ctx.lr = 0x82EC9EF4;
	sub_822609B8(ctx, base);
	// 82EC9EF4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9EF8: C3E3004C  lfs f31, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC9EFC: 816B00A4  lwz r11, 0xa4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC9F00: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC9F04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC9F08: C3CB0BEC  lfs f30, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x82EC9F0C; continue 'dispatch;
            }
            0x82EC9F0C => {
    //   block [0x82EC9F0C..0x82EC9F5C)
	// 82EC9F0C: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EC9F10: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC9F14: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC9F18: 418200B0  beq 0x82ec9fc8
	if ctx.cr[0].eq {
	pc = 0x82EC9FC8; continue 'dispatch;
	}
	// 82EC9F1C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC9F20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9F24: 4182009C  beq 0x82ec9fc0
	if ctx.cr[0].eq {
	pc = 0x82EC9FC0; continue 'dispatch;
	}
	// 82EC9F28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC9F2C: 3BDF00A4  addi r30, r31, 0xa4
	ctx.r[30].s64 = ctx.r[31].s64 + 164;
	// 82EC9F30: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC9F34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC9F38: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC9F3C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9F40: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9F44: 41820018  beq 0x82ec9f5c
	if ctx.cr[0].eq {
	pc = 0x82EC9F5C; continue 'dispatch;
	}
	// 82EC9F48: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC9F4C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9F50: 4182000C  beq 0x82ec9f5c
	if ctx.cr[0].eq {
	pc = 0x82EC9F5C; continue 'dispatch;
	}
	// 82EC9F54: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9F58: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82EC9F5C; continue 'dispatch;
            }
            0x82EC9F5C => {
    //   block [0x82EC9F5C..0x82EC9FA4)
	// 82EC9F5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC9F60: 4BFA7411  bl 0x82e71370
	ctx.lr = 0x82EC9F64;
	sub_82E71370(ctx, base);
	// 82EC9F64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC9F68: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC9F6C: 4BFBF115  bl 0x82e89080
	ctx.lr = 0x82EC9F70;
	sub_82E89080(ctx, base);
	// 82EC9F70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC9F74: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9F78: 4BFBD3D9  bl 0x82e87350
	ctx.lr = 0x82EC9F7C;
	sub_82E87350(ctx, base);
	// 82EC9F7C: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 82EC9F80: 419A0034  beq cr6, 0x82ec9fb4
	if ctx.cr[6].eq {
	pc = 0x82EC9FB4; continue 'dispatch;
	}
	// 82EC9F84: EC1F0828  fsubs f0, f31, f1
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC9F88: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC9F8C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC9F90: 40980014  bge cr6, 0x82ec9fa4
	if !ctx.cr[6].lt {
	pc = 0x82EC9FA4; continue 'dispatch;
	}
	// 82EC9F94: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9F98: C1AB0098  lfs f13, 0x98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC9F9C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC9FA0: 41980014  blt cr6, 0x82ec9fb4
	if ctx.cr[6].lt {
	pc = 0x82EC9FB4; continue 'dispatch;
	}
	pc = 0x82EC9FA4; continue 'dispatch;
            }
            0x82EC9FA4 => {
    //   block [0x82EC9FA4..0x82EC9FB4)
	// 82EC9FA4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC9FA8: 809F00C4  lwz r4, 0xc4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EC9FAC: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC9FB0: 4BFBF149  bl 0x82e890f8
	ctx.lr = 0x82EC9FB4;
	sub_82E890F8(ctx, base);
	pc = 0x82EC9FB4; continue 'dispatch;
            }
            0x82EC9FB4 => {
    //   block [0x82EC9FB4..0x82EC9FC0)
	// 82EC9FB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC9FB8: 4BFFF489  bl 0x82ec9440
	ctx.lr = 0x82EC9FBC;
	sub_82EC9440(ctx, base);
	// 82EC9FBC: 4BFFFF50  b 0x82ec9f0c
	pc = 0x82EC9F0C; continue 'dispatch;
            }
            0x82EC9FC0 => {
    //   block [0x82EC9FC0..0x82EC9FC8)
	// 82EC9FC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC9FC4: 48000010  b 0x82ec9fd4
	pc = 0x82EC9FD4; continue 'dispatch;
            }
            0x82EC9FC8 => {
    //   block [0x82EC9FC8..0x82EC9FD0)
	// 82EC9FC8: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 82EC9FCC: 4BFFF655  bl 0x82ec9620
	ctx.lr = 0x82EC9FD0;
	sub_82EC9620(ctx, base);
	pc = 0x82EC9FD0; continue 'dispatch;
            }
            0x82EC9FD0 => {
    //   block [0x82EC9FD0..0x82EC9FD4)
	// 82EC9FD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC9FD4; continue 'dispatch;
            }
            0x82EC9FD4 => {
    //   block [0x82EC9FD4..0x82EC9FE4)
	// 82EC9FD4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC9FD8: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EC9FDC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC9FE0: 4BDDF47C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC9FE8 size=172
    let mut pc: u32 = 0x82EC9FE8;
    'dispatch: loop {
        match pc {
            0x82EC9FE8 => {
    //   block [0x82EC9FE8..0x82ECA014)
	// 82EC9FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC9FF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC9FF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC9FF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC9FFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA000: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ECA004: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA008: 4182000C  beq 0x82eca014
	if ctx.cr[0].eq {
	pc = 0x82ECA014; continue 'dispatch;
	}
	// 82ECA00C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECA010: 4800006C  b 0x82eca07c
	pc = 0x82ECA07C; continue 'dispatch;
            }
            0x82ECA014 => {
    //   block [0x82ECA014..0x82ECA02C)
	// 82ECA014: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ECA018: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECA01C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECA020: 915F0068  stw r10, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82ECA024: 40990030  ble cr6, 0x82eca054
	if !ctx.cr[6].gt {
	pc = 0x82ECA054; continue 'dispatch;
	}
	// 82ECA028: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	pc = 0x82ECA02C; continue 'dispatch;
            }
            0x82ECA02C => {
    //   block [0x82ECA02C..0x82ECA054)
	// 82ECA02C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECA030: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ECA034: 811F0068  lwz r8, 0x68(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82ECA038: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ECA03C: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECA040: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82ECA044: 913F0068  stw r9, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 82ECA048: 813F0078  lwz r9, 0x78(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECA04C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ECA050: 4198FFDC  blt cr6, 0x82eca02c
	if ctx.cr[6].lt {
	pc = 0x82ECA02C; continue 'dispatch;
	}
	pc = 0x82ECA054; continue 'dispatch;
            }
            0x82ECA054 => {
    //   block [0x82ECA054..0x82ECA07C)
	// 82ECA054: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82ECA058: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82ECA05C: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82ECA060: 7FCB21D6  mullw r30, r11, r4
	ctx.r[30].s32 = ((ctx.r[11].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[30].s64 = ctx.r[30].s32 as i64;
	// 82ECA064: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA068: 4BFFFC69  bl 0x82ec9cd0
	ctx.lr = 0x82ECA06C;
	sub_82EC9CD0(ctx, base);
	// 82ECA06C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA070: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECA074: 4BFBEF75  bl 0x82e88fe8
	ctx.lr = 0x82ECA078;
	sub_82E88FE8(ctx, base);
	// 82ECA078: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82ECA07C; continue 'dispatch;
            }
            0x82ECA07C => {
    //   block [0x82ECA07C..0x82ECA094)
	// 82ECA07C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECA080: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECA084: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECA088: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECA08C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECA090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA098 size=88
    let mut pc: u32 = 0x82ECA098;
    'dispatch: loop {
        match pc {
            0x82ECA098 => {
    //   block [0x82ECA098..0x82ECA0D4)
	// 82ECA098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA09C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECA0A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECA0A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECA0A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA0AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA0B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ECA0B4: 4BFFEF8D  bl 0x82ec9040
	ctx.lr = 0x82ECA0B8;
	sub_82EC9040(ctx, base);
	// 82ECA0B8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECA0BC: 41820018  beq 0x82eca0d4
	if ctx.cr[0].eq {
	pc = 0x82ECA0D4; continue 'dispatch;
	}
	// 82ECA0C0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ECA0C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA0C8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECA0CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECA0D0: 4E800421  bctrl
	ctx.lr = 0x82ECA0D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ECA0D4 => {
    //   block [0x82ECA0D4..0x82ECA0F0)
	// 82ECA0D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA0D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECA0DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECA0E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECA0E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECA0E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECA0EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECA0F0 size=12
    let mut pc: u32 = 0x82ECA0F0;
    'dispatch: loop {
        match pc {
            0x82ECA0F0 => {
    //   block [0x82ECA0F0..0x82ECA0FC)
	// 82ECA0F0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECA0F4: 386BE6D4  addi r3, r11, -0x192c
	ctx.r[3].s64 = ctx.r[11].s64 + -6444;
	// 82ECA0F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA100 size=92
    let mut pc: u32 = 0x82ECA100;
    'dispatch: loop {
        match pc {
            0x82ECA100 => {
    //   block [0x82ECA100..0x82ECA150)
	// 82ECA100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA104: 4BDDF305  bl 0x82ca9408
	ctx.lr = 0x82ECA108;
	sub_82CA93D0(ctx, base);
	// 82ECA108: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA10C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECA110: 386000CC  li r3, 0xcc
	ctx.r[3].s64 = 204;
	// 82ECA114: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ECA118: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ECA11C: 4B74C80D  bl 0x82616928
	ctx.lr = 0x82ECA120;
	sub_82616928(ctx, base);
	// 82ECA120: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ECA124: 4182002C  beq 0x82eca150
	if ctx.cr[0].eq {
	pc = 0x82ECA150; continue 'dispatch;
	}
	// 82ECA128: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82ECA12C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECA130: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA138: 4BFFEF59  bl 0x82ec9090
	ctx.lr = 0x82ECA13C;
	sub_82EC9090(ctx, base);
	// 82ECA13C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECA140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA144: 396BB474  addi r11, r11, -0x4b8c
	ctx.r[11].s64 = ctx.r[11].s64 + -19340;
	// 82ECA148: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECA14C: 48000008  b 0x82eca154
	pc = 0x82ECA154; continue 'dispatch;
            }
            0x82ECA150 => {
    //   block [0x82ECA150..0x82ECA154)
	// 82ECA150: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ECA154; continue 'dispatch;
            }
            0x82ECA154 => {
    //   block [0x82ECA154..0x82ECA15C)
	// 82ECA154: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECA158: 4BDDF300  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECA160 size=244
    let mut pc: u32 = 0x82ECA160;
    'dispatch: loop {
        match pc {
            0x82ECA160 => {
    //   block [0x82ECA160..0x82ECA1CC)
	// 82ECA160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA164: 4BDDF2A1  bl 0x82ca9404
	ctx.lr = 0x82ECA168;
	sub_82CA93D0(ctx, base);
	// 82ECA168: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA16C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ECA170: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ECA174: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82ECA178: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECA17C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA180: 418200B8  beq 0x82eca238
	if ctx.cr[0].eq {
	pc = 0x82ECA238; continue 'dispatch;
	}
	// 82ECA184: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ECA188: 388B1048  addi r4, r11, 0x1048
	ctx.r[4].s64 = ctx.r[11].s64 + 4168;
	// 82ECA18C: 4B39D385  bl 0x82267510
	ctx.lr = 0x82ECA190;
	sub_82267510(ctx, base);
	// 82ECA190: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ECA194: 418200A4  beq 0x82eca238
	if ctx.cr[0].eq {
	pc = 0x82ECA238; continue 'dispatch;
	}
	// 82ECA198: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ECA19C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ECA1A0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82ECA1A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ECA1A8: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82ECA1AC: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECA1B0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82ECA1B4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ECA1B8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82ECA1BC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82ECA1C0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82ECA1C4: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82ECA1C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82ECA1CC; continue 'dispatch;
            }
            0x82ECA1CC => {
    //   block [0x82ECA1CC..0x82ECA230)
	// 82ECA1CC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ECA1D0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82ECA1D4: 4200FFF8  bdnz 0x82eca1cc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82ECA1CC; continue 'dispatch;
	}
	// 82ECA1D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECA1DC: 9BE100B8  stb r31, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u8 ) };
	// 82ECA1E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ECA1E4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82ECA1E8: 396B10BC  addi r11, r11, 0x10bc
	ctx.r[11].s64 = ctx.r[11].s64 + 4284;
	// 82ECA1EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ECA1F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ECA1F4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82ECA1F8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82ECA1FC: 4B2E44AD  bl 0x821ae6a8
	ctx.lr = 0x82ECA200;
	sub_821AE6A8(ctx, base);
	// 82ECA200: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECA204: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82ECA208: 389D0034  addi r4, r29, 0x34
	ctx.r[4].s64 = ctx.r[29].s64 + 52;
	// 82ECA20C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECA210: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECA214: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECA218: 4E800421  bctrl
	ctx.lr = 0x82ECA21C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECA21C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82ECA220: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ECA224: 409A000C  bne cr6, 0x82eca230
	if !ctx.cr[6].eq {
	pc = 0x82ECA230; continue 'dispatch;
	}
	// 82ECA228: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ECA22C: 48000010  b 0x82eca23c
	pc = 0x82ECA23C; continue 'dispatch;
            }
            0x82ECA230 => {
    //   block [0x82ECA230..0x82ECA238)
	// 82ECA230: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ECA234: 4800000C  b 0x82eca240
	pc = 0x82ECA240; continue 'dispatch;
            }
            0x82ECA238 => {
    //   block [0x82ECA238..0x82ECA23C)
	// 82ECA238: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82ECA23C; continue 'dispatch;
            }
            0x82ECA23C => {
    //   block [0x82ECA23C..0x82ECA240)
	// 82ECA23C: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82ECA240; continue 'dispatch;
            }
            0x82ECA240 => {
    //   block [0x82ECA240..0x82ECA254)
	// 82ECA240: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ECA244: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECA248: 997B0000  stb r11, 0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82ECA24C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82ECA250: 4BDDF204  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA258 size=112
    let mut pc: u32 = 0x82ECA258;
    'dispatch: loop {
        match pc {
            0x82ECA258 => {
    //   block [0x82ECA258..0x82ECA2B8)
	// 82ECA258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA25C: 4BDDF1B1  bl 0x82ca940c
	ctx.lr = 0x82ECA260;
	sub_82CA93D0(ctx, base);
	// 82ECA260: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA264: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA268: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82ECA26C: 4BFBC36D  bl 0x82e865d8
	ctx.lr = 0x82ECA270;
	sub_82E865D8(ctx, base);
	// 82ECA270: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECA274: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82ECA278: 396BB408  addi r11, r11, -0x4bf8
	ctx.r[11].s64 = ctx.r[11].s64 + -19448;
	// 82ECA27C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ECA280: 394AA8F0  addi r10, r10, -0x5710
	ctx.r[10].s64 = ctx.r[10].s64 + -22288;
	// 82ECA284: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ECA288: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECA28C: 93BF0058  stw r29, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82ECA290: 915F0054  stw r10, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82ECA294: 93BF005C  stw r29, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82ECA298: 93BF0060  stw r29, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82ECA29C: 83DE00AC  lwz r30, 0xac(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 82ECA2A0: 4B74C689  bl 0x82616928
	ctx.lr = 0x82ECA2A4;
	sub_82616928(ctx, base);
	// 82ECA2A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA2A8: 41820010  beq 0x82eca2b8
	if ctx.cr[0].eq {
	pc = 0x82ECA2B8; continue 'dispatch;
	}
	// 82ECA2AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA2B0: 4BFBECB9  bl 0x82e88f68
	ctx.lr = 0x82ECA2B4;
	sub_82E88F68(ctx, base);
	// 82ECA2B4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	pc = 0x82ECA2B8; continue 'dispatch;
            }
            0x82ECA2B8 => {
    //   block [0x82ECA2B8..0x82ECA2C8)
	// 82ECA2B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA2BC: 93BF0064  stw r29, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82ECA2C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECA2C4: 4BDDF198  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA2C8 size=120
    let mut pc: u32 = 0x82ECA2C8;
    'dispatch: loop {
        match pc {
            0x82ECA2C8 => {
    //   block [0x82ECA2C8..0x82ECA308)
	// 82ECA2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA2CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECA2D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECA2D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECA2D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA2DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECA2E0: 807E0064  lwz r3, 0x64(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECA2E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA2E8: 41820040  beq 0x82eca328
	if ctx.cr[0].eq {
	pc = 0x82ECA328; continue 'dispatch;
	}
	// 82ECA2EC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECA2F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ECA2F4: 816B00A4  lwz r11, 0xa4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82ECA2F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ECA2FC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECA300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECA304: 40990024  ble cr6, 0x82eca328
	if !ctx.cr[6].gt {
	pc = 0x82ECA328; continue 'dispatch;
	}
	pc = 0x82ECA308; continue 'dispatch;
            }
            0x82ECA308 => {
    //   block [0x82ECA308..0x82ECA328)
	// 82ECA308: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ECA30C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECA310: 4BFBEDE9  bl 0x82e890f8
	ctx.lr = 0x82ECA314;
	sub_82E890F8(ctx, base);
	// 82ECA314: 807E0064  lwz r3, 0x64(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECA318: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82ECA31C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECA320: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECA324: 4198FFE4  blt cr6, 0x82eca308
	if ctx.cr[6].lt {
	pc = 0x82ECA308; continue 'dispatch;
	}
	pc = 0x82ECA328; continue 'dispatch;
            }
            0x82ECA328 => {
    //   block [0x82ECA328..0x82ECA340)
	// 82ECA328: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECA32C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECA330: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECA334: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECA338: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECA33C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA340 size=88
    let mut pc: u32 = 0x82ECA340;
    'dispatch: loop {
        match pc {
            0x82ECA340 => {
    //   block [0x82ECA340..0x82ECA398)
	// 82ECA340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECA348: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECA34C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA354: 4BFFFF05  bl 0x82eca258
	ctx.lr = 0x82ECA358;
	sub_82ECA258(ctx, base);
	// 82ECA358: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECA35C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ECA360: 394BB4C4  addi r10, r11, -0x4b3c
	ctx.r[10].s64 = ctx.r[11].s64 + -19260;
	// 82ECA364: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ECA368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA36C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82ECA370: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ECA374: 913F006C  stw r9, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 82ECA378: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82ECA37C: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82ECA380: 913F0074  stw r9, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82ECA384: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ECA388: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECA38C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECA390: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECA394: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA398 size=104
    let mut pc: u32 = 0x82ECA398;
    'dispatch: loop {
        match pc {
            0x82ECA398 => {
    //   block [0x82ECA398..0x82ECA3C8)
	// 82ECA398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA39C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECA3A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECA3A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECA3A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA3AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA3B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ECA3B4: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ECA3B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA3BC: 4182000C  beq 0x82eca3c8
	if ctx.cr[0].eq {
	pc = 0x82ECA3C8; continue 'dispatch;
	}
	// 82ECA3C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECA3C4: 48000024  b 0x82eca3e8
	pc = 0x82ECA3E8; continue 'dispatch;
            }
            0x82ECA3C8 => {
    //   block [0x82ECA3C8..0x82ECA3E8)
	// 82ECA3C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82ECA3CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA3D0: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82ECA3D4: 4BFBDA55  bl 0x82e87e28
	ctx.lr = 0x82ECA3D8;
	sub_82E87E28(ctx, base);
	// 82ECA3D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA3DC: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECA3E0: 4BFBEC09  bl 0x82e88fe8
	ctx.lr = 0x82ECA3E4;
	sub_82E88FE8(ctx, base);
	// 82ECA3E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82ECA3E8; continue 'dispatch;
            }
            0x82ECA3E8 => {
    //   block [0x82ECA3E8..0x82ECA400)
	// 82ECA3E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECA3EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECA3F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECA3F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECA3F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECA3FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECA400 size=12
    let mut pc: u32 = 0x82ECA400;
    'dispatch: loop {
        match pc {
            0x82ECA400 => {
    //   block [0x82ECA400..0x82ECA40C)
	// 82ECA400: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECA404: 386BE7E8  addi r3, r11, -0x1818
	ctx.r[3].s64 = ctx.r[11].s64 + -6168;
	// 82ECA408: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA410 size=92
    let mut pc: u32 = 0x82ECA410;
    'dispatch: loop {
        match pc {
            0x82ECA410 => {
    //   block [0x82ECA410..0x82ECA460)
	// 82ECA410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA414: 4BDDEFF5  bl 0x82ca9408
	ctx.lr = 0x82ECA418;
	sub_82CA93D0(ctx, base);
	// 82ECA418: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA41C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECA420: 38600078  li r3, 0x78
	ctx.r[3].s64 = 120;
	// 82ECA424: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ECA428: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ECA42C: 4B74C4FD  bl 0x82616928
	ctx.lr = 0x82ECA430;
	sub_82616928(ctx, base);
	// 82ECA430: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ECA434: 4182002C  beq 0x82eca460
	if ctx.cr[0].eq {
	pc = 0x82ECA460; continue 'dispatch;
	}
	// 82ECA438: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82ECA43C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECA440: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA448: 4BFFFEF9  bl 0x82eca340
	ctx.lr = 0x82ECA44C;
	sub_82ECA340(ctx, base);
	// 82ECA44C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECA450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA454: 396BB4FC  addi r11, r11, -0x4b04
	ctx.r[11].s64 = ctx.r[11].s64 + -19204;
	// 82ECA458: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECA45C: 48000008  b 0x82eca464
	pc = 0x82ECA464; continue 'dispatch;
            }
            0x82ECA460 => {
    //   block [0x82ECA460..0x82ECA464)
	// 82ECA460: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ECA464; continue 'dispatch;
            }
            0x82ECA464 => {
    //   block [0x82ECA464..0x82ECA46C)
	// 82ECA464: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECA468: 4BDDEFF0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA470 size=132
    let mut pc: u32 = 0x82ECA470;
    'dispatch: loop {
        match pc {
            0x82ECA470 => {
    //   block [0x82ECA470..0x82ECA4CC)
	// 82ECA470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECA478: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECA47C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECA480: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA484: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA488: 4BFBC8B1  bl 0x82e86d38
	ctx.lr = 0x82ECA48C;
	sub_82E86D38(ctx, base);
	// 82ECA48C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECA490: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECA494: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECA498: 388BE6D4  addi r4, r11, -0x192c
	ctx.r[4].s64 = ctx.r[11].s64 + -6444;
	// 82ECA49C: 4BFBD235  bl 0x82e876d0
	ctx.lr = 0x82ECA4A0;
	sub_82E876D0(ctx, base);
	// 82ECA4A0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82ECA4A4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECA4A8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECA4AC: 388BE398  addi r4, r11, -0x1c68
	ctx.r[4].s64 = ctx.r[11].s64 + -7272;
	// 82ECA4B0: 915F0078  stw r10, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82ECA4B4: 4BFBD21D  bl 0x82e876d0
	ctx.lr = 0x82ECA4B8;
	sub_82E876D0(ctx, base);
	// 82ECA4B8: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECA4BC: 907F007C  stw r3, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 82ECA4C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECA4C4: 409A0008  bne cr6, 0x82eca4cc
	if !ctx.cr[6].eq {
	pc = 0x82ECA4CC; continue 'dispatch;
	}
	// 82ECA4C8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ECA4CC; continue 'dispatch;
            }
            0x82ECA4CC => {
    //   block [0x82ECA4CC..0x82ECA4D8)
	// 82ECA4CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ECA4D0: 409A0008  bne cr6, 0x82eca4d8
	if !ctx.cr[6].eq {
	pc = 0x82ECA4D8; continue 'dispatch;
	}
	// 82ECA4D4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ECA4D8; continue 'dispatch;
            }
            0x82ECA4D8 => {
    //   block [0x82ECA4D8..0x82ECA4F4)
	// 82ECA4D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECA4DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECA4E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECA4E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECA4E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECA4EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECA4F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECA4F8 size=124
    let mut pc: u32 = 0x82ECA4F8;
    'dispatch: loop {
        match pc {
            0x82ECA4F8 => {
    //   block [0x82ECA4F8..0x82ECA4FC)
	// 82ECA4F8: 4800001C  b 0x82eca514
	pc = 0x82ECA514; continue 'dispatch;
            }
            0x82ECA4FC => {
    //   block [0x82ECA4FC..0x82ECA514)
	// 82ECA4FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECA500: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82ECA504: 409A0038  bne cr6, 0x82eca53c
	if !ctx.cr[6].eq {
	pc = 0x82ECA53C; continue 'dispatch;
	}
	// 82ECA508: 8163006C  lwz r11, 0x6c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ECA50C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECA510: 9163006C  stw r11, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	pc = 0x82ECA514; continue 'dispatch;
            }
            0x82ECA514 => {
    //   block [0x82ECA514..0x82ECA524)
	// 82ECA514: 8163006C  lwz r11, 0x6c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ECA518: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA51C: 4082FFE0  bne 0x82eca4fc
	if !ctx.cr[0].eq {
	pc = 0x82ECA4FC; continue 'dispatch;
	}
	// 82ECA520: 4800001C  b 0x82eca53c
	pc = 0x82ECA53C; continue 'dispatch;
            }
            0x82ECA524 => {
    //   block [0x82ECA524..0x82ECA53C)
	// 82ECA524: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECA528: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82ECA52C: 409A001C  bne cr6, 0x82eca548
	if !ctx.cr[6].eq {
	pc = 0x82ECA548; continue 'dispatch;
	}
	// 82ECA530: 81630074  lwz r11, 0x74(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ECA534: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECA538: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	pc = 0x82ECA53C; continue 'dispatch;
            }
            0x82ECA53C => {
    //   block [0x82ECA53C..0x82ECA548)
	// 82ECA53C: 81630074  lwz r11, 0x74(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ECA540: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA544: 4082FFE0  bne 0x82eca524
	if !ctx.cr[0].eq {
	pc = 0x82ECA524; continue 'dispatch;
	}
	pc = 0x82ECA548; continue 'dispatch;
            }
            0x82ECA548 => {
    //   block [0x82ECA548..0x82ECA574)
	// 82ECA548: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECA54C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECA550: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82ECA554: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ECA558: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA55C: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82ECA560: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECA564: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82ECA568: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82ECA56C: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82ECA570: 4BFBBFC0  b 0x82e86530
	sub_82E86530(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECA578 size=352
    let mut pc: u32 = 0x82ECA578;
    'dispatch: loop {
        match pc {
            0x82ECA578 => {
    //   block [0x82ECA578..0x82ECA5DC)
	// 82ECA578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA57C: 4BDDEE7D  bl 0x82ca93f8
	ctx.lr = 0x82ECA580;
	sub_82CA93D0(ctx, base);
	// 82ECA580: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82ECA584: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA588: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA58C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ECA590: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82ECA594: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82ECA598: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82ECA59C: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECA5A0: 4BFBEAE1  bl 0x82e89080
	ctx.lr = 0x82ECA5A4;
	sub_82E89080(ctx, base);
	// 82ECA5A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ECA5A8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECA5AC: 4BFBCDA5  bl 0x82e87350
	ctx.lr = 0x82ECA5B0;
	sub_82E87350(ctx, base);
	// 82ECA5B0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82ECA5B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECA5B8: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82ECA5BC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82ECA5C0: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 82ECA5C4: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECA5C8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82ECA5CC: 419A0010  beq cr6, 0x82eca5dc
	if ctx.cr[6].eq {
	pc = 0x82ECA5DC; continue 'dispatch;
	}
	// 82ECA5D0: 4B3963E9  bl 0x822609b8
	ctx.lr = 0x82ECA5D4;
	sub_822609B8(ctx, base);
	// 82ECA5D4: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECA5D8: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	pc = 0x82ECA5DC; continue 'dispatch;
            }
            0x82ECA5DC => {
    //   block [0x82ECA5DC..0x82ECA5F0)
	// 82ECA5DC: C1BF003C  lfs f13, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECA5E0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECA5E4: 4098000C  bge cr6, 0x82eca5f0
	if !ctx.cr[6].lt {
	pc = 0x82ECA5F0; continue 'dispatch;
	}
	// 82ECA5E8: 3B600002  li r27, 2
	ctx.r[27].s64 = 2;
	// 82ECA5EC: 4800002C  b 0x82eca618
	pc = 0x82ECA618; continue 'dispatch;
            }
            0x82ECA5F0 => {
    //   block [0x82ECA5F0..0x82ECA60C)
	// 82ECA5F0: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECA5F4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECA5F8: 40980014  bge cr6, 0x82eca60c
	if !ctx.cr[6].lt {
	pc = 0x82ECA60C; continue 'dispatch;
	}
	// 82ECA5FC: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 82ECA600: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 82ECA604: 409A0014  bne cr6, 0x82eca618
	if !ctx.cr[6].eq {
	pc = 0x82ECA618; continue 'dispatch;
	}
	// 82ECA608: 4800000C  b 0x82eca614
	pc = 0x82ECA614; continue 'dispatch;
            }
            0x82ECA60C => {
    //   block [0x82ECA60C..0x82ECA614)
	// 82ECA60C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ECA610: 40990008  ble cr6, 0x82eca618
	if !ctx.cr[6].gt {
	pc = 0x82ECA618; continue 'dispatch;
	}
	pc = 0x82ECA614; continue 'dispatch;
            }
            0x82ECA614 => {
    //   block [0x82ECA614..0x82ECA618)
	// 82ECA614: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82ECA618; continue 'dispatch;
            }
            0x82ECA618 => {
    //   block [0x82ECA618..0x82ECA634)
	// 82ECA618: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECA61C: 4082009C  bne 0x82eca6b8
	if !ctx.cr[0].eq {
	pc = 0x82ECA6B8; continue 'dispatch;
	}
	// 82ECA620: 2F1A0001  cmpwi cr6, r26, 1
	ctx.cr[6].compare_i32(ctx.r[26].s32, 1, &mut ctx.xer);
	// 82ECA624: 409A0054  bne cr6, 0x82eca678
	if !ctx.cr[6].eq {
	pc = 0x82ECA678; continue 'dispatch;
	}
	// 82ECA628: 4B396391  bl 0x822609b8
	ctx.lr = 0x82ECA62C;
	sub_822609B8(ctx, base);
	// 82ECA62C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECA630: 48000030  b 0x82eca660
	pc = 0x82ECA660; continue 'dispatch;
            }
            0x82ECA634 => {
    //   block [0x82ECA634..0x82ECA660)
	// 82ECA634: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECA638: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ECA63C: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 82ECA640: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ECA644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA648: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ECA64C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECA650: 4E800421  bctrl
	ctx.lr = 0x82ECA654;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECA654: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ECA658: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA65C: 40820050  bne 0x82eca6ac
	if !ctx.cr[0].eq {
	pc = 0x82ECA6AC; continue 'dispatch;
	}
            }
            0x82ECA660 => {
    //   block [0x82ECA660..0x82ECA678)
	// 82ECA660: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECA664: 4BFB6FED  bl 0x82e81650
	ctx.lr = 0x82ECA668;
	sub_82E81650(ctx, base);
	// 82ECA668: 897E006C  lbz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ECA66C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ECA670: 409AFFC4  bne cr6, 0x82eca634
	if !ctx.cr[6].eq {
	pc = 0x82ECA634; continue 'dispatch;
	}
	// 82ECA674: 48000044  b 0x82eca6b8
	pc = 0x82ECA6B8; continue 'dispatch;
            }
            0x82ECA678 => {
    //   block [0x82ECA678..0x82ECA680)
	// 82ECA678: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 82ECA67C: 409A003C  bne cr6, 0x82eca6b8
	if !ctx.cr[6].eq {
	pc = 0x82ECA6B8; continue 'dispatch;
	}
	pc = 0x82ECA680; continue 'dispatch;
            }
            0x82ECA680 => {
    //   block [0x82ECA680..0x82ECA6AC)
	// 82ECA680: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECA684: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ECA688: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 82ECA68C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ECA690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA694: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ECA698: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECA69C: 4E800421  bctrl
	ctx.lr = 0x82ECA6A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECA6A0: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ECA6A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA6A8: 4182FFD8  beq 0x82eca680
	if ctx.cr[0].eq {
	pc = 0x82ECA680; continue 'dispatch;
	}
            }
            0x82ECA6AC => {
    //   block [0x82ECA6AC..0x82ECA6B8)
	// 82ECA6AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECA6B0: 41820008  beq 0x82eca6b8
	if ctx.cr[0].eq {
	pc = 0x82ECA6B8; continue 'dispatch;
	}
	// 82ECA6B4: 3B600002  li r27, 2
	ctx.r[27].s64 = 2;
	pc = 0x82ECA6B8; continue 'dispatch;
            }
            0x82ECA6B8 => {
    //   block [0x82ECA6B8..0x82ECA6D8)
	// 82ECA6B8: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ECA6BC: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ECA6C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82ECA6C4: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ECA6C8: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECA6CC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82ECA6D0: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82ECA6D4: 4BDDED74  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECA6D8 size=344
    let mut pc: u32 = 0x82ECA6D8;
    'dispatch: loop {
        match pc {
            0x82ECA6D8 => {
    //   block [0x82ECA6D8..0x82ECA6F8)
	// 82ECA6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA6DC: 4BDDED2D  bl 0x82ca9408
	ctx.lr = 0x82ECA6E0;
	sub_82CA93D0(ctx, base);
	// 82ECA6E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA6E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA6E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ECA6EC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82ECA6F0: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82ECA6F4: 409A000C  bne cr6, 0x82eca700
	if !ctx.cr[6].eq {
	pc = 0x82ECA700; continue 'dispatch;
	}
	pc = 0x82ECA6F8; continue 'dispatch;
            }
            0x82ECA6F8 => {
    //   block [0x82ECA6F8..0x82ECA700)
	// 82ECA6F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECA6FC: 480000C4  b 0x82eca7c0
	pc = 0x82ECA7C0; continue 'dispatch;
            }
            0x82ECA700 => {
    //   block [0x82ECA700..0x82ECA74C)
	// 82ECA700: 893F0044  lbz r9, 0x44(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ECA704: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA708: 40820044  bne 0x82eca74c
	if !ctx.cr[0].eq {
	pc = 0x82ECA74C; continue 'dispatch;
	}
	// 82ECA70C: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECA710: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECA714: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82ECA718: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82ECA71C: 554ADFFF  rlwinm. r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECA720: 4182002C  beq 0x82eca74c
	if ctx.cr[0].eq {
	pc = 0x82ECA74C; continue 'dispatch;
	}
	// 82ECA724: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECA728: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 82ECA72C: 815E006C  lwz r10, 0x6c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ECA730: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECA734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA738: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECA73C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82ECA740: 7C8B4B96  divwu r4, r11, r9
	ctx.r[4].u32 = ctx.r[11].u32 / ctx.r[9].u32;
	// 82ECA744: 4BFFFE35  bl 0x82eca578
	ctx.lr = 0x82ECA748;
	sub_82ECA578(ctx, base);
	// 82ECA748: 48000078  b 0x82eca7c0
	pc = 0x82ECA7C0; continue 'dispatch;
            }
            0x82ECA74C => {
    //   block [0x82ECA74C..0x82ECA764)
	// 82ECA74C: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 82ECA750: 419A0078  beq cr6, 0x82eca7c8
	if ctx.cr[6].eq {
	pc = 0x82ECA7C8; continue 'dispatch;
	}
	// 82ECA754: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ECA758: 419A000C  beq cr6, 0x82eca764
	if ctx.cr[6].eq {
	pc = 0x82ECA764; continue 'dispatch;
	}
	// 82ECA75C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82ECA760: 419A0068  beq cr6, 0x82eca7c8
	if ctx.cr[6].eq {
	pc = 0x82ECA7C8; continue 'dispatch;
	}
	pc = 0x82ECA764; continue 'dispatch;
            }
            0x82ECA764 => {
    //   block [0x82ECA764..0x82ECA76C)
	// 82ECA764: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 82ECA768: 409AFF90  bne cr6, 0x82eca6f8
	if !ctx.cr[6].eq {
	pc = 0x82ECA6F8; continue 'dispatch;
	}
	pc = 0x82ECA76C; continue 'dispatch;
            }
            0x82ECA76C => {
    //   block [0x82ECA76C..0x82ECA7B0)
	// 82ECA76C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82ECA770: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECA774: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA778: 4B408BE1  bl 0x822d3358
	ctx.lr = 0x82ECA77C;
	sub_822D3358(ctx, base);
	// 82ECA77C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECA780: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ECA784: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82ECA788: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECA78C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA790: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECA794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA798: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82ECA79C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECA7A0: 4E800421  bctrl
	ctx.lr = 0x82ECA7A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECA7A4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ECA7A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA7AC: 4182FFC0  beq 0x82eca76c
	if ctx.cr[0].eq {
	pc = 0x82ECA76C; continue 'dispatch;
	}
            }
            0x82ECA7B0 => {
    //   block [0x82ECA7B0..0x82ECA7C0)
	// 82ECA7B0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82ECA7B4: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 82ECA7B8: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82ECA7BC: 556307BC  rlwinm r3, r11, 0, 0x1e, 0x1e
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x82ECA7C0; continue 'dispatch;
            }
            0x82ECA7C0 => {
    //   block [0x82ECA7C0..0x82ECA7C8)
	// 82ECA7C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECA7C4: 4BDDEC94  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ECA7C8 => {
    //   block [0x82ECA7C8..0x82ECA7D4)
	// 82ECA7C8: 4B3961F1  bl 0x822609b8
	ctx.lr = 0x82ECA7CC;
	sub_822609B8(ctx, base);
	// 82ECA7CC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82ECA7D0: 48000048  b 0x82eca818
	pc = 0x82ECA818; continue 'dispatch;
            }
            0x82ECA7D4 => {
    //   block [0x82ECA7D4..0x82ECA818)
	// 82ECA7D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82ECA7D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECA7DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA7E0: 4B408B79  bl 0x822d3358
	ctx.lr = 0x82ECA7E4;
	sub_822D3358(ctx, base);
	// 82ECA7E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECA7E8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ECA7EC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82ECA7F0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECA7F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA7F8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECA7FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA800: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82ECA804: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECA808: 4E800421  bctrl
	ctx.lr = 0x82ECA80C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECA80C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ECA810: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA814: 4082FF9C  bne 0x82eca7b0
	if !ctx.cr[0].eq {
	pc = 0x82ECA7B0; continue 'dispatch;
	}
            }
            0x82ECA818 => {
    //   block [0x82ECA818..0x82ECA830)
	// 82ECA818: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ECA81C: 4BFB6E35  bl 0x82e81650
	ctx.lr = 0x82ECA820;
	sub_82E81650(ctx, base);
	// 82ECA820: 897C006C  lbz r11, 0x6c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ECA824: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ECA828: 409AFFAC  bne cr6, 0x82eca7d4
	if !ctx.cr[6].eq {
	pc = 0x82ECA7D4; continue 'dispatch;
	}
	// 82ECA82C: 4BFFFECC  b 0x82eca6f8
	pc = 0x82ECA6F8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECA830 size=360
    let mut pc: u32 = 0x82ECA830;
    'dispatch: loop {
        match pc {
            0x82ECA830 => {
    //   block [0x82ECA830..0x82ECA874)
	// 82ECA830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA834: 4BDDEBC1  bl 0x82ca93f4
	ctx.lr = 0x82ECA838;
	sub_82CA93D0(ctx, base);
	// 82ECA838: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82ECA83C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA840: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA844: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82ECA848: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82ECA84C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82ECA850: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82ECA854: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82ECA858: 897E0018  lbz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECA85C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA860: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECA864: C3EB0BEC  lfs f31, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ECA868: 4182000C  beq 0x82eca874
	if ctx.cr[0].eq {
	pc = 0x82ECA874; continue 'dispatch;
	}
	// 82ECA86C: D3FF0084  stfs f31, 0x84(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82ECA870: 935F0080  stw r26, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[26].u32 ) };
	pc = 0x82ECA874; continue 'dispatch;
            }
            0x82ECA874 => {
    //   block [0x82ECA874..0x82ECA888)
	// 82ECA874: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECA878: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82ECA87C: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82ECA880: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82ECA884: 419A00C8  beq cr6, 0x82eca94c
	if ctx.cr[6].eq {
	pc = 0x82ECA94C; continue 'dispatch;
	}
	pc = 0x82ECA888; continue 'dispatch;
            }
            0x82ECA888 => {
    //   block [0x82ECA888..0x82ECA930)
	// 82ECA888: 557B043E  clrlwi r27, r11, 0x10
	ctx.r[27].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82ECA88C: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82ECA890: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECA894: 409800B8  bge cr6, 0x82eca94c
	if !ctx.cr[6].lt {
	pc = 0x82ECA94C; continue 'dispatch;
	}
	// 82ECA898: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECA89C: 4BFBBBD5  bl 0x82e86470
	ctx.lr = 0x82ECA8A0;
	sub_82E86470(ctx, base);
	// 82ECA8A0: 7F03E040  cmplw cr6, r3, r28
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82ECA8A4: 419A008C  beq cr6, 0x82eca930
	if ctx.cr[6].eq {
	pc = 0x82ECA930; continue 'dispatch;
	}
	// 82ECA8A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECA8AC: 4BFBBBC5  bl 0x82e86470
	ctx.lr = 0x82ECA8B0;
	sub_82E86470(ctx, base);
	// 82ECA8B0: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82ECA8B4: 4182007C  beq 0x82eca930
	if ctx.cr[0].eq {
	pc = 0x82ECA930; continue 'dispatch;
	}
	// 82ECA8B8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECA8BC: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECA8C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ECA8C4: D3E10054  stfs f31, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82ECA8C8: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82ECA8CC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECA8D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ECA8D4: 4BFA726D  bl 0x82e71b40
	ctx.lr = 0x82ECA8D8;
	sub_82E71B40(ctx, base);
	// 82ECA8D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECA8DC: 41820090  beq 0x82eca96c
	if ctx.cr[0].eq {
	pc = 0x82ECA96C; continue 'dispatch;
	}
	// 82ECA8E0: C01F0084  lfs f0, 0x84(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECA8E4: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECA8E8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ECA8EC: 40980044  bge cr6, 0x82eca930
	if !ctx.cr[6].lt {
	pc = 0x82ECA930; continue 'dispatch;
	}
	// 82ECA8F0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECA8F4: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ECA8F8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ECA8FC: 9B410050  stb r26, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 82ECA900: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82ECA904: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECA908: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ECA90C: 4B406AA5  bl 0x822d13b0
	ctx.lr = 0x82ECA910;
	sub_822D13B0(ctx, base);
	// 82ECA910: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECA914: 41820068  beq 0x82eca97c
	if ctx.cr[0].eq {
	pc = 0x82ECA97C; continue 'dispatch;
	}
	// 82ECA918: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ECA91C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA920: 41820010  beq 0x82eca930
	if ctx.cr[0].eq {
	pc = 0x82ECA930; continue 'dispatch;
	}
	// 82ECA924: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECA928: 93BF0080  stw r29, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 82ECA92C: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	pc = 0x82ECA930; continue 'dispatch;
            }
            0x82ECA930 => {
    //   block [0x82ECA930..0x82ECA94C)
	// 82ECA930: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECA934: 4BFBBBFD  bl 0x82e86530
	ctx.lr = 0x82ECA938;
	sub_82E86530(ctx, base);
	// 82ECA938: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECA93C: 395B0001  addi r10, r27, 1
	ctx.r[10].s64 = ctx.r[27].s64 + 1;
	// 82ECA940: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECA944: 554B043E  clrlwi r11, r10, 0x10
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82ECA948: 409AFF40  bne cr6, 0x82eca888
	if !ctx.cr[6].eq {
	pc = 0x82ECA888; continue 'dispatch;
	}
	pc = 0x82ECA94C; continue 'dispatch;
            }
            0x82ECA94C => {
    //   block [0x82ECA94C..0x82ECA960)
	// 82ECA94C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECA950: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECA954: 419A0034  beq cr6, 0x82eca988
	if ctx.cr[6].eq {
	pc = 0x82ECA988; continue 'dispatch;
	}
	// 82ECA958: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECA95C: 9B570000  stb r26, 0(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	pc = 0x82ECA960; continue 'dispatch;
            }
            0x82ECA960 => {
    //   block [0x82ECA960..0x82ECA96C)
	// 82ECA960: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82ECA964: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82ECA968: 4BDDEADC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ECA96C => {
    //   block [0x82ECA96C..0x82ECA97C)
	// 82ECA96C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ECA970: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECA974: 99770000  stb r11, 0(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82ECA978: 4BFFFFE8  b 0x82eca960
	pc = 0x82ECA960; continue 'dispatch;
            }
            0x82ECA97C => {
    //   block [0x82ECA97C..0x82ECA980)
	// 82ECA97C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	pc = 0x82ECA980; continue 'dispatch;
            }
            0x82ECA980 => {
    //   block [0x82ECA980..0x82ECA988)
	// 82ECA980: 9B170000  stb r24, 0(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[24].u8 ) };
	// 82ECA984: 4BFFFFDC  b 0x82eca960
	pc = 0x82ECA960; continue 'dispatch;
            }
            0x82ECA988 => {
    //   block [0x82ECA988..0x82ECA998)
	// 82ECA988: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82ECA98C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82ECA990: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECA994: 4BFFFFEC  b 0x82eca980
	pc = 0x82ECA980; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECA998 size=16
    let mut pc: u32 = 0x82ECA998;
    'dispatch: loop {
        match pc {
            0x82ECA998 => {
    //   block [0x82ECA998..0x82ECA9A8)
	// 82ECA998: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECA99C: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ECA9A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECA9A4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECA9A8 size=284
    let mut pc: u32 = 0x82ECA9A8;
    'dispatch: loop {
        match pc {
            0x82ECA9A8 => {
    //   block [0x82ECA9A8..0x82ECAA00)
	// 82ECA9A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA9AC: 4BDDEA61  bl 0x82ca940c
	ctx.lr = 0x82ECA9B0;
	sub_82CA93D0(ctx, base);
	// 82ECA9B0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82ECA9B4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82ECA9B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA9BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA9C0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ECA9C4: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ECA9C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA9CC: 408200DC  bne 0x82ecaaa8
	if !ctx.cr[0].eq {
	pc = 0x82ECAAA8; continue 'dispatch;
	}
	// 82ECA9D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECA9D4: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ECA9D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ECA9DC: 814B00A8  lwz r10, 0xa8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 82ECA9E0: 812B009C  lwz r9, 0x9c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 82ECA9E4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ECA9E8: 816B00A4  lwz r11, 0xa4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82ECA9EC: 7FEA4C2E  lfsx f31, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ECA9F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ECA9F4: 419A00A4  beq cr6, 0x82ecaa98
	if ctx.cr[6].eq {
	pc = 0x82ECAA98; continue 'dispatch;
	}
	// 82ECA9F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECA9FC: C3CB0BEC  lfs f30, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x82ECAA00; continue 'dispatch;
            }
            0x82ECAA00 => {
    //   block [0x82ECAA00..0x82ECAA70)
	// 82ECAA00: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECAA04: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECAA08: 418200B4  beq 0x82ecaabc
	if ctx.cr[0].eq {
	pc = 0x82ECAABC; continue 'dispatch;
	}
	// 82ECAA0C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82ECAA10: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82ECAA14: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECAA18: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAA1C: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ECAA20: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECAA24: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAA28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECAA2C: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82ECAA30: 7FCB5396  divwu r30, r11, r10
	ctx.r[30].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82ECAA34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECAA38: 4BFBE649  bl 0x82e89080
	ctx.lr = 0x82ECAA3C;
	sub_82E89080(ctx, base);
	// 82ECAA3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ECAA40: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECAA44: 4BFBC90D  bl 0x82e87350
	ctx.lr = 0x82ECAA48;
	sub_82E87350(ctx, base);
	// 82ECAA48: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 82ECAA4C: 419A0034  beq cr6, 0x82ecaa80
	if ctx.cr[6].eq {
	pc = 0x82ECAA80; continue 'dispatch;
	}
	// 82ECAA50: EC1F0828  fsubs f0, f31, f1
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82ECAA54: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECAA58: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECAA5C: 40980014  bge cr6, 0x82ecaa70
	if !ctx.cr[6].lt {
	pc = 0x82ECAA70; continue 'dispatch;
	}
	// 82ECAA60: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECAA64: C1AB0098  lfs f13, 0x98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECAA68: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECAA6C: 41980014  blt cr6, 0x82ecaa80
	if ctx.cr[6].lt {
	pc = 0x82ECAA80; continue 'dispatch;
	}
	pc = 0x82ECAA70; continue 'dispatch;
            }
            0x82ECAA70 => {
    //   block [0x82ECAA70..0x82ECAA80)
	// 82ECAA70: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ECAA74: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECAA78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECAA7C: 4BFBE67D  bl 0x82e890f8
	ctx.lr = 0x82ECAA80;
	sub_82E890F8(ctx, base);
	pc = 0x82ECAA80; continue 'dispatch;
            }
            0x82ECAA80 => {
    //   block [0x82ECAA80..0x82ECAA98)
	// 82ECAA80: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ECAA84: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECAA88: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82ECAA8C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECAA90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECAA94: 409AFF6C  bne cr6, 0x82ecaa00
	if !ctx.cr[6].eq {
	pc = 0x82ECAA00; continue 'dispatch;
	}
	pc = 0x82ECAA98; continue 'dispatch;
            }
            0x82ECAA98 => {
    //   block [0x82ECAA98..0x82ECAAA8)
	// 82ECAA98: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAA9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAAA0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAAA4: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	pc = 0x82ECAAA8; continue 'dispatch;
            }
            0x82ECAAA8 => {
    //   block [0x82ECAAA8..0x82ECAAAC)
	// 82ECAAA8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82ECAAAC; continue 'dispatch;
            }
            0x82ECAAAC => {
    //   block [0x82ECAAAC..0x82ECAABC)
	// 82ECAAAC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ECAAB0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82ECAAB4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82ECAAB8: 4BDDE9A4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ECAABC => {
    //   block [0x82ECAABC..0x82ECAAC4)
	// 82ECAABC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECAAC0: 4BFFFFEC  b 0x82ecaaac
	pc = 0x82ECAAAC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECAAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECAAC8 size=212
    let mut pc: u32 = 0x82ECAAC8;
    'dispatch: loop {
        match pc {
            0x82ECAAC8 => {
    //   block [0x82ECAAC8..0x82ECAB04)
	// 82ECAAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECAACC: 4BDDE93D  bl 0x82ca9408
	ctx.lr = 0x82ECAAD0;
	sub_82CA93D0(ctx, base);
	// 82ECAAD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECAAD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECAAD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ECAADC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ECAAE0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAAE4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAAE8: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECAAEC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECAAF0: 40980014  bge cr6, 0x82ecab04
	if !ctx.cr[6].lt {
	pc = 0x82ECAB04; continue 'dispatch;
	}
	// 82ECAAF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECAAF8: 1D5E0014  mulli r10, r30, 0x14
	ctx.r[10].s32 = ((ctx.r[30].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ECAAFC: 7D6B5215  add. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECAB00: 4082000C  bne 0x82ecab0c
	if !ctx.cr[0].eq {
	pc = 0x82ECAB0C; continue 'dispatch;
	}
	pc = 0x82ECAB04; continue 'dispatch;
            }
            0x82ECAB04 => {
    //   block [0x82ECAB04..0x82ECAB0C)
	// 82ECAB04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECAB08: 4800008C  b 0x82ecab94
	pc = 0x82ECAB94; continue 'dispatch;
            }
            0x82ECAB0C => {
    //   block [0x82ECAB0C..0x82ECAB90)
	// 82ECAB0C: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82ECAB10: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECAB14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECAB18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ECAB1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECAB20: 915F004C  stw r10, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 82ECAB24: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECAB28: 4B408831  bl 0x822d3358
	ctx.lr = 0x82ECAB2C;
	sub_822D3358(ctx, base);
	// 82ECAB2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECAB30: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82ECAB34: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ECAB38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ECAB3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECAB40: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECAB44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECAB48: 4E800421  bctrl
	ctx.lr = 0x82ECAB4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECAB4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ECAB50: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECAB54: 4182003C  beq 0x82ecab90
	if ctx.cr[0].eq {
	pc = 0x82ECAB90; continue 'dispatch;
	}
	// 82ECAB58: 897C0000  lbz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECAB5C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECAB60: 41820030  beq 0x82ecab90
	if ctx.cr[0].eq {
	pc = 0x82ECAB90; continue 'dispatch;
	}
	// 82ECAB64: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ECAB68: 57C9103A  slwi r9, r30, 2
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82ECAB6C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ECAB70: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82ECAB74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECAB78: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82ECAB7C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECAB80: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECAB84: 816B00A8  lwz r11, 0xa8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 82ECAB88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ECAB8C: 4BFBE56D  bl 0x82e890f8
	ctx.lr = 0x82ECAB90;
	sub_82E890F8(ctx, base);
            }
            0x82ECAB90 => {
    //   block [0x82ECAB90..0x82ECAB94)
	// 82ECAB90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x82ECAB94; continue 'dispatch;
            }
            0x82ECAB94 => {
    //   block [0x82ECAB94..0x82ECAB9C)
	// 82ECAB94: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECAB98: 4BDDE8C0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECABA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECABA0 size=16
    let mut pc: u32 = 0x82ECABA0;
    'dispatch: loop {
        match pc {
            0x82ECABA0 => {
    //   block [0x82ECABA0..0x82ECABB0)
	// 82ECABA0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECABA4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECABA8: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECABAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECABB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECABB0 size=104
    let mut pc: u32 = 0x82ECABB0;
    'dispatch: loop {
        match pc {
            0x82ECABB0 => {
    //   block [0x82ECABB0..0x82ECAC08)
	// 82ECABB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECABB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECABB8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECABBC: 89630044  lbz r11, 0x44(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ECABC0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECABC4: 40820044  bne 0x82ecac08
	if !ctx.cr[0].eq {
	pc = 0x82ECAC08; continue 'dispatch;
	}
	// 82ECABC8: 81640064  lwz r11, 0x64(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECABCC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECABD0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECABD4: 409A0034  bne cr6, 0x82ecac08
	if !ctx.cr[6].eq {
	pc = 0x82ECAC08; continue 'dispatch;
	}
	// 82ECABD8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECABDC: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 82ECABE0: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECABE4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ECABE8: 8144006C  lwz r10, 0x6c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ECABEC: 80630064  lwz r3, 0x64(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECABF0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECABF4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82ECABF8: 814800A4  lwz r10, 0xa4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(164 as u32) ) } as u64;
	// 82ECABFC: 7C8B4B96  divwu r4, r11, r9
	ctx.r[4].u32 = ctx.r[11].u32 / ctx.r[9].u32;
	// 82ECAC00: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ECAC04: 4BFBE4F5  bl 0x82e890f8
	ctx.lr = 0x82ECAC08;
	sub_82E890F8(ctx, base);
	pc = 0x82ECAC08; continue 'dispatch;
            }
            0x82ECAC08 => {
    //   block [0x82ECAC08..0x82ECAC18)
	// 82ECAC08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ECAC0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECAC10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECAC14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECAC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECAC18 size=444
    let mut pc: u32 = 0x82ECAC18;
    'dispatch: loop {
        match pc {
            0x82ECAC18 => {
    //   block [0x82ECAC18..0x82ECAC48)
	// 82ECAC18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECAC1C: 4BDDE7E5  bl 0x82ca9400
	ctx.lr = 0x82ECAC20;
	sub_82CA93D0(ctx, base);
	// 82ECAC20: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82ECAC24: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECAC28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECAC2C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82ECAC30: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ECAC34: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECAC38: 40820184  bne 0x82ecadbc
	if !ctx.cr[0].eq {
	pc = 0x82ECADBC; continue 'dispatch;
	}
	// 82ECAC3C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ECAC40: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAC44: 48000028  b 0x82ecac6c
	pc = 0x82ECAC6C; continue 'dispatch;
            }
            0x82ECAC48 => {
    //   block [0x82ECAC48..0x82ECAC6C)
	// 82ECAC48: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECAC4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECAC50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECAC54: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECAC58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECAC5C: 4E800421  bctrl
	ctx.lr = 0x82ECAC60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECAC60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECAC64: 40820158  bne 0x82ecadbc
	if !ctx.cr[0].eq {
	pc = 0x82ECADBC; continue 'dispatch;
	}
	// 82ECAC68: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
            }
            0x82ECAC6C => {
    //   block [0x82ECAC6C..0x82ECACA0)
	// 82ECAC6C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECAC70: 4082FFD8  bne 0x82ecac48
	if !ctx.cr[0].eq {
	pc = 0x82ECAC48; continue 'dispatch;
	}
	// 82ECAC74: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECAC78: 808300A8  lwz r4, 0xa8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) } as u64;
	// 82ECAC7C: 4BFBC6D5  bl 0x82e87350
	ctx.lr = 0x82ECAC80;
	sub_82E87350(ctx, base);
	// 82ECAC80: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ECAC84: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82ECAC88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECAC8C: 409A0014  bne cr6, 0x82ecaca0
	if !ctx.cr[6].eq {
	pc = 0x82ECACA0; continue 'dispatch;
	}
	// 82ECAC90: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAC94: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAC98: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAC9C: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	pc = 0x82ECACA0; continue 'dispatch;
            }
            0x82ECACA0 => {
    //   block [0x82ECACA0..0x82ECACB4)
	// 82ECACA0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECACA4: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ECACA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ECACAC: 836B00A4  lwz r27, 0xa4(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82ECACB0: 419A0104  beq cr6, 0x82ecadb4
	if ctx.cr[6].eq {
	pc = 0x82ECADB4; continue 'dispatch;
	}
	pc = 0x82ECACB4; continue 'dispatch;
            }
            0x82ECACB4 => {
    //   block [0x82ECACB4..0x82ECACE0)
	// 82ECACB4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECACB8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECACBC: 41820110  beq 0x82ecadcc
	if ctx.cr[0].eq {
	pc = 0x82ECADCC; continue 'dispatch;
	}
	// 82ECACC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82ECACC4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82ECACC8: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECACCC: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ECACD0: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ECACD4: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECACD8: 83AA0004  lwz r29, 4(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECACDC: 4800002C  b 0x82ecad08
	pc = 0x82ECAD08; continue 'dispatch;
            }
            0x82ECACE0 => {
    //   block [0x82ECACE0..0x82ECAD08)
	// 82ECACE0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECACE4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECACE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECACEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECACF0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECACF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECACF8: 4E800421  bctrl
	ctx.lr = 0x82ECACFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECACFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECAD00: 40820014  bne 0x82ecad14
	if !ctx.cr[0].eq {
	pc = 0x82ECAD14; continue 'dispatch;
	}
	// 82ECAD04: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
            }
            0x82ECAD08 => {
    //   block [0x82ECAD08..0x82ECAD14)
	// 82ECAD08: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECAD0C: 4082FFD4  bne 0x82ecace0
	if !ctx.cr[0].eq {
	pc = 0x82ECACE0; continue 'dispatch;
	}
	// 82ECAD10: 48000008  b 0x82ecad18
	pc = 0x82ECAD18; continue 'dispatch;
            }
            0x82ECAD14 => {
    //   block [0x82ECAD14..0x82ECAD18)
	// 82ECAD14: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x82ECAD18; continue 'dispatch;
            }
            0x82ECAD18 => {
    //   block [0x82ECAD18..0x82ECAD6C)
	// 82ECAD18: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECAD1C: 40820080  bne 0x82ecad9c
	if !ctx.cr[0].eq {
	pc = 0x82ECAD9C; continue 'dispatch;
	}
	// 82ECAD20: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAD24: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 82ECAD28: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ECAD2C: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECAD30: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAD34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECAD38: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82ECAD3C: 7FCB4B96  divwu r30, r11, r9
	ctx.r[30].u32 = ctx.r[11].u32 / ctx.r[9].u32;
	// 82ECAD40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECAD44: 4BFBE33D  bl 0x82e89080
	ctx.lr = 0x82ECAD48;
	sub_82E89080(ctx, base);
	// 82ECAD48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ECAD4C: 7F04D840  cmplw cr6, r4, r27
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82ECAD50: 4098001C  bge cr6, 0x82ecad6c
	if !ctx.cr[6].lt {
	pc = 0x82ECAD6C; continue 'dispatch;
	}
	// 82ECAD54: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECAD58: 4BFBC5F9  bl 0x82e87350
	ctx.lr = 0x82ECAD5C;
	sub_82E87350(ctx, base);
	// 82ECAD5C: EDBF0828  fsubs f13, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82ECAD60: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECAD64: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ECAD68: 41980034  blt cr6, 0x82ecad9c
	if ctx.cr[6].lt {
	pc = 0x82ECAD9C; continue 'dispatch;
	}
	pc = 0x82ECAD6C; continue 'dispatch;
            }
            0x82ECAD6C => {
    //   block [0x82ECAD6C..0x82ECAD9C)
	// 82ECAD6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECAD70: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ECAD74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ECAD78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECAD7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECAD80: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ECAD84: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82ECAD88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECAD8C: 4E800421  bctrl
	ctx.lr = 0x82ECAD90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECAD90: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ECAD94: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECAD98: 41820034  beq 0x82ecadcc
	if ctx.cr[0].eq {
	pc = 0x82ECADCC; continue 'dispatch;
	}
            }
            0x82ECAD9C => {
    //   block [0x82ECAD9C..0x82ECADB4)
	// 82ECAD9C: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ECADA0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECADA4: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82ECADA8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECADAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECADB0: 409AFF04  bne cr6, 0x82ecacb4
	if !ctx.cr[6].eq {
	pc = 0x82ECACB4; continue 'dispatch;
	}
	pc = 0x82ECADB4; continue 'dispatch;
            }
            0x82ECADB4 => {
    //   block [0x82ECADB4..0x82ECADBC)
	// 82ECADB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECADB8: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	pc = 0x82ECADBC; continue 'dispatch;
            }
            0x82ECADBC => {
    //   block [0x82ECADBC..0x82ECADC0)
	// 82ECADBC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82ECADC0; continue 'dispatch;
            }
            0x82ECADC0 => {
    //   block [0x82ECADC0..0x82ECADCC)
	// 82ECADC0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ECADC4: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82ECADC8: 4BDDE688  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ECADCC => {
    //   block [0x82ECADCC..0x82ECADD4)
	// 82ECADCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECADD0: 4BFFFFF0  b 0x82ecadc0
	pc = 0x82ECADC0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECADD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECADD8 size=12
    let mut pc: u32 = 0x82ECADD8;
    'dispatch: loop {
        match pc {
            0x82ECADD8 => {
    //   block [0x82ECADD8..0x82ECADE4)
	// 82ECADD8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECADDC: 386BE8FC  addi r3, r11, -0x1704
	ctx.r[3].s64 = ctx.r[11].s64 + -5892;
	// 82ECADE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECADE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECADE8 size=116
    let mut pc: u32 = 0x82ECADE8;
    'dispatch: loop {
        match pc {
            0x82ECADE8 => {
    //   block [0x82ECADE8..0x82ECAE50)
	// 82ECADE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECADEC: 4BDDE61D  bl 0x82ca9408
	ctx.lr = 0x82ECADF0;
	sub_82CA93D0(ctx, base);
	// 82ECADF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECADF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECADF8: 3860008C  li r3, 0x8c
	ctx.r[3].s64 = 140;
	// 82ECADFC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ECAE00: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ECAE04: 4B74BB25  bl 0x82616928
	ctx.lr = 0x82ECAE08;
	sub_82616928(ctx, base);
	// 82ECAE08: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ECAE0C: 41820044  beq 0x82ecae50
	if ctx.cr[0].eq {
	pc = 0x82ECAE50; continue 'dispatch;
	}
	// 82ECAE10: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82ECAE14: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECAE18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECAE1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECAE20: 4BFFF521  bl 0x82eca340
	ctx.lr = 0x82ECAE24;
	sub_82ECA340(ctx, base);
	// 82ECAE24: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECAE28: 3920000F  li r9, 0xf
	ctx.r[9].s64 = 15;
	// 82ECAE2C: 394BB56C  addi r10, r11, -0x4a94
	ctx.r[10].s64 = ctx.r[11].s64 + -19092;
	// 82ECAE30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECAE34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECAE38: 913F0088  stw r9, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 82ECAE3C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ECAE40: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82ECAE44: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82ECAE48: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82ECAE4C: 48000008  b 0x82ecae54
	pc = 0x82ECAE54; continue 'dispatch;
            }
            0x82ECAE50 => {
    //   block [0x82ECAE50..0x82ECAE54)
	// 82ECAE50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ECAE54; continue 'dispatch;
            }
            0x82ECAE54 => {
    //   block [0x82ECAE54..0x82ECAE5C)
	// 82ECAE54: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECAE58: 4BDDE600  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECAE60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECAE60 size=172
    let mut pc: u32 = 0x82ECAE60;
    'dispatch: loop {
        match pc {
            0x82ECAE60 => {
    //   block [0x82ECAE60..0x82ECAED4)
	// 82ECAE60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECAE64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECAE68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECAE6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECAE70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECAE74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECAE78: 4BFBBEC1  bl 0x82e86d38
	ctx.lr = 0x82ECAE7C;
	sub_82E86D38(ctx, base);
	// 82ECAE7C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECAE80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECAE84: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAE88: 388BE6D4  addi r4, r11, -0x192c
	ctx.r[4].s64 = ctx.r[11].s64 + -6444;
	// 82ECAE8C: 4BFBC845  bl 0x82e876d0
	ctx.lr = 0x82ECAE90;
	sub_82E876D0(ctx, base);
	// 82ECAE90: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82ECAE94: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECAE98: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAE9C: 388BE5C0  addi r4, r11, -0x1a40
	ctx.r[4].s64 = ctx.r[11].s64 + -6720;
	// 82ECAEA0: 915F0078  stw r10, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82ECAEA4: 4BFBC82D  bl 0x82e876d0
	ctx.lr = 0x82ECAEA8;
	sub_82E876D0(ctx, base);
	// 82ECAEA8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82ECAEAC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECAEB0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECAEB4: 388BE398  addi r4, r11, -0x1c68
	ctx.r[4].s64 = ctx.r[11].s64 + -7272;
	// 82ECAEB8: 915F007C  stw r10, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 82ECAEBC: 4BFBC815  bl 0x82e876d0
	ctx.lr = 0x82ECAEC0;
	sub_82E876D0(ctx, base);
	// 82ECAEC0: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECAEC4: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 82ECAEC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECAECC: 409A0008  bne cr6, 0x82ecaed4
	if !ctx.cr[6].eq {
	pc = 0x82ECAED4; continue 'dispatch;
	}
	// 82ECAED0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ECAED4; continue 'dispatch;
            }
            0x82ECAED4 => {
    //   block [0x82ECAED4..0x82ECAEE4)
	// 82ECAED4: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ECAED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECAEDC: 409A0008  bne cr6, 0x82ecaee4
	if !ctx.cr[6].eq {
	pc = 0x82ECAEE4; continue 'dispatch;
	}
	// 82ECAEE0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ECAEE4; continue 'dispatch;
            }
            0x82ECAEE4 => {
    //   block [0x82ECAEE4..0x82ECAEF0)
	// 82ECAEE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ECAEE8: 409A0008  bne cr6, 0x82ecaef0
	if !ctx.cr[6].eq {
	pc = 0x82ECAEF0; continue 'dispatch;
	}
	// 82ECAEEC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ECAEF0; continue 'dispatch;
            }
            0x82ECAEF0 => {
    //   block [0x82ECAEF0..0x82ECAF0C)
	// 82ECAEF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECAEF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECAEF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECAEFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECAF00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECAF04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECAF08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECAF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECAF10 size=404
    let mut pc: u32 = 0x82ECAF10;
    'dispatch: loop {
        match pc {
            0x82ECAF10 => {
    //   block [0x82ECAF10..0x82ECAF54)
	// 82ECAF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECAF14: 4BDDE4E5  bl 0x82ca93f8
	ctx.lr = 0x82ECAF18;
	sub_82CA93D0(ctx, base);
	// 82ECAF18: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82ECAF1C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECAF20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECAF24: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82ECAF28: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 82ECAF2C: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82ECAF30: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82ECAF34: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82ECAF38: 897D0018  lbz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECAF3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECAF40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECAF44: C3EB0BEC  lfs f31, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ECAF48: 4182000C  beq 0x82ecaf54
	if ctx.cr[0].eq {
	pc = 0x82ECAF54; continue 'dispatch;
	}
	// 82ECAF4C: D3FF0088  stfs f31, 0x88(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82ECAF50: 937F0084  stw r27, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	pc = 0x82ECAF54; continue 'dispatch;
            }
            0x82ECAF54 => {
    //   block [0x82ECAF54..0x82ECAF64)
	// 82ECAF54: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECAF58: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82ECAF5C: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82ECAF60: 419A00FC  beq cr6, 0x82ecb05c
	if ctx.cr[6].eq {
	pc = 0x82ECB05C; continue 'dispatch;
	}
	pc = 0x82ECAF64; continue 'dispatch;
            }
            0x82ECAF64 => {
    //   block [0x82ECAF64..0x82ECB040)
	// 82ECAF64: 557A043E  clrlwi r26, r11, 0x10
	ctx.r[26].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82ECAF68: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82ECAF6C: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECAF70: 409800EC  bge cr6, 0x82ecb05c
	if !ctx.cr[6].lt {
	pc = 0x82ECB05C; continue 'dispatch;
	}
	// 82ECAF74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECAF78: 4BFBB4F9  bl 0x82e86470
	ctx.lr = 0x82ECAF7C;
	sub_82E86470(ctx, base);
	// 82ECAF7C: 7F03E040  cmplw cr6, r3, r28
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82ECAF80: 419A00C0  beq cr6, 0x82ecb040
	if ctx.cr[6].eq {
	pc = 0x82ECB040; continue 'dispatch;
	}
	// 82ECAF84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECAF88: 4BFBB4E9  bl 0x82e86470
	ctx.lr = 0x82ECAF8C;
	sub_82E86470(ctx, base);
	// 82ECAF8C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ECAF90: 418200B0  beq 0x82ecb040
	if ctx.cr[0].eq {
	pc = 0x82ECB040; continue 'dispatch;
	}
	// 82ECAF94: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECAF98: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ECAF9C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ECAFA0: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 82ECAFA4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82ECAFA8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECAFAC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ECAFB0: 4B406401  bl 0x822d13b0
	ctx.lr = 0x82ECAFB4;
	sub_822D13B0(ctx, base);
	// 82ECAFB4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECAFB8: 418200BC  beq 0x82ecb074
	if ctx.cr[0].eq {
	pc = 0x82ECB074; continue 'dispatch;
	}
	// 82ECAFBC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ECAFC0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECAFC4: 4182007C  beq 0x82ecb040
	if ctx.cr[0].eq {
	pc = 0x82ECB040; continue 'dispatch;
	}
	// 82ECAFC8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECAFCC: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECAFD0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ECAFD4: D3E10054  stfs f31, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82ECAFD8: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82ECAFDC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECAFE0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ECAFE4: 4BFA6B5D  bl 0x82e71b40
	ctx.lr = 0x82ECAFE8;
	sub_82E71B40(ctx, base);
	// 82ECAFE8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECAFEC: 41820088  beq 0x82ecb074
	if ctx.cr[0].eq {
	pc = 0x82ECB074; continue 'dispatch;
	}
	// 82ECAFF0: C01F0088  lfs f0, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECAFF4: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECAFF8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ECAFFC: 40980044  bge cr6, 0x82ecb040
	if !ctx.cr[6].lt {
	pc = 0x82ECB040; continue 'dispatch;
	}
	// 82ECB000: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECB004: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82ECB008: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ECB00C: 9B610051  stb r27, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[27].u8 ) };
	// 82ECB010: 38C10051  addi r6, r1, 0x51
	ctx.r[6].s64 = ctx.r[1].s64 + 81;
	// 82ECB014: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECB018: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ECB01C: 4B406395  bl 0x822d13b0
	ctx.lr = 0x82ECB020;
	sub_822D13B0(ctx, base);
	// 82ECB020: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECB024: 41820050  beq 0x82ecb074
	if ctx.cr[0].eq {
	pc = 0x82ECB074; continue 'dispatch;
	}
	// 82ECB028: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82ECB02C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECB030: 41820010  beq 0x82ecb040
	if ctx.cr[0].eq {
	pc = 0x82ECB040; continue 'dispatch;
	}
	// 82ECB034: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECB038: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82ECB03C: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	pc = 0x82ECB040; continue 'dispatch;
            }
            0x82ECB040 => {
    //   block [0x82ECB040..0x82ECB05C)
	// 82ECB040: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECB044: 4BFBB4ED  bl 0x82e86530
	ctx.lr = 0x82ECB048;
	sub_82E86530(ctx, base);
	// 82ECB048: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECB04C: 395A0001  addi r10, r26, 1
	ctx.r[10].s64 = ctx.r[26].s64 + 1;
	// 82ECB050: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECB054: 554B043E  clrlwi r11, r10, 0x10
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82ECB058: 409AFF0C  bne cr6, 0x82ecaf64
	if !ctx.cr[6].eq {
	pc = 0x82ECAF64; continue 'dispatch;
	}
	pc = 0x82ECB05C; continue 'dispatch;
            }
            0x82ECB05C => {
    //   block [0x82ECB05C..0x82ECB074)
	// 82ECB05C: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECB060: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECB064: 419A0020  beq cr6, 0x82ecb084
	if ctx.cr[6].eq {
	pc = 0x82ECB084; continue 'dispatch;
	}
	// 82ECB068: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECB06C: 9B790000  stb r27, 0(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[27].u8 ) };
	// 82ECB070: 48000028  b 0x82ecb098
	pc = 0x82ECB098; continue 'dispatch;
            }
            0x82ECB074 => {
    //   block [0x82ECB074..0x82ECB084)
	// 82ECB074: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ECB078: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECB07C: 99790000  stb r11, 0(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82ECB080: 48000018  b 0x82ecb098
	pc = 0x82ECB098; continue 'dispatch;
            }
            0x82ECB084 => {
    //   block [0x82ECB084..0x82ECB098)
	// 82ECB084: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82ECB088: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ECB08C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECB090: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECB094: 99590000  stb r10, 0(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	pc = 0x82ECB098; continue 'dispatch;
            }
            0x82ECB098 => {
    //   block [0x82ECB098..0x82ECB0A4)
	// 82ECB098: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82ECB09C: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82ECB0A0: 4BDDE3A8  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECB0A8 size=88
    let mut pc: u32 = 0x82ECB0A8;
    'dispatch: loop {
        match pc {
            0x82ECB0A8 => {
    //   block [0x82ECB0A8..0x82ECB100)
	// 82ECB0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECB0AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECB0B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECB0B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECB0B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECB0BC: 4BFFF285  bl 0x82eca340
	ctx.lr = 0x82ECB0C0;
	sub_82ECA340(ctx, base);
	// 82ECB0C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECB0C4: 3920000F  li r9, 0xf
	ctx.r[9].s64 = 15;
	// 82ECB0C8: 394BB5C8  addi r10, r11, -0x4a38
	ctx.r[10].s64 = ctx.r[11].s64 + -19000;
	// 82ECB0CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECB0D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECB0D4: 913F008C  stw r9, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[9].u32 ) };
	// 82ECB0D8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ECB0DC: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82ECB0E0: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82ECB0E4: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82ECB0E8: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82ECB0EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ECB0F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECB0F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECB0F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECB0FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECB100 size=12
    let mut pc: u32 = 0x82ECB100;
    'dispatch: loop {
        match pc {
            0x82ECB100 => {
    //   block [0x82ECB100..0x82ECB10C)
	// 82ECB100: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECB104: 386BEA10  addi r3, r11, -0x15f0
	ctx.r[3].s64 = ctx.r[11].s64 + -5616;
	// 82ECB108: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECB110 size=72
    let mut pc: u32 = 0x82ECB110;
    'dispatch: loop {
        match pc {
            0x82ECB110 => {
    //   block [0x82ECB110..0x82ECB14C)
	// 82ECB110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECB114: 4BDDE2F9  bl 0x82ca940c
	ctx.lr = 0x82ECB118;
	sub_82CA93D0(ctx, base);
	// 82ECB118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECB11C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECB120: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 82ECB124: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ECB128: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82ECB12C: 4B74B7FD  bl 0x82616928
	ctx.lr = 0x82ECB130;
	sub_82616928(ctx, base);
	// 82ECB130: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECB134: 41820018  beq 0x82ecb14c
	if ctx.cr[0].eq {
	pc = 0x82ECB14C; continue 'dispatch;
	}
	// 82ECB138: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82ECB13C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECB140: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECB144: 4BFFFF65  bl 0x82ecb0a8
	ctx.lr = 0x82ECB148;
	sub_82ECB0A8(ctx, base);
	// 82ECB148: 48000008  b 0x82ecb150
	pc = 0x82ECB150; continue 'dispatch;
            }
            0x82ECB14C => {
    //   block [0x82ECB14C..0x82ECB150)
	// 82ECB14C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ECB150; continue 'dispatch;
            }
            0x82ECB150 => {
    //   block [0x82ECB150..0x82ECB158)
	// 82ECB150: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECB154: 4BDDE308  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECB158 size=132
    let mut pc: u32 = 0x82ECB158;
    'dispatch: loop {
        match pc {
            0x82ECB158 => {
    //   block [0x82ECB158..0x82ECB1B4)
	// 82ECB158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECB15C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECB160: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECB164: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECB168: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECB16C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECB170: 4BFBBBC9  bl 0x82e86d38
	ctx.lr = 0x82ECB174;
	sub_82E86D38(ctx, base);
	// 82ECB174: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECB178: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECB17C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECB180: 388BE6D4  addi r4, r11, -0x192c
	ctx.r[4].s64 = ctx.r[11].s64 + -6444;
	// 82ECB184: 4BFBC54D  bl 0x82e876d0
	ctx.lr = 0x82ECB188;
	sub_82E876D0(ctx, base);
	// 82ECB188: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82ECB18C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECB190: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECB194: 388BE284  addi r4, r11, -0x1d7c
	ctx.r[4].s64 = ctx.r[11].s64 + -7548;
	// 82ECB198: 915F0078  stw r10, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82ECB19C: 4BFBC535  bl 0x82e876d0
	ctx.lr = 0x82ECB1A0;
	sub_82E876D0(ctx, base);
	// 82ECB1A0: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECB1A4: 907F007C  stw r3, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 82ECB1A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECB1AC: 409A0008  bne cr6, 0x82ecb1b4
	if !ctx.cr[6].eq {
	pc = 0x82ECB1B4; continue 'dispatch;
	}
	// 82ECB1B0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ECB1B4; continue 'dispatch;
            }
            0x82ECB1B4 => {
    //   block [0x82ECB1B4..0x82ECB1C0)
	// 82ECB1B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ECB1B8: 409A0008  bne cr6, 0x82ecb1c0
	if !ctx.cr[6].eq {
	pc = 0x82ECB1C0; continue 'dispatch;
	}
	// 82ECB1BC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ECB1C0; continue 'dispatch;
            }
            0x82ECB1C0 => {
    //   block [0x82ECB1C0..0x82ECB1DC)
	// 82ECB1C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECB1C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECB1C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECB1CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECB1D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECB1D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECB1D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB1E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECB1E0 size=360
    let mut pc: u32 = 0x82ECB1E0;
    'dispatch: loop {
        match pc {
            0x82ECB1E0 => {
    //   block [0x82ECB1E0..0x82ECB224)
	// 82ECB1E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECB1E4: 4BDDE211  bl 0x82ca93f4
	ctx.lr = 0x82ECB1E8;
	sub_82CA93D0(ctx, base);
	// 82ECB1E8: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82ECB1EC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECB1F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECB1F4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82ECB1F8: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82ECB1FC: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82ECB200: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82ECB204: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82ECB208: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECB20C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECB210: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECB214: C3EB0BEC  lfs f31, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ECB218: 419A000C  beq cr6, 0x82ecb224
	if ctx.cr[6].eq {
	pc = 0x82ECB224; continue 'dispatch;
	}
	// 82ECB21C: D3FF0084  stfs f31, 0x84(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82ECB220: 935F0080  stw r26, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[26].u32 ) };
	pc = 0x82ECB224; continue 'dispatch;
            }
            0x82ECB224 => {
    //   block [0x82ECB224..0x82ECB238)
	// 82ECB224: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECB228: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82ECB22C: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82ECB230: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82ECB234: 419A00C8  beq cr6, 0x82ecb2fc
	if ctx.cr[6].eq {
	pc = 0x82ECB2FC; continue 'dispatch;
	}
	pc = 0x82ECB238; continue 'dispatch;
            }
            0x82ECB238 => {
    //   block [0x82ECB238..0x82ECB2E0)
	// 82ECB238: 557B043E  clrlwi r27, r11, 0x10
	ctx.r[27].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82ECB23C: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82ECB240: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECB244: 409800B8  bge cr6, 0x82ecb2fc
	if !ctx.cr[6].lt {
	pc = 0x82ECB2FC; continue 'dispatch;
	}
	// 82ECB248: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECB24C: 4BFBB225  bl 0x82e86470
	ctx.lr = 0x82ECB250;
	sub_82E86470(ctx, base);
	// 82ECB250: 7F03E040  cmplw cr6, r3, r28
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82ECB254: 419A008C  beq cr6, 0x82ecb2e0
	if ctx.cr[6].eq {
	pc = 0x82ECB2E0; continue 'dispatch;
	}
	// 82ECB258: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECB25C: 4BFBB215  bl 0x82e86470
	ctx.lr = 0x82ECB260;
	sub_82E86470(ctx, base);
	// 82ECB260: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82ECB264: 4182007C  beq 0x82ecb2e0
	if ctx.cr[0].eq {
	pc = 0x82ECB2E0; continue 'dispatch;
	}
	// 82ECB268: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECB26C: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECB270: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ECB274: D3E10054  stfs f31, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82ECB278: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82ECB27C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECB280: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ECB284: 4BFA68BD  bl 0x82e71b40
	ctx.lr = 0x82ECB288;
	sub_82E71B40(ctx, base);
	// 82ECB288: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECB28C: 41820090  beq 0x82ecb31c
	if ctx.cr[0].eq {
	pc = 0x82ECB31C; continue 'dispatch;
	}
	// 82ECB290: C01F0084  lfs f0, 0x84(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECB294: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECB298: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ECB29C: 40980044  bge cr6, 0x82ecb2e0
	if !ctx.cr[6].lt {
	pc = 0x82ECB2E0; continue 'dispatch;
	}
	// 82ECB2A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECB2A4: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ECB2A8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ECB2AC: 9B410050  stb r26, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 82ECB2B0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82ECB2B4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECB2B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ECB2BC: 4B4060F5  bl 0x822d13b0
	ctx.lr = 0x82ECB2C0;
	sub_822D13B0(ctx, base);
	// 82ECB2C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECB2C4: 41820068  beq 0x82ecb32c
	if ctx.cr[0].eq {
	pc = 0x82ECB32C; continue 'dispatch;
	}
	// 82ECB2C8: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ECB2CC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECB2D0: 41820010  beq 0x82ecb2e0
	if ctx.cr[0].eq {
	pc = 0x82ECB2E0; continue 'dispatch;
	}
	// 82ECB2D4: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECB2D8: 93BF0080  stw r29, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 82ECB2DC: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	pc = 0x82ECB2E0; continue 'dispatch;
            }
            0x82ECB2E0 => {
    //   block [0x82ECB2E0..0x82ECB2FC)
	// 82ECB2E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECB2E4: 4BFBB24D  bl 0x82e86530
	ctx.lr = 0x82ECB2E8;
	sub_82E86530(ctx, base);
	// 82ECB2E8: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECB2EC: 395B0001  addi r10, r27, 1
	ctx.r[10].s64 = ctx.r[27].s64 + 1;
	// 82ECB2F0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECB2F4: 554B043E  clrlwi r11, r10, 0x10
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82ECB2F8: 409AFF40  bne cr6, 0x82ecb238
	if !ctx.cr[6].eq {
	pc = 0x82ECB238; continue 'dispatch;
	}
	pc = 0x82ECB2FC; continue 'dispatch;
            }
            0x82ECB2FC => {
    //   block [0x82ECB2FC..0x82ECB310)
	// 82ECB2FC: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECB300: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECB304: 419A0034  beq cr6, 0x82ecb338
	if ctx.cr[6].eq {
	pc = 0x82ECB338; continue 'dispatch;
	}
	// 82ECB308: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECB30C: 9B570000  stb r26, 0(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	pc = 0x82ECB310; continue 'dispatch;
            }
            0x82ECB310 => {
    //   block [0x82ECB310..0x82ECB31C)
	// 82ECB310: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82ECB314: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82ECB318: 4BDDE12C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ECB31C => {
    //   block [0x82ECB31C..0x82ECB32C)
	// 82ECB31C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ECB320: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECB324: 99770000  stb r11, 0(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82ECB328: 4BFFFFE8  b 0x82ecb310
	pc = 0x82ECB310; continue 'dispatch;
            }
            0x82ECB32C => {
    //   block [0x82ECB32C..0x82ECB330)
	// 82ECB32C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	pc = 0x82ECB330; continue 'dispatch;
            }
            0x82ECB330 => {
    //   block [0x82ECB330..0x82ECB338)
	// 82ECB330: 9B170000  stb r24, 0(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[24].u8 ) };
	// 82ECB334: 4BFFFFDC  b 0x82ecb310
	pc = 0x82ECB310; continue 'dispatch;
            }
            0x82ECB338 => {
    //   block [0x82ECB338..0x82ECB348)
	// 82ECB338: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82ECB33C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82ECB340: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECB344: 4BFFFFEC  b 0x82ecb330
	pc = 0x82ECB330; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECB348 size=12
    let mut pc: u32 = 0x82ECB348;
    'dispatch: loop {
        match pc {
            0x82ECB348 => {
    //   block [0x82ECB348..0x82ECB354)
	// 82ECB348: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECB34C: 386BEB24  addi r3, r11, -0x14dc
	ctx.r[3].s64 = ctx.r[11].s64 + -5340;
	// 82ECB350: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECB358 size=116
    let mut pc: u32 = 0x82ECB358;
    'dispatch: loop {
        match pc {
            0x82ECB358 => {
    //   block [0x82ECB358..0x82ECB3C0)
	// 82ECB358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECB35C: 4BDDE0AD  bl 0x82ca9408
	ctx.lr = 0x82ECB360;
	sub_82CA93D0(ctx, base);
	// 82ECB360: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECB364: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECB368: 3860008C  li r3, 0x8c
	ctx.r[3].s64 = 140;
	// 82ECB36C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ECB370: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ECB374: 4B74B5B5  bl 0x82616928
	ctx.lr = 0x82ECB378;
	sub_82616928(ctx, base);
	// 82ECB378: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ECB37C: 41820044  beq 0x82ecb3c0
	if ctx.cr[0].eq {
	pc = 0x82ECB3C0; continue 'dispatch;
	}
	// 82ECB380: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82ECB384: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECB388: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECB38C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECB390: 4BFFEFB1  bl 0x82eca340
	ctx.lr = 0x82ECB394;
	sub_82ECA340(ctx, base);
	// 82ECB394: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECB398: 3920000F  li r9, 0xf
	ctx.r[9].s64 = 15;
	// 82ECB39C: 394BB620  addi r10, r11, -0x49e0
	ctx.r[10].s64 = ctx.r[11].s64 + -18912;
	// 82ECB3A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECB3A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECB3A8: 913F0088  stw r9, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 82ECB3AC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ECB3B0: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82ECB3B4: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82ECB3B8: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82ECB3BC: 48000008  b 0x82ecb3c4
	pc = 0x82ECB3C4; continue 'dispatch;
            }
            0x82ECB3C0 => {
    //   block [0x82ECB3C0..0x82ECB3C4)
	// 82ECB3C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ECB3C4; continue 'dispatch;
            }
            0x82ECB3C4 => {
    //   block [0x82ECB3C4..0x82ECB3CC)
	// 82ECB3C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECB3C8: 4BDDE090  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECB3D0 size=172
    let mut pc: u32 = 0x82ECB3D0;
    'dispatch: loop {
        match pc {
            0x82ECB3D0 => {
    //   block [0x82ECB3D0..0x82ECB444)
	// 82ECB3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECB3D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECB3D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECB3DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECB3E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECB3E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECB3E8: 4BFBB951  bl 0x82e86d38
	ctx.lr = 0x82ECB3EC;
	sub_82E86D38(ctx, base);
	// 82ECB3EC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECB3F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECB3F4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECB3F8: 388BE6D4  addi r4, r11, -0x192c
	ctx.r[4].s64 = ctx.r[11].s64 + -6444;
	// 82ECB3FC: 4BFBC2D5  bl 0x82e876d0
	ctx.lr = 0x82ECB400;
	sub_82E876D0(ctx, base);
	// 82ECB400: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82ECB404: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECB408: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECB40C: 388BE5C0  addi r4, r11, -0x1a40
	ctx.r[4].s64 = ctx.r[11].s64 + -6720;
	// 82ECB410: 915F0078  stw r10, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82ECB414: 4BFBC2BD  bl 0x82e876d0
	ctx.lr = 0x82ECB418;
	sub_82E876D0(ctx, base);
	// 82ECB418: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82ECB41C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECB420: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECB424: 388BE284  addi r4, r11, -0x1d7c
	ctx.r[4].s64 = ctx.r[11].s64 + -7548;
	// 82ECB428: 915F007C  stw r10, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 82ECB42C: 4BFBC2A5  bl 0x82e876d0
	ctx.lr = 0x82ECB430;
	sub_82E876D0(ctx, base);
	// 82ECB430: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECB434: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 82ECB438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECB43C: 409A0008  bne cr6, 0x82ecb444
	if !ctx.cr[6].eq {
	pc = 0x82ECB444; continue 'dispatch;
	}
	// 82ECB440: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ECB444; continue 'dispatch;
            }
            0x82ECB444 => {
    //   block [0x82ECB444..0x82ECB454)
	// 82ECB444: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ECB448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECB44C: 409A0008  bne cr6, 0x82ecb454
	if !ctx.cr[6].eq {
	pc = 0x82ECB454; continue 'dispatch;
	}
	// 82ECB450: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ECB454; continue 'dispatch;
            }
            0x82ECB454 => {
    //   block [0x82ECB454..0x82ECB460)
	// 82ECB454: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ECB458: 409A0008  bne cr6, 0x82ecb460
	if !ctx.cr[6].eq {
	pc = 0x82ECB460; continue 'dispatch;
	}
	// 82ECB45C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ECB460; continue 'dispatch;
            }
            0x82ECB460 => {
    //   block [0x82ECB460..0x82ECB47C)
	// 82ECB460: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECB464: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECB468: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECB46C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECB470: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECB474: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECB478: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECB480 size=172
    let mut pc: u32 = 0x82ECB480;
    'dispatch: loop {
        match pc {
            0x82ECB480 => {
    //   block [0x82ECB480..0x82ECB4C8)
	// 82ECB480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECB484: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECB488: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECB48C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECB490: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECB494: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ECB498: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECB49C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ECB4A0: 419A0030  beq cr6, 0x82ecb4d0
	if ctx.cr[6].eq {
	pc = 0x82ECB4D0; continue 'dispatch;
	}
	// 82ECB4A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECB4A8: 482F0BB9  bl 0x831bc060
	ctx.lr = 0x82ECB4AC;
	sub_831BC060(ctx, base);
	// 82ECB4AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECB4B0: 41820020  beq 0x82ecb4d0
	if ctx.cr[0].eq {
	pc = 0x82ECB4D0; continue 'dispatch;
	}
	// 82ECB4B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECB4B8: 482F0BA9  bl 0x831bc060
	ctx.lr = 0x82ECB4BC;
	sub_831BC060(ctx, base);
	// 82ECB4BC: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECB4C0: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82ECB4C4: 409A000C  bne cr6, 0x82ecb4d0
	if !ctx.cr[6].eq {
	pc = 0x82ECB4D0; continue 'dispatch;
	}
	pc = 0x82ECB4C8; continue 'dispatch;
            }
            0x82ECB4C8 => {
    //   block [0x82ECB4C8..0x82ECB4D0)
	// 82ECB4C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECB4CC: 48000048  b 0x82ecb514
	pc = 0x82ECB514; continue 'dispatch;
            }
            0x82ECB4D0 => {
    //   block [0x82ECB4D0..0x82ECB508)
	// 82ECB4D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECB4D4: 482F0B8D  bl 0x831bc060
	ctx.lr = 0x82ECB4D8;
	sub_831BC060(ctx, base);
	// 82ECB4D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECB4DC: 388BB55C  addi r4, r11, -0x4aa4
	ctx.r[4].s64 = ctx.r[11].s64 + -19108;
	// 82ECB4E0: 4BDE1671  bl 0x82cacb50
	ctx.lr = 0x82ECB4E4;
	sub_82CACB50(ctx, base);
	// 82ECB4E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECB4E8: 40820020  bne 0x82ecb508
	if !ctx.cr[0].eq {
	pc = 0x82ECB508; continue 'dispatch;
	}
	// 82ECB4EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECB4F0: 4BA42819  bl 0x8290dd08
	ctx.lr = 0x82ECB4F4;
	sub_8290DD08(ctx, base);
	// 82ECB4F4: 4BDDEECD  bl 0x82caa3c0
	ctx.lr = 0x82ECB4F8;
	sub_82CAA3C0(ctx, base);
	// 82ECB4F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECB4FC: 4081FFCC  ble 0x82ecb4c8
	if !ctx.cr[0].gt {
	pc = 0x82ECB4C8; continue 'dispatch;
	}
	// 82ECB500: 907E008C  stw r3, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 82ECB504: 4BFFFFC4  b 0x82ecb4c8
	pc = 0x82ECB4C8; continue 'dispatch;
            }
            0x82ECB508 => {
    //   block [0x82ECB508..0x82ECB514)
	// 82ECB508: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECB50C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECB510: 4BFBB4B9  bl 0x82e869c8
	ctx.lr = 0x82ECB514;
	sub_82E869C8(ctx, base);
	pc = 0x82ECB514; continue 'dispatch;
            }
            0x82ECB514 => {
    //   block [0x82ECB514..0x82ECB52C)
	// 82ECB514: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECB518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECB51C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECB520: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECB524: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECB528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECB530 size=404
    let mut pc: u32 = 0x82ECB530;
    'dispatch: loop {
        match pc {
            0x82ECB530 => {
    //   block [0x82ECB530..0x82ECB574)
	// 82ECB530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECB534: 4BDDDEC1  bl 0x82ca93f4
	ctx.lr = 0x82ECB538;
	sub_82CA93D0(ctx, base);
	// 82ECB538: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82ECB53C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECB540: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECB544: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82ECB548: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 82ECB54C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82ECB550: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82ECB554: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82ECB558: 897D0018  lbz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECB55C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECB560: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECB564: C3EB0BEC  lfs f31, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ECB568: 4182000C  beq 0x82ecb574
	if ctx.cr[0].eq {
	pc = 0x82ECB574; continue 'dispatch;
	}
	// 82ECB56C: D3FF0088  stfs f31, 0x88(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82ECB570: 937F0084  stw r27, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	pc = 0x82ECB574; continue 'dispatch;
            }
            0x82ECB574 => {
    //   block [0x82ECB574..0x82ECB580)
	// 82ECB574: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82ECB578: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82ECB57C: 480000F0  b 0x82ecb66c
	pc = 0x82ECB66C; continue 'dispatch;
            }
            0x82ECB580 => {
    //   block [0x82ECB580..0x82ECB65C)
	// 82ECB580: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82ECB584: 57DA043E  clrlwi r26, r30, 0x10
	ctx.r[26].u64 = ctx.r[30].u32 as u64 & 0x0000FFFFu64;
	// 82ECB588: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECB58C: 409800EC  bge cr6, 0x82ecb678
	if !ctx.cr[6].lt {
	pc = 0x82ECB678; continue 'dispatch;
	}
	// 82ECB590: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECB594: 4BFBAEDD  bl 0x82e86470
	ctx.lr = 0x82ECB598;
	sub_82E86470(ctx, base);
	// 82ECB598: 7F03E040  cmplw cr6, r3, r28
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82ECB59C: 419A00C0  beq cr6, 0x82ecb65c
	if ctx.cr[6].eq {
	pc = 0x82ECB65C; continue 'dispatch;
	}
	// 82ECB5A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECB5A4: 4BFBAECD  bl 0x82e86470
	ctx.lr = 0x82ECB5A8;
	sub_82E86470(ctx, base);
	// 82ECB5A8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ECB5AC: 418200B0  beq 0x82ecb65c
	if ctx.cr[0].eq {
	pc = 0x82ECB65C; continue 'dispatch;
	}
	// 82ECB5B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECB5B4: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ECB5B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ECB5BC: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 82ECB5C0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82ECB5C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECB5C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ECB5CC: 4B405DE5  bl 0x822d13b0
	ctx.lr = 0x82ECB5D0;
	sub_822D13B0(ctx, base);
	// 82ECB5D0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECB5D4: 418200C4  beq 0x82ecb698
	if ctx.cr[0].eq {
	pc = 0x82ECB698; continue 'dispatch;
	}
	// 82ECB5D8: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ECB5DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECB5E0: 4182007C  beq 0x82ecb65c
	if ctx.cr[0].eq {
	pc = 0x82ECB65C; continue 'dispatch;
	}
	// 82ECB5E4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECB5E8: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECB5EC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ECB5F0: D3E10054  stfs f31, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82ECB5F4: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82ECB5F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECB5FC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ECB600: 4BFA6541  bl 0x82e71b40
	ctx.lr = 0x82ECB604;
	sub_82E71B40(ctx, base);
	// 82ECB604: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECB608: 41820090  beq 0x82ecb698
	if ctx.cr[0].eq {
	pc = 0x82ECB698; continue 'dispatch;
	}
	// 82ECB60C: C01F0088  lfs f0, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECB610: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECB614: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ECB618: 40980044  bge cr6, 0x82ecb65c
	if !ctx.cr[6].lt {
	pc = 0x82ECB65C; continue 'dispatch;
	}
	// 82ECB61C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECB620: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82ECB624: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ECB628: 9B610051  stb r27, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[27].u8 ) };
	// 82ECB62C: 38C10051  addi r6, r1, 0x51
	ctx.r[6].s64 = ctx.r[1].s64 + 81;
	// 82ECB630: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECB634: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ECB638: 4B405D79  bl 0x822d13b0
	ctx.lr = 0x82ECB63C;
	sub_822D13B0(ctx, base);
	// 82ECB63C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECB640: 41820068  beq 0x82ecb6a8
	if ctx.cr[0].eq {
	pc = 0x82ECB6A8; continue 'dispatch;
	}
	// 82ECB644: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82ECB648: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECB64C: 41820010  beq 0x82ecb65c
	if ctx.cr[0].eq {
	pc = 0x82ECB65C; continue 'dispatch;
	}
	// 82ECB650: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECB654: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82ECB658: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	pc = 0x82ECB65C; continue 'dispatch;
            }
            0x82ECB65C => {
    //   block [0x82ECB65C..0x82ECB66C)
	// 82ECB65C: 397A0001  addi r11, r26, 1
	ctx.r[11].s64 = ctx.r[26].s64 + 1;
	// 82ECB660: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECB664: 557E043E  clrlwi r30, r11, 0x10
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82ECB668: 4BFBAEC9  bl 0x82e86530
	ctx.lr = 0x82ECB66C;
	sub_82E86530(ctx, base);
	pc = 0x82ECB66C; continue 'dispatch;
            }
            0x82ECB66C => {
    //   block [0x82ECB66C..0x82ECB678)
	// 82ECB66C: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECB670: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECB674: 409AFF0C  bne cr6, 0x82ecb580
	if !ctx.cr[6].eq {
	pc = 0x82ECB580; continue 'dispatch;
	}
	pc = 0x82ECB678; continue 'dispatch;
            }
            0x82ECB678 => {
    //   block [0x82ECB678..0x82ECB68C)
	// 82ECB678: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECB67C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECB680: 419A0034  beq cr6, 0x82ecb6b4
	if ctx.cr[6].eq {
	pc = 0x82ECB6B4; continue 'dispatch;
	}
	// 82ECB684: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECB688: 9B770000  stb r27, 0(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[27].u8 ) };
	pc = 0x82ECB68C; continue 'dispatch;
            }
            0x82ECB68C => {
    //   block [0x82ECB68C..0x82ECB698)
	// 82ECB68C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82ECB690: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82ECB694: 4BDDDDB0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ECB698 => {
    //   block [0x82ECB698..0x82ECB6A8)
	// 82ECB698: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ECB69C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECB6A0: 99770000  stb r11, 0(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82ECB6A4: 4BFFFFE8  b 0x82ecb68c
	pc = 0x82ECB68C; continue 'dispatch;
            }
            0x82ECB6A8 => {
    //   block [0x82ECB6A8..0x82ECB6AC)
	// 82ECB6A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	pc = 0x82ECB6AC; continue 'dispatch;
            }
            0x82ECB6AC => {
    //   block [0x82ECB6AC..0x82ECB6B4)
	// 82ECB6AC: 9B170000  stb r24, 0(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[24].u8 ) };
	// 82ECB6B0: 4BFFFFDC  b 0x82ecb68c
	pc = 0x82ECB68C; continue 'dispatch;
            }
            0x82ECB6B4 => {
    //   block [0x82ECB6B4..0x82ECB6C4)
	// 82ECB6B4: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82ECB6B8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82ECB6BC: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECB6C0: 4BFFFFEC  b 0x82ecb6ac
	pc = 0x82ECB6AC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECB6C8 size=156
    let mut pc: u32 = 0x82ECB6C8;
    'dispatch: loop {
        match pc {
            0x82ECB6C8 => {
    //   block [0x82ECB6C8..0x82ECB6F4)
	// 82ECB6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECB6CC: 4BDDDD3D  bl 0x82ca9408
	ctx.lr = 0x82ECB6D0;
	sub_82CA93D0(ctx, base);
	// 82ECB6D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECB6D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECB6D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ECB6DC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82ECB6E0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECB6E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ECB6E8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECB6EC: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECB6F0: 48000058  b 0x82ecb748
	pc = 0x82ECB748; continue 'dispatch;
            }
            0x82ECB6F4 => {
    //   block [0x82ECB6F4..0x82ECB744)
	// 82ECB6F4: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECB6F8: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECB6FC: 41820048  beq 0x82ecb744
	if ctx.cr[0].eq {
	pc = 0x82ECB744; continue 'dispatch;
	}
	// 82ECB700: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82ECB704: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 82ECB708: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ECB70C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECB710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECB714: 4BFFEFC5  bl 0x82eca6d8
	ctx.lr = 0x82ECB718;
	sub_82ECA6D8(ctx, base);
	// 82ECB718: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECB71C: 41820028  beq 0x82ecb744
	if ctx.cr[0].eq {
	pc = 0x82ECB744; continue 'dispatch;
	}
	// 82ECB720: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ECB724: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82ECB728: 409A001C  bne cr6, 0x82ecb744
	if !ctx.cr[6].eq {
	pc = 0x82ECB744; continue 'dispatch;
	}
	// 82ECB72C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECB730: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECB734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECB738: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ECB73C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECB740: 4E800421  bctrl
	ctx.lr = 0x82ECB744;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ECB744 => {
    //   block [0x82ECB744..0x82ECB748)
	// 82ECB744: 83BD000C  lwz r29, 0xc(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82ECB748; continue 'dispatch;
            }
            0x82ECB748 => {
    //   block [0x82ECB748..0x82ECB764)
	// 82ECB748: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECB74C: 4082FFA8  bne 0x82ecb6f4
	if !ctx.cr[0].eq {
	pc = 0x82ECB6F4; continue 'dispatch;
	}
	// 82ECB750: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ECB754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECB758: 4BFFEDA1  bl 0x82eca4f8
	ctx.lr = 0x82ECB75C;
	sub_82ECA4F8(ctx, base);
	// 82ECB75C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECB760: 4BDDDCF8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECB768 size=88
    let mut pc: u32 = 0x82ECB768;
    'dispatch: loop {
        match pc {
            0x82ECB768 => {
    //   block [0x82ECB768..0x82ECB7C0)
	// 82ECB768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECB76C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECB770: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECB774: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECB778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECB77C: 4BFFEBC5  bl 0x82eca340
	ctx.lr = 0x82ECB780;
	sub_82ECA340(ctx, base);
	// 82ECB780: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECB784: 3920000F  li r9, 0xf
	ctx.r[9].s64 = 15;
	// 82ECB788: 394BB67C  addi r10, r11, -0x4984
	ctx.r[10].s64 = ctx.r[11].s64 + -18820;
	// 82ECB78C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECB790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECB794: 913F008C  stw r9, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[9].u32 ) };
	// 82ECB798: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ECB79C: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82ECB7A0: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82ECB7A4: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82ECB7A8: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82ECB7AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ECB7B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECB7B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECB7B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECB7BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECB7C0 size=12
    let mut pc: u32 = 0x82ECB7C0;
    'dispatch: loop {
        match pc {
            0x82ECB7C0 => {
    //   block [0x82ECB7C0..0x82ECB7CC)
	// 82ECB7C0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECB7C4: 386BEC38  addi r3, r11, -0x13c8
	ctx.r[3].s64 = ctx.r[11].s64 + -5064;
	// 82ECB7C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECB7D0 size=72
    let mut pc: u32 = 0x82ECB7D0;
    'dispatch: loop {
        match pc {
            0x82ECB7D0 => {
    //   block [0x82ECB7D0..0x82ECB80C)
	// 82ECB7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECB7D4: 4BDDDC39  bl 0x82ca940c
	ctx.lr = 0x82ECB7D8;
	sub_82CA93D0(ctx, base);
	// 82ECB7D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECB7DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECB7E0: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 82ECB7E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ECB7E8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82ECB7EC: 4B74B13D  bl 0x82616928
	ctx.lr = 0x82ECB7F0;
	sub_82616928(ctx, base);
	// 82ECB7F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECB7F4: 41820018  beq 0x82ecb80c
	if ctx.cr[0].eq {
	pc = 0x82ECB80C; continue 'dispatch;
	}
	// 82ECB7F8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82ECB7FC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECB800: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECB804: 4BFFFF65  bl 0x82ecb768
	ctx.lr = 0x82ECB808;
	sub_82ECB768(ctx, base);
	// 82ECB808: 48000008  b 0x82ecb810
	pc = 0x82ECB810; continue 'dispatch;
            }
            0x82ECB80C => {
    //   block [0x82ECB80C..0x82ECB810)
	// 82ECB80C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ECB810; continue 'dispatch;
            }
            0x82ECB810 => {
    //   block [0x82ECB810..0x82ECB818)
	// 82ECB810: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECB814: 4BDDDC48  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECB818 size=92
    let mut pc: u32 = 0x82ECB818;
    'dispatch: loop {
        match pc {
            0x82ECB818 => {
    //   block [0x82ECB818..0x82ECB858)
	// 82ECB818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECB81C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECB820: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECB824: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECB828: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECB82C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECB830: 4BFBB509  bl 0x82e86d38
	ctx.lr = 0x82ECB834;
	sub_82E86D38(ctx, base);
	// 82ECB834: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECB838: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECB83C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECB840: 388BE6D4  addi r4, r11, -0x192c
	ctx.r[4].s64 = ctx.r[11].s64 + -6444;
	// 82ECB844: 4BFBBE8D  bl 0x82e876d0
	ctx.lr = 0x82ECB848;
	sub_82E876D0(ctx, base);
	// 82ECB848: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECB84C: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 82ECB850: 40820008  bne 0x82ecb858
	if !ctx.cr[0].eq {
	pc = 0x82ECB858; continue 'dispatch;
	}
	// 82ECB854: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ECB858; continue 'dispatch;
            }
            0x82ECB858 => {
    //   block [0x82ECB858..0x82ECB874)
	// 82ECB858: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECB85C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECB860: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECB864: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECB868: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECB86C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECB870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECB878 size=172
    let mut pc: u32 = 0x82ECB878;
    'dispatch: loop {
        match pc {
            0x82ECB878 => {
    //   block [0x82ECB878..0x82ECB8C0)
	// 82ECB878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECB87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECB880: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECB884: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECB888: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECB88C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ECB890: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECB894: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ECB898: 419A0030  beq cr6, 0x82ecb8c8
	if ctx.cr[6].eq {
	pc = 0x82ECB8C8; continue 'dispatch;
	}
	// 82ECB89C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECB8A0: 482F07C1  bl 0x831bc060
	ctx.lr = 0x82ECB8A4;
	sub_831BC060(ctx, base);
	// 82ECB8A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECB8A8: 41820020  beq 0x82ecb8c8
	if ctx.cr[0].eq {
	pc = 0x82ECB8C8; continue 'dispatch;
	}
	// 82ECB8AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECB8B0: 482F07B1  bl 0x831bc060
	ctx.lr = 0x82ECB8B4;
	sub_831BC060(ctx, base);
	// 82ECB8B4: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECB8B8: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82ECB8BC: 409A000C  bne cr6, 0x82ecb8c8
	if !ctx.cr[6].eq {
	pc = 0x82ECB8C8; continue 'dispatch;
	}
	pc = 0x82ECB8C0; continue 'dispatch;
            }
            0x82ECB8C0 => {
    //   block [0x82ECB8C0..0x82ECB8C8)
	// 82ECB8C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECB8C4: 48000048  b 0x82ecb90c
	pc = 0x82ECB90C; continue 'dispatch;
            }
            0x82ECB8C8 => {
    //   block [0x82ECB8C8..0x82ECB900)
	// 82ECB8C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECB8CC: 482F0795  bl 0x831bc060
	ctx.lr = 0x82ECB8D0;
	sub_831BC060(ctx, base);
	// 82ECB8D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECB8D4: 388BB55C  addi r4, r11, -0x4aa4
	ctx.r[4].s64 = ctx.r[11].s64 + -19108;
	// 82ECB8D8: 4BDE1279  bl 0x82cacb50
	ctx.lr = 0x82ECB8DC;
	sub_82CACB50(ctx, base);
	// 82ECB8DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECB8E0: 40820020  bne 0x82ecb900
	if !ctx.cr[0].eq {
	pc = 0x82ECB900; continue 'dispatch;
	}
	// 82ECB8E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECB8E8: 4BA42421  bl 0x8290dd08
	ctx.lr = 0x82ECB8EC;
	sub_8290DD08(ctx, base);
	// 82ECB8EC: 4BDDEAD5  bl 0x82caa3c0
	ctx.lr = 0x82ECB8F0;
	sub_82CAA3C0(ctx, base);
	// 82ECB8F0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECB8F4: 4081FFCC  ble 0x82ecb8c0
	if !ctx.cr[0].gt {
	pc = 0x82ECB8C0; continue 'dispatch;
	}
	// 82ECB8F8: 907E0084  stw r3, 0x84(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82ECB8FC: 4BFFFFC4  b 0x82ecb8c0
	pc = 0x82ECB8C0; continue 'dispatch;
            }
            0x82ECB900 => {
    //   block [0x82ECB900..0x82ECB90C)
	// 82ECB900: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECB904: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECB908: 4BFBB0C1  bl 0x82e869c8
	ctx.lr = 0x82ECB90C;
	sub_82E869C8(ctx, base);
	pc = 0x82ECB90C; continue 'dispatch;
            }
            0x82ECB90C => {
    //   block [0x82ECB90C..0x82ECB924)
	// 82ECB90C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECB910: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECB914: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECB918: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECB91C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECB920: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECB928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECB928 size=296
    let mut pc: u32 = 0x82ECB928;
    'dispatch: loop {
        match pc {
            0x82ECB928 => {
    //   block [0x82ECB928..0x82ECB96C)
	// 82ECB928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECB92C: 4BDDDACD  bl 0x82ca93f8
	ctx.lr = 0x82ECB930;
	sub_82CA93D0(ctx, base);
	// 82ECB930: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82ECB934: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECB938: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECB93C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82ECB940: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82ECB944: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82ECB948: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82ECB94C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82ECB950: 897E0018  lbz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECB954: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECB958: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECB95C: C3EB0BEC  lfs f31, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ECB960: 4182000C  beq 0x82ecb96c
	if ctx.cr[0].eq {
	pc = 0x82ECB96C; continue 'dispatch;
	}
	// 82ECB964: D3FF0080  stfs f31, 0x80(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82ECB968: 931F007C  stw r24, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[24].u32 ) };
	pc = 0x82ECB96C; continue 'dispatch;
            }
            0x82ECB96C => {
    //   block [0x82ECB96C..0x82ECB97C)
	// 82ECB96C: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECB970: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82ECB974: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82ECB978: 419A0090  beq cr6, 0x82ecba08
	if ctx.cr[6].eq {
	pc = 0x82ECBA08; continue 'dispatch;
	}
	pc = 0x82ECB97C; continue 'dispatch;
            }
            0x82ECB97C => {
    //   block [0x82ECB97C..0x82ECB9EC)
	// 82ECB97C: 557C043E  clrlwi r28, r11, 0x10
	ctx.r[28].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82ECB980: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82ECB984: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECB988: 40980080  bge cr6, 0x82ecba08
	if !ctx.cr[6].lt {
	pc = 0x82ECBA08; continue 'dispatch;
	}
	// 82ECB98C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECB990: 4BFBAAE1  bl 0x82e86470
	ctx.lr = 0x82ECB994;
	sub_82E86470(ctx, base);
	// 82ECB994: 7F03D840  cmplw cr6, r3, r27
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82ECB998: 419A0054  beq cr6, 0x82ecb9ec
	if ctx.cr[6].eq {
	pc = 0x82ECB9EC; continue 'dispatch;
	}
	// 82ECB99C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECB9A0: 4BFBAAD1  bl 0x82e86470
	ctx.lr = 0x82ECB9A4;
	sub_82E86470(ctx, base);
	// 82ECB9A4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82ECB9A8: 41820044  beq 0x82ecb9ec
	if ctx.cr[0].eq {
	pc = 0x82ECB9EC; continue 'dispatch;
	}
	// 82ECB9AC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECB9B0: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECB9B4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ECB9B8: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82ECB9BC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82ECB9C0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECB9C4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82ECB9C8: 4BFA6179  bl 0x82e71b40
	ctx.lr = 0x82ECB9CC;
	sub_82E71B40(ctx, base);
	// 82ECB9CC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECB9D0: 41820050  beq 0x82ecba20
	if ctx.cr[0].eq {
	pc = 0x82ECBA20; continue 'dispatch;
	}
	// 82ECB9D4: C1BF0080  lfs f13, 0x80(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECB9D8: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECB9DC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECB9E0: 4098000C  bge cr6, 0x82ecb9ec
	if !ctx.cr[6].lt {
	pc = 0x82ECB9EC; continue 'dispatch;
	}
	// 82ECB9E4: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82ECB9E8: 93BF007C  stw r29, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	pc = 0x82ECB9EC; continue 'dispatch;
            }
            0x82ECB9EC => {
    //   block [0x82ECB9EC..0x82ECBA08)
	// 82ECB9EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECB9F0: 4BFBAB41  bl 0x82e86530
	ctx.lr = 0x82ECB9F4;
	sub_82E86530(ctx, base);
	// 82ECB9F4: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECB9F8: 395C0001  addi r10, r28, 1
	ctx.r[10].s64 = ctx.r[28].s64 + 1;
	// 82ECB9FC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECBA00: 554B043E  clrlwi r11, r10, 0x10
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82ECBA04: 409AFF78  bne cr6, 0x82ecb97c
	if !ctx.cr[6].eq {
	pc = 0x82ECB97C; continue 'dispatch;
	}
	pc = 0x82ECBA08; continue 'dispatch;
            }
            0x82ECBA08 => {
    //   block [0x82ECBA08..0x82ECBA20)
	// 82ECBA08: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECBA0C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECBA10: 419A0020  beq cr6, 0x82ecba30
	if ctx.cr[6].eq {
	pc = 0x82ECBA30; continue 'dispatch;
	}
	// 82ECBA14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECBA18: 9B1A0000  stb r24, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[24].u8 ) };
	// 82ECBA1C: 48000028  b 0x82ecba44
	pc = 0x82ECBA44; continue 'dispatch;
            }
            0x82ECBA20 => {
    //   block [0x82ECBA20..0x82ECBA30)
	// 82ECBA20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ECBA24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECBA28: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82ECBA2C: 48000018  b 0x82ecba44
	pc = 0x82ECBA44; continue 'dispatch;
            }
            0x82ECBA30 => {
    //   block [0x82ECBA30..0x82ECBA44)
	// 82ECBA30: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ECBA34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ECBA38: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECBA3C: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECBA40: 995A0000  stb r10, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	pc = 0x82ECBA44; continue 'dispatch;
            }
            0x82ECBA44 => {
    //   block [0x82ECBA44..0x82ECBA50)
	// 82ECBA44: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82ECBA48: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82ECBA4C: 4BDDD9FC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECBA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECBA50 size=12
    let mut pc: u32 = 0x82ECBA50;
    'dispatch: loop {
        match pc {
            0x82ECBA50 => {
    //   block [0x82ECBA50..0x82ECBA5C)
	// 82ECBA50: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECBA54: 386BED4C  addi r3, r11, -0x12b4
	ctx.r[3].s64 = ctx.r[11].s64 + -4788;
	// 82ECBA58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECBA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECBA60 size=104
    let mut pc: u32 = 0x82ECBA60;
    'dispatch: loop {
        match pc {
            0x82ECBA60 => {
    //   block [0x82ECBA60..0x82ECBAAC)
	// 82ECBA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECBA64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECBA68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECBA6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECBA70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECBA74: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ECBA78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECBA7C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82ECBA80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ECBA84: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82ECBA88: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82ECBA8C: 4BFFD4F5  bl 0x82ec8f80
	ctx.lr = 0x82ECBA90;
	sub_82EC8F80(ctx, base);
	// 82ECBA90: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECBA94: 41820018  beq 0x82ecbaac
	if ctx.cr[0].eq {
	pc = 0x82ECBAAC; continue 'dispatch;
	}
	// 82ECBA98: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ECBA9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECBAA0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECBAA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECBAA8: 4E800421  bctrl
	ctx.lr = 0x82ECBAAC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ECBAAC => {
    //   block [0x82ECBAAC..0x82ECBAC8)
	// 82ECBAAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECBAB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECBAB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECBAB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECBABC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECBAC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECBAC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECBAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECBAC8 size=112
    let mut pc: u32 = 0x82ECBAC8;
    'dispatch: loop {
        match pc {
            0x82ECBAC8 => {
    //   block [0x82ECBAC8..0x82ECBB2C)
	// 82ECBAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECBACC: 4BDDD93D  bl 0x82ca9408
	ctx.lr = 0x82ECBAD0;
	sub_82CA93D0(ctx, base);
	// 82ECBAD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECBAD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECBAD8: 38600088  li r3, 0x88
	ctx.r[3].s64 = 136;
	// 82ECBADC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ECBAE0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ECBAE4: 4B74AE45  bl 0x82616928
	ctx.lr = 0x82ECBAE8;
	sub_82616928(ctx, base);
	// 82ECBAE8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ECBAEC: 41820040  beq 0x82ecbb2c
	if ctx.cr[0].eq {
	pc = 0x82ECBB2C; continue 'dispatch;
	}
	// 82ECBAF0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82ECBAF4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECBAF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECBAFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECBB00: 4BFFE841  bl 0x82eca340
	ctx.lr = 0x82ECBB04;
	sub_82ECA340(ctx, base);
	// 82ECBB04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECBB08: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ECBB0C: 396BB6D8  addi r11, r11, -0x4928
	ctx.r[11].s64 = ctx.r[11].s64 + -18728;
	// 82ECBB10: 3920000F  li r9, 0xf
	ctx.r[9].s64 = 15;
	// 82ECBB14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECBB18: 915F0078  stw r10, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82ECBB1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECBB20: 915F007C  stw r10, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 82ECBB24: 913F0084  stw r9, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 82ECBB28: 48000008  b 0x82ecbb30
	pc = 0x82ECBB30; continue 'dispatch;
            }
            0x82ECBB2C => {
    //   block [0x82ECBB2C..0x82ECBB30)
	// 82ECBB2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ECBB30; continue 'dispatch;
            }
            0x82ECBB30 => {
    //   block [0x82ECBB30..0x82ECBB38)
	// 82ECBB30: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECBB34: 4BDDD924  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECBB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECBB38 size=132
    let mut pc: u32 = 0x82ECBB38;
    'dispatch: loop {
        match pc {
            0x82ECBB38 => {
    //   block [0x82ECBB38..0x82ECBB94)
	// 82ECBB38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECBB3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECBB40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECBB44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECBB48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECBB4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECBB50: 4BFBB1E9  bl 0x82e86d38
	ctx.lr = 0x82ECBB54;
	sub_82E86D38(ctx, base);
	// 82ECBB54: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECBB58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECBB5C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECBB60: 388BE6D4  addi r4, r11, -0x192c
	ctx.r[4].s64 = ctx.r[11].s64 + -6444;
	// 82ECBB64: 4BFBBB6D  bl 0x82e876d0
	ctx.lr = 0x82ECBB68;
	sub_82E876D0(ctx, base);
	// 82ECBB68: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82ECBB6C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECBB70: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECBB74: 388BE5C0  addi r4, r11, -0x1a40
	ctx.r[4].s64 = ctx.r[11].s64 + -6720;
	// 82ECBB78: 915F0078  stw r10, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82ECBB7C: 4BFBBB55  bl 0x82e876d0
	ctx.lr = 0x82ECBB80;
	sub_82E876D0(ctx, base);
	// 82ECBB80: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECBB84: 907F007C  stw r3, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 82ECBB88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECBB8C: 409A0008  bne cr6, 0x82ecbb94
	if !ctx.cr[6].eq {
	pc = 0x82ECBB94; continue 'dispatch;
	}
	// 82ECBB90: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ECBB94; continue 'dispatch;
            }
            0x82ECBB94 => {
    //   block [0x82ECBB94..0x82ECBBA0)
	// 82ECBB94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ECBB98: 409A0008  bne cr6, 0x82ecbba0
	if !ctx.cr[6].eq {
	pc = 0x82ECBBA0; continue 'dispatch;
	}
	// 82ECBB9C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ECBBA0; continue 'dispatch;
            }
            0x82ECBBA0 => {
    //   block [0x82ECBBA0..0x82ECBBBC)
	// 82ECBBA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECBBA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECBBA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECBBAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECBBB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECBBB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECBBB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECBBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECBBC0 size=172
    let mut pc: u32 = 0x82ECBBC0;
    'dispatch: loop {
        match pc {
            0x82ECBBC0 => {
    //   block [0x82ECBBC0..0x82ECBC08)
	// 82ECBBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECBBC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECBBC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECBBCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECBBD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECBBD4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ECBBD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECBBDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ECBBE0: 419A0030  beq cr6, 0x82ecbc10
	if ctx.cr[6].eq {
	pc = 0x82ECBC10; continue 'dispatch;
	}
	// 82ECBBE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECBBE8: 482F0479  bl 0x831bc060
	ctx.lr = 0x82ECBBEC;
	sub_831BC060(ctx, base);
	// 82ECBBEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECBBF0: 41820020  beq 0x82ecbc10
	if ctx.cr[0].eq {
	pc = 0x82ECBC10; continue 'dispatch;
	}
	// 82ECBBF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECBBF8: 482F0469  bl 0x831bc060
	ctx.lr = 0x82ECBBFC;
	sub_831BC060(ctx, base);
	// 82ECBBFC: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECBC00: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82ECBC04: 409A000C  bne cr6, 0x82ecbc10
	if !ctx.cr[6].eq {
	pc = 0x82ECBC10; continue 'dispatch;
	}
	pc = 0x82ECBC08; continue 'dispatch;
            }
            0x82ECBC08 => {
    //   block [0x82ECBC08..0x82ECBC10)
	// 82ECBC08: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECBC0C: 48000048  b 0x82ecbc54
	pc = 0x82ECBC54; continue 'dispatch;
            }
            0x82ECBC10 => {
    //   block [0x82ECBC10..0x82ECBC48)
	// 82ECBC10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECBC14: 482F044D  bl 0x831bc060
	ctx.lr = 0x82ECBC18;
	sub_831BC060(ctx, base);
	// 82ECBC18: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECBC1C: 388BB55C  addi r4, r11, -0x4aa4
	ctx.r[4].s64 = ctx.r[11].s64 + -19108;
	// 82ECBC20: 4BDE0F31  bl 0x82cacb50
	ctx.lr = 0x82ECBC24;
	sub_82CACB50(ctx, base);
	// 82ECBC24: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECBC28: 40820020  bne 0x82ecbc48
	if !ctx.cr[0].eq {
	pc = 0x82ECBC48; continue 'dispatch;
	}
	// 82ECBC2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECBC30: 4BA420D9  bl 0x8290dd08
	ctx.lr = 0x82ECBC34;
	sub_8290DD08(ctx, base);
	// 82ECBC34: 4BDDE78D  bl 0x82caa3c0
	ctx.lr = 0x82ECBC38;
	sub_82CAA3C0(ctx, base);
	// 82ECBC38: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECBC3C: 4081FFCC  ble 0x82ecbc08
	if !ctx.cr[0].gt {
	pc = 0x82ECBC08; continue 'dispatch;
	}
	// 82ECBC40: 907E0088  stw r3, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[3].u32 ) };
	// 82ECBC44: 4BFFFFC4  b 0x82ecbc08
	pc = 0x82ECBC08; continue 'dispatch;
            }
            0x82ECBC48 => {
    //   block [0x82ECBC48..0x82ECBC54)
	// 82ECBC48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECBC4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECBC50: 4BFBAD79  bl 0x82e869c8
	ctx.lr = 0x82ECBC54;
	sub_82E869C8(ctx, base);
	pc = 0x82ECBC54; continue 'dispatch;
            }
            0x82ECBC54 => {
    //   block [0x82ECBC54..0x82ECBC6C)
	// 82ECBC54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECBC58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECBC5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECBC60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECBC64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECBC68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECBC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECBC70 size=332
    let mut pc: u32 = 0x82ECBC70;
    'dispatch: loop {
        match pc {
            0x82ECBC70 => {
    //   block [0x82ECBC70..0x82ECBCB0)
	// 82ECBC70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECBC74: 4BDDD785  bl 0x82ca93f8
	ctx.lr = 0x82ECBC78;
	sub_82CA93D0(ctx, base);
	// 82ECBC78: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECBC7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECBC80: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82ECBC84: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 82ECBC88: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82ECBC8C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82ECBC90: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82ECBC94: 897D0018  lbz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECBC98: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECBC9C: 41820014  beq 0x82ecbcb0
	if ctx.cr[0].eq {
	pc = 0x82ECBCB0; continue 'dispatch;
	}
	// 82ECBCA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECBCA4: 933F0080  stw r25, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[25].u32 ) };
	// 82ECBCA8: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECBCAC: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	pc = 0x82ECBCB0; continue 'dispatch;
            }
            0x82ECBCB0 => {
    //   block [0x82ECBCB0..0x82ECBCC0)
	// 82ECBCB0: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECBCB4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82ECBCB8: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82ECBCBC: 419A00BC  beq cr6, 0x82ecbd78
	if ctx.cr[6].eq {
	pc = 0x82ECBD78; continue 'dispatch;
	}
	pc = 0x82ECBCC0; continue 'dispatch;
            }
            0x82ECBCC0 => {
    //   block [0x82ECBCC0..0x82ECBD5C)
	// 82ECBCC0: 557B043E  clrlwi r27, r11, 0x10
	ctx.r[27].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82ECBCC4: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82ECBCC8: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECBCCC: 409800AC  bge cr6, 0x82ecbd78
	if !ctx.cr[6].lt {
	pc = 0x82ECBD78; continue 'dispatch;
	}
	// 82ECBCD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECBCD4: 4BFBA79D  bl 0x82e86470
	ctx.lr = 0x82ECBCD8;
	sub_82E86470(ctx, base);
	// 82ECBCD8: 7F03E040  cmplw cr6, r3, r28
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82ECBCDC: 419A0080  beq cr6, 0x82ecbd5c
	if ctx.cr[6].eq {
	pc = 0x82ECBD5C; continue 'dispatch;
	}
	// 82ECBCE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECBCE4: 4BFBA78D  bl 0x82e86470
	ctx.lr = 0x82ECBCE8;
	sub_82E86470(ctx, base);
	// 82ECBCE8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ECBCEC: 41820070  beq 0x82ecbd5c
	if ctx.cr[0].eq {
	pc = 0x82ECBD5C; continue 'dispatch;
	}
	// 82ECBCF0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECBCF4: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ECBCF8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ECBCFC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82ECBD00: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECBD04: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ECBD08: 4B4056A9  bl 0x822d13b0
	ctx.lr = 0x82ECBD0C;
	sub_822D13B0(ctx, base);
	// 82ECBD0C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECBD10: 41820080  beq 0x82ecbd90
	if ctx.cr[0].eq {
	pc = 0x82ECBD90; continue 'dispatch;
	}
	// 82ECBD14: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ECBD18: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECBD1C: 41820040  beq 0x82ecbd5c
	if ctx.cr[0].eq {
	pc = 0x82ECBD5C; continue 'dispatch;
	}
	// 82ECBD20: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECBD24: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECBD28: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ECBD2C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82ECBD30: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECBD34: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ECBD38: 4BFA5E09  bl 0x82e71b40
	ctx.lr = 0x82ECBD3C;
	sub_82E71B40(ctx, base);
	// 82ECBD3C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECBD40: 41820050  beq 0x82ecbd90
	if ctx.cr[0].eq {
	pc = 0x82ECBD90; continue 'dispatch;
	}
	// 82ECBD44: C1BF0084  lfs f13, 0x84(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECBD48: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECBD4C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECBD50: 4098000C  bge cr6, 0x82ecbd5c
	if !ctx.cr[6].lt {
	pc = 0x82ECBD5C; continue 'dispatch;
	}
	// 82ECBD54: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82ECBD58: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	pc = 0x82ECBD5C; continue 'dispatch;
            }
            0x82ECBD5C => {
    //   block [0x82ECBD5C..0x82ECBD78)
	// 82ECBD5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECBD60: 4BFBA7D1  bl 0x82e86530
	ctx.lr = 0x82ECBD64;
	sub_82E86530(ctx, base);
	// 82ECBD64: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECBD68: 395B0001  addi r10, r27, 1
	ctx.r[10].s64 = ctx.r[27].s64 + 1;
	// 82ECBD6C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECBD70: 554B043E  clrlwi r11, r10, 0x10
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82ECBD74: 409AFF4C  bne cr6, 0x82ecbcc0
	if !ctx.cr[6].eq {
	pc = 0x82ECBCC0; continue 'dispatch;
	}
	pc = 0x82ECBD78; continue 'dispatch;
            }
            0x82ECBD78 => {
    //   block [0x82ECBD78..0x82ECBD90)
	// 82ECBD78: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECBD7C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECBD80: 419A0020  beq cr6, 0x82ecbda0
	if ctx.cr[6].eq {
	pc = 0x82ECBDA0; continue 'dispatch;
	}
	// 82ECBD84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECBD88: 9B3A0000  stb r25, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 82ECBD8C: 48000028  b 0x82ecbdb4
	pc = 0x82ECBDB4; continue 'dispatch;
            }
            0x82ECBD90 => {
    //   block [0x82ECBD90..0x82ECBDA0)
	// 82ECBD90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ECBD94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECBD98: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82ECBD9C: 48000018  b 0x82ecbdb4
	pc = 0x82ECBDB4; continue 'dispatch;
            }
            0x82ECBDA0 => {
    //   block [0x82ECBDA0..0x82ECBDB4)
	// 82ECBDA0: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82ECBDA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ECBDA8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECBDAC: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECBDB0: 995A0000  stb r10, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	pc = 0x82ECBDB4; continue 'dispatch;
            }
            0x82ECBDB4 => {
    //   block [0x82ECBDB4..0x82ECBDBC)
	// 82ECBDB4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ECBDB8: 4BDDD690  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECBDC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECBDC0 size=12
    let mut pc: u32 = 0x82ECBDC0;
    'dispatch: loop {
        match pc {
            0x82ECBDC0 => {
    //   block [0x82ECBDC0..0x82ECBDCC)
	// 82ECBDC0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECBDC4: 386BEE60  addi r3, r11, -0x11a0
	ctx.r[3].s64 = ctx.r[11].s64 + -4512;
	// 82ECBDC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECBDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECBDD0 size=116
    let mut pc: u32 = 0x82ECBDD0;
    'dispatch: loop {
        match pc {
            0x82ECBDD0 => {
    //   block [0x82ECBDD0..0x82ECBE38)
	// 82ECBDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECBDD4: 4BDDD635  bl 0x82ca9408
	ctx.lr = 0x82ECBDD8;
	sub_82CA93D0(ctx, base);
	// 82ECBDD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECBDDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECBDE0: 3860008C  li r3, 0x8c
	ctx.r[3].s64 = 140;
	// 82ECBDE4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ECBDE8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ECBDEC: 4B74AB3D  bl 0x82616928
	ctx.lr = 0x82ECBDF0;
	sub_82616928(ctx, base);
	// 82ECBDF0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ECBDF4: 41820044  beq 0x82ecbe38
	if ctx.cr[0].eq {
	pc = 0x82ECBE38; continue 'dispatch;
	}
	// 82ECBDF8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82ECBDFC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECBE00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECBE04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECBE08: 4BFFE539  bl 0x82eca340
	ctx.lr = 0x82ECBE0C;
	sub_82ECA340(ctx, base);
	// 82ECBE0C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECBE10: 3920000F  li r9, 0xf
	ctx.r[9].s64 = 15;
	// 82ECBE14: 394BB730  addi r10, r11, -0x48d0
	ctx.r[10].s64 = ctx.r[11].s64 + -18640;
	// 82ECBE18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECBE1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECBE20: 913F0088  stw r9, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 82ECBE24: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ECBE28: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82ECBE2C: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82ECBE30: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82ECBE34: 48000008  b 0x82ecbe3c
	pc = 0x82ECBE3C; continue 'dispatch;
            }
            0x82ECBE38 => {
    //   block [0x82ECBE38..0x82ECBE3C)
	// 82ECBE38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ECBE3C; continue 'dispatch;
            }
            0x82ECBE3C => {
    //   block [0x82ECBE3C..0x82ECBE44)
	// 82ECBE3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECBE40: 4BDDD618  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECBE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECBE48 size=140
    let mut pc: u32 = 0x82ECBE48;
    'dispatch: loop {
        match pc {
            0x82ECBE48 => {
    //   block [0x82ECBE48..0x82ECBEA0)
	// 82ECBE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECBE4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECBE50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECBE54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECBE58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECBE5C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82ECBE60: 394AB788  addi r10, r10, -0x4878
	ctx.r[10].s64 = ctx.r[10].s64 + -18552;
	// 82ECBE64: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECBE68: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECBE6C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ECBE70: 41820034  beq 0x82ecbea4
	if ctx.cr[0].eq {
	pc = 0x82ECBEA4; continue 'dispatch;
	}
	// 82ECBE74: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82ECBE78: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ECBE7C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECBE80: 419A0020  beq cr6, 0x82ecbea0
	if ctx.cr[6].eq {
	pc = 0x82ECBEA0; continue 'dispatch;
	}
	// 82ECBE84: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECBE88: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82ECBE8C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82ECBE90: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECBE94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECBE98: 4E800421  bctrl
	ctx.lr = 0x82ECBE9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECBE9C: 48000008  b 0x82ecbea4
	pc = 0x82ECBEA4; continue 'dispatch;
            }
            0x82ECBEA0 => {
    //   block [0x82ECBEA0..0x82ECBEA4)
	// 82ECBEA0: 4B979911  bl 0x828457b0
	ctx.lr = 0x82ECBEA4;
	sub_828457B0(ctx, base);
	pc = 0x82ECBEA4; continue 'dispatch;
            }
            0x82ECBEA4 => {
    //   block [0x82ECBEA4..0x82ECBED4)
	// 82ECBEA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ECBEA8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ECBEAC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82ECBEB0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82ECBEB4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ECBEB8: 9149EF74  stw r10, -0x108c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-4236 as u32), ctx.r[10].u32 ) };
	// 82ECBEBC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECBEC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ECBEC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECBEC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECBECC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECBED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECBED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECBED8 size=12
    let mut pc: u32 = 0x82ECBED8;
    'dispatch: loop {
        match pc {
            0x82ECBED8 => {
    //   block [0x82ECBED8..0x82ECBEE4)
	// 82ECBED8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECBEDC: 386BEF78  addi r3, r11, -0x1088
	ctx.r[3].s64 = ctx.r[11].s64 + -4232;
	// 82ECBEE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECBEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECBEE8 size=316
    let mut pc: u32 = 0x82ECBEE8;
    'dispatch: loop {
        match pc {
            0x82ECBEE8 => {
    //   block [0x82ECBEE8..0x82ECBF04)
	// 82ECBEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECBEEC: 4BDDD519  bl 0x82ca9404
	ctx.lr = 0x82ECBEF0;
	sub_82CA93D0(ctx, base);
	// 82ECBEF0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECBEF4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82ECBEF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECBEFC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82ECBF00: 409A000C  bne cr6, 0x82ecbf0c
	if !ctx.cr[6].eq {
	pc = 0x82ECBF0C; continue 'dispatch;
	}
	pc = 0x82ECBF04; continue 'dispatch;
            }
            0x82ECBF04 => {
    //   block [0x82ECBF04..0x82ECBF0C)
	// 82ECBF04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECBF08: 480000E0  b 0x82ecbfe8
	pc = 0x82ECBFE8; continue 'dispatch;
            }
            0x82ECBF0C => {
    //   block [0x82ECBF0C..0x82ECBFB0)
	// 82ECBF0C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82ECBF10: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82ECBF14: 394AB84C  addi r10, r10, -0x47b4
	ctx.r[10].s64 = ctx.r[10].s64 + -18356;
	// 82ECBF18: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82ECBF1C: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82ECBF20: 3CC08204  lis r6, -0x7dfc
	ctx.r[6].s64 = -2113667072;
	// 82ECBF24: 3CA08204  lis r5, -0x7dfc
	ctx.r[5].s64 = -2113667072;
	// 82ECBF28: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ECBF2C: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 82ECBF30: 3C808204  lis r4, -0x7dfc
	ctx.r[4].s64 = -2113667072;
	// 82ECBF34: 3C608204  lis r3, -0x7dfc
	ctx.r[3].s64 = -2113667072;
	// 82ECBF38: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82ECBF3C: 3929B834  addi r9, r9, -0x47cc
	ctx.r[9].s64 = ctx.r[9].s64 + -18380;
	// 82ECBF40: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82ECBF44: 395F0014  addi r10, r31, 0x14
	ctx.r[10].s64 = ctx.r[31].s64 + 20;
	// 82ECBF48: 3908B81C  addi r8, r8, -0x47e4
	ctx.r[8].s64 = ctx.r[8].s64 + -18404;
	// 82ECBF4C: 38E7B804  addi r7, r7, -0x47fc
	ctx.r[7].s64 = ctx.r[7].s64 + -18428;
	// 82ECBF50: 38C6B7EC  addi r6, r6, -0x4814
	ctx.r[6].s64 = ctx.r[6].s64 + -18452;
	// 82ECBF54: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ECBF58: 38A5B7D4  addi r5, r5, -0x482c
	ctx.r[5].s64 = ctx.r[5].s64 + -18476;
	// 82ECBF5C: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 82ECBF60: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82ECBF64: 395F0018  addi r10, r31, 0x18
	ctx.r[10].s64 = ctx.r[31].s64 + 24;
	// 82ECBF68: 3884B7BC  addi r4, r4, -0x4844
	ctx.r[4].s64 = ctx.r[4].s64 + -18500;
	// 82ECBF6C: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 82ECBF70: 3863B7A4  addi r3, r3, -0x485c
	ctx.r[3].s64 = ctx.r[3].s64 + -18524;
	// 82ECBF74: 90E10068  stw r7, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u32 ) };
	// 82ECBF78: 90C10070  stw r6, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[6].u32 ) };
	// 82ECBF7C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ECBF80: 90A10078  stw r5, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[5].u32 ) };
	// 82ECBF84: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82ECBF88: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82ECBF8C: 395F001C  addi r10, r31, 0x1c
	ctx.r[10].s64 = ctx.r[31].s64 + 28;
	// 82ECBF90: 90810080  stw r4, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[4].u32 ) };
	// 82ECBF94: 90610088  stw r3, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[3].u32 ) };
	// 82ECBF98: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82ECBF9C: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 82ECBFA0: 395F0020  addi r10, r31, 0x20
	ctx.r[10].s64 = ctx.r[31].s64 + 32;
	// 82ECBFA4: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 82ECBFA8: 395F0024  addi r10, r31, 0x24
	ctx.r[10].s64 = ctx.r[31].s64 + 36;
	// 82ECBFAC: 9141008C  stw r10, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	pc = 0x82ECBFB0; continue 'dispatch;
            }
            0x82ECBFB0 => {
    //   block [0x82ECBFB0..0x82ECBFE8)
	// 82ECBFB0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ECBFB4: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECBFB8: 482F00A9  bl 0x831bc060
	ctx.lr = 0x82ECBFBC;
	sub_831BC060(ctx, base);
	// 82ECBFBC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82ECBFC0: 4BDE0B91  bl 0x82cacb50
	ctx.lr = 0x82ECBFC4;
	sub_82CACB50(ctx, base);
	// 82ECBFC4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECBFC8: 41820028  beq 0x82ecbff0
	if ctx.cr[0].eq {
	pc = 0x82ECBFF0; continue 'dispatch;
	}
	// 82ECBFCC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82ECBFD0: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82ECBFD4: 2B1D0008  cmplwi cr6, r29, 8
	ctx.cr[6].compare_u32(ctx.r[29].u32, 8 as u32, &mut ctx.xer);
	// 82ECBFD8: 4198FFD8  blt cr6, 0x82ecbfb0
	if ctx.cr[6].lt {
	pc = 0x82ECBFB0; continue 'dispatch;
	}
	// 82ECBFDC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ECBFE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECBFE4: 4B74D655  bl 0x82619638
	ctx.lr = 0x82ECBFE8;
	sub_82619638(ctx, base);
	pc = 0x82ECBFE8; continue 'dispatch;
            }
            0x82ECBFE8 => {
    //   block [0x82ECBFE8..0x82ECBFF0)
	// 82ECBFE8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82ECBFEC: 4BDDD468  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ECBFF0 => {
    //   block [0x82ECBFF0..0x82ECC01C)
	// 82ECBFF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ECBFF4: 4BA41D15  bl 0x8290dd08
	ctx.lr = 0x82ECBFF8;
	sub_8290DD08(ctx, base);
	// 82ECBFF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECBFFC: 4182FF08  beq 0x82ecbf04
	if ctx.cr[0].eq {
	pc = 0x82ECBF04; continue 'dispatch;
	}
	// 82ECC000: 4BDDE3C1  bl 0x82caa3c0
	ctx.lr = 0x82ECC004;
	sub_82CAA3C0(ctx, base);
	// 82ECC004: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECC008: 40810014  ble 0x82ecc01c
	if !ctx.cr[0].gt {
	pc = 0x82ECC01C; continue 'dispatch;
	}
	// 82ECC00C: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECC010: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82ECC014: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ECC018: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82ECC01C; continue 'dispatch;
            }
            0x82ECC01C => {
    //   block [0x82ECC01C..0x82ECC024)
	// 82ECC01C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECC020: 4BFFFFC8  b 0x82ecbfe8
	pc = 0x82ECBFE8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECC028 size=20
    let mut pc: u32 = 0x82ECC028;
    'dispatch: loop {
        match pc {
            0x82ECC028 => {
    //   block [0x82ECC028..0x82ECC03C)
	// 82ECC028: 80C30008  lwz r6, 8(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECC02C: 2C060000  cmpwi r6, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECC030: 4181000C  bgt 0x82ecc03c
	if ctx.cr[0].gt {
		sub_82ECC03C(ctx, base);
		return;
	}
	// 82ECC034: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECC038: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC03C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECC03C size=72
    let mut pc: u32 = 0x82ECC03C;
    'dispatch: loop {
        match pc {
            0x82ECC03C => {
    //   block [0x82ECC03C..0x82ECC084)
	// 82ECC03C: 81230020  lwz r9, 0x20(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECC040: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ECC044: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECC048: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82ECC04C: 80E30018  lwz r7, 0x18(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECC050: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECC054: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECC058: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECC05C: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECC060: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECC064: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82ECC068: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82ECC06C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82ECC070: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECC074: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82ECC078: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
	// 82ECC07C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECC080: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECC088 size=152
    let mut pc: u32 = 0x82ECC088;
    'dispatch: loop {
        match pc {
            0x82ECC088 => {
    //   block [0x82ECC088..0x82ECC0BC)
	// 82ECC088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECC08C: 4BDDD379  bl 0x82ca9404
	ctx.lr = 0x82ECC090;
	sub_82CA93D0(ctx, base);
	// 82ECC090: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECC094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECC098: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ECC09C: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	// 82ECC0A0: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82ECC0A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECC0A8: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82ECC0AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECC0B0: 937F0048  stw r27, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[27].u32 ) };
	// 82ECC0B4: 40990034  ble cr6, 0x82ecc0e8
	if !ctx.cr[6].gt {
	pc = 0x82ECC0E8; continue 'dispatch;
	}
	// 82ECC0B8: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82ECC0BC; continue 'dispatch;
            }
            0x82ECC0BC => {
    //   block [0x82ECC0BC..0x82ECC0E8)
	// 82ECC0BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECC0C0: 7C6BEA14  add r3, r11, r29
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82ECC0C4: 48000545  bl 0x82ecc608
	ctx.lr = 0x82ECC0C8;
	sub_82ECC608(ctx, base);
	// 82ECC0C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECC0CC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ECC0D0: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82ECC0D4: 3BBD0024  addi r29, r29, 0x24
	ctx.r[29].s64 = ctx.r[29].s64 + 36;
	// 82ECC0D8: 938B0020  stw r28, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[28].u32 ) };
	// 82ECC0DC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECC0E0: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82ECC0E4: 4198FFD8  blt cr6, 0x82ecc0bc
	if ctx.cr[6].lt {
	pc = 0x82ECC0BC; continue 'dispatch;
	}
	pc = 0x82ECC0E8; continue 'dispatch;
            }
            0x82ECC0E8 => {
    //   block [0x82ECC0E8..0x82ECC120)
	// 82ECC0E8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECC0EC: 1D7C0024  mulli r11, r28, 0x24
	ctx.r[11].s32 = ((ctx.r[28].s32 as i64 * 36 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ECC0F0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECC0F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECC0F8: 936BFFFC  stw r27, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[27].u32 ) };
	// 82ECC0FC: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82ECC100: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82ECC104: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82ECC108: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82ECC10C: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82ECC110: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82ECC114: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 82ECC118: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECC11C: 4BDDD338  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECC120 size=64
    let mut pc: u32 = 0x82ECC120;
    'dispatch: loop {
        match pc {
            0x82ECC120 => {
    //   block [0x82ECC120..0x82ECC160)
	// 82ECC120: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 82ECC124: 419A006C  beq cr6, 0x82ecc190
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ECC190);
		return;
	}
	// 82ECC128: 2F040002  cmpwi cr6, r4, 2
	ctx.cr[6].compare_i32(ctx.r[4].s32, 2, &mut ctx.xer);
	// 82ECC12C: 419A005C  beq cr6, 0x82ecc188
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ECC188);
		return;
	}
	// 82ECC130: 2F040004  cmpwi cr6, r4, 4
	ctx.cr[6].compare_i32(ctx.r[4].s32, 4, &mut ctx.xer);
	// 82ECC134: 419A004C  beq cr6, 0x82ecc180
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ECC180);
		return;
	}
	// 82ECC138: 2F040008  cmpwi cr6, r4, 8
	ctx.cr[6].compare_i32(ctx.r[4].s32, 8, &mut ctx.xer);
	// 82ECC13C: 419A003C  beq cr6, 0x82ecc178
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ECC178);
		return;
	}
	// 82ECC140: 2F040010  cmpwi cr6, r4, 0x10
	ctx.cr[6].compare_i32(ctx.r[4].s32, 16, &mut ctx.xer);
	// 82ECC144: 419A002C  beq cr6, 0x82ecc170
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ECC170);
		return;
	}
	// 82ECC148: 2F040020  cmpwi cr6, r4, 0x20
	ctx.cr[6].compare_i32(ctx.r[4].s32, 32, &mut ctx.xer);
	// 82ECC14C: 419A001C  beq cr6, 0x82ecc168
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ECC168);
		return;
	}
	// 82ECC150: 2F040040  cmpwi cr6, r4, 0x40
	ctx.cr[6].compare_i32(ctx.r[4].s32, 64, &mut ctx.xer);
	// 82ECC154: 419A000C  beq cr6, 0x82ecc160
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ECC160);
		return;
	}
	// 82ECC158: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECC15C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECC198 size=88
    let mut pc: u32 = 0x82ECC198;
    'dispatch: loop {
        match pc {
            0x82ECC198 => {
    //   block [0x82ECC198..0x82ECC1D4)
	// 82ECC198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECC19C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECC1A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECC1A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECC1A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECC1AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECC1B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ECC1B4: 4BFFFC95  bl 0x82ecbe48
	ctx.lr = 0x82ECC1B8;
	sub_82ECBE48(ctx, base);
	// 82ECC1B8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECC1BC: 41820018  beq 0x82ecc1d4
	if ctx.cr[0].eq {
	pc = 0x82ECC1D4; continue 'dispatch;
	}
	// 82ECC1C0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ECC1C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECC1C8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECC1CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECC1D0: 4E800421  bctrl
	ctx.lr = 0x82ECC1D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ECC1D4 => {
    //   block [0x82ECC1D4..0x82ECC1F0)
	// 82ECC1D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECC1D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECC1DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECC1E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECC1E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECC1E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECC1EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECC1F0 size=64
    let mut pc: u32 = 0x82ECC1F0;
    'dispatch: loop {
        match pc {
            0x82ECC1F0 => {
    //   block [0x82ECC1F0..0x82ECC230)
	// 82ECC1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECC1F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECC1F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECC1FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECC200: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECC204: 4B3947B5  bl 0x822609b8
	ctx.lr = 0x82ECC208;
	sub_822609B8(ctx, base);
	// 82ECC208: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ECC20C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECC210: C00B004C  lfs f0, 0x4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECC214: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82ECC218: 4BFFFE71  bl 0x82ecc088
	ctx.lr = 0x82ECC21C;
	sub_82ECC088(ctx, base);
	// 82ECC21C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ECC220: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECC224: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECC228: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECC22C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECC230 size=372
    let mut pc: u32 = 0x82ECC230;
    'dispatch: loop {
        match pc {
            0x82ECC230 => {
    //   block [0x82ECC230..0x82ECC288)
	// 82ECC230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECC234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECC238: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECC23C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECC240: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECC244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECC248: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ECC24C: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 82ECC250: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ECC254: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82ECC258: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ECC25C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82ECC260: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82ECC264: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82ECC268: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82ECC26C: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82ECC270: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82ECC274: 4B394745  bl 0x822609b8
	ctx.lr = 0x82ECC278;
	sub_822609B8(ctx, base);
	// 82ECC278: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECC27C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ECC280: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82ECC284: 409A000C  bne cr6, 0x82ecc290
	if !ctx.cr[6].eq {
	pc = 0x82ECC290; continue 'dispatch;
	}
	pc = 0x82ECC288; continue 'dispatch;
            }
            0x82ECC288 => {
    //   block [0x82ECC288..0x82ECC290)
	// 82ECC288: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECC28C: 48000100  b 0x82ecc38c
	pc = 0x82ECC38C; continue 'dispatch;
            }
            0x82ECC290 => {
    //   block [0x82ECC290..0x82ECC2D8)
	// 82ECC290: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECC294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECC298: 4BFB9111  bl 0x82e853a8
	ctx.lr = 0x82ECC29C;
	sub_82E853A8(ctx, base);
	// 82ECC29C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECC2A0: 4182FFE8  beq 0x82ecc288
	if ctx.cr[0].eq {
	pc = 0x82ECC288; continue 'dispatch;
	}
	// 82ECC2A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECC2A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECC2AC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECC2B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECC2B4: 4E800421  bctrl
	ctx.lr = 0x82ECC2B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECC2B8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECC2BC: 4182FFCC  beq 0x82ecc288
	if ctx.cr[0].eq {
	pc = 0x82ECC288; continue 'dispatch;
	}
	// 82ECC2C0: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECC2C4: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECC2C8: 40820010  bne 0x82ecc2d8
	if !ctx.cr[0].eq {
	pc = 0x82ECC2D8; continue 'dispatch;
	}
	// 82ECC2CC: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82ECC2D0: 4B41DEE9  bl 0x822ea1b8
	ctx.lr = 0x82ECC2D4;
	sub_822EA1B8(ctx, base);
	// 82ECC2D4: 48000034  b 0x82ecc308
	pc = 0x82ECC308; continue 'dispatch;
            }
            0x82ECC2D8 => {
    //   block [0x82ECC2D8..0x82ECC2F4)
	// 82ECC2D8: 3D60071C  lis r11, 0x71c
	ctx.r[11].s64 = 119275520;
	// 82ECC2DC: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ECC2E0: 616B71C7  ori r11, r11, 0x71c7
	ctx.r[11].u64 = ctx.r[11].u64 | 29127;
	// 82ECC2E4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECC2E8: 1D7E0024  mulli r11, r30, 0x24
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 36 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ECC2EC: 40990008  ble cr6, 0x82ecc2f4
	if !ctx.cr[6].gt {
	pc = 0x82ECC2F4; continue 'dispatch;
	}
	// 82ECC2F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82ECC2F4; continue 'dispatch;
            }
            0x82ECC2F4 => {
    //   block [0x82ECC2F4..0x82ECC304)
	// 82ECC2F4: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82ECC2F8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECC2FC: 41990008  bgt cr6, 0x82ecc304
	if ctx.cr[6].gt {
	pc = 0x82ECC304; continue 'dispatch;
	}
	// 82ECC300: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82ECC304; continue 'dispatch;
            }
            0x82ECC304 => {
    //   block [0x82ECC304..0x82ECC308)
	// 82ECC304: 4B74A625  bl 0x82616928
	ctx.lr = 0x82ECC308;
	sub_82616928(ctx, base);
	pc = 0x82ECC308; continue 'dispatch;
            }
            0x82ECC308 => {
    //   block [0x82ECC308..0x82ECC338)
	// 82ECC308: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ECC30C: 419A005C  beq cr6, 0x82ecc368
	if ctx.cr[6].eq {
	pc = 0x82ECC368; continue 'dispatch;
	}
	// 82ECC310: 38C30004  addi r6, r3, 4
	ctx.r[6].s64 = ctx.r[3].s64 + 4;
	// 82ECC314: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82ECC318: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECC31C: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82ECC320: 41800040  blt 0x82ecc360
	if ctx.cr[0].lt {
	pc = 0x82ECC360; continue 'dispatch;
	}
	// 82ECC324: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82ECC328: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82ECC32C: 3969000C  addi r11, r9, 0xc
	ctx.r[11].s64 = ctx.r[9].s64 + 12;
	// 82ECC330: 3908B784  addi r8, r8, -0x487c
	ctx.r[8].s64 = ctx.r[8].s64 + -18556;
	// 82ECC334: C0070C18  lfs f0, 0xc18(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82ECC338; continue 'dispatch;
            }
            0x82ECC338 => {
    //   block [0x82ECC338..0x82ECC360)
	// 82ECC338: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82ECC33C: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82ECC340: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82ECC344: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82ECC348: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ECC34C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECC350: 39290024  addi r9, r9, 0x24
	ctx.r[9].s64 = ctx.r[9].s64 + 36;
	// 82ECC354: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82ECC358: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 82ECC35C: 4080FFDC  bge 0x82ecc338
	if !ctx.cr[0].lt {
	pc = 0x82ECC338; continue 'dispatch;
	}
	pc = 0x82ECC360; continue 'dispatch;
            }
            0x82ECC360 => {
    //   block [0x82ECC360..0x82ECC368)
	// 82ECC360: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82ECC364: 48000008  b 0x82ecc36c
	pc = 0x82ECC36C; continue 'dispatch;
            }
            0x82ECC368 => {
    //   block [0x82ECC368..0x82ECC36C)
	// 82ECC368: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82ECC36C; continue 'dispatch;
            }
            0x82ECC36C => {
    //   block [0x82ECC36C..0x82ECC38C)
	// 82ECC36C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECC370: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82ECC374: 4BFFFD15  bl 0x82ecc088
	ctx.lr = 0x82ECC378;
	sub_82ECC088(ctx, base);
	// 82ECC378: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECC37C: 4182FF0C  beq 0x82ecc288
	if ctx.cr[0].eq {
	pc = 0x82ECC288; continue 'dispatch;
	}
	// 82ECC380: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECC384: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECC388: 93EBEF74  stw r31, -0x108c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4236 as u32), ctx.r[31].u32 ) };
	pc = 0x82ECC38C; continue 'dispatch;
            }
            0x82ECC38C => {
    //   block [0x82ECC38C..0x82ECC3A4)
	// 82ECC38C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECC390: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECC394: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECC398: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECC39C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECC3A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECC3A8 size=200
    let mut pc: u32 = 0x82ECC3A8;
    'dispatch: loop {
        match pc {
            0x82ECC3A8 => {
    //   block [0x82ECC3A8..0x82ECC3E8)
	// 82ECC3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECC3AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECC3B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECC3B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECC3B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECC3BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECC3C0: 548B07BD  rlwinm. r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECC3C4: 41820060  beq 0x82ecc424
	if ctx.cr[0].eq {
	pc = 0x82ECC424; continue 'dispatch;
	}
	// 82ECC3C8: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82ECC3CC: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82ECC3D0: 1D4B0024  mulli r10, r11, 0x24
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 36 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ECC3D4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECC3D8: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82ECC3DC: 41800024  blt 0x82ecc400
	if ctx.cr[0].lt {
	pc = 0x82ECC400; continue 'dispatch;
	}
	// 82ECC3E0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82ECC3E4: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x82ECC3E8; continue 'dispatch;
            }
            0x82ECC3E8 => {
    //   block [0x82ECC3E8..0x82ECC400)
	// 82ECC3E8: 394AFFDC  addi r10, r10, -0x24
	ctx.r[10].s64 = ctx.r[10].s64 + -36;
	// 82ECC3EC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECC3F0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECC3F4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ECC3F8: 910A0010  stw r8, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82ECC3FC: 4080FFEC  bge 0x82ecc3e8
	if !ctx.cr[0].lt {
	pc = 0x82ECC3E8; continue 'dispatch;
	}
	pc = 0x82ECC400; continue 'dispatch;
            }
            0x82ECC400 => {
    //   block [0x82ECC400..0x82ECC41C)
	// 82ECC400: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECC404: 41820018  beq 0x82ecc41c
	if ctx.cr[0].eq {
	pc = 0x82ECC41C; continue 'dispatch;
	}
	// 82ECC408: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ECC40C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECC410: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECC414: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECC418: 4E800421  bctrl
	ctx.lr = 0x82ECC41C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ECC41C => {
    //   block [0x82ECC41C..0x82ECC424)
	// 82ECC41C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECC420: 48000038  b 0x82ecc458
	pc = 0x82ECC458; continue 'dispatch;
            }
            0x82ECC424 => {
    //   block [0x82ECC424..0x82ECC454)
	// 82ECC424: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ECC428: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ECC42C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82ECC430: 548907FF  clrlwi. r9, r4, 0x1f
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ECC434: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82ECC438: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECC43C: 41820018  beq 0x82ecc454
	if ctx.cr[0].eq {
	pc = 0x82ECC454; continue 'dispatch;
	}
	// 82ECC440: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ECC444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECC448: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECC44C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECC450: 4E800421  bctrl
	ctx.lr = 0x82ECC454;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ECC454 => {
    //   block [0x82ECC454..0x82ECC458)
	// 82ECC454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82ECC458; continue 'dispatch;
            }
            0x82ECC458 => {
    //   block [0x82ECC458..0x82ECC470)
	// 82ECC458: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECC45C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECC460: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECC464: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECC468: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECC46C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECC470 size=136
    let mut pc: u32 = 0x82ECC470;
    'dispatch: loop {
        match pc {
            0x82ECC470 => {
    //   block [0x82ECC470..0x82ECC4A4)
	// 82ECC470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECC474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECC478: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECC47C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECC480: 2F05FFFF  cmpwi cr6, r5, -1
	ctx.cr[6].compare_i32(ctx.r[5].s32, -1, &mut ctx.xer);
	// 82ECC484: 1D640024  mulli r11, r4, 0x24
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 36 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ECC488: 419A001C  beq cr6, 0x82ecc4a4
	if ctx.cr[6].eq {
	pc = 0x82ECC4A4; continue 'dispatch;
	}
	// 82ECC48C: 1D250024  mulli r9, r5, 0x24
	ctx.r[9].s32 = ((ctx.r[5].s32 as i64 * 36 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ECC490: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82ECC494: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82ECC498: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECC49C: 91490020  stw r10, 0x20(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82ECC4A0: 48000010  b 0x82ecc4b0
	pc = 0x82ECC4B0; continue 'dispatch;
            }
            0x82ECC4A4 => {
    //   block [0x82ECC4A4..0x82ECC4B0)
	// 82ECC4A4: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82ECC4A8: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECC4AC: 91430048  stw r10, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	pc = 0x82ECC4B0; continue 'dispatch;
            }
            0x82ECC4B0 => {
    //   block [0x82ECC4B0..0x82ECC4E8)
	// 82ECC4B0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECC4B4: 81230044  lwz r9, 0x44(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ECC4B8: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82ECC4BC: 912A0020  stw r9, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 82ECC4C0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECC4C4: 90830044  stw r4, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[4].u32 ) };
	// 82ECC4C8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82ECC4CC: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECC4D0: 4BFFFC51  bl 0x82ecc120
	ctx.lr = 0x82ECC4D4;
	sub_82ECC120(ctx, base);
	// 82ECC4D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECC4D8: 41820010  beq 0x82ecc4e8
	if ctx.cr[0].eq {
	pc = 0x82ECC4E8; continue 'dispatch;
	}
	// 82ECC4DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECC4E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82ECC4E4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82ECC4E8; continue 'dispatch;
            }
            0x82ECC4E8 => {
    //   block [0x82ECC4E8..0x82ECC4F8)
	// 82ECC4E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ECC4EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECC4F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECC4F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECC4F8 size=168
    let mut pc: u32 = 0x82ECC4F8;
    'dispatch: loop {
        match pc {
            0x82ECC4F8 => {
    //   block [0x82ECC4F8..0x82ECC538)
	// 82ECC4F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECC4FC: 4BDDCF11  bl 0x82ca940c
	ctx.lr = 0x82ECC500;
	sub_82CA93D0(ctx, base);
	// 82ECC500: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82ECC504: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECC508: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECC50C: 4B3944AD  bl 0x822609b8
	ctx.lr = 0x82ECC510;
	sub_822609B8(ctx, base);
	// 82ECC510: C01E004C  lfs f0, 0x4c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECC514: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECC518: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECC51C: 419A0078  beq cr6, 0x82ecc594
	if ctx.cr[6].eq {
	pc = 0x82ECC594; continue 'dispatch;
	}
	// 82ECC520: 83FE0048  lwz r31, 0x48(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ECC524: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82ECC528: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 82ECC52C: 419A005C  beq cr6, 0x82ecc588
	if ctx.cr[6].eq {
	pc = 0x82ECC588; continue 'dispatch;
	}
	// 82ECC530: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECC534: C3EB0EE0  lfs f31, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82ECC538; continue 'dispatch;
            }
            0x82ECC538 => {
    //   block [0x82ECC538..0x82ECC578)
	// 82ECC538: 4B394481  bl 0x822609b8
	ctx.lr = 0x82ECC53C;
	sub_822609B8(ctx, base);
	// 82ECC53C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECC540: 1D7F0024  mulli r11, r31, 0x24
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 36 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ECC544: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECC548: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECC54C: C00B001C  lfs f0, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECC550: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECC554: 41990024  bgt cr6, 0x82ecc578
	if ctx.cr[6].gt {
	pc = 0x82ECC578; continue 'dispatch;
	}
	// 82ECC558: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ECC55C: 419A001C  beq cr6, 0x82ecc578
	if ctx.cr[6].eq {
	pc = 0x82ECC578; continue 'dispatch;
	}
	// 82ECC560: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECC564: 83EB0020  lwz r31, 0x20(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECC568: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECC56C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECC570: 4BFFFF01  bl 0x82ecc470
	ctx.lr = 0x82ECC574;
	sub_82ECC470(ctx, base);
	// 82ECC574: 4800000C  b 0x82ecc580
	pc = 0x82ECC580; continue 'dispatch;
            }
            0x82ECC578 => {
    //   block [0x82ECC578..0x82ECC580)
	// 82ECC578: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82ECC57C: 83EB0020  lwz r31, 0x20(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	pc = 0x82ECC580; continue 'dispatch;
            }
            0x82ECC580 => {
    //   block [0x82ECC580..0x82ECC588)
	// 82ECC580: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 82ECC584: 409AFFB4  bne cr6, 0x82ecc538
	if !ctx.cr[6].eq {
	pc = 0x82ECC538; continue 'dispatch;
	}
	pc = 0x82ECC588; continue 'dispatch;
            }
            0x82ECC588 => {
    //   block [0x82ECC588..0x82ECC594)
	// 82ECC588: 4B394431  bl 0x822609b8
	ctx.lr = 0x82ECC58C;
	sub_822609B8(ctx, base);
	// 82ECC58C: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECC590: D01E004C  stfs f0, 0x4c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(76 as u32), tmp.u32 ) };
	pc = 0x82ECC594; continue 'dispatch;
            }
            0x82ECC594 => {
    //   block [0x82ECC594..0x82ECC5A0)
	// 82ECC594: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECC598: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82ECC59C: 4BDDCEC0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECC5A0 size=100
    let mut pc: u32 = 0x82ECC5A0;
    'dispatch: loop {
        match pc {
            0x82ECC5A0 => {
    //   block [0x82ECC5A0..0x82ECC5F0)
	// 82ECC5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECC5A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECC5A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECC5AC: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 82ECC5B0: 4B74A379  bl 0x82616928
	ctx.lr = 0x82ECC5B4;
	sub_82616928(ctx, base);
	// 82ECC5B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECC5B8: 41820038  beq 0x82ecc5f0
	if ctx.cr[0].eq {
	pc = 0x82ECC5F0; continue 'dispatch;
	}
	// 82ECC5BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ECC5C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECC5C4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ECC5C8: 396BB788  addi r11, r11, -0x4878
	ctx.r[11].s64 = ctx.r[11].s64 + -18552;
	// 82ECC5CC: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECC5D0: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82ECC5D4: D003004C  stfs f0, 0x4c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82ECC5D8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82ECC5DC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECC5E0: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82ECC5E4: 91430044  stw r10, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	// 82ECC5E8: 91430048  stw r10, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 82ECC5EC: 48000008  b 0x82ecc5f4
	pc = 0x82ECC5F4; continue 'dispatch;
            }
            0x82ECC5F0 => {
    //   block [0x82ECC5F0..0x82ECC5F4)
	// 82ECC5F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ECC5F4; continue 'dispatch;
            }
            0x82ECC5F4 => {
    //   block [0x82ECC5F4..0x82ECC604)
	// 82ECC5F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ECC5F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECC5FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECC600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82ECC608 size=48
    let mut pc: u32 = 0x82ECC608;
    'dispatch: loop {
        match pc {
            0x82ECC608 => {
    //   block [0x82ECC608..0x82ECC638)
	// 82ECC608: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECC60C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ECC610: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECC614: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82ECC618: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82ECC61C: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82ECC620: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82ECC624: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82ECC628: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82ECC62C: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82ECC630: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82ECC634: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECC638 size=88
    let mut pc: u32 = 0x82ECC638;
    'dispatch: loop {
        match pc {
            0x82ECC638 => {
    //   block [0x82ECC638..0x82ECC668)
	// 82ECC638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECC63C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECC640: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECC644: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECC648: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECC64C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECC650: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ECC654: 4BFB530D  bl 0x82e81960
	ctx.lr = 0x82ECC658;
	sub_82E81960(ctx, base);
	// 82ECC658: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECC65C: 4082000C  bne 0x82ecc668
	if !ctx.cr[0].eq {
	pc = 0x82ECC668; continue 'dispatch;
	}
	// 82ECC660: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECC664: 48000014  b 0x82ecc678
	pc = 0x82ECC678; continue 'dispatch;
            }
            0x82ECC668 => {
    //   block [0x82ECC668..0x82ECC678)
	// 82ECC668: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECC66C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECC670: 4BFB5541  bl 0x82e81bb0
	ctx.lr = 0x82ECC674;
	sub_82E81BB0(ctx, base);
	// 82ECC674: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82ECC678; continue 'dispatch;
            }
            0x82ECC678 => {
    //   block [0x82ECC678..0x82ECC690)
	// 82ECC678: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECC67C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECC680: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECC684: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECC688: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECC68C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECC690 size=108
    let mut pc: u32 = 0x82ECC690;
    'dispatch: loop {
        match pc {
            0x82ECC690 => {
    //   block [0x82ECC690..0x82ECC69C)
	// 82ECC690: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECC694: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ECC698: 4800004C  b 0x82ecc6e4
	pc = 0x82ECC6E4; continue 'dispatch;
            }
            0x82ECC69C => {
    //   block [0x82ECC69C..0x82ECC6DC)
	// 82ECC69C: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82ECC6A0: 4098005C  bge cr6, 0x82ecc6fc
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82ECC6FC);
		return;
	}
	// 82ECC6A4: 7D4B29D6  mullw r10, r11, r5
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ECC6A8: 7C6A3A14  add r3, r10, r7
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82ECC6AC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECC6B0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ECC6B4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82ECC6B8: 7D442A14  add r10, r4, r5
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[5].u64;
	// 82ECC6BC: 554AF87E  srwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ECC6C0: 7D2B51D6  mullw r9, r11, r10
	ctx.r[9].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ECC6C4: 7D29382E  lwzx r9, r9, r7
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82ECC6C8: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ECC6CC: 40990010  ble cr6, 0x82ecc6dc
	if !ctx.cr[6].gt {
	pc = 0x82ECC6DC; continue 'dispatch;
	}
	// 82ECC6D0: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 82ECC6D4: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82ECC6D8: 4800000C  b 0x82ecc6e4
	pc = 0x82ECC6E4; continue 'dispatch;
            }
            0x82ECC6DC => {
    //   block [0x82ECC6DC..0x82ECC6E4)
	// 82ECC6DC: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 82ECC6E0: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	pc = 0x82ECC6E4; continue 'dispatch;
            }
            0x82ECC6E4 => {
    //   block [0x82ECC6E4..0x82ECC6FC)
	// 82ECC6E4: 7D4B21D6  mullw r10, r11, r4
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ECC6E8: 7C6A3A14  add r3, r10, r7
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82ECC6EC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECC6F0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ECC6F4: 409AFFA8  bne cr6, 0x82ecc69c
	if !ctx.cr[6].eq {
	pc = 0x82ECC69C; continue 'dispatch;
	}
	// 82ECC6F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECC708 size=116
    let mut pc: u32 = 0x82ECC708;
    'dispatch: loop {
        match pc {
            0x82ECC708 => {
    //   block [0x82ECC708..0x82ECC70C)
	// 82ECC708: 48000048  b 0x82ecc750
	pc = 0x82ECC750; continue 'dispatch;
            }
            0x82ECC70C => {
    //   block [0x82ECC70C..0x82ECC748)
	// 82ECC70C: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82ECC710: 40980058  bge cr6, 0x82ecc768
	if !ctx.cr[6].lt {
	pc = 0x82ECC768; continue 'dispatch;
	}
	// 82ECC714: 54AB2834  slwi r11, r5, 5
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECC718: 7D6B382E  lwzx r11, r11, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82ECC71C: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ECC720: 419A0050  beq cr6, 0x82ecc770
	if ctx.cr[6].eq {
	pc = 0x82ECC770; continue 'dispatch;
	}
	// 82ECC724: 7D642A14  add r11, r4, r5
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[5].u64;
	// 82ECC728: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECC72C: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ECC730: 7D4A382E  lwzx r10, r10, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82ECC734: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ECC738: 40990010  ble cr6, 0x82ecc748
	if !ctx.cr[6].gt {
	pc = 0x82ECC748; continue 'dispatch;
	}
	// 82ECC73C: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82ECC740: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82ECC744: 4800000C  b 0x82ecc750
	pc = 0x82ECC750; continue 'dispatch;
            }
            0x82ECC748 => {
    //   block [0x82ECC748..0x82ECC750)
	// 82ECC748: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 82ECC74C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	pc = 0x82ECC750; continue 'dispatch;
            }
            0x82ECC750 => {
    //   block [0x82ECC750..0x82ECC768)
	// 82ECC750: 548B2834  slwi r11, r4, 5
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECC754: 7D6B382E  lwzx r11, r11, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82ECC758: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ECC75C: 409AFFB0  bne cr6, 0x82ecc70c
	if !ctx.cr[6].eq {
	pc = 0x82ECC70C; continue 'dispatch;
	}
	// 82ECC760: 548B2834  slwi r11, r4, 5
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECC764: 48000010  b 0x82ecc774
	pc = 0x82ECC774; continue 'dispatch;
            }
            0x82ECC768 => {
    //   block [0x82ECC768..0x82ECC770)
	// 82ECC768: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECC76C: 4E800020  blr
	return;
            }
            0x82ECC770 => {
    //   block [0x82ECC770..0x82ECC774)
	// 82ECC770: 54AB2834  slwi r11, r5, 5
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x82ECC774; continue 'dispatch;
            }
            0x82ECC774 => {
    //   block [0x82ECC774..0x82ECC77C)
	// 82ECC774: 7C6B3A14  add r3, r11, r7
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82ECC778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECC780 size=24
    let mut pc: u32 = 0x82ECC780;
    'dispatch: loop {
        match pc {
            0x82ECC780 => {
    //   block [0x82ECC780..0x82ECC798)
	// 82ECC780: 80E30034  lwz r7, 0x34(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECC784: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82ECC788: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECC78C: 4082000C  bne 0x82ecc798
	if !ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ECC798);
		return;
	}
	// 82ECC790: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECC794: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECC7D0 size=136
    let mut pc: u32 = 0x82ECC7D0;
    'dispatch: loop {
        match pc {
            0x82ECC7D0 => {
    //   block [0x82ECC7D0..0x82ECC844)
	// 82ECC7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECC7D4: 4BDDCC39  bl 0x82ca940c
	ctx.lr = 0x82ECC7D8;
	sub_82CA93D0(ctx, base);
	// 82ECC7D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECC7DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECC7E0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ECC7E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECC7E8: 83DF0020  lwz r30, 0x20(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECC7EC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECC7F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECC7F4: 4E800421  bctrl
	ctx.lr = 0x82ECC7F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECC7F8: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECC7FC: 7D5E1850  subf r10, r30, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[30].s64;
	// 82ECC800: 57A6007E  clrlwi r6, r29, 1
	ctx.r[6].u64 = ctx.r[29].u32 as u64 & 0x7FFFFFFFu64;
	// 82ECC804: 38AAFFFF  addi r5, r10, -1
	ctx.r[5].s64 = ctx.r[10].s64 + -1;
	// 82ECC808: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECC80C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ECC810: 41990034  bgt cr6, 0x82ecc844
	if ctx.cr[6].gt {
	pc = 0x82ECC844; continue 'dispatch;
	}
	// 82ECC814: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECC818: 814A007C  lwz r10, 0x7c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ECC81C: 7D4A29D6  mullw r10, r10, r5
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ECC820: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECC824: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ECC828: 4198001C  blt cr6, 0x82ecc844
	if ctx.cr[6].lt {
	pc = 0x82ECC844; continue 'dispatch;
	}
	// 82ECC82C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ECC830: 80FF002C  lwz r7, 0x2c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECC834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECC838: 4BFFFE59  bl 0x82ecc690
	ctx.lr = 0x82ECC83C;
	sub_82ECC690(ctx, base);
	// 82ECC83C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECC840: 40820010  bne 0x82ecc850
	if !ctx.cr[0].eq {
	pc = 0x82ECC850; continue 'dispatch;
	}
            }
            0x82ECC844 => {
    //   block [0x82ECC844..0x82ECC850)
	// 82ECC844: 67A48000  oris r4, r29, 0x8000
	ctx.r[4].u64 = ctx.r[29].u64 | 2147483648;
	// 82ECC848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECC84C: 4BFFFF35  bl 0x82ecc780
	ctx.lr = 0x82ECC850;
	sub_82ECC780(ctx, base);
	pc = 0x82ECC850; continue 'dispatch;
            }
            0x82ECC850 => {
    //   block [0x82ECC850..0x82ECC858)
	// 82ECC850: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECC854: 4BDDCC08  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECC858 size=184
    let mut pc: u32 = 0x82ECC858;
    'dispatch: loop {
        match pc {
            0x82ECC858 => {
    //   block [0x82ECC858..0x82ECC8C0)
	// 82ECC858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECC85C: 4BDDCBB1  bl 0x82ca940c
	ctx.lr = 0x82ECC860;
	sub_82CA93D0(ctx, base);
	// 82ECC860: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECC864: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECC868: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ECC86C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECC870: 83DF0020  lwz r30, 0x20(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECC874: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECC878: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECC87C: 4E800421  bctrl
	ctx.lr = 0x82ECC880;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECC880: 80FF002C  lwz r7, 0x2c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECC884: 7D7E1850  subf r11, r30, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[30].s64;
	// 82ECC888: 57A6007E  clrlwi r6, r29, 1
	ctx.r[6].u64 = ctx.r[29].u32 as u64 & 0x7FFFFFFFu64;
	// 82ECC88C: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 82ECC890: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECC894: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ECC898: 41990028  bgt cr6, 0x82ecc8c0
	if ctx.cr[6].gt {
	pc = 0x82ECC8C0; continue 'dispatch;
	}
	// 82ECC89C: 54AB2834  slwi r11, r5, 5
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECC8A0: 7D6B382E  lwzx r11, r11, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82ECC8A4: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ECC8A8: 41980018  blt cr6, 0x82ecc8c0
	if ctx.cr[6].lt {
	pc = 0x82ECC8C0; continue 'dispatch;
	}
	// 82ECC8AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ECC8B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECC8B4: 4BFFFE55  bl 0x82ecc708
	ctx.lr = 0x82ECC8B8;
	sub_82ECC708(ctx, base);
	// 82ECC8B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECC8BC: 4082004C  bne 0x82ecc908
	if !ctx.cr[0].eq {
	pc = 0x82ECC908; continue 'dispatch;
	}
            }
            0x82ECC8C0 => {
    //   block [0x82ECC8C0..0x82ECC8D0)
	// 82ECC8C0: 80FF0034  lwz r7, 0x34(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECC8C4: 67A68000  oris r6, r29, 0x8000
	ctx.r[6].u64 = ctx.r[29].u64 | 2147483648;
	// 82ECC8C8: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECC8CC: 4082000C  bne 0x82ecc8d8
	if !ctx.cr[0].eq {
	pc = 0x82ECC8D8; continue 'dispatch;
	}
	pc = 0x82ECC8D0; continue 'dispatch;
            }
            0x82ECC8D0 => {
    //   block [0x82ECC8D0..0x82ECC8D8)
	// 82ECC8D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECC8D4: 48000034  b 0x82ecc908
	pc = 0x82ECC908; continue 'dispatch;
            }
            0x82ECC8D8 => {
    //   block [0x82ECC8D8..0x82ECC908)
	// 82ECC8D8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECC8DC: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECC8E0: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 82ECC8E4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ECC8E8: 4199FFE8  bgt cr6, 0x82ecc8d0
	if ctx.cr[6].gt {
	pc = 0x82ECC8D0; continue 'dispatch;
	}
	// 82ECC8EC: 54AB2834  slwi r11, r5, 5
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECC8F0: 7D6B382E  lwzx r11, r11, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82ECC8F4: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ECC8F8: 4198FFD8  blt cr6, 0x82ecc8d0
	if ctx.cr[6].lt {
	pc = 0x82ECC8D0; continue 'dispatch;
	}
	// 82ECC8FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ECC900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECC904: 4BFFFE05  bl 0x82ecc708
	ctx.lr = 0x82ECC908;
	sub_82ECC708(ctx, base);
	pc = 0x82ECC908; continue 'dispatch;
            }
            0x82ECC908 => {
    //   block [0x82ECC908..0x82ECC910)
	// 82ECC908: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECC90C: 4BDDCB50  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECC910 size=140
    let mut pc: u32 = 0x82ECC910;
    'dispatch: loop {
        match pc {
            0x82ECC910 => {
    //   block [0x82ECC910..0x82ECC934)
	// 82ECC910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECC914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECC918: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECC91C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECC920: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECC924: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ECC928: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECC92C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82ECC930: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82ECC934; continue 'dispatch;
            }
            0x82ECC934 => {
    //   block [0x82ECC934..0x82ECC96C)
	// 82ECC934: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECC938: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECC93C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ECC940: 409AFFF4  bne cr6, 0x82ecc934
	if !ctx.cr[6].eq {
	pc = 0x82ECC934; continue 'dispatch;
	}
	// 82ECC944: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82ECC948: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82ECC94C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECC950: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82ECC954: 4B749FD5  bl 0x82616928
	ctx.lr = 0x82ECC958;
	sub_82616928(ctx, base);
	// 82ECC958: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECC95C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82ECC960: 616984F4  ori r9, r11, 0x84f4
	ctx.r[9].u64 = ctx.r[11].u64 | 34036;
	// 82ECC964: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82ECC968: 7C7E492E  stwx r3, r30, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32), ctx.r[3].u32) };
	pc = 0x82ECC96C; continue 'dispatch;
            }
            0x82ECC96C => {
    //   block [0x82ECC96C..0x82ECC99C)
	// 82ECC96C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECC970: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECC974: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECC978: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 82ECC97C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ECC980: 4082FFEC  bne 0x82ecc96c
	if !ctx.cr[0].eq {
	pc = 0x82ECC96C; continue 'dispatch;
	}
	// 82ECC984: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECC988: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECC98C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECC990: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECC994: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECC998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECC9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECC9A0 size=348
    let mut pc: u32 = 0x82ECC9A0;
    'dispatch: loop {
        match pc {
            0x82ECC9A0 => {
    //   block [0x82ECC9A0..0x82ECC9F4)
	// 82ECC9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECC9A4: 4BDDCA5D  bl 0x82ca9400
	ctx.lr = 0x82ECC9A8;
	sub_82CA93D0(ctx, base);
	// 82ECC9A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECC9AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECC9B0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82ECC9B4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82ECC9B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECC9BC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECC9C0: 40820040  bne 0x82ecca00
	if !ctx.cr[0].eq {
	pc = 0x82ECCA00; continue 'dispatch;
	}
	// 82ECC9C4: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82ECC9C8: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 82ECC9CC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82ECC9D0: 4B749F59  bl 0x82616928
	ctx.lr = 0x82ECC9D4;
	sub_82616928(ctx, base);
	// 82ECC9D4: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82ECC9D8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECC9DC: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82ECC9E0: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82ECC9E4: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82ECC9E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECC9EC: 40990008  ble cr6, 0x82ecc9f4
	if !ctx.cr[6].gt {
	pc = 0x82ECC9F4; continue 'dispatch;
	}
	// 82ECC9F0: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82ECC9F4; continue 'dispatch;
            }
            0x82ECC9F4 => {
    //   block [0x82ECC9F4..0x82ECCA00)
	// 82ECC9F4: 4B749F35  bl 0x82616928
	ctx.lr = 0x82ECC9F8;
	sub_82616928(ctx, base);
	// 82ECC9F8: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82ECC9FC: 480000CC  b 0x82eccac8
	pc = 0x82ECCAC8; continue 'dispatch;
            }
            0x82ECCA00 => {
    //   block [0x82ECCA00..0x82ECCA30)
	// 82ECCA00: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECCA04: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82ECCA08: 409A00C0  bne cr6, 0x82eccac8
	if !ctx.cr[6].eq {
	pc = 0x82ECCAC8; continue 'dispatch;
	}
	// 82ECCA0C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECCA10: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82ECCA14: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82ECCA18: 615EFFFF  ori r30, r10, 0xffff
	ctx.r[30].u64 = ctx.r[10].u64 | 65535;
	// 82ECCA1C: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82ECCA20: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82ECCA24: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82ECCA28: 40990008  ble cr6, 0x82ecca30
	if !ctx.cr[6].gt {
	pc = 0x82ECCA30; continue 'dispatch;
	}
	// 82ECCA2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x82ECCA30; continue 'dispatch;
            }
            0x82ECCA30 => {
    //   block [0x82ECCA30..0x82ECCA4C)
	// 82ECCA30: 4B749EF9  bl 0x82616928
	ctx.lr = 0x82ECCA34;
	sub_82616928(ctx, base);
	// 82ECCA34: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECCA38: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82ECCA3C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82ECCA40: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82ECCA44: 40990008  ble cr6, 0x82ecca4c
	if !ctx.cr[6].gt {
	pc = 0x82ECCA4C; continue 'dispatch;
	}
	// 82ECCA48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x82ECCA4C; continue 'dispatch;
            }
            0x82ECCA4C => {
    //   block [0x82ECCA4C..0x82ECCA6C)
	// 82ECCA4C: 4B749EDD  bl 0x82616928
	ctx.lr = 0x82ECCA50;
	sub_82616928(ctx, base);
	// 82ECCA50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECCA54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECCA58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ECCA5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECCA60: 4099003C  ble cr6, 0x82ecca9c
	if !ctx.cr[6].gt {
	pc = 0x82ECCA9C; continue 'dispatch;
	}
	// 82ECCA64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECCA68: 7D1EE050  subf r8, r30, r28
	ctx.r[8].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	pc = 0x82ECCA6C; continue 'dispatch;
            }
            0x82ECCA6C => {
    //   block [0x82ECCA6C..0x82ECCA9C)
	// 82ECCA6C: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECCA70: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82ECCA74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ECCA78: 7CE7582E  lwzx r7, r7, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECCA7C: 7CE8492E  stwx r7, r8, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 82ECCA80: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECCA84: 7D29582E  lwzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECCA88: 7D2BF12E  stwx r9, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[9].u32) };
	// 82ECCA8C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ECCA90: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECCA94: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82ECCA98: 4198FFD4  blt cr6, 0x82ecca6c
	if ctx.cr[6].lt {
	pc = 0x82ECCA6C; continue 'dispatch;
	}
	pc = 0x82ECCA9C; continue 'dispatch;
            }
            0x82ECCA9C => {
    //   block [0x82ECCA9C..0x82ECCAC8)
	// 82ECCA9C: 3FA08330  lis r29, -0x7cd0
	ctx.r[29].s64 = -2094006272;
	// 82ECCAA0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECCAA4: 817DDAB4  lwz r11, -0x254c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECCAA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECCAAC: 4E800421  bctrl
	ctx.lr = 0x82ECCAB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECCAB0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECCAB4: 817DDAB4  lwz r11, -0x254c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECCAB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECCABC: 4E800421  bctrl
	ctx.lr = 0x82ECCAC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECCAC0: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82ECCAC4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
            }
            0x82ECCAC8 => {
    //   block [0x82ECCAC8..0x82ECCAFC)
	// 82ECCAC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECCACC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECCAD0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECCAD4: 7F6B512E  stwx r27, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[27].u32) };
	// 82ECCAD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECCADC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECCAE0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECCAE4: 7F4B512E  stwx r26, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[26].u32) };
	// 82ECCAE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECCAEC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECCAF0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECCAF4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ECCAF8: 4BDDC958  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECCB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECCB00 size=76
    let mut pc: u32 = 0x82ECCB00;
    'dispatch: loop {
        match pc {
            0x82ECCB00 => {
    //   block [0x82ECCB00..0x82ECCB18)
	// 82ECCB00: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECCB04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECCB08: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECCB0C: 4C810020  blelr
	if !ctx.cr[0].gt { return; }
	// 82ECCB10: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECCB14: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82ECCB18; continue 'dispatch;
            }
            0x82ECCB18 => {
    //   block [0x82ECCB18..0x82ECCB34)
	// 82ECCB18: 7CEA402E  lwzx r7, r10, r8
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82ECCB1C: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82ECCB20: 409A0014  bne cr6, 0x82eccb34
	if !ctx.cr[6].eq {
	pc = 0x82ECCB34; continue 'dispatch;
	}
	// 82ECCB24: 80E3000C  lwz r7, 0xc(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECCB28: 7CE7502E  lwzx r7, r7, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ECCB2C: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82ECCB30: 419A001C  beq cr6, 0x82eccb4c
	if ctx.cr[6].eq {
		sub_82ECCB4C(ctx, base);
		return;
	}
	pc = 0x82ECCB34; continue 'dispatch;
            }
            0x82ECCB34 => {
    //   block [0x82ECCB34..0x82ECCB4C)
	// 82ECCB34: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECCB38: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECCB3C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82ECCB40: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82ECCB44: 4198FFD4  blt cr6, 0x82eccb18
	if ctx.cr[6].lt {
	pc = 0x82ECCB18; continue 'dispatch;
	}
	// 82ECCB48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECCB4C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECCB4C size=76
    let mut pc: u32 = 0x82ECCB4C;
    'dispatch: loop {
        match pc {
            0x82ECCB4C => {
    //   block [0x82ECCB4C..0x82ECCB60)
	// 82ECCB4C: 3949FFFF  addi r10, r9, -1
	ctx.r[10].s64 = ctx.r[9].s64 + -1;
	// 82ECCB50: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82ECCB54: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ECCB58: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82ECCB5C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x82ECCB60; continue 'dispatch;
            }
            0x82ECCB60 => {
    //   block [0x82ECCB60..0x82ECCB98)
	// 82ECCB60: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECCB64: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECCB68: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82ECCB6C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECCB70: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82ECCB74: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECCB78: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82ECCB7C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82ECCB80: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECCB84: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82ECCB88: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECCB8C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82ECCB90: 4198FFD0  blt cr6, 0x82eccb60
	if ctx.cr[6].lt {
	pc = 0x82ECCB60; continue 'dispatch;
	}
	// 82ECCB94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECCB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECCB98 size=348
    let mut pc: u32 = 0x82ECCB98;
    'dispatch: loop {
        match pc {
            0x82ECCB98 => {
    //   block [0x82ECCB98..0x82ECCBEC)
	// 82ECCB98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECCB9C: 4BDDC865  bl 0x82ca9400
	ctx.lr = 0x82ECCBA0;
	sub_82CA93D0(ctx, base);
	// 82ECCBA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECCBA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECCBA8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82ECCBAC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82ECCBB0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECCBB4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECCBB8: 40820040  bne 0x82eccbf8
	if !ctx.cr[0].eq {
	pc = 0x82ECCBF8; continue 'dispatch;
	}
	// 82ECCBBC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82ECCBC0: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 82ECCBC4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82ECCBC8: 4B749D61  bl 0x82616928
	ctx.lr = 0x82ECCBCC;
	sub_82616928(ctx, base);
	// 82ECCBCC: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82ECCBD0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECCBD4: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 82ECCBD8: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82ECCBDC: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82ECCBE0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECCBE4: 40990008  ble cr6, 0x82eccbec
	if !ctx.cr[6].gt {
	pc = 0x82ECCBEC; continue 'dispatch;
	}
	// 82ECCBE8: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82ECCBEC; continue 'dispatch;
            }
            0x82ECCBEC => {
    //   block [0x82ECCBEC..0x82ECCBF8)
	// 82ECCBEC: 4B749D3D  bl 0x82616928
	ctx.lr = 0x82ECCBF0;
	sub_82616928(ctx, base);
	// 82ECCBF0: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 82ECCBF4: 480000CC  b 0x82ecccc0
	pc = 0x82ECCCC0; continue 'dispatch;
            }
            0x82ECCBF8 => {
    //   block [0x82ECCBF8..0x82ECCC28)
	// 82ECCBF8: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECCBFC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82ECCC00: 409A00C0  bne cr6, 0x82ecccc0
	if !ctx.cr[6].eq {
	pc = 0x82ECCCC0; continue 'dispatch;
	}
	// 82ECCC04: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECCC08: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82ECCC0C: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82ECCC10: 615EFFFF  ori r30, r10, 0xffff
	ctx.r[30].u64 = ctx.r[10].u64 | 65535;
	// 82ECCC14: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82ECCC18: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82ECCC1C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82ECCC20: 40990008  ble cr6, 0x82eccc28
	if !ctx.cr[6].gt {
	pc = 0x82ECCC28; continue 'dispatch;
	}
	// 82ECCC24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x82ECCC28; continue 'dispatch;
            }
            0x82ECCC28 => {
    //   block [0x82ECCC28..0x82ECCC44)
	// 82ECCC28: 4B749D01  bl 0x82616928
	ctx.lr = 0x82ECCC2C;
	sub_82616928(ctx, base);
	// 82ECCC2C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECCC30: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82ECCC34: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82ECCC38: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82ECCC3C: 40990008  ble cr6, 0x82eccc44
	if !ctx.cr[6].gt {
	pc = 0x82ECCC44; continue 'dispatch;
	}
	// 82ECCC40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x82ECCC44; continue 'dispatch;
            }
            0x82ECCC44 => {
    //   block [0x82ECCC44..0x82ECCC64)
	// 82ECCC44: 4B749CE5  bl 0x82616928
	ctx.lr = 0x82ECCC48;
	sub_82616928(ctx, base);
	// 82ECCC48: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECCC4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECCC50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ECCC54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECCC58: 4099003C  ble cr6, 0x82eccc94
	if !ctx.cr[6].gt {
	pc = 0x82ECCC94; continue 'dispatch;
	}
	// 82ECCC5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECCC60: 7D1EE050  subf r8, r30, r28
	ctx.r[8].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	pc = 0x82ECCC64; continue 'dispatch;
            }
            0x82ECCC64 => {
    //   block [0x82ECCC64..0x82ECCC94)
	// 82ECCC64: 80FF001C  lwz r7, 0x1c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECCC68: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82ECCC6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ECCC70: 7CE7582E  lwzx r7, r7, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECCC74: 7CE8492E  stwx r7, r8, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 82ECCC78: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECCC7C: 7D29582E  lwzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECCC80: 7D2BF12E  stwx r9, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[9].u32) };
	// 82ECCC84: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ECCC88: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECCC8C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82ECCC90: 4198FFD4  blt cr6, 0x82eccc64
	if ctx.cr[6].lt {
	pc = 0x82ECCC64; continue 'dispatch;
	}
	pc = 0x82ECCC94; continue 'dispatch;
            }
            0x82ECCC94 => {
    //   block [0x82ECCC94..0x82ECCCC0)
	// 82ECCC94: 3FA08330  lis r29, -0x7cd0
	ctx.r[29].s64 = -2094006272;
	// 82ECCC98: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECCC9C: 817DDAB4  lwz r11, -0x254c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECCCA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECCCA4: 4E800421  bctrl
	ctx.lr = 0x82ECCCA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECCCA8: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECCCAC: 817DDAB4  lwz r11, -0x254c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECCCB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECCCB4: 4E800421  bctrl
	ctx.lr = 0x82ECCCB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECCCB8: 939F001C  stw r28, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[28].u32 ) };
	// 82ECCCBC: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
            }
            0x82ECCCC0 => {
    //   block [0x82ECCCC0..0x82ECCCF4)
	// 82ECCCC0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECCCC4: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECCCC8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECCCCC: 7F6A592E  stwx r27, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[27].u32) };
	// 82ECCCD0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECCCD4: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECCCD8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECCCDC: 7F4A592E  stwx r26, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[26].u32) };
	// 82ECCCE0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECCCE4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECCCE8: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82ECCCEC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ECCCF0: 4BDDC760  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECCCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECCCF8 size=76
    let mut pc: u32 = 0x82ECCCF8;
    'dispatch: loop {
        match pc {
            0x82ECCCF8 => {
    //   block [0x82ECCCF8..0x82ECCD10)
	// 82ECCCF8: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECCCFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECCD00: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECCD04: 4C810020  blelr
	if !ctx.cr[0].gt { return; }
	// 82ECCD08: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECCD0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82ECCD10; continue 'dispatch;
            }
            0x82ECCD10 => {
    //   block [0x82ECCD10..0x82ECCD2C)
	// 82ECCD10: 7CEA402E  lwzx r7, r10, r8
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82ECCD14: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82ECCD18: 409A0014  bne cr6, 0x82eccd2c
	if !ctx.cr[6].eq {
	pc = 0x82ECCD2C; continue 'dispatch;
	}
	// 82ECCD1C: 80E30020  lwz r7, 0x20(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECCD20: 7CE7502E  lwzx r7, r7, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ECCD24: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82ECCD28: 419A001C  beq cr6, 0x82eccd44
	if ctx.cr[6].eq {
		sub_82ECCD44(ctx, base);
		return;
	}
	pc = 0x82ECCD2C; continue 'dispatch;
            }
            0x82ECCD2C => {
    //   block [0x82ECCD2C..0x82ECCD44)
	// 82ECCD2C: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECCD30: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECCD34: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82ECCD38: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82ECCD3C: 4198FFD4  blt cr6, 0x82eccd10
	if ctx.cr[6].lt {
	pc = 0x82ECCD10; continue 'dispatch;
	}
	// 82ECCD40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECCD44(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECCD44 size=76
    let mut pc: u32 = 0x82ECCD44;
    'dispatch: loop {
        match pc {
            0x82ECCD44 => {
    //   block [0x82ECCD44..0x82ECCD58)
	// 82ECCD44: 3949FFFF  addi r10, r9, -1
	ctx.r[10].s64 = ctx.r[9].s64 + -1;
	// 82ECCD48: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82ECCD4C: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82ECCD50: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82ECCD54: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x82ECCD58; continue 'dispatch;
            }
            0x82ECCD58 => {
    //   block [0x82ECCD58..0x82ECCD90)
	// 82ECCD58: 8123001C  lwz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECCD5C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECCD60: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82ECCD64: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECCD68: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82ECCD6C: 81230020  lwz r9, 0x20(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECCD70: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82ECCD74: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82ECCD78: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECCD7C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82ECCD80: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECCD84: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82ECCD88: 4198FFD0  blt cr6, 0x82eccd58
	if ctx.cr[6].lt {
	pc = 0x82ECCD58; continue 'dispatch;
	}
	// 82ECCD8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECCD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECCD90 size=128
    let mut pc: u32 = 0x82ECCD90;
    'dispatch: loop {
        match pc {
            0x82ECCD90 => {
    //   block [0x82ECCD90..0x82ECCDC8)
	// 82ECCD90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECCD94: 4BDDC675  bl 0x82ca9408
	ctx.lr = 0x82ECCD98;
	sub_82CA93D0(ctx, base);
	// 82ECCD98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECCD9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ECCDA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ECCDA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECCDA8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECCDAC: 83FE0030  lwz r31, 0x30(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ECCDB0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECCDB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECCDB8: 4E800421  bctrl
	ctx.lr = 0x82ECCDBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECCDBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECCDC0: 41820048  beq 0x82ecce08
	if ctx.cr[0].eq {
	pc = 0x82ECCE08; continue 'dispatch;
	}
	// 82ECCDC4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
            }
            0x82ECCDC8 => {
    //   block [0x82ECCDC8..0x82ECCDF8)
	// 82ECCDC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECCDCC: 556B0001  rlwinm. r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECCDD0: 40820028  bne 0x82eccdf8
	if !ctx.cr[0].eq {
	pc = 0x82ECCDF8; continue 'dispatch;
	}
	// 82ECCDD4: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECCDD8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82ECCDDC: 616B84FC  ori r11, r11, 0x84fc
	ctx.r[11].u64 = ctx.r[11].u64 | 34044;
	// 82ECCDE0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82ECCDE4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECCDE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ECCDEC: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECCDF0: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECCDF4: 4BFCFFD5  bl 0x82e9cdc8
	ctx.lr = 0x82ECCDF8;
	sub_82E9CDC8(ctx, base);
	pc = 0x82ECCDF8; continue 'dispatch;
            }
            0x82ECCDF8 => {
    //   block [0x82ECCDF8..0x82ECCE08)
	// 82ECCDF8: 817D01F8  lwz r11, 0x1f8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(504 as u32) ) } as u64;
	// 82ECCDFC: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82ECCE00: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82ECCE04: 4082FFC4  bne 0x82eccdc8
	if !ctx.cr[0].eq {
	pc = 0x82ECCDC8; continue 'dispatch;
	}
	pc = 0x82ECCE08; continue 'dispatch;
            }
            0x82ECCE08 => {
    //   block [0x82ECCE08..0x82ECCE10)
	// 82ECCE08: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECCE0C: 4BDDC64C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECCE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECCE10 size=128
    let mut pc: u32 = 0x82ECCE10;
    'dispatch: loop {
        match pc {
            0x82ECCE10 => {
    //   block [0x82ECCE10..0x82ECCE48)
	// 82ECCE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECCE14: 4BDDC5F5  bl 0x82ca9408
	ctx.lr = 0x82ECCE18;
	sub_82CA93D0(ctx, base);
	// 82ECCE18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECCE1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ECCE20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECCE24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECCE28: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECCE2C: 83FD0030  lwz r31, 0x30(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ECCE30: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECCE34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECCE38: 4E800421  bctrl
	ctx.lr = 0x82ECCE3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECCE3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECCE40: 41820048  beq 0x82ecce88
	if ctx.cr[0].eq {
	pc = 0x82ECCE88; continue 'dispatch;
	}
	// 82ECCE44: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
            }
            0x82ECCE48 => {
    //   block [0x82ECCE48..0x82ECCE78)
	// 82ECCE48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECCE4C: 556A005F  rlwinm. r10, r11, 0, 1, 0xf
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECCE50: 41820028  beq 0x82ecce78
	if ctx.cr[0].eq {
	pc = 0x82ECCE78; continue 'dispatch;
	}
	// 82ECCE54: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ECCE58: 5565847E  rlwinm r5, r11, 0x10, 0x11, 0x1f
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82ECCE5C: 614A84FC  ori r10, r10, 0x84fc
	ctx.r[10].u64 = ctx.r[10].u64 | 34044;
	// 82ECCE60: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82ECCE64: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82ECCE68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECCE6C: 7D7E502E  lwzx r11, r30, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ECCE70: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECCE74: 4BFD0295  bl 0x82e9d108
	ctx.lr = 0x82ECCE78;
	sub_82E9D108(ctx, base);
	pc = 0x82ECCE78; continue 'dispatch;
            }
            0x82ECCE78 => {
    //   block [0x82ECCE78..0x82ECCE88)
	// 82ECCE78: 817E01F8  lwz r11, 0x1f8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(504 as u32) ) } as u64;
	// 82ECCE7C: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82ECCE80: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82ECCE84: 4082FFC4  bne 0x82ecce48
	if !ctx.cr[0].eq {
	pc = 0x82ECCE48; continue 'dispatch;
	}
	pc = 0x82ECCE88; continue 'dispatch;
            }
            0x82ECCE88 => {
    //   block [0x82ECCE88..0x82ECCE90)
	// 82ECCE88: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECCE8C: 4BDDC5CC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECCE90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECCE90 size=84
    let mut pc: u32 = 0x82ECCE90;
    'dispatch: loop {
        match pc {
            0x82ECCE90 => {
    //   block [0x82ECCE90..0x82ECCEA4)
	// 82ECCE90: 81440020  lwz r10, 0x20(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECCE94: 81640034  lwz r11, 0x34(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECCE98: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECCE9C: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82ECCEA0: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	pc = 0x82ECCEA4; continue 'dispatch;
            }
            0x82ECCEA4 => {
    //   block [0x82ECCEA4..0x82ECCEC4)
	// 82ECCEA4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECCEA8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECCEAC: 41820020  beq 0x82eccecc
	if ctx.cr[0].eq {
	pc = 0x82ECCECC; continue 'dispatch;
	}
	// 82ECCEB0: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECCEB4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECCEB8: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82ECCEBC: 40820008  bne 0x82eccec4
	if !ctx.cr[0].eq {
	pc = 0x82ECCEC4; continue 'dispatch;
	}
	// 82ECCEC0: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	pc = 0x82ECCEC4; continue 'dispatch;
            }
            0x82ECCEC4 => {
    //   block [0x82ECCEC4..0x82ECCECC)
	// 82ECCEC4: 916A0014  stw r11, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82ECCEC8: 48000008  b 0x82ecced0
	pc = 0x82ECCED0; continue 'dispatch;
            }
            0x82ECCECC => {
    //   block [0x82ECCECC..0x82ECCED0)
	// 82ECCECC: 916B0014  stw r11, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	pc = 0x82ECCED0; continue 'dispatch;
            }
            0x82ECCED0 => {
    //   block [0x82ECCED0..0x82ECCEE4)
	// 82ECCED0: 814301F4  lwz r10, 0x1f4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(500 as u32) ) } as u64;
	// 82ECCED4: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82ECCED8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82ECCEDC: 4082FFC8  bne 0x82eccea4
	if !ctx.cr[0].eq {
	pc = 0x82ECCEA4; continue 'dispatch;
	}
	// 82ECCEE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECCEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECCEE8 size=80
    let mut pc: u32 = 0x82ECCEE8;
    'dispatch: loop {
        match pc {
            0x82ECCEE8 => {
    //   block [0x82ECCEE8..0x82ECCEFC)
	// 82ECCEE8: 81440020  lwz r10, 0x20(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECCEEC: 81640034  lwz r11, 0x34(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECCEF0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECCEF4: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82ECCEF8: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	pc = 0x82ECCEFC; continue 'dispatch;
            }
            0x82ECCEFC => {
    //   block [0x82ECCEFC..0x82ECCF1C)
	// 82ECCEFC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECCF00: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECCF04: 41820020  beq 0x82eccf24
	if ctx.cr[0].eq {
	pc = 0x82ECCF24; continue 'dispatch;
	}
	// 82ECCF08: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECCF0C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECCF10: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82ECCF14: 40820008  bne 0x82eccf1c
	if !ctx.cr[0].eq {
	pc = 0x82ECCF1C; continue 'dispatch;
	}
	// 82ECCF18: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	pc = 0x82ECCF1C; continue 'dispatch;
            }
            0x82ECCF1C => {
    //   block [0x82ECCF1C..0x82ECCF24)
	// 82ECCF1C: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82ECCF20: 48000008  b 0x82eccf28
	pc = 0x82ECCF28; continue 'dispatch;
            }
            0x82ECCF24 => {
    //   block [0x82ECCF24..0x82ECCF28)
	// 82ECCF24: 916B0018  stw r11, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x82ECCF28; continue 'dispatch;
            }
            0x82ECCF28 => {
    //   block [0x82ECCF28..0x82ECCF38)
	// 82ECCF28: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82ECCF2C: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82ECCF30: 4082FFCC  bne 0x82eccefc
	if !ctx.cr[0].eq {
	pc = 0x82ECCEFC; continue 'dispatch;
	}
	// 82ECCF34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECCF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECCF38 size=192
    let mut pc: u32 = 0x82ECCF38;
    'dispatch: loop {
        match pc {
            0x82ECCF38 => {
    //   block [0x82ECCF38..0x82ECCF70)
	// 82ECCF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECCF3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECCF40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECCF44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECCF48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECCF4C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECCF50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECCF54: 83E4002C  lwz r31, 0x2c(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECCF58: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82ECCF5C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECCF60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECCF64: 4E800421  bctrl
	ctx.lr = 0x82ECCF68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECCF68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECCF6C: 41820074  beq 0x82eccfe0
	if ctx.cr[0].eq {
	pc = 0x82ECCFE0; continue 'dispatch;
	}
            }
            0x82ECCF70 => {
    //   block [0x82ECCF70..0x82ECCFA8)
	// 82ECCF70: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECCF74: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECCF78: 40820058  bne 0x82eccfd0
	if !ctx.cr[0].eq {
	pc = 0x82ECCFD0; continue 'dispatch;
	}
	// 82ECCF7C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECCF80: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECCF84: 4182004C  beq 0x82eccfd0
	if ctx.cr[0].eq {
	pc = 0x82ECCFD0; continue 'dispatch;
	}
	// 82ECCF88: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECCF8C: 7D4B5A78  xor r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 82ECCF90: 556B007F  clrlwi. r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECCF94: 4082003C  bne 0x82eccfd0
	if !ctx.cr[0].eq {
	pc = 0x82ECCFD0; continue 'dispatch;
	}
	// 82ECCF98: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECCF9C: 93EB0014  stw r31, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82ECCFA0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECCFA4: 48000020  b 0x82eccfc4
	pc = 0x82ECCFC4; continue 'dispatch;
            }
            0x82ECCFA8 => {
    //   block [0x82ECCFA8..0x82ECCFC4)
	// 82ECCFA8: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECCFAC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECCFB0: 419A0020  beq cr6, 0x82eccfd0
	if ctx.cr[6].eq {
	pc = 0x82ECCFD0; continue 'dispatch;
	}
	// 82ECCFB4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECCFB8: 554A0001  rlwinm. r10, r10, 0, 0, 0
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECCFBC: 41820008  beq 0x82eccfc4
	if ctx.cr[0].eq {
	pc = 0x82ECCFC4; continue 'dispatch;
	}
	// 82ECCFC0: 93EB0014  stw r31, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	pc = 0x82ECCFC4; continue 'dispatch;
            }
            0x82ECCFC4 => {
    //   block [0x82ECCFC4..0x82ECCFD0)
	// 82ECCFC4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECCFC8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECCFCC: 4082FFDC  bne 0x82eccfa8
	if !ctx.cr[0].eq {
	pc = 0x82ECCFA8; continue 'dispatch;
	}
	pc = 0x82ECCFD0; continue 'dispatch;
            }
            0x82ECCFD0 => {
    //   block [0x82ECCFD0..0x82ECCFE0)
	// 82ECCFD0: 817E01F4  lwz r11, 0x1f4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(500 as u32) ) } as u64;
	// 82ECCFD4: 3463FFFF  addic. r3, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82ECCFD8: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82ECCFDC: 4082FF94  bne 0x82eccf70
	if !ctx.cr[0].eq {
	pc = 0x82ECCF70; continue 'dispatch;
	}
	pc = 0x82ECCFE0; continue 'dispatch;
            }
            0x82ECCFE0 => {
    //   block [0x82ECCFE0..0x82ECCFF8)
	// 82ECCFE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECCFE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECCFE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECCFEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECCFF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECCFF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECCFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECCFF8 size=176
    let mut pc: u32 = 0x82ECCFF8;
    'dispatch: loop {
        match pc {
            0x82ECCFF8 => {
    //   block [0x82ECCFF8..0x82ECD028)
	// 82ECCFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECCFFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECD000: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECD004: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECD008: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD00C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82ECD010: 83E4002C  lwz r31, 0x2c(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECD014: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD018: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECD01C: 4E800421  bctrl
	ctx.lr = 0x82ECD020;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECD020: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD024: 41820070  beq 0x82ecd094
	if ctx.cr[0].eq {
	pc = 0x82ECD094; continue 'dispatch;
	}
            }
            0x82ECD028 => {
    //   block [0x82ECD028..0x82ECD060)
	// 82ECD028: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD02C: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECD030: 40820058  bne 0x82ecd088
	if !ctx.cr[0].eq {
	pc = 0x82ECD088; continue 'dispatch;
	}
	// 82ECD034: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECD038: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECD03C: 4182004C  beq 0x82ecd088
	if ctx.cr[0].eq {
	pc = 0x82ECD088; continue 'dispatch;
	}
	// 82ECD040: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD044: 7D4B5A78  xor r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 82ECD048: 556B007F  clrlwi. r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECD04C: 4082003C  bne 0x82ecd088
	if !ctx.cr[0].eq {
	pc = 0x82ECD088; continue 'dispatch;
	}
	// 82ECD050: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD054: 93EB0014  stw r31, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82ECD058: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD05C: 48000020  b 0x82ecd07c
	pc = 0x82ECD07C; continue 'dispatch;
            }
            0x82ECD060 => {
    //   block [0x82ECD060..0x82ECD07C)
	// 82ECD060: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD064: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECD068: 419A0020  beq cr6, 0x82ecd088
	if ctx.cr[6].eq {
	pc = 0x82ECD088; continue 'dispatch;
	}
	// 82ECD06C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECD070: 554A0001  rlwinm. r10, r10, 0, 0, 0
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECD074: 41820008  beq 0x82ecd07c
	if ctx.cr[0].eq {
	pc = 0x82ECD07C; continue 'dispatch;
	}
	// 82ECD078: 93EB0014  stw r31, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	pc = 0x82ECD07C; continue 'dispatch;
            }
            0x82ECD07C => {
    //   block [0x82ECD07C..0x82ECD088)
	// 82ECD07C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECD080: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD084: 4082FFDC  bne 0x82ecd060
	if !ctx.cr[0].eq {
	pc = 0x82ECD060; continue 'dispatch;
	}
	pc = 0x82ECD088; continue 'dispatch;
            }
            0x82ECD088 => {
    //   block [0x82ECD088..0x82ECD094)
	// 82ECD088: 3463FFFF  addic. r3, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82ECD08C: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82ECD090: 4082FF98  bne 0x82ecd028
	if !ctx.cr[0].eq {
	pc = 0x82ECD028; continue 'dispatch;
	}
	pc = 0x82ECD094; continue 'dispatch;
            }
            0x82ECD094 => {
    //   block [0x82ECD094..0x82ECD0A8)
	// 82ECD094: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ECD098: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECD09C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECD0A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECD0A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECD0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECD0A8 size=112
    let mut pc: u32 = 0x82ECD0A8;
    'dispatch: loop {
        match pc {
            0x82ECD0A8 => {
    //   block [0x82ECD0A8..0x82ECD0E0)
	// 82ECD0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECD0AC: 4BDDC35D  bl 0x82ca9408
	ctx.lr = 0x82ECD0B0;
	sub_82CA93D0(ctx, base);
	// 82ECD0B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECD0B4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD0B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ECD0BC: 83E4002C  lwz r31, 0x2c(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECD0C0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ECD0C4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82ECD0C8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD0CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECD0D0: 4E800421  bctrl
	ctx.lr = 0x82ECD0D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECD0D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD0D8: 41820038  beq 0x82ecd110
	if ctx.cr[0].eq {
	pc = 0x82ECD110; continue 'dispatch;
	}
	// 82ECD0DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
            }
            0x82ECD0E0 => {
    //   block [0x82ECD0E0..0x82ECD100)
	// 82ECD0E0: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD0E4: 548B0001  rlwinm. r11, r4, 0, 0, 0
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECD0E8: 41820018  beq 0x82ecd100
	if ctx.cr[0].eq {
	pc = 0x82ECD100; continue 'dispatch;
	}
	// 82ECD0EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ECD0F0: 4BFFF769  bl 0x82ecc858
	ctx.lr = 0x82ECD0F4;
	sub_82ECC858(ctx, base);
	// 82ECD0F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD0F8: 41820008  beq 0x82ecd100
	if ctx.cr[0].eq {
	pc = 0x82ECD100; continue 'dispatch;
	}
	// 82ECD0FC: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	pc = 0x82ECD100; continue 'dispatch;
            }
            0x82ECD100 => {
    //   block [0x82ECD100..0x82ECD110)
	// 82ECD100: 817D01F4  lwz r11, 0x1f4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(500 as u32) ) } as u64;
	// 82ECD104: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ECD108: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82ECD10C: 4082FFD4  bne 0x82ecd0e0
	if !ctx.cr[0].eq {
	pc = 0x82ECD0E0; continue 'dispatch;
	}
	pc = 0x82ECD110; continue 'dispatch;
            }
            0x82ECD110 => {
    //   block [0x82ECD110..0x82ECD118)
	// 82ECD110: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECD114: 4BDDC344  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECD118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECD118 size=108
    let mut pc: u32 = 0x82ECD118;
    'dispatch: loop {
        match pc {
            0x82ECD118 => {
    //   block [0x82ECD118..0x82ECD150)
	// 82ECD118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECD11C: 4BDDC2F1  bl 0x82ca940c
	ctx.lr = 0x82ECD120;
	sub_82CA93D0(ctx, base);
	// 82ECD120: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECD124: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD128: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82ECD12C: 83E4002C  lwz r31, 0x2c(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECD130: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82ECD134: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD138: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECD13C: 4E800421  bctrl
	ctx.lr = 0x82ECD140;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECD140: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD144: 41820038  beq 0x82ecd17c
	if ctx.cr[0].eq {
	pc = 0x82ECD17C; continue 'dispatch;
	}
	// 82ECD148: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82ECD14C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
            }
            0x82ECD150 => {
    //   block [0x82ECD150..0x82ECD170)
	// 82ECD150: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD154: 548B0001  rlwinm. r11, r4, 0, 0, 0
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECD158: 41820018  beq 0x82ecd170
	if ctx.cr[0].eq {
	pc = 0x82ECD170; continue 'dispatch;
	}
	// 82ECD15C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECD160: 4BFFF6F9  bl 0x82ecc858
	ctx.lr = 0x82ECD164;
	sub_82ECC858(ctx, base);
	// 82ECD164: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD168: 41820008  beq 0x82ecd170
	if ctx.cr[0].eq {
	pc = 0x82ECD170; continue 'dispatch;
	}
	// 82ECD16C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82ECD170; continue 'dispatch;
            }
            0x82ECD170 => {
    //   block [0x82ECD170..0x82ECD17C)
	// 82ECD170: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ECD174: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82ECD178: 4082FFD8  bne 0x82ecd150
	if !ctx.cr[0].eq {
	pc = 0x82ECD150; continue 'dispatch;
	}
	pc = 0x82ECD17C; continue 'dispatch;
            }
            0x82ECD17C => {
    //   block [0x82ECD17C..0x82ECD184)
	// 82ECD17C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECD180: 4BDDC2DC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECD188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECD188 size=100
    let mut pc: u32 = 0x82ECD188;
    'dispatch: loop {
        match pc {
            0x82ECD188 => {
    //   block [0x82ECD188..0x82ECD1B0)
	// 82ECD188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECD18C: 4BDDC281  bl 0x82ca940c
	ctx.lr = 0x82ECD190;
	sub_82CA93D0(ctx, base);
	// 82ECD190: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECD194: 81640020  lwz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECD198: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECD19C: 81040034  lwz r8, 0x34(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECD1A0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82ECD1A4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECD1A8: 4081003C  ble 0x82ecd1e4
	if !ctx.cr[0].gt {
	pc = 0x82ECD1E4; continue 'dispatch;
	}
	// 82ECD1AC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x82ECD1B0; continue 'dispatch;
            }
            0x82ECD1B0 => {
    //   block [0x82ECD1B0..0x82ECD1D4)
	// 82ECD1B0: 81680014  lwz r11, 0x14(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECD1B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECD1B8: 409A001C  bne cr6, 0x82ecd1d4
	if !ctx.cr[6].eq {
	pc = 0x82ECD1D4; continue 'dispatch;
	}
	// 82ECD1BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECD1C0: 80880000  lwz r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD1C4: 4BFFF5BD  bl 0x82ecc780
	ctx.lr = 0x82ECD1C8;
	sub_82ECC780(ctx, base);
	// 82ECD1C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD1CC: 41820008  beq 0x82ecd1d4
	if ctx.cr[0].eq {
	pc = 0x82ECD1D4; continue 'dispatch;
	}
	// 82ECD1D0: 90680014  stw r3, 0x14(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	pc = 0x82ECD1D4; continue 'dispatch;
            }
            0x82ECD1D4 => {
    //   block [0x82ECD1D4..0x82ECD1E4)
	// 82ECD1D4: 817E01F4  lwz r11, 0x1f4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(500 as u32) ) } as u64;
	// 82ECD1D8: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ECD1DC: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82ECD1E0: 4082FFD0  bne 0x82ecd1b0
	if !ctx.cr[0].eq {
	pc = 0x82ECD1B0; continue 'dispatch;
	}
	pc = 0x82ECD1E4; continue 'dispatch;
            }
            0x82ECD1E4 => {
    //   block [0x82ECD1E4..0x82ECD1EC)
	// 82ECD1E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECD1E8: 4BDDC274  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECD1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECD1F0 size=160
    let mut pc: u32 = 0x82ECD1F0;
    'dispatch: loop {
        match pc {
            0x82ECD1F0 => {
    //   block [0x82ECD1F0..0x82ECD218)
	// 82ECD1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECD1F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECD1F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECD1FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECD200: 81640020  lwz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECD204: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82ECD208: 81040034  lwz r8, 0x34(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECD20C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECD210: 4081006C  ble 0x82ecd27c
	if !ctx.cr[0].gt {
	pc = 0x82ECD27C; continue 'dispatch;
	}
	// 82ECD214: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x82ECD218; continue 'dispatch;
            }
            0x82ECD218 => {
    //   block [0x82ECD218..0x82ECD270)
	// 82ECD218: 81680018  lwz r11, 0x18(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECD21C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECD220: 409A0050  bne cr6, 0x82ecd270
	if !ctx.cr[6].eq {
	pc = 0x82ECD270; continue 'dispatch;
	}
	// 82ECD224: 80E90034  lwz r7, 0x34(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECD228: 80C80000  lwz r6, 0(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD22C: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECD230: 41820040  beq 0x82ecd270
	if ctx.cr[0].eq {
	pc = 0x82ECD270; continue 'dispatch;
	}
	// 82ECD234: 81690020  lwz r11, 0x20(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECD238: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD23C: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 82ECD240: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ECD244: 4199002C  bgt cr6, 0x82ecd270
	if ctx.cr[6].gt {
	pc = 0x82ECD270; continue 'dispatch;
	}
	// 82ECD248: 54AB2834  slwi r11, r5, 5
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECD24C: 7D6B382E  lwzx r11, r11, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82ECD250: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ECD254: 4198001C  blt cr6, 0x82ecd270
	if ctx.cr[6].lt {
	pc = 0x82ECD270; continue 'dispatch;
	}
	// 82ECD258: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ECD25C: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 82ECD260: 4BFFF4A9  bl 0x82ecc708
	ctx.lr = 0x82ECD264;
	sub_82ECC708(ctx, base);
	// 82ECD264: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD268: 41820008  beq 0x82ecd270
	if ctx.cr[0].eq {
	pc = 0x82ECD270; continue 'dispatch;
	}
	// 82ECD26C: 90680018  stw r3, 0x18(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	pc = 0x82ECD270; continue 'dispatch;
            }
            0x82ECD270 => {
    //   block [0x82ECD270..0x82ECD27C)
	// 82ECD270: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ECD274: 39080020  addi r8, r8, 0x20
	ctx.r[8].s64 = ctx.r[8].s64 + 32;
	// 82ECD278: 4082FFA0  bne 0x82ecd218
	if !ctx.cr[0].eq {
	pc = 0x82ECD218; continue 'dispatch;
	}
	pc = 0x82ECD27C; continue 'dispatch;
            }
            0x82ECD27C => {
    //   block [0x82ECD27C..0x82ECD290)
	// 82ECD27C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ECD280: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECD284: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECD288: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECD28C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECD290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECD290 size=180
    let mut pc: u32 = 0x82ECD290;
    'dispatch: loop {
        match pc {
            0x82ECD290 => {
    //   block [0x82ECD290..0x82ECD2C8)
	// 82ECD290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECD294: 4BDDC16D  bl 0x82ca9400
	ctx.lr = 0x82ECD298;
	sub_82CA93D0(ctx, base);
	// 82ECD298: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECD29C: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD2A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECD2A4: 83C5002C  lwz r30, 0x2c(r5)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECD2A8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82ECD2AC: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82ECD2B0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD2B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECD2B8: 4E800421  bctrl
	ctx.lr = 0x82ECD2BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECD2BC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82ECD2C0: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82ECD2C4: 41820078  beq 0x82ecd33c
	if ctx.cr[0].eq {
	pc = 0x82ECD33C; continue 'dispatch;
	}
            }
            0x82ECD2C8 => {
    //   block [0x82ECD2C8..0x82ECD328)
	// 82ECD2C8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD2CC: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 82ECD2D0: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECD2D4: 41820054  beq 0x82ecd328
	if ctx.cr[0].eq {
	pc = 0x82ECD328; continue 'dispatch;
	}
	// 82ECD2D8: 5564007E  clrlwi r4, r11, 1
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82ECD2DC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82ECD2E0: 4BFFF579  bl 0x82ecc858
	ctx.lr = 0x82ECD2E4;
	sub_82ECC858(ctx, base);
	// 82ECD2E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD2E8: 41820040  beq 0x82ecd328
	if ctx.cr[0].eq {
	pc = 0x82ECD328; continue 'dispatch;
	}
	// 82ECD2EC: 3D7F0001  addis r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 65536;
	// 82ECD2F0: 396B82A4  addi r11, r11, -0x7d5c
	ctx.r[11].s64 = ctx.r[11].s64 + -32092;
	// 82ECD2F4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD2F8: 2B0A1000  cmplwi cr6, r10, 0x1000
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4096 as u32, &mut ctx.xer);
	// 82ECD2FC: 40980040  bge cr6, 0x82ecd33c
	if !ctx.cr[6].lt {
	pc = 0x82ECD33C; continue 'dispatch;
	}
	// 82ECD300: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ECD304: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82ECD308: 93AA02A4  stw r29, 0x2a4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(676 as u32), ctx.r[29].u32 ) };
	// 82ECD30C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD310: 394A0055  addi r10, r10, 0x55
	ctx.r[10].s64 = ctx.r[10].s64 + 85;
	// 82ECD314: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ECD318: 7C6AF92E  stwx r3, r10, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[3].u32) };
	// 82ECD31C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD320: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ECD324: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82ECD328; continue 'dispatch;
            }
            0x82ECD328 => {
    //   block [0x82ECD328..0x82ECD33C)
	// 82ECD328: 817F01F4  lwz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 82ECD32C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ECD330: 7FCBF214  add r30, r11, r30
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82ECD334: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82ECD338: 4198FF90  blt cr6, 0x82ecd2c8
	if ctx.cr[6].lt {
	pc = 0x82ECD2C8; continue 'dispatch;
	}
	pc = 0x82ECD33C; continue 'dispatch;
            }
            0x82ECD33C => {
    //   block [0x82ECD33C..0x82ECD344)
	// 82ECD33C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ECD340: 4BDDC110  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECD348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECD348 size=176
    let mut pc: u32 = 0x82ECD348;
    'dispatch: loop {
        match pc {
            0x82ECD348 => {
    //   block [0x82ECD348..0x82ECD384)
	// 82ECD348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECD34C: 4BDDC0B9  bl 0x82ca9404
	ctx.lr = 0x82ECD350;
	sub_82CA93D0(ctx, base);
	// 82ECD350: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECD354: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECD35C: 83C5002C  lwz r30, 0x2c(r5)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECD360: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82ECD364: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82ECD368: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD36C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECD370: 4E800421  bctrl
	ctx.lr = 0x82ECD374;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECD374: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ECD378: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82ECD37C: 41820074  beq 0x82ecd3f0
	if ctx.cr[0].eq {
	pc = 0x82ECD3F0; continue 'dispatch;
	}
	// 82ECD380: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
            }
            0x82ECD384 => {
    //   block [0x82ECD384..0x82ECD3E0)
	// 82ECD384: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD388: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECD38C: 41820054  beq 0x82ecd3e0
	if ctx.cr[0].eq {
	pc = 0x82ECD3E0; continue 'dispatch;
	}
	// 82ECD390: 5564007E  clrlwi r4, r11, 1
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82ECD394: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82ECD398: 4BFFF4C1  bl 0x82ecc858
	ctx.lr = 0x82ECD39C;
	sub_82ECC858(ctx, base);
	// 82ECD39C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD3A0: 41820040  beq 0x82ecd3e0
	if ctx.cr[0].eq {
	pc = 0x82ECD3E0; continue 'dispatch;
	}
	// 82ECD3A4: 3D7F0001  addis r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 65536;
	// 82ECD3A8: 396B82A4  addi r11, r11, -0x7d5c
	ctx.r[11].s64 = ctx.r[11].s64 + -32092;
	// 82ECD3AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD3B0: 2B0A1000  cmplwi cr6, r10, 0x1000
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4096 as u32, &mut ctx.xer);
	// 82ECD3B4: 4098003C  bge cr6, 0x82ecd3f0
	if !ctx.cr[6].lt {
	pc = 0x82ECD3F0; continue 'dispatch;
	}
	// 82ECD3B8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ECD3BC: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82ECD3C0: 93CA02A4  stw r30, 0x2a4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(676 as u32), ctx.r[30].u32 ) };
	// 82ECD3C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD3C8: 394A0055  addi r10, r10, 0x55
	ctx.r[10].s64 = ctx.r[10].s64 + 85;
	// 82ECD3CC: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ECD3D0: 7C6AF92E  stwx r3, r10, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[3].u32) };
	// 82ECD3D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD3D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ECD3DC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82ECD3E0; continue 'dispatch;
            }
            0x82ECD3E0 => {
    //   block [0x82ECD3E0..0x82ECD3F0)
	// 82ECD3E0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82ECD3E4: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82ECD3E8: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82ECD3EC: 4198FF98  blt cr6, 0x82ecd384
	if ctx.cr[6].lt {
	pc = 0x82ECD384; continue 'dispatch;
	}
	pc = 0x82ECD3F0; continue 'dispatch;
            }
            0x82ECD3F0 => {
    //   block [0x82ECD3F0..0x82ECD3F8)
	// 82ECD3F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECD3F4: 4BDDC060  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECD3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECD3F8 size=320
    let mut pc: u32 = 0x82ECD3F8;
    'dispatch: loop {
        match pc {
            0x82ECD3F8 => {
    //   block [0x82ECD3F8..0x82ECD434)
	// 82ECD3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECD3FC: 4BDDC005  bl 0x82ca9400
	ctx.lr = 0x82ECD400;
	sub_82CA93D0(ctx, base);
	// 82ECD400: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82ECD404: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECD408: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECD40C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82ECD410: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82ECD414: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 82ECD418: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ECD41C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECD420: 409900D0  ble cr6, 0x82ecd4f0
	if !ctx.cr[6].gt {
	pc = 0x82ECD4F0; continue 'dispatch;
	}
	// 82ECD424: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECD428: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82ECD42C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82ECD430: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82ECD434; continue 'dispatch;
            }
            0x82ECD434 => {
    //   block [0x82ECD434..0x82ECD480)
	// 82ECD434: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ECD438: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82ECD43C: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD440: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD444: 40820098  bne 0x82ecd4dc
	if !ctx.cr[0].eq {
	pc = 0x82ECD4DC; continue 'dispatch;
	}
	// 82ECD448: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECD44C: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82ECD450: 409A008C  bne cr6, 0x82ecd4dc
	if !ctx.cr[6].eq {
	pc = 0x82ECD4DC; continue 'dispatch;
	}
	// 82ECD454: 938B0014  stw r28, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 82ECD458: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ECD45C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82ECD460: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 82ECD464: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD468: 41820018  beq 0x82ecd480
	if ctx.cr[0].eq {
	pc = 0x82ECD480; continue 'dispatch;
	}
	// 82ECD46C: 9BAB0010  stb r29, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82ECD470: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ECD474: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82ECD478: 9B8B0039  stb r28, 0x39(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(57 as u32), ctx.r[28].u8 ) };
	// 82ECD47C: 48000060  b 0x82ecd4dc
	pc = 0x82ECD4DC; continue 'dispatch;
            }
            0x82ECD480 => {
    //   block [0x82ECD480..0x82ECD4BC)
	// 82ECD480: C00B0028  lfs f0, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECD484: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ECD488: 419A003C  beq cr6, 0x82ecd4c4
	if ctx.cr[6].eq {
	pc = 0x82ECD4C4; continue 'dispatch;
	}
	// 82ECD48C: C00B002C  lfs f0, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECD490: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ECD494: 419A0030  beq cr6, 0x82ecd4c4
	if ctx.cr[6].eq {
	pc = 0x82ECD4C4; continue 'dispatch;
	}
	// 82ECD498: 4B393521  bl 0x822609b8
	ctx.lr = 0x82ECD49C;
	sub_822609B8(ctx, base);
	// 82ECD49C: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ECD4A0: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82ECD4A4: C00B0028  lfs f0, 0x28(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECD4A8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ECD4AC: 41980010  blt cr6, 0x82ecd4bc
	if ctx.cr[6].lt {
	pc = 0x82ECD4BC; continue 'dispatch;
	}
	// 82ECD4B0: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECD4B4: C18B002C  lfs f12, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ECD4B8: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	pc = 0x82ECD4BC; continue 'dispatch;
            }
            0x82ECD4BC => {
    //   block [0x82ECD4BC..0x82ECD4C4)
	// 82ECD4BC: 9BAB0038  stb r29, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 82ECD4C0: 4800001C  b 0x82ecd4dc
	pc = 0x82ECD4DC; continue 'dispatch;
            }
            0x82ECD4C4 => {
    //   block [0x82ECD4C4..0x82ECD4DC)
	// 82ECD4C4: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECD4C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ECD4CC: 914B0034  stw r10, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 82ECD4D0: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ECD4D4: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82ECD4D8: 9BAB0030  stb r29, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	pc = 0x82ECD4DC; continue 'dispatch;
            }
            0x82ECD4DC => {
    //   block [0x82ECD4DC..0x82ECD4F0)
	// 82ECD4DC: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ECD4E0: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82ECD4E4: 3BDE004C  addi r30, r30, 0x4c
	ctx.r[30].s64 = ctx.r[30].s64 + 76;
	// 82ECD4E8: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECD4EC: 4198FF48  blt cr6, 0x82ecd434
	if ctx.cr[6].lt {
	pc = 0x82ECD434; continue 'dispatch;
	}
	pc = 0x82ECD4F0; continue 'dispatch;
            }
            0x82ECD4F0 => {
    //   block [0x82ECD4F0..0x82ECD514)
	// 82ECD4F0: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD4F4: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ECD4F8: 40980024  bge cr6, 0x82ecd51c
	if !ctx.cr[6].lt {
	pc = 0x82ECD51C; continue 'dispatch;
	}
	// 82ECD4FC: 817F014C  lwz r11, 0x14c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82ECD500: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECD504: 409A0010  bne cr6, 0x82ecd514
	if !ctx.cr[6].eq {
	pc = 0x82ECD514; continue 'dispatch;
	}
	// 82ECD508: 939F014C  stw r28, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[28].u32 ) };
	// 82ECD50C: 939F015C  stw r28, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[28].u32 ) };
	// 82ECD510: 939F0154  stw r28, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[28].u32 ) };
	pc = 0x82ECD514; continue 'dispatch;
            }
            0x82ECD514 => {
    //   block [0x82ECD514..0x82ECD51C)
	// 82ECD514: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82ECD518: 48000014  b 0x82ecd52c
	pc = 0x82ECD52C; continue 'dispatch;
            }
            0x82ECD51C => {
    //   block [0x82ECD51C..0x82ECD52C)
	// 82ECD51C: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82ECD520: 939A000C  stw r28, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82ECD524: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECD528: 917A0010  stw r11, 0x10(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82ECD52C; continue 'dispatch;
            }
            0x82ECD52C => {
    //   block [0x82ECD52C..0x82ECD538)
	// 82ECD52C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ECD530: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82ECD534: 4BDDBF1C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECD538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECD538 size=84
    let mut pc: u32 = 0x82ECD538;
    'dispatch: loop {
        match pc {
            0x82ECD538 => {
    //   block [0x82ECD538..0x82ECD58C)
	// 82ECD538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECD53C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECD540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECD544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECD548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECD54C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECD550: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82ECD554: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82ECD558: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECD55C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECD560: 4BDDBF21  bl 0x82ca9480
	ctx.lr = 0x82ECD564;
	sub_82CA9480(ctx, base);
	// 82ECD564: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECD568: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECD56C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82ECD570: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82ECD574: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECD578: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECD57C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECD580: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECD584: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECD588: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECD590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECD590 size=36
    let mut pc: u32 = 0x82ECD590;
    'dispatch: loop {
        match pc {
            0x82ECD590 => {
    //   block [0x82ECD590..0x82ECD5B4)
	// 82ECD590: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ECD594: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD598: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECD59C: 7D432214  add r10, r3, r4
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[4].u64;
	// 82ECD5A0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ECD5A4: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82ECD5A8: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 82ECD5AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECD5B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECD5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECD5B8 size=216
    let mut pc: u32 = 0x82ECD5B8;
    'dispatch: loop {
        match pc {
            0x82ECD5B8 => {
    //   block [0x82ECD5B8..0x82ECD5C8)
	// 82ECD5B8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ECD5BC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECD5C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECD5C4: 39430194  addi r10, r3, 0x194
	ctx.r[10].s64 = ctx.r[3].s64 + 404;
	pc = 0x82ECD5C8; continue 'dispatch;
            }
            0x82ECD5C8 => {
    //   block [0x82ECD5C8..0x82ECD5E8)
	// 82ECD5C8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD5CC: 2B070002  cmplwi cr6, r7, 2
	ctx.cr[6].compare_u32(ctx.r[7].u32, 2 as u32, &mut ctx.xer);
	// 82ECD5D0: 419A0018  beq cr6, 0x82ecd5e8
	if ctx.cr[6].eq {
	pc = 0x82ECD5E8; continue 'dispatch;
	}
	// 82ECD5D4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECD5D8: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82ECD5DC: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82ECD5E0: 4198FFE8  blt cr6, 0x82ecd5c8
	if ctx.cr[6].lt {
	pc = 0x82ECD5C8; continue 'dispatch;
	}
	// 82ECD5E4: 48000014  b 0x82ecd5f8
	pc = 0x82ECD5F8; continue 'dispatch;
            }
            0x82ECD5E8 => {
    //   block [0x82ECD5E8..0x82ECD5F8)
	// 82ECD5E8: 396B0022  addi r11, r11, 0x22
	ctx.r[11].s64 = ctx.r[11].s64 + 34;
	// 82ECD5EC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82ECD5F0: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ECD5F4: 7D0B182E  lwzx r8, r11, r3
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	pc = 0x82ECD5F8; continue 'dispatch;
            }
            0x82ECD5F8 => {
    //   block [0x82ECD5F8..0x82ECD614)
	// 82ECD5F8: 552B063F  clrlwi. r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECD5FC: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82ECD600: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ECD604: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ECD608: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD60C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECD610: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82ECD614; continue 'dispatch;
            }
            0x82ECD614 => {
    //   block [0x82ECD614..0x82ECD690)
	// 82ECD614: 816301F4  lwz r11, 0x1f4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(500 as u32) ) } as u64;
	// 82ECD618: 8124002C  lwz r9, 0x2c(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECD61C: 7D6B51D6  mullw r11, r11, r10
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ECD620: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82ECD624: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ECD628: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82ECD62C: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 82ECD630: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD634: 5527403E  rotlwi r7, r9, 8
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 82ECD638: 5529C23E  srwi r9, r9, 8
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82ECD63C: 54E7043E  clrlwi r7, r7, 0x10
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0000FFFFu64;
	// 82ECD640: 7CE94B78  or r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 | ctx.r[9].u64;
	// 82ECD644: B12B0000  sth r9, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 82ECD648: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82ECD64C: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD650: 5527403E  rotlwi r7, r9, 8
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 82ECD654: 5529C23E  srwi r9, r9, 8
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82ECD658: 54E7043E  clrlwi r7, r7, 0x10
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0000FFFFu64;
	// 82ECD65C: 7CE94B78  or r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 | ctx.r[9].u64;
	// 82ECD660: B12B0000  sth r9, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 82ECD664: A12B0002  lhz r9, 2(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82ECD668: 5527403E  rotlwi r7, r9, 8
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 82ECD66C: 5529C23E  srwi r9, r9, 8
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82ECD670: 54E7043E  clrlwi r7, r7, 0x10
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0000FFFFu64;
	// 82ECD674: 7CE94B78  or r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 | ctx.r[9].u64;
	// 82ECD678: B12B0002  sth r9, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[9].u16 ) };
	// 82ECD67C: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ECD680: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD684: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECD688: 4198FF8C  blt cr6, 0x82ecd614
	if ctx.cr[6].lt {
	pc = 0x82ECD614; continue 'dispatch;
	}
	// 82ECD68C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECD690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82ECD690 size=132
    let mut pc: u32 = 0x82ECD690;
    'dispatch: loop {
        match pc {
            0x82ECD690 => {
    //   block [0x82ECD690..0x82ECD714)
	// 82ECD690: 8164001C  lwz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECD694: 8145001C  lwz r10, 0x1c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECD698: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECD69C: 810A001C  lwz r8, 0x1c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECD6A0: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82ECD6A4: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82ECD6A8: 2B070002  cmplwi cr6, r7, 2
	ctx.cr[6].compare_u32(ctx.r[7].u32, 2 as u32, &mut ctx.xer);
	// 82ECD6AC: 4199012C  bgt cr6, 0x82ecd7d8
	if ctx.cr[6].gt {
		sub_82ECD77C(ctx, base);
		return;
	}
	// 82ECD6B0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82ECD6B4: 409A00C8  bne cr6, 0x82ecd77c
	if !ctx.cr[6].eq {
		sub_82ECD77C(ctx, base);
		return;
	}
	// 82ECD6B8: 81230180  lwz r9, 0x180(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(384 as u32) ) } as u64;
	// 82ECD6BC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ECD6C0: 409A0054  bne cr6, 0x82ecd714
	if !ctx.cr[6].eq {
		sub_82ECD714(ctx, base);
		return;
	}
	// 82ECD6C4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECD6C8: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECD6CC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82ECD6D0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ECD6D4: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 82ECD6D8: 41990100  bgt cr6, 0x82ecd7d8
	if ctx.cr[6].gt {
		sub_82ECD77C(ctx, base);
		return;
	}
	// 82ECD6DC: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECD6E0: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECD6E4: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82ECD6E8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ECD6EC: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 82ECD6F0: 419900E8  bgt cr6, 0x82ecd7d8
	if ctx.cr[6].gt {
		sub_82ECD77C(ctx, base);
		return;
	}
	// 82ECD6F4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECD6F8: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECD6FC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82ECD700: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECD704: 216B0002  subfic r11, r11, 2
	ctx.xer.ca = ctx.r[11].u32 <= 2 as u32;
	ctx.r[11].s64 = (2 as i64) - ctx.r[11].s64;
	// 82ECD708: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82ECD70C: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82ECD710: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECD714(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82ECD714 size=104
    let mut pc: u32 = 0x82ECD714;
    'dispatch: loop {
        match pc {
            0x82ECD714 => {
    //   block [0x82ECD714..0x82ECD77C)
	// 82ECD714: C00B0008  lfs f0, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECD718: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECD71C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECD720: 419800B8  blt cr6, 0x82ecd7d8
	if ctx.cr[6].lt {
		sub_82ECD77C(ctx, base);
		return;
	}
	// 82ECD724: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECD728: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECD72C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECD730: 419800A8  blt cr6, 0x82ecd7d8
	if ctx.cr[6].lt {
		sub_82ECD77C(ctx, base);
		return;
	}
	// 82ECD734: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECD738: C1AA0014  lfs f13, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECD73C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECD740: 41980098  blt cr6, 0x82ecd7d8
	if ctx.cr[6].lt {
		sub_82ECD77C(ctx, base);
		return;
	}
	// 82ECD744: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECD748: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECD74C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECD750: 41990088  bgt cr6, 0x82ecd7d8
	if ctx.cr[6].gt {
		sub_82ECD77C(ctx, base);
		return;
	}
	// 82ECD754: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECD758: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECD75C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECD760: 41990078  bgt cr6, 0x82ecd7d8
	if ctx.cr[6].gt {
		sub_82ECD77C(ctx, base);
		return;
	}
	// 82ECD764: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECD768: C1AA0018  lfs f13, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECD76C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECD770: 41990068  bgt cr6, 0x82ecd7d8
	if ctx.cr[6].gt {
		sub_82ECD77C(ctx, base);
		return;
	}
	// 82ECD774: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECD778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECD77C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECD77C size=100
    let mut pc: u32 = 0x82ECD77C;
    'dispatch: loop {
        match pc {
            0x82ECD77C => {
    //   block [0x82ECD77C..0x82ECD7D8)
	// 82ECD77C: 40990064  ble cr6, 0x82ecd7e0
	if !ctx.cr[6].gt {
		sub_82ECD7E0(ctx, base);
		return;
	}
	// 82ECD780: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECD784: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECD788: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82ECD78C: 7D294050  subf r9, r9, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82ECD790: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ECD794: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 82ECD798: 41990040  bgt cr6, 0x82ecd7d8
	if ctx.cr[6].gt {
	pc = 0x82ECD7D8; continue 'dispatch;
	}
	// 82ECD79C: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECD7A0: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECD7A4: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82ECD7A8: 7D294050  subf r9, r9, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82ECD7AC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ECD7B0: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 82ECD7B4: 41990024  bgt cr6, 0x82ecd7d8
	if ctx.cr[6].gt {
	pc = 0x82ECD7D8; continue 'dispatch;
	}
	// 82ECD7B8: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECD7BC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECD7C0: 7D4A0E70  srawi r10, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 82ECD7C4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82ECD7C8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECD7CC: 4198000C  blt cr6, 0x82ecd7d8
	if ctx.cr[6].lt {
	pc = 0x82ECD7D8; continue 'dispatch;
	}
	// 82ECD7D0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ECD7D4: 4099FFA0  ble cr6, 0x82ecd774
	if !ctx.cr[6].gt {
		sub_82ECD714(ctx, base);
		return;
	}
	pc = 0x82ECD7D8; continue 'dispatch;
            }
            0x82ECD7D8 => {
    //   block [0x82ECD7D8..0x82ECD7E0)
	// 82ECD7D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECD7DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECD7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECD7E0 size=84
    let mut pc: u32 = 0x82ECD7E0;
    'dispatch: loop {
        match pc {
            0x82ECD7E0 => {
    //   block [0x82ECD7E0..0x82ECD834)
	// 82ECD7E0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECD7E4: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECD7E8: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82ECD7EC: 7D294050  subf r9, r9, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82ECD7F0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ECD7F4: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 82ECD7F8: 4199FFE0  bgt cr6, 0x82ecd7d8
	if ctx.cr[6].gt {
		sub_82ECD77C(ctx, base);
		return;
	}
	// 82ECD7FC: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECD800: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECD804: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82ECD808: 7D294050  subf r9, r9, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82ECD80C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ECD810: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 82ECD814: 4199FFC4  bgt cr6, 0x82ecd7d8
	if ctx.cr[6].gt {
		sub_82ECD77C(ctx, base);
		return;
	}
	// 82ECD818: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECD81C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECD820: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82ECD824: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82ECD828: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECD82C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82ECD830: 4BFFFF40  b 0x82ecd770
	sub_82ECD714(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECD838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECD838 size=1252
    let mut pc: u32 = 0x82ECD838;
    'dispatch: loop {
        match pc {
            0x82ECD838 => {
    //   block [0x82ECD838..0x82ECD898)
	// 82ECD838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECD83C: 4BDDBBB1  bl 0x82ca93ec
	ctx.lr = 0x82ECD840;
	sub_82CA93D0(ctx, base);
	// 82ECD840: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECD844: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82ECD848: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 82ECD84C: 81780160  lwz r11, 0x160(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(352 as u32) ) } as u64;
	// 82ECD850: 92AB0010  stw r21, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[21].u32 ) };
	// 82ECD854: 80780160  lwz r3, 0x160(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(352 as u32) ) } as u64;
	// 82ECD858: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD85C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECD860: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECD864: 4E800421  bctrl
	ctx.lr = 0x82ECD868;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECD868: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ECD86C: 409A0130  bne cr6, 0x82ecd99c
	if !ctx.cr[6].eq {
	pc = 0x82ECD99C; continue 'dispatch;
	}
	// 82ECD870: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECD874: 83F80160  lwz r31, 0x160(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(352 as u32) ) } as u64;
	// 82ECD878: 616B84FC  ori r11, r11, 0x84fc
	ctx.r[11].u64 = ctx.r[11].u64 | 34044;
	// 82ECD87C: 7D78582E  lwzx r11, r24, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECD880: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECD884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECD888: 419A0010  beq cr6, 0x82ecd898
	if ctx.cr[6].eq {
	pc = 0x82ECD898; continue 'dispatch;
	}
	// 82ECD88C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECD890: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82ECD894: 4BFFF4FD  bl 0x82eccd90
	ctx.lr = 0x82ECD898;
	sub_82ECCD90(ctx, base);
            }
            0x82ECD898 => {
    //   block [0x82ECD898..0x82ECD8B8)
	// 82ECD898: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD89C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECD8A0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD8A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECD8A8: 4E800421  bctrl
	ctx.lr = 0x82ECD8AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECD8AC: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECD8B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD8B4: 41820454  beq 0x82ecdd08
	if ctx.cr[0].eq {
	pc = 0x82ECDD08; continue 'dispatch;
	}
            }
            0x82ECD8B8 => {
    //   block [0x82ECD8B8..0x82ECD8D8)
	// 82ECD8B8: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECD8BC: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 82ECD8C0: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD8C4: 41820028  beq 0x82ecd8ec
	if ctx.cr[0].eq {
	pc = 0x82ECD8EC; continue 'dispatch;
	}
	// 82ECD8C8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECD8CC: 419A0020  beq cr6, 0x82ecd8ec
	if ctx.cr[6].eq {
	pc = 0x82ECD8EC; continue 'dispatch;
	}
	// 82ECD8D0: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82ECD8D4: 48000008  b 0x82ecd8dc
	pc = 0x82ECD8DC; continue 'dispatch;
            }
            0x82ECD8D8 => {
    //   block [0x82ECD8D8..0x82ECD8DC)
	// 82ECD8D8: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	pc = 0x82ECD8DC; continue 'dispatch;
            }
            0x82ECD8DC => {
    //   block [0x82ECD8DC..0x82ECD8EC)
	// 82ECD8DC: 810A0014  lwz r8, 0x14(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECD8E0: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECD8E4: 409AFFF4  bne cr6, 0x82ecd8d8
	if !ctx.cr[6].eq {
	pc = 0x82ECD8D8; continue 'dispatch;
	}
	// 82ECD8E8: 912A0014  stw r9, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	pc = 0x82ECD8EC; continue 'dispatch;
            }
            0x82ECD8EC => {
    //   block [0x82ECD8EC..0x82ECD93C)
	// 82ECD8EC: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD8F0: 55280001  rlwinm. r8, r9, 0, 0, 0
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82ECD8F4: 40820094  bne 0x82ecd988
	if !ctx.cr[0].eq {
	pc = 0x82ECD988; continue 'dispatch;
	}
	// 82ECD8F8: C0090004  lfs f0, 4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECD8FC: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECD900: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECD904: 409A0084  bne cr6, 0x82ecd988
	if !ctx.cr[6].eq {
	pc = 0x82ECD988; continue 'dispatch;
	}
	// 82ECD908: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECD90C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECD910: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECD914: 409A0074  bne cr6, 0x82ecd988
	if !ctx.cr[6].eq {
	pc = 0x82ECD988; continue 'dispatch;
	}
	// 82ECD918: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECD91C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECD920: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECD924: 409A0064  bne cr6, 0x82ecd988
	if !ctx.cr[6].eq {
	pc = 0x82ECD988; continue 'dispatch;
	}
	// 82ECD928: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD92C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ECD930: 65088000  oris r8, r8, 0x8000
	ctx.r[8].u64 = ctx.r[8].u64 | 2147483648;
	// 82ECD934: 419A0008  beq cr6, 0x82ecd93c
	if ctx.cr[6].eq {
	pc = 0x82ECD93C; continue 'dispatch;
	}
	// 82ECD938: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	pc = 0x82ECD93C; continue 'dispatch;
            }
            0x82ECD93C => {
    //   block [0x82ECD93C..0x82ECD94C)
	// 82ECD93C: 81490014  lwz r10, 0x14(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECD940: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECD944: 409A0008  bne cr6, 0x82ecd94c
	if !ctx.cr[6].eq {
	pc = 0x82ECD94C; continue 'dispatch;
	}
	// 82ECD948: 91090014  stw r8, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	pc = 0x82ECD94C; continue 'dispatch;
            }
            0x82ECD94C => {
    //   block [0x82ECD94C..0x82ECD960)
	// 82ECD94C: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD950: 81490018  lwz r10, 0x18(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECD954: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD958: 41820030  beq 0x82ecd988
	if ctx.cr[0].eq {
	pc = 0x82ECD988; continue 'dispatch;
	}
	// 82ECD95C: 48000024  b 0x82ecd980
	pc = 0x82ECD980; continue 'dispatch;
            }
            0x82ECD960 => {
    //   block [0x82ECD960..0x82ECD978)
	// 82ECD960: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECD964: 55270001  rlwinm. r7, r9, 0, 0, 0
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82ECD968: 40820010  bne 0x82ecd978
	if !ctx.cr[0].eq {
	pc = 0x82ECD978; continue 'dispatch;
	}
	// 82ECD96C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECD970: 409A0008  bne cr6, 0x82ecd978
	if !ctx.cr[6].eq {
	pc = 0x82ECD978; continue 'dispatch;
	}
	// 82ECD974: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	pc = 0x82ECD978; continue 'dispatch;
            }
            0x82ECD978 => {
    //   block [0x82ECD978..0x82ECD980)
	// 82ECD978: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECD97C: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	pc = 0x82ECD980; continue 'dispatch;
            }
            0x82ECD980 => {
    //   block [0x82ECD980..0x82ECD988)
	// 82ECD980: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ECD984: 409AFFDC  bne cr6, 0x82ecd960
	if !ctx.cr[6].eq {
	pc = 0x82ECD960; continue 'dispatch;
	}
	pc = 0x82ECD988; continue 'dispatch;
            }
            0x82ECD988 => {
    //   block [0x82ECD988..0x82ECD99C)
	// 82ECD988: 815801F4  lwz r10, 0x1f4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(500 as u32) ) } as u64;
	// 82ECD98C: 3463FFFF  addic. r3, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82ECD990: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82ECD994: 4082FF24  bne 0x82ecd8b8
	if !ctx.cr[0].eq {
	pc = 0x82ECD8B8; continue 'dispatch;
	}
	// 82ECD998: 48000370  b 0x82ecdd08
	pc = 0x82ECDD08; continue 'dispatch;
            }
            0x82ECD99C => {
    //   block [0x82ECD99C..0x82ECD9E0)
	// 82ECD99C: 83380160  lwz r25, 0x160(r24)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(352 as u32) ) } as u64;
	// 82ECD9A0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82ECD9A4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECD9A8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECD9AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECD9B0: 4E800421  bctrl
	ctx.lr = 0x82ECD9B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECD9B4: 8159001C  lwz r10, 0x1c(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECD9B8: 8179002C  lwz r11, 0x2c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECD9BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD9C0: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECD9C4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82ECD9C8: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82ECD9CC: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82ECD9D0: 41820338  beq 0x82ecdd08
	if ctx.cr[0].eq {
	pc = 0x82ECDD08; continue 'dispatch;
	}
	// 82ECD9D4: 5556063E  clrlwi r22, r10, 0x18
	ctx.r[22].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82ECD9D8: 3B6B0010  addi r27, r11, 0x10
	ctx.r[27].s64 = ctx.r[11].s64 + 16;
	// 82ECD9DC: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
            }
            0x82ECD9E0 => {
    //   block [0x82ECD9E0..0x82ECDA04)
	// 82ECD9E0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECD9E4: 7EA9AB78  mr r9, r21
	ctx.r[9].u64 = ctx.r[21].u64;
	// 82ECD9E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECD9EC: 4182002C  beq 0x82ecda18
	if ctx.cr[0].eq {
	pc = 0x82ECDA18; continue 'dispatch;
	}
	// 82ECD9F0: 395BFFF0  addi r10, r27, -0x10
	ctx.r[10].s64 = ctx.r[27].s64 + -16;
	// 82ECD9F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECD9F8: 419A0020  beq cr6, 0x82ecda18
	if ctx.cr[6].eq {
	pc = 0x82ECDA18; continue 'dispatch;
	}
	// 82ECD9FC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ECDA00: 48000008  b 0x82ecda08
	pc = 0x82ECDA08; continue 'dispatch;
            }
            0x82ECDA04 => {
    //   block [0x82ECDA04..0x82ECDA08)
	// 82ECDA04: 81290018  lwz r9, 0x18(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x82ECDA08; continue 'dispatch;
            }
            0x82ECDA08 => {
    //   block [0x82ECDA08..0x82ECDA18)
	// 82ECDA08: 81090018  lwz r8, 0x18(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECDA0C: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECDA10: 409AFFF4  bne cr6, 0x82ecda04
	if !ctx.cr[6].eq {
	pc = 0x82ECDA04; continue 'dispatch;
	}
	// 82ECDA14: 91690018  stw r11, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x82ECDA18; continue 'dispatch;
            }
            0x82ECDA18 => {
    //   block [0x82ECDA18..0x82ECDA6C)
	// 82ECDA18: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECDA1C: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECDA20: 4082009C  bne 0x82ecdabc
	if !ctx.cr[0].eq {
	pc = 0x82ECDABC; continue 'dispatch;
	}
	// 82ECDA24: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECDA28: C1BBFFF4  lfs f13, -0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECDA2C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECDA30: 409A008C  bne cr6, 0x82ecdabc
	if !ctx.cr[6].eq {
	pc = 0x82ECDABC; continue 'dispatch;
	}
	// 82ECDA34: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECDA38: C1BBFFF8  lfs f13, -8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECDA3C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECDA40: 409A007C  bne cr6, 0x82ecdabc
	if !ctx.cr[6].eq {
	pc = 0x82ECDABC; continue 'dispatch;
	}
	// 82ECDA44: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECDA48: C1BBFFFC  lfs f13, -4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECDA4C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECDA50: 409A006C  bne cr6, 0x82ecdabc
	if !ctx.cr[6].eq {
	pc = 0x82ECDABC; continue 'dispatch;
	}
	// 82ECDA54: 815BFFF0  lwz r10, -0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82ECDA58: 38FBFFF0  addi r7, r27, -0x10
	ctx.r[7].s64 = ctx.r[27].s64 + -16;
	// 82ECDA5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ECDA60: 65488000  oris r8, r10, 0x8000
	ctx.r[8].u64 = ctx.r[10].u64 | 2147483648;
	// 82ECDA64: 419A0008  beq cr6, 0x82ecda6c
	if ctx.cr[6].eq {
	pc = 0x82ECDA6C; continue 'dispatch;
	}
	// 82ECDA68: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x82ECDA6C; continue 'dispatch;
            }
            0x82ECDA6C => {
    //   block [0x82ECDA6C..0x82ECDA80)
	// 82ECDA6C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECDA70: 38DBFFF0  addi r6, r27, -0x10
	ctx.r[6].s64 = ctx.r[27].s64 + -16;
	// 82ECDA74: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ECDA78: 409A0008  bne cr6, 0x82ecda80
	if !ctx.cr[6].eq {
	pc = 0x82ECDA80; continue 'dispatch;
	}
	// 82ECDA7C: 910B0014  stw r8, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	pc = 0x82ECDA80; continue 'dispatch;
            }
            0x82ECDA80 => {
    //   block [0x82ECDA80..0x82ECDA94)
	// 82ECDA80: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECDA84: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECDA88: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECDA8C: 41820030  beq 0x82ecdabc
	if ctx.cr[0].eq {
	pc = 0x82ECDABC; continue 'dispatch;
	}
	// 82ECDA90: 48000024  b 0x82ecdab4
	pc = 0x82ECDAB4; continue 'dispatch;
            }
            0x82ECDA94 => {
    //   block [0x82ECDA94..0x82ECDAAC)
	// 82ECDA94: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECDA98: 55460001  rlwinm. r6, r10, 0, 0, 0
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82ECDA9C: 40820010  bne 0x82ecdaac
	if !ctx.cr[0].eq {
	pc = 0x82ECDAAC; continue 'dispatch;
	}
	// 82ECDAA0: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82ECDAA4: 409A0008  bne cr6, 0x82ecdaac
	if !ctx.cr[6].eq {
	pc = 0x82ECDAAC; continue 'dispatch;
	}
	// 82ECDAA8: 910B0014  stw r8, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	pc = 0x82ECDAAC; continue 'dispatch;
            }
            0x82ECDAAC => {
    //   block [0x82ECDAAC..0x82ECDAB4)
	// 82ECDAAC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECDAB0: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82ECDAB4; continue 'dispatch;
            }
            0x82ECDAB4 => {
    //   block [0x82ECDAB4..0x82ECDABC)
	// 82ECDAB4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECDAB8: 409AFFDC  bne cr6, 0x82ecda94
	if !ctx.cr[6].eq {
	pc = 0x82ECDA94; continue 'dispatch;
	}
	pc = 0x82ECDABC; continue 'dispatch;
            }
            0x82ECDABC => {
    //   block [0x82ECDABC..0x82ECDAD0)
	// 82ECDABC: 817BFFF0  lwz r11, -0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82ECDAC0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ECDAC4: 657A8000  oris r26, r11, 0x8000
	ctx.r[26].u64 = ctx.r[11].u64 | 2147483648;
	// 82ECDAC8: 419A0008  beq cr6, 0x82ecdad0
	if ctx.cr[6].eq {
	pc = 0x82ECDAD0; continue 'dispatch;
	}
	// 82ECDACC: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	pc = 0x82ECDAD0; continue 'dispatch;
            }
            0x82ECDAD0 => {
    //   block [0x82ECDAD0..0x82ECDAF0)
	// 82ECDAD0: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82ECDAD4: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 82ECDAD8: 419A010C  beq cr6, 0x82ecdbe4
	if ctx.cr[6].eq {
	pc = 0x82ECDBE4; continue 'dispatch;
	}
	// 82ECDADC: 81780034  lwz r11, 0x34(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECDAE0: 83AB000C  lwz r29, 0xc(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECDAE4: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECDAE8: 41820214  beq 0x82ecdcfc
	if ctx.cr[0].eq {
	pc = 0x82ECDCFC; continue 'dispatch;
	}
	// 82ECDAEC: 3B9BFFF0  addi r28, r27, -0x10
	ctx.r[28].s64 = ctx.r[27].s64 + -16;
	pc = 0x82ECDAF0; continue 'dispatch;
            }
            0x82ECDAF0 => {
    //   block [0x82ECDAF0..0x82ECDB20)
	// 82ECDAF0: 80780034  lwz r3, 0x34(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECDAF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDAF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECDAFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECDB00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECDB04: 4E800421  bctrl
	ctx.lr = 0x82ECDB08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECDB08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECDB0C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECDB10: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ECDB14: 419A000C  beq cr6, 0x82ecdb20
	if ctx.cr[6].eq {
	pc = 0x82ECDB20; continue 'dispatch;
	}
	// 82ECDB18: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82ECDB1C: 409A00B8  bne cr6, 0x82ecdbd4
	if !ctx.cr[6].eq {
	pc = 0x82ECDBD4; continue 'dispatch;
	}
            }
            0x82ECDB20 => {
    //   block [0x82ECDB20..0x82ECDB8C)
	// 82ECDB20: 81780180  lwz r11, 0x180(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(384 as u32) ) } as u64;
	// 82ECDB24: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECDB28: 409A0064  bne cr6, 0x82ecdb8c
	if !ctx.cr[6].eq {
	pc = 0x82ECDB8C; continue 'dispatch;
	}
	// 82ECDB2C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECDB30: 8159001C  lwz r10, 0x1c(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECDB34: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECDB38: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECDB3C: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82ECDB40: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82ECDB44: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ECDB48: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 82ECDB4C: 41990088  bgt cr6, 0x82ecdbd4
	if ctx.cr[6].gt {
	pc = 0x82ECDBD4; continue 'dispatch;
	}
	// 82ECDB50: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECDB54: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECDB58: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82ECDB5C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82ECDB60: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ECDB64: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 82ECDB68: 4199006C  bgt cr6, 0x82ecdbd4
	if ctx.cr[6].gt {
	pc = 0x82ECDBD4; continue 'dispatch;
	}
	// 82ECDB6C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECDB70: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECDB74: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82ECDB78: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82ECDB7C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECDB80: 41980054  blt cr6, 0x82ecdbd4
	if ctx.cr[6].lt {
	pc = 0x82ECDBD4; continue 'dispatch;
	}
	// 82ECDB84: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ECDB88: 4199004C  bgt cr6, 0x82ecdbd4
	if ctx.cr[6].gt {
	pc = 0x82ECDBD4; continue 'dispatch;
	}
	pc = 0x82ECDB8C; continue 'dispatch;
            }
            0x82ECDB8C => {
    //   block [0x82ECDB8C..0x82ECDBAC)
	// 82ECDB8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECDB90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECDB94: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECDB98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECDB9C: 4E800421  bctrl
	ctx.lr = 0x82ECDBA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECDBA0: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECDBA4: 7C6A1B79  or. r10, r3, r3
	ctx.r[10].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECDBA8: 4182002C  beq 0x82ecdbd4
	if ctx.cr[0].eq {
	pc = 0x82ECDBD4; continue 'dispatch;
	}
            }
            0x82ECDBAC => {
    //   block [0x82ECDBAC..0x82ECDBC4)
	// 82ECDBAC: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECDBB0: 55280001  rlwinm. r8, r9, 0, 0, 0
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82ECDBB4: 40820010  bne 0x82ecdbc4
	if !ctx.cr[0].eq {
	pc = 0x82ECDBC4; continue 'dispatch;
	}
	// 82ECDBB8: 7F09E040  cmplw cr6, r9, r28
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82ECDBBC: 409A0008  bne cr6, 0x82ecdbc4
	if !ctx.cr[6].eq {
	pc = 0x82ECDBC4; continue 'dispatch;
	}
	// 82ECDBC0: 934B0010  stw r26, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	pc = 0x82ECDBC4; continue 'dispatch;
            }
            0x82ECDBC4 => {
    //   block [0x82ECDBC4..0x82ECDBD4)
	// 82ECDBC4: 813801F4  lwz r9, 0x1f4(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(500 as u32) ) } as u64;
	// 82ECDBC8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECDBCC: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82ECDBD0: 4082FFDC  bne 0x82ecdbac
	if !ctx.cr[0].eq {
	pc = 0x82ECDBAC; continue 'dispatch;
	}
	pc = 0x82ECDBD4; continue 'dispatch;
            }
            0x82ECDBD4 => {
    //   block [0x82ECDBD4..0x82ECDBE4)
	// 82ECDBD4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82ECDBD8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82ECDBDC: 4198FF14  blt cr6, 0x82ecdaf0
	if ctx.cr[6].lt {
	pc = 0x82ECDAF0; continue 'dispatch;
	}
	// 82ECDBE0: 4800011C  b 0x82ecdcfc
	pc = 0x82ECDCFC; continue 'dispatch;
            }
            0x82ECDBE4 => {
    //   block [0x82ECDBE4..0x82ECDBF8)
	// 82ECDBE4: 81780030  lwz r11, 0x30(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ECDBE8: 83AB000C  lwz r29, 0xc(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECDBEC: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECDBF0: 4182010C  beq 0x82ecdcfc
	if ctx.cr[0].eq {
	pc = 0x82ECDCFC; continue 'dispatch;
	}
	// 82ECDBF4: 3B9BFFF0  addi r28, r27, -0x10
	ctx.r[28].s64 = ctx.r[27].s64 + -16;
	pc = 0x82ECDBF8; continue 'dispatch;
            }
            0x82ECDBF8 => {
    //   block [0x82ECDBF8..0x82ECDC28)
	// 82ECDBF8: 80780030  lwz r3, 0x30(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ECDBFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDC00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECDC04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECDC08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECDC0C: 4E800421  bctrl
	ctx.lr = 0x82ECDC10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECDC10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECDC14: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECDC18: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ECDC1C: 419A000C  beq cr6, 0x82ecdc28
	if ctx.cr[6].eq {
	pc = 0x82ECDC28; continue 'dispatch;
	}
	// 82ECDC20: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82ECDC24: 409A00CC  bne cr6, 0x82ecdcf0
	if !ctx.cr[6].eq {
	pc = 0x82ECDCF0; continue 'dispatch;
	}
            }
            0x82ECDC28 => {
    //   block [0x82ECDC28..0x82ECDCA8)
	// 82ECDC28: 8179001C  lwz r11, 0x1c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECDC2C: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECDC30: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECDC34: 810A001C  lwz r8, 0x1c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECDC38: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82ECDC3C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ECDC40: 409A00B0  bne cr6, 0x82ecdcf0
	if !ctx.cr[6].eq {
	pc = 0x82ECDCF0; continue 'dispatch;
	}
	// 82ECDC44: 81380180  lwz r9, 0x180(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(384 as u32) ) } as u64;
	// 82ECDC48: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ECDC4C: 409A005C  bne cr6, 0x82ecdca8
	if !ctx.cr[6].eq {
	pc = 0x82ECDCA8; continue 'dispatch;
	}
	// 82ECDC50: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECDC54: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECDC58: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82ECDC5C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82ECDC60: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ECDC64: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 82ECDC68: 41990088  bgt cr6, 0x82ecdcf0
	if ctx.cr[6].gt {
	pc = 0x82ECDCF0; continue 'dispatch;
	}
	// 82ECDC6C: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECDC70: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECDC74: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82ECDC78: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82ECDC7C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ECDC80: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 82ECDC84: 4199006C  bgt cr6, 0x82ecdcf0
	if ctx.cr[6].gt {
	pc = 0x82ECDCF0; continue 'dispatch;
	}
	// 82ECDC88: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECDC8C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECDC90: 7D4A0E70  srawi r10, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 82ECDC94: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82ECDC98: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECDC9C: 41980054  blt cr6, 0x82ecdcf0
	if ctx.cr[6].lt {
	pc = 0x82ECDCF0; continue 'dispatch;
	}
	// 82ECDCA0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ECDCA4: 4199004C  bgt cr6, 0x82ecdcf0
	if ctx.cr[6].gt {
	pc = 0x82ECDCF0; continue 'dispatch;
	}
	pc = 0x82ECDCA8; continue 'dispatch;
            }
            0x82ECDCA8 => {
    //   block [0x82ECDCA8..0x82ECDCCC)
	// 82ECDCA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECDCAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECDCB0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECDCB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECDCB8: 4E800421  bctrl
	ctx.lr = 0x82ECDCBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECDCBC: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECDCC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECDCC4: 4182002C  beq 0x82ecdcf0
	if ctx.cr[0].eq {
	pc = 0x82ECDCF0; continue 'dispatch;
	}
	// 82ECDCC8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
            }
            0x82ECDCCC => {
    //   block [0x82ECDCCC..0x82ECDCE4)
	// 82ECDCCC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECDCD0: 55490001  rlwinm. r9, r10, 0, 0, 0
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ECDCD4: 40820010  bne 0x82ecdce4
	if !ctx.cr[0].eq {
	pc = 0x82ECDCE4; continue 'dispatch;
	}
	// 82ECDCD8: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82ECDCDC: 409A0008  bne cr6, 0x82ecdce4
	if !ctx.cr[6].eq {
	pc = 0x82ECDCE4; continue 'dispatch;
	}
	// 82ECDCE0: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x82ECDCE4; continue 'dispatch;
            }
            0x82ECDCE4 => {
    //   block [0x82ECDCE4..0x82ECDCF0)
	// 82ECDCE4: 3463FFFF  addic. r3, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82ECDCE8: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82ECDCEC: 4082FFE0  bne 0x82ecdccc
	if !ctx.cr[0].eq {
	pc = 0x82ECDCCC; continue 'dispatch;
	}
	pc = 0x82ECDCF0; continue 'dispatch;
            }
            0x82ECDCF0 => {
    //   block [0x82ECDCF0..0x82ECDCFC)
	// 82ECDCF0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82ECDCF4: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82ECDCF8: 4198FF00  blt cr6, 0x82ecdbf8
	if ctx.cr[6].lt {
	pc = 0x82ECDBF8; continue 'dispatch;
	}
	pc = 0x82ECDCFC; continue 'dispatch;
            }
            0x82ECDCFC => {
    //   block [0x82ECDCFC..0x82ECDD08)
	// 82ECDCFC: 36F7FFFF  addic. r23, r23, -1
	ctx.xer.ca = (ctx.r[23].u32 > (!(-1 as u32)));
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 82ECDD00: 3B7B0020  addi r27, r27, 0x20
	ctx.r[27].s64 = ctx.r[27].s64 + 32;
	// 82ECDD04: 4082FCDC  bne 0x82ecd9e0
	if !ctx.cr[0].eq {
	pc = 0x82ECD9E0; continue 'dispatch;
	}
	pc = 0x82ECDD08; continue 'dispatch;
            }
            0x82ECDD08 => {
    //   block [0x82ECDD08..0x82ECDD1C)
	// 82ECDD08: 81780160  lwz r11, 0x160(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(352 as u32) ) } as u64;
	// 82ECDD0C: 92AB001C  stw r21, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[21].u32 ) };
	// 82ECDD10: 92B80160  stw r21, 0x160(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(352 as u32), ctx.r[21].u32 ) };
	// 82ECDD14: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82ECDD18: 4BDDB724  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECDD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECDD20 size=172
    let mut pc: u32 = 0x82ECDD20;
    'dispatch: loop {
        match pc {
            0x82ECDD20 => {
    //   block [0x82ECDD20..0x82ECDD44)
	// 82ECDD20: 8144001C  lwz r10, 0x1c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECDD24: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECDD28: 8123017C  lwz r9, 0x17c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECDD2C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82ECDD30: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82ECDD34: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ECDD38: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECDD3C: 40990034  ble cr6, 0x82ecdd70
	if !ctx.cr[6].gt {
	pc = 0x82ECDD70; continue 'dispatch;
	}
	// 82ECDD40: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	pc = 0x82ECDD44; continue 'dispatch;
            }
            0x82ECDD44 => {
    //   block [0x82ECDD44..0x82ECDD5C)
	// 82ECDD44: 812301FC  lwz r9, 0x1fc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECDD48: 7D2A482E  lwzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82ECDD4C: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82ECDD50: 409A000C  bne cr6, 0x82ecdd5c
	if !ctx.cr[6].eq {
	pc = 0x82ECDD5C; continue 'dispatch;
	}
	// 82ECDD54: 8123020C  lwz r9, 0x20c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(524 as u32) ) } as u64;
	// 82ECDD58: 7CC959AE  stbx r6, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u8) };
	pc = 0x82ECDD5C; continue 'dispatch;
            }
            0x82ECDD5C => {
    //   block [0x82ECDD5C..0x82ECDD70)
	// 82ECDD5C: 8123017C  lwz r9, 0x17c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECDD60: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECDD64: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 82ECDD68: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ECDD6C: 4198FFD8  blt cr6, 0x82ecdd44
	if ctx.cr[6].lt {
	pc = 0x82ECDD44; continue 'dispatch;
	}
	pc = 0x82ECDD70; continue 'dispatch;
            }
            0x82ECDD70 => {
    //   block [0x82ECDD70..0x82ECDD84)
	// 82ECDD70: 91040010  stw r8, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82ECDD74: 81630210  lwz r11, 0x210(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ECDD78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECDD7C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 82ECDD80: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	pc = 0x82ECDD84; continue 'dispatch;
            }
            0x82ECDD84 => {
    //   block [0x82ECDD84..0x82ECDDB4)
	// 82ECDD84: 81630164  lwz r11, 0x164(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ECDD88: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECDD8C: 892B0010  lbz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECDD90: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECDD94: 40820020  bne 0x82ecddb4
	if !ctx.cr[0].eq {
	pc = 0x82ECDDB4; continue 'dispatch;
	}
	// 82ECDD98: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECDD9C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECDDA0: 41820014  beq 0x82ecddb4
	if ctx.cr[0].eq {
	pc = 0x82ECDDB4; continue 'dispatch;
	}
	// 82ECDDA4: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECDDA8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82ECDDAC: 409A0008  bne cr6, 0x82ecddb4
	if !ctx.cr[6].eq {
	pc = 0x82ECDDB4; continue 'dispatch;
	}
	// 82ECDDB0: 98CB0038  stb r6, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[6].u8 ) };
	pc = 0x82ECDDB4; continue 'dispatch;
            }
            0x82ECDDB4 => {
    //   block [0x82ECDDB4..0x82ECDDCC)
	// 82ECDDB4: 81630210  lwz r11, 0x210(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ECDDB8: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82ECDDBC: 394A004C  addi r10, r10, 0x4c
	ctx.r[10].s64 = ctx.r[10].s64 + 76;
	// 82ECDDC0: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECDDC4: 4198FFC0  blt cr6, 0x82ecdd84
	if ctx.cr[6].lt {
	pc = 0x82ECDD84; continue 'dispatch;
	}
	// 82ECDDC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECDDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECDDD0 size=20
    let mut pc: u32 = 0x82ECDDD0;
    'dispatch: loop {
        match pc {
            0x82ECDDD0 => {
    //   block [0x82ECDDD0..0x82ECDDE4)
	// 82ECDDD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ECDDD4: 806B02A0  lwz r3, 0x2a0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(672 as u32) ) } as u64;
	// 82ECDDD8: 3943FFFF  addi r10, r3, -1
	ctx.r[10].s64 = ctx.r[3].s64 + -1;
	// 82ECDDDC: 914B02A0  stw r10, 0x2a0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(672 as u32), ctx.r[10].u32 ) };
	// 82ECDDE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECDDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECDDE8 size=1780
    let mut pc: u32 = 0x82ECDDE8;
    'dispatch: loop {
        match pc {
            0x82ECDDE8 => {
    //   block [0x82ECDDE8..0x82ECDEDC)
	// 82ECDDE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECDDEC: 4BDDB621  bl 0x82ca940c
	ctx.lr = 0x82ECDDF0;
	sub_82CA93D0(ctx, base);
	// 82ECDDF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECDDF4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ECDDF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ECDDFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECDE00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECDE04: 3BCBB980  addi r30, r11, -0x4680
	ctx.r[30].s64 = ctx.r[11].s64 + -18048;
	// 82ECDE08: 482EE259  bl 0x831bc060
	ctx.lr = 0x82ECDE0C;
	sub_831BC060(ctx, base);
	// 82ECDE0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDE10: 4BDDED41  bl 0x82cacb50
	ctx.lr = 0x82ECDE14;
	sub_82CACB50(ctx, base);
	// 82ECDE14: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECDE18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECDE1C: 408200D8  bne 0x82ecdef4
	if !ctx.cr[0].eq {
	pc = 0x82ECDEF4; continue 'dispatch;
	}
	// 82ECDE20: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82ECDE24: 3BCB1694  addi r30, r11, 0x1694
	ctx.r[30].s64 = ctx.r[11].s64 + 5780;
	// 82ECDE28: 4BA3FEE1  bl 0x8290dd08
	ctx.lr = 0x82ECDE2C;
	sub_8290DD08(ctx, base);
	// 82ECDE2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDE30: 4BDDED21  bl 0x82cacb50
	ctx.lr = 0x82ECDE34;
	sub_82CACB50(ctx, base);
	// 82ECDE34: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECDE38: 418200AC  beq 0x82ecdee4
	if ctx.cr[0].eq {
	pc = 0x82ECDEE4; continue 'dispatch;
	}
	// 82ECDE3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECDE40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECDE44: 3BCB0F40  addi r30, r11, 0xf40
	ctx.r[30].s64 = ctx.r[11].s64 + 3904;
	// 82ECDE48: 4BA3FEC1  bl 0x8290dd08
	ctx.lr = 0x82ECDE4C;
	sub_8290DD08(ctx, base);
	// 82ECDE4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDE50: 4BDDED01  bl 0x82cacb50
	ctx.lr = 0x82ECDE54;
	sub_82CACB50(ctx, base);
	// 82ECDE54: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECDE58: 4182008C  beq 0x82ecdee4
	if ctx.cr[0].eq {
	pc = 0x82ECDEE4; continue 'dispatch;
	}
	// 82ECDE5C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82ECDE60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECDE64: 3BCBD56C  addi r30, r11, -0x2a94
	ctx.r[30].s64 = ctx.r[11].s64 + -10900;
	// 82ECDE68: 4BA3FEA1  bl 0x8290dd08
	ctx.lr = 0x82ECDE6C;
	sub_8290DD08(ctx, base);
	// 82ECDE6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDE70: 4BDDECE1  bl 0x82cacb50
	ctx.lr = 0x82ECDE74;
	sub_82CACB50(ctx, base);
	// 82ECDE74: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECDE78: 4182006C  beq 0x82ecdee4
	if ctx.cr[0].eq {
	pc = 0x82ECDEE4; continue 'dispatch;
	}
	// 82ECDE7C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82ECDE80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECDE84: 3BCB1698  addi r30, r11, 0x1698
	ctx.r[30].s64 = ctx.r[11].s64 + 5784;
	// 82ECDE88: 4BA3FE81  bl 0x8290dd08
	ctx.lr = 0x82ECDE8C;
	sub_8290DD08(ctx, base);
	// 82ECDE8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDE90: 4BDDECC1  bl 0x82cacb50
	ctx.lr = 0x82ECDE94;
	sub_82CACB50(ctx, base);
	// 82ECDE94: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECDE98: 41820044  beq 0x82ecdedc
	if ctx.cr[0].eq {
	pc = 0x82ECDEDC; continue 'dispatch;
	}
	// 82ECDE9C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82ECDEA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECDEA4: 3BCB1700  addi r30, r11, 0x1700
	ctx.r[30].s64 = ctx.r[11].s64 + 5888;
	// 82ECDEA8: 4BA3FE61  bl 0x8290dd08
	ctx.lr = 0x82ECDEAC;
	sub_8290DD08(ctx, base);
	// 82ECDEAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDEB0: 4BDDECA1  bl 0x82cacb50
	ctx.lr = 0x82ECDEB4;
	sub_82CACB50(ctx, base);
	// 82ECDEB4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECDEB8: 41820024  beq 0x82ecdedc
	if ctx.cr[0].eq {
	pc = 0x82ECDEDC; continue 'dispatch;
	}
	// 82ECDEBC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82ECDEC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECDEC4: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82ECDEC8: 4BA3FE41  bl 0x8290dd08
	ctx.lr = 0x82ECDECC;
	sub_8290DD08(ctx, base);
	// 82ECDECC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDED0: 4BDDEC81  bl 0x82cacb50
	ctx.lr = 0x82ECDED4;
	sub_82CACB50(ctx, base);
	// 82ECDED4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECDED8: 408205F8  bne 0x82ece4d0
	if !ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	pc = 0x82ECDEDC; continue 'dispatch;
            }
            0x82ECDEDC => {
    //   block [0x82ECDEDC..0x82ECDEE4)
	// 82ECDEDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECDEE0: 48000008  b 0x82ecdee8
	pc = 0x82ECDEE8; continue 'dispatch;
            }
            0x82ECDEE4 => {
    //   block [0x82ECDEE4..0x82ECDEE8)
	// 82ECDEE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82ECDEE8; continue 'dispatch;
            }
            0x82ECDEE8 => {
    //   block [0x82ECDEE8..0x82ECDEEC)
	// 82ECDEE8: 997D0039  stb r11, 0x39(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(57 as u32), ctx.r[11].u8 ) };
	pc = 0x82ECDEEC; continue 'dispatch;
            }
            0x82ECDEEC => {
    //   block [0x82ECDEEC..0x82ECDEF4)
	// 82ECDEEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECDEF0: 480005E4  b 0x82ece4d4
	pc = 0x82ECE4D4; continue 'dispatch;
            }
            0x82ECDEF4 => {
    //   block [0x82ECDEF4..0x82ECDFD0)
	// 82ECDEF4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECDEF8: 3BCBB96C  addi r30, r11, -0x4694
	ctx.r[30].s64 = ctx.r[11].s64 + -18068;
	// 82ECDEFC: 482EE165  bl 0x831bc060
	ctx.lr = 0x82ECDF00;
	sub_831BC060(ctx, base);
	// 82ECDF00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDF04: 4BDDEC4D  bl 0x82cacb50
	ctx.lr = 0x82ECDF08;
	sub_82CACB50(ctx, base);
	// 82ECDF08: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECDF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECDF10: 408200D4  bne 0x82ecdfe4
	if !ctx.cr[0].eq {
	pc = 0x82ECDFE4; continue 'dispatch;
	}
	// 82ECDF14: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82ECDF18: 3BCB1694  addi r30, r11, 0x1694
	ctx.r[30].s64 = ctx.r[11].s64 + 5780;
	// 82ECDF1C: 4BA3FDED  bl 0x8290dd08
	ctx.lr = 0x82ECDF20;
	sub_8290DD08(ctx, base);
	// 82ECDF20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDF24: 4BDDEC2D  bl 0x82cacb50
	ctx.lr = 0x82ECDF28;
	sub_82CACB50(ctx, base);
	// 82ECDF28: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECDF2C: 418200AC  beq 0x82ecdfd8
	if ctx.cr[0].eq {
	pc = 0x82ECDFD8; continue 'dispatch;
	}
	// 82ECDF30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECDF34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECDF38: 3BCB0F40  addi r30, r11, 0xf40
	ctx.r[30].s64 = ctx.r[11].s64 + 3904;
	// 82ECDF3C: 4BA3FDCD  bl 0x8290dd08
	ctx.lr = 0x82ECDF40;
	sub_8290DD08(ctx, base);
	// 82ECDF40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDF44: 4BDDEC0D  bl 0x82cacb50
	ctx.lr = 0x82ECDF48;
	sub_82CACB50(ctx, base);
	// 82ECDF48: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECDF4C: 4182008C  beq 0x82ecdfd8
	if ctx.cr[0].eq {
	pc = 0x82ECDFD8; continue 'dispatch;
	}
	// 82ECDF50: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82ECDF54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECDF58: 3BCBD56C  addi r30, r11, -0x2a94
	ctx.r[30].s64 = ctx.r[11].s64 + -10900;
	// 82ECDF5C: 4BA3FDAD  bl 0x8290dd08
	ctx.lr = 0x82ECDF60;
	sub_8290DD08(ctx, base);
	// 82ECDF60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDF64: 4BDDEBED  bl 0x82cacb50
	ctx.lr = 0x82ECDF68;
	sub_82CACB50(ctx, base);
	// 82ECDF68: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECDF6C: 4182006C  beq 0x82ecdfd8
	if ctx.cr[0].eq {
	pc = 0x82ECDFD8; continue 'dispatch;
	}
	// 82ECDF70: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82ECDF74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECDF78: 3BCB1698  addi r30, r11, 0x1698
	ctx.r[30].s64 = ctx.r[11].s64 + 5784;
	// 82ECDF7C: 4BA3FD8D  bl 0x8290dd08
	ctx.lr = 0x82ECDF80;
	sub_8290DD08(ctx, base);
	// 82ECDF80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDF84: 4BDDEBCD  bl 0x82cacb50
	ctx.lr = 0x82ECDF88;
	sub_82CACB50(ctx, base);
	// 82ECDF88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECDF8C: 41820044  beq 0x82ecdfd0
	if ctx.cr[0].eq {
	pc = 0x82ECDFD0; continue 'dispatch;
	}
	// 82ECDF90: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82ECDF94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECDF98: 3BCB1700  addi r30, r11, 0x1700
	ctx.r[30].s64 = ctx.r[11].s64 + 5888;
	// 82ECDF9C: 4BA3FD6D  bl 0x8290dd08
	ctx.lr = 0x82ECDFA0;
	sub_8290DD08(ctx, base);
	// 82ECDFA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDFA4: 4BDDEBAD  bl 0x82cacb50
	ctx.lr = 0x82ECDFA8;
	sub_82CACB50(ctx, base);
	// 82ECDFA8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECDFAC: 41820024  beq 0x82ecdfd0
	if ctx.cr[0].eq {
	pc = 0x82ECDFD0; continue 'dispatch;
	}
	// 82ECDFB0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82ECDFB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECDFB8: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82ECDFBC: 4BA3FD4D  bl 0x8290dd08
	ctx.lr = 0x82ECDFC0;
	sub_8290DD08(ctx, base);
	// 82ECDFC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDFC4: 4BDDEB8D  bl 0x82cacb50
	ctx.lr = 0x82ECDFC8;
	sub_82CACB50(ctx, base);
	// 82ECDFC8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECDFCC: 40820504  bne 0x82ece4d0
	if !ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	pc = 0x82ECDFD0; continue 'dispatch;
            }
            0x82ECDFD0 => {
    //   block [0x82ECDFD0..0x82ECDFD8)
	// 82ECDFD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECDFD4: 48000008  b 0x82ecdfdc
	pc = 0x82ECDFDC; continue 'dispatch;
            }
            0x82ECDFD8 => {
    //   block [0x82ECDFD8..0x82ECDFDC)
	// 82ECDFD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82ECDFDC; continue 'dispatch;
            }
            0x82ECDFDC => {
    //   block [0x82ECDFDC..0x82ECDFE4)
	// 82ECDFDC: 997D0038  stb r11, 0x38(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 82ECDFE0: 4BFFFF0C  b 0x82ecdeec
	pc = 0x82ECDEEC; continue 'dispatch;
            }
            0x82ECDFE4 => {
    //   block [0x82ECDFE4..0x82ECE0C0)
	// 82ECDFE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECDFE8: 3BCBB95C  addi r30, r11, -0x46a4
	ctx.r[30].s64 = ctx.r[11].s64 + -18084;
	// 82ECDFEC: 482EE075  bl 0x831bc060
	ctx.lr = 0x82ECDFF0;
	sub_831BC060(ctx, base);
	// 82ECDFF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECDFF4: 4BDDEB5D  bl 0x82cacb50
	ctx.lr = 0x82ECDFF8;
	sub_82CACB50(ctx, base);
	// 82ECDFF8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECDFFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE000: 408200DC  bne 0x82ece0dc
	if !ctx.cr[0].eq {
	pc = 0x82ECE0DC; continue 'dispatch;
	}
	// 82ECE004: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82ECE008: 3BCB1694  addi r30, r11, 0x1694
	ctx.r[30].s64 = ctx.r[11].s64 + 5780;
	// 82ECE00C: 4BA3FCFD  bl 0x8290dd08
	ctx.lr = 0x82ECE010;
	sub_8290DD08(ctx, base);
	// 82ECE010: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE014: 4BDDEB3D  bl 0x82cacb50
	ctx.lr = 0x82ECE018;
	sub_82CACB50(ctx, base);
	// 82ECE018: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE01C: 418200AC  beq 0x82ece0c8
	if ctx.cr[0].eq {
	pc = 0x82ECE0C8; continue 'dispatch;
	}
	// 82ECE020: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECE024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE028: 3BCB0F40  addi r30, r11, 0xf40
	ctx.r[30].s64 = ctx.r[11].s64 + 3904;
	// 82ECE02C: 4BA3FCDD  bl 0x8290dd08
	ctx.lr = 0x82ECE030;
	sub_8290DD08(ctx, base);
	// 82ECE030: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE034: 4BDDEB1D  bl 0x82cacb50
	ctx.lr = 0x82ECE038;
	sub_82CACB50(ctx, base);
	// 82ECE038: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE03C: 4182008C  beq 0x82ece0c8
	if ctx.cr[0].eq {
	pc = 0x82ECE0C8; continue 'dispatch;
	}
	// 82ECE040: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82ECE044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE048: 3BCBD56C  addi r30, r11, -0x2a94
	ctx.r[30].s64 = ctx.r[11].s64 + -10900;
	// 82ECE04C: 4BA3FCBD  bl 0x8290dd08
	ctx.lr = 0x82ECE050;
	sub_8290DD08(ctx, base);
	// 82ECE050: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE054: 4BDDEAFD  bl 0x82cacb50
	ctx.lr = 0x82ECE058;
	sub_82CACB50(ctx, base);
	// 82ECE058: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE05C: 4182006C  beq 0x82ece0c8
	if ctx.cr[0].eq {
	pc = 0x82ECE0C8; continue 'dispatch;
	}
	// 82ECE060: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82ECE064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE068: 3BCB1698  addi r30, r11, 0x1698
	ctx.r[30].s64 = ctx.r[11].s64 + 5784;
	// 82ECE06C: 4BA3FC9D  bl 0x8290dd08
	ctx.lr = 0x82ECE070;
	sub_8290DD08(ctx, base);
	// 82ECE070: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE074: 4BDDEADD  bl 0x82cacb50
	ctx.lr = 0x82ECE078;
	sub_82CACB50(ctx, base);
	// 82ECE078: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE07C: 41820044  beq 0x82ece0c0
	if ctx.cr[0].eq {
	pc = 0x82ECE0C0; continue 'dispatch;
	}
	// 82ECE080: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82ECE084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE088: 3BCB1700  addi r30, r11, 0x1700
	ctx.r[30].s64 = ctx.r[11].s64 + 5888;
	// 82ECE08C: 4BA3FC7D  bl 0x8290dd08
	ctx.lr = 0x82ECE090;
	sub_8290DD08(ctx, base);
	// 82ECE090: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE094: 4BDDEABD  bl 0x82cacb50
	ctx.lr = 0x82ECE098;
	sub_82CACB50(ctx, base);
	// 82ECE098: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE09C: 41820024  beq 0x82ece0c0
	if ctx.cr[0].eq {
	pc = 0x82ECE0C0; continue 'dispatch;
	}
	// 82ECE0A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82ECE0A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE0A8: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82ECE0AC: 4BA3FC5D  bl 0x8290dd08
	ctx.lr = 0x82ECE0B0;
	sub_8290DD08(ctx, base);
	// 82ECE0B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE0B4: 4BDDEA9D  bl 0x82cacb50
	ctx.lr = 0x82ECE0B8;
	sub_82CACB50(ctx, base);
	// 82ECE0B8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE0BC: 40820414  bne 0x82ece4d0
	if !ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	pc = 0x82ECE0C0; continue 'dispatch;
            }
            0x82ECE0C0 => {
    //   block [0x82ECE0C0..0x82ECE0C8)
	// 82ECE0C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ECE0C4: 48000008  b 0x82ece0cc
	pc = 0x82ECE0CC; continue 'dispatch;
            }
            0x82ECE0C8 => {
    //   block [0x82ECE0C8..0x82ECE0CC)
	// 82ECE0C8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x82ECE0CC; continue 'dispatch;
            }
            0x82ECE0CC => {
    //   block [0x82ECE0CC..0x82ECE0DC)
	// 82ECE0CC: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECE0D0: 616B84F8  ori r11, r11, 0x84f8
	ctx.r[11].u64 = ctx.r[11].u64 | 34040;
	// 82ECE0D4: 7D5D59AE  stbx r10, r29, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u8) };
	// 82ECE0D8: 4BFFFE14  b 0x82ecdeec
	pc = 0x82ECDEEC; continue 'dispatch;
            }
            0x82ECE0DC => {
    //   block [0x82ECE0DC..0x82ECE1B8)
	// 82ECE0DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECE0E0: 3BCBB94C  addi r30, r11, -0x46b4
	ctx.r[30].s64 = ctx.r[11].s64 + -18100;
	// 82ECE0E4: 482EDF7D  bl 0x831bc060
	ctx.lr = 0x82ECE0E8;
	sub_831BC060(ctx, base);
	// 82ECE0E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE0EC: 4BDDEA65  bl 0x82cacb50
	ctx.lr = 0x82ECE0F0;
	sub_82CACB50(ctx, base);
	// 82ECE0F0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE0F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE0F8: 408200D4  bne 0x82ece1cc
	if !ctx.cr[0].eq {
	pc = 0x82ECE1CC; continue 'dispatch;
	}
	// 82ECE0FC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82ECE100: 3BCB1694  addi r30, r11, 0x1694
	ctx.r[30].s64 = ctx.r[11].s64 + 5780;
	// 82ECE104: 4BA3FC05  bl 0x8290dd08
	ctx.lr = 0x82ECE108;
	sub_8290DD08(ctx, base);
	// 82ECE108: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE10C: 4BDDEA45  bl 0x82cacb50
	ctx.lr = 0x82ECE110;
	sub_82CACB50(ctx, base);
	// 82ECE110: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE114: 418200AC  beq 0x82ece1c0
	if ctx.cr[0].eq {
	pc = 0x82ECE1C0; continue 'dispatch;
	}
	// 82ECE118: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECE11C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE120: 3BCB0F40  addi r30, r11, 0xf40
	ctx.r[30].s64 = ctx.r[11].s64 + 3904;
	// 82ECE124: 4BA3FBE5  bl 0x8290dd08
	ctx.lr = 0x82ECE128;
	sub_8290DD08(ctx, base);
	// 82ECE128: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE12C: 4BDDEA25  bl 0x82cacb50
	ctx.lr = 0x82ECE130;
	sub_82CACB50(ctx, base);
	// 82ECE130: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE134: 4182008C  beq 0x82ece1c0
	if ctx.cr[0].eq {
	pc = 0x82ECE1C0; continue 'dispatch;
	}
	// 82ECE138: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82ECE13C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE140: 3BCBD56C  addi r30, r11, -0x2a94
	ctx.r[30].s64 = ctx.r[11].s64 + -10900;
	// 82ECE144: 4BA3FBC5  bl 0x8290dd08
	ctx.lr = 0x82ECE148;
	sub_8290DD08(ctx, base);
	// 82ECE148: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE14C: 4BDDEA05  bl 0x82cacb50
	ctx.lr = 0x82ECE150;
	sub_82CACB50(ctx, base);
	// 82ECE150: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE154: 4182006C  beq 0x82ece1c0
	if ctx.cr[0].eq {
	pc = 0x82ECE1C0; continue 'dispatch;
	}
	// 82ECE158: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82ECE15C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE160: 3BCB1698  addi r30, r11, 0x1698
	ctx.r[30].s64 = ctx.r[11].s64 + 5784;
	// 82ECE164: 4BA3FBA5  bl 0x8290dd08
	ctx.lr = 0x82ECE168;
	sub_8290DD08(ctx, base);
	// 82ECE168: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE16C: 4BDDE9E5  bl 0x82cacb50
	ctx.lr = 0x82ECE170;
	sub_82CACB50(ctx, base);
	// 82ECE170: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE174: 41820044  beq 0x82ece1b8
	if ctx.cr[0].eq {
	pc = 0x82ECE1B8; continue 'dispatch;
	}
	// 82ECE178: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82ECE17C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE180: 3BCB1700  addi r30, r11, 0x1700
	ctx.r[30].s64 = ctx.r[11].s64 + 5888;
	// 82ECE184: 4BA3FB85  bl 0x8290dd08
	ctx.lr = 0x82ECE188;
	sub_8290DD08(ctx, base);
	// 82ECE188: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE18C: 4BDDE9C5  bl 0x82cacb50
	ctx.lr = 0x82ECE190;
	sub_82CACB50(ctx, base);
	// 82ECE190: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE194: 41820024  beq 0x82ece1b8
	if ctx.cr[0].eq {
	pc = 0x82ECE1B8; continue 'dispatch;
	}
	// 82ECE198: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82ECE19C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE1A0: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82ECE1A4: 4BA3FB65  bl 0x8290dd08
	ctx.lr = 0x82ECE1A8;
	sub_8290DD08(ctx, base);
	// 82ECE1A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE1AC: 4BDDE9A5  bl 0x82cacb50
	ctx.lr = 0x82ECE1B0;
	sub_82CACB50(ctx, base);
	// 82ECE1B0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE1B4: 4082031C  bne 0x82ece4d0
	if !ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	pc = 0x82ECE1B8; continue 'dispatch;
            }
            0x82ECE1B8 => {
    //   block [0x82ECE1B8..0x82ECE1C0)
	// 82ECE1B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECE1BC: 48000008  b 0x82ece1c4
	pc = 0x82ECE1C4; continue 'dispatch;
            }
            0x82ECE1C0 => {
    //   block [0x82ECE1C0..0x82ECE1C4)
	// 82ECE1C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82ECE1C4; continue 'dispatch;
            }
            0x82ECE1C4 => {
    //   block [0x82ECE1C4..0x82ECE1CC)
	// 82ECE1C4: 997D0040  stb r11, 0x40(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 82ECE1C8: 4BFFFD24  b 0x82ecdeec
	pc = 0x82ECDEEC; continue 'dispatch;
            }
            0x82ECE1CC => {
    //   block [0x82ECE1CC..0x82ECE20C)
	// 82ECE1CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECE1D0: 3BCBB93C  addi r30, r11, -0x46c4
	ctx.r[30].s64 = ctx.r[11].s64 + -18116;
	// 82ECE1D4: 482EDE8D  bl 0x831bc060
	ctx.lr = 0x82ECE1D8;
	sub_831BC060(ctx, base);
	// 82ECE1D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE1DC: 4BDDE975  bl 0x82cacb50
	ctx.lr = 0x82ECE1E0;
	sub_82CACB50(ctx, base);
	// 82ECE1E0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE1E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE1E8: 40820024  bne 0x82ece20c
	if !ctx.cr[0].eq {
	pc = 0x82ECE20C; continue 'dispatch;
	}
	// 82ECE1EC: 4BA3FB1D  bl 0x8290dd08
	ctx.lr = 0x82ECE1F0;
	sub_8290DD08(ctx, base);
	// 82ECE1F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECE1F4: 418202DC  beq 0x82ece4d0
	if ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	// 82ECE1F8: 4BDDC1C9  bl 0x82caa3c0
	ctx.lr = 0x82ECE1FC;
	sub_82CAA3C0(ctx, base);
	// 82ECE1FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ECE200: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECE204: 917D0044  stw r11, 0x44(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82ECE208: 480002CC  b 0x82ece4d4
	pc = 0x82ECE4D4; continue 'dispatch;
            }
            0x82ECE20C => {
    //   block [0x82ECE20C..0x82ECE240)
	// 82ECE20C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECE210: 3BCBB928  addi r30, r11, -0x46d8
	ctx.r[30].s64 = ctx.r[11].s64 + -18136;
	// 82ECE214: 482EDE4D  bl 0x831bc060
	ctx.lr = 0x82ECE218;
	sub_831BC060(ctx, base);
	// 82ECE218: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE21C: 4BDDE935  bl 0x82cacb50
	ctx.lr = 0x82ECE220;
	sub_82CACB50(ctx, base);
	// 82ECE220: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE228: 40820030  bne 0x82ece258
	if !ctx.cr[0].eq {
	pc = 0x82ECE258; continue 'dispatch;
	}
	// 82ECE22C: 4BA3FADD  bl 0x8290dd08
	ctx.lr = 0x82ECE230;
	sub_8290DD08(ctx, base);
	// 82ECE230: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECE234: 4182029C  beq 0x82ece4d0
	if ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	// 82ECE238: 395D004C  addi r10, r29, 0x4c
	ctx.r[10].s64 = ctx.r[29].s64 + 76;
	// 82ECE23C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	pc = 0x82ECE240; continue 'dispatch;
            }
            0x82ECE240 => {
    //   block [0x82ECE240..0x82ECE258)
	// 82ECE240: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECE244: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECE248: 7D4959AE  stbx r10, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u8) };
	// 82ECE24C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECE250: 4082FFF0  bne 0x82ece240
	if !ctx.cr[0].eq {
	pc = 0x82ECE240; continue 'dispatch;
	}
	// 82ECE254: 4BFFFC98  b 0x82ecdeec
	pc = 0x82ECDEEC; continue 'dispatch;
            }
            0x82ECE258 => {
    //   block [0x82ECE258..0x82ECE298)
	// 82ECE258: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECE25C: 3BCBB918  addi r30, r11, -0x46e8
	ctx.r[30].s64 = ctx.r[11].s64 + -18152;
	// 82ECE260: 482EDE01  bl 0x831bc060
	ctx.lr = 0x82ECE264;
	sub_831BC060(ctx, base);
	// 82ECE264: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE268: 4BDDE8E9  bl 0x82cacb50
	ctx.lr = 0x82ECE26C;
	sub_82CACB50(ctx, base);
	// 82ECE26C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE274: 40820024  bne 0x82ece298
	if !ctx.cr[0].eq {
	pc = 0x82ECE298; continue 'dispatch;
	}
	// 82ECE278: 4BA3FA91  bl 0x8290dd08
	ctx.lr = 0x82ECE27C;
	sub_8290DD08(ctx, base);
	// 82ECE27C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECE280: 41820250  beq 0x82ece4d0
	if ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	// 82ECE284: 4BDDC13D  bl 0x82caa3c0
	ctx.lr = 0x82ECE288;
	sub_82CAA3C0(ctx, base);
	// 82ECE288: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ECE28C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECE290: 917D0210  stw r11, 0x210(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(528 as u32), ctx.r[11].u32 ) };
	// 82ECE294: 48000240  b 0x82ece4d4
	pc = 0x82ECE4D4; continue 'dispatch;
            }
            0x82ECE298 => {
    //   block [0x82ECE298..0x82ECE2CC)
	// 82ECE298: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ECE29C: 3BCBDFC0  addi r30, r11, -0x2040
	ctx.r[30].s64 = ctx.r[11].s64 + -8256;
	// 82ECE2A0: 482EDDC1  bl 0x831bc060
	ctx.lr = 0x82ECE2A4;
	sub_831BC060(ctx, base);
	// 82ECE2A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE2A8: 4BDDE8A9  bl 0x82cacb50
	ctx.lr = 0x82ECE2AC;
	sub_82CACB50(ctx, base);
	// 82ECE2AC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE2B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE2B4: 40820030  bne 0x82ece2e4
	if !ctx.cr[0].eq {
	pc = 0x82ECE2E4; continue 'dispatch;
	}
	// 82ECE2B8: 4BA3FA51  bl 0x8290dd08
	ctx.lr = 0x82ECE2BC;
	sub_8290DD08(ctx, base);
	// 82ECE2BC: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECE2C0: 41820210  beq 0x82ece4d0
	if ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	// 82ECE2C4: 395D0214  addi r10, r29, 0x214
	ctx.r[10].s64 = ctx.r[29].s64 + 532;
	// 82ECE2C8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	pc = 0x82ECE2CC; continue 'dispatch;
            }
            0x82ECE2CC => {
    //   block [0x82ECE2CC..0x82ECE2E4)
	// 82ECE2CC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECE2D0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECE2D4: 7D4959AE  stbx r10, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u8) };
	// 82ECE2D8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECE2DC: 4082FFF0  bne 0x82ece2cc
	if !ctx.cr[0].eq {
	pc = 0x82ECE2CC; continue 'dispatch;
	}
	// 82ECE2E0: 4BFFFC0C  b 0x82ecdeec
	pc = 0x82ECDEEC; continue 'dispatch;
            }
            0x82ECE2E4 => {
    //   block [0x82ECE2E4..0x82ECE32C)
	// 82ECE2E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECE2E8: 3BCBB908  addi r30, r11, -0x46f8
	ctx.r[30].s64 = ctx.r[11].s64 + -18168;
	// 82ECE2EC: 482EDD75  bl 0x831bc060
	ctx.lr = 0x82ECE2F0;
	sub_831BC060(ctx, base);
	// 82ECE2F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE2F4: 4BDDE85D  bl 0x82cacb50
	ctx.lr = 0x82ECE2F8;
	sub_82CACB50(ctx, base);
	// 82ECE2F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE2FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE300: 40820060  bne 0x82ece360
	if !ctx.cr[0].eq {
	pc = 0x82ECE360; continue 'dispatch;
	}
	// 82ECE304: 4BA3FA05  bl 0x8290dd08
	ctx.lr = 0x82ECE308;
	sub_8290DD08(ctx, base);
	// 82ECE308: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ECE30C: 418201C4  beq 0x82ece4d0
	if ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	// 82ECE310: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECE314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE318: 388BB900  addi r4, r11, -0x4700
	ctx.r[4].s64 = ctx.r[11].s64 + -18176;
	// 82ECE31C: 4BDDE835  bl 0x82cacb50
	ctx.lr = 0x82ECE320;
	sub_82CACB50(ctx, base);
	// 82ECE320: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE324: 4082001C  bne 0x82ece340
	if !ctx.cr[0].eq {
	pc = 0x82ECE340; continue 'dispatch;
	}
	// 82ECE328: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x82ECE32C; continue 'dispatch;
            }
            0x82ECE32C => {
    //   block [0x82ECE32C..0x82ECE340)
	// 82ECE32C: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECE330: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECE334: 616B84D8  ori r11, r11, 0x84d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34008;
	// 82ECE338: 7D5D592E  stwx r10, r29, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 82ECE33C: 48000198  b 0x82ece4d4
	pc = 0x82ECE4D4; continue 'dispatch;
            }
            0x82ECE340 => {
    //   block [0x82ECE340..0x82ECE360)
	// 82ECE340: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECE344: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE348: 388BB8F4  addi r4, r11, -0x470c
	ctx.r[4].s64 = ctx.r[11].s64 + -18188;
	// 82ECE34C: 4BDDE805  bl 0x82cacb50
	ctx.lr = 0x82ECE350;
	sub_82CACB50(ctx, base);
	// 82ECE350: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE354: 4082017C  bne 0x82ece4d0
	if !ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	// 82ECE358: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ECE35C: 4BFFFFD0  b 0x82ece32c
	pc = 0x82ECE32C; continue 'dispatch;
            }
            0x82ECE360 => {
    //   block [0x82ECE360..0x82ECE3D4)
	// 82ECE360: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECE364: 3BCBB8E4  addi r30, r11, -0x471c
	ctx.r[30].s64 = ctx.r[11].s64 + -18204;
	// 82ECE368: 482EDCF9  bl 0x831bc060
	ctx.lr = 0x82ECE36C;
	sub_831BC060(ctx, base);
	// 82ECE36C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE370: 4BDDE7E1  bl 0x82cacb50
	ctx.lr = 0x82ECE374;
	sub_82CACB50(ctx, base);
	// 82ECE374: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE37C: 40820058  bne 0x82ece3d4
	if !ctx.cr[0].eq {
	pc = 0x82ECE3D4; continue 'dispatch;
	}
	// 82ECE380: 4BA3F989  bl 0x8290dd08
	ctx.lr = 0x82ECE384;
	sub_8290DD08(ctx, base);
	// 82ECE384: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECE388: 41820148  beq 0x82ece4d0
	if ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	// 82ECE38C: 4BDDC035  bl 0x82caa3c0
	ctx.lr = 0x82ECE390;
	sub_82CAA3C0(ctx, base);
	// 82ECE390: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ECE394: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ECE398: 3D000000  lis r8, 0
	ctx.r[8].s64 = 0;
	// 82ECE39C: 3CE00000  lis r7, 0
	ctx.r[7].s64 = 0;
	// 82ECE3A0: 3CC00000  lis r6, 0
	ctx.r[6].s64 = 0;
	// 82ECE3A4: 614984DC  ori r9, r10, 0x84dc
	ctx.r[9].u64 = ctx.r[10].u64 | 34012;
	// 82ECE3A8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82ECE3AC: 556BD97E  srwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECE3B0: 610884E0  ori r8, r8, 0x84e0
	ctx.r[8].u64 = ctx.r[8].u64 | 34016;
	// 82ECE3B4: 60E784E4  ori r7, r7, 0x84e4
	ctx.r[7].u64 = ctx.r[7].u64 | 34020;
	// 82ECE3B8: 60C684E8  ori r6, r6, 0x84e8
	ctx.r[6].u64 = ctx.r[6].u64 | 34024;
	// 82ECE3BC: 7D5D492E  stwx r10, r29, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82ECE3C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECE3C4: 7D5D412E  stwx r10, r29, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 82ECE3C8: 7D7D392E  stwx r11, r29, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 82ECE3CC: 7D7D312E  stwx r11, r29, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 82ECE3D0: 48000104  b 0x82ece4d4
	pc = 0x82ECE4D4; continue 'dispatch;
            }
            0x82ECE3D4 => {
    //   block [0x82ECE3D4..0x82ECE410)
	// 82ECE3D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECE3D8: 3BCBB8D0  addi r30, r11, -0x4730
	ctx.r[30].s64 = ctx.r[11].s64 + -18224;
	// 82ECE3DC: 482EDC85  bl 0x831bc060
	ctx.lr = 0x82ECE3E0;
	sub_831BC060(ctx, base);
	// 82ECE3E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE3E4: 4BDDE76D  bl 0x82cacb50
	ctx.lr = 0x82ECE3E8;
	sub_82CACB50(ctx, base);
	// 82ECE3E8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE3EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE3F0: 40820020  bne 0x82ece410
	if !ctx.cr[0].eq {
	pc = 0x82ECE410; continue 'dispatch;
	}
	// 82ECE3F4: 4BA3F915  bl 0x8290dd08
	ctx.lr = 0x82ECE3F8;
	sub_8290DD08(ctx, base);
	// 82ECE3F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECE3FC: 418200D4  beq 0x82ece4d0
	if ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	// 82ECE400: 4BDDBFC1  bl 0x82caa3c0
	ctx.lr = 0x82ECE404;
	sub_82CAA3C0(ctx, base);
	// 82ECE404: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ECE408: 614A84DC  ori r10, r10, 0x84dc
	ctx.r[10].u64 = ctx.r[10].u64 | 34012;
	// 82ECE40C: 480000B4  b 0x82ece4c0
	pc = 0x82ECE4C0; continue 'dispatch;
            }
            0x82ECE410 => {
    //   block [0x82ECE410..0x82ECE44C)
	// 82ECE410: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECE414: 3BCBB8BC  addi r30, r11, -0x4744
	ctx.r[30].s64 = ctx.r[11].s64 + -18244;
	// 82ECE418: 482EDC49  bl 0x831bc060
	ctx.lr = 0x82ECE41C;
	sub_831BC060(ctx, base);
	// 82ECE41C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE420: 4BDDE731  bl 0x82cacb50
	ctx.lr = 0x82ECE424;
	sub_82CACB50(ctx, base);
	// 82ECE424: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE42C: 40820020  bne 0x82ece44c
	if !ctx.cr[0].eq {
	pc = 0x82ECE44C; continue 'dispatch;
	}
	// 82ECE430: 4BA3F8D9  bl 0x8290dd08
	ctx.lr = 0x82ECE434;
	sub_8290DD08(ctx, base);
	// 82ECE434: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECE438: 41820098  beq 0x82ece4d0
	if ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	// 82ECE43C: 4BDDBF85  bl 0x82caa3c0
	ctx.lr = 0x82ECE440;
	sub_82CAA3C0(ctx, base);
	// 82ECE440: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ECE444: 614A84E4  ori r10, r10, 0x84e4
	ctx.r[10].u64 = ctx.r[10].u64 | 34020;
	// 82ECE448: 48000078  b 0x82ece4c0
	pc = 0x82ECE4C0; continue 'dispatch;
            }
            0x82ECE44C => {
    //   block [0x82ECE44C..0x82ECE488)
	// 82ECE44C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECE450: 3BCBB8A8  addi r30, r11, -0x4758
	ctx.r[30].s64 = ctx.r[11].s64 + -18264;
	// 82ECE454: 482EDC0D  bl 0x831bc060
	ctx.lr = 0x82ECE458;
	sub_831BC060(ctx, base);
	// 82ECE458: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE45C: 4BDDE6F5  bl 0x82cacb50
	ctx.lr = 0x82ECE460;
	sub_82CACB50(ctx, base);
	// 82ECE460: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE468: 40820020  bne 0x82ece488
	if !ctx.cr[0].eq {
	pc = 0x82ECE488; continue 'dispatch;
	}
	// 82ECE46C: 4BA3F89D  bl 0x8290dd08
	ctx.lr = 0x82ECE470;
	sub_8290DD08(ctx, base);
	// 82ECE470: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECE474: 4182005C  beq 0x82ece4d0
	if ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	// 82ECE478: 4BDDBF49  bl 0x82caa3c0
	ctx.lr = 0x82ECE47C;
	sub_82CAA3C0(ctx, base);
	// 82ECE47C: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ECE480: 614A84E0  ori r10, r10, 0x84e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34016;
	// 82ECE484: 4800003C  b 0x82ece4c0
	pc = 0x82ECE4C0; continue 'dispatch;
            }
            0x82ECE488 => {
    //   block [0x82ECE488..0x82ECE4C0)
	// 82ECE488: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECE48C: 3BCBB894  addi r30, r11, -0x476c
	ctx.r[30].s64 = ctx.r[11].s64 + -18284;
	// 82ECE490: 482EDBD1  bl 0x831bc060
	ctx.lr = 0x82ECE494;
	sub_831BC060(ctx, base);
	// 82ECE494: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECE498: 4BDDE6B9  bl 0x82cacb50
	ctx.lr = 0x82ECE49C;
	sub_82CACB50(ctx, base);
	// 82ECE49C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE4A0: 40820030  bne 0x82ece4d0
	if !ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	// 82ECE4A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECE4A8: 4BA3F861  bl 0x8290dd08
	ctx.lr = 0x82ECE4AC;
	sub_8290DD08(ctx, base);
	// 82ECE4AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECE4B0: 41820020  beq 0x82ece4d0
	if ctx.cr[0].eq {
	pc = 0x82ECE4D0; continue 'dispatch;
	}
	// 82ECE4B4: 4BDDBF0D  bl 0x82caa3c0
	ctx.lr = 0x82ECE4B8;
	sub_82CAA3C0(ctx, base);
	// 82ECE4B8: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ECE4BC: 614A84E8  ori r10, r10, 0x84e8
	ctx.r[10].u64 = ctx.r[10].u64 | 34024;
	pc = 0x82ECE4C0; continue 'dispatch;
            }
            0x82ECE4C0 => {
    //   block [0x82ECE4C0..0x82ECE4D0)
	// 82ECE4C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ECE4C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECE4C8: 7D7D512E  stwx r11, r29, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82ECE4CC: 48000008  b 0x82ece4d4
	pc = 0x82ECE4D4; continue 'dispatch;
            }
            0x82ECE4D0 => {
    //   block [0x82ECE4D0..0x82ECE4D4)
	// 82ECE4D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ECE4D4; continue 'dispatch;
            }
            0x82ECE4D4 => {
    //   block [0x82ECE4D4..0x82ECE4DC)
	// 82ECE4D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECE4D8: 4BDDAF84  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECE4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECE4E0 size=140
    let mut pc: u32 = 0x82ECE4E0;
    'dispatch: loop {
        match pc {
            0x82ECE4E0 => {
    //   block [0x82ECE4E0..0x82ECE518)
	// 82ECE4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECE4E4: 4BDDAF21  bl 0x82ca9404
	ctx.lr = 0x82ECE4E8;
	sub_82CA93D0(ctx, base);
	// 82ECE4E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECE4EC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82ECE4F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECE4F4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82ECE4F8: 419A0058  beq cr6, 0x82ece550
	if ctx.cr[6].eq {
	pc = 0x82ECE550; continue 'dispatch;
	}
	// 82ECE4FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECE500: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82ECE504: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECE508: 40990048  ble cr6, 0x82ece550
	if !ctx.cr[6].gt {
	pc = 0x82ECE550; continue 'dispatch;
	}
	// 82ECE50C: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECE510: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ECE514: 617D8578  ori r29, r11, 0x8578
	ctx.r[29].u64 = ctx.r[11].u64 | 34168;
	pc = 0x82ECE518; continue 'dispatch;
            }
            0x82ECE518 => {
    //   block [0x82ECE518..0x82ECE550)
	// 82ECE518: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECE51C: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ECE520: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82ECE524: 614A84F4  ori r10, r10, 0x84f4
	ctx.r[10].u64 = ctx.r[10].u64 | 34036;
	// 82ECE528: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82ECE52C: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ECE530: 4BDDE621  bl 0x82cacb50
	ctx.lr = 0x82ECE534;
	sub_82CACB50(ctx, base);
	// 82ECE534: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECE538: 41820024  beq 0x82ece55c
	if ctx.cr[0].eq {
	pc = 0x82ECE55C; continue 'dispatch;
	}
	// 82ECE53C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECE540: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ECE544: 7FDEEA14  add r30, r30, r29
	ctx.r[30].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 82ECE548: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECE54C: 4198FFCC  blt cr6, 0x82ece518
	if ctx.cr[6].lt {
	pc = 0x82ECE518; continue 'dispatch;
	}
	pc = 0x82ECE550; continue 'dispatch;
            }
            0x82ECE550 => {
    //   block [0x82ECE550..0x82ECE554)
	// 82ECE550: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ECE554; continue 'dispatch;
            }
            0x82ECE554 => {
    //   block [0x82ECE554..0x82ECE55C)
	// 82ECE554: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECE558: 4BDDAEFC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ECE55C => {
    //   block [0x82ECE55C..0x82ECE56C)
	// 82ECE55C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECE560: 7D7CE9D6  mullw r11, r28, r29
	ctx.r[11].s32 = ((ctx.r[28].s32 as i64 * ctx.r[29].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ECE564: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECE568: 4BFFFFEC  b 0x82ece554
	pc = 0x82ECE554; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECE570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECE570 size=564
    let mut pc: u32 = 0x82ECE570;
    'dispatch: loop {
        match pc {
            0x82ECE570 => {
    //   block [0x82ECE570..0x82ECE674)
	// 82ECE570: 81630178  lwz r11, 0x178(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(376 as u32) ) } as u64;
	// 82ECE574: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82ECE578: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ECE57C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE580: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE584: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82ECE588: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE58C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82ECE590: 91630178  stw r11, 0x178(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 82ECE594: 8163017C  lwz r11, 0x17c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECE598: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82ECE59C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ECE5A0: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE5A4: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE5A8: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82ECE5AC: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE5B0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82ECE5B4: 9163017C  stw r11, 0x17c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(380 as u32), ctx.r[11].u32 ) };
	// 82ECE5B8: 81630180  lwz r11, 0x180(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(384 as u32) ) } as u64;
	// 82ECE5BC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82ECE5C0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ECE5C4: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE5C8: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE5CC: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82ECE5D0: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE5D4: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82ECE5D8: 91630180  stw r11, 0x180(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 82ECE5DC: 81630184  lwz r11, 0x184(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(388 as u32) ) } as u64;
	// 82ECE5E0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82ECE5E4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ECE5E8: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE5EC: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE5F0: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82ECE5F4: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE5F8: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82ECE5FC: 91630184  stw r11, 0x184(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 82ECE600: 81630188  lwz r11, 0x188(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(392 as u32) ) } as u64;
	// 82ECE604: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82ECE608: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ECE60C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE610: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE614: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82ECE618: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE61C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82ECE620: 91630188  stw r11, 0x188(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 82ECE624: 8163018C  lwz r11, 0x18c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(396 as u32) ) } as u64;
	// 82ECE628: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82ECE62C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ECE630: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE634: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE638: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82ECE63C: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE640: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82ECE644: 9163018C  stw r11, 0x18c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 82ECE648: 81630190  lwz r11, 0x190(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(400 as u32) ) } as u64;
	// 82ECE64C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82ECE650: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ECE654: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE658: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE65C: 554AC43E  rlwinm r10, r10, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82ECE660: 5529401E  rlwinm r9, r9, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE664: 39630198  addi r11, r3, 0x198
	ctx.r[11].s64 = ctx.r[3].s64 + 408;
	// 82ECE668: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82ECE66C: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82ECE670: 91430190  stw r10, 0x190(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(400 as u32), ctx.r[10].u32 ) };
	pc = 0x82ECE674; continue 'dispatch;
            }
            0x82ECE674 => {
    //   block [0x82ECE674..0x82ECE7A4)
	// 82ECE674: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82ECE678: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ECE67C: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82ECE680: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE684: 5148801E  rlwimi r8, r10, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE688: 5147843E  rlwimi r7, r10, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE68C: 550A401E  rlwinm r10, r8, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE690: 54E8C43E  rlwinm r8, r7, 0x18, 0x10, 0x1f
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82ECE694: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82ECE698: 914BFFFC  stw r10, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	// 82ECE69C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECE6A0: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82ECE6A4: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE6A8: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE6AC: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE6B0: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82ECE6B4: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE6B8: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82ECE6BC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ECE6C0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECE6C4: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82ECE6C8: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE6CC: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE6D0: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE6D4: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82ECE6D8: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE6DC: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82ECE6E0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ECE6E4: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECE6E8: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82ECE6EC: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE6F0: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE6F4: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE6F8: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82ECE6FC: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE700: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82ECE704: 914B002C  stw r10, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82ECE708: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ECE70C: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82ECE710: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE714: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE718: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE71C: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82ECE720: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE724: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82ECE728: 914B0030  stw r10, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 82ECE72C: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECE730: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82ECE734: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE738: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE73C: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE740: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82ECE744: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE748: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82ECE74C: 914B0034  stw r10, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 82ECE750: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82ECE754: 4082FF20  bne 0x82ece674
	if !ctx.cr[0].eq {
	pc = 0x82ECE674; continue 'dispatch;
	}
	// 82ECE758: 816301F4  lwz r11, 0x1f4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(500 as u32) ) } as u64;
	// 82ECE75C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82ECE760: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ECE764: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE768: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE76C: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82ECE770: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE774: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82ECE778: 916301F4  stw r11, 0x1f4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(500 as u32), ctx.r[11].u32 ) };
	// 82ECE77C: 816301F8  lwz r11, 0x1f8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(504 as u32) ) } as u64;
	// 82ECE780: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82ECE784: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ECE788: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE78C: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE790: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82ECE794: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE798: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82ECE79C: 916301F8  stw r11, 0x1f8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(504 as u32), ctx.r[11].u32 ) };
	// 82ECE7A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECE7A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECE7A8 size=480
    let mut pc: u32 = 0x82ECE7A8;
    'dispatch: loop {
        match pc {
            0x82ECE7A8 => {
    //   block [0x82ECE7A8..0x82ECE7BC)
	// 82ECE7A8: 8163017C  lwz r11, 0x17c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECE7AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ECE7B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECE7B4: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 82ECE7B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82ECE7BC; continue 'dispatch;
            }
            0x82ECE7BC => {
    //   block [0x82ECE7BC..0x82ECE988)
	// 82ECE7BC: 810301FC  lwz r8, 0x1fc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECE7C0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ECE7C4: 7D4B402E  lwzx r10, r11, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82ECE7C8: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE7CC: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82ECE7D0: 5147843E  rlwimi r7, r10, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE7D4: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE7D8: 54EAC43E  rlwinm r10, r7, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82ECE7DC: 54C7401E  rlwinm r7, r6, 8, 0, 0xf
	ctx.r[7].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE7E0: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 82ECE7E4: 7D4B412E  stwx r10, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 82ECE7E8: 814301FC  lwz r10, 0x1fc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECE7EC: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECE7F0: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECE7F4: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE7F8: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82ECE7FC: 5147843E  rlwimi r7, r10, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE800: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE804: 54EAC43E  rlwinm r10, r7, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82ECE808: 54C7401E  rlwinm r7, r6, 8, 0, 0xf
	ctx.r[7].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE80C: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 82ECE810: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ECE814: 814301FC  lwz r10, 0x1fc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECE818: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECE81C: 8148000C  lwz r10, 0xc(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECE820: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE824: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82ECE828: 5147843E  rlwimi r7, r10, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE82C: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE830: 54EAC43E  rlwinm r10, r7, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82ECE834: 54C7401E  rlwinm r7, r6, 8, 0, 0xf
	ctx.r[7].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE838: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 82ECE83C: 9148000C  stw r10, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82ECE840: 814301FC  lwz r10, 0x1fc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECE844: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECE848: 81480014  lwz r10, 0x14(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECE84C: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE850: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82ECE854: 5147843E  rlwimi r7, r10, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE858: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE85C: 54EAC43E  rlwinm r10, r7, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82ECE860: 54C7401E  rlwinm r7, r6, 8, 0, 0xf
	ctx.r[7].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE864: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 82ECE868: 91480014  stw r10, 0x14(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82ECE86C: 814301FC  lwz r10, 0x1fc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECE870: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECE874: 81480008  lwz r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECE878: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE87C: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82ECE880: 5147843E  rlwimi r7, r10, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE884: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE888: 54EAC43E  rlwinm r10, r7, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82ECE88C: 54C7401E  rlwinm r7, r6, 8, 0, 0xf
	ctx.r[7].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE890: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 82ECE894: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ECE898: 814301FC  lwz r10, 0x1fc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECE89C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECE8A0: 81480010  lwz r10, 0x10(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECE8A4: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE8A8: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82ECE8AC: 5147843E  rlwimi r7, r10, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE8B0: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE8B4: 54EAC43E  rlwinm r10, r7, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82ECE8B8: 54C7401E  rlwinm r7, r6, 8, 0, 0xf
	ctx.r[7].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE8BC: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 82ECE8C0: 91480010  stw r10, 0x10(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82ECE8C4: 814301FC  lwz r10, 0x1fc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECE8C8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECE8CC: 81480018  lwz r10, 0x18(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECE8D0: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE8D4: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82ECE8D8: 5147843E  rlwimi r7, r10, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE8DC: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE8E0: 54EAC43E  rlwinm r10, r7, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82ECE8E4: 54C7401E  rlwinm r7, r6, 8, 0, 0xf
	ctx.r[7].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE8E8: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 82ECE8EC: 91480018  stw r10, 0x18(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82ECE8F0: 814301FC  lwz r10, 0x1fc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECE8F4: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECE8F8: 8148001C  lwz r10, 0x1c(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECE8FC: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE900: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82ECE904: 5147843E  rlwimi r7, r10, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE908: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE90C: 54EAC43E  rlwinm r10, r7, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82ECE910: 54C7401E  rlwinm r7, r6, 8, 0, 0xf
	ctx.r[7].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE914: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 82ECE918: 9148001C  stw r10, 0x1c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82ECE91C: 814301FC  lwz r10, 0x1fc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECE920: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECE924: 81480020  lwz r10, 0x20(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECE928: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE92C: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82ECE930: 5147843E  rlwimi r7, r10, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE934: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE938: 54EAC43E  rlwinm r10, r7, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82ECE93C: 54C7401E  rlwinm r7, r6, 8, 0, 0xf
	ctx.r[7].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE940: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 82ECE944: 91480020  stw r10, 0x20(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82ECE948: 814301FC  lwz r10, 0x1fc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECE94C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECE950: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 82ECE954: 81480024  lwz r10, 0x24(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ECE958: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ECE95C: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82ECE960: 5147843E  rlwimi r7, r10, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECE964: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECE968: 54EAC43E  rlwinm r10, r7, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82ECE96C: 54C7401E  rlwinm r7, r6, 8, 0, 0xf
	ctx.r[7].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82ECE970: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 82ECE974: 91480024  stw r10, 0x24(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82ECE978: 8143017C  lwz r10, 0x17c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECE97C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECE980: 4198FE3C  blt cr6, 0x82ece7bc
	if ctx.cr[6].lt {
	pc = 0x82ECE7BC; continue 'dispatch;
	}
	// 82ECE984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECE988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECE988 size=684
    let mut pc: u32 = 0x82ECE988;
    'dispatch: loop {
        match pc {
            0x82ECE988 => {
    //   block [0x82ECE988..0x82ECE9C4)
	// 82ECE988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECE98C: 4BDDAA71  bl 0x82ca93fc
	ctx.lr = 0x82ECE990;
	sub_82CA93D0(ctx, base);
	// 82ECE990: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECE994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECE998: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82ECE99C: 3B3F0174  addi r25, r31, 0x174
	ctx.r[25].s64 = ctx.r[31].s64 + 372;
	// 82ECE9A0: 817F0174  lwz r11, 0x174(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 82ECE9A4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ECE9A8: 409A0284  bne cr6, 0x82ecec2c
	if !ctx.cr[6].eq {
	pc = 0x82ECEC2C; continue 'dispatch;
	}
	// 82ECE9AC: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECE9B0: 616B84F8  ori r11, r11, 0x84f8
	ctx.r[11].u64 = ctx.r[11].u64 | 34040;
	// 82ECE9B4: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECE9B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECE9BC: 41820008  beq 0x82ece9c4
	if ctx.cr[0].eq {
	pc = 0x82ECE9C4; continue 'dispatch;
	}
	// 82ECE9C0: 4BFFFBB1  bl 0x82ece570
	ctx.lr = 0x82ECE9C4;
	sub_82ECE570(ctx, base);
	pc = 0x82ECE9C4; continue 'dispatch;
            }
            0x82ECE9C4 => {
    //   block [0x82ECE9C4..0x82ECEA0C)
	// 82ECE9C4: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECE9C8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ECE9CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECE9D0: 409A0044  bne cr6, 0x82ecea14
	if !ctx.cr[6].eq {
	pc = 0x82ECEA14; continue 'dispatch;
	}
	// 82ECE9D4: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82ECE9D8: 4B747F51  bl 0x82616928
	ctx.lr = 0x82ECE9DC;
	sub_82616928(ctx, base);
	// 82ECE9DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECE9E0: 4182002C  beq 0x82ecea0c
	if ctx.cr[0].eq {
	pc = 0x82ECEA0C; continue 'dispatch;
	}
	// 82ECE9E4: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECE9E8: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ECE9EC: 616B84E8  ori r11, r11, 0x84e8
	ctx.r[11].u64 = ctx.r[11].u64 | 34024;
	// 82ECE9F0: 614A84E0  ori r10, r10, 0x84e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34016;
	// 82ECE9F4: 38DF0178  addi r6, r31, 0x178
	ctx.r[6].s64 = ctx.r[31].s64 + 376;
	// 82ECE9F8: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECE9FC: 7C9F502E  lwzx r4, r31, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ECEA00: 5565502A  slwi r5, r11, 0xa
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(10);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82ECEA04: 4800807D  bl 0x82ed6a80
	ctx.lr = 0x82ECEA08;
	sub_82ED6A80(ctx, base);
	// 82ECEA08: 48000008  b 0x82ecea10
	pc = 0x82ECEA10; continue 'dispatch;
            }
            0x82ECEA0C => {
    //   block [0x82ECEA0C..0x82ECEA10)
	// 82ECEA0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82ECEA10; continue 'dispatch;
            }
            0x82ECEA10 => {
    //   block [0x82ECEA10..0x82ECEA14)
	// 82ECEA10: 907F0034  stw r3, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[3].u32 ) };
	pc = 0x82ECEA14; continue 'dispatch;
            }
            0x82ECEA14 => {
    //   block [0x82ECEA14..0x82ECEA58)
	// 82ECEA14: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ECEA18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECEA1C: 409A0044  bne cr6, 0x82ecea60
	if !ctx.cr[6].eq {
	pc = 0x82ECEA60; continue 'dispatch;
	}
	// 82ECEA20: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82ECEA24: 4B747F05  bl 0x82616928
	ctx.lr = 0x82ECEA28;
	sub_82616928(ctx, base);
	// 82ECEA28: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECEA2C: 4182002C  beq 0x82ecea58
	if ctx.cr[0].eq {
	pc = 0x82ECEA58; continue 'dispatch;
	}
	// 82ECEA30: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECEA34: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ECEA38: 616B84E4  ori r11, r11, 0x84e4
	ctx.r[11].u64 = ctx.r[11].u64 | 34020;
	// 82ECEA3C: 614A84DC  ori r10, r10, 0x84dc
	ctx.r[10].u64 = ctx.r[10].u64 | 34012;
	// 82ECEA40: 38DF0178  addi r6, r31, 0x178
	ctx.r[6].s64 = ctx.r[31].s64 + 376;
	// 82ECEA44: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECEA48: 7C9F502E  lwzx r4, r31, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ECEA4C: 5565502A  slwi r5, r11, 0xa
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(10);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82ECEA50: 48008271  bl 0x82ed6cc0
	ctx.lr = 0x82ECEA54;
	sub_82ED6CC0(ctx, base);
	// 82ECEA54: 48000008  b 0x82ecea5c
	pc = 0x82ECEA5C; continue 'dispatch;
            }
            0x82ECEA58 => {
    //   block [0x82ECEA58..0x82ECEA5C)
	// 82ECEA58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82ECEA5C; continue 'dispatch;
            }
            0x82ECEA5C => {
    //   block [0x82ECEA5C..0x82ECEA60)
	// 82ECEA5C: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	pc = 0x82ECEA60; continue 'dispatch;
            }
            0x82ECEA60 => {
    //   block [0x82ECEA60..0x82ECEA80)
	// 82ECEA60: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82ECEA64: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECEA68: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 82ECEA6C: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82ECEA70: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82ECEA74: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECEA78: 40990008  ble cr6, 0x82ecea80
	if !ctx.cr[6].gt {
	pc = 0x82ECEA80; continue 'dispatch;
	}
	// 82ECEA7C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	pc = 0x82ECEA80; continue 'dispatch;
            }
            0x82ECEA80 => {
    //   block [0x82ECEA80..0x82ECEA9C)
	// 82ECEA80: 4B747EA9  bl 0x82616928
	ctx.lr = 0x82ECEA84;
	sub_82616928(ctx, base);
	// 82ECEA84: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECEA88: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 82ECEA8C: 907F0208  stw r3, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[3].u32 ) };
	// 82ECEA90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECEA94: 40990048  ble cr6, 0x82eceadc
	if !ctx.cr[6].gt {
	pc = 0x82ECEADC; continue 'dispatch;
	}
	// 82ECEA98: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82ECEA9C; continue 'dispatch;
            }
            0x82ECEA9C => {
    //   block [0x82ECEA9C..0x82ECEAB0)
	// 82ECEA9C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ECEAA0: 4B747E89  bl 0x82616928
	ctx.lr = 0x82ECEAA4;
	sub_82616928(ctx, base);
	// 82ECEAA4: 815F0208  lwz r10, 0x208(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82ECEAA8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82ECEAAC: 7C6AE92E  stwx r3, r10, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32), ctx.r[3].u32) };
	pc = 0x82ECEAB0; continue 'dispatch;
            }
            0x82ECEAB0 => {
    //   block [0x82ECEAB0..0x82ECEADC)
	// 82ECEAB0: 815F0208  lwz r10, 0x208(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82ECEAB4: 7D4AE82E  lwzx r10, r10, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82ECEAB8: 7FCA592E  stwx r30, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u32) };
	// 82ECEABC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ECEAC0: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 82ECEAC4: 4198FFEC  blt cr6, 0x82eceab0
	if ctx.cr[6].lt {
	pc = 0x82ECEAB0; continue 'dispatch;
	}
	// 82ECEAC8: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECEACC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82ECEAD0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82ECEAD4: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECEAD8: 4198FFC4  blt cr6, 0x82ecea9c
	if ctx.cr[6].lt {
	pc = 0x82ECEA9C; continue 'dispatch;
	}
	pc = 0x82ECEADC; continue 'dispatch;
            }
            0x82ECEADC => {
    //   block [0x82ECEADC..0x82ECEAF8)
	// 82ECEADC: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECEAE0: 4B747E49  bl 0x82616928
	ctx.lr = 0x82ECEAE4;
	sub_82616928(ctx, base);
	// 82ECEAE4: 815F017C  lwz r10, 0x17c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECEAE8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82ECEAEC: 907F020C  stw r3, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[3].u32 ) };
	// 82ECEAF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ECEAF4: 4099001C  ble cr6, 0x82eceb10
	if !ctx.cr[6].gt {
	pc = 0x82ECEB10; continue 'dispatch;
	}
	pc = 0x82ECEAF8; continue 'dispatch;
            }
            0x82ECEAF8 => {
    //   block [0x82ECEAF8..0x82ECEB10)
	// 82ECEAF8: 815F020C  lwz r10, 0x20c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 82ECEAFC: 7FCA59AE  stbx r30, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u8) };
	// 82ECEB00: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECEB04: 815F017C  lwz r10, 0x17c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECEB08: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECEB0C: 4198FFEC  blt cr6, 0x82eceaf8
	if ctx.cr[6].lt {
	pc = 0x82ECEAF8; continue 'dispatch;
	}
	pc = 0x82ECEB10; continue 'dispatch;
            }
            0x82ECEB10 => {
    //   block [0x82ECEB10..0x82ECEB38)
	// 82ECEB10: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECEB14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECEB18: 409A0114  bne cr6, 0x82ecec2c
	if !ctx.cr[6].eq {
	pc = 0x82ECEC2C; continue 'dispatch;
	}
	// 82ECEB1C: 3D400555  lis r10, 0x555
	ctx.r[10].s64 = 89456640;
	// 82ECEB20: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECEB24: 614A5555  ori r10, r10, 0x5555
	ctx.r[10].u64 = ctx.r[10].u64 | 21845;
	// 82ECEB28: 1C6B0030  mulli r3, r11, 0x30
	ctx.r[3].s32 = ((ctx.r[11].s32 as i64 * 48 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82ECEB2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECEB30: 40990008  ble cr6, 0x82eceb38
	if !ctx.cr[6].gt {
	pc = 0x82ECEB38; continue 'dispatch;
	}
	// 82ECEB34: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	pc = 0x82ECEB38; continue 'dispatch;
            }
            0x82ECEB38 => {
    //   block [0x82ECEB38..0x82ECEB84)
	// 82ECEB38: 4B747DF1  bl 0x82616928
	ctx.lr = 0x82ECEB3C;
	sub_82616928(ctx, base);
	// 82ECEB3C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ECEB40: C1BF0178  lfs f13, 0x178(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECEB44: 917F01FC  stw r11, 0x1fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), ctx.r[11].u32 ) };
	// 82ECEB48: 578A063F  clrlwi. r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ECEB4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ECEB50: C00A0C14  lfs f0, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECEB54: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ECEB58: 4182003C  beq 0x82eceb94
	if ctx.cr[0].eq {
	pc = 0x82ECEB94; continue 'dispatch;
	}
	// 82ECEB5C: 815F017C  lwz r10, 0x17c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECEB60: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 82ECEB64: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82ECEB68: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECEB6C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82ECEB70: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82ECEB74: 38800084  li r4, 0x84
	ctx.r[4].s64 = 132;
	// 82ECEB78: 1CAA0028  mulli r5, r10, 0x28
	ctx.r[5].s32 = ((ctx.r[10].s32 as i64 * 40 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82ECEB7C: 419A0008  beq cr6, 0x82eceb84
	if ctx.cr[6].eq {
	pc = 0x82ECEB84; continue 'dispatch;
	}
	// 82ECEB80: 1CAA0030  mulli r5, r10, 0x30
	ctx.r[5].s32 = ((ctx.r[10].s32 as i64 * 48 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	pc = 0x82ECEB84; continue 'dispatch;
            }
            0x82ECEB84 => {
    //   block [0x82ECEB84..0x82ECEB94)
	// 82ECEB84: 4821F3D5  bl 0x830edf58
	ctx.lr = 0x82ECEB88;
	sub_830EDF58(ctx, base);
	// 82ECEB88: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82ECEB8C: 917F0294  stw r11, 0x294(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), ctx.r[11].u32 ) };
	// 82ECEB90: 4800009C  b 0x82ecec2c
	pc = 0x82ECEC2C; continue 'dispatch;
            }
            0x82ECEB94 => {
    //   block [0x82ECEB94..0x82ECEBB8)
	// 82ECEB94: 409A0074  bne cr6, 0x82ecec08
	if !ctx.cr[6].eq {
	pc = 0x82ECEC08; continue 'dispatch;
	}
	// 82ECEB98: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECEB9C: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82ECEBA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECEBA4: 40990088  ble cr6, 0x82ecec2c
	if !ctx.cr[6].gt {
	pc = 0x82ECEC2C; continue 'dispatch;
	}
	// 82ECEBA8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ECEBAC: 3B6BDAC0  addi r27, r11, -0x2540
	ctx.r[27].s64 = ctx.r[11].s64 + -9536;
	// 82ECEBB0: 3D60BAFF  lis r11, -0x4501
	ctx.r[11].s64 = -1157693440;
	// 82ECEBB4: 617DE000  ori r29, r11, 0xe000
	ctx.r[29].u64 = ctx.r[11].u64 | 57344;
	pc = 0x82ECEBB8; continue 'dispatch;
            }
            0x82ECEBB8 => {
    //   block [0x82ECEBB8..0x82ECEC08)
	// 82ECEBB8: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECEBBC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ECEBC0: 80DF0200  lwz r6, 0x200(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82ECEBC4: 38800028  li r4, 0x28
	ctx.r[4].s64 = 40;
	// 82ECEBC8: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82ECEBCC: 817B0064  lwz r11, 0x64(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECEBD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECEBD4: 4E800421  bctrl
	ctx.lr = 0x82ECEBD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECEBD8: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECEBDC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ECEBE0: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82ECEBE4: 93AB0028  stw r29, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 82ECEBE8: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECEBEC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82ECEBF0: 3BDE0030  addi r30, r30, 0x30
	ctx.r[30].s64 = ctx.r[30].s64 + 48;
	// 82ECEBF4: 93AB002C  stw r29, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[29].u32 ) };
	// 82ECEBF8: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECEBFC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECEC00: 4198FFB8  blt cr6, 0x82ecebb8
	if ctx.cr[6].lt {
	pc = 0x82ECEBB8; continue 'dispatch;
	}
	// 82ECEC04: 48000028  b 0x82ecec2c
	pc = 0x82ECEC2C; continue 'dispatch;
            }
            0x82ECEC08 => {
    //   block [0x82ECEC08..0x82ECEC2C)
	// 82ECEC08: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82ECEC0C: 80DF0200  lwz r6, 0x200(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82ECEC10: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82ECEC14: 80BF017C  lwz r5, 0x17c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECEC18: 394ADAC0  addi r10, r10, -0x2540
	ctx.r[10].s64 = ctx.r[10].s64 + -9536;
	// 82ECEC1C: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 82ECEC20: 816A0064  lwz r11, 0x64(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECEC24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECEC28: 4E800421  bctrl
	ctx.lr = 0x82ECEC2C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ECEC2C => {
    //   block [0x82ECEC2C..0x82ECEC34)
	// 82ECEC2C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ECEC30: 4BDDA81C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECEC38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECEC38 size=600
    let mut pc: u32 = 0x82ECEC38;
    'dispatch: loop {
        match pc {
            0x82ECEC38 => {
    //   block [0x82ECEC38..0x82ECECA0)
	// 82ECEC38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECEC3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECEC40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECEC44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECEC48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECEC4C: 81630174  lwz r11, 0x174(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(372 as u32) ) } as u64;
	// 82ECEC50: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ECEC54: 409A0224  bne cr6, 0x82ecee78
	if !ctx.cr[6].eq {
	pc = 0x82ECEE78; continue 'dispatch;
	}
	// 82ECEC58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECEC5C: C1A30178  lfs f13, 0x178(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECEC60: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECEC64: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ECEC68: 409A0080  bne cr6, 0x82ecece8
	if !ctx.cr[6].eq {
	pc = 0x82ECECE8; continue 'dispatch;
	}
	// 82ECEC6C: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECEC70: 41820078  beq 0x82ecece8
	if ctx.cr[0].eq {
	pc = 0x82ECECE8; continue 'dispatch;
	}
	// 82ECEC74: 8143017C  lwz r10, 0x17c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECEC78: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECEC7C: 812301FC  lwz r9, 0x1fc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECEC80: 1D6A0030  mulli r11, r10, 0x30
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 48 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ECEC84: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82ECEC88: 1D4A0028  mulli r10, r10, 0x28
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 40 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ECEC8C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82ECEC90: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ECEC94: 419A0054  beq cr6, 0x82ecece8
	if ctx.cr[6].eq {
	pc = 0x82ECECE8; continue 'dispatch;
	}
	// 82ECEC98: 3CE0BAFF  lis r7, -0x4501
	ctx.r[7].s64 = -1157693440;
	// 82ECEC9C: 60E6E000  ori r6, r7, 0xe000
	ctx.r[6].u64 = ctx.r[7].u64 | 57344;
	pc = 0x82ECECA0; continue 'dispatch;
            }
            0x82ECECA0 => {
    //   block [0x82ECECA0..0x82ECECC0)
	// 82ECECA0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82ECECA4: 409A001C  bne cr6, 0x82ececc0
	if !ctx.cr[6].eq {
	pc = 0x82ECECC0; continue 'dispatch;
	}
	// 82ECECA8: 38EBFFF8  addi r7, r11, -8
	ctx.r[7].s64 = ctx.r[11].s64 + -8;
	// 82ECECAC: 90CBFFF8  stw r6, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[6].u32 ) };
	// 82ECECB0: 90CBFFFC  stw r6, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[6].u32 ) };
	// 82ECECB4: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 82ECECB8: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82ECECBC: 48000024  b 0x82ecece0
	pc = 0x82ECECE0; continue 'dispatch;
            }
            0x82ECECC0 => {
    //   block [0x82ECECC0..0x82ECECE0)
	// 82ECECC0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82ECECC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82ECECC8: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82ECECCC: 2B080030  cmplwi cr6, r8, 0x30
	ctx.cr[6].compare_u32(ctx.r[8].u32, 48 as u32, &mut ctx.xer);
	// 82ECECD0: 88EA0000  lbz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECECD4: 98EB0000  stb r7, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 82ECECD8: 409A0008  bne cr6, 0x82ecece0
	if !ctx.cr[6].eq {
	pc = 0x82ECECE0; continue 'dispatch;
	}
	// 82ECECDC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x82ECECE0; continue 'dispatch;
            }
            0x82ECECE0 => {
    //   block [0x82ECECE0..0x82ECECE8)
	// 82ECECE0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ECECE4: 409AFFBC  bne cr6, 0x82ececa0
	if !ctx.cr[6].eq {
	pc = 0x82ECECA0; continue 'dispatch;
	}
	pc = 0x82ECECE8; continue 'dispatch;
            }
            0x82ECECE8 => {
    //   block [0x82ECECE8..0x82ECED00)
	// 82ECECE8: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECECEC: 616B84F8  ori r11, r11, 0x84f8
	ctx.r[11].u64 = ctx.r[11].u64 | 34040;
	// 82ECECF0: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECECF4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECECF8: 41820008  beq 0x82eced00
	if ctx.cr[0].eq {
	pc = 0x82ECED00; continue 'dispatch;
	}
	// 82ECECFC: 4BFFFAAD  bl 0x82ece7a8
	ctx.lr = 0x82ECED00;
	sub_82ECE7A8(ctx, base);
	pc = 0x82ECED00; continue 'dispatch;
            }
            0x82ECED00 => {
    //   block [0x82ECED00..0x82ECED24)
	// 82ECED00: 81630180  lwz r11, 0x180(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(384 as u32) ) } as u64;
	// 82ECED04: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ECED08: 409A0168  bne cr6, 0x82ecee70
	if !ctx.cr[6].eq {
	pc = 0x82ECEE70; continue 'dispatch;
	}
	// 82ECED0C: 8163017C  lwz r11, 0x17c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECED10: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82ECED14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECED18: 40990158  ble cr6, 0x82ecee70
	if !ctx.cr[6].gt {
	pc = 0x82ECEE70; continue 'dispatch;
	}
	// 82ECED1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ECED20: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82ECED24; continue 'dispatch;
            }
            0x82ECED24 => {
    //   block [0x82ECED24..0x82ECED68)
	// 82ECED24: 81630208  lwz r11, 0x208(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(520 as u32) ) } as u64;
	// 82ECED28: 7D66582E  lwzx r11, r6, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECED2C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECED30: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECED34: 419A0124  beq cr6, 0x82ecee58
	if ctx.cr[6].eq {
	pc = 0x82ECEE58; continue 'dispatch;
	}
	// 82ECED38: 816301FC  lwz r11, 0x1fc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECED3C: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82ECED40: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECED44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECED48: 409A0110  bne cr6, 0x82ecee58
	if !ctx.cr[6].eq {
	pc = 0x82ECEE58; continue 'dispatch;
	}
	// 82ECED4C: 8143017C  lwz r10, 0x17c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECED50: 39670001  addi r11, r7, 1
	ctx.r[11].s64 = ctx.r[7].s64 + 1;
	// 82ECED54: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82ECED58: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECED5C: 409800FC  bge cr6, 0x82ecee58
	if !ctx.cr[6].lt {
	pc = 0x82ECEE58; continue 'dispatch;
	}
	// 82ECED60: 39060004  addi r8, r6, 4
	ctx.r[8].s64 = ctx.r[6].s64 + 4;
	// 82ECED64: 389F0030  addi r4, r31, 0x30
	ctx.r[4].s64 = ctx.r[31].s64 + 48;
	pc = 0x82ECED68; continue 'dispatch;
            }
            0x82ECED68 => {
    //   block [0x82ECED68..0x82ECEE14)
	// 82ECED68: 814301FC  lwz r10, 0x1fc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECED6C: 7D645214  add r11, r4, r10
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[10].u64;
	// 82ECED70: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECED74: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ECED78: 409A00C8  bne cr6, 0x82ecee40
	if !ctx.cr[6].eq {
	pc = 0x82ECEE40; continue 'dispatch;
	}
	// 82ECED7C: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82ECED80: 419A00C0  beq cr6, 0x82ecee40
	if ctx.cr[6].eq {
	pc = 0x82ECEE40; continue 'dispatch;
	}
	// 82ECED84: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 82ECED88: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECED8C: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECED90: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ECED94: 409A00AC  bne cr6, 0x82ecee40
	if !ctx.cr[6].eq {
	pc = 0x82ECEE40; continue 'dispatch;
	}
	// 82ECED98: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECED9C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECEDA0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECEDA4: 409A009C  bne cr6, 0x82ecee40
	if !ctx.cr[6].eq {
	pc = 0x82ECEE40; continue 'dispatch;
	}
	// 82ECEDA8: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECEDAC: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECEDB0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECEDB4: 409A008C  bne cr6, 0x82ecee40
	if !ctx.cr[6].eq {
	pc = 0x82ECEE40; continue 'dispatch;
	}
	// 82ECEDB8: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECEDBC: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECEDC0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECEDC4: 409A007C  bne cr6, 0x82ecee40
	if !ctx.cr[6].eq {
	pc = 0x82ECEE40; continue 'dispatch;
	}
	// 82ECEDC8: C00A0014  lfs f0, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECEDCC: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECEDD0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECEDD4: 409A006C  bne cr6, 0x82ecee40
	if !ctx.cr[6].eq {
	pc = 0x82ECEE40; continue 'dispatch;
	}
	// 82ECEDD8: C00A0018  lfs f0, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECEDDC: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECEDE0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECEDE4: 409A005C  bne cr6, 0x82ecee40
	if !ctx.cr[6].eq {
	pc = 0x82ECEE40; continue 'dispatch;
	}
	// 82ECEDE8: 81430208  lwz r10, 0x208(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(520 as u32) ) } as u64;
	// 82ECEDEC: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 82ECEDF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECEDF4: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ECEDF8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ECEDFC: 81430208  lwz r10, 0x208(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(520 as u32) ) } as u64;
	// 82ECEE00: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ECEE04: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82ECEE08: 81430208  lwz r10, 0x208(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(520 as u32) ) } as u64;
	// 82ECEE0C: 7D46502E  lwzx r10, r6, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ECEE10: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	pc = 0x82ECEE14; continue 'dispatch;
            }
            0x82ECEE14 => {
    //   block [0x82ECEE14..0x82ECEE34)
	// 82ECEE14: 83C90000  lwz r30, 0(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECEE18: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ECEE1C: 419A0018  beq cr6, 0x82ecee34
	if ctx.cr[6].eq {
	pc = 0x82ECEE34; continue 'dispatch;
	}
	// 82ECEE20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECEE24: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82ECEE28: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82ECEE2C: 4198FFE8  blt cr6, 0x82ecee14
	if ctx.cr[6].lt {
	pc = 0x82ECEE14; continue 'dispatch;
	}
	// 82ECEE30: 48000010  b 0x82ecee40
	pc = 0x82ECEE40; continue 'dispatch;
            }
            0x82ECEE34 => {
    //   block [0x82ECEE34..0x82ECEE40)
	// 82ECEE34: 39250001  addi r9, r5, 1
	ctx.r[9].s64 = ctx.r[5].s64 + 1;
	// 82ECEE38: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ECEE3C: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	pc = 0x82ECEE40; continue 'dispatch;
            }
            0x82ECEE40 => {
    //   block [0x82ECEE40..0x82ECEE58)
	// 82ECEE40: 8163017C  lwz r11, 0x17c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECEE44: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82ECEE48: 38840030  addi r4, r4, 0x30
	ctx.r[4].s64 = ctx.r[4].s64 + 48;
	// 82ECEE4C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82ECEE50: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECEE54: 4198FF14  blt cr6, 0x82eced68
	if ctx.cr[6].lt {
	pc = 0x82ECED68; continue 'dispatch;
	}
	pc = 0x82ECEE58; continue 'dispatch;
            }
            0x82ECEE58 => {
    //   block [0x82ECEE58..0x82ECEE70)
	// 82ECEE58: 8163017C  lwz r11, 0x17c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECEE5C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82ECEE60: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 82ECEE64: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82ECEE68: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECEE6C: 4198FEB8  blt cr6, 0x82eced24
	if ctx.cr[6].lt {
	pc = 0x82ECED24; continue 'dispatch;
	}
	pc = 0x82ECEE70; continue 'dispatch;
            }
            0x82ECEE70 => {
    //   block [0x82ECEE70..0x82ECEE78)
	// 82ECEE70: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82ECEE74: 91630294  stw r11, 0x294(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(660 as u32), ctx.r[11].u32 ) };
	pc = 0x82ECEE78; continue 'dispatch;
            }
            0x82ECEE78 => {
    //   block [0x82ECEE78..0x82ECEE90)
	// 82ECEE78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECEE7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECEE80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECEE84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECEE88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECEE8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECEE90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECEE90 size=60
    let mut pc: u32 = 0x82ECEE90;
    'dispatch: loop {
        match pc {
            0x82ECEE90 => {
    //   block [0x82ECEE90..0x82ECEEA8)
	// 82ECEE90: 81030210  lwz r8, 0x210(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ECEE94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECEE98: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECEE9C: 41820028  beq 0x82eceec4
	if ctx.cr[0].eq {
	pc = 0x82ECEEC4; continue 'dispatch;
	}
	// 82ECEEA0: 81230164  lwz r9, 0x164(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ECEEA4: 39490010  addi r10, r9, 0x10
	ctx.r[10].s64 = ctx.r[9].s64 + 16;
	pc = 0x82ECEEA8; continue 'dispatch;
            }
            0x82ECEEA8 => {
    //   block [0x82ECEEA8..0x82ECEEC4)
	// 82ECEEA8: 88EA0000  lbz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECEEAC: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECEEB0: 4082001C  bne 0x82eceecc
	if !ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ECEECC);
		return;
	}
	// 82ECEEB4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ECEEB8: 394A004C  addi r10, r10, 0x4c
	ctx.r[10].s64 = ctx.r[10].s64 + 76;
	// 82ECEEBC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82ECEEC0: 4198FFE8  blt cr6, 0x82eceea8
	if ctx.cr[6].lt {
	pc = 0x82ECEEA8; continue 'dispatch;
	}
	pc = 0x82ECEEC4; continue 'dispatch;
            }
            0x82ECEEC4 => {
    //   block [0x82ECEEC4..0x82ECEECC)
	// 82ECEEC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECEEC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECEED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECEED8 size=544
    let mut pc: u32 = 0x82ECEED8;
    'dispatch: loop {
        match pc {
            0x82ECEED8 => {
    //   block [0x82ECEED8..0x82ECF0F8)
	// 82ECEED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECEEDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECEEE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECEEE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECEEE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECEEEC: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECEEF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECEEF4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ECEEF8: 616B84FC  ori r11, r11, 0x84fc
	ctx.r[11].u64 = ctx.r[11].u64 | 34044;
	// 82ECEEFC: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ECEF00: 39200080  li r9, 0x80
	ctx.r[9].s64 = 128;
	// 82ECEF04: 614A84F4  ori r10, r10, 0x84f4
	ctx.r[10].u64 = ctx.r[10].u64 | 34036;
	// 82ECEF08: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 82ECEF0C: 93DF0164  stw r30, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[30].u32 ) };
	// 82ECEF10: 7FDF592E  stwx r30, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u32) };
	// 82ECEF14: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82ECEF18: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ECEF1C: 93DF01FC  stw r30, 0x1fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), ctx.r[30].u32 ) };
	// 82ECEF20: 387F0214  addi r3, r31, 0x214
	ctx.r[3].s64 = ctx.r[31].s64 + 532;
	// 82ECEF24: 93DF0200  stw r30, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[30].u32 ) };
	// 82ECEF28: 7FDF512E  stwx r30, r31, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 82ECEF2C: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ECEF30: 9BDF0204  stb r30, 0x204(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), ctx.r[30].u8 ) };
	// 82ECEF34: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82ECEF38: 614A84F8  ori r10, r10, 0x84f8
	ctx.r[10].u64 = ctx.r[10].u64 | 34040;
	// 82ECEF3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ECEF40: 93DF0208  stw r30, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[30].u32 ) };
	// 82ECEF44: 93DF020C  stw r30, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[30].u32 ) };
	// 82ECEF48: 9BDF0040  stb r30, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 82ECEF4C: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82ECEF50: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82ECEF54: 9BDF004C  stb r30, 0x4c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u8 ) };
	// 82ECEF58: 9BDF0038  stb r30, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 82ECEF5C: 9BDF0039  stb r30, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[30].u8 ) };
	// 82ECEF60: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82ECEF64: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82ECEF68: 93DF014C  stw r30, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[30].u32 ) };
	// 82ECEF6C: 93DF0150  stw r30, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[30].u32 ) };
	// 82ECEF70: 93DF0158  stw r30, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[30].u32 ) };
	// 82ECEF74: 93DF0154  stw r30, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[30].u32 ) };
	// 82ECEF78: 93DF015C  stw r30, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[30].u32 ) };
	// 82ECEF7C: 93DF0160  stw r30, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[30].u32 ) };
	// 82ECEF80: 997F0168  stb r11, 0x168(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u8 ) };
	// 82ECEF84: 93DF016C  stw r30, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[30].u32 ) };
	// 82ECEF88: 7FDF51AE  stbx r30, r31, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u8) };
	// 82ECEF8C: 93DF0294  stw r30, 0x294(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), ctx.r[30].u32 ) };
	// 82ECEF90: 913F0210  stw r9, 0x210(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), ctx.r[9].u32 ) };
	// 82ECEF94: 4BDDAA1D  bl 0x82ca99b0
	ctx.lr = 0x82ECEF98;
	sub_82CA99B0(ctx, base);
	// 82ECEF98: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ECEF9C: 9BDF0298  stb r30, 0x298(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[30].u8 ) };
	// 82ECEFA0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82ECEFA4: 614A82A4  ori r10, r10, 0x82a4
	ctx.r[10].u64 = ctx.r[10].u64 | 33444;
	// 82ECEFA8: 3CA00000  lis r5, 0
	ctx.r[5].s64 = 0;
	// 82ECEFAC: 3C808888  lis r4, -0x7778
	ctx.r[4].s64 = -2004353024;
	// 82ECEFB0: 60A58000  ori r5, r5, 0x8000
	ctx.r[5].u64 = ctx.r[5].u64 | 32768;
	// 82ECEFB4: 60848888  ori r4, r4, 0x8888
	ctx.r[4].u64 = ctx.r[4].u64 | 34952;
	// 82ECEFB8: 917F02A0  stw r11, 0x2a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(672 as u32), ctx.r[11].u32 ) };
	// 82ECEFBC: 387F02A4  addi r3, r31, 0x2a4
	ctx.r[3].s64 = ctx.r[31].s64 + 676;
	// 82ECEFC0: 7FDF512E  stwx r30, r31, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 82ECEFC4: 4BDDA9ED  bl 0x82ca99b0
	ctx.lr = 0x82ECEFC8;
	sub_82CA99B0(ctx, base);
	// 82ECEFC8: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECEFCC: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 82ECEFD0: 616A82A8  ori r10, r11, 0x82a8
	ctx.r[10].u64 = ctx.r[11].u64 | 33448;
	// 82ECEFD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECEFD8: 612982B0  ori r9, r9, 0x82b0
	ctx.r[9].u64 = ctx.r[9].u64 | 33456;
	// 82ECEFDC: 3D000000  lis r8, 0
	ctx.r[8].s64 = 0;
	// 82ECEFE0: 3CE00000  lis r7, 0
	ctx.r[7].s64 = 0;
	// 82ECEFE4: 3CC00000  lis r6, 0
	ctx.r[6].s64 = 0;
	// 82ECEFE8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECEFEC: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECEFF0: 7C1F552E  stfsx f0, r31, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82ECEFF4: 7FDF492E  stwx r30, r31, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	// 82ECEFF8: 616B82AC  ori r11, r11, 0x82ac
	ctx.r[11].u64 = ctx.r[11].u64 | 33452;
	// 82ECEFFC: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 82ECF000: 610882BC  ori r8, r8, 0x82bc
	ctx.r[8].u64 = ctx.r[8].u64 | 33468;
	// 82ECF004: 60E782C0  ori r7, r7, 0x82c0
	ctx.r[7].u64 = ctx.r[7].u64 | 33472;
	// 82ECF008: 612982C4  ori r9, r9, 0x82c4
	ctx.r[9].u64 = ctx.r[9].u64 | 33476;
	// 82ECF00C: 7FDF59AE  stbx r30, r31, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u8) };
	// 82ECF010: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECF014: 60C684CC  ori r6, r6, 0x84cc
	ctx.r[6].u64 = ctx.r[6].u64 | 33996;
	// 82ECF018: 616A82B4  ori r10, r11, 0x82b4
	ctx.r[10].u64 = ctx.r[11].u64 | 33460;
	// 82ECF01C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECF020: 7FDF512E  stwx r30, r31, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 82ECF024: C1AB0AA4  lfs f13, 0xaa4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2724 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECF028: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECF02C: 616B82B8  ori r11, r11, 0x82b8
	ctx.r[11].u64 = ctx.r[11].u64 | 33464;
	// 82ECF030: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ECF034: 7DBF452E  stfsx f13, r31, r8
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 82ECF038: 7C1F5D2E  stfsx f0, r31, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82ECF03C: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECF040: 614884D8  ori r8, r10, 0x84d8
	ctx.r[8].u64 = ctx.r[10].u64 | 34008;
	// 82ECF044: 7C1F3D2E  stfsx f0, r31, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 82ECF048: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ECF04C: 7C1F4D2E  stfsx f0, r31, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82ECF050: 3CE00000  lis r7, 0
	ctx.r[7].s64 = 0;
	// 82ECF054: 7FDF312E  stwx r30, r31, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[6].u32), ctx.r[30].u32) };
	// 82ECF058: 616B82C8  ori r11, r11, 0x82c8
	ctx.r[11].u64 = ctx.r[11].u64 | 33480;
	// 82ECF05C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82ECF060: 614984DC  ori r9, r10, 0x84dc
	ctx.r[9].u64 = ctx.r[10].u64 | 34012;
	// 82ECF064: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82ECF068: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82ECF06C: 7FDF412E  stwx r30, r31, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32), ctx.r[30].u32) };
	// 82ECF070: 60E784E0  ori r7, r7, 0x84e0
	ctx.r[7].u64 = ctx.r[7].u64 | 34016;
	// 82ECF074: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82ECF078: 3D000000  lis r8, 0
	ctx.r[8].s64 = 0;
	// 82ECF07C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82ECF080: 7C1F5D2E  stfsx f0, r31, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82ECF084: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECF088: 610884E8  ori r8, r8, 0x84e8
	ctx.r[8].u64 = ctx.r[8].u64 | 34024;
	// 82ECF08C: 9BDF0010  stb r30, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 82ECF090: 7D5F492E  stwx r10, r31, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82ECF094: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 82ECF098: 7D5F392E  stwx r10, r31, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[7].u32), ctx.r[10].u32) };
	// 82ECF09C: 3CE00000  lis r7, 0
	ctx.r[7].s64 = 0;
	// 82ECF0A0: 616684E4  ori r6, r11, 0x84e4
	ctx.r[6].u64 = ctx.r[11].u64 | 34020;
	// 82ECF0A4: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82ECF0A8: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 82ECF0AC: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82ECF0B0: 612984EC  ori r9, r9, 0x84ec
	ctx.r[9].u64 = ctx.r[9].u64 | 34028;
	// 82ECF0B4: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82ECF0B8: 60E784F0  ori r7, r7, 0x84f0
	ctx.r[7].u64 = ctx.r[7].u64 | 34032;
	// 82ECF0BC: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82ECF0C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECF0C4: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82ECF0C8: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82ECF0CC: 7D7F312E  stwx r11, r31, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 82ECF0D0: 7D7F412E  stwx r11, r31, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	// 82ECF0D4: 7FDF492E  stwx r30, r31, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	// 82ECF0D8: 7FDF392E  stwx r30, r31, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[7].u32), ctx.r[30].u32) };
	// 82ECF0DC: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82ECF0E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECF0E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECF0E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECF0EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECF0F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECF0F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECF0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECF0F8 size=732
    let mut pc: u32 = 0x82ECF0F8;
    'dispatch: loop {
        match pc {
            0x82ECF0F8 => {
    //   block [0x82ECF0F8..0x82ECF134)
	// 82ECF0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECF0FC: 4BDDA305  bl 0x82ca9400
	ctx.lr = 0x82ECF100;
	sub_82CA93D0(ctx, base);
	// 82ECF100: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECF104: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECF108: 48006961  bl 0x82ed5a68
	ctx.lr = 0x82ECF10C;
	sub_82ED5A68(ctx, base);
	// 82ECF10C: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ECF110: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ECF114: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF118: 4182001C  beq 0x82ecf134
	if ctx.cr[0].eq {
	pc = 0x82ECF134; continue 'dispatch;
	}
	// 82ECF11C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF120: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ECF124: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF128: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF12C: 4E800421  bctrl
	ctx.lr = 0x82ECF130;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF130: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
            }
            0x82ECF134 => {
    //   block [0x82ECF134..0x82ECF158)
	// 82ECF134: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECF138: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF13C: 4182001C  beq 0x82ecf158
	if ctx.cr[0].eq {
	pc = 0x82ECF158; continue 'dispatch;
	}
	// 82ECF140: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF144: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ECF148: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF14C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF150: 4E800421  bctrl
	ctx.lr = 0x82ECF154;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF154: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
            }
            0x82ECF158 => {
    //   block [0x82ECF158..0x82ECF178)
	// 82ECF158: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ECF15C: 3F608330  lis r27, -0x7cd0
	ctx.r[27].s64 = -2094006272;
	// 82ECF160: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF164: 41820014  beq 0x82ecf178
	if ctx.cr[0].eq {
	pc = 0x82ECF178; continue 'dispatch;
	}
	// 82ECF168: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECF16C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF170: 4E800421  bctrl
	ctx.lr = 0x82ECF174;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF174: 93DF0164  stw r30, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[30].u32 ) };
            }
            0x82ECF178 => {
    //   block [0x82ECF178..0x82ECF19C)
	// 82ECF178: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ECF17C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF180: 4182001C  beq 0x82ecf19c
	if ctx.cr[0].eq {
	pc = 0x82ECF19C; continue 'dispatch;
	}
	// 82ECF184: 897F0204  lbz r11, 0x204(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(516 as u32) ) } as u64;
	// 82ECF188: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF18C: 40820010  bne 0x82ecf19c
	if !ctx.cr[0].eq {
	pc = 0x82ECF19C; continue 'dispatch;
	}
	// 82ECF190: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECF194: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF198: 4E800421  bctrl
	ctx.lr = 0x82ECF19C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ECF19C => {
    //   block [0x82ECF19C..0x82ECF1C0)
	// 82ECF19C: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82ECF1A0: 93DF01FC  stw r30, 0x1fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), ctx.r[30].u32 ) };
	// 82ECF1A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECF1A8: 419A0068  beq cr6, 0x82ecf210
	if ctx.cr[6].eq {
	pc = 0x82ECF210; continue 'dispatch;
	}
	// 82ECF1AC: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECF1B0: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82ECF1B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECF1B8: 40990044  ble cr6, 0x82ecf1fc
	if !ctx.cr[6].gt {
	pc = 0x82ECF1FC; continue 'dispatch;
	}
	// 82ECF1BC: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82ECF1C0; continue 'dispatch;
            }
            0x82ECF1C0 => {
    //   block [0x82ECF1C0..0x82ECF1E8)
	// 82ECF1C0: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82ECF1C4: 7D5D582E  lwzx r10, r29, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECF1C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ECF1CC: 419A001C  beq cr6, 0x82ecf1e8
	if ctx.cr[6].eq {
	pc = 0x82ECF1E8; continue 'dispatch;
	}
	// 82ECF1D0: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECF1D4: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82ECF1D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF1DC: 4E800421  bctrl
	ctx.lr = 0x82ECF1E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF1E0: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82ECF1E4: 7FDD592E  stwx r30, r29, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u32) };
            }
            0x82ECF1E8 => {
    //   block [0x82ECF1E8..0x82ECF1FC)
	// 82ECF1E8: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ECF1EC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ECF1F0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82ECF1F4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECF1F8: 4198FFC8  blt cr6, 0x82ecf1c0
	if ctx.cr[6].lt {
	pc = 0x82ECF1C0; continue 'dispatch;
	}
	pc = 0x82ECF1FC; continue 'dispatch;
            }
            0x82ECF1FC => {
    //   block [0x82ECF1FC..0x82ECF210)
	// 82ECF1FC: 807F0208  lwz r3, 0x208(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82ECF200: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECF204: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF208: 4E800421  bctrl
	ctx.lr = 0x82ECF20C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF20C: 93DF0208  stw r30, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[30].u32 ) };
            }
            0x82ECF210 => {
    //   block [0x82ECF210..0x82ECF22C)
	// 82ECF210: 807F020C  lwz r3, 0x20c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 82ECF214: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF218: 41820014  beq 0x82ecf22c
	if ctx.cr[0].eq {
	pc = 0x82ECF22C; continue 'dispatch;
	}
	// 82ECF21C: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECF220: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF224: 4E800421  bctrl
	ctx.lr = 0x82ECF228;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF228: 93DF020C  stw r30, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[30].u32 ) };
            }
            0x82ECF22C => {
    //   block [0x82ECF22C..0x82ECF250)
	// 82ECF22C: 3FBF0001  addis r29, r31, 1
	ctx.r[29].s64 = ctx.r[31].s64 + 65536;
	// 82ECF230: 3BBD84F4  addi r29, r29, -0x7b0c
	ctx.r[29].s64 = ctx.r[29].s64 + -31500;
	// 82ECF234: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF238: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF23C: 41820014  beq 0x82ecf250
	if ctx.cr[0].eq {
	pc = 0x82ECF250; continue 'dispatch;
	}
	// 82ECF240: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECF244: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF248: 4E800421  bctrl
	ctx.lr = 0x82ECF24C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF24C: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
            }
            0x82ECF250 => {
    //   block [0x82ECF250..0x82ECF284)
	// 82ECF250: 897F0040  lbz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ECF254: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF258: 418200E8  beq 0x82ecf340
	if ctx.cr[0].eq {
	pc = 0x82ECF340; continue 'dispatch;
	}
	// 82ECF25C: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ECF260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECF264: 419A00B8  beq cr6, 0x82ecf31c
	if ctx.cr[6].eq {
	pc = 0x82ECF31C; continue 'dispatch;
	}
	// 82ECF268: 3F5F0001  addis r26, r31, 1
	ctx.r[26].s64 = ctx.r[31].s64 + 65536;
	// 82ECF26C: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82ECF270: 3B5A84E0  addi r26, r26, -0x7b20
	ctx.r[26].s64 = ctx.r[26].s64 + -31520;
	// 82ECF274: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF278: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECF27C: 4099008C  ble cr6, 0x82ecf308
	if !ctx.cr[6].gt {
	pc = 0x82ECF308; continue 'dispatch;
	}
	// 82ECF280: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82ECF284; continue 'dispatch;
            }
            0x82ECF284 => {
    //   block [0x82ECF284..0x82ECF2C0)
	// 82ECF284: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ECF288: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECF28C: 93CB0028  stw r30, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82ECF290: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ECF294: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECF298: 93CB002C  stw r30, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82ECF29C: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ECF2A0: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECF2A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF2A8: 41820018  beq 0x82ecf2c0
	if ctx.cr[0].eq {
	pc = 0x82ECF2C0; continue 'dispatch;
	}
	// 82ECF2AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF2B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ECF2B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF2B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF2BC: 4E800421  bctrl
	ctx.lr = 0x82ECF2C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ECF2C0 => {
    //   block [0x82ECF2C0..0x82ECF2F4)
	// 82ECF2C0: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ECF2C4: 7FDD592E  stwx r30, r29, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u32) };
	// 82ECF2C8: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ECF2CC: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82ECF2D0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECF2D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF2D8: 4182001C  beq 0x82ecf2f4
	if ctx.cr[0].eq {
	pc = 0x82ECF2F4; continue 'dispatch;
	}
	// 82ECF2DC: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECF2E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF2E4: 4E800421  bctrl
	ctx.lr = 0x82ECF2E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF2E8: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ECF2EC: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82ECF2F0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
            }
            0x82ECF2F4 => {
    //   block [0x82ECF2F4..0x82ECF308)
	// 82ECF2F4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF2F8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ECF2FC: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82ECF300: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECF304: 4198FF80  blt cr6, 0x82ecf284
	if ctx.cr[6].lt {
	pc = 0x82ECF284; continue 'dispatch;
	}
	pc = 0x82ECF308; continue 'dispatch;
            }
            0x82ECF308 => {
    //   block [0x82ECF308..0x82ECF31C)
	// 82ECF308: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ECF30C: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECF310: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF314: 4E800421  bctrl
	ctx.lr = 0x82ECF318;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF318: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
            }
            0x82ECF31C => {
    //   block [0x82ECF31C..0x82ECF340)
	// 82ECF31C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ECF320: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF324: 4182001C  beq 0x82ecf340
	if ctx.cr[0].eq {
	pc = 0x82ECF340; continue 'dispatch;
	}
	// 82ECF328: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF32C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ECF330: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF334: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF338: 4E800421  bctrl
	ctx.lr = 0x82ECF33C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF33C: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
            }
            0x82ECF340 => {
    //   block [0x82ECF340..0x82ECF37C)
	// 82ECF340: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECF344: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECF348: 419A0034  beq cr6, 0x82ecf37c
	if ctx.cr[6].eq {
	pc = 0x82ECF37C; continue 'dispatch;
	}
	// 82ECF34C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82ECF350: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82ECF354: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECF358: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECF35C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF360: 4E800421  bctrl
	ctx.lr = 0x82ECF364;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF364: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82ECF368: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECF36C: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECF370: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF374: 4E800421  bctrl
	ctx.lr = 0x82ECF378;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF378: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
            }
            0x82ECF37C => {
    //   block [0x82ECF37C..0x82ECF3B8)
	// 82ECF37C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECF380: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECF384: 419A0034  beq cr6, 0x82ecf3b8
	if ctx.cr[6].eq {
	pc = 0x82ECF3B8; continue 'dispatch;
	}
	// 82ECF388: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82ECF38C: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82ECF390: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECF394: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECF398: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF39C: 4E800421  bctrl
	ctx.lr = 0x82ECF3A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF3A0: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82ECF3A4: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECF3A8: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECF3AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF3B0: 4E800421  bctrl
	ctx.lr = 0x82ECF3B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF3B4: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
            }
            0x82ECF3B8 => {
    //   block [0x82ECF3B8..0x82ECF3CC)
	// 82ECF3B8: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82ECF3BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF3C0: 4182000C  beq 0x82ecf3cc
	if ctx.cr[0].eq {
	pc = 0x82ECF3CC; continue 'dispatch;
	}
	// 82ECF3C4: 4821EBAD  bl 0x830edf70
	ctx.lr = 0x82ECF3C8;
	sub_830EDF70(ctx, base);
	// 82ECF3C8: 93DF0170  stw r30, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[30].u32 ) };
	pc = 0x82ECF3CC; continue 'dispatch;
            }
            0x82ECF3CC => {
    //   block [0x82ECF3CC..0x82ECF3D4)
	// 82ECF3CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ECF3D0: 4BDDA080  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECF3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECF3D8 size=120
    let mut pc: u32 = 0x82ECF3D8;
    'dispatch: loop {
        match pc {
            0x82ECF3D8 => {
    //   block [0x82ECF3D8..0x82ECF3F8)
	// 82ECF3D8: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECF3DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ECF3E0: 994B001C  stb r10, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 82ECF3E4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECF3E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECF3EC: 409A000C  bne cr6, 0x82ecf3f8
	if !ctx.cr[6].eq {
	pc = 0x82ECF3F8; continue 'dispatch;
	}
	// 82ECF3F0: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECF3F4: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82ECF3F8; continue 'dispatch;
            }
            0x82ECF3F8 => {
    //   block [0x82ECF3F8..0x82ECF40C)
	// 82ECF3F8: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECF3FC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECF400: 409A000C  bne cr6, 0x82ecf40c
	if !ctx.cr[6].eq {
	pc = 0x82ECF40C; continue 'dispatch;
	}
	// 82ECF404: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECF408: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x82ECF40C; continue 'dispatch;
            }
            0x82ECF40C => {
    //   block [0x82ECF40C..0x82ECF420)
	// 82ECF40C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECF410: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF414: 4182000C  beq 0x82ecf420
	if ctx.cr[0].eq {
	pc = 0x82ECF420; continue 'dispatch;
	}
	// 82ECF418: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECF41C: 912A0018  stw r9, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	pc = 0x82ECF420; continue 'dispatch;
            }
            0x82ECF420 => {
    //   block [0x82ECF420..0x82ECF434)
	// 82ECF420: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECF424: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF428: 4182000C  beq 0x82ecf434
	if ctx.cr[0].eq {
	pc = 0x82ECF434; continue 'dispatch;
	}
	// 82ECF42C: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECF430: 912A0014  stw r9, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	pc = 0x82ECF434; continue 'dispatch;
            }
            0x82ECF434 => {
    //   block [0x82ECF434..0x82ECF450)
	// 82ECF434: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECF438: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82ECF43C: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECF440: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82ECF444: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 82ECF448: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82ECF44C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECF450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECF450 size=144
    let mut pc: u32 = 0x82ECF450;
    'dispatch: loop {
        match pc {
            0x82ECF450 => {
    //   block [0x82ECF450..0x82ECF484)
	// 82ECF450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECF454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECF458: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECF45C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECF460: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF464: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82ECF468: 83E4002C  lwz r31, 0x2c(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECF46C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECF470: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF474: 4E800421  bctrl
	ctx.lr = 0x82ECF478;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF478: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF47C: 41820050  beq 0x82ecf4cc
	if ctx.cr[0].eq {
	pc = 0x82ECF4CC; continue 'dispatch;
	}
	// 82ECF480: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
            }
            0x82ECF484 => {
    //   block [0x82ECF484..0x82ECF49C)
	// 82ECF484: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECF488: 552B0001  rlwinm. r11, r9, 0, 0, 0
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECF48C: 40820034  bne 0x82ecf4c0
	if !ctx.cr[0].eq {
	pc = 0x82ECF4C0; continue 'dispatch;
	}
	// 82ECF490: 81690014  lwz r11, 0x14(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECF494: 91490010  stw r10, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82ECF498: 48000020  b 0x82ecf4b8
	pc = 0x82ECF4B8; continue 'dispatch;
            }
            0x82ECF49C => {
    //   block [0x82ECF49C..0x82ECF4B4)
	// 82ECF49C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ECF4A0: 419A0020  beq cr6, 0x82ecf4c0
	if ctx.cr[6].eq {
	pc = 0x82ECF4C0; continue 'dispatch;
	}
	// 82ECF4A4: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECF4A8: 55080001  rlwinm. r8, r8, 0, 0, 0
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82ECF4AC: 41820008  beq 0x82ecf4b4
	if ctx.cr[0].eq {
	pc = 0x82ECF4B4; continue 'dispatch;
	}
	// 82ECF4B0: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82ECF4B4; continue 'dispatch;
            }
            0x82ECF4B4 => {
    //   block [0x82ECF4B4..0x82ECF4B8)
	// 82ECF4B4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	pc = 0x82ECF4B8; continue 'dispatch;
            }
            0x82ECF4B8 => {
    //   block [0x82ECF4B8..0x82ECF4C0)
	// 82ECF4B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF4BC: 4082FFE0  bne 0x82ecf49c
	if !ctx.cr[0].eq {
	pc = 0x82ECF49C; continue 'dispatch;
	}
	pc = 0x82ECF4C0; continue 'dispatch;
            }
            0x82ECF4C0 => {
    //   block [0x82ECF4C0..0x82ECF4CC)
	// 82ECF4C0: 3463FFFF  addic. r3, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82ECF4C4: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82ECF4C8: 4082FFBC  bne 0x82ecf484
	if !ctx.cr[0].eq {
	pc = 0x82ECF484; continue 'dispatch;
	}
	pc = 0x82ECF4CC; continue 'dispatch;
            }
            0x82ECF4CC => {
    //   block [0x82ECF4CC..0x82ECF4E0)
	// 82ECF4CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ECF4D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECF4D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECF4D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECF4DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECF4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECF4E0 size=144
    let mut pc: u32 = 0x82ECF4E0;
    'dispatch: loop {
        match pc {
            0x82ECF4E0 => {
    //   block [0x82ECF4E0..0x82ECF514)
	// 82ECF4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECF4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECF4E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECF4EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECF4F0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF4F4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82ECF4F8: 83E4002C  lwz r31, 0x2c(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECF4FC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECF500: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF504: 4E800421  bctrl
	ctx.lr = 0x82ECF508;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF508: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF50C: 41820050  beq 0x82ecf55c
	if ctx.cr[0].eq {
	pc = 0x82ECF55C; continue 'dispatch;
	}
	// 82ECF510: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
            }
            0x82ECF514 => {
    //   block [0x82ECF514..0x82ECF52C)
	// 82ECF514: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECF518: 552B0001  rlwinm. r11, r9, 0, 0, 0
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECF51C: 40820034  bne 0x82ecf550
	if !ctx.cr[0].eq {
	pc = 0x82ECF550; continue 'dispatch;
	}
	// 82ECF520: 81690018  lwz r11, 0x18(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECF524: 91490010  stw r10, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82ECF528: 48000020  b 0x82ecf548
	pc = 0x82ECF548; continue 'dispatch;
            }
            0x82ECF52C => {
    //   block [0x82ECF52C..0x82ECF544)
	// 82ECF52C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ECF530: 419A0020  beq cr6, 0x82ecf550
	if ctx.cr[6].eq {
	pc = 0x82ECF550; continue 'dispatch;
	}
	// 82ECF534: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECF538: 55080001  rlwinm. r8, r8, 0, 0, 0
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82ECF53C: 41820008  beq 0x82ecf544
	if ctx.cr[0].eq {
	pc = 0x82ECF544; continue 'dispatch;
	}
	// 82ECF540: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82ECF544; continue 'dispatch;
            }
            0x82ECF544 => {
    //   block [0x82ECF544..0x82ECF548)
	// 82ECF544: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x82ECF548; continue 'dispatch;
            }
            0x82ECF548 => {
    //   block [0x82ECF548..0x82ECF550)
	// 82ECF548: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF54C: 4082FFE0  bne 0x82ecf52c
	if !ctx.cr[0].eq {
	pc = 0x82ECF52C; continue 'dispatch;
	}
	pc = 0x82ECF550; continue 'dispatch;
            }
            0x82ECF550 => {
    //   block [0x82ECF550..0x82ECF55C)
	// 82ECF550: 3463FFFF  addic. r3, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82ECF554: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82ECF558: 4082FFBC  bne 0x82ecf514
	if !ctx.cr[0].eq {
	pc = 0x82ECF514; continue 'dispatch;
	}
	pc = 0x82ECF55C; continue 'dispatch;
            }
            0x82ECF55C => {
    //   block [0x82ECF55C..0x82ECF570)
	// 82ECF55C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ECF560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECF564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECF568: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECF56C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECF570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECF570 size=108
    let mut pc: u32 = 0x82ECF570;
    'dispatch: loop {
        match pc {
            0x82ECF570 => {
    //   block [0x82ECF570..0x82ECF5A8)
	// 82ECF570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECF574: 4BDD9E99  bl 0x82ca940c
	ctx.lr = 0x82ECF578;
	sub_82CA93D0(ctx, base);
	// 82ECF578: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECF57C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF580: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82ECF584: 83E4002C  lwz r31, 0x2c(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECF588: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82ECF58C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECF590: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF594: 4E800421  bctrl
	ctx.lr = 0x82ECF598;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF598: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF59C: 41820038  beq 0x82ecf5d4
	if ctx.cr[0].eq {
	pc = 0x82ECF5D4; continue 'dispatch;
	}
	// 82ECF5A0: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82ECF5A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
            }
            0x82ECF5A8 => {
    //   block [0x82ECF5A8..0x82ECF5C8)
	// 82ECF5A8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF5AC: 548B0001  rlwinm. r11, r4, 0, 0, 0
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECF5B0: 41820018  beq 0x82ecf5c8
	if ctx.cr[0].eq {
	pc = 0x82ECF5C8; continue 'dispatch;
	}
	// 82ECF5B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECF5B8: 4BFFD219  bl 0x82ecc7d0
	ctx.lr = 0x82ECF5BC;
	sub_82ECC7D0(ctx, base);
	// 82ECF5BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF5C0: 41820008  beq 0x82ecf5c8
	if ctx.cr[0].eq {
	pc = 0x82ECF5C8; continue 'dispatch;
	}
	// 82ECF5C4: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82ECF5C8; continue 'dispatch;
            }
            0x82ECF5C8 => {
    //   block [0x82ECF5C8..0x82ECF5D4)
	// 82ECF5C8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ECF5CC: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82ECF5D0: 4082FFD8  bne 0x82ecf5a8
	if !ctx.cr[0].eq {
	pc = 0x82ECF5A8; continue 'dispatch;
	}
	pc = 0x82ECF5D4; continue 'dispatch;
            }
            0x82ECF5D4 => {
    //   block [0x82ECF5D4..0x82ECF5DC)
	// 82ECF5D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECF5D8: 4BDD9E84  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECF5E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECF5E0 size=108
    let mut pc: u32 = 0x82ECF5E0;
    'dispatch: loop {
        match pc {
            0x82ECF5E0 => {
    //   block [0x82ECF5E0..0x82ECF618)
	// 82ECF5E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECF5E4: 4BDD9E29  bl 0x82ca940c
	ctx.lr = 0x82ECF5E8;
	sub_82CA93D0(ctx, base);
	// 82ECF5E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECF5EC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF5F0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82ECF5F4: 83E4002C  lwz r31, 0x2c(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ECF5F8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82ECF5FC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECF600: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF604: 4E800421  bctrl
	ctx.lr = 0x82ECF608;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF608: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF60C: 41820038  beq 0x82ecf644
	if ctx.cr[0].eq {
	pc = 0x82ECF644; continue 'dispatch;
	}
	// 82ECF610: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82ECF614: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
            }
            0x82ECF618 => {
    //   block [0x82ECF618..0x82ECF638)
	// 82ECF618: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF61C: 548B0001  rlwinm. r11, r4, 0, 0, 0
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECF620: 41820018  beq 0x82ecf638
	if ctx.cr[0].eq {
	pc = 0x82ECF638; continue 'dispatch;
	}
	// 82ECF624: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECF628: 4BFFD231  bl 0x82ecc858
	ctx.lr = 0x82ECF62C;
	sub_82ECC858(ctx, base);
	// 82ECF62C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF630: 41820008  beq 0x82ecf638
	if ctx.cr[0].eq {
	pc = 0x82ECF638; continue 'dispatch;
	}
	// 82ECF634: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82ECF638; continue 'dispatch;
            }
            0x82ECF638 => {
    //   block [0x82ECF638..0x82ECF644)
	// 82ECF638: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ECF63C: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82ECF640: 4082FFD8  bne 0x82ecf618
	if !ctx.cr[0].eq {
	pc = 0x82ECF618; continue 'dispatch;
	}
	pc = 0x82ECF644; continue 'dispatch;
            }
            0x82ECF644 => {
    //   block [0x82ECF644..0x82ECF64C)
	// 82ECF644: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECF648: 4BDD9E14  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECF650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECF650 size=924
    let mut pc: u32 = 0x82ECF650;
    'dispatch: loop {
        match pc {
            0x82ECF650 => {
    //   block [0x82ECF650..0x82ECF680)
	// 82ECF650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECF654: 4BDD9DA1  bl 0x82ca93f4
	ctx.lr = 0x82ECF658;
	sub_82CA93D0(ctx, base);
	// 82ECF658: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82ECF65C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECF660: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82ECF664: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82ECF668: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82ECF66C: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82ECF670: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ECF674: 8359000C  lwz r26, 0xc(r25)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECF678: 281A0000  cmplwi r26, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF67C: 41820034  beq 0x82ecf6b0
	if ctx.cr[0].eq {
	pc = 0x82ECF6B0; continue 'dispatch;
	}
	pc = 0x82ECF680; continue 'dispatch;
            }
            0x82ECF680 => {
    //   block [0x82ECF680..0x82ECF6B0)
	// 82ECF680: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF684: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECF688: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82ECF68C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECF690: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF694: 4E800421  bctrl
	ctx.lr = 0x82ECF698;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF698: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECF69C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECF6A0: 419A0340  beq cr6, 0x82ecf9e0
	if ctx.cr[6].eq {
	pc = 0x82ECF9E0; continue 'dispatch;
	}
	// 82ECF6A4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82ECF6A8: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82ECF6AC: 4198FFD4  blt cr6, 0x82ecf680
	if ctx.cr[6].lt {
	pc = 0x82ECF680; continue 'dispatch;
	}
            }
            0x82ECF6B0 => {
    //   block [0x82ECF6B0..0x82ECF6D8)
	// 82ECF6B0: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECF6B4: 616B84D8  ori r11, r11, 0x84d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34008;
	// 82ECF6B8: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECF6BC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ECF6C0: 419A031C  beq cr6, 0x82ecf9dc
	if ctx.cr[6].eq {
	pc = 0x82ECF9DC; continue 'dispatch;
	}
	// 82ECF6C4: 2F180001  cmpwi cr6, r24, 1
	ctx.cr[6].compare_i32(ctx.r[24].s32, 1, &mut ctx.xer);
	// 82ECF6C8: 419A0314  beq cr6, 0x82ecf9dc
	if ctx.cr[6].eq {
	pc = 0x82ECF9DC; continue 'dispatch;
	}
	// 82ECF6CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ECF6D0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ECF6D4: 419A0034  beq cr6, 0x82ecf708
	if ctx.cr[6].eq {
	pc = 0x82ECF708; continue 'dispatch;
	}
	pc = 0x82ECF6D8; continue 'dispatch;
            }
            0x82ECF6D8 => {
    //   block [0x82ECF6D8..0x82ECF708)
	// 82ECF6D8: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF6DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECF6E0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82ECF6E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECF6E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF6EC: 4E800421  bctrl
	ctx.lr = 0x82ECF6F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF6F0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECF6F4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ECF6F8: 419A02E8  beq cr6, 0x82ecf9e0
	if ctx.cr[6].eq {
	pc = 0x82ECF9E0; continue 'dispatch;
	}
	// 82ECF6FC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82ECF700: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82ECF704: 4198FFD4  blt cr6, 0x82ecf6d8
	if ctx.cr[6].lt {
	pc = 0x82ECF6D8; continue 'dispatch;
	}
            }
            0x82ECF708 => {
    //   block [0x82ECF708..0x82ECF714)
	// 82ECF708: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ECF70C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ECF710: 419A00AC  beq cr6, 0x82ecf7bc
	if ctx.cr[6].eq {
	pc = 0x82ECF7BC; continue 'dispatch;
	}
	pc = 0x82ECF714; continue 'dispatch;
            }
            0x82ECF714 => {
    //   block [0x82ECF714..0x82ECF760)
	// 82ECF714: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF718: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECF71C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82ECF720: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECF724: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF728: 4E800421  bctrl
	ctx.lr = 0x82ECF72C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF72C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ECF730: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECF734: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82ECF738: 409A0078  bne cr6, 0x82ecf7b0
	if !ctx.cr[6].eq {
	pc = 0x82ECF7B0; continue 'dispatch;
	}
	// 82ECF73C: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECF740: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ECF744: 409A006C  bne cr6, 0x82ecf7b0
	if !ctx.cr[6].eq {
	pc = 0x82ECF7B0; continue 'dispatch;
	}
	// 82ECF748: 811B0210  lwz r8, 0x210(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ECF74C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ECF750: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ECF754: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF758: 41820050  beq 0x82ecf7a8
	if ctx.cr[0].eq {
	pc = 0x82ECF7A8; continue 'dispatch;
	}
	// 82ECF75C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
            }
            0x82ECF760 => {
    //   block [0x82ECF760..0x82ECF798)
	// 82ECF760: 54EB063F  clrlwi. r11, r7, 0x18
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECF764: 41820044  beq 0x82ecf7a8
	if ctx.cr[0].eq {
	pc = 0x82ECF7A8; continue 'dispatch;
	}
	// 82ECF768: 817B0164  lwz r11, 0x164(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ECF76C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECF770: 88CB0010  lbz r6, 0x10(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECF774: 28060000  cmplwi r6, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF778: 40820020  bne 0x82ecf798
	if !ctx.cr[0].eq {
	pc = 0x82ECF798; continue 'dispatch;
	}
	// 82ECF77C: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECF780: 7F062040  cmplw cr6, r6, r4
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82ECF784: 409A0014  bne cr6, 0x82ecf798
	if !ctx.cr[6].eq {
	pc = 0x82ECF798; continue 'dispatch;
	}
	// 82ECF788: 896B0039  lbz r11, 0x39(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 82ECF78C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF790: 40820008  bne 0x82ecf798
	if !ctx.cr[0].eq {
	pc = 0x82ECF798; continue 'dispatch;
	}
	// 82ECF794: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82ECF798; continue 'dispatch;
            }
            0x82ECF798 => {
    //   block [0x82ECF798..0x82ECF7A8)
	// 82ECF798: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ECF79C: 394A004C  addi r10, r10, 0x4c
	ctx.r[10].s64 = ctx.r[10].s64 + 76;
	// 82ECF7A0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82ECF7A4: 4198FFBC  blt cr6, 0x82ecf760
	if ctx.cr[6].lt {
	pc = 0x82ECF760; continue 'dispatch;
	}
	pc = 0x82ECF7A8; continue 'dispatch;
            }
            0x82ECF7A8 => {
    //   block [0x82ECF7A8..0x82ECF7B0)
	// 82ECF7A8: 54EB063F  clrlwi. r11, r7, 0x18
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECF7AC: 40820120  bne 0x82ecf8cc
	if !ctx.cr[0].eq {
	pc = 0x82ECF8CC; continue 'dispatch;
	}
	pc = 0x82ECF7B0; continue 'dispatch;
            }
            0x82ECF7B0 => {
    //   block [0x82ECF7B0..0x82ECF7BC)
	// 82ECF7B0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82ECF7B4: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82ECF7B8: 4198FF5C  blt cr6, 0x82ecf714
	if ctx.cr[6].lt {
	pc = 0x82ECF714; continue 'dispatch;
	}
	pc = 0x82ECF7BC; continue 'dispatch;
            }
            0x82ECF7BC => {
    //   block [0x82ECF7BC..0x82ECF7D4)
	// 82ECF7BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECF7C0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82ECF7C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ECF7C8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ECF7CC: C3EB0C18  lfs f31, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ECF7D0: 419A0108  beq cr6, 0x82ecf8d8
	if ctx.cr[6].eq {
	pc = 0x82ECF8D8; continue 'dispatch;
	}
	pc = 0x82ECF7D4; continue 'dispatch;
            }
            0x82ECF7D4 => {
    //   block [0x82ECF7D4..0x82ECF828)
	// 82ECF7D4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF7D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ECF7DC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82ECF7E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECF7E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF7E8: 4E800421  bctrl
	ctx.lr = 0x82ECF7EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF7EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECF7F0: 897E0008  lbz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECF7F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ECF7F8: 419A00BC  beq cr6, 0x82ecf8b4
	if ctx.cr[6].eq {
	pc = 0x82ECF8B4; continue 'dispatch;
	}
	// 82ECF7FC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECF800: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82ECF804: 419A00B0  beq cr6, 0x82ecf8b4
	if ctx.cr[6].eq {
	pc = 0x82ECF8B4; continue 'dispatch;
	}
	// 82ECF808: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECF80C: 7F0BC000  cmpw cr6, r11, r24
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[24].s32, &mut ctx.xer);
	// 82ECF810: 409800A4  bge cr6, 0x82ecf8b4
	if !ctx.cr[6].lt {
	pc = 0x82ECF8B4; continue 'dispatch;
	}
	// 82ECF814: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82ECF818: 419A0010  beq cr6, 0x82ecf828
	if ctx.cr[6].eq {
	pc = 0x82ECF828; continue 'dispatch;
	}
	// 82ECF81C: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECF820: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82ECF824: 41990090  bgt cr6, 0x82ecf8b4
	if ctx.cr[6].gt {
	pc = 0x82ECF8B4; continue 'dispatch;
	}
            }
            0x82ECF828 => {
    //   block [0x82ECF828..0x82ECF848)
	// 82ECF828: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82ECF82C: 4B39118D  bl 0x822609b8
	ctx.lr = 0x82ECF830;
	sub_822609B8(ctx, base);
	// 82ECF830: 813B0210  lwz r9, 0x210(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ECF834: C183004C  lfs f12, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ECF838: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECF83C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF840: 41820068  beq 0x82ecf8a8
	if ctx.cr[0].eq {
	pc = 0x82ECF8A8; continue 'dispatch;
	}
	// 82ECF844: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82ECF848; continue 'dispatch;
            }
            0x82ECF848 => {
    //   block [0x82ECF848..0x82ECF898)
	// 82ECF848: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECF84C: 4182005C  beq 0x82ecf8a8
	if ctx.cr[0].eq {
	pc = 0x82ECF8A8; continue 'dispatch;
	}
	// 82ECF850: 817B0164  lwz r11, 0x164(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ECF854: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECF858: 88EB0010  lbz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECF85C: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF860: 40820038  bne 0x82ecf898
	if !ctx.cr[0].eq {
	pc = 0x82ECF898; continue 'dispatch;
	}
	// 82ECF864: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECF868: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82ECF86C: 409A002C  bne cr6, 0x82ecf898
	if !ctx.cr[6].eq {
	pc = 0x82ECF898; continue 'dispatch;
	}
	// 82ECF870: C1AB0028  lfs f13, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECF874: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 82ECF878: 40990020  ble cr6, 0x82ecf898
	if !ctx.cr[6].gt {
	pc = 0x82ECF898; continue 'dispatch;
	}
	// 82ECF87C: C00B002C  lfs f0, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECF880: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ECF884: 40990014  ble cr6, 0x82ecf898
	if !ctx.cr[6].gt {
	pc = 0x82ECF898; continue 'dispatch;
	}
	// 82ECF888: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ECF88C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECF890: 41990008  bgt cr6, 0x82ecf898
	if ctx.cr[6].gt {
	pc = 0x82ECF898; continue 'dispatch;
	}
	// 82ECF894: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82ECF898; continue 'dispatch;
            }
            0x82ECF898 => {
    //   block [0x82ECF898..0x82ECF8A8)
	// 82ECF898: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82ECF89C: 394A004C  addi r10, r10, 0x4c
	ctx.r[10].s64 = ctx.r[10].s64 + 76;
	// 82ECF8A0: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ECF8A4: 4198FFA4  blt cr6, 0x82ecf848
	if ctx.cr[6].lt {
	pc = 0x82ECF848; continue 'dispatch;
	}
	pc = 0x82ECF8A8; continue 'dispatch;
            }
            0x82ECF8A8 => {
    //   block [0x82ECF8A8..0x82ECF8B4)
	// 82ECF8A8: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECF8AC: 41820008  beq 0x82ecf8b4
	if ctx.cr[0].eq {
	pc = 0x82ECF8B4; continue 'dispatch;
	}
	// 82ECF8B0: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	pc = 0x82ECF8B4; continue 'dispatch;
            }
            0x82ECF8B4 => {
    //   block [0x82ECF8B4..0x82ECF8C8)
	// 82ECF8B4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82ECF8B8: 7F1DD040  cmplw cr6, r29, r26
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82ECF8BC: 4198FF18  blt cr6, 0x82ecf7d4
	if ctx.cr[6].lt {
	pc = 0x82ECF7D4; continue 'dispatch;
	}
	// 82ECF8C0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82ECF8C4: 419A0014  beq cr6, 0x82ecf8d8
	if ctx.cr[6].eq {
	pc = 0x82ECF8D8; continue 'dispatch;
	}
	pc = 0x82ECF8C8; continue 'dispatch;
            }
            0x82ECF8C8 => {
    //   block [0x82ECF8C8..0x82ECF8CC)
	// 82ECF8C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x82ECF8CC; continue 'dispatch;
            }
            0x82ECF8CC => {
    //   block [0x82ECF8CC..0x82ECF8D8)
	// 82ECF8CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82ECF8D0: 4BFFDB29  bl 0x82ecd3f8
	ctx.lr = 0x82ECF8D4;
	sub_82ECD3F8(ctx, base);
	// 82ECF8D4: 4800010C  b 0x82ecf9e0
	pc = 0x82ECF9E0; continue 'dispatch;
            }
            0x82ECF8D8 => {
    //   block [0x82ECF8D8..0x82ECF8F0)
	// 82ECF8D8: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82ECF8DC: 419A0100  beq cr6, 0x82ecf9dc
	if ctx.cr[6].eq {
	pc = 0x82ECF9DC; continue 'dispatch;
	}
	// 82ECF8E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82ECF8E4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ECF8E8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ECF8EC: 419A00F0  beq cr6, 0x82ecf9dc
	if ctx.cr[6].eq {
	pc = 0x82ECF9DC; continue 'dispatch;
	}
	pc = 0x82ECF8F0; continue 'dispatch;
            }
            0x82ECF8F0 => {
    //   block [0x82ECF8F0..0x82ECF950)
	// 82ECF8F0: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECF8F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ECF8F8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82ECF8FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECF900: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECF904: 4E800421  bctrl
	ctx.lr = 0x82ECF908;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECF908: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECF90C: 897E0008  lbz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECF910: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ECF914: 419A00B4  beq cr6, 0x82ecf9c8
	if ctx.cr[6].eq {
	pc = 0x82ECF9C8; continue 'dispatch;
	}
	// 82ECF918: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECF91C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82ECF920: 419A00A8  beq cr6, 0x82ecf9c8
	if ctx.cr[6].eq {
	pc = 0x82ECF9C8; continue 'dispatch;
	}
	// 82ECF924: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECF928: 7F0BC000  cmpw cr6, r11, r24
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[24].s32, &mut ctx.xer);
	// 82ECF92C: 409A009C  bne cr6, 0x82ecf9c8
	if !ctx.cr[6].eq {
	pc = 0x82ECF9C8; continue 'dispatch;
	}
	// 82ECF930: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82ECF934: 4B391085  bl 0x822609b8
	ctx.lr = 0x82ECF938;
	sub_822609B8(ctx, base);
	// 82ECF938: 813B0210  lwz r9, 0x210(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ECF93C: C183004C  lfs f12, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ECF940: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ECF944: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF948: 41820074  beq 0x82ecf9bc
	if ctx.cr[0].eq {
	pc = 0x82ECF9BC; continue 'dispatch;
	}
	// 82ECF94C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
            }
            0x82ECF950 => {
    //   block [0x82ECF950..0x82ECF9A8)
	// 82ECF950: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECF954: 41820068  beq 0x82ecf9bc
	if ctx.cr[0].eq {
	pc = 0x82ECF9BC; continue 'dispatch;
	}
	// 82ECF958: 817B0164  lwz r11, 0x164(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ECF95C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECF960: 88EB0010  lbz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECF964: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECF968: 40820044  bne 0x82ecf9ac
	if !ctx.cr[0].eq {
	pc = 0x82ECF9AC; continue 'dispatch;
	}
	// 82ECF96C: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECF970: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82ECF974: 409A0038  bne cr6, 0x82ecf9ac
	if !ctx.cr[6].eq {
	pc = 0x82ECF9AC; continue 'dispatch;
	}
	// 82ECF978: C1AB0028  lfs f13, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ECF97C: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 82ECF980: 4099002C  ble cr6, 0x82ecf9ac
	if !ctx.cr[6].gt {
	pc = 0x82ECF9AC; continue 'dispatch;
	}
	// 82ECF984: 80EB0044  lwz r7, 0x44(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ECF988: 7F07B840  cmplw cr6, r7, r23
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82ECF98C: 4098001C  bge cr6, 0x82ecf9a8
	if !ctx.cr[6].lt {
	pc = 0x82ECF9A8; continue 'dispatch;
	}
	// 82ECF990: C00B002C  lfs f0, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECF994: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ECF998: 40990014  ble cr6, 0x82ecf9ac
	if !ctx.cr[6].gt {
	pc = 0x82ECF9AC; continue 'dispatch;
	}
	// 82ECF99C: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ECF9A0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ECF9A4: 41990008  bgt cr6, 0x82ecf9ac
	if ctx.cr[6].gt {
	pc = 0x82ECF9AC; continue 'dispatch;
	}
	pc = 0x82ECF9A8; continue 'dispatch;
            }
            0x82ECF9A8 => {
    //   block [0x82ECF9A8..0x82ECF9AC)
	// 82ECF9A8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82ECF9AC; continue 'dispatch;
            }
            0x82ECF9AC => {
    //   block [0x82ECF9AC..0x82ECF9BC)
	// 82ECF9AC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82ECF9B0: 394A004C  addi r10, r10, 0x4c
	ctx.r[10].s64 = ctx.r[10].s64 + 76;
	// 82ECF9B4: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ECF9B8: 4198FF98  blt cr6, 0x82ecf950
	if ctx.cr[6].lt {
	pc = 0x82ECF950; continue 'dispatch;
	}
	pc = 0x82ECF9BC; continue 'dispatch;
            }
            0x82ECF9BC => {
    //   block [0x82ECF9BC..0x82ECF9C8)
	// 82ECF9BC: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECF9C0: 41820008  beq 0x82ecf9c8
	if ctx.cr[0].eq {
	pc = 0x82ECF9C8; continue 'dispatch;
	}
	// 82ECF9C4: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	pc = 0x82ECF9C8; continue 'dispatch;
            }
            0x82ECF9C8 => {
    //   block [0x82ECF9C8..0x82ECF9DC)
	// 82ECF9C8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82ECF9CC: 7F1DD040  cmplw cr6, r29, r26
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82ECF9D0: 4198FF20  blt cr6, 0x82ecf8f0
	if ctx.cr[6].lt {
	pc = 0x82ECF8F0; continue 'dispatch;
	}
	// 82ECF9D4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82ECF9D8: 409AFEF0  bne cr6, 0x82ecf8c8
	if !ctx.cr[6].eq {
	pc = 0x82ECF8C8; continue 'dispatch;
	}
	pc = 0x82ECF9DC; continue 'dispatch;
            }
            0x82ECF9DC => {
    //   block [0x82ECF9DC..0x82ECF9E0)
	// 82ECF9DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ECF9E0; continue 'dispatch;
            }
            0x82ECF9E0 => {
    //   block [0x82ECF9E0..0x82ECF9EC)
	// 82ECF9E0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82ECF9E4: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82ECF9E8: 4BDD9A5C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECF9F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECF9F0 size=412
    let mut pc: u32 = 0x82ECF9F0;
    'dispatch: loop {
        match pc {
            0x82ECF9F0 => {
    //   block [0x82ECF9F0..0x82ECFA20)
	// 82ECF9F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECF9F4: 4BDD9A0D  bl 0x82ca9400
	ctx.lr = 0x82ECF9F8;
	sub_82CA93D0(ctx, base);
	// 82ECF9F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECF9FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ECFA00: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ECFA04: 837F0018  lwz r27, 0x18(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECFA08: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECFA0C: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFA10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECFA14: 409A000C  bne cr6, 0x82ecfa20
	if !ctx.cr[6].eq {
	pc = 0x82ECFA20; continue 'dispatch;
	}
	// 82ECFA18: 807D0034  lwz r3, 0x34(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECFA1C: 48000008  b 0x82ecfa24
	pc = 0x82ECFA24; continue 'dispatch;
            }
            0x82ECFA20 => {
    //   block [0x82ECFA20..0x82ECFA24)
	// 82ECFA20: 807D0030  lwz r3, 0x30(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	pc = 0x82ECFA24; continue 'dispatch;
            }
            0x82ECFA24 => {
    //   block [0x82ECFA24..0x82ECFA60)
	// 82ECFA24: 48006D0D  bl 0x82ed6730
	ctx.lr = 0x82ECFA28;
	sub_82ED6730(ctx, base);
	// 82ECFA28: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECFA2C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82ECFA30: 616B84D8  ori r11, r11, 0x84d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34008;
	// 82ECFA34: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECFA38: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ECFA3C: 409A0030  bne cr6, 0x82ecfa6c
	if !ctx.cr[6].eq {
	pc = 0x82ECFA6C; continue 'dispatch;
	}
	// 82ECFA40: 897F0039  lbz r11, 0x39(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(57 as u32) ) } as u64;
	// 82ECFA44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECFA48: 40820024  bne 0x82ecfa6c
	if !ctx.cr[0].eq {
	pc = 0x82ECFA6C; continue 'dispatch;
	}
	// 82ECFA4C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82ECFA50: 419A0010  beq cr6, 0x82ecfa60
	if ctx.cr[6].eq {
	pc = 0x82ECFA60; continue 'dispatch;
	}
	// 82ECFA54: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECFA58: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ECFA5C: 419A0010  beq cr6, 0x82ecfa6c
	if ctx.cr[6].eq {
	pc = 0x82ECFA6C; continue 'dispatch;
	}
	pc = 0x82ECFA60; continue 'dispatch;
            }
            0x82ECFA60 => {
    //   block [0x82ECFA60..0x82ECFA6C)
	// 82ECFA60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ECFA64: 997F0038  stb r11, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 82ECFA68: 48000118  b 0x82ecfb80
	pc = 0x82ECFB80; continue 'dispatch;
            }
            0x82ECFA6C => {
    //   block [0x82ECFA6C..0x82ECFA8C)
	// 82ECFA6C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82ECFA70: 419A0030  beq cr6, 0x82ecfaa0
	if ctx.cr[6].eq {
	pc = 0x82ECFAA0; continue 'dispatch;
	}
	// 82ECFA74: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECFA78: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ECFA7C: 409A0010  bne cr6, 0x82ecfa8c
	if !ctx.cr[6].eq {
	pc = 0x82ECFA8C; continue 'dispatch;
	}
	// 82ECFA80: 4B390F39  bl 0x822609b8
	ctx.lr = 0x82ECFA84;
	sub_822609B8(ctx, base);
	// 82ECFA84: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECFA88: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	pc = 0x82ECFA8C; continue 'dispatch;
            }
            0x82ECFA8C => {
    //   block [0x82ECFA8C..0x82ECFAA0)
	// 82ECFA8C: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ECFA90: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82ECFA94: 409A000C  bne cr6, 0x82ecfaa0
	if !ctx.cr[6].eq {
	pc = 0x82ECFAA0; continue 'dispatch;
	}
	// 82ECFA98: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82ECFA9C: 917C0010  stw r11, 0x10(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82ECFAA0; continue 'dispatch;
            }
            0x82ECFAA0 => {
    //   block [0x82ECFAA0..0x82ECFAC8)
	// 82ECFAA0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECFAA4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82ECFAA8: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82ECFAAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ECFAB0: 41980020  blt cr6, 0x82ecfad0
	if ctx.cr[6].lt {
	pc = 0x82ECFAD0; continue 'dispatch;
	}
	// 82ECFAB4: 419A0014  beq cr6, 0x82ecfac8
	if ctx.cr[6].eq {
	pc = 0x82ECFAC8; continue 'dispatch;
	}
	// 82ECFAB8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82ECFABC: 40980018  bge cr6, 0x82ecfad4
	if !ctx.cr[6].lt {
	pc = 0x82ECFAD4; continue 'dispatch;
	}
	// 82ECFAC0: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 82ECFAC4: 48000010  b 0x82ecfad4
	pc = 0x82ECFAD4; continue 'dispatch;
            }
            0x82ECFAC8 => {
    //   block [0x82ECFAC8..0x82ECFAD0)
	// 82ECFAC8: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82ECFACC: 48000008  b 0x82ecfad4
	pc = 0x82ECFAD4; continue 'dispatch;
            }
            0x82ECFAD0 => {
    //   block [0x82ECFAD0..0x82ECFAD4)
	// 82ECFAD0: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	pc = 0x82ECFAD4; continue 'dispatch;
            }
            0x82ECFAD4 => {
    //   block [0x82ECFAD4..0x82ECFAFC)
	// 82ECFAD4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82ECFAD8: 409A0070  bne cr6, 0x82ecfb48
	if !ctx.cr[6].eq {
	pc = 0x82ECFB48; continue 'dispatch;
	}
	// 82ECFADC: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECFAE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECFAE4: 80DF0044  lwz r6, 0x44(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ECFAE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECFAEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECFAF0: 409A000C  bne cr6, 0x82ecfafc
	if !ctx.cr[6].eq {
	pc = 0x82ECFAFC; continue 'dispatch;
	}
	// 82ECFAF4: 809D0034  lwz r4, 0x34(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECFAF8: 48000008  b 0x82ecfb00
	pc = 0x82ECFB00; continue 'dispatch;
            }
            0x82ECFAFC => {
    //   block [0x82ECFAFC..0x82ECFB00)
	// 82ECFAFC: 809D0030  lwz r4, 0x30(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	pc = 0x82ECFB00; continue 'dispatch;
            }
            0x82ECFB00 => {
    //   block [0x82ECFB00..0x82ECFB24)
	// 82ECFB00: 4BFFFB51  bl 0x82ecf650
	ctx.lr = 0x82ECFB04;
	sub_82ECF650(ctx, base);
	// 82ECFB04: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ECFB08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECFB0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECFB10: 409A0014  bne cr6, 0x82ecfb24
	if !ctx.cr[6].eq {
	pc = 0x82ECFB24; continue 'dispatch;
	}
	// 82ECFB14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ECFB18: 935F0014  stw r26, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	// 82ECFB1C: 997F0030  stb r11, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 82ECFB20: 48000064  b 0x82ecfb84
	pc = 0x82ECFB84; continue 'dispatch;
            }
            0x82ECFB24 => {
    //   block [0x82ECFB24..0x82ECFB48)
	// 82ECFB24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ECFB28: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82ECFB2C: 936B001C  stw r27, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[27].u32 ) };
	// 82ECFB30: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82ECFB34: 895F0024  lbz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ECFB38: 994B0008  stb r10, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82ECFB3C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82ECFB40: 9B5F0030  stb r26, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[26].u8 ) };
	// 82ECFB44: 48000040  b 0x82ecfb84
	pc = 0x82ECFB84; continue 'dispatch;
            }
            0x82ECFB48 => {
    //   block [0x82ECFB48..0x82ECFB58)
	// 82ECFB48: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECFB4C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82ECFB50: 40990008  ble cr6, 0x82ecfb58
	if !ctx.cr[6].gt {
	pc = 0x82ECFB58; continue 'dispatch;
	}
	// 82ECFB54: 93DC000C  stw r30, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	pc = 0x82ECFB58; continue 'dispatch;
            }
            0x82ECFB58 => {
    //   block [0x82ECFB58..0x82ECFB78)
	// 82ECFB58: 897C0008  lbz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECFB5C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECFB60: 40820018  bne 0x82ecfb78
	if !ctx.cr[0].eq {
	pc = 0x82ECFB78; continue 'dispatch;
	}
	// 82ECFB64: 897F0024  lbz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ECFB68: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECFB6C: 4182000C  beq 0x82ecfb78
	if ctx.cr[0].eq {
	pc = 0x82ECFB78; continue 'dispatch;
	}
	// 82ECFB70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ECFB74: 997C0008  stb r11, 8(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	pc = 0x82ECFB78; continue 'dispatch;
            }
            0x82ECFB78 => {
    //   block [0x82ECFB78..0x82ECFB80)
	// 82ECFB78: 939F0014  stw r28, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 82ECFB7C: 9B5F0030  stb r26, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[26].u8 ) };
	pc = 0x82ECFB80; continue 'dispatch;
            }
            0x82ECFB80 => {
    //   block [0x82ECFB80..0x82ECFB84)
	// 82ECFB80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82ECFB84; continue 'dispatch;
            }
            0x82ECFB84 => {
    //   block [0x82ECFB84..0x82ECFB8C)
	// 82ECFB84: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ECFB88: 4BDD98C8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECFB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECFB90 size=88
    let mut pc: u32 = 0x82ECFB90;
    'dispatch: loop {
        match pc {
            0x82ECFB90 => {
    //   block [0x82ECFB90..0x82ECFBCC)
	// 82ECFB90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECFB94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECFB98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECFB9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECFBA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECFBA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECFBA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ECFBAC: 4BFB4F4D  bl 0x82e84af8
	ctx.lr = 0x82ECFBB0;
	sub_82E84AF8(ctx, base);
	// 82ECFBB0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECFBB4: 41820018  beq 0x82ecfbcc
	if ctx.cr[0].eq {
	pc = 0x82ECFBCC; continue 'dispatch;
	}
	// 82ECFBB8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ECFBBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECFBC0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECFBC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECFBC8: 4E800421  bctrl
	ctx.lr = 0x82ECFBCC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ECFBCC => {
    //   block [0x82ECFBCC..0x82ECFBE8)
	// 82ECFBCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECFBD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECFBD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECFBD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECFBDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECFBE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECFBE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECFBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECFBE8 size=696
    let mut pc: u32 = 0x82ECFBE8;
    'dispatch: loop {
        match pc {
            0x82ECFBE8 => {
    //   block [0x82ECFBE8..0x82ECFC4C)
	// 82ECFBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECFBEC: 4BDD980D  bl 0x82ca93f8
	ctx.lr = 0x82ECFBF0;
	sub_82CA93D0(ctx, base);
	// 82ECFBF0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECFBF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ECFBF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ECFBFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECFC00: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFC04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECFC08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECFC0C: 4E800421  bctrl
	ctx.lr = 0x82ECFC10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECFC10: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ECFC14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECFC18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECFC1C: 409A0204  bne cr6, 0x82ecfe20
	if !ctx.cr[6].eq {
	pc = 0x82ECFE20; continue 'dispatch;
	}
	// 82ECFC20: 4BFFD271  bl 0x82ecce90
	ctx.lr = 0x82ECFC24;
	sub_82ECCE90(ctx, base);
	// 82ECFC24: 4BFFD315  bl 0x82eccf38
	ctx.lr = 0x82ECFC28;
	sub_82ECCF38(ctx, base);
	// 82ECFC28: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ECFC2C: 616B84FC  ori r11, r11, 0x84fc
	ctx.r[11].u64 = ctx.r[11].u64 | 34044;
	// 82ECFC30: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ECFC34: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECFC38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECFC3C: 419A0010  beq cr6, 0x82ecfc4c
	if ctx.cr[6].eq {
	pc = 0x82ECFC4C; continue 'dispatch;
	}
	// 82ECFC40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECFC44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECFC48: 4BFFD1C9  bl 0x82ecce10
	ctx.lr = 0x82ECFC4C;
	sub_82ECCE10(ctx, base);
            }
            0x82ECFC4C => {
    //   block [0x82ECFC4C..0x82ECFC6C)
	// 82ECFC4C: 3CDD0001  addis r6, r29, 1
	ctx.r[6].s64 = ctx.r[29].s64 + 65536;
	// 82ECFC50: 38C684F8  addi r6, r6, -0x7b08
	ctx.r[6].s64 = ctx.r[6].s64 + -31496;
	// 82ECFC54: 89660000  lbz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFC58: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECFC5C: 41820010  beq 0x82ecfc6c
	if ctx.cr[0].eq {
	pc = 0x82ECFC6C; continue 'dispatch;
	}
	// 82ECFC60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECFC64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECFC68: 4BFFD951  bl 0x82ecd5b8
	ctx.lr = 0x82ECFC6C;
	sub_82ECD5B8(ctx, base);
	pc = 0x82ECFC6C; continue 'dispatch;
            }
            0x82ECFC6C => {
    //   block [0x82ECFC6C..0x82ECFCBC)
	// 82ECFC6C: 897D0040  lbz r11, 0x40(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ECFC70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECFC74: 41820224  beq 0x82ecfe98
	if ctx.cr[0].eq {
	pc = 0x82ECFE98; continue 'dispatch;
	}
	// 82ECFC78: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECFC7C: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ECFC80: 89260000  lbz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFC84: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECFC88: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECFC8C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ECFC90: 3B6BFFF8  addi r27, r11, -8
	ctx.r[27].s64 = ctx.r[11].s64 + -8;
	// 82ECFC94: 41820028  beq 0x82ecfcbc
	if ctx.cr[0].eq {
	pc = 0x82ECFCBC; continue 'dispatch;
	}
	// 82ECFC98: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFC9C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82ECFCA0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ECFCA4: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82ECFCA8: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82ECFCAC: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82ECFCB0: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82ECFCB4: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82ECFCB8: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82ECFCBC; continue 'dispatch;
            }
            0x82ECFCBC => {
    //   block [0x82ECFCBC..0x82ECFCE0)
	// 82ECFCBC: 3F5D0001  addis r26, r29, 1
	ctx.r[26].s64 = ctx.r[29].s64 + 65536;
	// 82ECFCC0: 83FB0000  lwz r31, 0(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFCC4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82ECFCC8: 3B5A84E0  addi r26, r26, -0x7b20
	ctx.r[26].s64 = ctx.r[26].s64 + -31520;
	// 82ECFCCC: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 82ECFCD0: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 82ECFCD4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFCD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECFCDC: 4099003C  ble cr6, 0x82ecfd18
	if !ctx.cr[6].gt {
	pc = 0x82ECFD18; continue 'dispatch;
	}
	pc = 0x82ECFCE0; continue 'dispatch;
            }
            0x82ECFCE0 => {
    //   block [0x82ECFCE0..0x82ECFD14)
	// 82ECFCE0: 807D0034  lwz r3, 0x34(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ECFCE4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ECFCE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFCEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECFCF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECFCF4: 4E800421  bctrl
	ctx.lr = 0x82ECFCF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECFCF8: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82ECFCFC: 419A0018  beq cr6, 0x82ecfd14
	if ctx.cr[6].eq {
	pc = 0x82ECFD14; continue 'dispatch;
	}
	// 82ECFD00: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFD04: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ECFD08: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECFD0C: 4198FFD4  blt cr6, 0x82ecfce0
	if ctx.cr[6].lt {
	pc = 0x82ECFCE0; continue 'dispatch;
	}
	// 82ECFD10: 48000008  b 0x82ecfd18
	pc = 0x82ECFD18; continue 'dispatch;
            }
            0x82ECFD14 => {
    //   block [0x82ECFD14..0x82ECFD18)
	// 82ECFD14: 7F99E378  mr r25, r28
	ctx.r[25].u64 = ctx.r[28].u64;
	pc = 0x82ECFD18; continue 'dispatch;
            }
            0x82ECFD18 => {
    //   block [0x82ECFD18..0x82ECFD4C)
	// 82ECFD18: 817D003C  lwz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ECFD1C: 57391838  slwi r25, r25, 3
	ctx.r[25].u32 = ctx.r[25].u32.wrapping_shl(3);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 82ECFD20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ECFD24: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 82ECFD28: 834B0000  lwz r26, 0(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFD2C: 419A016C  beq cr6, 0x82ecfe98
	if ctx.cr[6].eq {
	pc = 0x82ECFE98; continue 'dispatch;
	}
	// 82ECFD30: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 82ECFD34: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECFD38: 409A0014  bne cr6, 0x82ecfd4c
	if !ctx.cr[6].eq {
	pc = 0x82ECFD4C; continue 'dispatch;
	}
	// 82ECFD3C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82ECFD40: 931A0028  stw r24, 0x28(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(40 as u32), ctx.r[24].u32 ) };
	// 82ECFD44: 4BFD60F5  bl 0x82ea5e38
	ctx.lr = 0x82ECFD48;
	sub_82EA5E38(ctx, base);
	// 82ECFD48: 48000150  b 0x82ecfe98
	pc = 0x82ECFE98; continue 'dispatch;
            }
            0x82ECFD4C => {
    //   block [0x82ECFD4C..0x82ECFD70)
	// 82ECFD4C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ECFD50: 419A0148  beq cr6, 0x82ecfe98
	if ctx.cr[6].eq {
	pc = 0x82ECFE98; continue 'dispatch;
	}
	// 82ECFD54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECFD58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECFD5C: 409A0014  bne cr6, 0x82ecfd70
	if !ctx.cr[6].eq {
	pc = 0x82ECFD70; continue 'dispatch;
	}
	// 82ECFD60: 7C9FD850  subf r4, r31, r27
	ctx.r[4].s64 = ctx.r[27].s64 - ctx.r[31].s64;
	// 82ECFD64: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82ECFD68: 4BFD69C9  bl 0x82ea6730
	ctx.lr = 0x82ECFD6C;
	sub_82EA6730(ctx, base);
	// 82ECFD6C: 4800012C  b 0x82ecfe98
	pc = 0x82ECFE98; continue 'dispatch;
            }
            0x82ECFD70 => {
    //   block [0x82ECFD70..0x82ECFE20)
	// 82ECFD70: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82ECFD74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECFD78: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82ECFD7C: 396BB874  addi r11, r11, -0x478c
	ctx.r[11].s64 = ctx.r[11].s64 + -18316;
	// 82ECFD80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ECFD84: 815E0718  lwz r10, 0x718(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ECFD88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ECFD8C: 838A0004  lwz r28, 4(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECFD90: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ECFD94: 7D7FD850  subf r11, r31, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[31].s64;
	// 82ECFD98: 3FE08334  lis r31, -0x7ccc
	ctx.r[31].s64 = -2093744128;
	// 82ECFD9C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ECFDA0: 837FFEF0  lwz r27, -0x110(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82ECFDA4: 4BFB53CD  bl 0x82e85170
	ctx.lr = 0x82ECFDA8;
	sub_82E85170(ctx, base);
	// 82ECFDA8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECFDAC: 815D003C  lwz r10, 0x3c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ECFDB0: 93010070  stw r24, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[24].u32 ) };
	// 82ECFDB4: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82ECFDB8: 396BB990  addi r11, r11, -0x4670
	ctx.r[11].s64 = ctx.r[11].s64 + -18032;
	// 82ECFDBC: 813D0044  lwz r9, 0x44(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ECFDC0: 7CEACA14  add r7, r10, r25
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[25].u64;
	// 82ECFDC4: 552A502A  slwi r10, r9, 0xa
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(10);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ECFDC8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ECFDCC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ECFDD0: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECFDD4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82ECFDD8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82ECFDDC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82ECFDE0: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82ECFDE4: 917FFEF0  stw r11, -0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-272 as u32), ctx.r[11].u32 ) };
	// 82ECFDE8: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ECFDEC: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82ECFDF0: 4BFB4419  bl 0x82e84208
	ctx.lr = 0x82ECFDF4;
	sub_82E84208(ctx, base);
	// 82ECFDF4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82ECFDF8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82ECFDFC: 4BFDA27D  bl 0x82eaa078
	ctx.lr = 0x82ECFE00;
	sub_82EAA078(ctx, base);
	// 82ECFE00: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ECFE04: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ECFE08: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82ECFE0C: 937FFEF0  stw r27, -0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-272 as u32), ctx.r[27].u32 ) };
	// 82ECFE10: 4BFB4AD1  bl 0x82e848e0
	ctx.lr = 0x82ECFE14;
	sub_82E848E0(ctx, base);
	// 82ECFE14: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ECFE18: 4BFB4CE1  bl 0x82e84af8
	ctx.lr = 0x82ECFE1C;
	sub_82E84AF8(ctx, base);
	// 82ECFE1C: 4800007C  b 0x82ecfe98
	pc = 0x82ECFE98; continue 'dispatch;
            }
            0x82ECFE20 => {
    //   block [0x82ECFE20..0x82ECFE50)
	// 82ECFE20: 4BFFD0C9  bl 0x82eccee8
	ctx.lr = 0x82ECFE24;
	sub_82ECCEE8(ctx, base);
	// 82ECFE24: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECFE28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECFE2C: 4BFFD1CD  bl 0x82eccff8
	ctx.lr = 0x82ECFE30;
	sub_82ECCFF8(ctx, base);
	// 82ECFE30: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECFE34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECFE38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECFE3C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECFE40: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ECFE44: 409A000C  bne cr6, 0x82ecfe50
	if !ctx.cr[6].eq {
	pc = 0x82ECFE50; continue 'dispatch;
	}
	// 82ECFE48: 4BFFF609  bl 0x82ecf450
	ctx.lr = 0x82ECFE4C;
	sub_82ECF450(ctx, base);
	// 82ECFE4C: 48000008  b 0x82ecfe54
	pc = 0x82ECFE54; continue 'dispatch;
            }
            0x82ECFE50 => {
    //   block [0x82ECFE50..0x82ECFE54)
	// 82ECFE50: 4BFFF691  bl 0x82ecf4e0
	ctx.lr = 0x82ECFE54;
	sub_82ECF4E0(ctx, base);
	pc = 0x82ECFE54; continue 'dispatch;
            }
            0x82ECFE54 => {
    //   block [0x82ECFE54..0x82ECFE74)
	// 82ECFE54: 3D3D0001  addis r9, r29, 1
	ctx.r[9].s64 = ctx.r[29].s64 + 65536;
	// 82ECFE58: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82ECFE5C: 392982A4  addi r9, r9, -0x7d5c
	ctx.r[9].s64 = ctx.r[9].s64 + -32092;
	// 82ECFE60: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82ECFE64: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFE68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECFE6C: 40990028  ble cr6, 0x82ecfe94
	if !ctx.cr[6].gt {
	pc = 0x82ECFE94; continue 'dispatch;
	}
	// 82ECFE70: 397D02A4  addi r11, r29, 0x2a4
	ctx.r[11].s64 = ctx.r[29].s64 + 676;
	pc = 0x82ECFE74; continue 'dispatch;
            }
            0x82ECFE74 => {
    //   block [0x82ECFE74..0x82ECFE94)
	// 82ECFE74: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFE78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ECFE7C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECFE80: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82ECFE84: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82ECFE88: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFE8C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82ECFE90: 4198FFE4  blt cr6, 0x82ecfe74
	if ctx.cr[6].lt {
	pc = 0x82ECFE74; continue 'dispatch;
	}
	pc = 0x82ECFE94; continue 'dispatch;
            }
            0x82ECFE94 => {
    //   block [0x82ECFE94..0x82ECFE98)
	// 82ECFE94: 93090000  stw r24, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	pc = 0x82ECFE98; continue 'dispatch;
            }
            0x82ECFE98 => {
    //   block [0x82ECFE98..0x82ECFEA0)
	// 82ECFE98: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82ECFE9C: 4BDD95AC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECFEA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECFEA0 size=600
    let mut pc: u32 = 0x82ECFEA0;
    'dispatch: loop {
        match pc {
            0x82ECFEA0 => {
    //   block [0x82ECFEA0..0x82ECFF00)
	// 82ECFEA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECFEA4: 4BDD9569  bl 0x82ca940c
	ctx.lr = 0x82ECFEA8;
	sub_82CA93D0(ctx, base);
	// 82ECFEA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECFEAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ECFEB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ECFEB4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82ECFEB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECFEBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFEC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECFEC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECFEC8: 4E800421  bctrl
	ctx.lr = 0x82ECFECC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECFECC: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ECFED0: 409A0038  bne cr6, 0x82ecff08
	if !ctx.cr[6].eq {
	pc = 0x82ECFF08; continue 'dispatch;
	}
	// 82ECFED4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFED8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECFEDC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECFEE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECFEE4: 4E800421  bctrl
	ctx.lr = 0x82ECFEE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECFEE8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECFEEC: 4082001C  bne 0x82ecff08
	if !ctx.cr[0].eq {
	pc = 0x82ECFF08; continue 'dispatch;
	}
	// 82ECFEF0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECFEF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECFEF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECFEFC: 4BFFD1AD  bl 0x82ecd0a8
	ctx.lr = 0x82ECFF00;
	sub_82ECD0A8(ctx, base);
            }
            0x82ECFF00 => {
    //   block [0x82ECFF00..0x82ECFF08)
	// 82ECFF00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECFF04: 480001EC  b 0x82ed00f0
	pc = 0x82ED00F0; continue 'dispatch;
            }
            0x82ECFF08 => {
    //   block [0x82ECFF08..0x82ECFF6C)
	// 82ECFF08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECFF10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECFF14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECFF18: 4E800421  bctrl
	ctx.lr = 0x82ECFF1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECFF1C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECFF20: 4082004C  bne 0x82ecff6c
	if !ctx.cr[0].eq {
	pc = 0x82ECFF6C; continue 'dispatch;
	}
	// 82ECFF24: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFF28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECFF2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECFF30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECFF34: 4E800421  bctrl
	ctx.lr = 0x82ECFF38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECFF38: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECFF3C: 40820030  bne 0x82ecff6c
	if !ctx.cr[0].eq {
	pc = 0x82ECFF6C; continue 'dispatch;
	}
	// 82ECFF40: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECFF44: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECFF48: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECFF4C: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECFF50: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ECFF54: 40980018  bge cr6, 0x82ecff6c
	if !ctx.cr[6].lt {
	pc = 0x82ECFF6C; continue 'dispatch;
	}
	// 82ECFF58: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECFF5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECFF60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECFF64: 4BFFD1B5  bl 0x82ecd118
	ctx.lr = 0x82ECFF68;
	sub_82ECD118(ctx, base);
	// 82ECFF68: 4BFFFF98  b 0x82ecff00
	pc = 0x82ECFF00; continue 'dispatch;
            }
            0x82ECFF6C => {
    //   block [0x82ECFF6C..0x82ECFFC8)
	// 82ECFF6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFF70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECFF74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECFF78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECFF7C: 4E800421  bctrl
	ctx.lr = 0x82ECFF80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECFF80: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECFF84: 40820044  bne 0x82ecffc8
	if !ctx.cr[0].eq {
	pc = 0x82ECFFC8; continue 'dispatch;
	}
	// 82ECFF88: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFF8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECFF90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECFF94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECFF98: 4E800421  bctrl
	ctx.lr = 0x82ECFF9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECFF9C: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ECFFA0: 409A0028  bne cr6, 0x82ecffc8
	if !ctx.cr[6].eq {
	pc = 0x82ECFFC8; continue 'dispatch;
	}
	// 82ECFFA4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECFFA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECFFAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECFFB0: 4BFFF5C1  bl 0x82ecf570
	ctx.lr = 0x82ECFFB4;
	sub_82ECF570(ctx, base);
	// 82ECFFB4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ECFFB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECFFBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ECFFC0: 4BFFD2D1  bl 0x82ecd290
	ctx.lr = 0x82ECFFC4;
	sub_82ECD290(ctx, base);
	// 82ECFFC4: 4BFFFF3C  b 0x82ecff00
	pc = 0x82ECFF00; continue 'dispatch;
            }
            0x82ECFFC8 => {
    //   block [0x82ECFFC8..0x82ED003C)
	// 82ECFFC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFFCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECFFD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECFFD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECFFD8: 4E800421  bctrl
	ctx.lr = 0x82ECFFDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECFFDC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECFFE0: 4082005C  bne 0x82ed003c
	if !ctx.cr[0].eq {
	pc = 0x82ED003C; continue 'dispatch;
	}
	// 82ECFFE4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECFFE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECFFEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECFFF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECFFF4: 4E800421  bctrl
	ctx.lr = 0x82ECFFF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECFFF8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ECFFFC: 40820040  bne 0x82ed003c
	if !ctx.cr[0].eq {
	pc = 0x82ED003C; continue 'dispatch;
	}
	// 82ED0000: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED0004: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED0008: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED000C: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED0010: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED0014: 40990028  ble cr6, 0x82ed003c
	if !ctx.cr[6].gt {
	pc = 0x82ED003C; continue 'dispatch;
	}
	// 82ED0018: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ED001C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED0020: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ED0024: 4BFFF5BD  bl 0x82ecf5e0
	ctx.lr = 0x82ED0028;
	sub_82ECF5E0(ctx, base);
	// 82ED0028: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ED002C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED0030: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ED0034: 4BFFD315  bl 0x82ecd348
	ctx.lr = 0x82ED0038;
	sub_82ECD348(ctx, base);
	// 82ED0038: 4BFFFEC8  b 0x82ecff00
	pc = 0x82ECFF00; continue 'dispatch;
            }
            0x82ED003C => {
    //   block [0x82ED003C..0x82ED00A0)
	// 82ED003C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED0044: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED0048: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED004C: 4E800421  bctrl
	ctx.lr = 0x82ED0050;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED0050: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED0054: 4082004C  bne 0x82ed00a0
	if !ctx.cr[0].eq {
	pc = 0x82ED00A0; continue 'dispatch;
	}
	// 82ED0058: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED005C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED0060: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED0064: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED0068: 4E800421  bctrl
	ctx.lr = 0x82ED006C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED006C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED0070: 40820030  bne 0x82ed00a0
	if !ctx.cr[0].eq {
	pc = 0x82ED00A0; continue 'dispatch;
	}
	// 82ED0074: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED0078: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED007C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED0080: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED0084: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED0088: 409A0018  bne cr6, 0x82ed00a0
	if !ctx.cr[6].eq {
	pc = 0x82ED00A0; continue 'dispatch;
	}
	// 82ED008C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ED0090: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED0094: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ED0098: 4BFFD159  bl 0x82ecd1f0
	ctx.lr = 0x82ED009C;
	sub_82ECD1F0(ctx, base);
	// 82ED009C: 4BFFFE64  b 0x82ecff00
	pc = 0x82ECFF00; continue 'dispatch;
            }
            0x82ED00A0 => {
    //   block [0x82ED00A0..0x82ED00EC)
	// 82ED00A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED00A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED00A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED00AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED00B0: 4E800421  bctrl
	ctx.lr = 0x82ED00B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED00B4: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ED00B8: 409A0034  bne cr6, 0x82ed00ec
	if !ctx.cr[6].eq {
	pc = 0x82ED00EC; continue 'dispatch;
	}
	// 82ED00BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED00C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED00C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED00C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED00CC: 4E800421  bctrl
	ctx.lr = 0x82ED00D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED00D0: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ED00D4: 409A0018  bne cr6, 0x82ed00ec
	if !ctx.cr[6].eq {
	pc = 0x82ED00EC; continue 'dispatch;
	}
	// 82ED00D8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ED00DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED00E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ED00E4: 4BFFD0A5  bl 0x82ecd188
	ctx.lr = 0x82ED00E8;
	sub_82ECD188(ctx, base);
	// 82ED00E8: 4BFFFE18  b 0x82ecff00
	pc = 0x82ECFF00; continue 'dispatch;
            }
            0x82ED00EC => {
    //   block [0x82ED00EC..0x82ED00F0)
	// 82ED00EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ED00F0; continue 'dispatch;
            }
            0x82ED00F0 => {
    //   block [0x82ED00F0..0x82ED00F8)
	// 82ED00F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED00F4: 4BDD9368  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED00F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED00F8 size=592
    let mut pc: u32 = 0x82ED00F8;
    'dispatch: loop {
        match pc {
            0x82ED00F8 => {
    //   block [0x82ED00F8..0x82ED0124)
	// 82ED00F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED00FC: 4BDD930D  bl 0x82ca9408
	ctx.lr = 0x82ED0100;
	sub_82CA93D0(ctx, base);
	// 82ED0100: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED0104: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED0108: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82ED010C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82ED0110: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED0114: 817F0154  lwz r11, 0x154(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82ED0118: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED011C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82ED0120: 419A00A0  beq cr6, 0x82ed01c0
	if ctx.cr[6].eq {
	pc = 0x82ED01C0; continue 'dispatch;
	}
	pc = 0x82ED0124; continue 'dispatch;
            }
            0x82ED0124 => {
    //   block [0x82ED0124..0x82ED015C)
	// 82ED0124: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0128: 809F0150  lwz r4, 0x150(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82ED012C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED0130: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED0134: 4E800421  bctrl
	ctx.lr = 0x82ED0138;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED0138: 809F014C  lwz r4, 0x14c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82ED013C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82ED0140: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82ED0144: 419A0034  beq cr6, 0x82ed0178
	if ctx.cr[6].eq {
	pc = 0x82ED0178; continue 'dispatch;
	}
	// 82ED0148: 81650010  lwz r11, 0x10(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED014C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED0150: 419A000C  beq cr6, 0x82ed015c
	if ctx.cr[6].eq {
	pc = 0x82ED015C; continue 'dispatch;
	}
	// 82ED0154: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82ED0158: 409A0020  bne cr6, 0x82ed0178
	if !ctx.cr[6].eq {
	pc = 0x82ED0178; continue 'dispatch;
	}
            }
            0x82ED015C => {
    //   block [0x82ED015C..0x82ED0178)
	// 82ED015C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED0160: 4BFFD531  bl 0x82ecd690
	ctx.lr = 0x82ED0164;
	sub_82ECD690(ctx, base);
	// 82ED0164: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0168: 41820010  beq 0x82ed0178
	if ctx.cr[0].eq {
	pc = 0x82ED0178; continue 'dispatch;
	}
	// 82ED016C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED0170: 4BFFFD31  bl 0x82ecfea0
	ctx.lr = 0x82ED0174;
	sub_82ECFEA0(ctx, base);
	// 82ED0174: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x82ED0178; continue 'dispatch;
            }
            0x82ED0178 => {
    //   block [0x82ED0178..0x82ED01A4)
	// 82ED0178: 817F0154  lwz r11, 0x154(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82ED017C: 813F0150  lwz r9, 0x150(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82ED0180: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82ED0184: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0188: 915F0154  stw r10, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[10].u32 ) };
	// 82ED018C: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 82ED0190: 40800014  bge 0x82ed01a4
	if !ctx.cr[0].lt {
	pc = 0x82ED01A4; continue 'dispatch;
	}
	// 82ED0194: 813F0034  lwz r9, 0x34(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED0198: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED019C: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82ED01A0: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED01A4; continue 'dispatch;
            }
            0x82ED01A4 => {
    //   block [0x82ED01A4..0x82ED01C0)
	// 82ED01A4: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED01A8: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED01AC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82ED01B0: 419A0190  beq cr6, 0x82ed0340
	if ctx.cr[6].eq {
	pc = 0x82ED0340; continue 'dispatch;
	}
	// 82ED01B4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED01B8: 4182FF6C  beq 0x82ed0124
	if ctx.cr[0].eq {
	pc = 0x82ED0124; continue 'dispatch;
	}
	// 82ED01BC: 48000184  b 0x82ed0340
	pc = 0x82ED0340; continue 'dispatch;
            }
            0x82ED01C0 => {
    //   block [0x82ED01C0..0x82ED0208)
	// 82ED01C0: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED01C4: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED01C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED01CC: 40990058  ble cr6, 0x82ed0224
	if !ctx.cr[6].gt {
	pc = 0x82ED0224; continue 'dispatch;
	}
	// 82ED01D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED01D4: 809F0158  lwz r4, 0x158(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 82ED01D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED01DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED01E0: 4E800421  bctrl
	ctx.lr = 0x82ED01E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED01E4: 809F014C  lwz r4, 0x14c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82ED01E8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82ED01EC: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82ED01F0: 419A0034  beq cr6, 0x82ed0224
	if ctx.cr[6].eq {
	pc = 0x82ED0224; continue 'dispatch;
	}
	// 82ED01F4: 81650010  lwz r11, 0x10(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED01F8: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED01FC: 419A000C  beq cr6, 0x82ed0208
	if ctx.cr[6].eq {
	pc = 0x82ED0208; continue 'dispatch;
	}
	// 82ED0200: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82ED0204: 409A0020  bne cr6, 0x82ed0224
	if !ctx.cr[6].eq {
	pc = 0x82ED0224; continue 'dispatch;
	}
            }
            0x82ED0208 => {
    //   block [0x82ED0208..0x82ED0224)
	// 82ED0208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED020C: 4BFFD485  bl 0x82ecd690
	ctx.lr = 0x82ED0210;
	sub_82ECD690(ctx, base);
	// 82ED0210: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0214: 41820010  beq 0x82ed0224
	if ctx.cr[0].eq {
	pc = 0x82ED0224; continue 'dispatch;
	}
	// 82ED0218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED021C: 4BFFFC85  bl 0x82ecfea0
	ctx.lr = 0x82ED0220;
	sub_82ECFEA0(ctx, base);
	// 82ED0220: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x82ED0224; continue 'dispatch;
            }
            0x82ED0224 => {
    //   block [0x82ED0224..0x82ED0250)
	// 82ED0224: 817F015C  lwz r11, 0x15c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 82ED0228: 813F0158  lwz r9, 0x158(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 82ED022C: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82ED0230: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0234: 915F015C  stw r10, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[10].u32 ) };
	// 82ED0238: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 82ED023C: 40800014  bge 0x82ed0250
	if !ctx.cr[0].lt {
	pc = 0x82ED0250; continue 'dispatch;
	}
	// 82ED0240: 813F0030  lwz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED0244: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED0248: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82ED024C: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED0250; continue 'dispatch;
            }
            0x82ED0250 => {
    //   block [0x82ED0250..0x82ED026C)
	// 82ED0250: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED0254: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED0258: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82ED025C: 40980010  bge cr6, 0x82ed026c
	if !ctx.cr[6].lt {
	pc = 0x82ED026C; continue 'dispatch;
	}
	// 82ED0260: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0264: 4182FF5C  beq 0x82ed01c0
	if ctx.cr[0].eq {
	pc = 0x82ED01C0; continue 'dispatch;
	}
	// 82ED0268: 480000D8  b 0x82ed0340
	pc = 0x82ED0340; continue 'dispatch;
            }
            0x82ED026C => {
    //   block [0x82ED026C..0x82ED0298)
	// 82ED026C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED0270: 809F014C  lwz r4, 0x14c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82ED0274: 4BFFF975  bl 0x82ecfbe8
	ctx.lr = 0x82ED0278;
	sub_82ECFBE8(ctx, base);
	// 82ED0278: 817F014C  lwz r11, 0x14c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82ED027C: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82ED0280: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82ED0284: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82ED0288: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED028C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0290: 4099003C  ble cr6, 0x82ed02cc
	if !ctx.cr[6].gt {
	pc = 0x82ED02CC; continue 'dispatch;
	}
	// 82ED0294: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82ED0298; continue 'dispatch;
            }
            0x82ED0298 => {
    //   block [0x82ED0298..0x82ED02CC)
	// 82ED0298: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED029C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED02A0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED02A4: 809F014C  lwz r4, 0x14c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82ED02A8: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED02AC: 7CBE502E  lwzx r5, r30, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ED02B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED02B4: 4E800421  bctrl
	ctx.lr = 0x82ED02B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED02B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED02BC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82ED02C0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82ED02C4: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82ED02C8: 4198FFD0  blt cr6, 0x82ed0298
	if ctx.cr[6].lt {
	pc = 0x82ED0298; continue 'dispatch;
	}
            }
            0x82ED02CC => {
    //   block [0x82ED02CC..0x82ED02F0)
	// 82ED02CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ED02D0: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ED02D4: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82ED02D8: 939F015C  stw r28, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[28].u32 ) };
	// 82ED02DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED02E0: 939F0154  stw r28, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[28].u32 ) };
	// 82ED02E4: 995F0010  stb r10, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 82ED02E8: 40990054  ble cr6, 0x82ed033c
	if !ctx.cr[6].gt {
	pc = 0x82ED033C; continue 'dispatch;
	}
	// 82ED02EC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82ED02F0; continue 'dispatch;
            }
            0x82ED02F0 => {
    //   block [0x82ED02F0..0x82ED0328)
	// 82ED02F0: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ED02F4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82ED02F8: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED02FC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0300: 40820028  bne 0x82ed0328
	if !ctx.cr[0].eq {
	pc = 0x82ED0328; continue 'dispatch;
	}
	// 82ED0304: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED0308: 815F014C  lwz r10, 0x14c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82ED030C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED0310: 409A0018  bne cr6, 0x82ed0328
	if !ctx.cr[6].eq {
	pc = 0x82ED0328; continue 'dispatch;
	}
	// 82ED0314: 4B3906A5  bl 0x822609b8
	ctx.lr = 0x82ED0318;
	sub_822609B8(ctx, base);
	// 82ED0318: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ED031C: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED0320: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82ED0324: D00B002C  stfs f0, 0x2c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	pc = 0x82ED0328; continue 'dispatch;
            }
            0x82ED0328 => {
    //   block [0x82ED0328..0x82ED033C)
	// 82ED0328: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ED032C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82ED0330: 3BDE004C  addi r30, r30, 0x4c
	ctx.r[30].s64 = ctx.r[30].s64 + 76;
	// 82ED0334: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED0338: 4198FFB8  blt cr6, 0x82ed02f0
	if ctx.cr[6].lt {
	pc = 0x82ED02F0; continue 'dispatch;
	}
	pc = 0x82ED033C; continue 'dispatch;
            }
            0x82ED033C => {
    //   block [0x82ED033C..0x82ED0340)
	// 82ED033C: 939F014C  stw r28, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[28].u32 ) };
	pc = 0x82ED0340; continue 'dispatch;
            }
            0x82ED0340 => {
    //   block [0x82ED0340..0x82ED0348)
	// 82ED0340: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ED0344: 4BDD9114  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED0348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED0348 size=164
    let mut pc: u32 = 0x82ED0348;
    'dispatch: loop {
        match pc {
            0x82ED0348 => {
    //   block [0x82ED0348..0x82ED0384)
	// 82ED0348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED034C: 4BDD90B9  bl 0x82ca9404
	ctx.lr = 0x82ED0350;
	sub_82CA93D0(ctx, base);
	// 82ED0350: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED0354: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82ED0358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED035C: 576B07BD  rlwinm. r11, r27, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0360: 4182005C  beq 0x82ed03bc
	if ctx.cr[0].eq {
	pc = 0x82ED03BC; continue 'dispatch;
	}
	// 82ED0364: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ED0368: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82ED036C: 3B9FFFFC  addi r28, r31, -4
	ctx.r[28].s64 = ctx.r[31].s64 + -4;
	// 82ED0370: 615D8578  ori r29, r10, 0x8578
	ctx.r[29].u64 = ctx.r[10].u64 | 34168;
	// 82ED0374: 37CBFFFF  addic. r30, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ED0378: 7D4BE9D6  mullw r10, r11, r29
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * ctx.r[29].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED037C: 7FEAFA14  add r31, r10, r31
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82ED0380: 41800018  blt 0x82ed0398
	if ctx.cr[0].lt {
	pc = 0x82ED0398; continue 'dispatch;
	}
	pc = 0x82ED0384; continue 'dispatch;
            }
            0x82ED0384 => {
    //   block [0x82ED0384..0x82ED0398)
	// 82ED0384: 7FFDF850  subf r31, r29, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[29].s64;
	// 82ED0388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED038C: 4BFFED6D  bl 0x82ecf0f8
	ctx.lr = 0x82ED0390;
	sub_82ECF0F8(ctx, base);
	// 82ED0390: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ED0394: 4080FFF0  bge 0x82ed0384
	if !ctx.cr[0].lt {
	pc = 0x82ED0384; continue 'dispatch;
	}
	pc = 0x82ED0398; continue 'dispatch;
            }
            0x82ED0398 => {
    //   block [0x82ED0398..0x82ED03B4)
	// 82ED0398: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED039C: 41820018  beq 0x82ed03b4
	if ctx.cr[0].eq {
	pc = 0x82ED03B4; continue 'dispatch;
	}
	// 82ED03A0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED03A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ED03A8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED03AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED03B0: 4E800421  bctrl
	ctx.lr = 0x82ED03B4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED03B4 => {
    //   block [0x82ED03B4..0x82ED03BC)
	// 82ED03B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ED03B8: 4800002C  b 0x82ed03e4
	pc = 0x82ED03E4; continue 'dispatch;
            }
            0x82ED03BC => {
    //   block [0x82ED03BC..0x82ED03E0)
	// 82ED03BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED03C0: 4BFFED39  bl 0x82ecf0f8
	ctx.lr = 0x82ED03C4;
	sub_82ECF0F8(ctx, base);
	// 82ED03C4: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED03C8: 41820018  beq 0x82ed03e0
	if ctx.cr[0].eq {
	pc = 0x82ED03E0; continue 'dispatch;
	}
	// 82ED03CC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED03D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED03D4: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED03D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED03DC: 4E800421  bctrl
	ctx.lr = 0x82ED03E0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED03E0 => {
    //   block [0x82ED03E0..0x82ED03E4)
	// 82ED03E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82ED03E4; continue 'dispatch;
            }
            0x82ED03E4 => {
    //   block [0x82ED03E4..0x82ED03EC)
	// 82ED03E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ED03E8: 4BDD906C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED03F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED03F0 size=244
    let mut pc: u32 = 0x82ED03F0;
    'dispatch: loop {
        match pc {
            0x82ED03F0 => {
    //   block [0x82ED03F0..0x82ED0424)
	// 82ED03F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED03F4: 4BDD9015  bl 0x82ca9408
	ctx.lr = 0x82ED03F8;
	sub_82CA93D0(ctx, base);
	// 82ED03F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED03FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED0400: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED0404: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82ED0408: 396BB9C0  addi r11, r11, -0x4640
	ctx.r[11].s64 = ctx.r[11].s64 + -17984;
	// 82ED040C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82ED0410: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED0414: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ED0418: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED041C: 40990050  ble cr6, 0x82ed046c
	if !ctx.cr[6].gt {
	pc = 0x82ED046C; continue 'dispatch;
	}
	// 82ED0420: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82ED0424; continue 'dispatch;
            }
            0x82ED0424 => {
    //   block [0x82ED0424..0x82ED0458)
	// 82ED0424: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED0428: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82ED042C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED0430: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ED0434: 419A0024  beq cr6, 0x82ed0458
	if ctx.cr[6].eq {
	pc = 0x82ED0458; continue 'dispatch;
	}
	// 82ED0438: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82ED043C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0440: 41820018  beq 0x82ed0458
	if ctx.cr[0].eq {
	pc = 0x82ED0458; continue 'dispatch;
	}
	// 82ED0444: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0448: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ED044C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0450: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED0454: 4E800421  bctrl
	ctx.lr = 0x82ED0458;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED0458 => {
    //   block [0x82ED0458..0x82ED046C)
	// 82ED0458: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED045C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82ED0460: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82ED0464: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED0468: 4198FFBC  blt cr6, 0x82ed0424
	if ctx.cr[6].lt {
	pc = 0x82ED0424; continue 'dispatch;
	}
	pc = 0x82ED046C; continue 'dispatch;
            }
            0x82ED046C => {
    //   block [0x82ED046C..0x82ED0494)
	// 82ED046C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED0470: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0474: 41820020  beq 0x82ed0494
	if ctx.cr[0].eq {
	pc = 0x82ED0494; continue 'dispatch;
	}
	// 82ED0478: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED047C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED0480: 419A0014  beq cr6, 0x82ed0494
	if ctx.cr[6].eq {
	pc = 0x82ED0494; continue 'dispatch;
	}
	// 82ED0484: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82ED0488: 4BFFFEC1  bl 0x82ed0348
	ctx.lr = 0x82ED048C;
	sub_82ED0348(ctx, base);
	// 82ED048C: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82ED0490: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x82ED0494; continue 'dispatch;
            }
            0x82ED0494 => {
    //   block [0x82ED0494..0x82ED04C8)
	// 82ED0494: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	// 82ED0498: 807E89B8  lwz r3, -0x7648(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-30280 as u32) ) } as u64;
	// 82ED049C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED04A0: 419A0028  beq cr6, 0x82ed04c8
	if ctx.cr[6].eq {
	pc = 0x82ED04C8; continue 'dispatch;
	}
	// 82ED04A4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED04A8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED04AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED04B0: 4E800421  bctrl
	ctx.lr = 0x82ED04B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED04B4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82ED04B8: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82ED04BC: 917E89B8  stw r11, -0x7648(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-30280 as u32), ctx.r[11].u32 ) };
	// 82ED04C0: 39600C10  li r11, 0xc10
	ctx.r[11].s64 = 3088;
	// 82ED04C4: 916AE1B4  stw r11, -0x1e4c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-7756 as u32), ctx.r[11].u32 ) };
            }
            0x82ED04C8 => {
    //   block [0x82ED04C8..0x82ED04E4)
	// 82ED04C8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82ED04CC: 4BFC2DD5  bl 0x82e932a0
	ctx.lr = 0x82ED04D0;
	sub_82E932A0(ctx, base);
	// 82ED04D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ED04D4: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82ED04D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED04DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ED04E0: 4BDD8F78  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED04E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED04E8 size=12
    let mut pc: u32 = 0x82ED04E8;
    'dispatch: loop {
        match pc {
            0x82ED04E8 => {
    //   block [0x82ED04E8..0x82ED04F4)
	// 82ED04E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ED04EC: 386BF090  addi r3, r11, -0xf70
	ctx.r[3].s64 = ctx.r[11].s64 + -3952;
	// 82ED04F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED04F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED04F8 size=184
    let mut pc: u32 = 0x82ED04F8;
    'dispatch: loop {
        match pc {
            0x82ED04F8 => {
    //   block [0x82ED04F8..0x82ED0538)
	// 82ED04F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED04FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED0500: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED0504: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED0508: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED050C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED0510: 548B07BD  rlwinm. r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0514: 41820058  beq 0x82ed056c
	if ctx.cr[0].eq {
	pc = 0x82ED056C; continue 'dispatch;
	}
	// 82ED0518: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82ED051C: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82ED0520: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED0524: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0528: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82ED052C: 4180001C  blt 0x82ed0548
	if ctx.cr[0].lt {
	pc = 0x82ED0548; continue 'dispatch;
	}
	// 82ED0530: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82ED0534: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x82ED0538; continue 'dispatch;
            }
            0x82ED0538 => {
    //   block [0x82ED0538..0x82ED0548)
	// 82ED0538: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 82ED053C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0540: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ED0544: 4080FFF4  bge 0x82ed0538
	if !ctx.cr[0].lt {
	pc = 0x82ED0538; continue 'dispatch;
	}
	pc = 0x82ED0548; continue 'dispatch;
            }
            0x82ED0548 => {
    //   block [0x82ED0548..0x82ED0564)
	// 82ED0548: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED054C: 41820018  beq 0x82ed0564
	if ctx.cr[0].eq {
	pc = 0x82ED0564; continue 'dispatch;
	}
	// 82ED0550: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED0554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED0558: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED055C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED0560: 4E800421  bctrl
	ctx.lr = 0x82ED0564;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED0564 => {
    //   block [0x82ED0564..0x82ED056C)
	// 82ED0564: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED0568: 48000030  b 0x82ed0598
	pc = 0x82ED0598; continue 'dispatch;
            }
            0x82ED056C => {
    //   block [0x82ED056C..0x82ED0594)
	// 82ED056C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ED0570: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED0574: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82ED0578: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED057C: 41820018  beq 0x82ed0594
	if ctx.cr[0].eq {
	pc = 0x82ED0594; continue 'dispatch;
	}
	// 82ED0580: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED0584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED0588: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED058C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED0590: 4E800421  bctrl
	ctx.lr = 0x82ED0594;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED0594 => {
    //   block [0x82ED0594..0x82ED0598)
	// 82ED0594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82ED0598; continue 'dispatch;
            }
            0x82ED0598 => {
    //   block [0x82ED0598..0x82ED05B0)
	// 82ED0598: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED059C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED05A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED05A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED05A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED05AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED05B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED05B0 size=136
    let mut pc: u32 = 0x82ED05B0;
    'dispatch: loop {
        match pc {
            0x82ED05B0 => {
    //   block [0x82ED05B0..0x82ED0638)
	// 82ED05B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED05B4: 4BDD8E59  bl 0x82ca940c
	ctx.lr = 0x82ED05B8;
	sub_82CA93D0(ctx, base);
	// 82ED05B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED05BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED05C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED05C4: 396BB9C0  addi r11, r11, -0x4640
	ctx.r[11].s64 = ctx.r[11].s64 + -17984;
	// 82ED05C8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82ED05CC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED05D0: 394A9B0C  addi r10, r10, -0x64f4
	ctx.r[10].s64 = ctx.r[10].s64 + -25844;
	// 82ED05D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED05D8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED05DC: 388B6D70  addi r4, r11, 0x6d70
	ctx.r[4].s64 = ctx.r[11].s64 + 28016;
	// 82ED05E0: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82ED05E4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED05E8: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82ED05EC: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82ED05F0: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82ED05F4: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82ED05F8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82ED05FC: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED0600: 4B397621  bl 0x82267c20
	ctx.lr = 0x82ED0604;
	sub_82267C20(ctx, base);
	// 82ED0604: 3FA08330  lis r29, -0x7cd0
	ctx.r[29].s64 = -2094006272;
	// 82ED0608: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 82ED060C: 807DE1B4  lwz r3, -0x1e4c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-7756 as u32) ) } as u64;
	// 82ED0610: 4B746319  bl 0x82616928
	ctx.lr = 0x82ED0614;
	sub_82616928(ctx, base);
	// 82ED0614: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ED0618: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82ED061C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED0620: 916A89B8  stw r11, -0x7648(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-30280 as u32), ctx.r[11].u32 ) };
	// 82ED0624: 815DE1B4  lwz r10, -0x1e4c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-7756 as u32) ) } as u64;
	// 82ED0628: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ED062C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82ED0630: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED0634: 4BDD8E28  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED0638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED0638 size=88
    let mut pc: u32 = 0x82ED0638;
    'dispatch: loop {
        match pc {
            0x82ED0638 => {
    //   block [0x82ED0638..0x82ED0674)
	// 82ED0638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED063C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED0640: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED0644: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED0648: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED064C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED0650: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED0654: 4BFFFD9D  bl 0x82ed03f0
	ctx.lr = 0x82ED0658;
	sub_82ED03F0(ctx, base);
	// 82ED0658: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED065C: 41820018  beq 0x82ed0674
	if ctx.cr[0].eq {
	pc = 0x82ED0674; continue 'dispatch;
	}
	// 82ED0660: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED0664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED0668: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED066C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED0670: 4E800421  bctrl
	ctx.lr = 0x82ED0674;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED0674 => {
    //   block [0x82ED0674..0x82ED0690)
	// 82ED0674: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED0678: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED067C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED0680: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED0684: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED0688: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED068C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED0690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED0690 size=156
    let mut pc: u32 = 0x82ED0690;
    'dispatch: loop {
        match pc {
            0x82ED0690 => {
    //   block [0x82ED0690..0x82ED06CC)
	// 82ED0690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED0694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED0698: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED069C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED06A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED06A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED06A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED06AC: 396BB9D8  addi r11, r11, -0x4628
	ctx.r[11].s64 = ctx.r[11].s64 + -17960;
	// 82ED06B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED06B4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82ED06B8: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82ED06BC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED06C0: 4BFBCB71  bl 0x82e8d230
	ctx.lr = 0x82ED06C4;
	sub_82E8D230(ctx, base);
	// 82ED06C4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82ED06C8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82ED06CC; continue 'dispatch;
            }
            0x82ED06CC => {
    //   block [0x82ED06CC..0x82ED06F8)
	// 82ED06CC: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED06D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED06D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ED06D8: 409AFFF4  bne cr6, 0x82ed06cc
	if !ctx.cr[6].eq {
	pc = 0x82ED06CC; continue 'dispatch;
	}
	// 82ED06DC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82ED06E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82ED06E4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED06E8: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82ED06EC: 4B74623D  bl 0x82616928
	ctx.lr = 0x82ED06F0;
	sub_82616928(ctx, base);
	// 82ED06F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ED06F4: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	pc = 0x82ED06F8; continue 'dispatch;
            }
            0x82ED06F8 => {
    //   block [0x82ED06F8..0x82ED072C)
	// 82ED06F8: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED06FC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82ED0700: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0704: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82ED0708: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED070C: 4082FFEC  bne 0x82ed06f8
	if !ctx.cr[0].eq {
	pc = 0x82ED06F8; continue 'dispatch;
	}
	// 82ED0710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED0714: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED0718: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED071C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED0720: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED0724: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED0728: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED0730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED0730 size=152
    let mut pc: u32 = 0x82ED0730;
    'dispatch: loop {
        match pc {
            0x82ED0730 => {
    //   block [0x82ED0730..0x82ED0770)
	// 82ED0730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED0734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED0738: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED073C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED0740: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED0744: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED0748: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED074C: 396BB9D8  addi r11, r11, -0x4628
	ctx.r[11].s64 = ctx.r[11].s64 + -17960;
	// 82ED0750: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82ED0754: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED0758: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED075C: 816ADAB4  lwz r11, -0x254c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED0760: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED0764: 4E800421  bctrl
	ctx.lr = 0x82ED0768;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED0768: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED076C: 48000028  b 0x82ed0794
	pc = 0x82ED0794; continue 'dispatch;
            }
            0x82ED0770 => {
    //   block [0x82ED0770..0x82ED0790)
	// 82ED0770: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED0774: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0778: 41820018  beq 0x82ed0790
	if ctx.cr[0].eq {
	pc = 0x82ED0790; continue 'dispatch;
	}
	// 82ED077C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0780: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ED0784: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0788: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED078C: 4E800421  bctrl
	ctx.lr = 0x82ED0790;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED0790 => {
    //   block [0x82ED0790..0x82ED0794)
	// 82ED0790: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82ED0794; continue 'dispatch;
            }
            0x82ED0794 => {
    //   block [0x82ED0794..0x82ED07C8)
	// 82ED0794: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0798: 4082FFD8  bne 0x82ed0770
	if !ctx.cr[0].eq {
	pc = 0x82ED0770; continue 'dispatch;
	}
	// 82ED079C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82ED07A0: 4BFDADC9  bl 0x82eab568
	ctx.lr = 0x82ED07A4;
	sub_82EAB568(ctx, base);
	// 82ED07A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ED07A8: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82ED07AC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED07B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED07B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED07B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED07BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED07C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED07C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED07C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED07C8 size=52
    let mut pc: u32 = 0x82ED07C8;
    'dispatch: loop {
        match pc {
            0x82ED07C8 => {
    //   block [0x82ED07C8..0x82ED07FC)
	// 82ED07C8: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED07CC: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED07D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED07D4: 40820028  bne 0x82ed07fc
	if !ctx.cr[0].eq {
		sub_82ED07FC(ctx, base);
		return;
	}
	// 82ED07D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED07DC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82ED07E0: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82ED07E4: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82ED07E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ED07EC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED07F0: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ED07F4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82ED07F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED07FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED07FC size=208
    let mut pc: u32 = 0x82ED07FC;
    'dispatch: loop {
        match pc {
            0x82ED07FC => {
    //   block [0x82ED07FC..0x82ED086C)
	// 82ED07FC: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED0800: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82ED0804: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ED0808: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED080C: 91240014  stw r9, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82ED0810: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED0814: 91240010  stw r9, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82ED0818: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED081C: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82ED0820: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED0824: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82ED0828: 8125000C  lwz r9, 0xc(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED082C: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82ED0830: 990B001C  stb r8, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[8].u8 ) };
	// 82ED0834: 409A0054  bne cr6, 0x82ed0888
	if !ctx.cr[6].eq {
	pc = 0x82ED0888; continue 'dispatch;
	}
	// 82ED0838: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED083C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0840: 4082002C  bne 0x82ed086c
	if !ctx.cr[0].eq {
	pc = 0x82ED086C; continue 'dispatch;
	}
	// 82ED0844: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82ED0848: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82ED084C: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82ED0850: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED0854: 91490014  stw r10, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82ED0858: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED085C: 91490014  stw r10, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82ED0860: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED0864: 91490018  stw r10, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82ED0868: 48000044  b 0x82ed08ac
	pc = 0x82ED08AC; continue 'dispatch;
            }
            0x82ED086C => {
    //   block [0x82ED086C..0x82ED0888)
	// 82ED086C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ED0870: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82ED0874: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82ED0878: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED087C: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82ED0880: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82ED0884: 48000028  b 0x82ed08ac
	pc = 0x82ED08AC; continue 'dispatch;
            }
            0x82ED0888 => {
    //   block [0x82ED0888..0x82ED08A8)
	// 82ED0888: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED088C: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82ED0890: 916A0014  stw r11, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82ED0894: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0898: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82ED089C: 4182000C  beq 0x82ed08a8
	if ctx.cr[0].eq {
	pc = 0x82ED08A8; continue 'dispatch;
	}
	// 82ED08A0: 91690018  stw r11, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82ED08A4: 48000008  b 0x82ed08ac
	pc = 0x82ED08AC; continue 'dispatch;
            }
            0x82ED08A8 => {
    //   block [0x82ED08A8..0x82ED08AC)
	// 82ED08A8: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED08AC; continue 'dispatch;
            }
            0x82ED08AC => {
    //   block [0x82ED08AC..0x82ED08CC)
	// 82ED08AC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82ED08B0: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82ED08B4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82ED08B8: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82ED08BC: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82ED08C0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ED08C4: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ED08C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED08D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED08D0 size=388
    let mut pc: u32 = 0x82ED08D0;
    'dispatch: loop {
        match pc {
            0x82ED08D0 => {
    //   block [0x82ED08D0..0x82ED0904)
	// 82ED08D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED08D4: 4BDD8B39  bl 0x82ca940c
	ctx.lr = 0x82ED08D8;
	sub_82CA93D0(ctx, base);
	// 82ED08D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED08DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED08E0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ED08E4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED08E8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED08EC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED08F0: 409A0138  bne cr6, 0x82ed0a28
	if !ctx.cr[6].eq {
	pc = 0x82ED0A28; continue 'dispatch;
	}
	// 82ED08F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED08F8: 409A000C  bne cr6, 0x82ed0904
	if !ctx.cr[6].eq {
	pc = 0x82ED0904; continue 'dispatch;
	}
	// 82ED08FC: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82ED0900: 48000008  b 0x82ed0908
	pc = 0x82ED0908; continue 'dispatch;
            }
            0x82ED0904 => {
    //   block [0x82ED0904..0x82ED0908)
	// 82ED0904: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x82ED0908; continue 'dispatch;
            }
            0x82ED0908 => {
    //   block [0x82ED0908..0x82ED0924)
	// 82ED0908: 557E003E  slwi r30, r11, 0
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82ED090C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82ED0910: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0914: 40820010  bne 0x82ed0924
	if !ctx.cr[0].eq {
	pc = 0x82ED0924; continue 'dispatch;
	}
	// 82ED0918: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82ED091C: 4B41989D  bl 0x822ea1b8
	ctx.lr = 0x82ED0920;
	sub_822EA1B8(ctx, base);
	// 82ED0920: 48000034  b 0x82ed0954
	pc = 0x82ED0954; continue 'dispatch;
            }
            0x82ED0924 => {
    //   block [0x82ED0924..0x82ED0940)
	// 82ED0924: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 82ED0928: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED092C: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82ED0930: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED0934: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED0938: 40990008  ble cr6, 0x82ed0940
	if !ctx.cr[6].gt {
	pc = 0x82ED0940; continue 'dispatch;
	}
	// 82ED093C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82ED0940; continue 'dispatch;
            }
            0x82ED0940 => {
    //   block [0x82ED0940..0x82ED0950)
	// 82ED0940: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82ED0944: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED0948: 41990008  bgt cr6, 0x82ed0950
	if ctx.cr[6].gt {
	pc = 0x82ED0950; continue 'dispatch;
	}
	// 82ED094C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82ED0950; continue 'dispatch;
            }
            0x82ED0950 => {
    //   block [0x82ED0950..0x82ED0954)
	// 82ED0950: 4B745FD9  bl 0x82616928
	ctx.lr = 0x82ED0954;
	sub_82616928(ctx, base);
	pc = 0x82ED0954; continue 'dispatch;
            }
            0x82ED0954 => {
    //   block [0x82ED0954..0x82ED0978)
	// 82ED0954: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED0958: 419A0038  beq cr6, 0x82ed0990
	if ctx.cr[6].eq {
	pc = 0x82ED0990; continue 'dispatch;
	}
	// 82ED095C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 82ED0960: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82ED0964: 357EFFFF  addic. r11, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0968: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82ED096C: 4180001C  blt 0x82ed0988
	if ctx.cr[0].lt {
	pc = 0x82ED0988; continue 'dispatch;
	}
	// 82ED0970: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82ED0974: 39089B10  addi r8, r8, -0x64f0
	ctx.r[8].s64 = ctx.r[8].s64 + -25840;
	pc = 0x82ED0978; continue 'dispatch;
            }
            0x82ED0978 => {
    //   block [0x82ED0978..0x82ED0988)
	// 82ED0978: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82ED097C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0980: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82ED0984: 4080FFF4  bge 0x82ed0978
	if !ctx.cr[0].lt {
	pc = 0x82ED0978; continue 'dispatch;
	}
	pc = 0x82ED0988; continue 'dispatch;
            }
            0x82ED0988 => {
    //   block [0x82ED0988..0x82ED0990)
	// 82ED0988: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 82ED098C: 48000008  b 0x82ed0994
	pc = 0x82ED0994; continue 'dispatch;
            }
            0x82ED0990 => {
    //   block [0x82ED0990..0x82ED0994)
	// 82ED0990: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ED0994; continue 'dispatch;
            }
            0x82ED0994 => {
    //   block [0x82ED0994..0x82ED09A8)
	// 82ED0994: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED0998: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED099C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED09A0: 40990008  ble cr6, 0x82ed09a8
	if !ctx.cr[6].gt {
	pc = 0x82ED09A8; continue 'dispatch;
	}
	// 82ED09A4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED09A8; continue 'dispatch;
            }
            0x82ED09A8 => {
    //   block [0x82ED09A8..0x82ED09C0)
	// 82ED09A8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED09AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ED09B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED09B4: 40990034  ble cr6, 0x82ed09e8
	if !ctx.cr[6].gt {
	pc = 0x82ED09E8; continue 'dispatch;
	}
	// 82ED09B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED09BC: 395E0004  addi r10, r30, 4
	ctx.r[10].s64 = ctx.r[30].s64 + 4;
	pc = 0x82ED09C0; continue 'dispatch;
            }
            0x82ED09C0 => {
    //   block [0x82ED09C0..0x82ED09E8)
	// 82ED09C0: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED09C4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED09C8: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82ED09CC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82ED09D0: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED09D4: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82ED09D8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82ED09DC: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED09E0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82ED09E4: 4198FFDC  blt cr6, 0x82ed09c0
	if ctx.cr[6].lt {
	pc = 0x82ED09C0; continue 'dispatch;
	}
	pc = 0x82ED09E8; continue 'dispatch;
            }
            0x82ED09E8 => {
    //   block [0x82ED09E8..0x82ED0A20)
	// 82ED09E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED09EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED09F0: 41820034  beq 0x82ed0a24
	if ctx.cr[0].eq {
	pc = 0x82ED0A24; continue 'dispatch;
	}
	// 82ED09F4: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82ED09F8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ED09FC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED0A00: 419A0020  beq cr6, 0x82ed0a20
	if ctx.cr[6].eq {
	pc = 0x82ED0A20; continue 'dispatch;
	}
	// 82ED0A04: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0A08: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82ED0A0C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82ED0A10: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0A14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED0A18: 4E800421  bctrl
	ctx.lr = 0x82ED0A1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED0A1C: 48000008  b 0x82ed0a24
	pc = 0x82ED0A24; continue 'dispatch;
            }
            0x82ED0A20 => {
    //   block [0x82ED0A20..0x82ED0A24)
	// 82ED0A20: 4B974D91  bl 0x828457b0
	ctx.lr = 0x82ED0A24;
	sub_828457B0(ctx, base);
	pc = 0x82ED0A24; continue 'dispatch;
            }
            0x82ED0A24 => {
    //   block [0x82ED0A24..0x82ED0A28)
	// 82ED0A24: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x82ED0A28; continue 'dispatch;
            }
            0x82ED0A28 => {
    //   block [0x82ED0A28..0x82ED0A54)
	// 82ED0A28: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED0A2C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED0A30: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED0A34: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0A38: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED0A3C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82ED0A40: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED0A44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED0A48: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82ED0A4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED0A50: 4BDD8A0C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED0A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED0A58 size=328
    let mut pc: u32 = 0x82ED0A58;
    'dispatch: loop {
        match pc {
            0x82ED0A58 => {
    //   block [0x82ED0A58..0x82ED0A98)
	// 82ED0A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED0A5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED0A60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED0A64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED0A68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED0A6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ED0A70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ED0A74: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED0A78: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED0A7C: 4099010C  ble cr6, 0x82ed0b88
	if !ctx.cr[6].gt {
	pc = 0x82ED0B88; continue 'dispatch;
	}
	// 82ED0A80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ED0A84: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82ED0A88: 409A0010  bne cr6, 0x82ed0a98
	if !ctx.cr[6].eq {
	pc = 0x82ED0A98; continue 'dispatch;
	}
	// 82ED0A8C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82ED0A90: 4B419729  bl 0x822ea1b8
	ctx.lr = 0x82ED0A94;
	sub_822EA1B8(ctx, base);
	// 82ED0A94: 48000034  b 0x82ed0ac8
	pc = 0x82ED0AC8; continue 'dispatch;
            }
            0x82ED0A98 => {
    //   block [0x82ED0A98..0x82ED0AB4)
	// 82ED0A98: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 82ED0A9C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED0AA0: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82ED0AA4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED0AA8: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED0AAC: 40990008  ble cr6, 0x82ed0ab4
	if !ctx.cr[6].gt {
	pc = 0x82ED0AB4; continue 'dispatch;
	}
	// 82ED0AB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82ED0AB4; continue 'dispatch;
            }
            0x82ED0AB4 => {
    //   block [0x82ED0AB4..0x82ED0AC4)
	// 82ED0AB4: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82ED0AB8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED0ABC: 41990008  bgt cr6, 0x82ed0ac4
	if ctx.cr[6].gt {
	pc = 0x82ED0AC4; continue 'dispatch;
	}
	// 82ED0AC0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82ED0AC4; continue 'dispatch;
            }
            0x82ED0AC4 => {
    //   block [0x82ED0AC4..0x82ED0AC8)
	// 82ED0AC4: 4B745E65  bl 0x82616928
	ctx.lr = 0x82ED0AC8;
	sub_82616928(ctx, base);
	pc = 0x82ED0AC8; continue 'dispatch;
            }
            0x82ED0AC8 => {
    //   block [0x82ED0AC8..0x82ED0AEC)
	// 82ED0AC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED0ACC: 419A0038  beq cr6, 0x82ed0b04
	if ctx.cr[6].eq {
	pc = 0x82ED0B04; continue 'dispatch;
	}
	// 82ED0AD0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 82ED0AD4: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ED0AD8: 357FFFFF  addic. r11, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0ADC: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82ED0AE0: 4180001C  blt 0x82ed0afc
	if ctx.cr[0].lt {
	pc = 0x82ED0AFC; continue 'dispatch;
	}
	// 82ED0AE4: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82ED0AE8: 39089B10  addi r8, r8, -0x64f0
	ctx.r[8].s64 = ctx.r[8].s64 + -25840;
	pc = 0x82ED0AEC; continue 'dispatch;
            }
            0x82ED0AEC => {
    //   block [0x82ED0AEC..0x82ED0AFC)
	// 82ED0AEC: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82ED0AF0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0AF4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82ED0AF8: 4080FFF4  bge 0x82ed0aec
	if !ctx.cr[0].lt {
	pc = 0x82ED0AEC; continue 'dispatch;
	}
	pc = 0x82ED0AFC; continue 'dispatch;
            }
            0x82ED0AFC => {
    //   block [0x82ED0AFC..0x82ED0B04)
	// 82ED0AFC: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 82ED0B00: 48000008  b 0x82ed0b08
	pc = 0x82ED0B08; continue 'dispatch;
            }
            0x82ED0B04 => {
    //   block [0x82ED0B04..0x82ED0B08)
	// 82ED0B04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82ED0B08; continue 'dispatch;
            }
            0x82ED0B08 => {
    //   block [0x82ED0B08..0x82ED0B20)
	// 82ED0B08: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED0B0C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ED0B10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED0B14: 40990034  ble cr6, 0x82ed0b48
	if !ctx.cr[6].gt {
	pc = 0x82ED0B48; continue 'dispatch;
	}
	// 82ED0B18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED0B1C: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	pc = 0x82ED0B20; continue 'dispatch;
            }
            0x82ED0B20 => {
    //   block [0x82ED0B20..0x82ED0B48)
	// 82ED0B20: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED0B24: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED0B28: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82ED0B2C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82ED0B30: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED0B34: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82ED0B38: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82ED0B3C: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED0B40: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82ED0B44: 4198FFDC  blt cr6, 0x82ed0b20
	if ctx.cr[6].lt {
	pc = 0x82ED0B20; continue 'dispatch;
	}
	pc = 0x82ED0B48; continue 'dispatch;
            }
            0x82ED0B48 => {
    //   block [0x82ED0B48..0x82ED0B80)
	// 82ED0B48: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED0B4C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0B50: 41820034  beq 0x82ed0b84
	if ctx.cr[0].eq {
	pc = 0x82ED0B84; continue 'dispatch;
	}
	// 82ED0B54: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82ED0B58: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ED0B5C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED0B60: 419A0020  beq cr6, 0x82ed0b80
	if ctx.cr[6].eq {
	pc = 0x82ED0B80; continue 'dispatch;
	}
	// 82ED0B64: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0B68: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82ED0B6C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82ED0B70: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0B74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED0B78: 4E800421  bctrl
	ctx.lr = 0x82ED0B7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED0B7C: 48000008  b 0x82ed0b84
	pc = 0x82ED0B84; continue 'dispatch;
            }
            0x82ED0B80 => {
    //   block [0x82ED0B80..0x82ED0B84)
	// 82ED0B80: 4B974C31  bl 0x828457b0
	ctx.lr = 0x82ED0B84;
	sub_828457B0(ctx, base);
	pc = 0x82ED0B84; continue 'dispatch;
            }
            0x82ED0B84 => {
    //   block [0x82ED0B84..0x82ED0B88)
	// 82ED0B84: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82ED0B88; continue 'dispatch;
            }
            0x82ED0B88 => {
    //   block [0x82ED0B88..0x82ED0BA0)
	// 82ED0B88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED0B8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED0B90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED0B94: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED0B98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED0B9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED0BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED0BA0 size=56
    let mut pc: u32 = 0x82ED0BA0;
    'dispatch: loop {
        match pc {
            0x82ED0BA0 => {
    //   block [0x82ED0BA0..0x82ED0BC4)
	// 82ED0BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED0BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED0BA8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED0BAC: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82ED0BB0: 4B745D79  bl 0x82616928
	ctx.lr = 0x82ED0BB4;
	sub_82616928(ctx, base);
	// 82ED0BB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0BB8: 4182000C  beq 0x82ed0bc4
	if ctx.cr[0].eq {
	pc = 0x82ED0BC4; continue 'dispatch;
	}
	// 82ED0BBC: 4BFFF9F5  bl 0x82ed05b0
	ctx.lr = 0x82ED0BC0;
	sub_82ED05B0(ctx, base);
	// 82ED0BC0: 48000008  b 0x82ed0bc8
	pc = 0x82ED0BC8; continue 'dispatch;
            }
            0x82ED0BC4 => {
    //   block [0x82ED0BC4..0x82ED0BC8)
	// 82ED0BC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ED0BC8; continue 'dispatch;
            }
            0x82ED0BC8 => {
    //   block [0x82ED0BC8..0x82ED0BD8)
	// 82ED0BC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED0BCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED0BD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED0BD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED0BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED0BD8 size=2380
    let mut pc: u32 = 0x82ED0BD8;
    'dispatch: loop {
        match pc {
            0x82ED0BD8 => {
    //   block [0x82ED0BD8..0x82ED0C34)
	// 82ED0BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED0BDC: 4BDD8809  bl 0x82ca93e4
	ctx.lr = 0x82ED0BE0;
	sub_82CA93D0(ctx, base);
	// 82ED0BE0: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 82ED0BE4: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED0BE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED0BEC: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ED0BF0: 3E7F0001  addis r19, r31, 1
	ctx.r[19].s64 = ctx.r[31].s64 + 65536;
	// 82ED0BF4: 615782A8  ori r23, r10, 0x82a8
	ctx.r[23].u64 = ctx.r[10].u64 | 33448;
	// 82ED0BF8: 3A7382AC  addi r19, r19, -0x7d54
	ctx.r[19].s64 = ctx.r[19].s64 + -32084;
	// 82ED0BFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ED0C00: 89730000  lbz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0C04: C3EA0C18  lfs f31, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ED0C08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0C0C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED0C10: 3B0BDAC0  addi r24, r11, -0x2540
	ctx.r[24].s64 = ctx.r[11].s64 + -9536;
	// 82ED0C14: 40820028  bne 0x82ed0c3c
	if !ctx.cr[0].eq {
	pc = 0x82ED0C3C; continue 'dispatch;
	}
	// 82ED0C18: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED0C1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED0C20: 419A0014  beq cr6, 0x82ed0c34
	if ctx.cr[6].eq {
	pc = 0x82ED0C34; continue 'dispatch;
	}
	// 82ED0C24: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED0C28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED0C2C: 4E800421  bctrl
	ctx.lr = 0x82ED0C30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED0C30: 48000008  b 0x82ed0c38
	pc = 0x82ED0C38; continue 'dispatch;
            }
            0x82ED0C34 => {
    //   block [0x82ED0C34..0x82ED0C38)
	// 82ED0C34: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x82ED0C38; continue 'dispatch;
            }
            0x82ED0C38 => {
    //   block [0x82ED0C38..0x82ED0C3C)
	// 82ED0C38: 7C3FBD2E  stfsx f1, r31, r23
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[23].u32), tmp.u32) };
	pc = 0x82ED0C3C; continue 'dispatch;
            }
            0x82ED0C3C => {
    //   block [0x82ED0C3C..0x82ED0C74)
	// 82ED0C3C: 3FDF0001  addis r30, r31, 1
	ctx.r[30].s64 = ctx.r[31].s64 + 65536;
	// 82ED0C40: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED0C44: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 82ED0C48: 3BDE84F8  addi r30, r30, -0x7b08
	ctx.r[30].s64 = ctx.r[30].s64 + -31496;
	// 82ED0C4C: 7E99A378  mr r25, r20
	ctx.r[25].u64 = ctx.r[20].u64;
	// 82ED0C50: 889E0000  lbz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0C54: 48005A55  bl 0x82ed66a8
	ctx.lr = 0x82ED0C58;
	sub_82ED66A8(ctx, base);
	// 82ED0C58: 889E0000  lbz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0C5C: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED0C60: 48005A49  bl 0x82ed66a8
	ctx.lr = 0x82ED0C64;
	sub_82ED66A8(ctx, base);
	// 82ED0C64: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 82ED0C68: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 82ED0C6C: 7EBAAB78  mr r26, r21
	ctx.r[26].u64 = ctx.r[21].u64;
	// 82ED0C70: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	pc = 0x82ED0C74; continue 'dispatch;
            }
            0x82ED0C74 => {
    //   block [0x82ED0C74..0x82ED0C88)
	// 82ED0C74: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0C78: 4082007C  bne 0x82ed0cf4
	if !ctx.cr[0].eq {
	pc = 0x82ED0CF4; continue 'dispatch;
	}
	// 82ED0C7C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82ED0C80: 409A0008  bne cr6, 0x82ed0c88
	if !ctx.cr[6].eq {
	pc = 0x82ED0C88; continue 'dispatch;
	}
	// 82ED0C84: 835F0034  lwz r26, 0x34(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	pc = 0x82ED0C88; continue 'dispatch;
            }
            0x82ED0C88 => {
    //   block [0x82ED0C88..0x82ED0C94)
	// 82ED0C88: 2B1B0001  cmplwi cr6, r27, 1
	ctx.cr[6].compare_u32(ctx.r[27].u32, 1 as u32, &mut ctx.xer);
	// 82ED0C8C: 409A0008  bne cr6, 0x82ed0c94
	if !ctx.cr[6].eq {
	pc = 0x82ED0C94; continue 'dispatch;
	}
	// 82ED0C90: 835F0030  lwz r26, 0x30(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	pc = 0x82ED0C94; continue 'dispatch;
            }
            0x82ED0C94 => {
    //   block [0x82ED0C94..0x82ED0CAC)
	// 82ED0C94: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ED0C98: 419A0050  beq cr6, 0x82ed0ce8
	if ctx.cr[6].eq {
	pc = 0x82ED0CE8; continue 'dispatch;
	}
	// 82ED0C9C: 83BA000C  lwz r29, 0xc(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED0CA0: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 82ED0CA4: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0CA8: 41820040  beq 0x82ed0ce8
	if ctx.cr[0].eq {
	pc = 0x82ED0CE8; continue 'dispatch;
	}
	pc = 0x82ED0CAC; continue 'dispatch;
            }
            0x82ED0CAC => {
    //   block [0x82ED0CAC..0x82ED0CDC)
	// 82ED0CAC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0CB0: 40820038  bne 0x82ed0ce8
	if !ctx.cr[0].eq {
	pc = 0x82ED0CE8; continue 'dispatch;
	}
	// 82ED0CB4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0CB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED0CBC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82ED0CC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED0CC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED0CC8: 4E800421  bctrl
	ctx.lr = 0x82ED0CCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED0CCC: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED0CD0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82ED0CD4: 409A0008  bne cr6, 0x82ed0cdc
	if !ctx.cr[6].eq {
	pc = 0x82ED0CDC; continue 'dispatch;
	}
	// 82ED0CD8: 7E9CA378  mr r28, r20
	ctx.r[28].u64 = ctx.r[20].u64;
            }
            0x82ED0CDC => {
    //   block [0x82ED0CDC..0x82ED0CE8)
	// 82ED0CDC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82ED0CE0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82ED0CE4: 4198FFC8  blt cr6, 0x82ed0cac
	if ctx.cr[6].lt {
	pc = 0x82ED0CAC; continue 'dispatch;
	}
	pc = 0x82ED0CE8; continue 'dispatch;
            }
            0x82ED0CE8 => {
    //   block [0x82ED0CE8..0x82ED0CF4)
	// 82ED0CE8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82ED0CEC: 2B1B0002  cmplwi cr6, r27, 2
	ctx.cr[6].compare_u32(ctx.r[27].u32, 2 as u32, &mut ctx.xer);
	// 82ED0CF0: 4198FF84  blt cr6, 0x82ed0c74
	if ctx.cr[6].lt {
	pc = 0x82ED0C74; continue 'dispatch;
	}
	pc = 0x82ED0CF4; continue 'dispatch;
            }
            0x82ED0CF4 => {
    //   block [0x82ED0CF4..0x82ED0D04)
	// 82ED0CF4: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0CF8: 408201C8  bne 0x82ed0ec0
	if !ctx.cr[0].eq {
	pc = 0x82ED0EC0; continue 'dispatch;
	}
	// 82ED0CFC: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 82ED0D00: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	pc = 0x82ED0D04; continue 'dispatch;
            }
            0x82ED0D04 => {
    //   block [0x82ED0D04..0x82ED0D10)
	// 82ED0D04: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82ED0D08: 409A0008  bne cr6, 0x82ed0d10
	if !ctx.cr[6].eq {
	pc = 0x82ED0D10; continue 'dispatch;
	}
	// 82ED0D0C: 835F0034  lwz r26, 0x34(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	pc = 0x82ED0D10; continue 'dispatch;
            }
            0x82ED0D10 => {
    //   block [0x82ED0D10..0x82ED0D1C)
	// 82ED0D10: 2B1B0001  cmplwi cr6, r27, 1
	ctx.cr[6].compare_u32(ctx.r[27].u32, 1 as u32, &mut ctx.xer);
	// 82ED0D14: 409A0008  bne cr6, 0x82ed0d1c
	if !ctx.cr[6].eq {
	pc = 0x82ED0D1C; continue 'dispatch;
	}
	// 82ED0D18: 835F0030  lwz r26, 0x30(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	pc = 0x82ED0D1C; continue 'dispatch;
            }
            0x82ED0D1C => {
    //   block [0x82ED0D1C..0x82ED0D34)
	// 82ED0D1C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ED0D20: 419A0060  beq cr6, 0x82ed0d80
	if ctx.cr[6].eq {
	pc = 0x82ED0D80; continue 'dispatch;
	}
	// 82ED0D24: 839A000C  lwz r28, 0xc(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED0D28: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	// 82ED0D2C: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0D30: 41820050  beq 0x82ed0d80
	if ctx.cr[0].eq {
	pc = 0x82ED0D80; continue 'dispatch;
	}
	pc = 0x82ED0D34; continue 'dispatch;
            }
            0x82ED0D34 => {
    //   block [0x82ED0D34..0x82ED0D70)
	// 82ED0D34: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0D38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ED0D3C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82ED0D40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED0D44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED0D48: 4E800421  bctrl
	ctx.lr = 0x82ED0D4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED0D4C: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED0D50: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED0D54: 409A0020  bne cr6, 0x82ed0d74
	if !ctx.cr[6].eq {
	pc = 0x82ED0D74; continue 'dispatch;
	}
	// 82ED0D58: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ED0D5C: 419A0014  beq cr6, 0x82ed0d70
	if ctx.cr[6].eq {
	pc = 0x82ED0D70; continue 'dispatch;
	}
	// 82ED0D60: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED0D64: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED0D68: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82ED0D6C: 40990008  ble cr6, 0x82ed0d74
	if !ctx.cr[6].gt {
	pc = 0x82ED0D74; continue 'dispatch;
	}
            }
            0x82ED0D70 => {
    //   block [0x82ED0D70..0x82ED0D74)
	// 82ED0D70: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	pc = 0x82ED0D74; continue 'dispatch;
            }
            0x82ED0D74 => {
    //   block [0x82ED0D74..0x82ED0D80)
	// 82ED0D74: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82ED0D78: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82ED0D7C: 4198FFB8  blt cr6, 0x82ed0d34
	if ctx.cr[6].lt {
	pc = 0x82ED0D34; continue 'dispatch;
	}
	pc = 0x82ED0D80; continue 'dispatch;
            }
            0x82ED0D80 => {
    //   block [0x82ED0D80..0x82ED0E00)
	// 82ED0D80: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82ED0D84: 2B1B0002  cmplwi cr6, r27, 2
	ctx.cr[6].compare_u32(ctx.r[27].u32, 2 as u32, &mut ctx.xer);
	// 82ED0D88: 4198FF7C  blt cr6, 0x82ed0d04
	if ctx.cr[6].lt {
	pc = 0x82ED0D04; continue 'dispatch;
	}
	// 82ED0D8C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ED0D90: 419A0130  beq cr6, 0x82ed0ec0
	if ctx.cr[6].eq {
	pc = 0x82ED0EC0; continue 'dispatch;
	}
	// 82ED0D94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED0D98: 387F0214  addi r3, r31, 0x214
	ctx.r[3].s64 = ctx.r[31].s64 + 532;
	// 82ED0D9C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82ED0DA0: 4BDDBDB1  bl 0x82cacb50
	ctx.lr = 0x82ED0DA4;
	sub_82CACB50(ctx, base);
	// 82ED0DA4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED0DA8: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82ED0DAC: 408200A0  bne 0x82ed0e4c
	if !ctx.cr[0].eq {
	pc = 0x82ED0E4C; continue 'dispatch;
	}
	// 82ED0DB0: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82ED0DB4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0DB8: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED0DBC: 4182007C  beq 0x82ed0e38
	if ctx.cr[0].eq {
	pc = 0x82ED0E38; continue 'dispatch;
	}
	// 82ED0DC0: 3B9E0024  addi r28, r30, 0x24
	ctx.r[28].s64 = ctx.r[30].s64 + 36;
	// 82ED0DC4: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 82ED0DC8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82ED0DCC: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED0DD0: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82ED0DD4: 80EB0028  lwz r7, 0x28(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED0DD8: 80AB0020  lwz r5, 0x20(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED0DDC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0DE0: 4821D179  bl 0x830edf58
	ctx.lr = 0x82ED0DE4;
	sub_830EDF58(ctx, base);
	// 82ED0DE4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ED0DE8: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82ED0DEC: 409A0014  bne cr6, 0x82ed0e00
	if !ctx.cr[6].eq {
	pc = 0x82ED0E00; continue 'dispatch;
	}
	// 82ED0DF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED0DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED0DF8: 4BFFCF29  bl 0x82ecdd20
	ctx.lr = 0x82ED0DFC;
	sub_82ECDD20(ctx, base);
	// 82ED0DFC: 480000C4  b 0x82ed0ec0
	pc = 0x82ED0EC0; continue 'dispatch;
            }
            0x82ED0E00 => {
    //   block [0x82ED0E00..0x82ED0E38)
	// 82ED0E00: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0E04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED0E08: 419A00A8  beq cr6, 0x82ed0eb0
	if ctx.cr[6].eq {
	pc = 0x82ED0EB0; continue 'dispatch;
	}
	// 82ED0E0C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0E10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED0E14: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED0E18: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED0E1C: 915E0014  stw r10, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82ED0E20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED0E24: 4E800421  bctrl
	ctx.lr = 0x82ED0E28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED0E28: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED0E2C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED0E30: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82ED0E34: 4800007C  b 0x82ed0eb0
	pc = 0x82ED0EB0; continue 'dispatch;
            }
            0x82ED0E38 => {
    //   block [0x82ED0E38..0x82ED0E4C)
	// 82ED0E38: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED0E3C: 80EB0028  lwz r7, 0x28(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED0E40: 80AB0020  lwz r5, 0x20(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED0E44: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED0E48: 48000044  b 0x82ed0e8c
	pc = 0x82ED0E8C; continue 'dispatch;
            }
            0x82ED0E4C => {
    //   block [0x82ED0E4C..0x82ED0E80)
	// 82ED0E4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED0E50: C1BF0178  lfs f13, 0x178(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED0E54: 815F017C  lwz r10, 0x17c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED0E58: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ED0E5C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82ED0E60: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED0E64: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED0E68: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED0E6C: 808B0024  lwz r4, 0x24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED0E70: 80AB0020  lwz r5, 0x20(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED0E74: 409A000C  bne cr6, 0x82ed0e80
	if !ctx.cr[6].eq {
	pc = 0x82ED0E80; continue 'dispatch;
	}
	// 82ED0E78: 1D4A0028  mulli r10, r10, 0x28
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 40 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED0E7C: 48000008  b 0x82ed0e84
	pc = 0x82ED0E84; continue 'dispatch;
            }
            0x82ED0E80 => {
    //   block [0x82ED0E80..0x82ED0E84)
	// 82ED0E80: 1D4A0030  mulli r10, r10, 0x30
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 48 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	pc = 0x82ED0E84; continue 'dispatch;
            }
            0x82ED0E84 => {
    //   block [0x82ED0E84..0x82ED0E8C)
	// 82ED0E84: 7D6A2214  add r11, r10, r4
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 82ED0E88: 388B0084  addi r4, r11, 0x84
	ctx.r[4].s64 = ctx.r[11].s64 + 132;
	pc = 0x82ED0E8C; continue 'dispatch;
            }
            0x82ED0E8C => {
    //   block [0x82ED0E8C..0x82ED0EB0)
	// 82ED0E8C: 393E0024  addi r9, r30, 0x24
	ctx.r[9].s64 = ctx.r[30].s64 + 36;
	// 82ED0E90: 80DE0014  lwz r6, 0x14(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED0E94: 4821D0C5  bl 0x830edf58
	ctx.lr = 0x82ED0E98;
	sub_830EDF58(ctx, base);
	// 82ED0E98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ED0E9C: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82ED0EA0: 409A0018  bne cr6, 0x82ed0eb8
	if !ctx.cr[6].eq {
	pc = 0x82ED0EB8; continue 'dispatch;
	}
	// 82ED0EA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED0EA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED0EAC: 4BFFCE75  bl 0x82ecdd20
	ctx.lr = 0x82ED0EB0;
	sub_82ECDD20(ctx, base);
	pc = 0x82ED0EB0; continue 'dispatch;
            }
            0x82ED0EB0 => {
    //   block [0x82ED0EB0..0x82ED0EB8)
	// 82ED0EB0: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82ED0EB4: 419A000C  beq cr6, 0x82ed0ec0
	if ctx.cr[6].eq {
	pc = 0x82ED0EC0; continue 'dispatch;
	}
	pc = 0x82ED0EB8; continue 'dispatch;
            }
            0x82ED0EB8 => {
    //   block [0x82ED0EB8..0x82ED0EC0)
	// 82ED0EB8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82ED0EBC: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED0EC0; continue 'dispatch;
            }
            0x82ED0EC0 => {
    //   block [0x82ED0EC0..0x82ED0EDC)
	// 82ED0EC0: 817F014C  lwz r11, 0x14c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82ED0EC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED0EC8: 419A0014  beq cr6, 0x82ed0edc
	if ctx.cr[6].eq {
	pc = 0x82ED0EDC; continue 'dispatch;
	}
	// 82ED0ECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED0ED0: 4BFFF229  bl 0x82ed00f8
	ctx.lr = 0x82ED0ED4;
	sub_82ED00F8(ctx, base);
	// 82ED0ED4: 7EB9AB78  mr r25, r21
	ctx.r[25].u64 = ctx.r[21].u64;
	// 82ED0ED8: 480000B8  b 0x82ed0f90
	pc = 0x82ED0F90; continue 'dispatch;
            }
            0x82ED0EDC => {
    //   block [0x82ED0EDC..0x82ED0F20)
	// 82ED0EDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ED0EE0: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED0EE4: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 82ED0EE8: 48005749  bl 0x82ed6630
	ctx.lr = 0x82ED0EEC;
	sub_82ED6630(ctx, base);
	// 82ED0EEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0EF0: 907F014C  stw r3, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[3].u32 ) };
	// 82ED0EF4: 4182002C  beq 0x82ed0f20
	if ctx.cr[0].eq {
	pc = 0x82ED0F20; continue 'dispatch;
	}
	// 82ED0EF8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED0EFC: 92BF0158  stw r21, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[21].u32 ) };
	// 82ED0F00: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0F04: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 82ED0F08: 4080006C  bge 0x82ed0f74
	if !ctx.cr[0].lt {
	pc = 0x82ED0F74; continue 'dispatch;
	}
	// 82ED0F0C: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED0F10: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED0F14: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82ED0F18: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 82ED0F1C: 48000058  b 0x82ed0f74
	pc = 0x82ED0F74; continue 'dispatch;
            }
            0x82ED0F20 => {
    //   block [0x82ED0F20..0x82ED0F54)
	// 82ED0F20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ED0F24: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED0F28: 48005709  bl 0x82ed6630
	ctx.lr = 0x82ED0F2C;
	sub_82ED6630(ctx, base);
	// 82ED0F2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0F30: 907F014C  stw r3, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[3].u32 ) };
	// 82ED0F34: 41820040  beq 0x82ed0f74
	if ctx.cr[0].eq {
	pc = 0x82ED0F74; continue 'dispatch;
	}
	// 82ED0F38: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED0F3C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED0F40: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED0F44: 40990010  ble cr6, 0x82ed0f54
	if !ctx.cr[6].gt {
	pc = 0x82ED0F54; continue 'dispatch;
	}
	// 82ED0F48: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED0F4C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED0F50: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED0F54; continue 'dispatch;
            }
            0x82ED0F54 => {
    //   block [0x82ED0F54..0x82ED0F74)
	// 82ED0F54: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED0F58: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0F5C: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 82ED0F60: 40800014  bge 0x82ed0f74
	if !ctx.cr[0].lt {
	pc = 0x82ED0F74; continue 'dispatch;
	}
	// 82ED0F64: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED0F68: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED0F6C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82ED0F70: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED0F74; continue 'dispatch;
            }
            0x82ED0F74 => {
    //   block [0x82ED0F74..0x82ED0F90)
	// 82ED0F74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED0F78: 419A0018  beq cr6, 0x82ed0f90
	if ctx.cr[6].eq {
	pc = 0x82ED0F90; continue 'dispatch;
	}
	// 82ED0F7C: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ED0F80: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82ED0F84: 614A82A4  ori r10, r10, 0x82a4
	ctx.r[10].u64 = ctx.r[10].u64 | 33444;
	// 82ED0F88: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82ED0F8C: 7EBF512E  stwx r21, r31, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[21].u32) };
	pc = 0x82ED0F90; continue 'dispatch;
            }
            0x82ED0F90 => {
    //   block [0x82ED0F90..0x82ED0FD4)
	// 82ED0F90: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 82ED0F94: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED0F98: 409A00B0  bne cr6, 0x82ed1048
	if !ctx.cr[6].eq {
	pc = 0x82ED1048; continue 'dispatch;
	}
	// 82ED0F9C: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82ED0FA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED0FA4: 409A008C  bne cr6, 0x82ed1030
	if !ctx.cr[6].eq {
	pc = 0x82ED1030; continue 'dispatch;
	}
	// 82ED0FA8: 817F014C  lwz r11, 0x14c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82ED0FAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED0FB0: 409A0080  bne cr6, 0x82ed1030
	if !ctx.cr[6].eq {
	pc = 0x82ED1030; continue 'dispatch;
	}
	// 82ED0FB4: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED0FB8: 48005601  bl 0x82ed65b8
	ctx.lr = 0x82ED0FBC;
	sub_82ED65B8(ctx, base);
	// 82ED0FBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0FC0: 907F0160  stw r3, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[3].u32 ) };
	// 82ED0FC4: 40820010  bne 0x82ed0fd4
	if !ctx.cr[0].eq {
	pc = 0x82ED0FD4; continue 'dispatch;
	}
	// 82ED0FC8: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED0FCC: 480055ED  bl 0x82ed65b8
	ctx.lr = 0x82ED0FD0;
	sub_82ED65B8(ctx, base);
	// 82ED0FD0: 907F0160  stw r3, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[3].u32 ) };
	pc = 0x82ED0FD4; continue 'dispatch;
            }
            0x82ED0FD4 => {
    //   block [0x82ED0FD4..0x82ED0FFC)
	// 82ED0FD4: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82ED0FD8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED0FDC: 41820054  beq 0x82ed1030
	if ctx.cr[0].eq {
	pc = 0x82ED1030; continue 'dispatch;
	}
	// 82ED0FE0: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82ED0FE4: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	// 82ED0FE8: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82ED0FEC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED0FF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED0FF4: 4099003C  ble cr6, 0x82ed1030
	if !ctx.cr[6].gt {
	pc = 0x82ED1030; continue 'dispatch;
	}
	// 82ED0FF8: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	pc = 0x82ED0FFC; continue 'dispatch;
            }
            0x82ED0FFC => {
    //   block [0x82ED0FFC..0x82ED1030)
	// 82ED0FFC: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED1000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED1004: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED1008: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82ED100C: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED1010: 7CBE502E  lwzx r5, r30, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ED1014: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED1018: 4E800421  bctrl
	ctx.lr = 0x82ED101C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED101C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED1020: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82ED1024: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82ED1028: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82ED102C: 4198FFD0  blt cr6, 0x82ed0ffc
	if ctx.cr[6].lt {
	pc = 0x82ED0FFC; continue 'dispatch;
	}
            }
            0x82ED1030 => {
    //   block [0x82ED1030..0x82ED1048)
	// 82ED1030: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82ED1034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED1038: 419A0010  beq cr6, 0x82ed1048
	if ctx.cr[6].eq {
	pc = 0x82ED1048; continue 'dispatch;
	}
	// 82ED103C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED1040: 4BFFC7F9  bl 0x82ecd838
	ctx.lr = 0x82ED1044;
	sub_82ECD838(ctx, base);
	// 82ED1044: 7EB9AB78  mr r25, r21
	ctx.r[25].u64 = ctx.r[21].u64;
	pc = 0x82ED1048; continue 'dispatch;
            }
            0x82ED1048 => {
    //   block [0x82ED1048..0x82ED1060)
	// 82ED1048: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ED104C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82ED1050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED1054: 40990070  ble cr6, 0x82ed10c4
	if !ctx.cr[6].gt {
	pc = 0x82ED10C4; continue 'dispatch;
	}
	// 82ED1058: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ED105C: 811F0210  lwz r8, 0x210(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	pc = 0x82ED1060; continue 'dispatch;
            }
            0x82ED1060 => {
    //   block [0x82ED1060..0x82ED10A4)
	// 82ED1060: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED1064: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1068: 40820040  bne 0x82ed10a8
	if !ctx.cr[0].eq {
	pc = 0x82ED10A8; continue 'dispatch;
	}
	// 82ED106C: 894B0030  lbz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED1070: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1074: 41820034  beq 0x82ed10a8
	if ctx.cr[0].eq {
	pc = 0x82ED10A8; continue 'dispatch;
	}
	// 82ED1078: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82ED107C: 419A0028  beq cr6, 0x82ed10a4
	if ctx.cr[6].eq {
	pc = 0x82ED10A4; continue 'dispatch;
	}
	// 82ED1080: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED1084: 81240020  lwz r9, 0x20(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED1088: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82ED108C: 41990018  bgt cr6, 0x82ed10a4
	if ctx.cr[6].gt {
	pc = 0x82ED10A4; continue 'dispatch;
	}
	// 82ED1090: 409A0018  bne cr6, 0x82ed10a8
	if !ctx.cr[6].eq {
	pc = 0x82ED10A8; continue 'dispatch;
	}
	// 82ED1094: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ED1098: 81240044  lwz r9, 0x44(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ED109C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ED10A0: 40990008  ble cr6, 0x82ed10a8
	if !ctx.cr[6].gt {
	pc = 0x82ED10A8; continue 'dispatch;
	}
	pc = 0x82ED10A4; continue 'dispatch;
            }
            0x82ED10A4 => {
    //   block [0x82ED10A4..0x82ED10A8)
	// 82ED10A4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	pc = 0x82ED10A8; continue 'dispatch;
            }
            0x82ED10A8 => {
    //   block [0x82ED10A8..0x82ED10C4)
	// 82ED10A8: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82ED10AC: 396B004C  addi r11, r11, 0x4c
	ctx.r[11].s64 = ctx.r[11].s64 + 76;
	// 82ED10B0: 4082FFB0  bne 0x82ed1060
	if !ctx.cr[0].eq {
	pc = 0x82ED1060; continue 'dispatch;
	}
	// 82ED10B4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82ED10B8: 419A000C  beq cr6, 0x82ed10c4
	if ctx.cr[6].eq {
	pc = 0x82ED10C4; continue 'dispatch;
	}
	// 82ED10BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED10C0: 4BFFE931  bl 0x82ecf9f0
	ctx.lr = 0x82ED10C4;
	sub_82ECF9F0(ctx, base);
	pc = 0x82ED10C4; continue 'dispatch;
            }
            0x82ED10C4 => {
    //   block [0x82ED10C4..0x82ED10FC)
	// 82ED10C4: 897F0168  lbz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82ED10C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED10CC: 418201A4  beq 0x82ed1270
	if ctx.cr[0].eq {
	pc = 0x82ED1270; continue 'dispatch;
	}
	// 82ED10D0: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED10D4: 616B84D8  ori r11, r11, 0x84d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34008;
	// 82ED10D8: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED10DC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED10E0: 419A0190  beq cr6, 0x82ed1270
	if ctx.cr[6].eq {
	pc = 0x82ED1270; continue 'dispatch;
	}
	// 82ED10E4: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED10E8: 41820014  beq 0x82ed10fc
	if ctx.cr[0].eq {
	pc = 0x82ED10FC; continue 'dispatch;
	}
	// 82ED10EC: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82ED10F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED10F4: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 82ED10F8: 48000008  b 0x82ed1100
	pc = 0x82ED1100; continue 'dispatch;
            }
            0x82ED10FC => {
    //   block [0x82ED10FC..0x82ED1100)
	// 82ED10FC: 92BF016C  stw r21, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[21].u32 ) };
	pc = 0x82ED1100; continue 'dispatch;
            }
            0x82ED1100 => {
    //   block [0x82ED1100..0x82ED1114)
	// 82ED1100: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82ED1104: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 82ED1108: 40990168  ble cr6, 0x82ed1270
	if !ctx.cr[6].gt {
	pc = 0x82ED1270; continue 'dispatch;
	}
	// 82ED110C: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 82ED1110: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	pc = 0x82ED1114; continue 'dispatch;
            }
            0x82ED1114 => {
    //   block [0x82ED1114..0x82ED1128)
	// 82ED1114: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED1118: 40820154  bne 0x82ed126c
	if !ctx.cr[0].eq {
	pc = 0x82ED126C; continue 'dispatch;
	}
	// 82ED111C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82ED1120: 409A0008  bne cr6, 0x82ed1128
	if !ctx.cr[6].eq {
	pc = 0x82ED1128; continue 'dispatch;
	}
	// 82ED1124: 835F0034  lwz r26, 0x34(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	pc = 0x82ED1128; continue 'dispatch;
            }
            0x82ED1128 => {
    //   block [0x82ED1128..0x82ED1134)
	// 82ED1128: 2B1B0001  cmplwi cr6, r27, 1
	ctx.cr[6].compare_u32(ctx.r[27].u32, 1 as u32, &mut ctx.xer);
	// 82ED112C: 409A0008  bne cr6, 0x82ed1134
	if !ctx.cr[6].eq {
	pc = 0x82ED1134; continue 'dispatch;
	}
	// 82ED1130: 835F0030  lwz r26, 0x30(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	pc = 0x82ED1134; continue 'dispatch;
            }
            0x82ED1134 => {
    //   block [0x82ED1134..0x82ED114C)
	// 82ED1134: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ED1138: 419A0128  beq cr6, 0x82ed1260
	if ctx.cr[6].eq {
	pc = 0x82ED1260; continue 'dispatch;
	}
	// 82ED113C: 839A000C  lwz r28, 0xc(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED1140: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	// 82ED1144: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1148: 41820118  beq 0x82ed1260
	if ctx.cr[0].eq {
	pc = 0x82ED1260; continue 'dispatch;
	}
	pc = 0x82ED114C; continue 'dispatch;
            }
            0x82ED114C => {
    //   block [0x82ED114C..0x82ED119C)
	// 82ED114C: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED1150: 40820110  bne 0x82ed1260
	if !ctx.cr[0].eq {
	pc = 0x82ED1260; continue 'dispatch;
	}
	// 82ED1154: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED1158: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ED115C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82ED1160: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED1164: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED1168: 4E800421  bctrl
	ctx.lr = 0x82ED116C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED116C: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED1170: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED1174: 409A00E0  bne cr6, 0x82ed1254
	if !ctx.cr[6].eq {
	pc = 0x82ED1254; continue 'dispatch;
	}
	// 82ED1178: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED117C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82ED1180: 409A00D4  bne cr6, 0x82ed1254
	if !ctx.cr[6].eq {
	pc = 0x82ED1254; continue 'dispatch;
	}
	// 82ED1184: 811F0210  lwz r8, 0x210(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ED1188: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 82ED118C: 7EA9AB78  mr r9, r21
	ctx.r[9].u64 = ctx.r[21].u64;
	// 82ED1190: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1194: 41820054  beq 0x82ed11e8
	if ctx.cr[0].eq {
	pc = 0x82ED11E8; continue 'dispatch;
	}
	// 82ED1198: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
            }
            0x82ED119C => {
    //   block [0x82ED119C..0x82ED11D4)
	// 82ED119C: 54EB063F  clrlwi. r11, r7, 0x18
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED11A0: 41820048  beq 0x82ed11e8
	if ctx.cr[0].eq {
	pc = 0x82ED11E8; continue 'dispatch;
	}
	// 82ED11A4: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ED11A8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED11AC: 88CB0010  lbz r6, 0x10(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED11B0: 28060000  cmplwi r6, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED11B4: 40820020  bne 0x82ed11d4
	if !ctx.cr[0].eq {
	pc = 0x82ED11D4; continue 'dispatch;
	}
	// 82ED11B8: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED11BC: 7F061840  cmplw cr6, r6, r3
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82ED11C0: 409A0014  bne cr6, 0x82ed11d4
	if !ctx.cr[6].eq {
	pc = 0x82ED11D4; continue 'dispatch;
	}
	// 82ED11C4: 896B0039  lbz r11, 0x39(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 82ED11C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED11CC: 40820008  bne 0x82ed11d4
	if !ctx.cr[0].eq {
	pc = 0x82ED11D4; continue 'dispatch;
	}
	// 82ED11D0: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	pc = 0x82ED11D4; continue 'dispatch;
            }
            0x82ED11D4 => {
    //   block [0x82ED11D4..0x82ED11E8)
	// 82ED11D4: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ED11D8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED11DC: 394A004C  addi r10, r10, 0x4c
	ctx.r[10].s64 = ctx.r[10].s64 + 76;
	// 82ED11E0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED11E4: 4198FFB8  blt cr6, 0x82ed119c
	if ctx.cr[6].lt {
	pc = 0x82ED119C; continue 'dispatch;
	}
	pc = 0x82ED11E8; continue 'dispatch;
            }
            0x82ED11E8 => {
    //   block [0x82ED11E8..0x82ED1200)
	// 82ED11E8: 54EB063F  clrlwi. r11, r7, 0x18
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED11EC: 41820068  beq 0x82ed1254
	if ctx.cr[0].eq {
	pc = 0x82ED1254; continue 'dispatch;
	}
	// 82ED11F0: 7EA9AB78  mr r9, r21
	ctx.r[9].u64 = ctx.r[21].u64;
	// 82ED11F4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82ED11F8: 419A004C  beq cr6, 0x82ed1244
	if ctx.cr[6].eq {
	pc = 0x82ED1244; continue 'dispatch;
	}
	// 82ED11FC: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x82ED1200; continue 'dispatch;
            }
            0x82ED1200 => {
    //   block [0x82ED1200..0x82ED1230)
	// 82ED1200: 815F0164  lwz r10, 0x164(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ED1204: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED1208: 890A0010  lbz r8, 0x10(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED120C: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1210: 40820020  bne 0x82ed1230
	if !ctx.cr[0].eq {
	pc = 0x82ED1230; continue 'dispatch;
	}
	// 82ED1214: 810A0014  lwz r8, 0x14(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED1218: 7F081840  cmplw cr6, r8, r3
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82ED121C: 409A0014  bne cr6, 0x82ed1230
	if !ctx.cr[6].eq {
	pc = 0x82ED1230; continue 'dispatch;
	}
	// 82ED1220: 9A8A0010  stb r20, 0x10(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[20].u8 ) };
	// 82ED1224: 815F0164  lwz r10, 0x164(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ED1228: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED122C: 9AAA0039  stb r21, 0x39(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(57 as u32), ctx.r[21].u8 ) };
	pc = 0x82ED1230; continue 'dispatch;
            }
            0x82ED1230 => {
    //   block [0x82ED1230..0x82ED1244)
	// 82ED1230: 815F0210  lwz r10, 0x210(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ED1234: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED1238: 396B004C  addi r11, r11, 0x4c
	ctx.r[11].s64 = ctx.r[11].s64 + 76;
	// 82ED123C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED1240: 4198FFC0  blt cr6, 0x82ed1200
	if ctx.cr[6].lt {
	pc = 0x82ED1200; continue 'dispatch;
	}
	pc = 0x82ED1244; continue 'dispatch;
            }
            0x82ED1244 => {
    //   block [0x82ED1244..0x82ED1254)
	// 82ED1244: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82ED1248: 92A3000C  stw r21, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[21].u32 ) };
	// 82ED124C: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	// 82ED1250: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED1254; continue 'dispatch;
            }
            0x82ED1254 => {
    //   block [0x82ED1254..0x82ED1260)
	// 82ED1254: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82ED1258: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82ED125C: 4198FEF0  blt cr6, 0x82ed114c
	if ctx.cr[6].lt {
	pc = 0x82ED114C; continue 'dispatch;
	}
	pc = 0x82ED1260; continue 'dispatch;
            }
            0x82ED1260 => {
    //   block [0x82ED1260..0x82ED126C)
	// 82ED1260: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82ED1264: 2B1B0002  cmplwi cr6, r27, 2
	ctx.cr[6].compare_u32(ctx.r[27].u32, 2 as u32, &mut ctx.xer);
	// 82ED1268: 4198FEAC  blt cr6, 0x82ed1114
	if ctx.cr[6].lt {
	pc = 0x82ED1114; continue 'dispatch;
	}
	pc = 0x82ED126C; continue 'dispatch;
            }
            0x82ED126C => {
    //   block [0x82ED126C..0x82ED1270)
	// 82ED126C: 92BF016C  stw r21, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[21].u32 ) };
	pc = 0x82ED1270; continue 'dispatch;
            }
            0x82ED1270 => {
    //   block [0x82ED1270..0x82ED128C)
	// 82ED1270: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED1274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED1278: 419A0014  beq cr6, 0x82ed128c
	if ctx.cr[6].eq {
	pc = 0x82ED128C; continue 'dispatch;
	}
	// 82ED127C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED1280: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED1284: 4E800421  bctrl
	ctx.lr = 0x82ED1288;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED1288: 48000008  b 0x82ed1290
	pc = 0x82ED1290; continue 'dispatch;
            }
            0x82ED128C => {
    //   block [0x82ED128C..0x82ED1290)
	// 82ED128C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x82ED1290; continue 'dispatch;
            }
            0x82ED1290 => {
    //   block [0x82ED1290..0x82ED12D8)
	// 82ED1290: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED1294: 7C1FBC2E  lfsx f0, r31, r23
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[23].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED1298: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED129C: 572A063F  clrlwi. r10, r25, 0x18
	ctx.r[10].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED12A0: 616B82B8  ori r11, r11, 0x82b8
	ctx.r[11].u64 = ctx.r[11].u64 | 33464;
	// 82ED12A4: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 82ED12A8: 7C1F5D2E  stfsx f0, r31, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82ED12AC: 40820044  bne 0x82ed12f0
	if !ctx.cr[0].eq {
	pc = 0x82ED12F0; continue 'dispatch;
	}
	// 82ED12B0: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED12B4: 616B84F0  ori r11, r11, 0x84f0
	ctx.r[11].u64 = ctx.r[11].u64 | 34032;
	// 82ED12B8: 7FBF582E  lwzx r29, r31, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED12BC: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82ED12C0: 409A0018  bne cr6, 0x82ed12d8
	if !ctx.cr[6].eq {
	pc = 0x82ED12D8; continue 'dispatch;
	}
	// 82ED12C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED12C8: C1AB0A8C  lfs f13, 0xa8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2700 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED12CC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED12D0: 40980020  bge cr6, 0x82ed12f0
	if !ctx.cr[6].lt {
	pc = 0x82ED12F0; continue 'dispatch;
	}
	// 82ED12D4: 48000018  b 0x82ed12ec
	pc = 0x82ED12EC; continue 'dispatch;
            }
            0x82ED12D8 => {
    //   block [0x82ED12D8..0x82ED12EC)
	// 82ED12D8: 4B38F6E1  bl 0x822609b8
	ctx.lr = 0x82ED12DC;
	sub_822609B8(ctx, base);
	// 82ED12DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ED12E0: 4BFFB359  bl 0x82ecc638
	ctx.lr = 0x82ED12E4;
	sub_82ECC638(ctx, base);
	// 82ED12E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED12E8: 41820008  beq 0x82ed12f0
	if ctx.cr[0].eq {
	pc = 0x82ED12F0; continue 'dispatch;
	}
	pc = 0x82ED12EC; continue 'dispatch;
            }
            0x82ED12EC => {
    //   block [0x82ED12EC..0x82ED12F0)
	// 82ED12EC: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	pc = 0x82ED12F0; continue 'dispatch;
            }
            0x82ED12F0 => {
    //   block [0x82ED12F0..0x82ED132C)
	// 82ED12F0: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ED12F4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED12F8: 615682B0  ori r22, r10, 0x82b0
	ctx.r[22].u64 = ctx.r[10].u64 | 33456;
	// 82ED12FC: 41820038  beq 0x82ed1334
	if ctx.cr[0].eq {
	pc = 0x82ED1334; continue 'dispatch;
	}
	// 82ED1300: 7D5FB214  add r10, r31, r22
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[22].u64;
	// 82ED1304: 9A930000  stb r20, 0(r19)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[19].u32.wrapping_add(0 as u32), ctx.r[20].u8 ) };
	// 82ED1308: 3D3F0001  addis r9, r31, 1
	ctx.r[9].s64 = ctx.r[31].s64 + 65536;
	// 82ED130C: 392982B4  addi r9, r9, -0x7d4c
	ctx.r[9].s64 = ctx.r[9].s64 + -32076;
	// 82ED1310: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED1314: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED1318: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED131C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82ED1320: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED1324: 40990008  ble cr6, 0x82ed132c
	if !ctx.cr[6].gt {
	pc = 0x82ED132C; continue 'dispatch;
	}
	// 82ED1328: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED132C; continue 'dispatch;
            }
            0x82ED132C => {
    //   block [0x82ED132C..0x82ED1334)
	// 82ED132C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED1330: 4BFFF8A9  bl 0x82ed0bd8
	ctx.lr = 0x82ED1334;
	sub_82ED0BD8(ctx, base);
	pc = 0x82ED1334; continue 'dispatch;
            }
            0x82ED1334 => {
    //   block [0x82ED1334..0x82ED1380)
	// 82ED1334: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED1338: 48004781  bl 0x82ed5ab8
	ctx.lr = 0x82ED133C;
	sub_82ED5AB8(ctx, base);
	// 82ED133C: 897F0040  lbz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED1340: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1344: 418201CC  beq 0x82ed1510
	if ctx.cr[0].eq {
	pc = 0x82ED1510; continue 'dispatch;
	}
	// 82ED1348: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ED134C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED1350: 615984E0  ori r25, r10, 0x84e0
	ctx.r[25].u64 = ctx.r[10].u64 | 34016;
	// 82ED1354: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82ED1358: 3B0A9128  addi r24, r10, -0x6ed8
	ctx.r[24].s64 = ctx.r[10].s64 + -28376;
	// 82ED135C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED1360: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82ED1364: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1368: 3AEAAFB4  addi r23, r10, -0x504c
	ctx.r[23].s64 = ctx.r[10].s64 + -20556;
	// 82ED136C: 418200B8  beq 0x82ed1424
	if ctx.cr[0].eq {
	pc = 0x82ED1424; continue 'dispatch;
	}
	// 82ED1370: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED1374: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1378: 418200AC  beq 0x82ed1424
	if ctx.cr[0].eq {
	pc = 0x82ED1424; continue 'dispatch;
	}
	// 82ED137C: 7F5FCA14  add r26, r31, r25
	ctx.r[26].u64 = ctx.r[31].u64 + ctx.r[25].u64;
	pc = 0x82ED1380; continue 'dispatch;
            }
            0x82ED1380 => {
    //   block [0x82ED1380..0x82ED1398)
	// 82ED1380: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED1384: 7E9BA378  mr r27, r20
	ctx.r[27].u64 = ctx.r[20].u64;
	// 82ED1388: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 82ED138C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED1390: 4099005C  ble cr6, 0x82ed13ec
	if !ctx.cr[6].gt {
	pc = 0x82ED13EC; continue 'dispatch;
	}
	// 82ED1394: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	pc = 0x82ED1398; continue 'dispatch;
            }
            0x82ED1398 => {
    //   block [0x82ED1398..0x82ED13D0)
	// 82ED1398: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED139C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED13A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED13A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED13A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED13AC: 4E800421  bctrl
	ctx.lr = 0x82ED13B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED13B0: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED13B4: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED13B8: 409A0018  bne cr6, 0x82ed13d0
	if !ctx.cr[6].eq {
	pc = 0x82ED13D0; continue 'dispatch;
	}
	// 82ED13BC: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ED13C0: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED13C4: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82ED13C8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED13CC: 419A001C  beq cr6, 0x82ed13e8
	if ctx.cr[6].eq {
	pc = 0x82ED13E8; continue 'dispatch;
	}
            }
            0x82ED13D0 => {
    //   block [0x82ED13D0..0x82ED13E8)
	// 82ED13D0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED13D4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82ED13D8: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82ED13DC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED13E0: 4198FFB8  blt cr6, 0x82ed1398
	if ctx.cr[6].lt {
	pc = 0x82ED1398; continue 'dispatch;
	}
	// 82ED13E4: 48000008  b 0x82ed13ec
	pc = 0x82ED13EC; continue 'dispatch;
            }
            0x82ED13E8 => {
    //   block [0x82ED13E8..0x82ED13EC)
	// 82ED13E8: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	pc = 0x82ED13EC; continue 'dispatch;
            }
            0x82ED13EC => {
    //   block [0x82ED13EC..0x82ED1418)
	// 82ED13EC: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED13F0: 41820028  beq 0x82ed1418
	if ctx.cr[0].eq {
	pc = 0x82ED1418; continue 'dispatch;
	}
	// 82ED13F4: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED13F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ED13FC: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82ED1400: 839C0018  lwz r28, 0x18(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED1404: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82ED1408: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED140C: 4BFFDFCD  bl 0x82ecf3d8
	ctx.lr = 0x82ED1410;
	sub_82ECF3D8(ctx, base);
	// 82ED1410: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 82ED1414: 48000008  b 0x82ed141c
	pc = 0x82ED141C; continue 'dispatch;
            }
            0x82ED1418 => {
    //   block [0x82ED1418..0x82ED141C)
	// 82ED1418: 839C0018  lwz r28, 0x18(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x82ED141C; continue 'dispatch;
            }
            0x82ED141C => {
    //   block [0x82ED141C..0x82ED1424)
	// 82ED141C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82ED1420: 409AFF60  bne cr6, 0x82ed1380
	if !ctx.cr[6].eq {
	pc = 0x82ED1380; continue 'dispatch;
	}
	pc = 0x82ED1424; continue 'dispatch;
            }
            0x82ED1424 => {
    //   block [0x82ED1424..0x82ED1448)
	// 82ED1424: 7F5FCA14  add r26, r31, r25
	ctx.r[26].u64 = ctx.r[31].u64 + ctx.r[25].u64;
	// 82ED1428: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	// 82ED142C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED1430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED1434: 409900DC  ble cr6, 0x82ed1510
	if !ctx.cr[6].gt {
	pc = 0x82ED1510; continue 'dispatch;
	}
	// 82ED1438: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED143C: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 82ED1440: 3B8BAFB4  addi r28, r11, -0x504c
	ctx.r[28].s64 = ctx.r[11].s64 + -20556;
	// 82ED1444: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	pc = 0x82ED1448; continue 'dispatch;
            }
            0x82ED1448 => {
    //   block [0x82ED1448..0x82ED148C)
	// 82ED1448: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED144C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82ED1450: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED1454: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED1458: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED145C: 4E800421  bctrl
	ctx.lr = 0x82ED1460;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED1460: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED1464: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED1468: 409A0094  bne cr6, 0x82ed14fc
	if !ctx.cr[6].eq {
	pc = 0x82ED14FC; continue 'dispatch;
	}
	// 82ED146C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED1470: 7E89A378  mr r9, r20
	ctx.r[9].u64 = ctx.r[20].u64;
	// 82ED1474: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED1478: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED147C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1480: 4182002C  beq 0x82ed14ac
	if ctx.cr[0].eq {
	pc = 0x82ED14AC; continue 'dispatch;
	}
	// 82ED1484: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ED1488: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
            }
            0x82ED148C => {
    //   block [0x82ED148C..0x82ED14A8)
	// 82ED148C: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED1490: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED1494: 419A0014  beq cr6, 0x82ed14a8
	if ctx.cr[6].eq {
	pc = 0x82ED14A8; continue 'dispatch;
	}
	// 82ED1498: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED149C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED14A0: 4082FFEC  bne 0x82ed148c
	if !ctx.cr[0].eq {
	pc = 0x82ED148C; continue 'dispatch;
	}
	// 82ED14A4: 48000008  b 0x82ed14ac
	pc = 0x82ED14AC; continue 'dispatch;
            }
            0x82ED14A8 => {
    //   block [0x82ED14A8..0x82ED14AC)
	// 82ED14A8: 7EA9AB78  mr r9, r21
	ctx.r[9].u64 = ctx.r[21].u64;
	pc = 0x82ED14AC; continue 'dispatch;
            }
            0x82ED14AC => {
    //   block [0x82ED14AC..0x82ED14FC)
	// 82ED14AC: 552B063F  clrlwi. r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED14B0: 4182004C  beq 0x82ed14fc
	if ctx.cr[0].eq {
	pc = 0x82ED14FC; continue 'dispatch;
	}
	// 82ED14B4: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ED14B8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82ED14BC: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED14C0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82ED14C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ED14C8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82ED14CC: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82ED14D0: 92A10054  stw r21, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[21].u32 ) };
	// 82ED14D4: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82ED14D8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82ED14DC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED14E0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82ED14E4: 817DF08C  lwz r11, -0xf74(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-3956 as u32) ) } as u64;
	// 82ED14E8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED14EC: 917DF08C  stw r11, -0xf74(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-3956 as u32), ctx.r[11].u32 ) };
	// 82ED14F0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82ED14F4: 4BFFF2D5  bl 0x82ed07c8
	ctx.lr = 0x82ED14F8;
	sub_82ED07C8(ctx, base);
	// 82ED14F8: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	pc = 0x82ED14FC; continue 'dispatch;
            }
            0x82ED14FC => {
    //   block [0x82ED14FC..0x82ED1510)
	// 82ED14FC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED1500: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82ED1504: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82ED1508: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED150C: 4198FF3C  blt cr6, 0x82ed1448
	if ctx.cr[6].lt {
	pc = 0x82ED1448; continue 'dispatch;
	}
	pc = 0x82ED1510; continue 'dispatch;
            }
            0x82ED1510 => {
    //   block [0x82ED1510..0x82ED1524)
	// 82ED1510: 9AB30000  stb r21, 0(r19)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[19].u32.wrapping_add(0 as u32), ctx.r[21].u8 ) };
	// 82ED1514: 7EBFB12E  stwx r21, r31, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[22].u32), ctx.r[21].u32) };
	// 82ED1518: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82ED151C: CBE1FF88  lfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82ED1520: 4BDD7F14  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED1528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED1528 size=176
    let mut pc: u32 = 0x82ED1528;
    'dispatch: loop {
        match pc {
            0x82ED1528 => {
    //   block [0x82ED1528..0x82ED155C)
	// 82ED1528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED152C: 4BDD7EE1  bl 0x82ca940c
	ctx.lr = 0x82ED1530;
	sub_82CA93D0(ctx, base);
	// 82ED1530: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED1534: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED1538: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED153C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED1540: 409A001C  bne cr6, 0x82ed155c
	if !ctx.cr[6].eq {
	pc = 0x82ED155C; continue 'dispatch;
	}
	// 82ED1544: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED1548: 388B6D70  addi r4, r11, 0x6d70
	ctx.r[4].s64 = ctx.r[11].s64 + 28016;
	// 82ED154C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED1550: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED1554: 4B3966CD  bl 0x82267c20
	ctx.lr = 0x82ED1558;
	sub_82267C20(ctx, base);
	// 82ED1558: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	pc = 0x82ED155C; continue 'dispatch;
            }
            0x82ED155C => {
    //   block [0x82ED155C..0x82ED1570)
	// 82ED155C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED1560: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ED1564: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED1568: 40990068  ble cr6, 0x82ed15d0
	if !ctx.cr[6].gt {
	pc = 0x82ED15D0; continue 'dispatch;
	}
	// 82ED156C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ED1570; continue 'dispatch;
            }
            0x82ED1570 => {
    //   block [0x82ED1570..0x82ED15A4)
	// 82ED1570: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED1574: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ED1578: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82ED157C: 81630294  lwz r11, 0x294(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(660 as u32) ) } as u64;
	// 82ED1580: 99430010  stb r10, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 82ED1584: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED1588: 419A0028  beq cr6, 0x82ed15b0
	if ctx.cr[6].eq {
	pc = 0x82ED15B0; continue 'dispatch;
	}
	// 82ED158C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82ED1590: 419A0014  beq cr6, 0x82ed15a4
	if ctx.cr[6].eq {
	pc = 0x82ED15A4; continue 'dispatch;
	}
	// 82ED1594: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ED1598: 409A0020  bne cr6, 0x82ed15b8
	if !ctx.cr[6].eq {
	pc = 0x82ED15B8; continue 'dispatch;
	}
	// 82ED159C: 4BFFF63D  bl 0x82ed0bd8
	ctx.lr = 0x82ED15A0;
	sub_82ED0BD8(ctx, base);
	// 82ED15A0: 48000018  b 0x82ed15b8
	pc = 0x82ED15B8; continue 'dispatch;
            }
            0x82ED15A4 => {
    //   block [0x82ED15A4..0x82ED15B0)
	// 82ED15A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ED15A8: 4BFFD691  bl 0x82ecec38
	ctx.lr = 0x82ED15AC;
	sub_82ECEC38(ctx, base);
	// 82ED15AC: 4800000C  b 0x82ed15b8
	pc = 0x82ED15B8; continue 'dispatch;
            }
            0x82ED15B0 => {
    //   block [0x82ED15B0..0x82ED15B8)
	// 82ED15B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ED15B4: 4BFFD3D5  bl 0x82ece988
	ctx.lr = 0x82ED15B8;
	sub_82ECE988(ctx, base);
	pc = 0x82ED15B8; continue 'dispatch;
            }
            0x82ED15B8 => {
    //   block [0x82ED15B8..0x82ED15D0)
	// 82ED15B8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED15BC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82ED15C0: 3FDE0001  addis r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 65536;
	// 82ED15C4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED15C8: 3BDE8578  addi r30, r30, -0x7a88
	ctx.r[30].s64 = ctx.r[30].s64 + -31368;
	// 82ED15CC: 4198FFA4  blt cr6, 0x82ed1570
	if ctx.cr[6].lt {
	pc = 0x82ED1570; continue 'dispatch;
	}
	pc = 0x82ED15D0; continue 'dispatch;
            }
            0x82ED15D0 => {
    //   block [0x82ED15D0..0x82ED15D8)
	// 82ED15D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED15D4: 4BDD7E88  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED15D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED15D8 size=88
    let mut pc: u32 = 0x82ED15D8;
    'dispatch: loop {
        match pc {
            0x82ED15D8 => {
    //   block [0x82ED15D8..0x82ED1614)
	// 82ED15D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED15DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED15E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED15E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED15E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED15EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED15F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED15F4: 4BFFF13D  bl 0x82ed0730
	ctx.lr = 0x82ED15F8;
	sub_82ED0730(ctx, base);
	// 82ED15F8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED15FC: 41820018  beq 0x82ed1614
	if ctx.cr[0].eq {
	pc = 0x82ED1614; continue 'dispatch;
	}
	// 82ED1600: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED1604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED1608: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED160C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED1610: 4E800421  bctrl
	ctx.lr = 0x82ED1614;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED1614 => {
    //   block [0x82ED1614..0x82ED1630)
	// 82ED1614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED1618: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED161C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED1620: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED1624: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED1628: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED162C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED1630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED1630 size=160
    let mut pc: u32 = 0x82ED1630;
    'dispatch: loop {
        match pc {
            0x82ED1630 => {
    //   block [0x82ED1630..0x82ED1664)
	// 82ED1630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED1634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED1638: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED163C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED1640: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED1644: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ED1648: 419A0064  beq cr6, 0x82ed16ac
	if ctx.cr[6].eq {
	pc = 0x82ED16AC; continue 'dispatch;
	}
	// 82ED164C: 4BFCFAED  bl 0x82ea1138
	ctx.lr = 0x82ED1650;
	sub_82EA1138(ctx, base);
	// 82ED1650: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82ED1654: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ED1658: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED165C: 40810050  ble 0x82ed16ac
	if !ctx.cr[0].gt {
	pc = 0x82ED16AC; continue 'dispatch;
	}
	// 82ED1660: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82ED1664; continue 'dispatch;
            }
            0x82ED1664 => {
    //   block [0x82ED1664..0x82ED1670)
	// 82ED1664: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED1668: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82ED166C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82ED1670; continue 'dispatch;
            }
            0x82ED1670 => {
    //   block [0x82ED1670..0x82ED1694)
	// 82ED1670: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED1674: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED1678: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED167C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82ED1680: 41820014  beq 0x82ed1694
	if ctx.cr[0].eq {
	pc = 0x82ED1694; continue 'dispatch;
	}
	// 82ED1684: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED1688: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED168C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82ED1690: 419AFFE0  beq cr6, 0x82ed1670
	if ctx.cr[6].eq {
	pc = 0x82ED1670; continue 'dispatch;
	}
	pc = 0x82ED1694; continue 'dispatch;
            }
            0x82ED1694 => {
    //   block [0x82ED1694..0x82ED16AC)
	// 82ED1694: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED1698: 4182002C  beq 0x82ed16c4
	if ctx.cr[0].eq {
	pc = 0x82ED16C4; continue 'dispatch;
	}
	// 82ED169C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82ED16A0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82ED16A4: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82ED16A8: 4198FFBC  blt cr6, 0x82ed1664
	if ctx.cr[6].lt {
	pc = 0x82ED1664; continue 'dispatch;
	}
	pc = 0x82ED16AC; continue 'dispatch;
            }
            0x82ED16AC => {
    //   block [0x82ED16AC..0x82ED16B0)
	// 82ED16AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ED16B0; continue 'dispatch;
            }
            0x82ED16B0 => {
    //   block [0x82ED16B0..0x82ED16C4)
	// 82ED16B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED16B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED16B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED16BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED16C0: 4E800020  blr
	return;
            }
            0x82ED16C4 => {
    //   block [0x82ED16C4..0x82ED16D0)
	// 82ED16C4: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED16C8: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82ED16CC: 4BFFFFE4  b 0x82ed16b0
	pc = 0x82ED16B0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED16D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED16D0 size=916
    let mut pc: u32 = 0x82ED16D0;
    'dispatch: loop {
        match pc {
            0x82ED16D0 => {
    //   block [0x82ED16D0..0x82ED1700)
	// 82ED16D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED16D4: 4BDD7D2D  bl 0x82ca9400
	ctx.lr = 0x82ED16D8;
	sub_82CA93D0(ctx, base);
	// 82ED16D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED16DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED16E0: 3D60035E  lis r11, 0x35e
	ctx.r[11].s64 = 56492032;
	// 82ED16E4: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 82ED16E8: 616B50D7  ori r11, r11, 0x50d7
	ctx.r[11].u64 = ctx.r[11].u64 | 20695;
	// 82ED16EC: 83DF0210  lwz r30, 0x210(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ED16F0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED16F4: 1C7E004C  mulli r3, r30, 0x4c
	ctx.r[3].s32 = ((ctx.r[30].s32 as i64 * 76 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82ED16F8: 40990008  ble cr6, 0x82ed1700
	if !ctx.cr[6].gt {
	pc = 0x82ED1700; continue 'dispatch;
	}
	// 82ED16FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	pc = 0x82ED1700; continue 'dispatch;
            }
            0x82ED1700 => {
    //   block [0x82ED1700..0x82ED1718)
	// 82ED1700: 4B745229  bl 0x82616928
	ctx.lr = 0x82ED1704;
	sub_82616928(ctx, base);
	// 82ED1704: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82ED1708: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82ED170C: 41820024  beq 0x82ed1730
	if ctx.cr[0].eq {
	pc = 0x82ED1730; continue 'dispatch;
	}
	// 82ED1710: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82ED1714: 48000010  b 0x82ed1724
	pc = 0x82ED1724; continue 'dispatch;
            }
            0x82ED1718 => {
    //   block [0x82ED1718..0x82ED1724)
	// 82ED1718: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ED171C: 480022A5  bl 0x82ed39c0
	ctx.lr = 0x82ED1720;
	sub_82ED39C0(ctx, base);
	// 82ED1720: 3BBD004C  addi r29, r29, 0x4c
	ctx.r[29].s64 = ctx.r[29].s64 + 76;
	pc = 0x82ED1724; continue 'dispatch;
            }
            0x82ED1724 => {
    //   block [0x82ED1724..0x82ED1730)
	// 82ED1724: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ED1728: 4080FFF0  bge 0x82ed1718
	if !ctx.cr[0].lt {
	pc = 0x82ED1718; continue 'dispatch;
	}
	// 82ED172C: 48000008  b 0x82ed1734
	pc = 0x82ED1734; continue 'dispatch;
            }
            0x82ED1730 => {
    //   block [0x82ED1730..0x82ED1734)
	// 82ED1730: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	pc = 0x82ED1734; continue 'dispatch;
            }
            0x82ED1734 => {
    //   block [0x82ED1734..0x82ED1750)
	// 82ED1734: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ED1738: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82ED173C: 939F0164  stw r28, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[28].u32 ) };
	// 82ED1740: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82ED1744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED1748: 40990064  ble cr6, 0x82ed17ac
	if !ctx.cr[6].gt {
	pc = 0x82ED17AC; continue 'dispatch;
	}
	// 82ED174C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82ED1750; continue 'dispatch;
            }
            0x82ED1750 => {
    //   block [0x82ED1750..0x82ED17AC)
	// 82ED1750: 813F0164  lwz r9, 0x164(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ED1754: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED1758: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82ED175C: 9BA90010  stb r29, 0x10(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82ED1760: 813F0164  lwz r9, 0x164(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ED1764: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82ED1768: 9B690038  stb r27, 0x38(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(56 as u32), ctx.r[27].u8 ) };
	// 82ED176C: 813F0164  lwz r9, 0x164(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ED1770: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82ED1774: 9B690030  stb r27, 0x30(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(48 as u32), ctx.r[27].u8 ) };
	// 82ED1778: 813F0164  lwz r9, 0x164(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ED177C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82ED1780: 93690034  stw r27, 0x34(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(52 as u32), ctx.r[27].u32 ) };
	// 82ED1784: 813F0164  lwz r9, 0x164(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ED1788: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82ED178C: 9B690039  stb r27, 0x39(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(57 as u32), ctx.r[27].u8 ) };
	// 82ED1790: 813F0164  lwz r9, 0x164(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ED1794: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82ED1798: 396B004C  addi r11, r11, 0x4c
	ctx.r[11].s64 = ctx.r[11].s64 + 76;
	// 82ED179C: 93E9001C  stw r31, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 82ED17A0: 813F0210  lwz r9, 0x210(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ED17A4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ED17A8: 4198FFA8  blt cr6, 0x82ed1750
	if ctx.cr[6].lt {
	pc = 0x82ED1750; continue 'dispatch;
	}
	pc = 0x82ED17AC; continue 'dispatch;
            }
            0x82ED17AC => {
    //   block [0x82ED17AC..0x82ED1818)
	// 82ED17AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED17B0: 3BDF0214  addi r30, r31, 0x214
	ctx.r[30].s64 = ctx.r[31].s64 + 532;
	// 82ED17B4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82ED17B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED17BC: 4BDDB395  bl 0x82cacb50
	ctx.lr = 0x82ED17C0;
	sub_82CACB50(ctx, base);
	// 82ED17C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED17C4: 41820054  beq 0x82ed1818
	if ctx.cr[0].eq {
	pc = 0x82ED1818; continue 'dispatch;
	}
	// 82ED17C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED17CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED17D0: 388BB9B4  addi r4, r11, -0x464c
	ctx.r[4].s64 = ctx.r[11].s64 + -17996;
	// 82ED17D4: 4BDDB37D  bl 0x82cacb50
	ctx.lr = 0x82ED17D8;
	sub_82CACB50(ctx, base);
	// 82ED17D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED17DC: 4182003C  beq 0x82ed1818
	if ctx.cr[0].eq {
	pc = 0x82ED1818; continue 'dispatch;
	}
	// 82ED17E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED17E4: 4821C75D  bl 0x830edf40
	ctx.lr = 0x82ED17E8;
	sub_830EDF40(ctx, base);
	// 82ED17E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED17EC: 907F0170  stw r3, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[3].u32 ) };
	// 82ED17F0: 41820044  beq 0x82ed1834
	if ctx.cr[0].eq {
	pc = 0x82ED1834; continue 'dispatch;
	}
	// 82ED17F4: 393F0174  addi r9, r31, 0x174
	ctx.r[9].s64 = ctx.r[31].s64 + 372;
	// 82ED17F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ED17FC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82ED1800: 38DF0178  addi r6, r31, 0x178
	ctx.r[6].s64 = ctx.r[31].s64 + 376;
	// 82ED1804: 38A00084  li r5, 0x84
	ctx.r[5].s64 = 132;
	// 82ED1808: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ED180C: 4821C74D  bl 0x830edf58
	ctx.lr = 0x82ED1810;
	sub_830EDF58(ctx, base);
	// 82ED1810: 93BF0294  stw r29, 0x294(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), ctx.r[29].u32 ) };
	// 82ED1814: 48000038  b 0x82ed184c
	pc = 0x82ED184C; continue 'dispatch;
            }
            0x82ED1818 => {
    //   block [0x82ED1818..0x82ED1834)
	// 82ED1818: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED181C: 616B84F4  ori r11, r11, 0x84f4
	ctx.r[11].u64 = ctx.r[11].u64 | 34036;
	// 82ED1820: 7C7F582E  lwzx r3, r31, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED1824: 4821C71D  bl 0x830edf40
	ctx.lr = 0x82ED1828;
	sub_830EDF40(ctx, base);
	// 82ED1828: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED182C: 907F0170  stw r3, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[3].u32 ) };
	// 82ED1830: 40820014  bne 0x82ed1844
	if !ctx.cr[0].eq {
	pc = 0x82ED1844; continue 'dispatch;
	}
	pc = 0x82ED1834; continue 'dispatch;
            }
            0x82ED1834 => {
    //   block [0x82ED1834..0x82ED1844)
	// 82ED1834: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82ED1838: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED183C: 917F0294  stw r11, 0x294(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), ctx.r[11].u32 ) };
	// 82ED1840: 4800021C  b 0x82ed1a5c
	pc = 0x82ED1A5C; continue 'dispatch;
            }
            0x82ED1844 => {
    //   block [0x82ED1844..0x82ED184C)
	// 82ED1844: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82ED1848: 917F0294  stw r11, 0x294(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED184C; continue 'dispatch;
            }
            0x82ED184C => {
    //   block [0x82ED184C..0x82ED187C)
	// 82ED184C: 897F0040  lbz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED1850: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1854: 41820140  beq 0x82ed1994
	if ctx.cr[0].eq {
	pc = 0x82ED1994; continue 'dispatch;
	}
	// 82ED1858: 3F9F0001  addis r28, r31, 1
	ctx.r[28].s64 = ctx.r[31].s64 + 65536;
	// 82ED185C: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 82ED1860: 3B9C84E0  addi r28, r28, -0x7b20
	ctx.r[28].s64 = ctx.r[28].s64 + -31520;
	// 82ED1864: 616AFFFF  ori r10, r11, 0xffff
	ctx.r[10].u64 = ctx.r[11].u64 | 65535;
	// 82ED1868: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED186C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED1870: 55631838  slwi r3, r11, 3
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82ED1874: 40990008  ble cr6, 0x82ed187c
	if !ctx.cr[6].gt {
	pc = 0x82ED187C; continue 'dispatch;
	}
	// 82ED1878: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	pc = 0x82ED187C; continue 'dispatch;
            }
            0x82ED187C => {
    //   block [0x82ED187C..0x82ED1898)
	// 82ED187C: 4B7450AD  bl 0x82616928
	ctx.lr = 0x82ED1880;
	sub_82616928(ctx, base);
	// 82ED1880: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED1884: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 82ED1888: 907F003C  stw r3, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[3].u32 ) };
	// 82ED188C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED1890: 40990070  ble cr6, 0x82ed1900
	if !ctx.cr[6].gt {
	pc = 0x82ED1900; continue 'dispatch;
	}
	// 82ED1894: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x82ED1898; continue 'dispatch;
            }
            0x82ED1898 => {
    //   block [0x82ED1898..0x82ED18B0)
	// 82ED1898: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 82ED189C: 4B74508D  bl 0x82616928
	ctx.lr = 0x82ED18A0;
	sub_82616928(ctx, base);
	// 82ED18A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED18A4: 4182000C  beq 0x82ed18b0
	if ctx.cr[0].eq {
	pc = 0x82ED18B0; continue 'dispatch;
	}
	// 82ED18A8: 4BFD4451  bl 0x82ea5cf8
	ctx.lr = 0x82ED18AC;
	sub_82EA5CF8(ctx, base);
	// 82ED18AC: 48000008  b 0x82ed18b4
	pc = 0x82ED18B4; continue 'dispatch;
            }
            0x82ED18B0 => {
    //   block [0x82ED18B0..0x82ED18B4)
	// 82ED18B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	pc = 0x82ED18B4; continue 'dispatch;
            }
            0x82ED18B4 => {
    //   block [0x82ED18B4..0x82ED18D8)
	// 82ED18B4: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ED18B8: 7C7E592E  stwx r3, r30, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 82ED18BC: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ED18C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED18C4: 40820014  bne 0x82ed18d8
	if !ctx.cr[0].eq {
	pc = 0x82ED18D8; continue 'dispatch;
	}
	// 82ED18C8: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ED18CC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82ED18D0: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82ED18D4: 48000018  b 0x82ed18ec
	pc = 0x82ED18EC; continue 'dispatch;
            }
            0x82ED18D8 => {
    //   block [0x82ED18D8..0x82ED18EC)
	// 82ED18D8: 5563502A  slwi r3, r11, 0xa
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(10);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82ED18DC: 4B74504D  bl 0x82616928
	ctx.lr = 0x82ED18E0;
	sub_82616928(ctx, base);
	// 82ED18E0: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ED18E4: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82ED18E8: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	pc = 0x82ED18EC; continue 'dispatch;
            }
            0x82ED18EC => {
    //   block [0x82ED18EC..0x82ED1900)
	// 82ED18EC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED18F0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82ED18F4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82ED18F8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED18FC: 4198FF9C  blt cr6, 0x82ed1898
	if ctx.cr[6].lt {
	pc = 0x82ED1898; continue 'dispatch;
	}
	pc = 0x82ED1900; continue 'dispatch;
            }
            0x82ED1900 => {
    //   block [0x82ED1900..0x82ED1930)
	// 82ED1900: 897F004C  lbz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82ED1904: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82ED1908: 3BBF004C  addi r29, r31, 0x4c
	ctx.r[29].s64 = ctx.r[31].s64 + 76;
	// 82ED190C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED1910: 419A0058  beq cr6, 0x82ed1968
	if ctx.cr[6].eq {
	pc = 0x82ED1968; continue 'dispatch;
	}
	// 82ED1914: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82ED1918: 4B745011  bl 0x82616928
	ctx.lr = 0x82ED191C;
	sub_82616928(ctx, base);
	// 82ED191C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1920: 41820010  beq 0x82ed1930
	if ctx.cr[0].eq {
	pc = 0x82ED1930; continue 'dispatch;
	}
	// 82ED1924: 4821E13D  bl 0x830efa60
	ctx.lr = 0x82ED1928;
	sub_830EFA60(ctx, base);
	// 82ED1928: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ED192C: 48000008  b 0x82ed1934
	pc = 0x82ED1934; continue 'dispatch;
            }
            0x82ED1930 => {
    //   block [0x82ED1930..0x82ED1934)
	// 82ED1930: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x82ED1934; continue 'dispatch;
            }
            0x82ED1934 => {
    //   block [0x82ED1934..0x82ED1968)
	// 82ED1934: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82ED1938: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ED193C: 388B0D84  addi r4, r11, 0xd84
	ctx.r[4].s64 = ctx.r[11].s64 + 3460;
	// 82ED1940: 4BDDB211  bl 0x82cacb50
	ctx.lr = 0x82ED1944;
	sub_82CACB50(ctx, base);
	// 82ED1944: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED1948: 41820020  beq 0x82ed1968
	if ctx.cr[0].eq {
	pc = 0x82ED1968; continue 'dispatch;
	}
	// 82ED194C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ED1950: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED1954: 4821E82D  bl 0x830f0180
	ctx.lr = 0x82ED1958;
	sub_830F0180(ctx, base);
	// 82ED1958: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED195C: 4082000C  bne 0x82ed1968
	if !ctx.cr[0].eq {
	pc = 0x82ED1968; continue 'dispatch;
	}
	// 82ED1960: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED1964: 4821E165  bl 0x830efac8
	ctx.lr = 0x82ED1968;
	sub_830EFAC8(ctx, base);
	pc = 0x82ED1968; continue 'dispatch;
            }
            0x82ED1968 => {
    //   block [0x82ED1968..0x82ED1980)
	// 82ED1968: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82ED196C: 4B744FBD  bl 0x82616928
	ctx.lr = 0x82ED1970;
	sub_82616928(ctx, base);
	// 82ED1970: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1974: 4182000C  beq 0x82ed1980
	if ctx.cr[0].eq {
	pc = 0x82ED1980; continue 'dispatch;
	}
	// 82ED1978: 4821C611  bl 0x830edf88
	ctx.lr = 0x82ED197C;
	sub_830EDF88(ctx, base);
	// 82ED197C: 48000008  b 0x82ed1984
	pc = 0x82ED1984; continue 'dispatch;
            }
            0x82ED1980 => {
    //   block [0x82ED1980..0x82ED1984)
	// 82ED1980: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	pc = 0x82ED1984; continue 'dispatch;
            }
            0x82ED1984 => {
    //   block [0x82ED1984..0x82ED1994)
	// 82ED1984: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ED1988: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED198C: 907F0048  stw r3, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[3].u32 ) };
	// 82ED1990: 4821CDE1  bl 0x830ee770
	ctx.lr = 0x82ED1994;
	sub_830EE770(ctx, base);
	pc = 0x82ED1994; continue 'dispatch;
            }
            0x82ED1994 => {
    //   block [0x82ED1994..0x82ED19F0)
	// 82ED1994: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED1998: 3BCBBA04  addi r30, r11, -0x45fc
	ctx.r[30].s64 = ctx.r[11].s64 + -17916;
	// 82ED199C: 4B38F01D  bl 0x822609b8
	ctx.lr = 0x82ED19A0;
	sub_822609B8(ctx, base);
	// 82ED19A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED19A4: 4BFAF7C5  bl 0x82e81168
	ctx.lr = 0x82ED19A8;
	sub_82E81168(ctx, base);
	// 82ED19A8: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED19AC: 616A84EC  ori r10, r11, 0x84ec
	ctx.r[10].u64 = ctx.r[11].u64 | 34028;
	// 82ED19B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED19B4: 3BCBB9DC  addi r30, r11, -0x4624
	ctx.r[30].s64 = ctx.r[11].s64 + -17956;
	// 82ED19B8: 7C7F512E  stwx r3, r31, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[3].u32) };
	// 82ED19BC: 4B38EFFD  bl 0x822609b8
	ctx.lr = 0x82ED19C0;
	sub_822609B8(ctx, base);
	// 82ED19C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED19C4: 4BFAF7A5  bl 0x82e81168
	ctx.lr = 0x82ED19C8;
	sub_82E81168(ctx, base);
	// 82ED19C8: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED19CC: 895F0039  lbz r10, 0x39(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(57 as u32) ) } as u64;
	// 82ED19D0: 616B84F0  ori r11, r11, 0x84f0
	ctx.r[11].u64 = ctx.r[11].u64 | 34032;
	// 82ED19D4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED19D8: 7C7F592E  stwx r3, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 82ED19DC: 4182007C  beq 0x82ed1a58
	if ctx.cr[0].eq {
	pc = 0x82ED1A58; continue 'dispatch;
	}
	// 82ED19E0: 817F0294  lwz r11, 0x294(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 82ED19E4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED19E8: 409A0070  bne cr6, 0x82ed1a58
	if !ctx.cr[6].eq {
	pc = 0x82ED1A58; continue 'dispatch;
	}
	// 82ED19EC: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x82ED19F0; continue 'dispatch;
            }
            0x82ED19F0 => {
    //   block [0x82ED19F0..0x82ED1A24)
	// 82ED19F0: 817F0294  lwz r11, 0x294(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 82ED19F4: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED19F8: 419A0060  beq cr6, 0x82ed1a58
	if ctx.cr[6].eq {
	pc = 0x82ED1A58; continue 'dispatch;
	}
	// 82ED19FC: 9B7F0010  stb r27, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[27].u8 ) };
	// 82ED1A00: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED1A04: 419A0030  beq cr6, 0x82ed1a34
	if ctx.cr[6].eq {
	pc = 0x82ED1A34; continue 'dispatch;
	}
	// 82ED1A08: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82ED1A0C: 419A0018  beq cr6, 0x82ed1a24
	if ctx.cr[6].eq {
	pc = 0x82ED1A24; continue 'dispatch;
	}
	// 82ED1A10: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ED1A14: 409A002C  bne cr6, 0x82ed1a40
	if !ctx.cr[6].eq {
	pc = 0x82ED1A40; continue 'dispatch;
	}
	// 82ED1A18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED1A1C: 4BFFF1BD  bl 0x82ed0bd8
	ctx.lr = 0x82ED1A20;
	sub_82ED0BD8(ctx, base);
	// 82ED1A20: 48000020  b 0x82ed1a40
	pc = 0x82ED1A40; continue 'dispatch;
            }
            0x82ED1A24 => {
    //   block [0x82ED1A24..0x82ED1A34)
	// 82ED1A24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ED1A28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED1A2C: 4BFFD20D  bl 0x82ecec38
	ctx.lr = 0x82ED1A30;
	sub_82ECEC38(ctx, base);
	// 82ED1A30: 48000010  b 0x82ed1a40
	pc = 0x82ED1A40; continue 'dispatch;
            }
            0x82ED1A34 => {
    //   block [0x82ED1A34..0x82ED1A40)
	// 82ED1A34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ED1A38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED1A3C: 4BFFCF4D  bl 0x82ece988
	ctx.lr = 0x82ED1A40;
	sub_82ECE988(ctx, base);
	pc = 0x82ED1A40; continue 'dispatch;
            }
            0x82ED1A40 => {
    //   block [0x82ED1A40..0x82ED1A58)
	// 82ED1A40: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82ED1A44: 2B1E2710  cmplwi cr6, r30, 0x2710
	ctx.cr[6].compare_u32(ctx.r[30].u32, 10000 as u32, &mut ctx.xer);
	// 82ED1A48: 41990010  bgt cr6, 0x82ed1a58
	if ctx.cr[6].gt {
	pc = 0x82ED1A58; continue 'dispatch;
	}
	// 82ED1A4C: 817F0294  lwz r11, 0x294(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 82ED1A50: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ED1A54: 409AFF9C  bne cr6, 0x82ed19f0
	if !ctx.cr[6].eq {
	pc = 0x82ED19F0; continue 'dispatch;
	}
	pc = 0x82ED1A58; continue 'dispatch;
            }
            0x82ED1A58 => {
    //   block [0x82ED1A58..0x82ED1A5C)
	// 82ED1A58: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82ED1A5C; continue 'dispatch;
            }
            0x82ED1A5C => {
    //   block [0x82ED1A5C..0x82ED1A64)
	// 82ED1A5C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ED1A60: 4BDD79F0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED1A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED1A68 size=208
    let mut pc: u32 = 0x82ED1A68;
    'dispatch: loop {
        match pc {
            0x82ED1A68 => {
    //   block [0x82ED1A68..0x82ED1A90)
	// 82ED1A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED1A6C: 4BDD7999  bl 0x82ca9404
	ctx.lr = 0x82ED1A70;
	sub_82CA93D0(ctx, base);
	// 82ED1A70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED1A74: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ED1A78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED1A7C: 4BFB392D  bl 0x82e853a8
	ctx.lr = 0x82ED1A80;
	sub_82E853A8(ctx, base);
	// 82ED1A80: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED1A84: 4082000C  bne 0x82ed1a90
	if !ctx.cr[0].eq {
	pc = 0x82ED1A90; continue 'dispatch;
	}
	// 82ED1A88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED1A8C: 480000A4  b 0x82ed1b30
	pc = 0x82ED1B30; continue 'dispatch;
            }
            0x82ED1A90 => {
    //   block [0x82ED1A90..0x82ED1AAC)
	// 82ED1A90: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED1A94: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82ED1A98: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ED1A9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED1AA0: 40990048  ble cr6, 0x82ed1ae8
	if !ctx.cr[6].gt {
	pc = 0x82ED1AE8; continue 'dispatch;
	}
	// 82ED1AA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED1AA8: 3B6B9848  addi r27, r11, -0x67b8
	ctx.r[27].s64 = ctx.r[11].s64 + -26552;
	pc = 0x82ED1AAC; continue 'dispatch;
            }
            0x82ED1AAC => {
    //   block [0x82ED1AAC..0x82ED1AD8)
	// 82ED1AAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED1AB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED1AB4: 4BFB2575  bl 0x82e84028
	ctx.lr = 0x82ED1AB8;
	sub_82E84028(ctx, base);
	// 82ED1AB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1ABC: 4182001C  beq 0x82ed1ad8
	if ctx.cr[0].eq {
	pc = 0x82ED1AD8; continue 'dispatch;
	}
	// 82ED1AC0: 482EA5A1  bl 0x831bc060
	ctx.lr = 0x82ED1AC4;
	sub_831BC060(ctx, base);
	// 82ED1AC4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82ED1AC8: 4BDDB089  bl 0x82cacb50
	ctx.lr = 0x82ED1ACC;
	sub_82CACB50(ctx, base);
	// 82ED1ACC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED1AD0: 40820008  bne 0x82ed1ad8
	if !ctx.cr[0].eq {
	pc = 0x82ED1AD8; continue 'dispatch;
	}
	// 82ED1AD4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	pc = 0x82ED1AD8; continue 'dispatch;
            }
            0x82ED1AD8 => {
    //   block [0x82ED1AD8..0x82ED1AE8)
	// 82ED1AD8: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED1ADC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82ED1AE0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED1AE4: 4198FFC8  blt cr6, 0x82ed1aac
	if ctx.cr[6].lt {
	pc = 0x82ED1AAC; continue 'dispatch;
	}
	pc = 0x82ED1AE8; continue 'dispatch;
            }
            0x82ED1AE8 => {
    //   block [0x82ED1AE8..0x82ED1B08)
	// 82ED1AE8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ED1AEC: 387D000C  addi r3, r29, 0xc
	ctx.r[3].s64 = ctx.r[29].s64 + 12;
	// 82ED1AF0: 4BFFEF69  bl 0x82ed0a58
	ctx.lr = 0x82ED1AF4;
	sub_82ED0A58(ctx, base);
	// 82ED1AF4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED1AF8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ED1AFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED1B00: 4099002C  ble cr6, 0x82ed1b2c
	if !ctx.cr[6].gt {
	pc = 0x82ED1B2C; continue 'dispatch;
	}
	// 82ED1B04: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82ED1B08; continue 'dispatch;
            }
            0x82ED1B08 => {
    //   block [0x82ED1B08..0x82ED1B2C)
	// 82ED1B08: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED1B0C: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82ED1B10: 4BFFFBC1  bl 0x82ed16d0
	ctx.lr = 0x82ED1B14;
	sub_82ED16D0(ctx, base);
	// 82ED1B14: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED1B18: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82ED1B1C: 3FDE0001  addis r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 65536;
	// 82ED1B20: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED1B24: 3BDE8578  addi r30, r30, -0x7a88
	ctx.r[30].s64 = ctx.r[30].s64 + -31368;
	// 82ED1B28: 4198FFE0  blt cr6, 0x82ed1b08
	if ctx.cr[6].lt {
	pc = 0x82ED1B08; continue 'dispatch;
	}
	pc = 0x82ED1B2C; continue 'dispatch;
            }
            0x82ED1B2C => {
    //   block [0x82ED1B2C..0x82ED1B30)
	// 82ED1B2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82ED1B30; continue 'dispatch;
            }
            0x82ED1B30 => {
    //   block [0x82ED1B30..0x82ED1B38)
	// 82ED1B30: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ED1B34: 4BDD7920  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED1B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED1B38 size=868
    let mut pc: u32 = 0x82ED1B38;
    'dispatch: loop {
        match pc {
            0x82ED1B38 => {
    //   block [0x82ED1B38..0x82ED1BAC)
	// 82ED1B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED1B3C: 4BDD78B9  bl 0x82ca93f4
	ctx.lr = 0x82ED1B40;
	sub_82CA93D0(ctx, base);
	// 82ED1B40: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED1B44: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82ED1B48: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82ED1B4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED1B50: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82ED1B54: 3BEBBA3C  addi r31, r11, -0x45c4
	ctx.r[31].s64 = ctx.r[11].s64 + -17860;
	// 82ED1B58: 482EA509  bl 0x831bc060
	ctx.lr = 0x82ED1B5C;
	sub_831BC060(ctx, base);
	// 82ED1B5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED1B60: 4BDDAFF1  bl 0x82cacb50
	ctx.lr = 0x82ED1B64;
	sub_82CACB50(ctx, base);
	// 82ED1B64: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED1B68: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82ED1B6C: 4082006C  bne 0x82ed1bd8
	if !ctx.cr[0].eq {
	pc = 0x82ED1BD8; continue 'dispatch;
	}
	// 82ED1B70: 4BA3C199  bl 0x8290dd08
	ctx.lr = 0x82ED1B74;
	sub_8290DD08(ctx, base);
	// 82ED1B74: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82ED1B78: 41820244  beq 0x82ed1dbc
	if ctx.cr[0].eq {
	pc = 0x82ED1DBC; continue 'dispatch;
	}
	// 82ED1B7C: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	// 82ED1B80: 3FE08330  lis r31, -0x7cd0
	ctx.r[31].s64 = -2094006272;
	// 82ED1B84: 807E89B8  lwz r3, -0x7648(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-30280 as u32) ) } as u64;
	// 82ED1B88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED1B8C: 419A0020  beq cr6, 0x82ed1bac
	if ctx.cr[6].eq {
	pc = 0x82ED1BAC; continue 'dispatch;
	}
	// 82ED1B90: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED1B94: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED1B98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED1B9C: 4E800421  bctrl
	ctx.lr = 0x82ED1BA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED1BA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED1BA4: 917E89B8  stw r11, -0x7648(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-30280 as u32), ctx.r[11].u32 ) };
	// 82ED1BA8: 917FE1B4  stw r11, -0x1e4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-7756 as u32), ctx.r[11].u32 ) };
            }
            0x82ED1BAC => {
    //   block [0x82ED1BAC..0x82ED1BD8)
	// 82ED1BAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ED1BB0: 4BDD8811  bl 0x82caa3c0
	ctx.lr = 0x82ED1BB4;
	sub_82CAA3C0(ctx, base);
	// 82ED1BB4: 907FE1B4  stw r3, -0x1e4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-7756 as u32), ctx.r[3].u32 ) };
	// 82ED1BB8: 4B744D71  bl 0x82616928
	ctx.lr = 0x82ED1BBC;
	sub_82616928(ctx, base);
	// 82ED1BBC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ED1BC0: 815FE1B4  lwz r10, -0x1e4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-7756 as u32) ) } as u64;
	// 82ED1BC4: 917E89B8  stw r11, -0x7648(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-30280 as u32), ctx.r[11].u32 ) };
	// 82ED1BC8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ED1BCC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ED1BD0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ED1BD4: 48000168  b 0x82ed1d3c
	pc = 0x82ED1D3C; continue 'dispatch;
            }
            0x82ED1BD8 => {
    //   block [0x82ED1BD8..0x82ED1C28)
	// 82ED1BD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED1BDC: 3BEBBA30  addi r31, r11, -0x45d0
	ctx.r[31].s64 = ctx.r[11].s64 + -17872;
	// 82ED1BE0: 482EA481  bl 0x831bc060
	ctx.lr = 0x82ED1BE4;
	sub_831BC060(ctx, base);
	// 82ED1BE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED1BE8: 4BDDAF69  bl 0x82cacb50
	ctx.lr = 0x82ED1BEC;
	sub_82CACB50(ctx, base);
	// 82ED1BEC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED1BF0: 40820154  bne 0x82ed1d44
	if !ctx.cr[0].eq {
	pc = 0x82ED1D44; continue 'dispatch;
	}
	// 82ED1BF4: 83D70020  lwz r30, 0x20(r23)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED1BF8: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1BFC: 93D90008  stw r30, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82ED1C00: 418201BC  beq 0x82ed1dbc
	if ctx.cr[0].eq {
	pc = 0x82ED1DBC; continue 'dispatch;
	}
	// 82ED1C04: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82ED1C08: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ED1C0C: 616BEB05  ori r11, r11, 0xeb05
	ctx.r[11].u64 = ctx.r[11].u64 | 60165;
	// 82ED1C10: 61588578  ori r24, r10, 0x8578
	ctx.r[24].u64 = ctx.r[10].u64 | 34168;
	// 82ED1C14: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED1C18: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED1C1C: 7D7EC1D6  mullw r11, r30, r24
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * ctx.r[24].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ED1C20: 40990008  ble cr6, 0x82ed1c28
	if !ctx.cr[6].gt {
	pc = 0x82ED1C28; continue 'dispatch;
	}
	// 82ED1C24: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82ED1C28; continue 'dispatch;
            }
            0x82ED1C28 => {
    //   block [0x82ED1C28..0x82ED1C38)
	// 82ED1C28: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82ED1C2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED1C30: 41990008  bgt cr6, 0x82ed1c38
	if ctx.cr[6].gt {
	pc = 0x82ED1C38; continue 'dispatch;
	}
	// 82ED1C34: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82ED1C38; continue 'dispatch;
            }
            0x82ED1C38 => {
    //   block [0x82ED1C38..0x82ED1C58)
	// 82ED1C38: 4B744CF1  bl 0x82616928
	ctx.lr = 0x82ED1C3C;
	sub_82616928(ctx, base);
	// 82ED1C3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1C40: 41820030  beq 0x82ed1c70
	if ctx.cr[0].eq {
	pc = 0x82ED1C70; continue 'dispatch;
	}
	// 82ED1C44: 3BA30004  addi r29, r3, 4
	ctx.r[29].s64 = ctx.r[3].s64 + 4;
	// 82ED1C48: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82ED1C4C: 37FEFFFF  addic. r31, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ED1C50: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82ED1C54: 41800020  blt 0x82ed1c74
	if ctx.cr[0].lt {
	pc = 0x82ED1C74; continue 'dispatch;
	}
	pc = 0x82ED1C58; continue 'dispatch;
            }
            0x82ED1C58 => {
    //   block [0x82ED1C58..0x82ED1C70)
	// 82ED1C58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED1C5C: 4BFFD27D  bl 0x82eceed8
	ctx.lr = 0x82ED1C60;
	sub_82ECEED8(ctx, base);
	// 82ED1C60: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ED1C64: 7FDEC214  add r30, r30, r24
	ctx.r[30].u64 = ctx.r[30].u64 + ctx.r[24].u64;
	// 82ED1C68: 4080FFF0  bge 0x82ed1c58
	if !ctx.cr[0].lt {
	pc = 0x82ED1C58; continue 'dispatch;
	}
	// 82ED1C6C: 48000008  b 0x82ed1c74
	pc = 0x82ED1C74; continue 'dispatch;
            }
            0x82ED1C70 => {
    //   block [0x82ED1C70..0x82ED1C74)
	// 82ED1C70: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82ED1C74; continue 'dispatch;
            }
            0x82ED1C74 => {
    //   block [0x82ED1C74..0x82ED1C94)
	// 82ED1C74: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED1C78: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82ED1C7C: 93B90004  stw r29, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82ED1C80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED1C84: 409900B8  ble cr6, 0x82ed1d3c
	if !ctx.cr[6].gt {
	pc = 0x82ED1D3C; continue 'dispatch;
	}
	// 82ED1C88: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED1C8C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ED1C90: 3B4B9C80  addi r26, r11, -0x6380
	ctx.r[26].s64 = ctx.r[11].s64 + -25472;
	pc = 0x82ED1C94; continue 'dispatch;
            }
            0x82ED1C94 => {
    //   block [0x82ED1C94..0x82ED1CEC)
	// 82ED1C94: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82ED1C98: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82ED1C9C: 4BFB238D  bl 0x82e84028
	ctx.lr = 0x82ED1CA0;
	sub_82E84028(ctx, base);
	// 82ED1CA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ED1CA4: 482EA3BD  bl 0x831bc060
	ctx.lr = 0x82ED1CA8;
	sub_831BC060(ctx, base);
	// 82ED1CA8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82ED1CAC: 4BDDAEA5  bl 0x82cacb50
	ctx.lr = 0x82ED1CB0;
	sub_82CACB50(ctx, base);
	// 82ED1CB0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED1CB4: 40820108  bne 0x82ed1dbc
	if !ctx.cr[0].eq {
	pc = 0x82ED1DBC; continue 'dispatch;
	}
	// 82ED1CB8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED1CBC: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ED1CC0: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82ED1CC4: 614A84FC  ori r10, r10, 0x84fc
	ctx.r[10].u64 = ctx.r[10].u64 | 34044;
	// 82ED1CC8: 7F2B512E  stwx r25, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[25].u32) };
	// 82ED1CCC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED1CD0: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED1CD4: 7C7F5A14  add r3, r31, r11
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82ED1CD8: 4BFFAC39  bl 0x82ecc910
	ctx.lr = 0x82ED1CDC;
	sub_82ECC910(ctx, base);
	// 82ED1CDC: 839E0020  lwz r28, 0x20(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED1CE0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ED1CE4: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1CE8: 41820034  beq 0x82ed1d1c
	if ctx.cr[0].eq {
	pc = 0x82ED1D1C; continue 'dispatch;
	}
	pc = 0x82ED1CEC; continue 'dispatch;
            }
            0x82ED1CEC => {
    //   block [0x82ED1CEC..0x82ED1D1C)
	// 82ED1CEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ED1CF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED1CF4: 4BFB2335  bl 0x82e84028
	ctx.lr = 0x82ED1CF8;
	sub_82E84028(ctx, base);
	// 82ED1CF8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED1CFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ED1D00: 7C7F5A14  add r3, r31, r11
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82ED1D04: 4BFFC0E5  bl 0x82ecdde8
	ctx.lr = 0x82ED1D08;
	sub_82ECDDE8(ctx, base);
	// 82ED1D08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED1D0C: 418200B0  beq 0x82ed1dbc
	if ctx.cr[0].eq {
	pc = 0x82ED1DBC; continue 'dispatch;
	}
	// 82ED1D10: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82ED1D14: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82ED1D18: 4198FFD4  blt cr6, 0x82ed1cec
	if ctx.cr[6].lt {
	pc = 0x82ED1CEC; continue 'dispatch;
	}
	pc = 0x82ED1D1C; continue 'dispatch;
            }
            0x82ED1D1C => {
    //   block [0x82ED1D1C..0x82ED1D3C)
	// 82ED1D1C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED1D20: 7C7F5A14  add r3, r31, r11
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82ED1D24: 48004095  bl 0x82ed5db8
	ctx.lr = 0x82ED1D28;
	sub_82ED5DB8(ctx, base);
	// 82ED1D28: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED1D2C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82ED1D30: 7FFFC214  add r31, r31, r24
	ctx.r[31].u64 = ctx.r[31].u64 + ctx.r[24].u64;
	// 82ED1D34: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED1D38: 4198FF5C  blt cr6, 0x82ed1c94
	if ctx.cr[6].lt {
	pc = 0x82ED1C94; continue 'dispatch;
	}
	pc = 0x82ED1D3C; continue 'dispatch;
            }
            0x82ED1D3C => {
    //   block [0x82ED1D3C..0x82ED1D44)
	// 82ED1D3C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ED1D40: 48000080  b 0x82ed1dc0
	pc = 0x82ED1DC0; continue 'dispatch;
            }
            0x82ED1D44 => {
    //   block [0x82ED1D44..0x82ED1DA8)
	// 82ED1D44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED1D48: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82ED1D4C: 3BEB9848  addi r31, r11, -0x67b8
	ctx.r[31].s64 = ctx.r[11].s64 + -26552;
	// 82ED1D50: 482EA311  bl 0x831bc060
	ctx.lr = 0x82ED1D54;
	sub_831BC060(ctx, base);
	// 82ED1D54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED1D58: 4BDDADF9  bl 0x82cacb50
	ctx.lr = 0x82ED1D5C;
	sub_82CACB50(ctx, base);
	// 82ED1D5C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED1D60: 4082005C  bne 0x82ed1dbc
	if !ctx.cr[0].eq {
	pc = 0x82ED1DBC; continue 'dispatch;
	}
	// 82ED1D64: 83D7000C  lwz r30, 0xc(r23)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED1D68: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1D6C: 41820050  beq 0x82ed1dbc
	if ctx.cr[0].eq {
	pc = 0x82ED1DBC; continue 'dispatch;
	}
	// 82ED1D70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED1D74: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82ED1D78: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82ED1D7C: 4BFB2225  bl 0x82e83fa0
	ctx.lr = 0x82ED1D80;
	sub_82E83FA0(ctx, base);
	// 82ED1D80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1D84: 41820038  beq 0x82ed1dbc
	if ctx.cr[0].eq {
	pc = 0x82ED1DBC; continue 'dispatch;
	}
	// 82ED1D88: 4BFFF8A9  bl 0x82ed1630
	ctx.lr = 0x82ED1D8C;
	sub_82ED1630(ctx, base);
	// 82ED1D8C: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82ED1D90: 40820038  bne 0x82ed1dc8
	if !ctx.cr[0].eq {
	pc = 0x82ED1DC8; continue 'dispatch;
	}
	// 82ED1D94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ED1D98: 4BFCF3A1  bl 0x82ea1138
	ctx.lr = 0x82ED1D9C;
	sub_82EA1138(ctx, base);
	// 82ED1D9C: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82ED1DA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED1DA4: 40990018  ble cr6, 0x82ed1dbc
	if !ctx.cr[6].gt {
	pc = 0x82ED1DBC; continue 'dispatch;
	}
	pc = 0x82ED1DA8; continue 'dispatch;
            }
            0x82ED1DA8 => {
    //   block [0x82ED1DA8..0x82ED1DBC)
	// 82ED1DA8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82ED1DAC: 4BFCF38D  bl 0x82ea1138
	ctx.lr = 0x82ED1DB0;
	sub_82EA1138(ctx, base);
	// 82ED1DB0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82ED1DB4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82ED1DB8: 4198FFF0  blt cr6, 0x82ed1da8
	if ctx.cr[6].lt {
	pc = 0x82ED1DA8; continue 'dispatch;
	}
	pc = 0x82ED1DBC; continue 'dispatch;
            }
            0x82ED1DBC => {
    //   block [0x82ED1DBC..0x82ED1DC0)
	// 82ED1DBC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ED1DC0; continue 'dispatch;
            }
            0x82ED1DC0 => {
    //   block [0x82ED1DC0..0x82ED1DC8)
	// 82ED1DC0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82ED1DC4: 4BDD7680  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ED1DC8 => {
    //   block [0x82ED1DC8..0x82ED1DEC)
	// 82ED1DC8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED1DCC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82ED1DD0: 388B9820  addi r4, r11, -0x67e0
	ctx.r[4].s64 = ctx.r[11].s64 + -26592;
	// 82ED1DD4: 4BFB21CD  bl 0x82e83fa0
	ctx.lr = 0x82ED1DD8;
	sub_82E83FA0(ctx, base);
	// 82ED1DD8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82ED1DDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1DE0: 4182000C  beq 0x82ed1dec
	if ctx.cr[0].eq {
	pc = 0x82ED1DEC; continue 'dispatch;
	}
	// 82ED1DE4: 4BDD85DD  bl 0x82caa3c0
	ctx.lr = 0x82ED1DE8;
	sub_82CAA3C0(ctx, base);
	// 82ED1DE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x82ED1DEC; continue 'dispatch;
            }
            0x82ED1DEC => {
    //   block [0x82ED1DEC..0x82ED1E10)
	// 82ED1DEC: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82ED1DF0: 4B744B39  bl 0x82616928
	ctx.lr = 0x82ED1DF4;
	sub_82616928(ctx, base);
	// 82ED1DF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1DF8: 41820018  beq 0x82ed1e10
	if ctx.cr[0].eq {
	pc = 0x82ED1E10; continue 'dispatch;
	}
	// 82ED1DFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ED1E00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED1E04: 4BFFE88D  bl 0x82ed0690
	ctx.lr = 0x82ED1E08;
	sub_82ED0690(ctx, base);
	// 82ED1E08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ED1E0C: 48000008  b 0x82ed1e14
	pc = 0x82ED1E14; continue 'dispatch;
            }
            0x82ED1E10 => {
    //   block [0x82ED1E10..0x82ED1E14)
	// 82ED1E10: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82ED1E14; continue 'dispatch;
            }
            0x82ED1E14 => {
    //   block [0x82ED1E14..0x82ED1E2C)
	// 82ED1E14: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82ED1E18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ED1E1C: 419A0070  beq cr6, 0x82ed1e8c
	if ctx.cr[6].eq {
	pc = 0x82ED1E8C; continue 'dispatch;
	}
	// 82ED1E20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED1E24: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82ED1E28: 3BCBAFB4  addi r30, r11, -0x504c
	ctx.r[30].s64 = ctx.r[11].s64 + -20556;
	pc = 0x82ED1E2C; continue 'dispatch;
            }
            0x82ED1E2C => {
    //   block [0x82ED1E2C..0x82ED1E84)
	// 82ED1E2C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED1E30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED1E34: 4E800421  bctrl
	ctx.lr = 0x82ED1E38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED1E38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED1E3C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82ED1E40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED1E44: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82ED1E48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED1E4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED1E50: 4E800421  bctrl
	ctx.lr = 0x82ED1E54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED1E54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED1E58: 4182002C  beq 0x82ed1e84
	if ctx.cr[0].eq {
	pc = 0x82ED1E84; continue 'dispatch;
	}
	// 82ED1E5C: 81790018  lwz r11, 0x18(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED1E60: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82ED1E64: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82ED1E68: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82ED1E6C: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 82ED1E70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ED1E74: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82ED1E78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED1E7C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82ED1E80: 4BFADCF1  bl 0x82e7fb70
	ctx.lr = 0x82ED1E84;
	sub_82E7FB70(ctx, base);
            }
            0x82ED1E84 => {
    //   block [0x82ED1E84..0x82ED1E8C)
	// 82ED1E84: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82ED1E88: 4082FFA4  bne 0x82ed1e2c
	if !ctx.cr[0].eq {
	pc = 0x82ED1E2C; continue 'dispatch;
	}
	pc = 0x82ED1E8C; continue 'dispatch;
            }
            0x82ED1E8C => {
    //   block [0x82ED1E8C..0x82ED1E9C)
	// 82ED1E8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ED1E90: 3879000C  addi r3, r25, 0xc
	ctx.r[3].s64 = ctx.r[25].s64 + 12;
	// 82ED1E94: 4BFFEA3D  bl 0x82ed08d0
	ctx.lr = 0x82ED1E98;
	sub_82ED08D0(ctx, base);
	// 82ED1E98: 4BFFFEA4  b 0x82ed1d3c
	pc = 0x82ED1D3C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED1EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED1EA0 size=24
    let mut pc: u32 = 0x82ED1EA0;
    'dispatch: loop {
        match pc {
            0x82ED1EA0 => {
    //   block [0x82ED1EA0..0x82ED1EB8)
	// 82ED1EA0: 81630034  lwz r11, 0x34(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED1EA4: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED1EA8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1EAC: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82ED1EB0: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED1EB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED1EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED1EB8 size=24
    let mut pc: u32 = 0x82ED1EB8;
    'dispatch: loop {
        match pc {
            0x82ED1EB8 => {
    //   block [0x82ED1EB8..0x82ED1ED0)
	// 82ED1EB8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82ED1EBC: 816A0294  lwz r11, 0x294(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(660 as u32) ) } as u64;
	// 82ED1EC0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ED1EC4: 419A000C  beq cr6, 0x82ed1ed0
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ED1ED0);
		return;
	}
	// 82ED1EC8: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED1ECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED1F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED1F08 size=48
    let mut pc: u32 = 0x82ED1F08;
    'dispatch: loop {
        match pc {
            0x82ED1F08 => {
    //   block [0x82ED1F08..0x82ED1F24)
	// 82ED1F08: 81430034  lwz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED1F0C: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED1F10: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1F14: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED1F18: 4182000C  beq 0x82ed1f24
	if ctx.cr[0].eq {
	pc = 0x82ED1F24; continue 'dispatch;
	}
	// 82ED1F1C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED1F20: 48000008  b 0x82ed1f28
	pc = 0x82ED1F28; continue 'dispatch;
            }
            0x82ED1F24 => {
    //   block [0x82ED1F24..0x82ED1F28)
	// 82ED1F24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82ED1F28; continue 'dispatch;
            }
            0x82ED1F28 => {
    //   block [0x82ED1F28..0x82ED1F38)
	// 82ED1F28: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED1F2C: 4099000C  ble cr6, 0x82ed1f38
	if !ctx.cr[6].gt {
		sub_82ED1F38(ctx, base);
		return;
	}
	// 82ED1F30: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82ED1F34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED1F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED1F38 size=28
    let mut pc: u32 = 0x82ED1F38;
    'dispatch: loop {
        match pc {
            0x82ED1F38 => {
    //   block [0x82ED1F38..0x82ED1F54)
	// 82ED1F38: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED1F3C: 4199FFF4  bgt cr6, 0x82ed1f30
	if ctx.cr[6].gt {
		sub_82ED1F08(ctx, base);
		return;
	}
	// 82ED1F40: 5549F87E  srwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82ED1F44: 7F054840  cmplw cr6, r5, r9
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ED1F48: 4099000C  ble cr6, 0x82ed1f54
	if !ctx.cr[6].gt {
		sub_82ED1F54(ctx, base);
		return;
	}
	// 82ED1F4C: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 82ED1F50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED1F54(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED1F54 size=32
    let mut pc: u32 = 0x82ED1F54;
    'dispatch: loop {
        match pc {
            0x82ED1F54 => {
    //   block [0x82ED1F54..0x82ED1F74)
	// 82ED1F54: 5569F87E  srwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82ED1F58: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ED1F5C: 4199FFF0  bgt cr6, 0x82ed1f4c
	if ctx.cr[6].gt {
		sub_82ED1F38(ctx, base);
		return;
	}
	// 82ED1F60: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED1F64: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED1F68: 4099000C  ble cr6, 0x82ed1f74
	if !ctx.cr[6].gt {
		sub_82ED1F74(ctx, base);
		return;
	}
	// 82ED1F6C: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82ED1F70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED1F74(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED1F74 size=40
    let mut pc: u32 = 0x82ED1F74;
    'dispatch: loop {
        match pc {
            0x82ED1F74 => {
    //   block [0x82ED1F74..0x82ED1F94)
	// 82ED1F74: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED1F78: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED1F7C: 4199FFF0  bgt cr6, 0x82ed1f6c
	if ctx.cr[6].gt {
		sub_82ED1F54(ctx, base);
		return;
	}
	// 82ED1F80: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82ED1F84: 409A0010  bne cr6, 0x82ed1f94
	if !ctx.cr[6].eq {
	pc = 0x82ED1F94; continue 'dispatch;
	}
	// 82ED1F88: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82ED1F8C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED1F90: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x82ED1F94; continue 'dispatch;
            }
            0x82ED1F94 => {
    //   block [0x82ED1F94..0x82ED1F9C)
	// 82ED1F94: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ED1F98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED1FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED1FA0 size=32
    let mut pc: u32 = 0x82ED1FA0;
    'dispatch: loop {
        match pc {
            0x82ED1FA0 => {
    //   block [0x82ED1FA0..0x82ED1FC0)
	// 82ED1FA0: 89630298  lbz r11, 0x298(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(664 as u32) ) } as u64;
	// 82ED1FA4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED1FA8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82ED1FAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ED1FB0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ED1FB4: 99630298  stb r11, 0x298(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(664 as u32), ctx.r[11].u8 ) };
	// 82ED1FB8: 9143029C  stw r10, 0x29c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(668 as u32), ctx.r[10].u32 ) };
	// 82ED1FBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED1FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED1FC0 size=16
    let mut pc: u32 = 0x82ED1FC0;
    'dispatch: loop {
        match pc {
            0x82ED1FC0 => {
    //   block [0x82ED1FC0..0x82ED1FD0)
	// 82ED1FC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED1FC4: 99630298  stb r11, 0x298(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(664 as u32), ctx.r[11].u8 ) };
	// 82ED1FC8: 9163029C  stw r11, 0x29c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(668 as u32), ctx.r[11].u32 ) };
	// 82ED1FCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED1FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED1FD0 size=144
    let mut pc: u32 = 0x82ED1FD0;
    'dispatch: loop {
        match pc {
            0x82ED1FD0 => {
    //   block [0x82ED1FD0..0x82ED2014)
	// 82ED1FD0: 81630208  lwz r11, 0x208(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(520 as u32) ) } as u64;
	// 82ED1FD4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1FD8: 418200B8  beq 0x82ed2090
	if ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ED2090);
		return;
	}
	// 82ED1FDC: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED1FE0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED1FE4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED1FE8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED1FEC: 418200A4  beq 0x82ed2090
	if ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ED2090);
		return;
	}
	// 82ED1FF0: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 82ED1FF4: 409A006C  bne cr6, 0x82ed2060
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ED2060);
		return;
	}
	// 82ED1FF8: 81630208  lwz r11, 0x208(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(520 as u32) ) } as u64;
	// 82ED1FFC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ED2000: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ED2004: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ED2008: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED200C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED2010: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x82ED2014; continue 'dispatch;
            }
            0x82ED2014 => {
    //   block [0x82ED2014..0x82ED2038)
	// 82ED2014: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED2018: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED201C: 4182001C  beq 0x82ed2038
	if ctx.cr[0].eq {
	pc = 0x82ED2038; continue 'dispatch;
	}
	// 82ED2020: 55470001  rlwinm. r7, r10, 0, 0, 0
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82ED2024: 41820014  beq 0x82ed2038
	if ctx.cr[0].eq {
	pc = 0x82ED2038; continue 'dispatch;
	}
	// 82ED2028: 554A007E  clrlwi r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED202C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82ED2030: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82ED2034: 419A0018  beq cr6, 0x82ed204c
	if ctx.cr[6].eq {
	pc = 0x82ED204C; continue 'dispatch;
	}
	pc = 0x82ED2038; continue 'dispatch;
            }
            0x82ED2038 => {
    //   block [0x82ED2038..0x82ED204C)
	// 82ED2038: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED203C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ED2040: 2B090004  cmplwi cr6, r9, 4
	ctx.cr[6].compare_u32(ctx.r[9].u32, 4 as u32, &mut ctx.xer);
	// 82ED2044: 4198FFD0  blt cr6, 0x82ed2014
	if ctx.cr[6].lt {
	pc = 0x82ED2014; continue 'dispatch;
	}
	// 82ED2048: 48000008  b 0x82ed2050
	pc = 0x82ED2050; continue 'dispatch;
            }
            0x82ED204C => {
    //   block [0x82ED204C..0x82ED2050)
	// 82ED204C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x82ED2050; continue 'dispatch;
            }
            0x82ED2050 => {
    //   block [0x82ED2050..0x82ED2060)
	// 82ED2050: 550B063F  clrlwi. r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED2054: 4082003C  bne 0x82ed2090
	if !ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ED2090);
		return;
	}
	// 82ED2058: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ED205C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED2098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED2098 size=964
    let mut pc: u32 = 0x82ED2098;
    'dispatch: loop {
        match pc {
            0x82ED2098 => {
    //   block [0x82ED2098..0x82ED20D8)
	// 82ED2098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED209C: 4BDD7355  bl 0x82ca93f0
	ctx.lr = 0x82ED20A0;
	sub_82CA93D0(ctx, base);
	// 82ED20A0: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82ED20A4: 4BDDBC29  bl 0x82cadccc
	ctx.lr = 0x82ED20A8;
	sub_82CADCA0(ctx, base);
	// 82ED20A8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED20AC: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 82ED20B0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82ED20B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED20B8: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82ED20BC: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 82ED20C0: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 82ED20C4: 93990000  stw r28, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82ED20C8: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 82ED20CC: 817F0294  lwz r11, 0x294(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 82ED20D0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ED20D4: 419A000C  beq cr6, 0x82ed20e0
	if ctx.cr[6].eq {
	pc = 0x82ED20E0; continue 'dispatch;
	}
	pc = 0x82ED20D8; continue 'dispatch;
            }
            0x82ED20D8 => {
    //   block [0x82ED20D8..0x82ED20E0)
	// 82ED20D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED20DC: 48000370  b 0x82ed244c
	pc = 0x82ED244C; continue 'dispatch;
            }
            0x82ED20E0 => {
    //   block [0x82ED20E0..0x82ED20FC)
	// 82ED20E0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ED20E4: 419A0018  beq cr6, 0x82ed20fc
	if ctx.cr[6].eq {
	pc = 0x82ED20FC; continue 'dispatch;
	}
	// 82ED20E8: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED20EC: 616B84DC  ori r11, r11, 0x84dc
	ctx.r[11].u64 = ctx.r[11].u64 | 34012;
	// 82ED20F0: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED20F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED20F8: 419AFFE0  beq cr6, 0x82ed20d8
	if ctx.cr[6].eq {
	pc = 0x82ED20D8; continue 'dispatch;
	}
	pc = 0x82ED20FC; continue 'dispatch;
            }
            0x82ED20FC => {
    //   block [0x82ED20FC..0x82ED213C)
	// 82ED20FC: 817F0180  lwz r11, 0x180(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82ED2100: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED2104: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED2108: EFC00828  fsubs f30, f0, f1
	ctx.f[30].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82ED210C: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED2110: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED2114: EF8D0828  fsubs f28, f13, f1
	ctx.f[28].f64 = (((ctx.f[13].f64 - ctx.f[1].f64) as f32) as f64);
	// 82ED2118: EF6C0828  fsubs f27, f12, f1
	ctx.f[27].f64 = (((ctx.f[12].f64 - ctx.f[1].f64) as f32) as f64);
	// 82ED211C: EFA0082A  fadds f29, f0, f1
	ctx.f[29].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82ED2120: EF4D082A  fadds f26, f13, f1
	ctx.f[26].f64 = ((ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64;
	// 82ED2124: EF2C082A  fadds f25, f12, f1
	ctx.f[25].f64 = ((ctx.f[12].f64 + ctx.f[1].f64) as f32) as f64;
	// 82ED2128: 409A0130  bne cr6, 0x82ed2258
	if !ctx.cr[6].eq {
	pc = 0x82ED2258; continue 'dispatch;
	}
	// 82ED212C: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED2130: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED2134: 40990314  ble cr6, 0x82ed2448
	if !ctx.cr[6].gt {
	pc = 0x82ED2448; continue 'dispatch;
	}
	// 82ED2138: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	pc = 0x82ED213C; continue 'dispatch;
            }
            0x82ED213C => {
    //   block [0x82ED213C..0x82ED2190)
	// 82ED213C: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ED2140: 7FDB5A14  add r30, r27, r11
	ctx.r[30].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 82ED2144: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED2148: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82ED214C: 409A00F4  bne cr6, 0x82ed2240
	if !ctx.cr[6].eq {
	pc = 0x82ED2240; continue 'dispatch;
	}
	// 82ED2150: 817F020C  lwz r11, 0x20c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 82ED2154: 7D6BE0AE  lbzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82ED2158: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED215C: 419A00E4  beq cr6, 0x82ed2240
	if ctx.cr[6].eq {
	pc = 0x82ED2240; continue 'dispatch;
	}
	// 82ED2160: 3FBF0001  addis r29, r31, 1
	ctx.r[29].s64 = ctx.r[31].s64 + 65536;
	// 82ED2164: 3BBD84D8  addi r29, r29, -0x7b28
	ctx.r[29].s64 = ctx.r[29].s64 + -31528;
	// 82ED2168: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED216C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED2170: 409A003C  bne cr6, 0x82ed21ac
	if !ctx.cr[6].eq {
	pc = 0x82ED21AC; continue 'dispatch;
	}
	// 82ED2174: 56CB063F  clrlwi. r11, r22, 0x18
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED2178: 40820034  bne 0x82ed21ac
	if !ctx.cr[0].eq {
	pc = 0x82ED21AC; continue 'dispatch;
	}
	// 82ED217C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED2180: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ED2184: 409A000C  bne cr6, 0x82ed2190
	if !ctx.cr[6].eq {
	pc = 0x82ED2190; continue 'dispatch;
	}
	// 82ED2188: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED218C: 48000008  b 0x82ed2194
	pc = 0x82ED2194; continue 'dispatch;
            }
            0x82ED2190 => {
    //   block [0x82ED2190..0x82ED2194)
	// 82ED2190: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	pc = 0x82ED2194; continue 'dispatch;
            }
            0x82ED2194 => {
    //   block [0x82ED2194..0x82ED21AC)
	// 82ED2194: 4800459D  bl 0x82ed6730
	ctx.lr = 0x82ED2198;
	sub_82ED6730(ctx, base);
	// 82ED2198: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED219C: 419A00A4  beq cr6, 0x82ed2240
	if ctx.cr[6].eq {
	pc = 0x82ED2240; continue 'dispatch;
	}
	// 82ED21A0: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED21A4: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED21A8: 409A0098  bne cr6, 0x82ed2240
	if !ctx.cr[6].eq {
	pc = 0x82ED2240; continue 'dispatch;
	}
	pc = 0x82ED21AC; continue 'dispatch;
            }
            0x82ED21AC => {
    //   block [0x82ED21AC..0x82ED21CC)
	// 82ED21AC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED21B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED21B4: 409A0018  bne cr6, 0x82ed21cc
	if !ctx.cr[6].eq {
	pc = 0x82ED21CC; continue 'dispatch;
	}
	// 82ED21B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ED21BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED21C0: 4BFFFE11  bl 0x82ed1fd0
	ctx.lr = 0x82ED21C4;
	sub_82ED1FD0(ctx, base);
	// 82ED21C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED21C8: 40820078  bne 0x82ed2240
	if !ctx.cr[0].eq {
	pc = 0x82ED2240; continue 'dispatch;
	}
	pc = 0x82ED21CC; continue 'dispatch;
            }
            0x82ED21CC => {
    //   block [0x82ED21CC..0x82ED2234)
	// 82ED21CC: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED21D0: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82ED21D4: 4199006C  bgt cr6, 0x82ed2240
	if ctx.cr[6].gt {
	pc = 0x82ED2240; continue 'dispatch;
	}
	// 82ED21D8: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED21DC: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82ED21E0: 41990060  bgt cr6, 0x82ed2240
	if ctx.cr[6].gt {
	pc = 0x82ED2240; continue 'dispatch;
	}
	// 82ED21E4: C01E0014  lfs f0, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED21E8: FF00C800  fcmpu cr6, f0, f25
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[25].f64);
	// 82ED21EC: 41990054  bgt cr6, 0x82ed2240
	if ctx.cr[6].gt {
	pc = 0x82ED2240; continue 'dispatch;
	}
	// 82ED21F0: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED21F4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82ED21F8: 41980048  blt cr6, 0x82ed2240
	if ctx.cr[6].lt {
	pc = 0x82ED2240; continue 'dispatch;
	}
	// 82ED21FC: C01E0010  lfs f0, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED2200: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82ED2204: 4198003C  blt cr6, 0x82ed2240
	if ctx.cr[6].lt {
	pc = 0x82ED2240; continue 'dispatch;
	}
	// 82ED2208: C01E0018  lfs f0, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED220C: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82ED2210: 41980030  blt cr6, 0x82ed2240
	if ctx.cr[6].lt {
	pc = 0x82ED2240; continue 'dispatch;
	}
	// 82ED2214: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED2218: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82ED221C: 4098022C  bge cr6, 0x82ed2448
	if !ctx.cr[6].lt {
	pc = 0x82ED2448; continue 'dispatch;
	}
	// 82ED2220: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82ED2224: 419A0010  beq cr6, 0x82ed2234
	if ctx.cr[6].eq {
	pc = 0x82ED2234; continue 'dispatch;
	}
	// 82ED2228: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED222C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED2230: 7D4BC12E  stwx r10, r11, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32), ctx.r[10].u32) };
	pc = 0x82ED2234; continue 'dispatch;
            }
            0x82ED2234 => {
    //   block [0x82ED2234..0x82ED2240)
	// 82ED2234: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED2238: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED223C: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED2240; continue 'dispatch;
            }
            0x82ED2240 => {
    //   block [0x82ED2240..0x82ED2258)
	// 82ED2240: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED2244: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ED2248: 3B7B0030  addi r27, r27, 0x30
	ctx.r[27].s64 = ctx.r[27].s64 + 48;
	// 82ED224C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED2250: 4198FEEC  blt cr6, 0x82ed213c
	if ctx.cr[6].lt {
	pc = 0x82ED213C; continue 'dispatch;
	}
	// 82ED2254: 480001F4  b 0x82ed2448
	pc = 0x82ED2448; continue 'dispatch;
            }
            0x82ED2258 => {
    //   block [0x82ED2258..0x82ED22B4)
	// 82ED2258: 7B4A0020  clrldi r10, r26, 0x20
	ctx.r[10].u64 = ctx.r[26].u64 & 0x00000000FFFFFFFFu64;
	// 82ED225C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED2260: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82ED2264: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82ED2268: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82ED226C: C82B0DE8  lfd f1, 0xde8(r11)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3560 as u32) ) };
	// 82ED2270: FC400018  frsp f2, f0
	ctx.f[2].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82ED2274: 4B32C235  bl 0x821fe4a8
	ctx.lr = 0x82ED2278;
	sub_821FE4A8(ctx, base);
	// 82ED2278: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED227C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82ED2280: 815F017C  lwz r10, 0x17c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED2284: C01F0190  lfs f0, 0x190(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED2288: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ED228C: FDA06E5E  fctidz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 82ED2290: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82ED2294: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED2298: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82ED229C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82ED22A0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82ED22A4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82ED22A8: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED22AC: 4099019C  ble cr6, 0x82ed2448
	if !ctx.cr[6].gt {
	pc = 0x82ED2448; continue 'dispatch;
	}
	// 82ED22B0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	pc = 0x82ED22B4; continue 'dispatch;
            }
            0x82ED22B4 => {
    //   block [0x82ED22B4..0x82ED2308)
	// 82ED22B4: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ED22B8: 7FDD5A14  add r30, r29, r11
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82ED22BC: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED22C0: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82ED22C4: 409A0170  bne cr6, 0x82ed2434
	if !ctx.cr[6].eq {
	pc = 0x82ED2434; continue 'dispatch;
	}
	// 82ED22C8: 817F020C  lwz r11, 0x20c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 82ED22CC: 7D6BE0AE  lbzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82ED22D0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED22D4: 419A0160  beq cr6, 0x82ed2434
	if ctx.cr[6].eq {
	pc = 0x82ED2434; continue 'dispatch;
	}
	// 82ED22D8: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED22DC: 616B84D8  ori r11, r11, 0x84d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34008;
	// 82ED22E0: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED22E4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED22E8: 409A003C  bne cr6, 0x82ed2324
	if !ctx.cr[6].eq {
	pc = 0x82ED2324; continue 'dispatch;
	}
	// 82ED22EC: 56CB063F  clrlwi. r11, r22, 0x18
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED22F0: 40820034  bne 0x82ed2324
	if !ctx.cr[0].eq {
	pc = 0x82ED2324; continue 'dispatch;
	}
	// 82ED22F4: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED22F8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ED22FC: 409A000C  bne cr6, 0x82ed2308
	if !ctx.cr[6].eq {
	pc = 0x82ED2308; continue 'dispatch;
	}
	// 82ED2300: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED2304: 48000008  b 0x82ed230c
	pc = 0x82ED230C; continue 'dispatch;
            }
            0x82ED2308 => {
    //   block [0x82ED2308..0x82ED230C)
	// 82ED2308: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	pc = 0x82ED230C; continue 'dispatch;
            }
            0x82ED230C => {
    //   block [0x82ED230C..0x82ED2324)
	// 82ED230C: 48004425  bl 0x82ed6730
	ctx.lr = 0x82ED2310;
	sub_82ED6730(ctx, base);
	// 82ED2310: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED2314: 419A0120  beq cr6, 0x82ed2434
	if ctx.cr[6].eq {
	pc = 0x82ED2434; continue 'dispatch;
	}
	// 82ED2318: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED231C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED2320: 409A0114  bne cr6, 0x82ed2434
	if !ctx.cr[6].eq {
	pc = 0x82ED2434; continue 'dispatch;
	}
	pc = 0x82ED2324; continue 'dispatch;
            }
            0x82ED2324 => {
    //   block [0x82ED2324..0x82ED2428)
	// 82ED2324: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED2328: C01F0184  lfs f0, 0x184(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED232C: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED2330: C1BF0188  lfs f13, 0x188(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED2334: 7D4707B4  extsw r7, r10
	ctx.r[7].s64 = ctx.r[10].s32 as i64;
	// 82ED2338: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED233C: 7D2607B4  extsw r6, r9
	ctx.r[6].s64 = ctx.r[9].s32 as i64;
	// 82ED2340: C19F018C  lfs f12, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED2344: 7D6807B4  extsw r8, r11
	ctx.r[8].s64 = ctx.r[11].s32 as i64;
	// 82ED2348: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 82ED234C: F8C10060  std r6, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u64 ) };
	// 82ED2350: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82ED2354: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82ED2358: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82ED235C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82ED2360: ED6B07FA  fmadds f11, f11, f31, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED2364: FF1D5800  fcmpu cr6, f29, f11
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[11].f64);
	// 82ED2368: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82ED236C: C9210060  lfd f9, 0x60(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82ED2370: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 82ED2374: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 82ED2378: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82ED237C: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82ED2380: ED4A6FFA  fmadds f10, f10, f31, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 82ED2384: ED2967FA  fmadds f9, f9, f31, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64);
	// 82ED2388: 419800AC  blt cr6, 0x82ed2434
	if ctx.cr[6].lt {
	pc = 0x82ED2434; continue 'dispatch;
	}
	// 82ED238C: FF1A5000  fcmpu cr6, f26, f10
	ctx.cr[6].compare_f64(ctx.f[26].f64, ctx.f[10].f64);
	// 82ED2390: 419800A4  blt cr6, 0x82ed2434
	if ctx.cr[6].lt {
	pc = 0x82ED2434; continue 'dispatch;
	}
	// 82ED2394: FF194800  fcmpu cr6, f25, f9
	ctx.cr[6].compare_f64(ctx.f[25].f64, ctx.f[9].f64);
	// 82ED2398: 4198009C  blt cr6, 0x82ed2434
	if ctx.cr[6].lt {
	pc = 0x82ED2434; continue 'dispatch;
	}
	// 82ED239C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED23A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED23A4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ED23A8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED23AC: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED23B0: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ED23B4: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 82ED23B8: F9410070  std r10, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u64 ) };
	// 82ED23BC: F9210078  std r9, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u64 ) };
	// 82ED23C0: C9610068  lfd f11, 0x68(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82ED23C4: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82ED23C8: C9410070  lfd f10, 0x70(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82ED23CC: C9210078  lfd f9, 0x78(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82ED23D0: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 82ED23D4: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 82ED23D8: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82ED23DC: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82ED23E0: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82ED23E4: EC0B07FA  fmadds f0, f11, f31, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED23E8: EDAA6FFA  fmadds f13, f10, f31, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 82ED23EC: ED8967FA  fmadds f12, f9, f31, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64);
	// 82ED23F0: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82ED23F4: 41990040  bgt cr6, 0x82ed2434
	if ctx.cr[6].gt {
	pc = 0x82ED2434; continue 'dispatch;
	}
	// 82ED23F8: FF1C6800  fcmpu cr6, f28, f13
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[13].f64);
	// 82ED23FC: 41990038  bgt cr6, 0x82ed2434
	if ctx.cr[6].gt {
	pc = 0x82ED2434; continue 'dispatch;
	}
	// 82ED2400: FF1B6000  fcmpu cr6, f27, f12
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[12].f64);
	// 82ED2404: 41990030  bgt cr6, 0x82ed2434
	if ctx.cr[6].gt {
	pc = 0x82ED2434; continue 'dispatch;
	}
	// 82ED2408: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED240C: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82ED2410: 40980038  bge cr6, 0x82ed2448
	if !ctx.cr[6].lt {
	pc = 0x82ED2448; continue 'dispatch;
	}
	// 82ED2414: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82ED2418: 419A0010  beq cr6, 0x82ed2428
	if ctx.cr[6].eq {
	pc = 0x82ED2428; continue 'dispatch;
	}
	// 82ED241C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED2420: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED2424: 7D4BC12E  stwx r10, r11, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32), ctx.r[10].u32) };
	pc = 0x82ED2428; continue 'dispatch;
            }
            0x82ED2428 => {
    //   block [0x82ED2428..0x82ED2434)
	// 82ED2428: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED242C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED2430: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED2434; continue 'dispatch;
            }
            0x82ED2434 => {
    //   block [0x82ED2434..0x82ED2448)
	// 82ED2434: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED2438: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ED243C: 3BBD0030  addi r29, r29, 0x30
	ctx.r[29].s64 = ctx.r[29].s64 + 48;
	// 82ED2440: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED2444: 4198FE70  blt cr6, 0x82ed22b4
	if ctx.cr[6].lt {
	pc = 0x82ED22B4; continue 'dispatch;
	}
	pc = 0x82ED2448; continue 'dispatch;
            }
            0x82ED2448 => {
    //   block [0x82ED2448..0x82ED244C)
	// 82ED2448: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82ED244C; continue 'dispatch;
            }
            0x82ED244C => {
    //   block [0x82ED244C..0x82ED245C)
	// 82ED244C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82ED2450: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82ED2454: 4BDDB8C5  bl 0x82cadd18
	ctx.lr = 0x82ED2458;
	sub_82CADCEC(ctx, base);
	// 82ED2458: 4BDD6FE8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED2460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED2460 size=976
    let mut pc: u32 = 0x82ED2460;
    'dispatch: loop {
        match pc {
            0x82ED2460 => {
    //   block [0x82ED2460..0x82ED24A4)
	// 82ED2460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED2464: 4BDD6F85  bl 0x82ca93e8
	ctx.lr = 0x82ED2468;
	sub_82CA93D0(ctx, base);
	// 82ED2468: DBE1FF90  stfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 82ED246C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED2470: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 82ED2474: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82ED2478: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED247C: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82ED2480: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82ED2484: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82ED2488: 93990000  stw r28, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82ED248C: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 82ED2490: 817F0294  lwz r11, 0x294(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 82ED2494: 7D154378  mr r21, r8
	ctx.r[21].u64 = ctx.r[8].u64;
	// 82ED2498: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 82ED249C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ED24A0: 419A000C  beq cr6, 0x82ed24ac
	if ctx.cr[6].eq {
	pc = 0x82ED24AC; continue 'dispatch;
	}
	pc = 0x82ED24A4; continue 'dispatch;
            }
            0x82ED24A4 => {
    //   block [0x82ED24A4..0x82ED24AC)
	// 82ED24A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED24A8: 4800037C  b 0x82ed2824
	pc = 0x82ED2824; continue 'dispatch;
            }
            0x82ED24AC => {
    //   block [0x82ED24AC..0x82ED24C8)
	// 82ED24AC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ED24B0: 419A0018  beq cr6, 0x82ed24c8
	if ctx.cr[6].eq {
	pc = 0x82ED24C8; continue 'dispatch;
	}
	// 82ED24B4: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED24B8: 616B84DC  ori r11, r11, 0x84dc
	ctx.r[11].u64 = ctx.r[11].u64 | 34012;
	// 82ED24BC: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED24C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED24C4: 419AFFE0  beq cr6, 0x82ed24a4
	if ctx.cr[6].eq {
	pc = 0x82ED24A4; continue 'dispatch;
	}
	pc = 0x82ED24C8; continue 'dispatch;
            }
            0x82ED24C8 => {
    //   block [0x82ED24C8..0x82ED24E4)
	// 82ED24C8: 817F0180  lwz r11, 0x180(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82ED24CC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED24D0: 409A0148  bne cr6, 0x82ed2618
	if !ctx.cr[6].eq {
	pc = 0x82ED2618; continue 'dispatch;
	}
	// 82ED24D4: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED24D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED24DC: 40990344  ble cr6, 0x82ed2820
	if !ctx.cr[6].gt {
	pc = 0x82ED2820; continue 'dispatch;
	}
	// 82ED24E0: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	pc = 0x82ED24E4; continue 'dispatch;
            }
            0x82ED24E4 => {
    //   block [0x82ED24E4..0x82ED2538)
	// 82ED24E4: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ED24E8: 7FDB5A14  add r30, r27, r11
	ctx.r[30].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 82ED24EC: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED24F0: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82ED24F4: 409A010C  bne cr6, 0x82ed2600
	if !ctx.cr[6].eq {
	pc = 0x82ED2600; continue 'dispatch;
	}
	// 82ED24F8: 817F020C  lwz r11, 0x20c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 82ED24FC: 7D6BE0AE  lbzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82ED2500: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED2504: 419A00FC  beq cr6, 0x82ed2600
	if ctx.cr[6].eq {
	pc = 0x82ED2600; continue 'dispatch;
	}
	// 82ED2508: 3FBF0001  addis r29, r31, 1
	ctx.r[29].s64 = ctx.r[31].s64 + 65536;
	// 82ED250C: 3BBD84D8  addi r29, r29, -0x7b28
	ctx.r[29].s64 = ctx.r[29].s64 + -31528;
	// 82ED2510: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED2514: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED2518: 409A003C  bne cr6, 0x82ed2554
	if !ctx.cr[6].eq {
	pc = 0x82ED2554; continue 'dispatch;
	}
	// 82ED251C: 568B063F  clrlwi. r11, r20, 0x18
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED2520: 40820034  bne 0x82ed2554
	if !ctx.cr[0].eq {
	pc = 0x82ED2554; continue 'dispatch;
	}
	// 82ED2524: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED2528: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ED252C: 409A000C  bne cr6, 0x82ed2538
	if !ctx.cr[6].eq {
	pc = 0x82ED2538; continue 'dispatch;
	}
	// 82ED2530: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED2534: 48000008  b 0x82ed253c
	pc = 0x82ED253C; continue 'dispatch;
            }
            0x82ED2538 => {
    //   block [0x82ED2538..0x82ED253C)
	// 82ED2538: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	pc = 0x82ED253C; continue 'dispatch;
            }
            0x82ED253C => {
    //   block [0x82ED253C..0x82ED2554)
	// 82ED253C: 480041F5  bl 0x82ed6730
	ctx.lr = 0x82ED2540;
	sub_82ED6730(ctx, base);
	// 82ED2540: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED2544: 419A00BC  beq cr6, 0x82ed2600
	if ctx.cr[6].eq {
	pc = 0x82ED2600; continue 'dispatch;
	}
	// 82ED2548: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED254C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED2550: 409A00B0  bne cr6, 0x82ed2600
	if !ctx.cr[6].eq {
	pc = 0x82ED2600; continue 'dispatch;
	}
	pc = 0x82ED2554; continue 'dispatch;
            }
            0x82ED2554 => {
    //   block [0x82ED2554..0x82ED2574)
	// 82ED2554: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED2558: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED255C: 409A0018  bne cr6, 0x82ed2574
	if !ctx.cr[6].eq {
	pc = 0x82ED2574; continue 'dispatch;
	}
	// 82ED2560: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ED2564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED2568: 4BFFFA69  bl 0x82ed1fd0
	ctx.lr = 0x82ED256C;
	sub_82ED1FD0(ctx, base);
	// 82ED256C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED2570: 40820090  bne 0x82ed2600
	if !ctx.cr[0].eq {
	pc = 0x82ED2600; continue 'dispatch;
	}
	pc = 0x82ED2574; continue 'dispatch;
            }
            0x82ED2574 => {
    //   block [0x82ED2574..0x82ED25F4)
	// 82ED2574: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED2578: C1B80000  lfs f13, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED257C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED2580: 41990080  bgt cr6, 0x82ed2600
	if ctx.cr[6].gt {
	pc = 0x82ED2600; continue 'dispatch;
	}
	// 82ED2584: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED2588: C1B80004  lfs f13, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED258C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED2590: 41990070  bgt cr6, 0x82ed2600
	if ctx.cr[6].gt {
	pc = 0x82ED2600; continue 'dispatch;
	}
	// 82ED2594: C01E0014  lfs f0, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED2598: C1B80008  lfs f13, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED259C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED25A0: 41990060  bgt cr6, 0x82ed2600
	if ctx.cr[6].gt {
	pc = 0x82ED2600; continue 'dispatch;
	}
	// 82ED25A4: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED25A8: C1B70000  lfs f13, 0(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED25AC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED25B0: 41980050  blt cr6, 0x82ed2600
	if ctx.cr[6].lt {
	pc = 0x82ED2600; continue 'dispatch;
	}
	// 82ED25B4: C01E0010  lfs f0, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED25B8: C1B70004  lfs f13, 4(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED25BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED25C0: 41980040  blt cr6, 0x82ed2600
	if ctx.cr[6].lt {
	pc = 0x82ED2600; continue 'dispatch;
	}
	// 82ED25C4: C01E0018  lfs f0, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED25C8: C1B70008  lfs f13, 8(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED25CC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED25D0: 41980030  blt cr6, 0x82ed2600
	if ctx.cr[6].lt {
	pc = 0x82ED2600; continue 'dispatch;
	}
	// 82ED25D4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED25D8: 7F0BA840  cmplw cr6, r11, r21
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82ED25DC: 40980244  bge cr6, 0x82ed2820
	if !ctx.cr[6].lt {
	pc = 0x82ED2820; continue 'dispatch;
	}
	// 82ED25E0: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82ED25E4: 419A0010  beq cr6, 0x82ed25f4
	if ctx.cr[6].eq {
	pc = 0x82ED25F4; continue 'dispatch;
	}
	// 82ED25E8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED25EC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED25F0: 7D4BB12E  stwx r10, r11, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32), ctx.r[10].u32) };
	pc = 0x82ED25F4; continue 'dispatch;
            }
            0x82ED25F4 => {
    //   block [0x82ED25F4..0x82ED2600)
	// 82ED25F4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED25F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED25FC: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED2600; continue 'dispatch;
            }
            0x82ED2600 => {
    //   block [0x82ED2600..0x82ED2618)
	// 82ED2600: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED2604: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ED2608: 3B7B0030  addi r27, r27, 0x30
	ctx.r[27].s64 = ctx.r[27].s64 + 48;
	// 82ED260C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED2610: 4198FED4  blt cr6, 0x82ed24e4
	if ctx.cr[6].lt {
	pc = 0x82ED24E4; continue 'dispatch;
	}
	// 82ED2614: 4800020C  b 0x82ed2820
	pc = 0x82ED2820; continue 'dispatch;
            }
            0x82ED2618 => {
    //   block [0x82ED2618..0x82ED2674)
	// 82ED2618: 7B4A0020  clrldi r10, r26, 0x20
	ctx.r[10].u64 = ctx.r[26].u64 & 0x00000000FFFFFFFFu64;
	// 82ED261C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED2620: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82ED2624: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82ED2628: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82ED262C: C82B0DE8  lfd f1, 0xde8(r11)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3560 as u32) ) };
	// 82ED2630: FC400018  frsp f2, f0
	ctx.f[2].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82ED2634: 4B32BE75  bl 0x821fe4a8
	ctx.lr = 0x82ED2638;
	sub_821FE4A8(ctx, base);
	// 82ED2638: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED263C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82ED2640: 815F017C  lwz r10, 0x17c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED2644: C01F0190  lfs f0, 0x190(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED2648: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ED264C: FDA06E5E  fctidz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 82ED2650: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82ED2654: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED2658: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82ED265C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82ED2660: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82ED2664: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82ED2668: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED266C: 409901B4  ble cr6, 0x82ed2820
	if !ctx.cr[6].gt {
	pc = 0x82ED2820; continue 'dispatch;
	}
	// 82ED2670: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	pc = 0x82ED2674; continue 'dispatch;
            }
            0x82ED2674 => {
    //   block [0x82ED2674..0x82ED26C8)
	// 82ED2674: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ED2678: 7FDD5A14  add r30, r29, r11
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82ED267C: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED2680: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82ED2684: 409A0188  bne cr6, 0x82ed280c
	if !ctx.cr[6].eq {
	pc = 0x82ED280C; continue 'dispatch;
	}
	// 82ED2688: 817F020C  lwz r11, 0x20c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 82ED268C: 7D6BE0AE  lbzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82ED2690: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED2694: 419A0178  beq cr6, 0x82ed280c
	if ctx.cr[6].eq {
	pc = 0x82ED280C; continue 'dispatch;
	}
	// 82ED2698: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED269C: 616B84D8  ori r11, r11, 0x84d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34008;
	// 82ED26A0: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED26A4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED26A8: 409A003C  bne cr6, 0x82ed26e4
	if !ctx.cr[6].eq {
	pc = 0x82ED26E4; continue 'dispatch;
	}
	// 82ED26AC: 568B063F  clrlwi. r11, r20, 0x18
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED26B0: 40820034  bne 0x82ed26e4
	if !ctx.cr[0].eq {
	pc = 0x82ED26E4; continue 'dispatch;
	}
	// 82ED26B4: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED26B8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ED26BC: 409A000C  bne cr6, 0x82ed26c8
	if !ctx.cr[6].eq {
	pc = 0x82ED26C8; continue 'dispatch;
	}
	// 82ED26C0: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED26C4: 48000008  b 0x82ed26cc
	pc = 0x82ED26CC; continue 'dispatch;
            }
            0x82ED26C8 => {
    //   block [0x82ED26C8..0x82ED26CC)
	// 82ED26C8: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	pc = 0x82ED26CC; continue 'dispatch;
            }
            0x82ED26CC => {
    //   block [0x82ED26CC..0x82ED26E4)
	// 82ED26CC: 48004065  bl 0x82ed6730
	ctx.lr = 0x82ED26D0;
	sub_82ED6730(ctx, base);
	// 82ED26D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED26D4: 419A0138  beq cr6, 0x82ed280c
	if ctx.cr[6].eq {
	pc = 0x82ED280C; continue 'dispatch;
	}
	// 82ED26D8: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED26DC: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED26E0: 409A012C  bne cr6, 0x82ed280c
	if !ctx.cr[6].eq {
	pc = 0x82ED280C; continue 'dispatch;
	}
	pc = 0x82ED26E4; continue 'dispatch;
            }
            0x82ED26E4 => {
    //   block [0x82ED26E4..0x82ED2800)
	// 82ED26E4: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED26E8: C01F0184  lfs f0, 0x184(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED26EC: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED26F0: C1BF0188  lfs f13, 0x188(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED26F4: 7D4707B4  extsw r7, r10
	ctx.r[7].s64 = ctx.r[10].s32 as i64;
	// 82ED26F8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED26FC: 7D2607B4  extsw r6, r9
	ctx.r[6].s64 = ctx.r[9].s32 as i64;
	// 82ED2700: C19F018C  lfs f12, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED2704: 7D6807B4  extsw r8, r11
	ctx.r[8].s64 = ctx.r[11].s32 as i64;
	// 82ED2708: C1180000  lfs f8, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED270C: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 82ED2710: F8C10060  std r6, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u64 ) };
	// 82ED2714: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82ED2718: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82ED271C: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82ED2720: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82ED2724: ED6B07FA  fmadds f11, f11, f31, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED2728: FF085800  fcmpu cr6, f8, f11
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[11].f64);
	// 82ED272C: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82ED2730: C9210060  lfd f9, 0x60(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82ED2734: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 82ED2738: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 82ED273C: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82ED2740: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82ED2744: ED4A6FFA  fmadds f10, f10, f31, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 82ED2748: ED2967FA  fmadds f9, f9, f31, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64);
	// 82ED274C: 419800C0  blt cr6, 0x82ed280c
	if ctx.cr[6].lt {
	pc = 0x82ED280C; continue 'dispatch;
	}
	// 82ED2750: C1780004  lfs f11, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED2754: FF0B5000  fcmpu cr6, f11, f10
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[10].f64);
	// 82ED2758: 419800B4  blt cr6, 0x82ed280c
	if ctx.cr[6].lt {
	pc = 0x82ED280C; continue 'dispatch;
	}
	// 82ED275C: C1780008  lfs f11, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED2760: FF0B4800  fcmpu cr6, f11, f9
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[9].f64);
	// 82ED2764: 419800A8  blt cr6, 0x82ed280c
	if ctx.cr[6].lt {
	pc = 0x82ED280C; continue 'dispatch;
	}
	// 82ED2768: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED276C: C1770000  lfs f11, 0(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED2770: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED2774: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ED2778: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED277C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED2780: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ED2784: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 82ED2788: F9410070  std r10, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u64 ) };
	// 82ED278C: F9210078  std r9, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u64 ) };
	// 82ED2790: C9410068  lfd f10, 0x68(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82ED2794: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 82ED2798: C9210070  lfd f9, 0x70(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82ED279C: C9010078  lfd f8, 0x78(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82ED27A0: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 82ED27A4: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 82ED27A8: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82ED27AC: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82ED27B0: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82ED27B4: EC0A07FA  fmadds f0, f10, f31, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED27B8: EDA96FFA  fmadds f13, f9, f31, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 82ED27BC: ED8867FA  fmadds f12, f8, f31, f12
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64);
	// 82ED27C0: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82ED27C4: 41990048  bgt cr6, 0x82ed280c
	if ctx.cr[6].gt {
	pc = 0x82ED280C; continue 'dispatch;
	}
	// 82ED27C8: C0170004  lfs f0, 4(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED27CC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED27D0: 4199003C  bgt cr6, 0x82ed280c
	if ctx.cr[6].gt {
	pc = 0x82ED280C; continue 'dispatch;
	}
	// 82ED27D4: C0170008  lfs f0, 8(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED27D8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82ED27DC: 41990030  bgt cr6, 0x82ed280c
	if ctx.cr[6].gt {
	pc = 0x82ED280C; continue 'dispatch;
	}
	// 82ED27E0: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED27E4: 7F0BA840  cmplw cr6, r11, r21
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82ED27E8: 40980038  bge cr6, 0x82ed2820
	if !ctx.cr[6].lt {
	pc = 0x82ED2820; continue 'dispatch;
	}
	// 82ED27EC: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82ED27F0: 419A0010  beq cr6, 0x82ed2800
	if ctx.cr[6].eq {
	pc = 0x82ED2800; continue 'dispatch;
	}
	// 82ED27F4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED27F8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED27FC: 7D4BB12E  stwx r10, r11, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32), ctx.r[10].u32) };
	pc = 0x82ED2800; continue 'dispatch;
            }
            0x82ED2800 => {
    //   block [0x82ED2800..0x82ED280C)
	// 82ED2800: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED2804: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED2808: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED280C; continue 'dispatch;
            }
            0x82ED280C => {
    //   block [0x82ED280C..0x82ED2820)
	// 82ED280C: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED2810: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ED2814: 3BBD0030  addi r29, r29, 0x30
	ctx.r[29].s64 = ctx.r[29].s64 + 48;
	// 82ED2818: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED281C: 4198FE58  blt cr6, 0x82ed2674
	if ctx.cr[6].lt {
	pc = 0x82ED2674; continue 'dispatch;
	}
	pc = 0x82ED2820; continue 'dispatch;
            }
            0x82ED2820 => {
    //   block [0x82ED2820..0x82ED2824)
	// 82ED2820: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82ED2824; continue 'dispatch;
            }
            0x82ED2824 => {
    //   block [0x82ED2824..0x82ED2830)
	// 82ED2824: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82ED2828: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82ED282C: 4BDD6C0C  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED2830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED2830 size=772
    let mut pc: u32 = 0x82ED2830;
    'dispatch: loop {
        match pc {
            0x82ED2830 => {
    //   block [0x82ED2830..0x82ED2880)
	// 82ED2830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED2834: 4BDD6BC5  bl 0x82ca93f8
	ctx.lr = 0x82ED2838;
	sub_82CA93D0(ctx, base);
	// 82ED2838: DBA1FFA0  stfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[29].u64 ) };
	// 82ED283C: DBC1FFA8  stfd f30, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 82ED2840: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82ED2844: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED2848: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED284C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ED2850: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82ED2854: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82ED2858: 817F0294  lwz r11, 0x294(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 82ED285C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ED2860: 409A0128  bne cr6, 0x82ed2988
	if !ctx.cr[6].eq {
	pc = 0x82ED2988; continue 'dispatch;
	}
	// 82ED2864: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82ED2868: 419A0018  beq cr6, 0x82ed2880
	if ctx.cr[6].eq {
	pc = 0x82ED2880; continue 'dispatch;
	}
	// 82ED286C: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED2870: 616B84DC  ori r11, r11, 0x84dc
	ctx.r[11].u64 = ctx.r[11].u64 | 34012;
	// 82ED2874: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED2878: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED287C: 419A010C  beq cr6, 0x82ed2988
	if ctx.cr[6].eq {
	pc = 0x82ED2988; continue 'dispatch;
	}
	pc = 0x82ED2880; continue 'dispatch;
            }
            0x82ED2880 => {
    //   block [0x82ED2880..0x82ED28A0)
	// 82ED2880: 817F0180  lwz r11, 0x180(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82ED2884: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED2888: 409A0128  bne cr6, 0x82ed29b0
	if !ctx.cr[6].eq {
	pc = 0x82ED29B0; continue 'dispatch;
	}
	// 82ED288C: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED2890: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82ED2894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED2898: 409900F0  ble cr6, 0x82ed2988
	if !ctx.cr[6].gt {
	pc = 0x82ED2988; continue 'dispatch;
	}
	// 82ED289C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	pc = 0x82ED28A0; continue 'dispatch;
            }
            0x82ED28A0 => {
    //   block [0x82ED28A0..0x82ED2900)
	// 82ED28A0: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ED28A4: 7FDA5A14  add r30, r26, r11
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 82ED28A8: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED28AC: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82ED28B0: 409A00C4  bne cr6, 0x82ed2974
	if !ctx.cr[6].eq {
	pc = 0x82ED2974; continue 'dispatch;
	}
	// 82ED28B4: 817F020C  lwz r11, 0x20c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 82ED28B8: 7D6BD8AE  lbzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82ED28BC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED28C0: 419A00B4  beq cr6, 0x82ed2974
	if ctx.cr[6].eq {
	pc = 0x82ED2974; continue 'dispatch;
	}
	// 82ED28C4: 3F9F0001  addis r28, r31, 1
	ctx.r[28].s64 = ctx.r[31].s64 + 65536;
	// 82ED28C8: 3B9C84D8  addi r28, r28, -0x7b28
	ctx.r[28].s64 = ctx.r[28].s64 + -31528;
	// 82ED28CC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED28D0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED28D4: 409A002C  bne cr6, 0x82ed2900
	if !ctx.cr[6].eq {
	pc = 0x82ED2900; continue 'dispatch;
	}
	// 82ED28D8: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED28DC: 40820024  bne 0x82ed2900
	if !ctx.cr[0].eq {
	pc = 0x82ED2900; continue 'dispatch;
	}
	// 82ED28E0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED28E4: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED28E8: 48003E49  bl 0x82ed6730
	ctx.lr = 0x82ED28EC;
	sub_82ED6730(ctx, base);
	// 82ED28EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED28F0: 41820084  beq 0x82ed2974
	if ctx.cr[0].eq {
	pc = 0x82ED2974; continue 'dispatch;
	}
	// 82ED28F4: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED28F8: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED28FC: 409A0078  bne cr6, 0x82ed2974
	if !ctx.cr[6].eq {
	pc = 0x82ED2974; continue 'dispatch;
	}
	pc = 0x82ED2900; continue 'dispatch;
            }
            0x82ED2900 => {
    //   block [0x82ED2900..0x82ED2920)
	// 82ED2900: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED2904: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED2908: 409A0018  bne cr6, 0x82ed2920
	if !ctx.cr[6].eq {
	pc = 0x82ED2920; continue 'dispatch;
	}
	// 82ED290C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82ED2910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED2914: 4BFFF6BD  bl 0x82ed1fd0
	ctx.lr = 0x82ED2918;
	sub_82ED1FD0(ctx, base);
	// 82ED2918: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED291C: 40820058  bne 0x82ed2974
	if !ctx.cr[0].eq {
	pc = 0x82ED2974; continue 'dispatch;
	}
	pc = 0x82ED2920; continue 'dispatch;
            }
            0x82ED2920 => {
    //   block [0x82ED2920..0x82ED2974)
	// 82ED2920: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED2924: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED2928: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED292C: 41980048  blt cr6, 0x82ed2974
	if ctx.cr[6].lt {
	pc = 0x82ED2974; continue 'dispatch;
	}
	// 82ED2930: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED2934: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED2938: 4199003C  bgt cr6, 0x82ed2974
	if ctx.cr[6].gt {
	pc = 0x82ED2974; continue 'dispatch;
	}
	// 82ED293C: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED2940: C1BE000C  lfs f13, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED2944: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED2948: 4198002C  blt cr6, 0x82ed2974
	if ctx.cr[6].lt {
	pc = 0x82ED2974; continue 'dispatch;
	}
	// 82ED294C: C1BE0010  lfs f13, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED2950: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED2954: 41990020  bgt cr6, 0x82ed2974
	if ctx.cr[6].gt {
	pc = 0x82ED2974; continue 'dispatch;
	}
	// 82ED2958: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED295C: C1BE0014  lfs f13, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED2960: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED2964: 41980010  blt cr6, 0x82ed2974
	if ctx.cr[6].lt {
	pc = 0x82ED2974; continue 'dispatch;
	}
	// 82ED2968: C1BE0018  lfs f13, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED296C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED2970: 40990030  ble cr6, 0x82ed29a0
	if !ctx.cr[6].gt {
	pc = 0x82ED29A0; continue 'dispatch;
	}
	pc = 0x82ED2974; continue 'dispatch;
            }
            0x82ED2974 => {
    //   block [0x82ED2974..0x82ED2988)
	// 82ED2974: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED2978: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82ED297C: 3B5A0030  addi r26, r26, 0x30
	ctx.r[26].s64 = ctx.r[26].s64 + 48;
	// 82ED2980: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED2984: 4198FF1C  blt cr6, 0x82ed28a0
	if ctx.cr[6].lt {
	pc = 0x82ED28A0; continue 'dispatch;
	}
	pc = 0x82ED2988; continue 'dispatch;
            }
            0x82ED2988 => {
    //   block [0x82ED2988..0x82ED298C)
	// 82ED2988: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ED298C; continue 'dispatch;
            }
            0x82ED298C => {
    //   block [0x82ED298C..0x82ED29A0)
	// 82ED298C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82ED2990: CBA1FFA0  lfd f29, -0x60(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82ED2994: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82ED2998: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82ED299C: 4BDD6AAC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ED29A0 => {
    //   block [0x82ED29A0..0x82ED29A4)
	// 82ED29A0: 1D5B0030  mulli r10, r27, 0x30
	ctx.r[10].s32 = ((ctx.r[27].s32 as i64 * 48 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	pc = 0x82ED29A4; continue 'dispatch;
            }
            0x82ED29A4 => {
    //   block [0x82ED29A4..0x82ED29B0)
	// 82ED29A4: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ED29A8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED29AC: 4BFFFFE0  b 0x82ed298c
	pc = 0x82ED298C; continue 'dispatch;
            }
            0x82ED29B0 => {
    //   block [0x82ED29B0..0x82ED2A80)
	// 82ED29B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED29B4: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED29B8: C1BF0184  lfs f13, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED29BC: 7B2A0020  clrldi r10, r25, 0x20
	ctx.r[10].u64 = ctx.r[25].u64 & 0x00000000FFFFFFFFu64;
	// 82ED29C0: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED29C4: C01F0188  lfs f0, 0x188(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED29C8: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED29CC: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED29D0: C01F018C  lfs f0, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED29D4: C82B0DE8  lfd f1, 0xde8(r11)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3560 as u32) ) };
	// 82ED29D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED29DC: C17D0008  lfs f11, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED29E0: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82ED29E4: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED29E8: C15F0190  lfs f10, 0x190(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED29EC: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED29F0: EC005024  fdivs f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 82ED29F4: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82ED29F8: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 82ED29FC: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED2A00: EFC00332  fmuls f30, f0, f12
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82ED2A04: EFA002F2  fmuls f29, f0, f11
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82ED2A08: FC405018  frsp f2, f10
	ctx.f[2].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82ED2A0C: 4B32BA9D  bl 0x821fe4a8
	ctx.lr = 0x82ED2A10;
	sub_821FE4A8(ctx, base);
	// 82ED2A10: FD600818  frsp f11, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED2A14: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82ED2A18: FC00FE5E  fctidz f0, f31
	ctx.f[0].s64 = if ctx.f[31].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[31].f64.trunc() as i64 };
	// 82ED2A1C: 815F017C  lwz r10, 0x17c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED2A20: FDA0F65E  fctidz f13, f30
	ctx.f[13].s64 = if ctx.f[30].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[30].f64.trunc() as i64 };
	// 82ED2A24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED2A28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ED2A2C: FD80EE5E  fctidz f12, f29
	ctx.f[12].s64 = if ctx.f[29].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[29].f64.trunc() as i64 };
	// 82ED2A30: FD605E5E  fctidz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[11].f64.trunc() as i64 };
	// 82ED2A34: 7D605FAE  stfiwx f11, 0, r11
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82ED2A38: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82ED2A3C: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82ED2A40: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ED2A44: 0CCB0000  twi 6, r11, 0
	// 82ED2A48: 0CCB0000  twi 6, r11, 0
	// 82ED2A4C: 0CCB0000  twi 6, r11, 0
	// 82ED2A50: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED2A54: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82ED2A58: 7F8A5B96  divwu r28, r10, r11
	ctx.r[28].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 82ED2A5C: 7DA04FAE  stfiwx f13, 0, r9
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 82ED2A60: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED2A64: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82ED2A68: 7F6A5B96  divwu r27, r10, r11
	ctx.r[27].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 82ED2A6C: 7D804FAE  stfiwx f12, 0, r9
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 82ED2A70: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED2A74: 7F4A5B96  divwu r26, r10, r11
	ctx.r[26].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 82ED2A78: 4099FF10  ble cr6, 0x82ed2988
	if !ctx.cr[6].gt {
	pc = 0x82ED2988; continue 'dispatch;
	}
	// 82ED2A7C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82ED2A80; continue 'dispatch;
            }
            0x82ED2A80 => {
    //   block [0x82ED2A80..0x82ED2AF8)
	// 82ED2A80: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ED2A84: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82ED2A88: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED2A8C: 7F0AC840  cmplw cr6, r10, r25
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82ED2A90: 409A0084  bne cr6, 0x82ed2b14
	if !ctx.cr[6].eq {
	pc = 0x82ED2B14; continue 'dispatch;
	}
	// 82ED2A94: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED2A98: 7F0AE000  cmpw cr6, r10, r28
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82ED2A9C: 409A0078  bne cr6, 0x82ed2b14
	if !ctx.cr[6].eq {
	pc = 0x82ED2B14; continue 'dispatch;
	}
	// 82ED2AA0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED2AA4: 7F0AD800  cmpw cr6, r10, r27
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82ED2AA8: 409A006C  bne cr6, 0x82ed2b14
	if !ctx.cr[6].eq {
	pc = 0x82ED2B14; continue 'dispatch;
	}
	// 82ED2AAC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED2AB0: 7F0AD000  cmpw cr6, r10, r26
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82ED2AB4: 409A0060  bne cr6, 0x82ed2b14
	if !ctx.cr[6].eq {
	pc = 0x82ED2B14; continue 'dispatch;
	}
	// 82ED2AB8: 815F020C  lwz r10, 0x20c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 82ED2ABC: 7D4AF0AE  lbzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82ED2AC0: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82ED2AC4: 419A0050  beq cr6, 0x82ed2b14
	if ctx.cr[6].eq {
	pc = 0x82ED2B14; continue 'dispatch;
	}
	// 82ED2AC8: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ED2ACC: 614A84D8  ori r10, r10, 0x84d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34008;
	// 82ED2AD0: 7D5F502E  lwzx r10, r31, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ED2AD4: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82ED2AD8: 409A0054  bne cr6, 0x82ed2b2c
	if !ctx.cr[6].eq {
	pc = 0x82ED2B2C; continue 'dispatch;
	}
	// 82ED2ADC: 570A063F  clrlwi. r10, r24, 0x18
	ctx.r[10].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED2AE0: 4082004C  bne 0x82ed2b2c
	if !ctx.cr[0].eq {
	pc = 0x82ED2B2C; continue 'dispatch;
	}
	// 82ED2AE4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED2AE8: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82ED2AEC: 409A000C  bne cr6, 0x82ed2af8
	if !ctx.cr[6].eq {
	pc = 0x82ED2AF8; continue 'dispatch;
	}
	// 82ED2AF0: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED2AF4: 48000008  b 0x82ed2afc
	pc = 0x82ED2AFC; continue 'dispatch;
            }
            0x82ED2AF8 => {
    //   block [0x82ED2AF8..0x82ED2AFC)
	// 82ED2AF8: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	pc = 0x82ED2AFC; continue 'dispatch;
            }
            0x82ED2AFC => {
    //   block [0x82ED2AFC..0x82ED2B14)
	// 82ED2AFC: 48003C35  bl 0x82ed6730
	ctx.lr = 0x82ED2B00;
	sub_82ED6730(ctx, base);
	// 82ED2B00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED2B04: 419A0010  beq cr6, 0x82ed2b14
	if ctx.cr[6].eq {
	pc = 0x82ED2B14; continue 'dispatch;
	}
	// 82ED2B08: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED2B0C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED2B10: 419A001C  beq cr6, 0x82ed2b2c
	if ctx.cr[6].eq {
	pc = 0x82ED2B2C; continue 'dispatch;
	}
	pc = 0x82ED2B14; continue 'dispatch;
            }
            0x82ED2B14 => {
    //   block [0x82ED2B14..0x82ED2B2C)
	// 82ED2B14: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED2B18: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82ED2B1C: 3BBD0030  addi r29, r29, 0x30
	ctx.r[29].s64 = ctx.r[29].s64 + 48;
	// 82ED2B20: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED2B24: 4198FF5C  blt cr6, 0x82ed2a80
	if ctx.cr[6].lt {
	pc = 0x82ED2A80; continue 'dispatch;
	}
	// 82ED2B28: 4BFFFE60  b 0x82ed2988
	pc = 0x82ED2988; continue 'dispatch;
            }
            0x82ED2B2C => {
    //   block [0x82ED2B2C..0x82ED2B34)
	// 82ED2B2C: 1D5E0030  mulli r10, r30, 0x30
	ctx.r[10].s32 = ((ctx.r[30].s32 as i64 * 48 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED2B30: 4BFFFE74  b 0x82ed29a4
	pc = 0x82ED29A4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED2B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED2B38 size=264
    let mut pc: u32 = 0x82ED2B38;
    'dispatch: loop {
        match pc {
            0x82ED2B38 => {
    //   block [0x82ED2B38..0x82ED2B5C)
	// 82ED2B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED2B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED2B40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED2B44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED2B48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED2B4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED2B50: 817F0294  lwz r11, 0x294(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 82ED2B54: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ED2B58: 419A000C  beq cr6, 0x82ed2b64
	if ctx.cr[6].eq {
	pc = 0x82ED2B64; continue 'dispatch;
	}
	pc = 0x82ED2B5C; continue 'dispatch;
            }
            0x82ED2B5C => {
    //   block [0x82ED2B5C..0x82ED2B64)
	// 82ED2B5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED2B60: 480000C8  b 0x82ed2c28
	pc = 0x82ED2C28; continue 'dispatch;
            }
            0x82ED2B64 => {
    //   block [0x82ED2B64..0x82ED2B7C)
	// 82ED2B64: 811F017C  lwz r8, 0x17c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED2B68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED2B6C: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED2B70: 4182FFEC  beq 0x82ed2b5c
	if ctx.cr[0].eq {
	pc = 0x82ED2B5C; continue 'dispatch;
	}
	// 82ED2B74: 813F01FC  lwz r9, 0x1fc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ED2B78: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x82ED2B7C; continue 'dispatch;
            }
            0x82ED2B7C => {
    //   block [0x82ED2B7C..0x82ED2B9C)
	// 82ED2B7C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED2B80: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82ED2B84: 419A0018  beq cr6, 0x82ed2b9c
	if ctx.cr[6].eq {
	pc = 0x82ED2B9C; continue 'dispatch;
	}
	// 82ED2B88: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED2B8C: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 82ED2B90: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82ED2B94: 4198FFE8  blt cr6, 0x82ed2b7c
	if ctx.cr[6].lt {
	pc = 0x82ED2B7C; continue 'dispatch;
	}
	// 82ED2B98: 4BFFFFC4  b 0x82ed2b5c
	pc = 0x82ED2B5C; continue 'dispatch;
            }
            0x82ED2B9C => {
    //   block [0x82ED2B9C..0x82ED2BD0)
	// 82ED2B9C: 811F020C  lwz r8, 0x20c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 82ED2BA0: 1D4B0030  mulli r10, r11, 0x30
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 48 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED2BA4: 7FCA4A14  add r30, r10, r9
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82ED2BA8: 7D6858AE  lbzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED2BAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED2BB0: 419AFFAC  beq cr6, 0x82ed2b5c
	if ctx.cr[6].eq {
	pc = 0x82ED2B5C; continue 'dispatch;
	}
	// 82ED2BB4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ED2BB8: 419AFFA4  beq cr6, 0x82ed2b5c
	if ctx.cr[6].eq {
	pc = 0x82ED2B5C; continue 'dispatch;
	}
	// 82ED2BBC: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED2BC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED2BC4: 409A000C  bne cr6, 0x82ed2bd0
	if !ctx.cr[6].eq {
	pc = 0x82ED2BD0; continue 'dispatch;
	}
	// 82ED2BC8: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED2BCC: 48000008  b 0x82ed2bd4
	pc = 0x82ED2BD4; continue 'dispatch;
            }
            0x82ED2BD0 => {
    //   block [0x82ED2BD0..0x82ED2BD4)
	// 82ED2BD0: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	pc = 0x82ED2BD4; continue 'dispatch;
            }
            0x82ED2BD4 => {
    //   block [0x82ED2BD4..0x82ED2C00)
	// 82ED2BD4: 48003B5D  bl 0x82ed6730
	ctx.lr = 0x82ED2BD8;
	sub_82ED6730(ctx, base);
	// 82ED2BD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED2BDC: 409A0048  bne cr6, 0x82ed2c24
	if !ctx.cr[6].eq {
	pc = 0x82ED2C24; continue 'dispatch;
	}
	// 82ED2BE0: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED2BE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ED2BE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ED2BEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED2BF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED2BF4: 409A000C  bne cr6, 0x82ed2c00
	if !ctx.cr[6].eq {
	pc = 0x82ED2C00; continue 'dispatch;
	}
	// 82ED2BF8: 809F0034  lwz r4, 0x34(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED2BFC: 48000008  b 0x82ed2c04
	pc = 0x82ED2C04; continue 'dispatch;
            }
            0x82ED2C00 => {
    //   block [0x82ED2C00..0x82ED2C04)
	// 82ED2C00: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	pc = 0x82ED2C04; continue 'dispatch;
            }
            0x82ED2C04 => {
    //   block [0x82ED2C04..0x82ED2C24)
	// 82ED2C04: 4BFFCA4D  bl 0x82ecf650
	ctx.lr = 0x82ED2C08;
	sub_82ECF650(ctx, base);
	// 82ED2C08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ED2C0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED2C10: 419A0014  beq cr6, 0x82ed2c24
	if ctx.cr[6].eq {
	pc = 0x82ED2C24; continue 'dispatch;
	}
	// 82ED2C14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ED2C18: 93CB001C  stw r30, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82ED2C1C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82ED2C20: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82ED2C24; continue 'dispatch;
            }
            0x82ED2C24 => {
    //   block [0x82ED2C24..0x82ED2C28)
	// 82ED2C24: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82ED2C28; continue 'dispatch;
            }
            0x82ED2C28 => {
    //   block [0x82ED2C28..0x82ED2C40)
	// 82ED2C28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED2C2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED2C30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED2C34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED2C38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED2C3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED2C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED2C40 size=264
    let mut pc: u32 = 0x82ED2C40;
    'dispatch: loop {
        match pc {
            0x82ED2C40 => {
    //   block [0x82ED2C40..0x82ED2C5C)
	// 82ED2C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED2C44: 4BDD67BD  bl 0x82ca9400
	ctx.lr = 0x82ED2C48;
	sub_82CA93D0(ctx, base);
	// 82ED2C48: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED2C4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED2C50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ED2C54: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ED2C58: 409A000C  bne cr6, 0x82ed2c64
	if !ctx.cr[6].eq {
	pc = 0x82ED2C64; continue 'dispatch;
	}
	pc = 0x82ED2C5C; continue 'dispatch;
            }
            0x82ED2C5C => {
    //   block [0x82ED2C5C..0x82ED2C64)
	// 82ED2C5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED2C60: 480000B8  b 0x82ed2d18
	pc = 0x82ED2D18; continue 'dispatch;
            }
            0x82ED2C64 => {
    //   block [0x82ED2C64..0x82ED2C94)
	// 82ED2C64: 817D0294  lwz r11, 0x294(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(660 as u32) ) } as u64;
	// 82ED2C68: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ED2C6C: 409AFFF0  bne cr6, 0x82ed2c5c
	if !ctx.cr[6].eq {
	pc = 0x82ED2C5C; continue 'dispatch;
	}
	// 82ED2C70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ED2C74: 4BFFC21D  bl 0x82ecee90
	ctx.lr = 0x82ED2C78;
	sub_82ECEE90(ctx, base);
	// 82ED2C78: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82ED2C7C: 4182FFE0  beq 0x82ed2c5c
	if ctx.cr[0].eq {
	pc = 0x82ED2C5C; continue 'dispatch;
	}
	// 82ED2C80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ED2C84: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82ED2C88: 4BFFB149  bl 0x82ecddd0
	ctx.lr = 0x82ED2C8C;
	sub_82ECDDD0(ctx, base);
	// 82ED2C8C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82ED2C90: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	pc = 0x82ED2C94; continue 'dispatch;
            }
            0x82ED2C94 => {
    //   block [0x82ED2C94..0x82ED2CB8)
	// 82ED2C94: 9B5F0010  stb r26, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u8 ) };
	// 82ED2C98: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED2C9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED2CA0: 419A0018  beq cr6, 0x82ed2cb8
	if ctx.cr[6].eq {
	pc = 0x82ED2CB8; continue 'dispatch;
	}
	// 82ED2CA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ED2CA8: 4BFFC1E9  bl 0x82ecee90
	ctx.lr = 0x82ED2CAC;
	sub_82ECEE90(ctx, base);
	// 82ED2CAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED2CB0: 907F0040  stw r3, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[3].u32 ) };
	// 82ED2CB4: 4182006C  beq 0x82ed2d20
	if ctx.cr[0].eq {
	pc = 0x82ED2D20; continue 'dispatch;
	}
	pc = 0x82ED2CB8; continue 'dispatch;
            }
            0x82ED2CB8 => {
    //   block [0x82ED2CB8..0x82ED2D18)
	// 82ED2CB8: 897E0038  lbz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82ED2CBC: 997F0038  stb r11, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 82ED2CC0: 897E0030  lbz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED2CC4: 997F0030  stb r11, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 82ED2CC8: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED2CCC: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82ED2CD0: C01E002C  lfs f0, 0x2c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED2CD4: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82ED2CD8: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED2CDC: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82ED2CE0: 897E0024  lbz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED2CE4: 997F0024  stb r11, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 82ED2CE8: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED2CEC: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82ED2CF0: 897E0039  lbz r11, 0x39(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(57 as u32) ) } as u64;
	// 82ED2CF4: 997F0039  stb r11, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[11].u8 ) };
	// 82ED2CF8: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED2CFC: 937F0044  stw r27, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[27].u32 ) };
	// 82ED2D00: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82ED2D04: 83DE0040  lwz r30, 0x40(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED2D08: 83FF0040  lwz r31, 0x40(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED2D0C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED2D10: 4082FF84  bne 0x82ed2c94
	if !ctx.cr[0].eq {
	pc = 0x82ED2C94; continue 'dispatch;
	}
	// 82ED2D14: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x82ED2D18; continue 'dispatch;
            }
            0x82ED2D18 => {
    //   block [0x82ED2D18..0x82ED2D20)
	// 82ED2D18: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ED2D1C: 4BDD6734  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ED2D20 => {
    //   block [0x82ED2D20..0x82ED2D24)
	// 82ED2D20: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82ED2D24; continue 'dispatch;
            }
            0x82ED2D24 => {
    //   block [0x82ED2D24..0x82ED2D48)
	// 82ED2D24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ED2D28: 9B4B0030  stb r26, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[26].u8 ) };
	// 82ED2D2C: 9B4B0038  stb r26, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[26].u8 ) };
	// 82ED2D30: 934B0034  stw r26, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[26].u32 ) };
	// 82ED2D34: 994B0010  stb r10, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 82ED2D38: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED2D3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED2D40: 4082FFE4  bne 0x82ed2d24
	if !ctx.cr[0].eq {
	pc = 0x82ED2D24; continue 'dispatch;
	}
	// 82ED2D44: 4BFFFF18  b 0x82ed2c5c
	pc = 0x82ED2C5C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED2D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED2D48 size=484
    let mut pc: u32 = 0x82ED2D48;
    'dispatch: loop {
        match pc {
            0x82ED2D48 => {
    //   block [0x82ED2D48..0x82ED2D78)
	// 82ED2D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED2D4C: 4BDD66B1  bl 0x82ca93fc
	ctx.lr = 0x82ED2D50;
	sub_82CA93D0(ctx, base);
	// 82ED2D50: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82ED2D54: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED2D58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ED2D5C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82ED2D60: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82ED2D64: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82ED2D68: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 82ED2D6C: 817E0294  lwz r11, 0x294(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(660 as u32) ) } as u64;
	// 82ED2D70: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ED2D74: 419A000C  beq cr6, 0x82ed2d80
	if ctx.cr[6].eq {
	pc = 0x82ED2D80; continue 'dispatch;
	}
	pc = 0x82ED2D78; continue 'dispatch;
            }
            0x82ED2D78 => {
    //   block [0x82ED2D78..0x82ED2D80)
	// 82ED2D78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED2D7C: 480001A4  b 0x82ed2f20
	pc = 0x82ED2F20; continue 'dispatch;
            }
            0x82ED2D80 => {
    //   block [0x82ED2D80..0x82ED2D9C)
	// 82ED2D80: 815E017C  lwz r10, 0x17c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED2D84: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ED2D88: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82ED2D8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ED2D90: 4099FFE8  ble cr6, 0x82ed2d78
	if !ctx.cr[6].gt {
	pc = 0x82ED2D78; continue 'dispatch;
	}
	// 82ED2D94: 813E01FC  lwz r9, 0x1fc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ED2D98: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x82ED2D9C; continue 'dispatch;
            }
            0x82ED2D9C => {
    //   block [0x82ED2D9C..0x82ED2DC0)
	// 82ED2D9C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED2DA0: 7F08D840  cmplw cr6, r8, r27
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82ED2DA4: 419A001C  beq cr6, 0x82ed2dc0
	if ctx.cr[6].eq {
	pc = 0x82ED2DC0; continue 'dispatch;
	}
	// 82ED2DA8: 811E017C  lwz r8, 0x17c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED2DAC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED2DB0: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 82ED2DB4: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82ED2DB8: 4198FFE4  blt cr6, 0x82ed2d9c
	if ctx.cr[6].lt {
	pc = 0x82ED2D9C; continue 'dispatch;
	}
	// 82ED2DBC: 4BFFFFBC  b 0x82ed2d78
	pc = 0x82ED2D78; continue 'dispatch;
            }
            0x82ED2DC0 => {
    //   block [0x82ED2DC0..0x82ED2E10)
	// 82ED2DC0: 811E020C  lwz r8, 0x20c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(524 as u32) ) } as u64;
	// 82ED2DC4: 1D4B0030  mulli r10, r11, 0x30
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 48 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED2DC8: 7F8A4A14  add r28, r10, r9
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82ED2DCC: 7D6858AE  lbzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED2DD0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED2DD4: 419AFFA4  beq cr6, 0x82ed2d78
	if ctx.cr[6].eq {
	pc = 0x82ED2D78; continue 'dispatch;
	}
	// 82ED2DD8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82ED2DDC: 419AFF9C  beq cr6, 0x82ed2d78
	if ctx.cr[6].eq {
	pc = 0x82ED2D78; continue 'dispatch;
	}
	// 82ED2DE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED2DE4: 4BFFC0AD  bl 0x82ecee90
	ctx.lr = 0x82ED2DE8;
	sub_82ECEE90(ctx, base);
	// 82ED2DE8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ED2DEC: 4182FF8C  beq 0x82ed2d78
	if ctx.cr[0].eq {
	pc = 0x82ED2D78; continue 'dispatch;
	}
	// 82ED2DF0: 9BBF0010  stb r29, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82ED2DF4: 897E0298  lbz r11, 0x298(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(664 as u32) ) } as u64;
	// 82ED2DF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED2DFC: 4182008C  beq 0x82ed2e88
	if ctx.cr[0].eq {
	pc = 0x82ED2E88; continue 'dispatch;
	}
	// 82ED2E00: 815E029C  lwz r10, 0x29c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(668 as u32) ) } as u64;
	// 82ED2E04: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED2E08: 41820080  beq 0x82ed2e88
	if ctx.cr[0].eq {
	pc = 0x82ED2E88; continue 'dispatch;
	}
	// 82ED2E0C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82ED2E10; continue 'dispatch;
            }
            0x82ED2E10 => {
    //   block [0x82ED2E10..0x82ED2E60)
	// 82ED2E10: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED2E14: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED2E18: 7F09D840  cmplw cr6, r9, r27
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82ED2E1C: 419A0044  beq cr6, 0x82ed2e60
	if ctx.cr[6].eq {
	pc = 0x82ED2E60; continue 'dispatch;
	}
	// 82ED2E20: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED2E24: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED2E28: 4082FFE8  bne 0x82ed2e10
	if !ctx.cr[0].eq {
	pc = 0x82ED2E10; continue 'dispatch;
	}
	// 82ED2E2C: 896A0024  lbz r11, 0x24(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED2E30: 997F0024  stb r11, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 82ED2E34: 817E029C  lwz r11, 0x29c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(668 as u32) ) } as u64;
	// 82ED2E38: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED2E3C: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82ED2E40: 817E029C  lwz r11, 0x29c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(668 as u32) ) } as u64;
	// 82ED2E44: C00B0028  lfs f0, 0x28(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED2E48: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82ED2E4C: 817E029C  lwz r11, 0x29c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(668 as u32) ) } as u64;
	// 82ED2E50: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ED2E54: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82ED2E58: 817E029C  lwz r11, 0x29c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(668 as u32) ) } as u64;
	// 82ED2E5C: 48000014  b 0x82ed2e70
	pc = 0x82ED2E70; continue 'dispatch;
            }
            0x82ED2E60 => {
    //   block [0x82ED2E60..0x82ED2E6C)
	// 82ED2E60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ED2E64: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 82ED2E68: 480000B4  b 0x82ed2f1c
	pc = 0x82ED2F1C; continue 'dispatch;
            }
            0x82ED2E6C => {
    //   block [0x82ED2E6C..0x82ED2E70)
	// 82ED2E6C: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	pc = 0x82ED2E70; continue 'dispatch;
            }
            0x82ED2E70 => {
    //   block [0x82ED2E70..0x82ED2E88)
	// 82ED2E70: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED2E74: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED2E78: 409AFFF4  bne cr6, 0x82ed2e6c
	if !ctx.cr[6].eq {
	pc = 0x82ED2E6C; continue 'dispatch;
	}
	// 82ED2E7C: 93EB0040  stw r31, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	// 82ED2E80: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82ED2E84: 48000010  b 0x82ed2e94
	pc = 0x82ED2E94; continue 'dispatch;
            }
            0x82ED2E88 => {
    //   block [0x82ED2E88..0x82ED2E94)
	// 82ED2E88: D3FF0028  stfs f31, 0x28(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82ED2E8C: 9B3F0024  stb r25, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[25].u8 ) };
	// 82ED2E90: 935F0020  stw r26, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	pc = 0x82ED2E94; continue 'dispatch;
            }
            0x82ED2E94 => {
    //   block [0x82ED2E94..0x82ED2EE8)
	// 82ED2E94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED2E98: 9BBF0038  stb r29, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 82ED2E9C: 9BBF0030  stb r29, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 82ED2EA0: 93BF0034  stw r29, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[29].u32 ) };
	// 82ED2EA4: 939F0018  stw r28, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	// 82ED2EA8: 9BBF0039  stb r29, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[29].u8 ) };
	// 82ED2EAC: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED2EB0: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82ED2EB4: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82ED2EB8: 897E0298  lbz r11, 0x298(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(664 as u32) ) } as u64;
	// 82ED2EBC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED2EC0: 41820028  beq 0x82ed2ee8
	if ctx.cr[0].eq {
	pc = 0x82ED2EE8; continue 'dispatch;
	}
	// 82ED2EC4: 815E029C  lwz r10, 0x29c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(668 as u32) ) } as u64;
	// 82ED2EC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ED2ECC: 409A001C  bne cr6, 0x82ed2ee8
	if !ctx.cr[6].eq {
	pc = 0x82ED2EE8; continue 'dispatch;
	}
	// 82ED2ED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED2ED4: 93FE029C  stw r31, 0x29c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(668 as u32), ctx.r[31].u32 ) };
	// 82ED2ED8: 4BFFAEF9  bl 0x82ecddd0
	ctx.lr = 0x82ED2EDC;
	sub_82ECDDD0(ctx, base);
	// 82ED2EDC: 817E029C  lwz r11, 0x29c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(668 as u32) ) } as u64;
	// 82ED2EE0: 906B0044  stw r3, 0x44(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	// 82ED2EE4: 48000018  b 0x82ed2efc
	pc = 0x82ED2EFC; continue 'dispatch;
            }
            0x82ED2EE8 => {
    //   block [0x82ED2EE8..0x82ED2EFC)
	// 82ED2EE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED2EEC: 409A0010  bne cr6, 0x82ed2efc
	if !ctx.cr[6].eq {
	pc = 0x82ED2EFC; continue 'dispatch;
	}
	// 82ED2EF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED2EF4: 4BFFAEDD  bl 0x82ecddd0
	ctx.lr = 0x82ED2EF8;
	sub_82ECDDD0(ctx, base);
	// 82ED2EF8: 907F0044  stw r3, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	pc = 0x82ED2EFC; continue 'dispatch;
            }
            0x82ED2EFC => {
    //   block [0x82ED2EFC..0x82ED2F18)
	// 82ED2EFC: 897E0298  lbz r11, 0x298(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(664 as u32) ) } as u64;
	// 82ED2F00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED2F04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED2F08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED2F0C: 4082000C  bne 0x82ed2f18
	if !ctx.cr[0].eq {
	pc = 0x82ED2F18; continue 'dispatch;
	}
	// 82ED2F10: 4BFFCAE1  bl 0x82ecf9f0
	ctx.lr = 0x82ED2F14;
	sub_82ECF9F0(ctx, base);
	// 82ED2F14: 4800000C  b 0x82ed2f20
	pc = 0x82ED2F20; continue 'dispatch;
            }
            0x82ED2F18 => {
    //   block [0x82ED2F18..0x82ED2F1C)
	// 82ED2F18: 4BFFCAD9  bl 0x82ecf9f0
	ctx.lr = 0x82ED2F1C;
	sub_82ECF9F0(ctx, base);
	pc = 0x82ED2F1C; continue 'dispatch;
            }
            0x82ED2F1C => {
    //   block [0x82ED2F1C..0x82ED2F20)
	// 82ED2F1C: 807E029C  lwz r3, 0x29c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(668 as u32) ) } as u64;
	pc = 0x82ED2F20; continue 'dispatch;
            }
            0x82ED2F20 => {
    //   block [0x82ED2F20..0x82ED2F2C)
	// 82ED2F20: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ED2F24: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82ED2F28: 4BDD6524  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED2F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED2F30 size=600
    let mut pc: u32 = 0x82ED2F30;
    'dispatch: loop {
        match pc {
            0x82ED2F30 => {
    //   block [0x82ED2F30..0x82ED2F48)
	// 82ED2F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED2F34: 4BDD64D9  bl 0x82ca940c
	ctx.lr = 0x82ED2F38;
	sub_82CA93D0(ctx, base);
	// 82ED2F38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED2F3C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED2F40: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ED2F44: 409A000C  bne cr6, 0x82ed2f50
	if !ctx.cr[6].eq {
	pc = 0x82ED2F50; continue 'dispatch;
	}
	pc = 0x82ED2F48; continue 'dispatch;
            }
            0x82ED2F48 => {
    //   block [0x82ED2F48..0x82ED2F50)
	// 82ED2F48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED2F4C: 48000234  b 0x82ed3180
	pc = 0x82ED3180; continue 'dispatch;
            }
            0x82ED2F50 => {
    //   block [0x82ED2F50..0x82ED2F84)
	// 82ED2F50: 897E0010  lbz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED2F54: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED2F58: 4082FFF0  bne 0x82ed2f48
	if !ctx.cr[0].eq {
	pc = 0x82ED2F48; continue 'dispatch;
	}
	// 82ED2F5C: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ED2F60: 80BE0014  lwz r5, 0x14(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED2F64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED2F68: 409AFFE0  bne cr6, 0x82ed2f48
	if !ctx.cr[6].eq {
	pc = 0x82ED2F48; continue 'dispatch;
	}
	// 82ED2F6C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82ED2F70: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ED2F74: 409A0010  bne cr6, 0x82ed2f84
	if !ctx.cr[6].eq {
	pc = 0x82ED2F84; continue 'dispatch;
	}
	// 82ED2F78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ED2F7C: 997E0010  stb r11, 0x10(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 82ED2F80: 480001C8  b 0x82ed3148
	pc = 0x82ED3148; continue 'dispatch;
            }
            0x82ED2F84 => {
    //   block [0x82ED2F84..0x82ED2FAC)
	// 82ED2F84: 897E0024  lbz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED2F88: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82ED2F8C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED2F90: 4182007C  beq 0x82ed300c
	if ctx.cr[0].eq {
	pc = 0x82ED300C; continue 'dispatch;
	}
	// 82ED2F94: 81630210  lwz r11, 0x210(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ED2F98: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 82ED2F9C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82ED2FA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED2FA4: 4099005C  ble cr6, 0x82ed3000
	if !ctx.cr[6].gt {
	pc = 0x82ED3000; continue 'dispatch;
	}
	// 82ED2FA8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x82ED2FAC; continue 'dispatch;
            }
            0x82ED2FAC => {
    //   block [0x82ED2FAC..0x82ED2FEC)
	// 82ED2FAC: 550B063F  clrlwi. r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED2FB0: 40820050  bne 0x82ed3000
	if !ctx.cr[0].eq {
	pc = 0x82ED3000; continue 'dispatch;
	}
	// 82ED2FB4: 81630164  lwz r11, 0x164(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ED2FB8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED2FBC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82ED2FC0: 419A002C  beq cr6, 0x82ed2fec
	if ctx.cr[6].eq {
	pc = 0x82ED2FEC; continue 'dispatch;
	}
	// 82ED2FC4: 88EB0010  lbz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED2FC8: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED2FCC: 40820020  bne 0x82ed2fec
	if !ctx.cr[0].eq {
	pc = 0x82ED2FEC; continue 'dispatch;
	}
	// 82ED2FD0: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED2FD4: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82ED2FD8: 409A0014  bne cr6, 0x82ed2fec
	if !ctx.cr[6].eq {
	pc = 0x82ED2FEC; continue 'dispatch;
	}
	// 82ED2FDC: 896B0024  lbz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED2FE0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED2FE4: 41820008  beq 0x82ed2fec
	if ctx.cr[0].eq {
	pc = 0x82ED2FEC; continue 'dispatch;
	}
	// 82ED2FE8: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	pc = 0x82ED2FEC; continue 'dispatch;
            }
            0x82ED2FEC => {
    //   block [0x82ED2FEC..0x82ED3000)
	// 82ED2FEC: 81630210  lwz r11, 0x210(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ED2FF0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED2FF4: 394A004C  addi r10, r10, 0x4c
	ctx.r[10].s64 = ctx.r[10].s64 + 76;
	// 82ED2FF8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED2FFC: 4198FFB0  blt cr6, 0x82ed2fac
	if ctx.cr[6].lt {
	pc = 0x82ED2FAC; continue 'dispatch;
	}
	pc = 0x82ED3000; continue 'dispatch;
            }
            0x82ED3000 => {
    //   block [0x82ED3000..0x82ED300C)
	// 82ED3000: 550B063F  clrlwi. r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED3004: 40820008  bne 0x82ed300c
	if !ctx.cr[0].eq {
	pc = 0x82ED300C; continue 'dispatch;
	}
	// 82ED3008: 9BE50008  stb r31, 8(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[31].u8 ) };
	pc = 0x82ED300C; continue 'dispatch;
            }
            0x82ED300C => {
    //   block [0x82ED300C..0x82ED3028)
	// 82ED300C: 81630210  lwz r11, 0x210(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ED3010: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82ED3014: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82ED3018: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82ED301C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED3020: 40990090  ble cr6, 0x82ed30b0
	if !ctx.cr[6].gt {
	pc = 0x82ED30B0; continue 'dispatch;
	}
	// 82ED3024: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	pc = 0x82ED3028; continue 'dispatch;
            }
            0x82ED3028 => {
    //   block [0x82ED3028..0x82ED3080)
	// 82ED3028: 81630164  lwz r11, 0x164(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) } as u64;
	// 82ED302C: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82ED3030: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82ED3034: 419A0068  beq cr6, 0x82ed309c
	if ctx.cr[6].eq {
	pc = 0x82ED309C; continue 'dispatch;
	}
	// 82ED3038: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED303C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED3040: 4082005C  bne 0x82ed309c
	if !ctx.cr[0].eq {
	pc = 0x82ED309C; continue 'dispatch;
	}
	// 82ED3044: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED3048: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED304C: 41820050  beq 0x82ed309c
	if ctx.cr[0].eq {
	pc = 0x82ED309C; continue 'dispatch;
	}
	// 82ED3050: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82ED3054: 409A0048  bne cr6, 0x82ed309c
	if !ctx.cr[6].eq {
	pc = 0x82ED309C; continue 'dispatch;
	}
	// 82ED3058: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED305C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED3060: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82ED3064: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82ED3068: 41980020  blt cr6, 0x82ed3088
	if ctx.cr[6].lt {
	pc = 0x82ED3088; continue 'dispatch;
	}
	// 82ED306C: 419A0014  beq cr6, 0x82ed3080
	if ctx.cr[6].eq {
	pc = 0x82ED3080; continue 'dispatch;
	}
	// 82ED3070: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 82ED3074: 40980018  bge cr6, 0x82ed308c
	if !ctx.cr[6].lt {
	pc = 0x82ED308C; continue 'dispatch;
	}
	// 82ED3078: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82ED307C: 48000010  b 0x82ed308c
	pc = 0x82ED308C; continue 'dispatch;
            }
            0x82ED3080 => {
    //   block [0x82ED3080..0x82ED3088)
	// 82ED3080: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82ED3084: 48000008  b 0x82ed308c
	pc = 0x82ED308C; continue 'dispatch;
            }
            0x82ED3088 => {
    //   block [0x82ED3088..0x82ED308C)
	// 82ED3088: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	pc = 0x82ED308C; continue 'dispatch;
            }
            0x82ED308C => {
    //   block [0x82ED308C..0x82ED309C)
	// 82ED308C: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82ED3090: 4099000C  ble cr6, 0x82ed309c
	if !ctx.cr[6].gt {
	pc = 0x82ED309C; continue 'dispatch;
	}
	// 82ED3094: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82ED3098: 9165000C  stw r11, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED309C; continue 'dispatch;
            }
            0x82ED309C => {
    //   block [0x82ED309C..0x82ED30B0)
	// 82ED309C: 81630210  lwz r11, 0x210(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(528 as u32) ) } as u64;
	// 82ED30A0: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82ED30A4: 3908004C  addi r8, r8, 0x4c
	ctx.r[8].s64 = ctx.r[8].s64 + 76;
	// 82ED30A8: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED30AC: 4198FF7C  blt cr6, 0x82ed3028
	if ctx.cr[6].lt {
	pc = 0x82ED3028; continue 'dispatch;
	}
	pc = 0x82ED30B0; continue 'dispatch;
            }
            0x82ED30B0 => {
    //   block [0x82ED30B0..0x82ED30E8)
	// 82ED30B0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82ED30B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ED30B8: 409A0084  bne cr6, 0x82ed313c
	if !ctx.cr[6].eq {
	pc = 0x82ED313C; continue 'dispatch;
	}
	// 82ED30BC: 81450010  lwz r10, 0x10(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED30C0: 2F0A0005  cmpwi cr6, r10, 5
	ctx.cr[6].compare_i32(ctx.r[10].s32, 5, &mut ctx.xer);
	// 82ED30C4: 40980038  bge cr6, 0x82ed30fc
	if !ctx.cr[6].lt {
	pc = 0x82ED30FC; continue 'dispatch;
	}
	// 82ED30C8: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 82ED30CC: 419A0030  beq cr6, 0x82ed30fc
	if ctx.cr[6].eq {
	pc = 0x82ED30FC; continue 'dispatch;
	}
	// 82ED30D0: 8163014C  lwz r11, 0x14c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(332 as u32) ) } as u64;
	// 82ED30D4: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED30D8: 409A0010  bne cr6, 0x82ed30e8
	if !ctx.cr[6].eq {
	pc = 0x82ED30E8; continue 'dispatch;
	}
	// 82ED30DC: 93E3014C  stw r31, 0x14c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(332 as u32), ctx.r[31].u32 ) };
	// 82ED30E0: 93E3015C  stw r31, 0x15c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(348 as u32), ctx.r[31].u32 ) };
	// 82ED30E4: 93E30154  stw r31, 0x154(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(340 as u32), ctx.r[31].u32 ) };
	pc = 0x82ED30E8; continue 'dispatch;
            }
            0x82ED30E8 => {
    //   block [0x82ED30E8..0x82ED30FC)
	// 82ED30E8: 93E50010  stw r31, 0x10(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82ED30EC: 93E5000C  stw r31, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ED30F0: 93E5001C  stw r31, 0x1c(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 82ED30F4: 9BBE0010  stb r29, 0x10(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82ED30F8: 48000054  b 0x82ed314c
	pc = 0x82ED314C; continue 'dispatch;
            }
            0x82ED30FC => {
    //   block [0x82ED30FC..0x82ED3130)
	// 82ED30FC: 89430168  lbz r10, 0x168(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(360 as u32) ) } as u64;
	// 82ED3100: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED3104: 4182002C  beq 0x82ed3130
	if ctx.cr[0].eq {
	pc = 0x82ED3130; continue 'dispatch;
	}
	// 82ED3108: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED310C: 9BFE0010  stb r31, 0x10(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[31].u8 ) };
	// 82ED3110: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82ED3114: 93FE0020  stw r31, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 82ED3118: 9BBE0039  stb r29, 0x39(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(57 as u32), ctx.r[29].u8 ) };
	// 82ED311C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3120: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82ED3124: D01E0028  stfs f0, 0x28(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82ED3128: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82ED312C: 48000010  b 0x82ed313c
	pc = 0x82ED313C; continue 'dispatch;
            }
            0x82ED3130 => {
    //   block [0x82ED3130..0x82ED313C)
	// 82ED3130: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 82ED3134: 93E5000C  stw r31, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ED3138: 91450010  stw r10, 0x10(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82ED313C; continue 'dispatch;
            }
            0x82ED313C => {
    //   block [0x82ED313C..0x82ED3148)
	// 82ED313C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED3140: 40820010  bne 0x82ed3150
	if !ctx.cr[0].eq {
	pc = 0x82ED3150; continue 'dispatch;
	}
	// 82ED3144: 9BBE0010  stb r29, 0x10(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	pc = 0x82ED3148; continue 'dispatch;
            }
            0x82ED3148 => {
    //   block [0x82ED3148..0x82ED314C)
	// 82ED3148: 9BFE0039  stb r31, 0x39(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(57 as u32), ctx.r[31].u8 ) };
	pc = 0x82ED314C; continue 'dispatch;
            }
            0x82ED314C => {
    //   block [0x82ED314C..0x82ED3150)
	// 82ED314C: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	pc = 0x82ED3150; continue 'dispatch;
            }
            0x82ED3150 => {
    //   block [0x82ED3150..0x82ED3174)
	// 82ED3150: 809E0040  lwz r4, 0x40(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED3154: 9BFE0030  stb r31, 0x30(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[31].u8 ) };
	// 82ED3158: 9BFE0038  stb r31, 0x38(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[31].u8 ) };
	// 82ED315C: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED3160: 9BFE0024  stb r31, 0x24(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[31].u8 ) };
	// 82ED3164: 93FE0034  stw r31, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[31].u32 ) };
	// 82ED3168: 4182000C  beq 0x82ed3174
	if ctx.cr[0].eq {
	pc = 0x82ED3174; continue 'dispatch;
	}
	// 82ED316C: 93E4003C  stw r31, 0x3c(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(60 as u32), ctx.r[31].u32 ) };
	// 82ED3170: 4BFFFDC1  bl 0x82ed2f30
	ctx.lr = 0x82ED3174;
	sub_82ED2F30(ctx, base);
	pc = 0x82ED3174; continue 'dispatch;
            }
            0x82ED3174 => {
    //   block [0x82ED3174..0x82ED3180)
	// 82ED3174: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ED3178: 93FE0040  stw r31, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	// 82ED317C: 93FE0044  stw r31, 0x44(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(68 as u32), ctx.r[31].u32 ) };
	pc = 0x82ED3180; continue 'dispatch;
            }
            0x82ED3180 => {
    //   block [0x82ED3180..0x82ED3188)
	// 82ED3180: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED3184: 4BDD62D8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED3188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED3188 size=1236
    let mut pc: u32 = 0x82ED3188;
    'dispatch: loop {
        match pc {
            0x82ED3188 => {
    //   block [0x82ED3188..0x82ED31D0)
	// 82ED3188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED318C: 4BDD6269  bl 0x82ca93f4
	ctx.lr = 0x82ED3190;
	sub_82CA93D0(ctx, base);
	// 82ED3190: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82ED3194: 4BDDAB19  bl 0x82cadcac
	ctx.lr = 0x82ED3198;
	sub_82CADCA0(ctx, base);
	// 82ED3198: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED319C: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 82ED31A0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82ED31A4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82ED31A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ED31AC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ED31B0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82ED31B4: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82ED31B8: 93790000  stw r27, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82ED31BC: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 82ED31C0: 817E0294  lwz r11, 0x294(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(660 as u32) ) } as u64;
	// 82ED31C4: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 82ED31C8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ED31CC: 419A000C  beq cr6, 0x82ed31d8
	if ctx.cr[6].eq {
	pc = 0x82ED31D8; continue 'dispatch;
	}
	pc = 0x82ED31D0; continue 'dispatch;
            }
            0x82ED31D0 => {
    //   block [0x82ED31D0..0x82ED31D8)
	// 82ED31D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED31D4: 48000478  b 0x82ed364c
	pc = 0x82ED364C; continue 'dispatch;
            }
            0x82ED31D8 => {
    //   block [0x82ED31D8..0x82ED31F4)
	// 82ED31D8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ED31DC: 419A0018  beq cr6, 0x82ed31f4
	if ctx.cr[6].eq {
	pc = 0x82ED31F4; continue 'dispatch;
	}
	// 82ED31E0: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED31E4: 616B84DC  ori r11, r11, 0x84dc
	ctx.r[11].u64 = ctx.r[11].u64 | 34012;
	// 82ED31E8: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED31EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED31F0: 419AFFE0  beq cr6, 0x82ed31d0
	if ctx.cr[6].eq {
	pc = 0x82ED31D0; continue 'dispatch;
	}
	pc = 0x82ED31F4; continue 'dispatch;
            }
            0x82ED31F4 => {
    //   block [0x82ED31F4..0x82ED320C)
	// 82ED31F4: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED31F8: C2DF0000  lfs f22, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82ED31FC: FF00B000  fcmpu cr6, f0, f22
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[22].f64);
	// 82ED3200: 4098000C  bge cr6, 0x82ed320c
	if !ctx.cr[6].lt {
	pc = 0x82ED320C; continue 'dispatch;
	}
	// 82ED3204: FEE00090  fmr f23, f0
	ctx.f[23].f64 = ctx.f[0].f64;
	// 82ED3208: 4800000C  b 0x82ed3214
	pc = 0x82ED3214; continue 'dispatch;
            }
            0x82ED320C => {
    //   block [0x82ED320C..0x82ED3214)
	// 82ED320C: FEE0B090  fmr f23, f22
	ctx.f[23].f64 = ctx.f[22].f64;
	// 82ED3210: FEC00090  fmr f22, f0
	ctx.f[22].f64 = ctx.f[0].f64;
	pc = 0x82ED3214; continue 'dispatch;
            }
            0x82ED3214 => {
    //   block [0x82ED3214..0x82ED322C)
	// 82ED3214: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3218: C37F0004  lfs f27, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82ED321C: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82ED3220: 4098000C  bge cr6, 0x82ed322c
	if !ctx.cr[6].lt {
	pc = 0x82ED322C; continue 'dispatch;
	}
	// 82ED3224: FF800090  fmr f28, f0
	ctx.f[28].f64 = ctx.f[0].f64;
	// 82ED3228: 4800000C  b 0x82ed3234
	pc = 0x82ED3234; continue 'dispatch;
            }
            0x82ED322C => {
    //   block [0x82ED322C..0x82ED3234)
	// 82ED322C: FF80D890  fmr f28, f27
	ctx.f[28].f64 = ctx.f[27].f64;
	// 82ED3230: FF600090  fmr f27, f0
	ctx.f[27].f64 = ctx.f[0].f64;
	pc = 0x82ED3234; continue 'dispatch;
            }
            0x82ED3234 => {
    //   block [0x82ED3234..0x82ED324C)
	// 82ED3234: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3238: C3BF0008  lfs f29, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82ED323C: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82ED3240: 4098000C  bge cr6, 0x82ed324c
	if !ctx.cr[6].lt {
	pc = 0x82ED324C; continue 'dispatch;
	}
	// 82ED3244: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 82ED3248: 4800000C  b 0x82ed3254
	pc = 0x82ED3254; continue 'dispatch;
            }
            0x82ED324C => {
    //   block [0x82ED324C..0x82ED3254)
	// 82ED324C: FFC0E890  fmr f30, f29
	ctx.f[30].f64 = ctx.f[29].f64;
	// 82ED3250: FFA00090  fmr f29, f0
	ctx.f[29].f64 = ctx.f[0].f64;
	pc = 0x82ED3254; continue 'dispatch;
            }
            0x82ED3254 => {
    //   block [0x82ED3254..0x82ED3288)
	// 82ED3254: 817E0180  lwz r11, 0x180(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(384 as u32) ) } as u64;
	// 82ED3258: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED325C: 409A014C  bne cr6, 0x82ed33a8
	if !ctx.cr[6].eq {
	pc = 0x82ED33A8; continue 'dispatch;
	}
	// 82ED3260: 817E017C  lwz r11, 0x17c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED3264: EF57F828  fsubs f26, f23, f31
	ctx.f[26].f64 = (((ctx.f[23].f64 - ctx.f[31].f64) as f32) as f64);
	// 82ED3268: EF9CF828  fsubs f28, f28, f31
	ctx.f[28].f64 = (((ctx.f[28].f64 - ctx.f[31].f64) as f32) as f64);
	// 82ED326C: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 82ED3270: EFDEF828  fsubs f30, f30, f31
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 82ED3274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED3278: EF36F82A  fadds f25, f22, f31
	ctx.f[25].f64 = ((ctx.f[22].f64 + ctx.f[31].f64) as f32) as f64;
	// 82ED327C: EF7BF82A  fadds f27, f27, f31
	ctx.f[27].f64 = ((ctx.f[27].f64 + ctx.f[31].f64) as f32) as f64;
	// 82ED3280: EFFDF82A  fadds f31, f29, f31
	ctx.f[31].f64 = ((ctx.f[29].f64 + ctx.f[31].f64) as f32) as f64;
	// 82ED3284: 409903C4  ble cr6, 0x82ed3648
	if !ctx.cr[6].gt {
	pc = 0x82ED3648; continue 'dispatch;
	}
	pc = 0x82ED3288; continue 'dispatch;
            }
            0x82ED3288 => {
    //   block [0x82ED3288..0x82ED32E0)
	// 82ED3288: 817E01FC  lwz r11, 0x1fc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ED328C: 7FFB5A14  add r31, r27, r11
	ctx.r[31].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 82ED3290: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED3294: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82ED3298: 409A00F8  bne cr6, 0x82ed3390
	if !ctx.cr[6].eq {
	pc = 0x82ED3390; continue 'dispatch;
	}
	// 82ED329C: 817E020C  lwz r11, 0x20c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(524 as u32) ) } as u64;
	// 82ED32A0: 7D6BE0AE  lbzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82ED32A4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED32A8: 419A00E8  beq cr6, 0x82ed3390
	if ctx.cr[6].eq {
	pc = 0x82ED3390; continue 'dispatch;
	}
	// 82ED32AC: 3FBE0001  addis r29, r30, 1
	ctx.r[29].s64 = ctx.r[30].s64 + 65536;
	// 82ED32B0: 3BBD84D8  addi r29, r29, -0x7b28
	ctx.r[29].s64 = ctx.r[29].s64 + -31528;
	// 82ED32B4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED32B8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED32BC: 409A0040  bne cr6, 0x82ed32fc
	if !ctx.cr[6].eq {
	pc = 0x82ED32FC; continue 'dispatch;
	}
	// 82ED32C0: 89610187  lbz r11, 0x187(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(391 as u32) ) } as u64;
	// 82ED32C4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED32C8: 40820034  bne 0x82ed32fc
	if !ctx.cr[0].eq {
	pc = 0x82ED32FC; continue 'dispatch;
	}
	// 82ED32CC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED32D0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ED32D4: 409A000C  bne cr6, 0x82ed32e0
	if !ctx.cr[6].eq {
	pc = 0x82ED32E0; continue 'dispatch;
	}
	// 82ED32D8: 807E0034  lwz r3, 0x34(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED32DC: 48000008  b 0x82ed32e4
	pc = 0x82ED32E4; continue 'dispatch;
            }
            0x82ED32E0 => {
    //   block [0x82ED32E0..0x82ED32E4)
	// 82ED32E0: 807E0030  lwz r3, 0x30(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	pc = 0x82ED32E4; continue 'dispatch;
            }
            0x82ED32E4 => {
    //   block [0x82ED32E4..0x82ED32FC)
	// 82ED32E4: 4800344D  bl 0x82ed6730
	ctx.lr = 0x82ED32E8;
	sub_82ED6730(ctx, base);
	// 82ED32E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED32EC: 419A00A4  beq cr6, 0x82ed3390
	if ctx.cr[6].eq {
	pc = 0x82ED3390; continue 'dispatch;
	}
	// 82ED32F0: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED32F4: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED32F8: 409A0098  bne cr6, 0x82ed3390
	if !ctx.cr[6].eq {
	pc = 0x82ED3390; continue 'dispatch;
	}
	pc = 0x82ED32FC; continue 'dispatch;
            }
            0x82ED32FC => {
    //   block [0x82ED32FC..0x82ED331C)
	// 82ED32FC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED3300: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED3304: 409A0018  bne cr6, 0x82ed331c
	if !ctx.cr[6].eq {
	pc = 0x82ED331C; continue 'dispatch;
	}
	// 82ED3308: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ED330C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED3310: 4BFFECC1  bl 0x82ed1fd0
	ctx.lr = 0x82ED3314;
	sub_82ED1FD0(ctx, base);
	// 82ED3314: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED3318: 40820078  bne 0x82ed3390
	if !ctx.cr[0].eq {
	pc = 0x82ED3390; continue 'dispatch;
	}
	pc = 0x82ED331C; continue 'dispatch;
            }
            0x82ED331C => {
    //   block [0x82ED331C..0x82ED3384)
	// 82ED331C: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3320: FF00C800  fcmpu cr6, f0, f25
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[25].f64);
	// 82ED3324: 4199006C  bgt cr6, 0x82ed3390
	if ctx.cr[6].gt {
	pc = 0x82ED3390; continue 'dispatch;
	}
	// 82ED3328: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED332C: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82ED3330: 41990060  bgt cr6, 0x82ed3390
	if ctx.cr[6].gt {
	pc = 0x82ED3390; continue 'dispatch;
	}
	// 82ED3334: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3338: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ED333C: 41990054  bgt cr6, 0x82ed3390
	if ctx.cr[6].gt {
	pc = 0x82ED3390; continue 'dispatch;
	}
	// 82ED3340: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3344: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82ED3348: 41980048  blt cr6, 0x82ed3390
	if ctx.cr[6].lt {
	pc = 0x82ED3390; continue 'dispatch;
	}
	// 82ED334C: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3350: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82ED3354: 4198003C  blt cr6, 0x82ed3390
	if ctx.cr[6].lt {
	pc = 0x82ED3390; continue 'dispatch;
	}
	// 82ED3358: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED335C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82ED3360: 41980030  blt cr6, 0x82ed3390
	if ctx.cr[6].lt {
	pc = 0x82ED3390; continue 'dispatch;
	}
	// 82ED3364: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED3368: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82ED336C: 409802DC  bge cr6, 0x82ed3648
	if !ctx.cr[6].lt {
	pc = 0x82ED3648; continue 'dispatch;
	}
	// 82ED3370: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82ED3374: 419A0010  beq cr6, 0x82ed3384
	if ctx.cr[6].eq {
	pc = 0x82ED3384; continue 'dispatch;
	}
	// 82ED3378: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED337C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED3380: 7D4BC12E  stwx r10, r11, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32), ctx.r[10].u32) };
	pc = 0x82ED3384; continue 'dispatch;
            }
            0x82ED3384 => {
    //   block [0x82ED3384..0x82ED3390)
	// 82ED3384: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED3388: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED338C: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED3390; continue 'dispatch;
            }
            0x82ED3390 => {
    //   block [0x82ED3390..0x82ED33A8)
	// 82ED3390: 817E017C  lwz r11, 0x17c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED3394: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ED3398: 3B7B0030  addi r27, r27, 0x30
	ctx.r[27].s64 = ctx.r[27].s64 + 48;
	// 82ED339C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED33A0: 4198FEE8  blt cr6, 0x82ed3288
	if ctx.cr[6].lt {
	pc = 0x82ED3288; continue 'dispatch;
	}
	// 82ED33A4: 480002A4  b 0x82ed3648
	pc = 0x82ED3648; continue 'dispatch;
            }
            0x82ED33A8 => {
    //   block [0x82ED33A8..0x82ED3490)
	// 82ED33A8: 7B4A0020  clrldi r10, r26, 0x20
	ctx.r[10].u64 = ctx.r[26].u64 & 0x00000000FFFFFFFFu64;
	// 82ED33AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED33B0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82ED33B4: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82ED33B8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82ED33BC: C82B0DE8  lfd f1, 0xde8(r11)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3560 as u32) ) };
	// 82ED33C0: FC400018  frsp f2, f0
	ctx.f[2].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82ED33C4: 4B32B0E5  bl 0x821fe4a8
	ctx.lr = 0x82ED33C8;
	sub_821FE4A8(ctx, base);
	// 82ED33C8: C1BD0000  lfs f13, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED33CC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82ED33D0: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED33D4: 815E017C  lwz r10, 0x17c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED33D8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED33DC: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED33E0: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED33E4: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 82ED33E8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED33EC: C17D0004  lfs f11, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED33F0: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED33F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ED33F8: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82ED33FC: C15E0190  lfs f10, 0x190(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(400 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED3400: FD600818  frsp f11, f1
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED3404: FD605E5E  fctidz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[11].f64.trunc() as i64 };
	// 82ED3408: 7D605FAE  stfiwx f11, 0, r11
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82ED340C: ED6D0372  fmuls f11, f13, f13
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED3410: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED3414: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82ED3418: C9210050  lfd f9, 0x50(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82ED341C: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 82ED3420: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED3424: ED60583A  fmadds f11, f0, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82ED3428: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82ED342C: ED6C5B3A  fmadds f11, f12, f12, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 82ED3430: EEAA0272  fmuls f21, f10, f9
	ctx.f[21].f64 = (((ctx.f[10].f64 * ctx.f[9].f64) as f32) as f64);
	// 82ED3434: EE60582C  fsqrts f19, f11
	ctx.f[19].f64 = ((ctx.f[11].f64).sqrt() as f32) as f64;
	// 82ED3438: C16B0C14  lfs f11, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED343C: ED6B9824  fdivs f11, f11, f19
	ctx.f[11].f64 = ((ctx.f[11].f64 / ctx.f[19].f64) as f32) as f64;
	// 82ED3440: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED3444: C28B0BFC  lfs f20, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 82ED3448: EF0B0372  fmuls f24, f11, f13
	ctx.f[24].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED344C: EDB50532  fmuls f13, f21, f20
	ctx.f[13].f64 = (((ctx.f[21].f64 * ctx.f[20].f64) as f32) as f64);
	// 82ED3450: EF4B0032  fmuls f26, f11, f0
	ctx.f[26].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED3454: EF2B0332  fmuls f25, f11, f12
	ctx.f[25].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82ED3458: EC0DF82A  fadds f0, f13, f31
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82ED345C: ED8DB02A  fadds f12, f13, f22
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[22].f64) as f32) as f64;
	// 82ED3460: ED6DD82A  fadds f11, f13, f27
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[27].f64) as f32) as f64;
	// 82ED3464: EDADE82A  fadds f13, f13, f29
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[29].f64) as f32) as f64;
	// 82ED3468: EFB70028  fsubs f29, f23, f0
	ctx.f[29].f64 = (((ctx.f[23].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED346C: EECCF82A  fadds f22, f12, f31
	ctx.f[22].f64 = ((ctx.f[12].f64 + ctx.f[31].f64) as f32) as f64;
	// 82ED3470: EE4BF82A  fadds f18, f11, f31
	ctx.f[18].f64 = ((ctx.f[11].f64 + ctx.f[31].f64) as f32) as f64;
	// 82ED3474: EE2DF82A  fadds f17, f13, f31
	ctx.f[17].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82ED3478: EF9C0028  fsubs f28, f28, f0
	ctx.f[28].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED347C: EFDE0028  fsubs f30, f30, f0
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED3480: EFE00032  fmuls f31, f0, f0
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED3484: 409901C4  ble cr6, 0x82ed3648
	if !ctx.cr[6].gt {
	pc = 0x82ED3648; continue 'dispatch;
	}
	// 82ED3488: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED348C: C36B0C18  lfs f27, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	pc = 0x82ED3490; continue 'dispatch;
            }
            0x82ED3490 => {
    //   block [0x82ED3490..0x82ED34E8)
	// 82ED3490: 817E01FC  lwz r11, 0x1fc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 82ED3494: 7FFB5A14  add r31, r27, r11
	ctx.r[31].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 82ED3498: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED349C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82ED34A0: 409A0194  bne cr6, 0x82ed3634
	if !ctx.cr[6].eq {
	pc = 0x82ED3634; continue 'dispatch;
	}
	// 82ED34A4: 817E020C  lwz r11, 0x20c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(524 as u32) ) } as u64;
	// 82ED34A8: 7D6BE0AE  lbzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82ED34AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED34B0: 419A0184  beq cr6, 0x82ed3634
	if ctx.cr[6].eq {
	pc = 0x82ED3634; continue 'dispatch;
	}
	// 82ED34B4: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED34B8: 616B84D8  ori r11, r11, 0x84d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34008;
	// 82ED34BC: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED34C0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED34C4: 409A0040  bne cr6, 0x82ed3504
	if !ctx.cr[6].eq {
	pc = 0x82ED3504; continue 'dispatch;
	}
	// 82ED34C8: 89610187  lbz r11, 0x187(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(391 as u32) ) } as u64;
	// 82ED34CC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED34D0: 40820034  bne 0x82ed3504
	if !ctx.cr[0].eq {
	pc = 0x82ED3504; continue 'dispatch;
	}
	// 82ED34D4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED34D8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ED34DC: 409A000C  bne cr6, 0x82ed34e8
	if !ctx.cr[6].eq {
	pc = 0x82ED34E8; continue 'dispatch;
	}
	// 82ED34E0: 807E0034  lwz r3, 0x34(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED34E4: 48000008  b 0x82ed34ec
	pc = 0x82ED34EC; continue 'dispatch;
            }
            0x82ED34E8 => {
    //   block [0x82ED34E8..0x82ED34EC)
	// 82ED34E8: 807E0030  lwz r3, 0x30(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	pc = 0x82ED34EC; continue 'dispatch;
            }
            0x82ED34EC => {
    //   block [0x82ED34EC..0x82ED3504)
	// 82ED34EC: 48003245  bl 0x82ed6730
	ctx.lr = 0x82ED34F0;
	sub_82ED6730(ctx, base);
	// 82ED34F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED34F4: 419A0140  beq cr6, 0x82ed3634
	if ctx.cr[6].eq {
	pc = 0x82ED3634; continue 'dispatch;
	}
	// 82ED34F8: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED34FC: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED3500: 409A0134  bne cr6, 0x82ed3634
	if !ctx.cr[6].eq {
	pc = 0x82ED3634; continue 'dispatch;
	}
	pc = 0x82ED3504; continue 'dispatch;
            }
            0x82ED3504 => {
    //   block [0x82ED3504..0x82ED35C4)
	// 82ED3504: E97F0006  lwa r11, 4(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as i32) as i64;
	// 82ED3508: C01E0184  lfs f0, 0x184(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED350C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82ED3510: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82ED3514: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82ED3518: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82ED351C: EDADA02A  fadds f13, f13, f20
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[20].f64) as f32) as f64;
	// 82ED3520: ECCD057A  fmadds f6, f13, f21, f0
	ctx.f[6].f64 = (((ctx.f[13].f64 * ctx.f[21].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED3524: FF06E800  fcmpu cr6, f6, f29
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[29].f64);
	// 82ED3528: 4198010C  blt cr6, 0x82ed3634
	if ctx.cr[6].lt {
	pc = 0x82ED3634; continue 'dispatch;
	}
	// 82ED352C: FF06B000  fcmpu cr6, f6, f22
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[22].f64);
	// 82ED3530: 41990104  bgt cr6, 0x82ed3634
	if ctx.cr[6].gt {
	pc = 0x82ED3634; continue 'dispatch;
	}
	// 82ED3534: E97F000A  lwa r11, 8(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as i32) as i64;
	// 82ED3538: C01E0188  lfs f0, 0x188(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED353C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82ED3540: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82ED3544: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82ED3548: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82ED354C: EDADA02A  fadds f13, f13, f20
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[20].f64) as f32) as f64;
	// 82ED3550: ECED057A  fmadds f7, f13, f21, f0
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[21].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED3554: FF07E000  fcmpu cr6, f7, f28
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[28].f64);
	// 82ED3558: 419800DC  blt cr6, 0x82ed3634
	if ctx.cr[6].lt {
	pc = 0x82ED3634; continue 'dispatch;
	}
	// 82ED355C: FF079000  fcmpu cr6, f7, f18
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[18].f64);
	// 82ED3560: 419900D4  bgt cr6, 0x82ed3634
	if ctx.cr[6].gt {
	pc = 0x82ED3634; continue 'dispatch;
	}
	// 82ED3564: E97F000E  lwa r11, 0xc(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as i32) as i64;
	// 82ED3568: C01E018C  lfs f0, 0x18c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED356C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82ED3570: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82ED3574: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82ED3578: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82ED357C: EDADA02A  fadds f13, f13, f20
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[20].f64) as f32) as f64;
	// 82ED3580: ED0D057A  fmadds f8, f13, f21, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[21].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED3584: FF08F000  fcmpu cr6, f8, f30
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[30].f64);
	// 82ED3588: 419800AC  blt cr6, 0x82ed3634
	if ctx.cr[6].lt {
	pc = 0x82ED3634; continue 'dispatch;
	}
	// 82ED358C: FF088800  fcmpu cr6, f8, f17
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[17].f64);
	// 82ED3590: 419900A4  bgt cr6, 0x82ed3634
	if ctx.cr[6].gt {
	pc = 0x82ED3634; continue 'dispatch;
	}
	// 82ED3594: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3598: EC076828  fsubs f0, f7, f13
	ctx.f[0].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED359C: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED35A0: ED486028  fsubs f10, f8, f12
	ctx.f[10].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 82ED35A4: C17D0000  lfs f11, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED35A8: ED265828  fsubs f9, f6, f11
	ctx.f[9].f64 = (((ctx.f[6].f64 - ctx.f[11].f64) as f32) as f64);
	// 82ED35AC: EC000672  fmuls f0, f0, f25
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 82ED35B0: EC0A063A  fmadds f0, f10, f24, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[24].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED35B4: EC0906BA  fmadds f0, f9, f26, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[26].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED35B8: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82ED35BC: 40980008  bge cr6, 0x82ed35c4
	if !ctx.cr[6].lt {
	pc = 0x82ED35C4; continue 'dispatch;
	}
	// 82ED35C0: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	pc = 0x82ED35C4; continue 'dispatch;
            }
            0x82ED35C4 => {
    //   block [0x82ED35C4..0x82ED35D0)
	// 82ED35C4: FF009800  fcmpu cr6, f0, f19
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[19].f64);
	// 82ED35C8: 40990008  ble cr6, 0x82ed35d0
	if !ctx.cr[6].gt {
	pc = 0x82ED35D0; continue 'dispatch;
	}
	// 82ED35CC: FC009890  fmr f0, f19
	ctx.f[0].f64 = ctx.f[19].f64;
	pc = 0x82ED35D0; continue 'dispatch;
            }
            0x82ED35D0 => {
    //   block [0x82ED35D0..0x82ED3628)
	// 82ED35D0: ED400672  fmuls f10, f0, f25
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 82ED35D4: ED200632  fmuls f9, f0, f24
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[24].f64) as f32) as f64);
	// 82ED35D8: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 82ED35DC: EDAD502A  fadds f13, f13, f10
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82ED35E0: ED8C482A  fadds f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64;
	// 82ED35E4: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED35E8: EC076828  fsubs f0, f7, f13
	ctx.f[0].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED35EC: EDA86028  fsubs f13, f8, f12
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 82ED35F0: ED865828  fsubs f12, f6, f11
	ctx.f[12].f64 = (((ctx.f[6].f64 - ctx.f[11].f64) as f32) as f64);
	// 82ED35F4: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED35F8: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED35FC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED3600: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ED3604: 40980030  bge cr6, 0x82ed3634
	if !ctx.cr[6].lt {
	pc = 0x82ED3634; continue 'dispatch;
	}
	// 82ED3608: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED360C: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82ED3610: 40980038  bge cr6, 0x82ed3648
	if !ctx.cr[6].lt {
	pc = 0x82ED3648; continue 'dispatch;
	}
	// 82ED3614: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82ED3618: 419A0010  beq cr6, 0x82ed3628
	if ctx.cr[6].eq {
	pc = 0x82ED3628; continue 'dispatch;
	}
	// 82ED361C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED3620: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED3624: 7D4BC12E  stwx r10, r11, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32), ctx.r[10].u32) };
	pc = 0x82ED3628; continue 'dispatch;
            }
            0x82ED3628 => {
    //   block [0x82ED3628..0x82ED3634)
	// 82ED3628: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED362C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED3630: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED3634; continue 'dispatch;
            }
            0x82ED3634 => {
    //   block [0x82ED3634..0x82ED3648)
	// 82ED3634: 817E017C  lwz r11, 0x17c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ED3638: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ED363C: 3B7B0030  addi r27, r27, 0x30
	ctx.r[27].s64 = ctx.r[27].s64 + 48;
	// 82ED3640: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED3644: 4198FE4C  blt cr6, 0x82ed3490
	if ctx.cr[6].lt {
	pc = 0x82ED3490; continue 'dispatch;
	}
	pc = 0x82ED3648; continue 'dispatch;
            }
            0x82ED3648 => {
    //   block [0x82ED3648..0x82ED364C)
	// 82ED3648: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82ED364C; continue 'dispatch;
            }
            0x82ED364C => {
    //   block [0x82ED364C..0x82ED365C)
	// 82ED364C: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82ED3650: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82ED3654: 4BDDA6A5  bl 0x82cadcf8
	ctx.lr = 0x82ED3658;
	sub_82CADCEC(ctx, base);
	// 82ED3658: 4BDD5DEC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED3660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82ED3660 size=44
    let mut pc: u32 = 0x82ED3660;
    'dispatch: loop {
        match pc {
            0x82ED3660 => {
    //   block [0x82ED3660..0x82ED368C)
	// 82ED3660: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ED3664: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED3668: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED366C: C1AA0000  lfs f13, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3670: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82ED3674: C00A84AC  lfs f0, -0x7b54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3678: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED367C: 419A0010  beq cr6, 0x82ed368c
	if ctx.cr[6].eq {
		sub_82ED368C(ctx, base);
		return;
	}
	// 82ED3680: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED3684: C02B0EE0  lfs f1, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ED3688: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED368C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82ED368C size=44
    let mut pc: u32 = 0x82ED368C;
    'dispatch: loop {
        match pc {
            0x82ED368C => {
    //   block [0x82ED368C..0x82ED3694)
	// 82ED368C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ED3690: C02A0C18  lfs f1, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x82ED3694; continue 'dispatch;
            }
            0x82ED3694 => {
    //   block [0x82ED3694..0x82ED36A8)
	// 82ED3694: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED3698: C00A0038  lfs f0, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED369C: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82ED36A0: 40990008  ble cr6, 0x82ed36a8
	if !ctx.cr[6].gt {
	pc = 0x82ED36A8; continue 'dispatch;
	}
	// 82ED36A4: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	pc = 0x82ED36A8; continue 'dispatch;
            }
            0x82ED36A8 => {
    //   block [0x82ED36A8..0x82ED36B8)
	// 82ED36A8: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED36AC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED36B0: 4082FFE4  bne 0x82ed3694
	if !ctx.cr[0].eq {
	pc = 0x82ED3694; continue 'dispatch;
	}
	// 82ED36B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED36B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82ED36B8 size=24
    let mut pc: u32 = 0x82ED36B8;
    'dispatch: loop {
        match pc {
            0x82ED36B8 => {
    //   block [0x82ED36B8..0x82ED36D0)
	// 82ED36B8: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED36BC: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED36C0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED36C4: 4099000C  ble cr6, 0x82ed36d0
	if !ctx.cr[6].gt {
		sub_82ED36D0(ctx, base);
		return;
	}
	// 82ED36C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ED36CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED36D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED36D0 size=20
    let mut pc: u32 = 0x82ED36D0;
    'dispatch: loop {
        match pc {
            0x82ED36D0 => {
    //   block [0x82ED36D0..0x82ED36E4)
	// 82ED36D0: FF006800  fcmpu cr6, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED36D4: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED36D8: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 82ED36DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED36E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED36E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED36E8 size=36
    let mut pc: u32 = 0x82ED36E8;
    'dispatch: loop {
        match pc {
            0x82ED36E8 => {
    //   block [0x82ED36E8..0x82ED370C)
	// 82ED36E8: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82ED36EC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ED36F0: 392A89AC  addi r9, r10, -0x7654
	ctx.r[9].s64 = ctx.r[10].s64 + -30292;
	// 82ED36F4: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED36F8: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED36FC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82ED3700: 4198000C  blt cr6, 0x82ed370c
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82ED370C);
		return;
	}
	// 82ED3704: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED3708: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED3740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED3740 size=16
    let mut pc: u32 = 0x82ED3740;
    'dispatch: loop {
        match pc {
            0x82ED3740 => {
    //   block [0x82ED3740..0x82ED3750)
	// 82ED3740: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED3744: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82ED3748: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82ED374C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED3750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED3750 size=28
    let mut pc: u32 = 0x82ED3750;
    'dispatch: loop {
        match pc {
            0x82ED3750 => {
    //   block [0x82ED3750..0x82ED376C)
	// 82ED3750: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ED3754: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 82ED3758: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED375C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED3760: 4082000C  bne 0x82ed376c
	if !ctx.cr[0].eq {
		sub_82ED376C(ctx, base);
		return;
	}
	// 82ED3764: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED3768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED376C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED376C size=48
    let mut pc: u32 = 0x82ED376C;
    'dispatch: loop {
        match pc {
            0x82ED376C => {
    //   block [0x82ED376C..0x82ED379C)
	// 82ED376C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED3770: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED3774: 4182FFF0  beq 0x82ed3764
	if ctx.cr[0].eq {
		sub_82ED3750(ctx, base);
		return;
	}
	// 82ED3778: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82ED377C: 419AFFE8  beq cr6, 0x82ed3764
	if ctx.cr[6].eq {
		sub_82ED3750(ctx, base);
		return;
	}
	// 82ED3780: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED3784: 55690001  rlwinm. r9, r11, 0, 0, 0
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ED3788: 41820014  beq 0x82ed379c
	if ctx.cr[0].eq {
		sub_82ED379C(ctx, base);
		return;
	}
	// 82ED378C: 556B007E  clrlwi r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED3790: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ED3794: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED3798: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED379C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED379C size=88
    let mut pc: u32 = 0x82ED379C;
    'dispatch: loop {
        match pc {
            0x82ED379C => {
    //   block [0x82ED379C..0x82ED37BC)
	// 82ED379C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82ED37A0: 80CA0038  lwz r6, 0x38(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 82ED37A4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ED37A8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED37AC: 7D4A302E  lwzx r10, r10, r6
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82ED37B0: 55490000  rlwinm r9, r10, 0, 0, 0
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82ED37B4: 7F094840  cmplw cr6, r9, r9
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ED37B8: 409A0034  bne cr6, 0x82ed37ec
	if !ctx.cr[6].eq {
	pc = 0x82ED37EC; continue 'dispatch;
	}
	pc = 0x82ED37BC; continue 'dispatch;
            }
            0x82ED37BC => {
    //   block [0x82ED37BC..0x82ED37EC)
	// 82ED37BC: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82ED37C0: 419A0034  beq cr6, 0x82ed37f4
	if ctx.cr[6].eq {
		sub_82ED37F4(ctx, base);
		return;
	}
	// 82ED37C4: 554A007E  clrlwi r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED37C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED37CC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82ED37D0: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ED37D4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED37D8: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82ED37DC: 7D4A302E  lwzx r10, r10, r6
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82ED37E0: 55440000  rlwinm r4, r10, 0, 0, 0
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82ED37E4: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82ED37E8: 419AFFD4  beq cr6, 0x82ed37bc
	if ctx.cr[6].eq {
	pc = 0x82ED37BC; continue 'dispatch;
	}
	pc = 0x82ED37EC; continue 'dispatch;
            }
            0x82ED37EC => {
    //   block [0x82ED37EC..0x82ED37F4)
	// 82ED37EC: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 82ED37F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED37F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED37F4 size=8
    let mut pc: u32 = 0x82ED37F4;
    'dispatch: loop {
        match pc {
            0x82ED37F4 => {
    //   block [0x82ED37F4..0x82ED37FC)
	// 82ED37F4: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82ED37F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED3800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED3800 size=32
    let mut pc: u32 = 0x82ED3800;
    'dispatch: loop {
        match pc {
            0x82ED3800 => {
    //   block [0x82ED3800..0x82ED3820)
	// 82ED3800: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED3804: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED3808: 41820020  beq 0x82ed3828
	if ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ED3828);
		return;
	}
	// 82ED380C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED3810: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED3814: 4182000C  beq 0x82ed3820
	if ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ED3820);
		return;
	}
	// 82ED3818: 5563007E  clrlwi r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED381C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED3830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED3830 size=24
    let mut pc: u32 = 0x82ED3830;
    'dispatch: loop {
        match pc {
            0x82ED3830 => {
    //   block [0x82ED3830..0x82ED3848)
	// 82ED3830: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED3834: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED3838: 41820010  beq 0x82ed3848
	if ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ED3848);
		return;
	}
	// 82ED383C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED3840: 5563007E  clrlwi r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED3844: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED3850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED3850 size=76
    let mut pc: u32 = 0x82ED3850;
    'dispatch: loop {
        match pc {
            0x82ED3850 => {
    //   block [0x82ED3850..0x82ED3858)
	// 82ED3850: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED3854: 419A0040  beq cr6, 0x82ed3894
	if ctx.cr[6].eq {
	pc = 0x82ED3894; continue 'dispatch;
	}
	pc = 0x82ED3858; continue 'dispatch;
            }
            0x82ED3858 => {
    //   block [0x82ED3858..0x82ED3894)
	// 82ED3858: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED385C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED3860: 4182003C  beq 0x82ed389c
	if ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ED389C);
		return;
	}
	// 82ED3864: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED3868: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED386C: 409A0030  bne cr6, 0x82ed389c
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ED389C);
		return;
	}
	// 82ED3870: 89630038  lbz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82ED3874: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED3878: 40820024  bne 0x82ed389c
	if !ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ED389C);
		return;
	}
	// 82ED387C: 89630030  lbz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED3880: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED3884: 40820018  bne 0x82ed389c
	if !ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ED389C);
		return;
	}
	// 82ED3888: 80630040  lwz r3, 0x40(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED388C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED3890: 4082FFC8  bne 0x82ed3858
	if !ctx.cr[0].eq {
	pc = 0x82ED3858; continue 'dispatch;
	}
	pc = 0x82ED3894; continue 'dispatch;
            }
            0x82ED3894 => {
    //   block [0x82ED3894..0x82ED389C)
	// 82ED3894: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ED3898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED38A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED38A8 size=40
    let mut pc: u32 = 0x82ED38A8;
    'dispatch: loop {
        match pc {
            0x82ED38A8 => {
    //   block [0x82ED38A8..0x82ED38B0)
	// 82ED38A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED38AC: 419A001C  beq cr6, 0x82ed38c8
	if ctx.cr[6].eq {
	pc = 0x82ED38C8; continue 'dispatch;
	}
	pc = 0x82ED38B0; continue 'dispatch;
            }
            0x82ED38B0 => {
    //   block [0x82ED38B0..0x82ED38C8)
	// 82ED38B0: 89630038  lbz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82ED38B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED38B8: 40820018  bne 0x82ed38d0
	if !ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82ED38D0);
		return;
	}
	// 82ED38BC: 80630040  lwz r3, 0x40(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED38C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED38C4: 4082FFEC  bne 0x82ed38b0
	if !ctx.cr[0].eq {
	pc = 0x82ED38B0; continue 'dispatch;
	}
	pc = 0x82ED38C8; continue 'dispatch;
            }
            0x82ED38C8 => {
    //   block [0x82ED38C8..0x82ED38D0)
	// 82ED38C8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED38CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED38D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED38D8 size=152
    let mut pc: u32 = 0x82ED38D8;
    'dispatch: loop {
        match pc {
            0x82ED38D8 => {
    //   block [0x82ED38D8..0x82ED38F8)
	// 82ED38D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED38DC: 4BDD5B2D  bl 0x82ca9408
	ctx.lr = 0x82ED38E0;
	sub_82CA93D0(ctx, base);
	// 82ED38E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED38E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ED38E8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ED38EC: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82ED38F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ED38F4: 419A0060  beq cr6, 0x82ed3954
	if ctx.cr[6].eq {
	pc = 0x82ED3954; continue 'dispatch;
	}
	pc = 0x82ED38F8; continue 'dispatch;
            }
            0x82ED38F8 => {
    //   block [0x82ED38F8..0x82ED393C)
	// 82ED38F8: 83FC0014  lwz r31, 0x14(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED38FC: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED3900: 41820048  beq 0x82ed3948
	if ctx.cr[0].eq {
	pc = 0x82ED3948; continue 'dispatch;
	}
	// 82ED3904: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED3908: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED390C: 409A003C  bne cr6, 0x82ed3948
	if !ctx.cr[6].eq {
	pc = 0x82ED3948; continue 'dispatch;
	}
	// 82ED3910: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED3914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED3918: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED391C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED3920: 4E800421  bctrl
	ctx.lr = 0x82ED3924;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED3924: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED3928: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ED392C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED3930: 4082000C  bne 0x82ed393c
	if !ctx.cr[0].eq {
	pc = 0x82ED393C; continue 'dispatch;
	}
	// 82ED3934: 4BFF8F25  bl 0x82ecc858
	ctx.lr = 0x82ED3938;
	sub_82ECC858(ctx, base);
	// 82ED3938: 48000008  b 0x82ed3940
	pc = 0x82ED3940; continue 'dispatch;
            }
            0x82ED393C => {
    //   block [0x82ED393C..0x82ED3940)
	// 82ED393C: 4BFF8E95  bl 0x82ecc7d0
	ctx.lr = 0x82ED3940;
	sub_82ECC7D0(ctx, base);
	pc = 0x82ED3940; continue 'dispatch;
            }
            0x82ED3940 => {
    //   block [0x82ED3940..0x82ED3948)
	// 82ED3940: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED3944: 4082001C  bne 0x82ed3960
	if !ctx.cr[0].eq {
	pc = 0x82ED3960; continue 'dispatch;
	}
	pc = 0x82ED3948; continue 'dispatch;
            }
            0x82ED3948 => {
    //   block [0x82ED3948..0x82ED3954)
	// 82ED3948: 839C0040  lwz r28, 0x40(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED394C: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED3950: 4082FFA8  bne 0x82ed38f8
	if !ctx.cr[0].eq {
	pc = 0x82ED38F8; continue 'dispatch;
	}
	pc = 0x82ED3954; continue 'dispatch;
            }
            0x82ED3954 => {
    //   block [0x82ED3954..0x82ED3958)
	// 82ED3954: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ED3958; continue 'dispatch;
            }
            0x82ED3958 => {
    //   block [0x82ED3958..0x82ED3960)
	// 82ED3958: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ED395C: 4BDD5AFC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ED3960 => {
    //   block [0x82ED3960..0x82ED3970)
	// 82ED3960: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ED3964: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82ED3968: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82ED396C: 4BFFFFEC  b 0x82ed3958
	pc = 0x82ED3958; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED3970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED3970 size=80
    let mut pc: u32 = 0x82ED3970;
    'dispatch: loop {
        match pc {
            0x82ED3970 => {
    //   block [0x82ED3970..0x82ED3974)
	// 82ED3970: 48000008  b 0x82ed3978
	pc = 0x82ED3978; continue 'dispatch;
            }
            0x82ED3974 => {
    //   block [0x82ED3974..0x82ED3978)
	// 82ED3974: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	pc = 0x82ED3978; continue 'dispatch;
            }
            0x82ED3978 => {
    //   block [0x82ED3978..0x82ED3984)
	// 82ED3978: 8163003C  lwz r11, 0x3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ED397C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED3980: 4082FFF4  bne 0x82ed3974
	if !ctx.cr[0].eq {
	pc = 0x82ED3974; continue 'dispatch;
	}
	pc = 0x82ED3984; continue 'dispatch;
            }
            0x82ED3984 => {
    //   block [0x82ED3984..0x82ED39B0)
	// 82ED3984: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED3988: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED398C: 2F0A0005  cmpwi cr6, r10, 5
	ctx.cr[6].compare_i32(ctx.r[10].s32, 5, &mut ctx.xer);
	// 82ED3990: 409A0020  bne cr6, 0x82ed39b0
	if !ctx.cr[6].eq {
	pc = 0x82ED39B0; continue 'dispatch;
	}
	// 82ED3994: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED3998: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED399C: 41980014  blt cr6, 0x82ed39b0
	if ctx.cr[6].lt {
	pc = 0x82ED39B0; continue 'dispatch;
	}
	// 82ED39A0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED39A4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED39A8: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED39AC: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82ED39B0; continue 'dispatch;
            }
            0x82ED39B0 => {
    //   block [0x82ED39B0..0x82ED39C0)
	// 82ED39B0: 80630040  lwz r3, 0x40(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED39B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED39B8: 4082FFCC  bne 0x82ed3984
	if !ctx.cr[0].eq {
	pc = 0x82ED3984; continue 'dispatch;
	}
	// 82ED39BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED39C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED39C0 size=144
    let mut pc: u32 = 0x82ED39C0;
    'dispatch: loop {
        match pc {
            0x82ED39C0 => {
    //   block [0x82ED39C0..0x82ED3A50)
	// 82ED39C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED39C4: 4BDD5A49  bl 0x82ca940c
	ctx.lr = 0x82ED39C8;
	sub_82CA93D0(ctx, base);
	// 82ED39C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED39CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED39D0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ED39D4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ED39D8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED39DC: 386BF9A8  addi r3, r11, -0x658
	ctx.r[3].s64 = ctx.r[11].s64 + -1624;
	// 82ED39E0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82ED39E4: 995F0010  stb r10, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 82ED39E8: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82ED39EC: 38A00800  li r5, 0x800
	ctx.r[5].s64 = 2048;
	// 82ED39F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ED39F4: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82ED39F8: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82ED39FC: 9BDF0030  stb r30, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u8 ) };
	// 82ED3A00: 9BDF0038  stb r30, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 82ED3A04: 916A89B4  stw r11, -0x764c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-30284 as u32), ctx.r[11].u32 ) };
	// 82ED3A08: 4BDD5FA9  bl 0x82ca99b0
	ctx.lr = 0x82ED3A0C;
	sub_82CA99B0(ctx, base);
	// 82ED3A0C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED3A10: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82ED3A14: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 82ED3A18: 3BABBA7C  addi r29, r11, -0x4584
	ctx.r[29].s64 = ctx.r[11].s64 + -17796;
	// 82ED3A1C: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82ED3A20: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82ED3A24: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82ED3A28: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82ED3A2C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82ED3A30: 4B38CF89  bl 0x822609b8
	ctx.lr = 0x82ED3A34;
	sub_822609B8(ctx, base);
	// 82ED3A34: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ED3A38: 4BFAD801  bl 0x82e81238
	ctx.lr = 0x82ED3A3C;
	sub_82E81238(ctx, base);
	// 82ED3A3C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ED3A40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED3A44: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82ED3A48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED3A4C: 4BDD5A10  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


