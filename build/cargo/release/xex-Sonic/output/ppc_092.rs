pub fn sub_82817770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82817770 size=196
    let mut pc: u32 = 0x82817770;
    'dispatch: loop {
        match pc {
            0x82817770 => {
    //   block [0x82817770..0x82817834)
	// 82817770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82817774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82817778: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281777C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82817780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82817784: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82817788: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281778C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82817790: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82817794: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817798: 4BAA91A1  bl 0x822c0938
	ctx.lr = 0x8281779C;
	sub_822C0938(ctx, base);
	// 8281779C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828177A0: 41820028  beq 0x828177c8
	if ctx.cr[0].eq {
	pc = 0x828177C8; continue 'dispatch;
	}
	// 828177A4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828177A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828177AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828177B0: 392B9568  addi r9, r11, -0x6a98
	ctx.r[9].s64 = ctx.r[11].s64 + -27288;
	// 828177B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828177B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828177BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828177C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828177C4: 48000008  b 0x828177cc
	pc = 0x828177CC; continue 'dispatch;
	// 828177C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828177CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828177D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828177D4: 409A0044  bne cr6, 0x82817818
	if !ctx.cr[6].eq {
	pc = 0x82817818; continue 'dispatch;
	}
	// 828177D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828177DC: 419A001C  beq cr6, 0x828177f8
	if ctx.cr[6].eq {
	pc = 0x828177F8; continue 'dispatch;
	}
	// 828177E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828177E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828177E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828177EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828177F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828177F4: 4E800421  bctrl
	ctx.lr = 0x828177F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828177F8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828177FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82817800: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82817804: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82817808: 816BF35C  lwz r11, -0xca4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3236 as u32) ) } as u64;
	// 8281780C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82817810: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82817814: 4BAA87ED  bl 0x822c0000
	ctx.lr = 0x82817818;
	sub_822C0000(ctx, base);
	// 82817818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281781C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82817820: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82817824: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82817828: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281782C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82817830: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82817838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82817838 size=196
    let mut pc: u32 = 0x82817838;
    'dispatch: loop {
        match pc {
            0x82817838 => {
    //   block [0x82817838..0x828178FC)
	// 82817838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281783C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82817840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82817844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82817848: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281784C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82817850: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82817854: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82817858: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281785C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817860: 4BAA90D9  bl 0x822c0938
	ctx.lr = 0x82817864;
	sub_822C0938(ctx, base);
	// 82817864: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82817868: 41820028  beq 0x82817890
	if ctx.cr[0].eq {
	pc = 0x82817890; continue 'dispatch;
	}
	// 8281786C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82817870: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82817874: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82817878: 392B957C  addi r9, r11, -0x6a84
	ctx.r[9].s64 = ctx.r[11].s64 + -27268;
	// 8281787C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82817880: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82817884: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82817888: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8281788C: 48000008  b 0x82817894
	pc = 0x82817894; continue 'dispatch;
	// 82817890: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82817894: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281789C: 409A0044  bne cr6, 0x828178e0
	if !ctx.cr[6].eq {
	pc = 0x828178E0; continue 'dispatch;
	}
	// 828178A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828178A4: 419A001C  beq cr6, 0x828178c0
	if ctx.cr[6].eq {
	pc = 0x828178C0; continue 'dispatch;
	}
	// 828178A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828178AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828178B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828178B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828178B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828178BC: 4E800421  bctrl
	ctx.lr = 0x828178C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828178C0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828178C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828178C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828178CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828178D0: 816BF35C  lwz r11, -0xca4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3236 as u32) ) } as u64;
	// 828178D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828178D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828178DC: 4BAA8725  bl 0x822c0000
	ctx.lr = 0x828178E0;
	sub_822C0000(ctx, base);
	// 828178E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828178E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828178E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828178EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828178F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828178F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828178F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82817900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82817900 size=196
    let mut pc: u32 = 0x82817900;
    'dispatch: loop {
        match pc {
            0x82817900 => {
    //   block [0x82817900..0x828179C4)
	// 82817900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82817904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82817908: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281790C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82817910: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82817914: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82817918: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281791C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82817920: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82817924: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817928: 4BAA9011  bl 0x822c0938
	ctx.lr = 0x8281792C;
	sub_822C0938(ctx, base);
	// 8281792C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82817930: 41820028  beq 0x82817958
	if ctx.cr[0].eq {
	pc = 0x82817958; continue 'dispatch;
	}
	// 82817934: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82817938: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8281793C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82817940: 392B9590  addi r9, r11, -0x6a70
	ctx.r[9].s64 = ctx.r[11].s64 + -27248;
	// 82817944: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82817948: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281794C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82817950: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82817954: 48000008  b 0x8281795c
	pc = 0x8281795C; continue 'dispatch;
	// 82817958: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281795C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82817964: 409A0044  bne cr6, 0x828179a8
	if !ctx.cr[6].eq {
	pc = 0x828179A8; continue 'dispatch;
	}
	// 82817968: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281796C: 419A001C  beq cr6, 0x82817988
	if ctx.cr[6].eq {
	pc = 0x82817988; continue 'dispatch;
	}
	// 82817970: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82817974: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82817978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281797C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82817980: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82817984: 4E800421  bctrl
	ctx.lr = 0x82817988;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82817988: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281798C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82817990: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82817994: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82817998: 816BF35C  lwz r11, -0xca4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3236 as u32) ) } as u64;
	// 8281799C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828179A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828179A4: 4BAA865D  bl 0x822c0000
	ctx.lr = 0x828179A8;
	sub_822C0000(ctx, base);
	// 828179A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828179AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828179B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828179B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828179B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828179BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828179C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828179C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828179C8 size=196
    let mut pc: u32 = 0x828179C8;
    'dispatch: loop {
        match pc {
            0x828179C8 => {
    //   block [0x828179C8..0x82817A8C)
	// 828179C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828179CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828179D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828179D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828179D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828179DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828179E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828179E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828179E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828179EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828179F0: 4BAA8F49  bl 0x822c0938
	ctx.lr = 0x828179F4;
	sub_822C0938(ctx, base);
	// 828179F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828179F8: 41820028  beq 0x82817a20
	if ctx.cr[0].eq {
	pc = 0x82817A20; continue 'dispatch;
	}
	// 828179FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82817A00: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82817A04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82817A08: 392B95A4  addi r9, r11, -0x6a5c
	ctx.r[9].s64 = ctx.r[11].s64 + -27228;
	// 82817A0C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82817A10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82817A14: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82817A18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82817A1C: 48000008  b 0x82817a24
	pc = 0x82817A24; continue 'dispatch;
	// 82817A20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82817A24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817A28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82817A2C: 409A0044  bne cr6, 0x82817a70
	if !ctx.cr[6].eq {
	pc = 0x82817A70; continue 'dispatch;
	}
	// 82817A30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82817A34: 419A001C  beq cr6, 0x82817a50
	if ctx.cr[6].eq {
	pc = 0x82817A50; continue 'dispatch;
	}
	// 82817A38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82817A3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82817A40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82817A44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82817A48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82817A4C: 4E800421  bctrl
	ctx.lr = 0x82817A50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82817A50: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82817A54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82817A58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82817A5C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82817A60: 816BF35C  lwz r11, -0xca4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3236 as u32) ) } as u64;
	// 82817A64: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82817A68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82817A6C: 4BAA8595  bl 0x822c0000
	ctx.lr = 0x82817A70;
	sub_822C0000(ctx, base);
	// 82817A70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82817A74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82817A78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82817A7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82817A80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82817A84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82817A88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82817A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82817A90 size=196
    let mut pc: u32 = 0x82817A90;
    'dispatch: loop {
        match pc {
            0x82817A90 => {
    //   block [0x82817A90..0x82817B54)
	// 82817A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82817A94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82817A98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82817A9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82817AA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82817AA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82817AA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82817AAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82817AB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82817AB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817AB8: 4BAA8E81  bl 0x822c0938
	ctx.lr = 0x82817ABC;
	sub_822C0938(ctx, base);
	// 82817ABC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82817AC0: 41820028  beq 0x82817ae8
	if ctx.cr[0].eq {
	pc = 0x82817AE8; continue 'dispatch;
	}
	// 82817AC4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82817AC8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82817ACC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82817AD0: 392B95B8  addi r9, r11, -0x6a48
	ctx.r[9].s64 = ctx.r[11].s64 + -27208;
	// 82817AD4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82817AD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82817ADC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82817AE0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82817AE4: 48000008  b 0x82817aec
	pc = 0x82817AEC; continue 'dispatch;
	// 82817AE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82817AEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817AF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82817AF4: 409A0044  bne cr6, 0x82817b38
	if !ctx.cr[6].eq {
	pc = 0x82817B38; continue 'dispatch;
	}
	// 82817AF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82817AFC: 419A001C  beq cr6, 0x82817b18
	if ctx.cr[6].eq {
	pc = 0x82817B18; continue 'dispatch;
	}
	// 82817B00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82817B04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82817B08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82817B0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82817B10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82817B14: 4E800421  bctrl
	ctx.lr = 0x82817B18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82817B18: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82817B1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82817B20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82817B24: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82817B28: 816BF35C  lwz r11, -0xca4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3236 as u32) ) } as u64;
	// 82817B2C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82817B30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82817B34: 4BAA84CD  bl 0x822c0000
	ctx.lr = 0x82817B38;
	sub_822C0000(ctx, base);
	// 82817B38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82817B3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82817B40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82817B44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82817B48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82817B4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82817B50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82817B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82817B58 size=196
    let mut pc: u32 = 0x82817B58;
    'dispatch: loop {
        match pc {
            0x82817B58 => {
    //   block [0x82817B58..0x82817C1C)
	// 82817B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82817B5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82817B60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82817B64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82817B68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82817B6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82817B70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82817B74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82817B78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82817B7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817B80: 4BAA8DB9  bl 0x822c0938
	ctx.lr = 0x82817B84;
	sub_822C0938(ctx, base);
	// 82817B84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82817B88: 41820028  beq 0x82817bb0
	if ctx.cr[0].eq {
	pc = 0x82817BB0; continue 'dispatch;
	}
	// 82817B8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82817B90: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82817B94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82817B98: 392B95CC  addi r9, r11, -0x6a34
	ctx.r[9].s64 = ctx.r[11].s64 + -27188;
	// 82817B9C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82817BA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82817BA4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82817BA8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82817BAC: 48000008  b 0x82817bb4
	pc = 0x82817BB4; continue 'dispatch;
	// 82817BB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82817BB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817BB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82817BBC: 409A0044  bne cr6, 0x82817c00
	if !ctx.cr[6].eq {
	pc = 0x82817C00; continue 'dispatch;
	}
	// 82817BC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82817BC4: 419A001C  beq cr6, 0x82817be0
	if ctx.cr[6].eq {
	pc = 0x82817BE0; continue 'dispatch;
	}
	// 82817BC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82817BCC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82817BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82817BD4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82817BD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82817BDC: 4E800421  bctrl
	ctx.lr = 0x82817BE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82817BE0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82817BE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82817BE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82817BEC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82817BF0: 816BF35C  lwz r11, -0xca4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3236 as u32) ) } as u64;
	// 82817BF4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82817BF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82817BFC: 4BAA8405  bl 0x822c0000
	ctx.lr = 0x82817C00;
	sub_822C0000(ctx, base);
	// 82817C00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82817C04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82817C08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82817C0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82817C10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82817C14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82817C18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82817C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82817C20 size=196
    let mut pc: u32 = 0x82817C20;
    'dispatch: loop {
        match pc {
            0x82817C20 => {
    //   block [0x82817C20..0x82817CE4)
	// 82817C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82817C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82817C28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82817C2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82817C30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82817C34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82817C38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82817C3C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82817C40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82817C44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817C48: 4BAA8CF1  bl 0x822c0938
	ctx.lr = 0x82817C4C;
	sub_822C0938(ctx, base);
	// 82817C4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82817C50: 41820028  beq 0x82817c78
	if ctx.cr[0].eq {
	pc = 0x82817C78; continue 'dispatch;
	}
	// 82817C54: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82817C58: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82817C5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82817C60: 392B95E0  addi r9, r11, -0x6a20
	ctx.r[9].s64 = ctx.r[11].s64 + -27168;
	// 82817C64: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82817C68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82817C6C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82817C70: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82817C74: 48000008  b 0x82817c7c
	pc = 0x82817C7C; continue 'dispatch;
	// 82817C78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82817C7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817C80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82817C84: 409A0044  bne cr6, 0x82817cc8
	if !ctx.cr[6].eq {
	pc = 0x82817CC8; continue 'dispatch;
	}
	// 82817C88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82817C8C: 419A001C  beq cr6, 0x82817ca8
	if ctx.cr[6].eq {
	pc = 0x82817CA8; continue 'dispatch;
	}
	// 82817C90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82817C94: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82817C98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82817C9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82817CA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82817CA4: 4E800421  bctrl
	ctx.lr = 0x82817CA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82817CA8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82817CAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82817CB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82817CB4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82817CB8: 816BF35C  lwz r11, -0xca4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3236 as u32) ) } as u64;
	// 82817CBC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82817CC0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82817CC4: 4BAA833D  bl 0x822c0000
	ctx.lr = 0x82817CC8;
	sub_822C0000(ctx, base);
	// 82817CC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82817CCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82817CD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82817CD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82817CD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82817CDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82817CE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82817CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82817CE8 size=196
    let mut pc: u32 = 0x82817CE8;
    'dispatch: loop {
        match pc {
            0x82817CE8 => {
    //   block [0x82817CE8..0x82817DAC)
	// 82817CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82817CEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82817CF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82817CF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82817CF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82817CFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82817D00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82817D04: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82817D08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82817D0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817D10: 4BAA8C29  bl 0x822c0938
	ctx.lr = 0x82817D14;
	sub_822C0938(ctx, base);
	// 82817D14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82817D18: 41820028  beq 0x82817d40
	if ctx.cr[0].eq {
	pc = 0x82817D40; continue 'dispatch;
	}
	// 82817D1C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82817D20: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82817D24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82817D28: 392B95F4  addi r9, r11, -0x6a0c
	ctx.r[9].s64 = ctx.r[11].s64 + -27148;
	// 82817D2C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82817D30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82817D34: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82817D38: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82817D3C: 48000008  b 0x82817d44
	pc = 0x82817D44; continue 'dispatch;
	// 82817D40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82817D44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817D48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82817D4C: 409A0044  bne cr6, 0x82817d90
	if !ctx.cr[6].eq {
	pc = 0x82817D90; continue 'dispatch;
	}
	// 82817D50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82817D54: 419A001C  beq cr6, 0x82817d70
	if ctx.cr[6].eq {
	pc = 0x82817D70; continue 'dispatch;
	}
	// 82817D58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82817D5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82817D60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82817D64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82817D68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82817D6C: 4E800421  bctrl
	ctx.lr = 0x82817D70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82817D70: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82817D74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82817D78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82817D7C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82817D80: 816BF35C  lwz r11, -0xca4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3236 as u32) ) } as u64;
	// 82817D84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82817D88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82817D8C: 4BAA8275  bl 0x822c0000
	ctx.lr = 0x82817D90;
	sub_822C0000(ctx, base);
	// 82817D90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82817D94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82817D98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82817D9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82817DA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82817DA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82817DA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82817DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82817DB0 size=196
    let mut pc: u32 = 0x82817DB0;
    'dispatch: loop {
        match pc {
            0x82817DB0 => {
    //   block [0x82817DB0..0x82817E74)
	// 82817DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82817DB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82817DB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82817DBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82817DC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82817DC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82817DC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82817DCC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82817DD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82817DD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817DD8: 4BAA8B61  bl 0x822c0938
	ctx.lr = 0x82817DDC;
	sub_822C0938(ctx, base);
	// 82817DDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82817DE0: 41820028  beq 0x82817e08
	if ctx.cr[0].eq {
	pc = 0x82817E08; continue 'dispatch;
	}
	// 82817DE4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82817DE8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82817DEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82817DF0: 392B9608  addi r9, r11, -0x69f8
	ctx.r[9].s64 = ctx.r[11].s64 + -27128;
	// 82817DF4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82817DF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82817DFC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82817E00: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82817E04: 48000008  b 0x82817e0c
	pc = 0x82817E0C; continue 'dispatch;
	// 82817E08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82817E0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817E10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82817E14: 409A0044  bne cr6, 0x82817e58
	if !ctx.cr[6].eq {
	pc = 0x82817E58; continue 'dispatch;
	}
	// 82817E18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82817E1C: 419A001C  beq cr6, 0x82817e38
	if ctx.cr[6].eq {
	pc = 0x82817E38; continue 'dispatch;
	}
	// 82817E20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82817E24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82817E28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82817E2C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82817E30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82817E34: 4E800421  bctrl
	ctx.lr = 0x82817E38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82817E38: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82817E3C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82817E40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82817E44: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82817E48: 816BF35C  lwz r11, -0xca4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3236 as u32) ) } as u64;
	// 82817E4C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82817E50: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82817E54: 4BAA81AD  bl 0x822c0000
	ctx.lr = 0x82817E58;
	sub_822C0000(ctx, base);
	// 82817E58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82817E5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82817E60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82817E64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82817E68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82817E6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82817E70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82817E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82817E78 size=140
    let mut pc: u32 = 0x82817E78;
    'dispatch: loop {
        match pc {
            0x82817E78 => {
    //   block [0x82817E78..0x82817F04)
	// 82817E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82817E7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82817E80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82817E84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82817E88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82817E8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82817E90: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82817E94: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82817E98: 396B9684  addi r11, r11, -0x697c
	ctx.r[11].s64 = ctx.r[11].s64 + -27004;
	// 82817E9C: 394A9670  addi r10, r10, -0x6990
	ctx.r[10].s64 = ctx.r[10].s64 + -27024;
	// 82817EA0: 39299624  addi r9, r9, -0x69dc
	ctx.r[9].s64 = ctx.r[9].s64 + -27100;
	// 82817EA4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82817EA8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82817EAC: 387F024C  addi r3, r31, 0x24c
	ctx.r[3].s64 = ctx.r[31].s64 + 588;
	// 82817EB0: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 82817EB4: 485DB575  bl 0x82df3428
	ctx.lr = 0x82817EB8;
	sub_82DF3428(ctx, base);
	// 82817EB8: 807F0220  lwz r3, 0x220(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 82817EBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82817EC0: 419A0008  beq cr6, 0x82817ec8
	if ctx.cr[6].eq {
	pc = 0x82817EC8; continue 'dispatch;
	}
	// 82817EC4: 4BAA89CD  bl 0x822c0890
	ctx.lr = 0x82817EC8;
	sub_822C0890(ctx, base);
	// 82817EC8: 807F0218  lwz r3, 0x218(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) } as u64;
	// 82817ECC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82817ED0: 419A0008  beq cr6, 0x82817ed8
	if ctx.cr[6].eq {
	pc = 0x82817ED8; continue 'dispatch;
	}
	// 82817ED4: 4BAA89BD  bl 0x822c0890
	ctx.lr = 0x82817ED8;
	sub_822C0890(ctx, base);
	// 82817ED8: 807F0210  lwz r3, 0x210(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82817EDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82817EE0: 419A0008  beq cr6, 0x82817ee8
	if ctx.cr[6].eq {
	pc = 0x82817EE8; continue 'dispatch;
	}
	// 82817EE4: 4BAA89AD  bl 0x822c0890
	ctx.lr = 0x82817EE8;
	sub_822C0890(ctx, base);
	// 82817EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82817EEC: 4BFD2EDD  bl 0x827eadc8
	ctx.lr = 0x82817EF0;
	sub_827EADC8(ctx, base);
	// 82817EF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82817EF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82817EF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82817EFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82817F00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82817F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82817F08 size=8
    let mut pc: u32 = 0x82817F08;
    'dispatch: loop {
        match pc {
            0x82817F08 => {
    //   block [0x82817F08..0x82817F10)
	// 82817F08: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82817F0C: 4800018C  b 0x82818098
	sub_82818098(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82817F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82817F10 size=8
    let mut pc: u32 = 0x82817F10;
    'dispatch: loop {
        match pc {
            0x82817F10 => {
    //   block [0x82817F10..0x82817F18)
	// 82817F10: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 82817F14: 48000184  b 0x82818098
	sub_82818098(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82817F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82817F18 size=180
    let mut pc: u32 = 0x82817F18;
    'dispatch: loop {
        match pc {
            0x82817F18 => {
    //   block [0x82817F18..0x82817FCC)
	// 82817F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82817F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82817F20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82817F24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82817F28: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82817F2C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82817F30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82817F34: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82817F38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82817F3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82817F40: 38AB749C  addi r5, r11, 0x749c
	ctx.r[5].s64 = ctx.r[11].s64 + 29852;
	// 82817F44: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82817F48: 4BCFA231  bl 0x82512178
	ctx.lr = 0x82817F4C;
	sub_82512178(ctx, base);
	// 82817F4C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82817F50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82817F54: 419A0008  beq cr6, 0x82817f5c
	if ctx.cr[6].eq {
	pc = 0x82817F5C; continue 'dispatch;
	}
	// 82817F58: 4BAA8939  bl 0x822c0890
	ctx.lr = 0x82817F5C;
	sub_822C0890(ctx, base);
	// 82817F5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82817F60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82817F64: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82817F68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82817F6C: 4E800421  bctrl
	ctx.lr = 0x82817F70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82817F70: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82817F74: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 82817F78: C1A30008  lfs f13, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82817F7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82817F80: 388A7488  addi r4, r10, 0x7488
	ctx.r[4].s64 = ctx.r[10].s64 + 29832;
	// 82817F84: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82817F88: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82817F8C: 485DBA7D  bl 0x82df3a08
	ctx.lr = 0x82817F90;
	sub_82DF3A08(ctx, base);
	// 82817F90: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 82817F94: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82817F98: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82817F9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82817FA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82817FA4: 4BFD4255  bl 0x827ec1f8
	ctx.lr = 0x82817FA8;
	sub_827EC1F8(ctx, base);
	// 82817FA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82817FAC: 485DB47D  bl 0x82df3428
	ctx.lr = 0x82817FB0;
	sub_82DF3428(ctx, base);
	// 82817FB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82817FB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82817FB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82817FBC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82817FC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82817FC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82817FC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82817FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82817FD0 size=12
    let mut pc: u32 = 0x82817FD0;
    'dispatch: loop {
        match pc {
            0x82817FD0 => {
    //   block [0x82817FD0..0x82817FDC)
	// 82817FD0: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82817FD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82817FD8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82817FDC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82817FDC size=8
    let mut pc: u32 = 0x82817FDC;
    'dispatch: loop {
        match pc {
            0x82817FDC => {
    //   block [0x82817FDC..0x82817FE4)
	// 82817FDC: 4BAA88B4  b 0x822c0890
	sub_822C0890(ctx, base);
	return;
	// 82817FE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82817FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82817FE8 size=172
    let mut pc: u32 = 0x82817FE8;
    'dispatch: loop {
        match pc {
            0x82817FE8 => {
    //   block [0x82817FE8..0x82818094)
	// 82817FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82817FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82817FF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82817FF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82817FF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82817FFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82818000: 4BFD2FD9  bl 0x827eafd8
	ctx.lr = 0x82818004;
	sub_827EAFD8(ctx, base);
	// 82818004: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82818008: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8281800C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82818010: 396B9684  addi r11, r11, -0x697c
	ctx.r[11].s64 = ctx.r[11].s64 + -27004;
	// 82818014: 394A9670  addi r10, r10, -0x6990
	ctx.r[10].s64 = ctx.r[10].s64 + -27024;
	// 82818018: 39299624  addi r9, r9, -0x69dc
	ctx.r[9].s64 = ctx.r[9].s64 + -27100;
	// 8281801C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82818020: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82818024: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82818028: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 8281802C: 387F023C  addi r3, r31, 0x23c
	ctx.r[3].s64 = ctx.r[31].s64 + 572;
	// 82818030: 93DF020C  stw r30, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[30].u32 ) };
	// 82818034: 93DF0210  stw r30, 0x210(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), ctx.r[30].u32 ) };
	// 82818038: 93DF0214  stw r30, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[30].u32 ) };
	// 8281803C: 93DF0218  stw r30, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[30].u32 ) };
	// 82818040: 93DF021C  stw r30, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[30].u32 ) };
	// 82818044: 93DF0220  stw r30, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[30].u32 ) };
	// 82818048: 93DF0224  stw r30, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[30].u32 ) };
	// 8281804C: 93DF0228  stw r30, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[30].u32 ) };
	// 82818050: 93DF022C  stw r30, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[30].u32 ) };
	// 82818054: 93DF0230  stw r30, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[30].u32 ) };
	// 82818058: 93DF0234  stw r30, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[30].u32 ) };
	// 8281805C: 93DF0238  stw r30, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[30].u32 ) };
	// 82818060: 4BFDDED9  bl 0x827f5f38
	ctx.lr = 0x82818064;
	sub_827F5F38(ctx, base);
	// 82818064: 387F024C  addi r3, r31, 0x24c
	ctx.r[3].s64 = ctx.r[31].s64 + 588;
	// 82818068: 485DB089  bl 0x82df30f0
	ctx.lr = 0x8281806C;
	sub_82DF30F0(ctx, base);
	// 8281806C: 9BDF0250  stb r30, 0x250(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[30].u8 ) };
	// 82818070: 9BDF0251  stb r30, 0x251(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(593 as u32), ctx.r[30].u8 ) };
	// 82818074: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82818078: 9BDF0252  stb r30, 0x252(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(594 as u32), ctx.r[30].u8 ) };
	// 8281807C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82818080: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82818084: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82818088: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281808C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82818090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82818098 size=76
    let mut pc: u32 = 0x82818098;
    'dispatch: loop {
        match pc {
            0x82818098 => {
    //   block [0x82818098..0x828180E4)
	// 82818098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281809C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828180A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828180A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828180A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828180AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828180B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828180B4: 4BFFFDC5  bl 0x82817e78
	ctx.lr = 0x828180B8;
	sub_82817E78(ctx, base);
	// 828180B8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828180BC: 4182000C  beq 0x828180c8
	if ctx.cr[0].eq {
	pc = 0x828180C8; continue 'dispatch;
	}
	// 828180C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828180C4: 485DA315  bl 0x82df23d8
	ctx.lr = 0x828180C8;
	sub_82DF23D8(ctx, base);
	// 828180C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828180CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828180D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828180D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828180D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828180DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828180E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828180E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828180E8 size=172
    let mut pc: u32 = 0x828180E8;
    'dispatch: loop {
        match pc {
            0x828180E8 => {
    //   block [0x828180E8..0x82818194)
	// 828180E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828180EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828180F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828180F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828180F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828180FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82818100: 4BFD2C69  bl 0x827ead68
	ctx.lr = 0x82818104;
	sub_827EAD68(ctx, base);
	// 82818104: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82818108: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8281810C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82818110: 396B9684  addi r11, r11, -0x697c
	ctx.r[11].s64 = ctx.r[11].s64 + -27004;
	// 82818114: 394A9670  addi r10, r10, -0x6990
	ctx.r[10].s64 = ctx.r[10].s64 + -27024;
	// 82818118: 39299624  addi r9, r9, -0x69dc
	ctx.r[9].s64 = ctx.r[9].s64 + -27100;
	// 8281811C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82818120: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82818124: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82818128: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 8281812C: 387F023C  addi r3, r31, 0x23c
	ctx.r[3].s64 = ctx.r[31].s64 + 572;
	// 82818130: 93DF020C  stw r30, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[30].u32 ) };
	// 82818134: 93DF0210  stw r30, 0x210(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), ctx.r[30].u32 ) };
	// 82818138: 93DF0214  stw r30, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[30].u32 ) };
	// 8281813C: 93DF0218  stw r30, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[30].u32 ) };
	// 82818140: 93DF021C  stw r30, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[30].u32 ) };
	// 82818144: 93DF0220  stw r30, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[30].u32 ) };
	// 82818148: 93DF0224  stw r30, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[30].u32 ) };
	// 8281814C: 93DF0228  stw r30, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[30].u32 ) };
	// 82818150: 93DF022C  stw r30, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[30].u32 ) };
	// 82818154: 93DF0230  stw r30, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[30].u32 ) };
	// 82818158: 93DF0234  stw r30, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[30].u32 ) };
	// 8281815C: 93DF0238  stw r30, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[30].u32 ) };
	// 82818160: 4BFDDDD9  bl 0x827f5f38
	ctx.lr = 0x82818164;
	sub_827F5F38(ctx, base);
	// 82818164: 387F024C  addi r3, r31, 0x24c
	ctx.r[3].s64 = ctx.r[31].s64 + 588;
	// 82818168: 485DAF89  bl 0x82df30f0
	ctx.lr = 0x8281816C;
	sub_82DF30F0(ctx, base);
	// 8281816C: 9BDF0250  stb r30, 0x250(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[30].u8 ) };
	// 82818170: 9BDF0251  stb r30, 0x251(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(593 as u32), ctx.r[30].u8 ) };
	// 82818174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82818178: 9BDF0252  stb r30, 0x252(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(594 as u32), ctx.r[30].u8 ) };
	// 8281817C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82818180: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82818184: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82818188: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281818C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82818190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82818198 size=148
    let mut pc: u32 = 0x82818198;
    'dispatch: loop {
        match pc {
            0x82818198 => {
    //   block [0x82818198..0x8281822C)
	// 82818198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281819C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828181A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828181A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828181A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828181AC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828181B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828181B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828181B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828181BC: 388B972C  addi r4, r11, -0x68d4
	ctx.r[4].s64 = ctx.r[11].s64 + -26836;
	// 828181C0: 485DB849  bl 0x82df3a08
	ctx.lr = 0x828181C4;
	sub_82DF3A08(ctx, base);
	// 828181C4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828181C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828181CC: 388B9718  addi r4, r11, -0x68e8
	ctx.r[4].s64 = ctx.r[11].s64 + -26856;
	// 828181D0: 485DB839  bl 0x82df3a08
	ctx.lr = 0x828181D4;
	sub_82DF3A08(ctx, base);
	// 828181D4: 38BF0251  addi r5, r31, 0x251
	ctx.r[5].s64 = ctx.r[31].s64 + 593;
	// 828181D8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828181DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828181E0: 4BD8AE71  bl 0x825a3050
	ctx.lr = 0x828181E4;
	sub_825A3050(ctx, base);
	// 828181E4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828181E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828181EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828181F0: 4BD89F99  bl 0x825a2188
	ctx.lr = 0x828181F4;
	sub_825A2188(ctx, base);
	// 828181F4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828181F8: 485DB231  bl 0x82df3428
	ctx.lr = 0x828181FC;
	sub_82DF3428(ctx, base);
	// 828181FC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82818200: 4BAB0AB9  bl 0x822c8cb8
	ctx.lr = 0x82818204;
	sub_822C8CB8(ctx, base);
	// 82818204: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82818208: 485DB221  bl 0x82df3428
	ctx.lr = 0x8281820C;
	sub_82DF3428(ctx, base);
	// 8281820C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82818210: 485DB219  bl 0x82df3428
	ctx.lr = 0x82818214;
	sub_82DF3428(ctx, base);
	// 82818214: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82818218: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281821C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82818220: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82818224: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82818228: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82818230 size=112
    let mut pc: u32 = 0x82818230;
    'dispatch: loop {
        match pc {
            0x82818230 => {
    //   block [0x82818230..0x828182A0)
	// 82818230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82818234: 4898FF39  bl 0x831a816c
	ctx.lr = 0x82818238;
	sub_831A8130(ctx, base);
	// 82818238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281823C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82818240: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82818244: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82818248: 388B9750  addi r4, r11, -0x68b0
	ctx.r[4].s64 = ctx.r[11].s64 + -26800;
	// 8281824C: 38A0013B  li r5, 0x13b
	ctx.r[5].s64 = 315;
	// 82818250: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82818254: 4BAA8185  bl 0x822c03d8
	ctx.lr = 0x82818258;
	sub_822C03D8(ctx, base);
	// 82818258: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281825C: 41820010  beq 0x8281826c
	if ctx.cr[0].eq {
	pc = 0x8281826C; continue 'dispatch;
	}
	// 82818260: 4BFD2A51  bl 0x827eacb0
	ctx.lr = 0x82818264;
	sub_827EACB0(ctx, base);
	// 82818264: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82818268: 48000008  b 0x82818270
	pc = 0x82818270; continue 'dispatch;
	// 8281826C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82818270: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82818274: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82818278: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281827C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818280: 4BFE2AF9  bl 0x827fad78
	ctx.lr = 0x82818284;
	sub_827FAD78(ctx, base);
	// 82818284: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82818288: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281828C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818290: 4BAA7D71  bl 0x822c0000
	ctx.lr = 0x82818294;
	sub_822C0000(ctx, base);
	// 82818294: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82818298: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281829C: 4898FF20  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828182A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828182A0 size=360
    let mut pc: u32 = 0x828182A0;
    'dispatch: loop {
        match pc {
            0x828182A0 => {
    //   block [0x828182A0..0x82818408)
	// 828182A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828182A4: 4898FEC9  bl 0x831a816c
	ctx.lr = 0x828182A8;
	sub_831A8130(ctx, base);
	// 828182A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828182AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828182B0: 4BFD2C21  bl 0x827eaed0
	ctx.lr = 0x828182B4;
	sub_827EAED0(ctx, base);
	// 828182B4: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 828182B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828182BC: 409A00A8  bne cr6, 0x82818364
	if !ctx.cr[6].eq {
	pc = 0x82818364; continue 'dispatch;
	}
	// 828182C0: 3BDF024C  addi r30, r31, 0x24c
	ctx.r[30].s64 = ctx.r[31].s64 + 588;
	// 828182C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828182C8: 485DAEE9  bl 0x82df31b0
	ctx.lr = 0x828182CC;
	sub_82DF31B0(ctx, base);
	// 828182CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828182D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828182D4: 485DAEDD  bl 0x82df31b0
	ctx.lr = 0x828182D8;
	sub_82DF31B0(ctx, base);
	// 828182D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828182DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828182E0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828182E4: 4BFEE64D  bl 0x82806930
	ctx.lr = 0x828182E8;
	sub_82806930(ctx, base);
	// 828182E8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828182EC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828182F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828182F4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828182F8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828182FC: 419A0024  beq cr6, 0x82818320
	if ctx.cr[6].eq {
	pc = 0x82818320; continue 'dispatch;
	}
	// 82818300: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82818304: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82818308: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281830C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82818310: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82818314: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82818318: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281831C: 4082FFE8  bne 0x82818304
	if !ctx.cr[0].eq {
	pc = 0x82818304; continue 'dispatch;
	}
	// 82818320: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82818324: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82818328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281832C: 4BFD4D45  bl 0x827ed070
	ctx.lr = 0x82818330;
	sub_827ED070(ctx, base);
	// 82818330: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82818334: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82818338: 419A0008  beq cr6, 0x82818340
	if ctx.cr[6].eq {
	pc = 0x82818340; continue 'dispatch;
	}
	// 8281833C: 4BAA8555  bl 0x822c0890
	ctx.lr = 0x82818340;
	sub_822C0890(ctx, base);
	// 82818340: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82818344: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82818348: 487F0C71  bl 0x83008fb8
	ctx.lr = 0x8281834C;
	sub_83008FB8(ctx, base);
	// 8281834C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82818350: 907F0224  stw r3, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[3].u32 ) };
	// 82818354: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82818358: 419A000C  beq cr6, 0x82818364
	if ctx.cr[6].eq {
	pc = 0x82818364; continue 'dispatch;
	}
	// 8281835C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82818360: 4BAA8531  bl 0x822c0890
	ctx.lr = 0x82818364;
	sub_822C0890(ctx, base);
	// 82818364: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 82818368: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281836C: 409A0094  bne cr6, 0x82818400
	if !ctx.cr[6].eq {
	pc = 0x82818400; continue 'dispatch;
	}
	// 82818370: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82818374: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82818378: 388B9534  addi r4, r11, -0x6acc
	ctx.r[4].s64 = ctx.r[11].s64 + -27340;
	// 8281837C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82818380: 4BFEE5B1  bl 0x82806930
	ctx.lr = 0x82818384;
	sub_82806930(ctx, base);
	// 82818384: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82818388: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8281838C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82818390: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82818394: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82818398: 419A0024  beq cr6, 0x828183bc
	if ctx.cr[6].eq {
	pc = 0x828183BC; continue 'dispatch;
	}
	// 8281839C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828183A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828183A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828183A8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828183AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828183B0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828183B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828183B8: 4082FFE8  bne 0x828183a0
	if !ctx.cr[0].eq {
	pc = 0x828183A0; continue 'dispatch;
	}
	// 828183BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828183C0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828183C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828183C8: 4BFD4CA9  bl 0x827ed070
	ctx.lr = 0x828183CC;
	sub_827ED070(ctx, base);
	// 828183CC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828183D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828183D4: 419A0008  beq cr6, 0x828183dc
	if ctx.cr[6].eq {
	pc = 0x828183DC; continue 'dispatch;
	}
	// 828183D8: 4BAA84B9  bl 0x822c0890
	ctx.lr = 0x828183DC;
	sub_822C0890(ctx, base);
	// 828183DC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828183E0: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 828183E4: 487F0BD5  bl 0x83008fb8
	ctx.lr = 0x828183E8;
	sub_83008FB8(ctx, base);
	// 828183E8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828183EC: 907F0228  stw r3, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[3].u32 ) };
	// 828183F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828183F4: 419A000C  beq cr6, 0x82818400
	if ctx.cr[6].eq {
	pc = 0x82818400; continue 'dispatch;
	}
	// 828183F8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828183FC: 4BAA8495  bl 0x822c0890
	ctx.lr = 0x82818400;
	sub_822C0890(ctx, base);
	// 82818400: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82818404: 4898FDB8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82818408 size=104
    let mut pc: u32 = 0x82818408;
    'dispatch: loop {
        match pc {
            0x82818408 => {
    //   block [0x82818408..0x82818470)
	// 82818408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281840C: 4898FD61  bl 0x831a816c
	ctx.lr = 0x82818410;
	sub_831A8130(ctx, base);
	// 82818410: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82818414: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82818418: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8281841C: 3BFE021C  addi r31, r30, 0x21c
	ctx.r[31].s64 = ctx.r[30].s64 + 540;
	// 82818420: 807E021C  lwz r3, 0x21c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(540 as u32) ) } as u64;
	// 82818424: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82818428: 419A0008  beq cr6, 0x82818430
	if ctx.cr[6].eq {
	pc = 0x82818430; continue 'dispatch;
	}
	// 8281842C: 4832E29D  bl 0x82b466c8
	ctx.lr = 0x82818430;
	sub_82B466C8(ctx, base);
	// 82818430: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82818434: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82818438: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281843C: 4BCF9D3D  bl 0x82512178
	ctx.lr = 0x82818440;
	sub_82512178(ctx, base);
	// 82818440: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82818444: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82818448: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8281844C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82818450: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82818454: 4BAAC00D  bl 0x822c4460
	ctx.lr = 0x82818458;
	sub_822C4460(ctx, base);
	// 82818458: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8281845C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82818460: 419A0008  beq cr6, 0x82818468
	if ctx.cr[6].eq {
	pc = 0x82818468; continue 'dispatch;
	}
	// 82818464: 4BAA842D  bl 0x822c0890
	ctx.lr = 0x82818468;
	sub_822C0890(ctx, base);
	// 82818468: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8281846C: 4898FD50  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82818470 size=192
    let mut pc: u32 = 0x82818470;
    'dispatch: loop {
        match pc {
            0x82818470 => {
    //   block [0x82818470..0x82818530)
	// 82818470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82818474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82818478: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281847C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82818480: 4BFD3CE1  bl 0x827ec160
	ctx.lr = 0x82818484;
	sub_827EC160(ctx, base);
	// 82818484: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82818488: 41820094  beq 0x8281851c
	if ctx.cr[0].eq {
	pc = 0x8281851C; continue 'dispatch;
	}
	// 8281848C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82818490: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82818494: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 82818498: 485DB571  bl 0x82df3a08
	ctx.lr = 0x8281849C;
	sub_82DF3A08(ctx, base);
	// 8281849C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828184A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828184A4: 4804B31D  bl 0x828637c0
	ctx.lr = 0x828184A8;
	sub_828637C0(ctx, base);
	// 828184A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828184AC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828184B0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828184B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828184B8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828184BC: 419A0024  beq cr6, 0x828184e0
	if ctx.cr[6].eq {
	pc = 0x828184E0; continue 'dispatch;
	}
	// 828184C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828184C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828184C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828184CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828184D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828184D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828184D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828184DC: 4082FFE8  bne 0x828184c4
	if !ctx.cr[0].eq {
	pc = 0x828184C4; continue 'dispatch;
	}
	// 828184E0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828184E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828184E8: 4BFD6789  bl 0x827eec70
	ctx.lr = 0x828184EC;
	sub_827EEC70(ctx, base);
	// 828184EC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828184F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828184F4: 419A0008  beq cr6, 0x828184fc
	if ctx.cr[6].eq {
	pc = 0x828184FC; continue 'dispatch;
	}
	// 828184F8: 4BAA8399  bl 0x822c0890
	ctx.lr = 0x828184FC;
	sub_822C0890(ctx, base);
	// 828184FC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82818500: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82818504: 419A0008  beq cr6, 0x8281850c
	if ctx.cr[6].eq {
	pc = 0x8281850C; continue 'dispatch;
	}
	// 82818508: 4BAA8389  bl 0x822c0890
	ctx.lr = 0x8281850C;
	sub_822C0890(ctx, base);
	// 8281850C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82818510: 485DAF19  bl 0x82df3428
	ctx.lr = 0x82818514;
	sub_82DF3428(ctx, base);
	// 82818514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82818518: 4BFD58A1  bl 0x827eddb8
	ctx.lr = 0x8281851C;
	sub_827EDDB8(ctx, base);
	// 8281851C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82818520: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82818524: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82818528: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281852C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82818530 size=120
    let mut pc: u32 = 0x82818530;
    'dispatch: loop {
        match pc {
            0x82818530 => {
    //   block [0x82818530..0x828185A8)
	// 82818530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82818534: 4898FC39  bl 0x831a816c
	ctx.lr = 0x82818538;
	sub_831A8130(ctx, base);
	// 82818538: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281853C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82818540: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82818544: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82818548: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281854C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82818550: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82818554: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82818558: 485D9E91  bl 0x82df23e8
	ctx.lr = 0x8281855C;
	sub_82DF23E8(ctx, base);
	// 8281855C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82818560: 41820014  beq 0x82818574
	if ctx.cr[0].eq {
	pc = 0x82818574; continue 'dispatch;
	}
	// 82818564: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82818568: 4BFDE1B1  bl 0x827f6718
	ctx.lr = 0x8281856C;
	sub_827F6718(ctx, base);
	// 8281856C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82818570: 48000008  b 0x82818578
	pc = 0x82818578; continue 'dispatch;
	// 82818574: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82818578: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8281857C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82818580: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82818584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818588: 4BFFF1E9  bl 0x82817770
	ctx.lr = 0x8281858C;
	sub_82817770(ctx, base);
	// 8281858C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82818590: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82818594: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818598: 4BAA7A69  bl 0x822c0000
	ctx.lr = 0x8281859C;
	sub_822C0000(ctx, base);
	// 8281859C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828185A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828185A4: 4898FC18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828185A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828185A8 size=120
    let mut pc: u32 = 0x828185A8;
    'dispatch: loop {
        match pc {
            0x828185A8 => {
    //   block [0x828185A8..0x82818620)
	// 828185A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828185AC: 4898FBC1  bl 0x831a816c
	ctx.lr = 0x828185B0;
	sub_831A8130(ctx, base);
	// 828185B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828185B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828185B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828185BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828185C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828185C4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828185C8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828185CC: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828185D0: 485D9E19  bl 0x82df23e8
	ctx.lr = 0x828185D4;
	sub_82DF23E8(ctx, base);
	// 828185D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828185D8: 41820014  beq 0x828185ec
	if ctx.cr[0].eq {
	pc = 0x828185EC; continue 'dispatch;
	}
	// 828185DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828185E0: 48002939  bl 0x8281af18
	ctx.lr = 0x828185E4;
	sub_8281AF18(ctx, base);
	// 828185E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828185E8: 48000008  b 0x828185f0
	pc = 0x828185F0; continue 'dispatch;
	// 828185EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828185F0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828185F4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828185F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828185FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818600: 4BFFF239  bl 0x82817838
	ctx.lr = 0x82818604;
	sub_82817838(ctx, base);
	// 82818604: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82818608: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281860C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818610: 4BAA79F1  bl 0x822c0000
	ctx.lr = 0x82818614;
	sub_822C0000(ctx, base);
	// 82818614: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82818618: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281861C: 4898FBA0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82818620 size=112
    let mut pc: u32 = 0x82818620;
    'dispatch: loop {
        match pc {
            0x82818620 => {
    //   block [0x82818620..0x82818690)
	// 82818620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82818624: 4898FB49  bl 0x831a816c
	ctx.lr = 0x82818628;
	sub_831A8130(ctx, base);
	// 82818628: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281862C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82818630: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82818634: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82818638: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8281863C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82818640: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82818644: 485D9DA5  bl 0x82df23e8
	ctx.lr = 0x82818648;
	sub_82DF23E8(ctx, base);
	// 82818648: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281864C: 41820010  beq 0x8281865c
	if ctx.cr[0].eq {
	pc = 0x8281865C; continue 'dispatch;
	}
	// 82818650: 48002831  bl 0x8281ae80
	ctx.lr = 0x82818654;
	sub_8281AE80(ctx, base);
	// 82818654: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82818658: 48000008  b 0x82818660
	pc = 0x82818660; continue 'dispatch;
	// 8281865C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82818660: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82818664: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82818668: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281866C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818670: 4BFFF291  bl 0x82817900
	ctx.lr = 0x82818674;
	sub_82817900(ctx, base);
	// 82818674: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82818678: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281867C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818680: 4BAA7981  bl 0x822c0000
	ctx.lr = 0x82818684;
	sub_822C0000(ctx, base);
	// 82818684: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82818688: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281868C: 4898FB30  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82818690 size=112
    let mut pc: u32 = 0x82818690;
    'dispatch: loop {
        match pc {
            0x82818690 => {
    //   block [0x82818690..0x82818700)
	// 82818690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82818694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82818698: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281869C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828186A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828186A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828186A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828186AC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828186B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828186B4: 4BFFF315  bl 0x828179c8
	ctx.lr = 0x828186B8;
	sub_828179C8(ctx, base);
	// 828186B8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828186BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828186C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828186C4: 4BAA793D  bl 0x822c0000
	ctx.lr = 0x828186C8;
	sub_822C0000(ctx, base);
	// 828186C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828186CC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828186D0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828186D4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828186D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828186DC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828186E0: 419A0008  beq cr6, 0x828186e8
	if ctx.cr[6].eq {
	pc = 0x828186E8; continue 'dispatch;
	}
	// 828186E4: 4BAA81AD  bl 0x822c0890
	ctx.lr = 0x828186E8;
	sub_822C0890(ctx, base);
	// 828186E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828186EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828186F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828186F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828186F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828186FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82818700 size=120
    let mut pc: u32 = 0x82818700;
    'dispatch: loop {
        match pc {
            0x82818700 => {
    //   block [0x82818700..0x82818778)
	// 82818700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82818704: 4898FA69  bl 0x831a816c
	ctx.lr = 0x82818708;
	sub_831A8130(ctx, base);
	// 82818708: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281870C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82818710: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82818714: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82818718: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281871C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82818720: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82818724: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82818728: 485D9CC1  bl 0x82df23e8
	ctx.lr = 0x8281872C;
	sub_82DF23E8(ctx, base);
	// 8281872C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82818730: 41820014  beq 0x82818744
	if ctx.cr[0].eq {
	pc = 0x82818744; continue 'dispatch;
	}
	// 82818734: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82818738: 4BFDE039  bl 0x827f6770
	ctx.lr = 0x8281873C;
	sub_827F6770(ctx, base);
	// 8281873C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82818740: 48000008  b 0x82818748
	pc = 0x82818748; continue 'dispatch;
	// 82818744: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82818748: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8281874C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82818750: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82818754: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818758: 4BFFF339  bl 0x82817a90
	ctx.lr = 0x8281875C;
	sub_82817A90(ctx, base);
	// 8281875C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82818760: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82818764: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818768: 4BAA7899  bl 0x822c0000
	ctx.lr = 0x8281876C;
	sub_822C0000(ctx, base);
	// 8281876C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82818770: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82818774: 4898FA48  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82818778 size=124
    let mut pc: u32 = 0x82818778;
    'dispatch: loop {
        match pc {
            0x82818778 => {
    //   block [0x82818778..0x828187F4)
	// 82818778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281877C: 4898F9F1  bl 0x831a816c
	ctx.lr = 0x82818780;
	sub_831A8130(ctx, base);
	// 82818780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82818784: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82818788: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8281878C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82818790: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82818794: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82818798: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8281879C: 485D9C4D  bl 0x82df23e8
	ctx.lr = 0x828187A0;
	sub_82DF23E8(ctx, base);
	// 828187A0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828187A4: 4182001C  beq 0x828187c0
	if ctx.cr[0].eq {
	pc = 0x828187C0; continue 'dispatch;
	}
	// 828187A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828187AC: 48640EF5  bl 0x82e596a0
	ctx.lr = 0x828187B0;
	sub_82E596A0(ctx, base);
	// 828187B0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828187B4: 396B961C  addi r11, r11, -0x69e4
	ctx.r[11].s64 = ctx.r[11].s64 + -27108;
	// 828187B8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828187BC: 48000008  b 0x828187c4
	pc = 0x828187C4; continue 'dispatch;
	// 828187C0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828187C4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828187C8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828187CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828187D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828187D4: 4BFFF385  bl 0x82817b58
	ctx.lr = 0x828187D8;
	sub_82817B58(ctx, base);
	// 828187D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828187DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828187E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828187E4: 4BAA781D  bl 0x822c0000
	ctx.lr = 0x828187E8;
	sub_822C0000(ctx, base);
	// 828187E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828187EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828187F0: 4898F9CC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828187F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828187F8 size=120
    let mut pc: u32 = 0x828187F8;
    'dispatch: loop {
        match pc {
            0x828187F8 => {
    //   block [0x828187F8..0x82818870)
	// 828187F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828187FC: 4898F971  bl 0x831a816c
	ctx.lr = 0x82818800;
	sub_831A8130(ctx, base);
	// 82818800: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82818804: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82818808: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8281880C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82818810: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82818814: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82818818: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8281881C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82818820: 485D9BC9  bl 0x82df23e8
	ctx.lr = 0x82818824;
	sub_82DF23E8(ctx, base);
	// 82818824: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82818828: 41820014  beq 0x8281883c
	if ctx.cr[0].eq {
	pc = 0x8281883C; continue 'dispatch;
	}
	// 8281882C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82818830: 48002691  bl 0x8281aec0
	ctx.lr = 0x82818834;
	sub_8281AEC0(ctx, base);
	// 82818834: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82818838: 48000008  b 0x82818840
	pc = 0x82818840; continue 'dispatch;
	// 8281883C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82818840: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82818844: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82818848: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281884C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818850: 4BFFF3D1  bl 0x82817c20
	ctx.lr = 0x82818854;
	sub_82817C20(ctx, base);
	// 82818854: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82818858: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281885C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818860: 4BAA77A1  bl 0x822c0000
	ctx.lr = 0x82818864;
	sub_822C0000(ctx, base);
	// 82818864: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82818868: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281886C: 4898F950  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82818870 size=120
    let mut pc: u32 = 0x82818870;
    'dispatch: loop {
        match pc {
            0x82818870 => {
    //   block [0x82818870..0x828188E8)
	// 82818870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82818874: 4898F8F9  bl 0x831a816c
	ctx.lr = 0x82818878;
	sub_831A8130(ctx, base);
	// 82818878: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281887C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82818880: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82818884: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82818888: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281888C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82818890: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82818894: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82818898: 485D9B51  bl 0x82df23e8
	ctx.lr = 0x8281889C;
	sub_82DF23E8(ctx, base);
	// 8281889C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828188A0: 41820014  beq 0x828188b4
	if ctx.cr[0].eq {
	pc = 0x828188B4; continue 'dispatch;
	}
	// 828188A4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828188A8: 4833F161  bl 0x82b57a08
	ctx.lr = 0x828188AC;
	sub_82B57A08(ctx, base);
	// 828188AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828188B0: 48000008  b 0x828188b8
	pc = 0x828188B8; continue 'dispatch;
	// 828188B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828188B8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828188BC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828188C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828188C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828188C8: 4BFFF421  bl 0x82817ce8
	ctx.lr = 0x828188CC;
	sub_82817CE8(ctx, base);
	// 828188CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828188D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828188D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828188D8: 4BAA7729  bl 0x822c0000
	ctx.lr = 0x828188DC;
	sub_822C0000(ctx, base);
	// 828188DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828188E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828188E4: 4898F8D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828188E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828188E8 size=128
    let mut pc: u32 = 0x828188E8;
    'dispatch: loop {
        match pc {
            0x828188E8 => {
    //   block [0x828188E8..0x82818968)
	// 828188E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828188EC: 4898F881  bl 0x831a816c
	ctx.lr = 0x828188F0;
	sub_831A8130(ctx, base);
	// 828188F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828188F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828188F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828188FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82818900: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82818904: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82818908: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8281890C: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82818910: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82818914: 485D9AD5  bl 0x82df23e8
	ctx.lr = 0x82818918;
	sub_82DF23E8(ctx, base);
	// 82818918: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281891C: 41820018  beq 0x82818934
	if ctx.cr[0].eq {
	pc = 0x82818934; continue 'dispatch;
	}
	// 82818920: 88BE0000  lbz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82818924: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82818928: 4833A0B1  bl 0x82b529d8
	ctx.lr = 0x8281892C;
	sub_82B529D8(ctx, base);
	// 8281892C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82818930: 48000008  b 0x82818938
	pc = 0x82818938; continue 'dispatch;
	// 82818934: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82818938: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8281893C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82818940: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82818944: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818948: 4BFFF469  bl 0x82817db0
	ctx.lr = 0x8281894C;
	sub_82817DB0(ctx, base);
	// 8281894C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82818950: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82818954: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818958: 4BAA76A9  bl 0x822c0000
	ctx.lr = 0x8281895C;
	sub_822C0000(ctx, base);
	// 8281895C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82818960: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82818964: 4898F858  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82818968 size=244
    let mut pc: u32 = 0x82818968;
    'dispatch: loop {
        match pc {
            0x82818968 => {
    //   block [0x82818968..0x82818A5C)
	// 82818968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281896C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82818970: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82818974: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82818978: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281897C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82818980: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82818984: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82818988: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8281898C: 388B97EC  addi r4, r11, -0x6814
	ctx.r[4].s64 = ctx.r[11].s64 + -26644;
	// 82818990: 485DB079  bl 0x82df3a08
	ctx.lr = 0x82818994;
	sub_82DF3A08(ctx, base);
	// 82818994: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82818998: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281899C: 388B97D8  addi r4, r11, -0x6828
	ctx.r[4].s64 = ctx.r[11].s64 + -26664;
	// 828189A0: 485DB069  bl 0x82df3a08
	ctx.lr = 0x828189A4;
	sub_82DF3A08(ctx, base);
	// 828189A4: 38BF004A  addi r5, r31, 0x4a
	ctx.r[5].s64 = ctx.r[31].s64 + 74;
	// 828189A8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828189AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828189B0: 4BD8A6A1  bl 0x825a3050
	ctx.lr = 0x828189B4;
	sub_825A3050(ctx, base);
	// 828189B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828189B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828189BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828189C0: 4BD897C9  bl 0x825a2188
	ctx.lr = 0x828189C4;
	sub_825A2188(ctx, base);
	// 828189C4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828189C8: 485DAA61  bl 0x82df3428
	ctx.lr = 0x828189CC;
	sub_82DF3428(ctx, base);
	// 828189CC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828189D0: 4BAB02E9  bl 0x822c8cb8
	ctx.lr = 0x828189D4;
	sub_822C8CB8(ctx, base);
	// 828189D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828189D8: 485DAA51  bl 0x82df3428
	ctx.lr = 0x828189DC;
	sub_82DF3428(ctx, base);
	// 828189DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828189E0: 485DAA49  bl 0x82df3428
	ctx.lr = 0x828189E4;
	sub_82DF3428(ctx, base);
	// 828189E4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828189E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828189EC: 388B97B0  addi r4, r11, -0x6850
	ctx.r[4].s64 = ctx.r[11].s64 + -26704;
	// 828189F0: 485DB019  bl 0x82df3a08
	ctx.lr = 0x828189F4;
	sub_82DF3A08(ctx, base);
	// 828189F4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828189F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828189FC: 388B979C  addi r4, r11, -0x6864
	ctx.r[4].s64 = ctx.r[11].s64 + -26724;
	// 82818A00: 485DB009  bl 0x82df3a08
	ctx.lr = 0x82818A04;
	sub_82DF3A08(ctx, base);
	// 82818A04: 38BF0048  addi r5, r31, 0x48
	ctx.r[5].s64 = ctx.r[31].s64 + 72;
	// 82818A08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82818A0C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82818A10: 4BD8A641  bl 0x825a3050
	ctx.lr = 0x82818A14;
	sub_825A3050(ctx, base);
	// 82818A14: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82818A18: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82818A1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818A20: 4BD89769  bl 0x825a2188
	ctx.lr = 0x82818A24;
	sub_825A2188(ctx, base);
	// 82818A24: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82818A28: 485DAA01  bl 0x82df3428
	ctx.lr = 0x82818A2C;
	sub_82DF3428(ctx, base);
	// 82818A2C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82818A30: 4BAB0289  bl 0x822c8cb8
	ctx.lr = 0x82818A34;
	sub_822C8CB8(ctx, base);
	// 82818A34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82818A38: 485DA9F1  bl 0x82df3428
	ctx.lr = 0x82818A3C;
	sub_82DF3428(ctx, base);
	// 82818A3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82818A40: 485DA9E9  bl 0x82df3428
	ctx.lr = 0x82818A44;
	sub_82DF3428(ctx, base);
	// 82818A44: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82818A48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82818A4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82818A50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82818A54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82818A58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82818A60 size=100
    let mut pc: u32 = 0x82818A60;
    'dispatch: loop {
        match pc {
            0x82818A60 => {
    //   block [0x82818A60..0x82818AC4)
	// 82818A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82818A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82818A68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82818A6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82818A70: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82818A74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82818A78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82818A7C: 388B9750  addi r4, r11, -0x68b0
	ctx.r[4].s64 = ctx.r[11].s64 + -26800;
	// 82818A80: 38A00133  li r5, 0x133
	ctx.r[5].s64 = 307;
	// 82818A84: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82818A88: 4BAA7951  bl 0x822c03d8
	ctx.lr = 0x82818A8C;
	sub_822C03D8(ctx, base);
	// 82818A8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82818A90: 41820014  beq 0x82818aa4
	if ctx.cr[0].eq {
	pc = 0x82818AA4; continue 'dispatch;
	}
	// 82818A94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82818A98: 48001DE9  bl 0x8281a880
	ctx.lr = 0x82818A9C;
	sub_8281A880(ctx, base);
	// 82818A9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82818AA0: 48000008  b 0x82818aa8
	pc = 0x82818AA8; continue 'dispatch;
	// 82818AA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82818AA8: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 82818AAC: 4BFFFBE5  bl 0x82818690
	ctx.lr = 0x82818AB0;
	sub_82818690(ctx, base);
	// 82818AB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82818AB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82818AB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82818ABC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82818AC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82818AC8 size=224
    let mut pc: u32 = 0x82818AC8;
    'dispatch: loop {
        match pc {
            0x82818AC8 => {
    //   block [0x82818AC8..0x82818BA8)
	// 82818AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82818ACC: 4898F6A1  bl 0x831a816c
	ctx.lr = 0x82818AD0;
	sub_831A8130(ctx, base);
	// 82818AD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82818AD4: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82818AD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82818ADC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82818AE0: 388100AC  addi r4, r1, 0xac
	ctx.r[4].s64 = ctx.r[1].s64 + 172;
	// 82818AE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82818AE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82818AEC: 4BFFFC15  bl 0x82818700
	ctx.lr = 0x82818AF0;
	sub_82818700(ctx, base);
	// 82818AF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82818AF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82818AF8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82818AFC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82818B00: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82818B04: 4BAAB95D  bl 0x822c4460
	ctx.lr = 0x82818B08;
	sub_822C4460(ctx, base);
	// 82818B08: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82818B0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82818B10: 419A0008  beq cr6, 0x82818b18
	if ctx.cr[6].eq {
	pc = 0x82818B18; continue 'dispatch;
	}
	// 82818B14: 4BAA7D7D  bl 0x822c0890
	ctx.lr = 0x82818B18;
	sub_822C0890(ctx, base);
	// 82818B18: 817E0230  lwz r11, 0x230(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(560 as u32) ) } as u64;
	// 82818B1C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82818B20: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82818B24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82818B28: 419A0060  beq cr6, 0x82818b88
	if ctx.cr[6].eq {
	pc = 0x82818B88; continue 'dispatch;
	}
	// 82818B2C: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82818B30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82818B34: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82818B38: 419A0024  beq cr6, 0x82818b5c
	if ctx.cr[6].eq {
	pc = 0x82818B5C; continue 'dispatch;
	}
	// 82818B3C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82818B40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82818B44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82818B48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82818B4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82818B50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82818B54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82818B58: 4082FFE8  bne 0x82818b40
	if !ctx.cr[0].eq {
	pc = 0x82818B40; continue 'dispatch;
	}
	// 82818B5C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82818B60: 80DE0230  lwz r6, 0x230(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(560 as u32) ) } as u64;
	// 82818B64: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82818B68: 388B9750  addi r4, r11, -0x68b0
	ctx.r[4].s64 = ctx.r[11].s64 + -26800;
	// 82818B6C: 38A001B3  li r5, 0x1b3
	ctx.r[5].s64 = 435;
	// 82818B70: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82818B74: 4863E475  bl 0x82e56fe8
	ctx.lr = 0x82818B78;
	sub_82E56FE8(ctx, base);
	// 82818B78: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82818B7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82818B80: 419A0008  beq cr6, 0x82818b88
	if ctx.cr[6].eq {
	pc = 0x82818B88; continue 'dispatch;
	}
	// 82818B84: 4BAA7D0D  bl 0x822c0890
	ctx.lr = 0x82818B88;
	sub_822C0890(ctx, base);
	// 82818B88: 83DD001C  lwz r30, 0x1c(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82818B8C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82818B90: 419A000C  beq cr6, 0x82818b9c
	if ctx.cr[6].eq {
	pc = 0x82818B9C; continue 'dispatch;
	}
	// 82818B94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82818B98: 4BAA7CF9  bl 0x822c0890
	ctx.lr = 0x82818B9C;
	sub_822C0890(ctx, base);
	// 82818B9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818BA0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82818BA4: 4898F618  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82818BA8 size=252
    let mut pc: u32 = 0x82818BA8;
    'dispatch: loop {
        match pc {
            0x82818BA8 => {
    //   block [0x82818BA8..0x82818CA4)
	// 82818BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82818BAC: 4898F5BD  bl 0x831a8168
	ctx.lr = 0x82818BB0;
	sub_831A8130(ctx, base);
	// 82818BB0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82818BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82818BB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82818BBC: 4BFFFBBD  bl 0x82818778
	ctx.lr = 0x82818BC0;
	sub_82818778(ctx, base);
	// 82818BC0: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82818BC4: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82818BC8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82818BCC: 419A00BC  beq cr6, 0x82818c88
	if ctx.cr[6].eq {
	pc = 0x82818C88; continue 'dispatch;
	}
	// 82818BD0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82818BD4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82818BD8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82818BDC: 419A0024  beq cr6, 0x82818c00
	if ctx.cr[6].eq {
	pc = 0x82818C00; continue 'dispatch;
	}
	// 82818BE0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82818BE4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82818BE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82818BEC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82818BF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82818BF4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82818BF8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82818BFC: 4082FFE8  bne 0x82818be4
	if !ctx.cr[0].eq {
	pc = 0x82818BE4; continue 'dispatch;
	}
	// 82818C00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82818C04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82818C08: 4BCF68C1  bl 0x8250f4c8
	ctx.lr = 0x82818C0C;
	sub_8250F4C8(ctx, base);
	// 82818C0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82818C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82818C14: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82818C18: 409A0008  bne cr6, 0x82818c20
	if !ctx.cr[6].eq {
	pc = 0x82818C20; continue 'dispatch;
	}
	// 82818C1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82818C20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82818C24: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82818C28: 4BCEFDF1  bl 0x82508a18
	ctx.lr = 0x82818C2C;
	sub_82508A18(ctx, base);
	// 82818C2C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82818C30: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82818C34: 388B9750  addi r4, r11, -0x68b0
	ctx.r[4].s64 = ctx.r[11].s64 + -26800;
	// 82818C38: 38A001BF  li r5, 0x1bf
	ctx.r[5].s64 = 447;
	// 82818C3C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82818C40: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82818C44: 4863E3A5  bl 0x82e56fe8
	ctx.lr = 0x82818C48;
	sub_82E56FE8(ctx, base);
	// 82818C48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82818C4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82818C50: 485D9041  bl 0x82df1c90
	ctx.lr = 0x82818C54;
	sub_82DF1C90(ctx, base);
	// 82818C54: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82818C58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82818C5C: 419A0008  beq cr6, 0x82818c64
	if ctx.cr[6].eq {
	pc = 0x82818C64; continue 'dispatch;
	}
	// 82818C60: 4BAA7C31  bl 0x822c0890
	ctx.lr = 0x82818C64;
	sub_822C0890(ctx, base);
	// 82818C64: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82818C68: 41820020  beq 0x82818c88
	if ctx.cr[0].eq {
	pc = 0x82818C88; continue 'dispatch;
	}
	// 82818C6C: 8BFD0018  lbz r31, 0x18(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82818C70: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82818C74: 419A000C  beq cr6, 0x82818c80
	if ctx.cr[6].eq {
	pc = 0x82818C80; continue 'dispatch;
	}
	// 82818C78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818C7C: 4BAA7C15  bl 0x822c0890
	ctx.lr = 0x82818C80;
	sub_822C0890(ctx, base);
	// 82818C80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82818C84: 48000018  b 0x82818c9c
	pc = 0x82818C9C; continue 'dispatch;
	// 82818C88: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82818C8C: 419A000C  beq cr6, 0x82818c98
	if ctx.cr[6].eq {
	pc = 0x82818C98; continue 'dispatch;
	}
	// 82818C90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82818C94: 4BAA7BFD  bl 0x822c0890
	ctx.lr = 0x82818C98;
	sub_822C0890(ctx, base);
	// 82818C98: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82818C9C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82818CA0: 4898F518  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82818CA8 size=192
    let mut pc: u32 = 0x82818CA8;
    'dispatch: loop {
        match pc {
            0x82818CA8 => {
    //   block [0x82818CA8..0x82818D68)
	// 82818CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82818CAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82818CB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82818CB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82818CB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82818CBC: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82818CC0: 817F0234  lwz r11, 0x234(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 82818CC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82818CC8: 419A008C  beq cr6, 0x82818d54
	if ctx.cr[6].eq {
	pc = 0x82818D54; continue 'dispatch;
	}
	// 82818CCC: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 82818CD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82818CD4: 4BFFFB25  bl 0x828187f8
	ctx.lr = 0x82818CD8;
	sub_828187F8(ctx, base);
	// 82818CD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82818CDC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82818CE0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82818CE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82818CE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82818CEC: 419A0024  beq cr6, 0x82818d10
	if ctx.cr[6].eq {
	pc = 0x82818D10; continue 'dispatch;
	}
	// 82818CF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82818CF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82818CF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82818CFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82818D00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82818D04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82818D08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82818D0C: 4082FFE8  bne 0x82818cf4
	if !ctx.cr[0].eq {
	pc = 0x82818CF4; continue 'dispatch;
	}
	// 82818D10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82818D14: 80DF0234  lwz r6, 0x234(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 82818D18: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82818D1C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82818D20: 388A9750  addi r4, r10, -0x68b0
	ctx.r[4].s64 = ctx.r[10].s64 + -26800;
	// 82818D24: 38A001CE  li r5, 0x1ce
	ctx.r[5].s64 = 462;
	// 82818D28: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82818D2C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82818D30: 4863FD11  bl 0x82e58a40
	ctx.lr = 0x82818D34;
	sub_82E58A40(ctx, base);
	// 82818D34: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82818D38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82818D3C: 419A0008  beq cr6, 0x82818d44
	if ctx.cr[6].eq {
	pc = 0x82818D44; continue 'dispatch;
	}
	// 82818D40: 4BAA7B51  bl 0x822c0890
	ctx.lr = 0x82818D44;
	sub_822C0890(ctx, base);
	// 82818D44: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82818D48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82818D4C: 419A0008  beq cr6, 0x82818d54
	if ctx.cr[6].eq {
	pc = 0x82818D54; continue 'dispatch;
	}
	// 82818D50: 4BAA7B41  bl 0x822c0890
	ctx.lr = 0x82818D54;
	sub_822C0890(ctx, base);
	// 82818D54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82818D58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82818D5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82818D60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82818D64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82818D68 size=372
    let mut pc: u32 = 0x82818D68;
    'dispatch: loop {
        match pc {
            0x82818D68 => {
    //   block [0x82818D68..0x82818EDC)
	// 82818D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82818D6C: 4898F3F9  bl 0x831a8164
	ctx.lr = 0x82818D70;
	sub_831A8130(ctx, base);
	// 82818D70: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82818D74: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82818D78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82818D7C: D02100D4  stfs f1, 0xd4(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82818D80: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82818D84: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82818D88: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82818D8C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82818D90: 813F0228  lwz r9, 0x228(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 82818D94: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82818D98: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82818D9C: 3BAB9750  addi r29, r11, -0x68b0
	ctx.r[29].s64 = ctx.r[11].s64 + -26800;
	// 82818DA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82818DA4: 419A0090  beq cr6, 0x82818e34
	if ctx.cr[6].eq {
	pc = 0x82818E34; continue 'dispatch;
	}
	// 82818DA8: 38A100D4  addi r5, r1, 0xd4
	ctx.r[5].s64 = ctx.r[1].s64 + 212;
	// 82818DAC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82818DB0: 4BFEF5D1  bl 0x82808380
	ctx.lr = 0x82818DB4;
	sub_82808380(ctx, base);
	// 82818DB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82818DB8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82818DBC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82818DC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82818DC4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82818DC8: 419A0024  beq cr6, 0x82818dec
	if ctx.cr[6].eq {
	pc = 0x82818DEC; continue 'dispatch;
	}
	// 82818DCC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82818DD0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82818DD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82818DD8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82818DDC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82818DE0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82818DE4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82818DE8: 4082FFE8  bne 0x82818dd0
	if !ctx.cr[0].eq {
	pc = 0x82818DD0; continue 'dispatch;
	}
	// 82818DEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82818DF0: 80DF0228  lwz r6, 0x228(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 82818DF4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82818DF8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82818DFC: 38A001F6  li r5, 0x1f6
	ctx.r[5].s64 = 502;
	// 82818E00: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82818E04: 4863FC3D  bl 0x82e58a40
	ctx.lr = 0x82818E08;
	sub_82E58A40(ctx, base);
	// 82818E08: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82818E0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82818E10: 419A0008  beq cr6, 0x82818e18
	if ctx.cr[6].eq {
	pc = 0x82818E18; continue 'dispatch;
	}
	// 82818E14: 4BAA7A7D  bl 0x822c0890
	ctx.lr = 0x82818E18;
	sub_822C0890(ctx, base);
	// 82818E18: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82818E1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82818E20: 419A0008  beq cr6, 0x82818e28
	if ctx.cr[6].eq {
	pc = 0x82818E28; continue 'dispatch;
	}
	// 82818E24: 4BAA7A6D  bl 0x822c0890
	ctx.lr = 0x82818E28;
	sub_822C0890(ctx, base);
	// 82818E28: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82818E2C: 41820008  beq 0x82818e34
	if ctx.cr[0].eq {
	pc = 0x82818E34; continue 'dispatch;
	}
	// 82818E30: 937F0228  stw r27, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[27].u32 ) };
	// 82818E34: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82818E38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82818E3C: 419A0094  beq cr6, 0x82818ed0
	if ctx.cr[6].eq {
	pc = 0x82818ED0; continue 'dispatch;
	}
	// 82818E40: 38A100D4  addi r5, r1, 0xd4
	ctx.r[5].s64 = ctx.r[1].s64 + 212;
	// 82818E44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82818E48: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82818E4C: 4BFEF535  bl 0x82808380
	ctx.lr = 0x82818E50;
	sub_82808380(ctx, base);
	// 82818E50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82818E54: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82818E58: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82818E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82818E60: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82818E64: 419A0024  beq cr6, 0x82818e88
	if ctx.cr[6].eq {
	pc = 0x82818E88; continue 'dispatch;
	}
	// 82818E68: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82818E6C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82818E70: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82818E74: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82818E78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82818E7C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82818E80: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82818E84: 4082FFE8  bne 0x82818e6c
	if !ctx.cr[0].eq {
	pc = 0x82818E6C; continue 'dispatch;
	}
	// 82818E88: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82818E8C: 80DF0224  lwz r6, 0x224(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82818E90: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82818E94: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82818E98: 38A001FB  li r5, 0x1fb
	ctx.r[5].s64 = 507;
	// 82818E9C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82818EA0: 4863FBA1  bl 0x82e58a40
	ctx.lr = 0x82818EA4;
	sub_82E58A40(ctx, base);
	// 82818EA4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82818EA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82818EAC: 419A0008  beq cr6, 0x82818eb4
	if ctx.cr[6].eq {
	pc = 0x82818EB4; continue 'dispatch;
	}
	// 82818EB0: 4BAA79E1  bl 0x822c0890
	ctx.lr = 0x82818EB4;
	sub_822C0890(ctx, base);
	// 82818EB4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82818EB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82818EBC: 419A0008  beq cr6, 0x82818ec4
	if ctx.cr[6].eq {
	pc = 0x82818EC4; continue 'dispatch;
	}
	// 82818EC0: 4BAA79D1  bl 0x822c0890
	ctx.lr = 0x82818EC4;
	sub_822C0890(ctx, base);
	// 82818EC4: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82818EC8: 41820008  beq 0x82818ed0
	if ctx.cr[0].eq {
	pc = 0x82818ED0; continue 'dispatch;
	}
	// 82818ECC: 937F0224  stw r27, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[27].u32 ) };
	// 82818ED0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82818ED4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82818ED8: 4898F2DC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82818EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82818EE0 size=332
    let mut pc: u32 = 0x82818EE0;
    'dispatch: loop {
        match pc {
            0x82818EE0 => {
    //   block [0x82818EE0..0x8281902C)
	// 82818EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82818EE4: 4898F289  bl 0x831a816c
	ctx.lr = 0x82818EE8;
	sub_831A8130(ctx, base);
	// 82818EE8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82818EEC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82818EF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82818EF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82818EF8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82818EFC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82818F00: 3BCB9750  addi r30, r11, -0x68b0
	ctx.r[30].s64 = ctx.r[11].s64 + -26800;
	// 82818F04: 813F0228  lwz r9, 0x228(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 82818F08: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82818F0C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82818F10: 419A0084  beq cr6, 0x82818f94
	if ctx.cr[6].eq {
	pc = 0x82818F94; continue 'dispatch;
	}
	// 82818F14: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82818F18: 4BDBF139  bl 0x825d8050
	ctx.lr = 0x82818F1C;
	sub_825D8050(ctx, base);
	// 82818F1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82818F20: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82818F24: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82818F28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82818F2C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82818F30: 419A0024  beq cr6, 0x82818f54
	if ctx.cr[6].eq {
	pc = 0x82818F54; continue 'dispatch;
	}
	// 82818F34: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82818F38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82818F3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82818F40: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82818F44: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82818F48: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82818F4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82818F50: 4082FFE8  bne 0x82818f38
	if !ctx.cr[0].eq {
	pc = 0x82818F38; continue 'dispatch;
	}
	// 82818F54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82818F58: 80DF0228  lwz r6, 0x228(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 82818F5C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82818F60: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82818F64: 38A00207  li r5, 0x207
	ctx.r[5].s64 = 519;
	// 82818F68: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82818F6C: 4863FAD5  bl 0x82e58a40
	ctx.lr = 0x82818F70;
	sub_82E58A40(ctx, base);
	// 82818F70: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82818F74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82818F78: 419A0008  beq cr6, 0x82818f80
	if ctx.cr[6].eq {
	pc = 0x82818F80; continue 'dispatch;
	}
	// 82818F7C: 4BAA7915  bl 0x822c0890
	ctx.lr = 0x82818F80;
	sub_822C0890(ctx, base);
	// 82818F80: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82818F84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82818F88: 419A0008  beq cr6, 0x82818f90
	if ctx.cr[6].eq {
	pc = 0x82818F90; continue 'dispatch;
	}
	// 82818F8C: 4BAA7905  bl 0x822c0890
	ctx.lr = 0x82818F90;
	sub_822C0890(ctx, base);
	// 82818F90: 93BF0228  stw r29, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[29].u32 ) };
	// 82818F94: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82818F98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82818F9C: 419A0084  beq cr6, 0x82819020
	if ctx.cr[6].eq {
	pc = 0x82819020; continue 'dispatch;
	}
	// 82818FA0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82818FA4: 4BDBF0AD  bl 0x825d8050
	ctx.lr = 0x82818FA8;
	sub_825D8050(ctx, base);
	// 82818FA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82818FAC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82818FB0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82818FB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82818FB8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82818FBC: 419A0024  beq cr6, 0x82818fe0
	if ctx.cr[6].eq {
	pc = 0x82818FE0; continue 'dispatch;
	}
	// 82818FC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82818FC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82818FC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82818FCC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82818FD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82818FD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82818FD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82818FDC: 4082FFE8  bne 0x82818fc4
	if !ctx.cr[0].eq {
	pc = 0x82818FC4; continue 'dispatch;
	}
	// 82818FE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82818FE4: 80DF0224  lwz r6, 0x224(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82818FE8: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82818FEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82818FF0: 38A0020C  li r5, 0x20c
	ctx.r[5].s64 = 524;
	// 82818FF4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82818FF8: 4863FA49  bl 0x82e58a40
	ctx.lr = 0x82818FFC;
	sub_82E58A40(ctx, base);
	// 82818FFC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82819000: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82819004: 419A0008  beq cr6, 0x8281900c
	if ctx.cr[6].eq {
	pc = 0x8281900C; continue 'dispatch;
	}
	// 82819008: 4BAA7889  bl 0x822c0890
	ctx.lr = 0x8281900C;
	sub_822C0890(ctx, base);
	// 8281900C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82819010: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82819014: 419A0008  beq cr6, 0x8281901c
	if ctx.cr[6].eq {
	pc = 0x8281901C; continue 'dispatch;
	}
	// 82819018: 4BAA7879  bl 0x822c0890
	ctx.lr = 0x8281901C;
	sub_822C0890(ctx, base);
	// 8281901C: 93BF0224  stw r29, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[29].u32 ) };
	// 82819020: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82819024: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82819028: 4898F194  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82819030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82819030 size=304
    let mut pc: u32 = 0x82819030;
    'dispatch: loop {
        match pc {
            0x82819030 => {
    //   block [0x82819030..0x82819160)
	// 82819030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82819034: 4898F139  bl 0x831a816c
	ctx.lr = 0x82819038;
	sub_831A8130(ctx, base);
	// 82819038: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8281903C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82819040: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82819044: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82819048: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8281904C: 389E0244  addi r4, r30, 0x244
	ctx.r[4].s64 = ctx.r[30].s64 + 580;
	// 82819050: 817E0244  lwz r11, 0x244(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(580 as u32) ) } as u64;
	// 82819054: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82819058: 40990098  ble cr6, 0x828190f0
	if !ctx.cr[6].gt {
	pc = 0x828190F0; continue 'dispatch;
	}
	// 8281905C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82819060: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82819064: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82819068: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8281906C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82819070: 4BFA34E9  bl 0x827bc558
	ctx.lr = 0x82819074;
	sub_827BC558(ctx, base);
	// 82819074: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819078: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8281907C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82819080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82819084: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82819088: 419A0024  beq cr6, 0x828190ac
	if ctx.cr[6].eq {
	pc = 0x828190AC; continue 'dispatch;
	}
	// 8281908C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82819090: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82819094: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82819098: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281909C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828190A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828190A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828190A8: 4082FFE8  bne 0x82819090
	if !ctx.cr[0].eq {
	pc = 0x82819090; continue 'dispatch;
	}
	// 828190AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828190B0: 80DE0238  lwz r6, 0x238(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(568 as u32) ) } as u64;
	// 828190B4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828190B8: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 828190BC: 388A9750  addi r4, r10, -0x68b0
	ctx.r[4].s64 = ctx.r[10].s64 + -26800;
	// 828190C0: 38A0022D  li r5, 0x22d
	ctx.r[5].s64 = 557;
	// 828190C4: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 828190C8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828190CC: 4863F975  bl 0x82e58a40
	ctx.lr = 0x828190D0;
	sub_82E58A40(ctx, base);
	// 828190D0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828190D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828190D8: 419A0008  beq cr6, 0x828190e0
	if ctx.cr[6].eq {
	pc = 0x828190E0; continue 'dispatch;
	}
	// 828190DC: 4BAA77B5  bl 0x822c0890
	ctx.lr = 0x828190E0;
	sub_822C0890(ctx, base);
	// 828190E0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828190E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828190E8: 419A0008  beq cr6, 0x828190f0
	if ctx.cr[6].eq {
	pc = 0x828190F0; continue 'dispatch;
	}
	// 828190EC: 4BAA77A5  bl 0x822c0890
	ctx.lr = 0x828190F0;
	sub_822C0890(ctx, base);
	// 828190F0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828190F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828190F8: 3BEB9550  addi r31, r11, -0x6ab0
	ctx.r[31].s64 = ctx.r[11].s64 + -27312;
	// 828190FC: 389FFFF4  addi r4, r31, -0xc
	ctx.r[4].s64 = ctx.r[31].s64 + -12;
	// 82819100: 485DA909  bl 0x82df3a08
	ctx.lr = 0x82819104;
	sub_82DF3A08(ctx, base);
	// 82819104: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82819108: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8281910C: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82819110: 48662EC9  bl 0x82e7bfd8
	ctx.lr = 0x82819114;
	sub_82E7BFD8(ctx, base);
	// 82819114: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82819118: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281911C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82819120: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82819124: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 82819128: 4BFD30D9  bl 0x827ec200
	ctx.lr = 0x8281912C;
	sub_827EC200(ctx, base);
	// 8281912C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82819130: 485DA2F9  bl 0x82df3428
	ctx.lr = 0x82819134;
	sub_82DF3428(ctx, base);
	// 82819134: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82819138: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281913C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82819140: 4BFD4071  bl 0x827ed1b0
	ctx.lr = 0x82819144;
	sub_827ED1B0(ctx, base);
	// 82819144: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82819148: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281914C: 419A0008  beq cr6, 0x82819154
	if ctx.cr[6].eq {
	pc = 0x82819154; continue 'dispatch;
	}
	// 82819150: 4BAA7741  bl 0x822c0890
	ctx.lr = 0x82819154;
	sub_822C0890(ctx, base);
	// 82819154: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82819158: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8281915C: 4898F060  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82819160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82819160 size=328
    let mut pc: u32 = 0x82819160;
    'dispatch: loop {
        match pc {
            0x82819160 => {
    //   block [0x82819160..0x828192A8)
	// 82819160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82819164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82819168: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281916C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82819170: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82819174: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82819178: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281917C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82819180: 4BCF6349  bl 0x8250f4c8
	ctx.lr = 0x82819184;
	sub_8250F4C8(ctx, base);
	// 82819184: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281918C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82819190: 409A0008  bne cr6, 0x82819198
	if !ctx.cr[6].eq {
	pc = 0x82819198; continue 'dispatch;
	}
	// 82819194: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82819198: 4BCEFCC9  bl 0x82508e60
	ctx.lr = 0x8281919C;
	sub_82508E60(ctx, base);
	// 8281919C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828191A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828191A4: 485D8AED  bl 0x82df1c90
	ctx.lr = 0x828191A8;
	sub_82DF1C90(ctx, base);
	// 828191A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828191AC: 419A00E4  beq cr6, 0x82819290
	if ctx.cr[6].eq {
	pc = 0x82819290; continue 'dispatch;
	}
	// 828191B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828191B4: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 828191B8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828191BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828191C0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828191C4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828191C8: 38AB9BC9  addi r5, r11, -0x6437
	ctx.r[5].s64 = ctx.r[11].s64 + -25655;
	// 828191CC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828191D0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828191D4: 48144F95  bl 0x8295e168
	ctx.lr = 0x828191D8;
	sub_8295E168(ctx, base);
	// 828191D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828191DC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828191E0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828191E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828191E8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828191EC: 419A0024  beq cr6, 0x82819210
	if ctx.cr[6].eq {
	pc = 0x82819210; continue 'dispatch;
	}
	// 828191F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828191F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828191F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828191FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82819200: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82819204: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82819208: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281920C: 4082FFE8  bne 0x828191f4
	if !ctx.cr[0].eq {
	pc = 0x828191F4; continue 'dispatch;
	}
	// 82819210: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82819214: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82819218: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8281921C: 388A9750  addi r4, r10, -0x68b0
	ctx.r[4].s64 = ctx.r[10].s64 + -26800;
	// 82819220: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82819224: 38A00242  li r5, 0x242
	ctx.r[5].s64 = 578;
	// 82819228: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281922C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82819230: 4863F811  bl 0x82e58a40
	ctx.lr = 0x82819234;
	sub_82E58A40(ctx, base);
	// 82819234: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82819238: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281923C: 419A0008  beq cr6, 0x82819244
	if ctx.cr[6].eq {
	pc = 0x82819244; continue 'dispatch;
	}
	// 82819240: 4BAA7651  bl 0x822c0890
	ctx.lr = 0x82819244;
	sub_822C0890(ctx, base);
	// 82819244: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82819248: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281924C: 419A0008  beq cr6, 0x82819254
	if ctx.cr[6].eq {
	pc = 0x82819254; continue 'dispatch;
	}
	// 82819250: 4BAA7641  bl 0x822c0890
	ctx.lr = 0x82819254;
	sub_822C0890(ctx, base);
	// 82819254: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82819258: 4BCD1831  bl 0x824eaa88
	ctx.lr = 0x8281925C;
	sub_824EAA88(ctx, base);
	// 8281925C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82819260: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82819264: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819268: 4BCD2059  bl 0x824eb2c0
	ctx.lr = 0x8281926C;
	sub_824EB2C0(ctx, base);
	// 8281926C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82819270: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819274: 4BCFEF8D  bl 0x82518200
	ctx.lr = 0x82819278;
	sub_82518200(ctx, base);
	// 82819278: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8281927C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82819280: 419A0008  beq cr6, 0x82819288
	if ctx.cr[6].eq {
	pc = 0x82819288; continue 'dispatch;
	}
	// 82819284: 4BAA760D  bl 0x822c0890
	ctx.lr = 0x82819288;
	sub_822C0890(ctx, base);
	// 82819288: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8281928C: 485D8A05  bl 0x82df1c90
	ctx.lr = 0x82819290;
	sub_82DF1C90(ctx, base);
	// 82819290: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82819294: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82819298: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281929C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828192A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828192A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828192A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828192A8 size=588
    let mut pc: u32 = 0x828192A8;
    'dispatch: loop {
        match pc {
            0x828192A8 => {
    //   block [0x828192A8..0x828194F4)
	// 828192A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828192AC: 4898EEAD  bl 0x831a8158
	ctx.lr = 0x828192B0;
	sub_831A8130(ctx, base);
	// 828192B0: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828192B4: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828192B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828192BC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828192C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828192C4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828192C8: 837D0240  lwz r27, 0x240(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(576 as u32) ) } as u64;
	// 828192CC: C01D0248  lfs f0, 0x248(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(584 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828192D0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828192D4: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 828192D8: 4BCF61F1  bl 0x8250f4c8
	ctx.lr = 0x828192DC;
	sub_8250F4C8(ctx, base);
	// 828192DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828192E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828192E4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 828192E8: 409A0008  bne cr6, 0x828192f0
	if !ctx.cr[6].eq {
	pc = 0x828192F0; continue 'dispatch;
	}
	// 828192EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828192F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828192F4: 4BCEF725  bl 0x82508a18
	ctx.lr = 0x828192F8;
	sub_82508A18(ctx, base);
	// 828192F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828192FC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82819300: 485D8991  bl 0x82df1c90
	ctx.lr = 0x82819304;
	sub_82DF1C90(ctx, base);
	// 82819304: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82819308: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8281930C: 3B8B9750  addi r28, r11, -0x68b0
	ctx.r[28].s64 = ctx.r[11].s64 + -26800;
	// 82819310: 419A0148  beq cr6, 0x82819458
	if ctx.cr[6].eq {
	pc = 0x82819458; continue 'dispatch;
	}
	// 82819314: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82819318: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8281931C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82819320: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82819324: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82819328: 3BE10054  addi r31, r1, 0x54
	ctx.r[31].s64 = ctx.r[1].s64 + 84;
	// 8281932C: 3B210058  addi r25, r1, 0x58
	ctx.r[25].s64 = ctx.r[1].s64 + 88;
	// 82819330: 3B010050  addi r24, r1, 0x50
	ctx.r[24].s64 = ctx.r[1].s64 + 80;
	// 82819334: 481FA34D  bl 0x82a13680
	ctx.lr = 0x82819338;
	sub_82A13680(ctx, base);
	// 82819338: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281933C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82819340: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82819344: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82819348: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 8281934C: 4BF6D4A5  bl 0x827867f0
	ctx.lr = 0x82819350;
	sub_827867F0(ctx, base);
	// 82819350: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819354: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82819358: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281935C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82819360: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82819364: 419A0024  beq cr6, 0x82819388
	if ctx.cr[6].eq {
	pc = 0x82819388; continue 'dispatch;
	}
	// 82819368: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281936C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82819370: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82819374: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82819378: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281937C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82819380: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82819384: 4082FFE8  bne 0x8281936c
	if !ctx.cr[0].eq {
	pc = 0x8281936C; continue 'dispatch;
	}
	// 82819388: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8281938C: 3BFD0028  addi r31, r29, 0x28
	ctx.r[31].s64 = ctx.r[29].s64 + 40;
	// 82819390: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82819394: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82819398: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8281939C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828193A0: 38A0028E  li r5, 0x28e
	ctx.r[5].s64 = 654;
	// 828193A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828193A8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828193AC: 4863F695  bl 0x82e58a40
	ctx.lr = 0x828193B0;
	sub_82E58A40(ctx, base);
	// 828193B0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828193B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828193B8: 419A0008  beq cr6, 0x828193c0
	if ctx.cr[6].eq {
	pc = 0x828193C0; continue 'dispatch;
	}
	// 828193BC: 4BAA74D5  bl 0x822c0890
	ctx.lr = 0x828193C0;
	sub_822C0890(ctx, base);
	// 828193C0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828193C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828193C8: 419A0008  beq cr6, 0x828193d0
	if ctx.cr[6].eq {
	pc = 0x828193D0; continue 'dispatch;
	}
	// 828193CC: 4BAA74C5  bl 0x822c0890
	ctx.lr = 0x828193D0;
	sub_822C0890(ctx, base);
	// 828193D0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828193D4: 419A0084  beq cr6, 0x82819458
	if ctx.cr[6].eq {
	pc = 0x82819458; continue 'dispatch;
	}
	// 828193D8: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 828193DC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828193E0: 4BFFF491  bl 0x82818870
	ctx.lr = 0x828193E4;
	sub_82818870(ctx, base);
	// 828193E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828193E8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828193EC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828193F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828193F4: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828193F8: 419A0024  beq cr6, 0x8281941c
	if ctx.cr[6].eq {
	pc = 0x8281941C; continue 'dispatch;
	}
	// 828193FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82819400: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82819404: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82819408: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281940C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82819410: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82819414: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82819418: 4082FFE8  bne 0x82819400
	if !ctx.cr[0].eq {
	pc = 0x82819400; continue 'dispatch;
	}
	// 8281941C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82819420: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82819424: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 82819428: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8281942C: 38A00293  li r5, 0x293
	ctx.r[5].s64 = 659;
	// 82819430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819434: 4863F60D  bl 0x82e58a40
	ctx.lr = 0x82819438;
	sub_82E58A40(ctx, base);
	// 82819438: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8281943C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82819440: 419A0008  beq cr6, 0x82819448
	if ctx.cr[6].eq {
	pc = 0x82819448; continue 'dispatch;
	}
	// 82819444: 4BAA744D  bl 0x822c0890
	ctx.lr = 0x82819448;
	sub_822C0890(ctx, base);
	// 82819448: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 8281944C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82819450: 419A0008  beq cr6, 0x82819458
	if ctx.cr[6].eq {
	pc = 0x82819458; continue 'dispatch;
	}
	// 82819454: 4BAA743D  bl 0x822c0890
	ctx.lr = 0x82819458;
	sub_822C0890(ctx, base);
	// 82819458: 38BA0030  addi r5, r26, 0x30
	ctx.r[5].s64 = ctx.r[26].s64 + 48;
	// 8281945C: 389A0050  addi r4, r26, 0x50
	ctx.r[4].s64 = ctx.r[26].s64 + 80;
	// 82819460: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82819464: 4BFE52DD  bl 0x827fe740
	ctx.lr = 0x82819468;
	sub_827FE740(ctx, base);
	// 82819468: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281946C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82819470: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82819474: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82819478: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8281947C: 419A0024  beq cr6, 0x828194a0
	if ctx.cr[6].eq {
	pc = 0x828194A0; continue 'dispatch;
	}
	// 82819480: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82819484: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82819488: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281948C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82819490: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82819494: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82819498: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281949C: 4082FFE8  bne 0x82819484
	if !ctx.cr[0].eq {
	pc = 0x82819484; continue 'dispatch;
	}
	// 828194A0: 3BFD0028  addi r31, r29, 0x28
	ctx.r[31].s64 = ctx.r[29].s64 + 40;
	// 828194A4: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 828194A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828194AC: 487EFB0D  bl 0x83008fb8
	ctx.lr = 0x828194B0;
	sub_83008FB8(ctx, base);
	// 828194B0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828194B4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828194B8: 38A00299  li r5, 0x299
	ctx.r[5].s64 = 665;
	// 828194BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828194C0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828194C4: 4863DB25  bl 0x82e56fe8
	ctx.lr = 0x828194C8;
	sub_82E56FE8(ctx, base);
	// 828194C8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828194CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828194D0: 419A0008  beq cr6, 0x828194d8
	if ctx.cr[6].eq {
	pc = 0x828194D8; continue 'dispatch;
	}
	// 828194D4: 4BAA73BD  bl 0x822c0890
	ctx.lr = 0x828194D8;
	sub_822C0890(ctx, base);
	// 828194D8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828194DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828194E0: 419A0008  beq cr6, 0x828194e8
	if ctx.cr[6].eq {
	pc = 0x828194E8; continue 'dispatch;
	}
	// 828194E4: 4BAA73AD  bl 0x822c0890
	ctx.lr = 0x828194E8;
	sub_822C0890(ctx, base);
	// 828194E8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828194EC: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828194F0: 4898ECB8  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828194F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828194F8 size=276
    let mut pc: u32 = 0x828194F8;
    'dispatch: loop {
        match pc {
            0x828194F8 => {
    //   block [0x828194F8..0x8281960C)
	// 828194F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828194FC: 4898EC6D  bl 0x831a8168
	ctx.lr = 0x82819500;
	sub_831A8130(ctx, base);
	// 82819500: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82819504: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82819508: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8281950C: 4BFD2CC5  bl 0x827ec1d0
	ctx.lr = 0x82819510;
	sub_827EC1D0(ctx, base);
	// 82819510: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82819514: 41820060  beq 0x82819574
	if ctx.cr[0].eq {
	pc = 0x82819574; continue 'dispatch;
	}
	// 82819518: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281951C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82819520: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 82819524: 485DA4E5  bl 0x82df3a08
	ctx.lr = 0x82819528;
	sub_82DF3A08(ctx, base);
	// 82819528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281952C: 4BFD0D7D  bl 0x827ea2a8
	ctx.lr = 0x82819530;
	sub_827EA2A8(ctx, base);
	// 82819530: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82819534: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82819538: 485DA699  bl 0x82df3bd0
	ctx.lr = 0x8281953C;
	sub_82DF3BD0(ctx, base);
	// 8281953C: 3BDD0018  addi r30, r29, 0x18
	ctx.r[30].s64 = ctx.r[29].s64 + 24;
	// 82819540: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82819544: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82819548: 485D9D59  bl 0x82df32a0
	ctx.lr = 0x8281954C;
	sub_82DF32A0(ctx, base);
	// 8281954C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82819550: 40820010  bne 0x82819560
	if !ctx.cr[0].eq {
	pc = 0x82819560; continue 'dispatch;
	}
	// 82819554: 897D001C  lbz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82819558: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281955C: 41820010  beq 0x8281956c
	if ctx.cr[0].eq {
	pc = 0x8281956C; continue 'dispatch;
	}
	// 82819560: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82819564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819568: 4BFD0F79  bl 0x827ea4e0
	ctx.lr = 0x8281956C;
	sub_827EA4E0(ctx, base);
	// 8281956C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82819570: 485D9EB9  bl 0x82df3428
	ctx.lr = 0x82819574;
	sub_82DF3428(ctx, base);
	// 82819574: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82819578: 4BFD2BE9  bl 0x827ec160
	ctx.lr = 0x8281957C;
	sub_827EC160(ctx, base);
	// 8281957C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82819580: 41820084  beq 0x82819604
	if ctx.cr[0].eq {
	pc = 0x82819604; continue 'dispatch;
	}
	// 82819584: 387D0018  addi r3, r29, 0x18
	ctx.r[3].s64 = ctx.r[29].s64 + 24;
	// 82819588: 485D9C29  bl 0x82df31b0
	ctx.lr = 0x8281958C;
	sub_82DF31B0(ctx, base);
	// 8281958C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82819590: 38BD001C  addi r5, r29, 0x1c
	ctx.r[5].s64 = ctx.r[29].s64 + 28;
	// 82819594: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82819598: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281959C: 4BFFF34D  bl 0x828188e8
	ctx.lr = 0x828195A0;
	sub_828188E8(ctx, base);
	// 828195A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828195A4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828195A8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828195AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828195B0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828195B4: 419A0024  beq cr6, 0x828195d8
	if ctx.cr[6].eq {
	pc = 0x828195D8; continue 'dispatch;
	}
	// 828195B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828195BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828195C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828195C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828195C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828195CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828195D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828195D4: 4082FFE8  bne 0x828195bc
	if !ctx.cr[0].eq {
	pc = 0x828195BC; continue 'dispatch;
	}
	// 828195D8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828195DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828195E0: 48000EE1  bl 0x8281a4c0
	ctx.lr = 0x828195E4;
	sub_8281A4C0(ctx, base);
	// 828195E4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828195E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828195EC: 419A0008  beq cr6, 0x828195f4
	if ctx.cr[6].eq {
	pc = 0x828195F4; continue 'dispatch;
	}
	// 828195F0: 4BAA72A1  bl 0x822c0890
	ctx.lr = 0x828195F4;
	sub_822C0890(ctx, base);
	// 828195F4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828195F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828195FC: 419A0008  beq cr6, 0x82819604
	if ctx.cr[6].eq {
	pc = 0x82819604; continue 'dispatch;
	}
	// 82819600: 4BAA7291  bl 0x822c0890
	ctx.lr = 0x82819604;
	sub_822C0890(ctx, base);
	// 82819604: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82819608: 4898EBB0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82819610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82819610 size=276
    let mut pc: u32 = 0x82819610;
    'dispatch: loop {
        match pc {
            0x82819610 => {
    //   block [0x82819610..0x82819724)
	// 82819610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82819614: 4898EB51  bl 0x831a8164
	ctx.lr = 0x82819618;
	sub_831A8130(ctx, base);
	// 82819618: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281961C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82819620: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82819624: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82819628: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8281962C: 897E0250  lbz r11, 0x250(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(592 as u32) ) } as u64;
	// 82819630: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82819634: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82819638: 41820048  beq 0x82819680
	if ctx.cr[0].eq {
	pc = 0x82819680; continue 'dispatch;
	}
	// 8281963C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82819640: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82819644: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82819648: 4BCF5E81  bl 0x8250f4c8
	ctx.lr = 0x8281964C;
	sub_8250F4C8(ctx, base);
	// 8281964C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82819654: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82819658: 409A0008  bne cr6, 0x82819660
	if !ctx.cr[6].eq {
	pc = 0x82819660; continue 'dispatch;
	}
	// 8281965C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82819660: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82819664: 4BCEF3B5  bl 0x82508a18
	ctx.lr = 0x82819668;
	sub_82508A18(ctx, base);
	// 82819668: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8281966C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82819670: 487EEAB9  bl 0x83008128
	ctx.lr = 0x82819674;
	sub_83008128(ctx, base);
	// 82819674: 7F03D840  cmplw cr6, r3, r27
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82819678: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8281967C: 409A0008  bne cr6, 0x82819684
	if !ctx.cr[6].eq {
	pc = 0x82819684; continue 'dispatch;
	}
	// 82819680: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82819684: 57EA07FF  clrlwi. r10, r31, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82819688: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8281968C: 4182000C  beq 0x82819698
	if ctx.cr[0].eq {
	pc = 0x82819698; continue 'dispatch;
	}
	// 82819690: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82819694: 485D85FD  bl 0x82df1c90
	ctx.lr = 0x82819698;
	sub_82DF1C90(ctx, base);
	// 82819698: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281969C: 4182000C  beq 0x828196a8
	if ctx.cr[0].eq {
	pc = 0x828196A8; continue 'dispatch;
	}
	// 828196A0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828196A4: 48000048  b 0x828196ec
	pc = 0x828196EC; continue 'dispatch;
	// 828196A8: 815E023C  lwz r10, 0x23c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(572 as u32) ) } as u64;
	// 828196AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828196B0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828196B4: 41990008  bgt cr6, 0x828196bc
	if ctx.cr[6].gt {
	pc = 0x828196BC; continue 'dispatch;
	}
	// 828196B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828196BC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828196C0: 4182002C  beq 0x828196ec
	if ctx.cr[0].eq {
	pc = 0x828196EC; continue 'dispatch;
	}
	// 828196C4: 356AFFFF  addic. r11, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828196C8: 917E023C  stw r11, 0x23c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(572 as u32), ctx.r[11].u32 ) };
	// 828196CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828196D0: 41810008  bgt 0x828196d8
	if ctx.cr[0].gt {
	pc = 0x828196D8; continue 'dispatch;
	}
	// 828196D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828196D8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828196DC: 40820010  bne 0x828196ec
	if !ctx.cr[0].eq {
	pc = 0x828196EC; continue 'dispatch;
	}
	// 828196E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828196E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828196E8: 4BFFFBC1  bl 0x828192a8
	ctx.lr = 0x828196EC;
	sub_828192A8(ctx, base);
	// 828196EC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828196F0: 41820028  beq 0x82819718
	if ctx.cr[0].eq {
	pc = 0x82819718; continue 'dispatch;
	}
	// 828196F4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828196F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828196FC: 38AB9804  addi r5, r11, -0x67fc
	ctx.r[5].s64 = ctx.r[11].s64 + -26620;
	// 82819700: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82819704: 4BFD3AAD  bl 0x827ed1b0
	ctx.lr = 0x82819708;
	sub_827ED1B0(ctx, base);
	// 82819708: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281970C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82819710: 419A0008  beq cr6, 0x82819718
	if ctx.cr[6].eq {
	pc = 0x82819718; continue 'dispatch;
	}
	// 82819714: 4BAA717D  bl 0x822c0890
	ctx.lr = 0x82819718;
	sub_822C0890(ctx, base);
	// 82819718: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8281971C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82819720: 4898EA94  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82819728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82819728 size=260
    let mut pc: u32 = 0x82819728;
    'dispatch: loop {
        match pc {
            0x82819728 => {
    //   block [0x82819728..0x8281982C)
	// 82819728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281972C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82819730: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82819734: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82819738: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8281973C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82819740: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82819744: 4BFD2A8D  bl 0x827ec1d0
	ctx.lr = 0x82819748;
	sub_827EC1D0(ctx, base);
	// 82819748: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8281974C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82819750: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82819754: 4182000C  beq 0x82819760
	if ctx.cr[0].eq {
	pc = 0x82819760; continue 'dispatch;
	}
	// 82819758: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8281975C: 4BFD0B55  bl 0x827ea2b0
	ctx.lr = 0x82819760;
	sub_827EA2B0(ctx, base);
	// 82819760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819764: 4BFD29FD  bl 0x827ec160
	ctx.lr = 0x82819768;
	sub_827EC160(ctx, base);
	// 82819768: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281976C: 41820008  beq 0x82819774
	if ctx.cr[0].eq {
	pc = 0x82819774; continue 'dispatch;
	}
	// 82819770: 4BFD5471  bl 0x827eebe0
	ctx.lr = 0x82819774;
	sub_827EEBE0(ctx, base);
	// 82819774: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82819778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281977C: 4BCF62D5  bl 0x8250fa50
	ctx.lr = 0x82819780;
	sub_8250FA50(ctx, base);
	// 82819780: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82819784: 4BDBE8CD  bl 0x825d8050
	ctx.lr = 0x82819788;
	sub_825D8050(ctx, base);
	// 82819788: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281978C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82819790: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82819794: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82819798: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281979C: 419A0024  beq cr6, 0x828197c0
	if ctx.cr[6].eq {
	pc = 0x828197C0; continue 'dispatch;
	}
	// 828197A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828197A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828197A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828197AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828197B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828197B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828197B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828197BC: 4082FFE8  bne 0x828197a4
	if !ctx.cr[0].eq {
	pc = 0x828197A4; continue 'dispatch;
	}
	// 828197C0: 3BFF0028  addi r31, r31, 0x28
	ctx.r[31].s64 = ctx.r[31].s64 + 40;
	// 828197C4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828197C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828197CC: 487EF7ED  bl 0x83008fb8
	ctx.lr = 0x828197D0;
	sub_83008FB8(ctx, base);
	// 828197D0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828197D4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828197D8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828197DC: 388B9750  addi r4, r11, -0x68b0
	ctx.r[4].s64 = ctx.r[11].s64 + -26800;
	// 828197E0: 38A00323  li r5, 0x323
	ctx.r[5].s64 = 803;
	// 828197E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828197E8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828197EC: 4863F255  bl 0x82e58a40
	ctx.lr = 0x828197F0;
	sub_82E58A40(ctx, base);
	// 828197F0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828197F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828197F8: 419A0008  beq cr6, 0x82819800
	if ctx.cr[6].eq {
	pc = 0x82819800; continue 'dispatch;
	}
	// 828197FC: 4BAA7095  bl 0x822c0890
	ctx.lr = 0x82819800;
	sub_822C0890(ctx, base);
	// 82819800: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82819804: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82819808: 419A0008  beq cr6, 0x82819810
	if ctx.cr[6].eq {
	pc = 0x82819810; continue 'dispatch;
	}
	// 8281980C: 4BAA7085  bl 0x822c0890
	ctx.lr = 0x82819810;
	sub_822C0890(ctx, base);
	// 82819810: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82819814: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82819818: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281981C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82819820: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82819824: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82819828: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82819830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82819830 size=556
    let mut pc: u32 = 0x82819830;
    'dispatch: loop {
        match pc {
            0x82819830 => {
    //   block [0x82819830..0x82819A5C)
	// 82819830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82819834: 4898E935  bl 0x831a8168
	ctx.lr = 0x82819838;
	sub_831A8130(ctx, base);
	// 82819838: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281983C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82819840: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82819844: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82819848: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8281984C: 41820038  beq 0x82819884
	if ctx.cr[0].eq {
	pc = 0x82819884; continue 'dispatch;
	}
	// 82819850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819854: 48990135  bl 0x831a9988
	ctx.lr = 0x82819858;
	sub_831A9988(ctx, base);
	// 82819858: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281985C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82819860: 386BDBD4  addi r3, r11, -0x242c
	ctx.r[3].s64 = ctx.r[11].s64 + -9260;
	// 82819864: 4898E895  bl 0x831a80f8
	ctx.lr = 0x82819868;
	sub_831A80F8(ctx, base);
	// 82819868: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281986C: 41820018  beq 0x82819884
	if ctx.cr[0].eq {
	pc = 0x82819884; continue 'dispatch;
	}
	// 82819870: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82819874: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82819878: 4BFFFEB1  bl 0x82819728
	ctx.lr = 0x8281987C;
	sub_82819728(ctx, base);
	// 8281987C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82819880: 480001D4  b 0x82819a54
	pc = 0x82819A54; continue 'dispatch;
	// 82819884: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82819888: 419A01BC  beq cr6, 0x82819a44
	if ctx.cr[6].eq {
	pc = 0x82819A44; continue 'dispatch;
	}
	// 8281988C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819890: 489900F9  bl 0x831a9988
	ctx.lr = 0x82819894;
	sub_831A9988(ctx, base);
	// 82819894: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82819898: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281989C: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 828198A0: 4898E859  bl 0x831a80f8
	ctx.lr = 0x828198A4;
	sub_831A80F8(ctx, base);
	// 828198A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828198A8: 41820014  beq 0x828198bc
	if ctx.cr[0].eq {
	pc = 0x828198BC; continue 'dispatch;
	}
	// 828198AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828198B0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828198B4: 4BFFFD5D  bl 0x82819610
	ctx.lr = 0x828198B8;
	sub_82819610(ctx, base);
	// 828198B8: 4800019C  b 0x82819a54
	pc = 0x82819A54; continue 'dispatch;
	// 828198BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828198C0: 419A0184  beq cr6, 0x82819a44
	if ctx.cr[6].eq {
	pc = 0x82819A44; continue 'dispatch;
	}
	// 828198C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828198C8: 489900C1  bl 0x831a9988
	ctx.lr = 0x828198CC;
	sub_831A9988(ctx, base);
	// 828198CC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828198D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828198D4: 386BF694  addi r3, r11, -0x96c
	ctx.r[3].s64 = ctx.r[11].s64 + -2412;
	// 828198D8: 4898E821  bl 0x831a80f8
	ctx.lr = 0x828198DC;
	sub_831A80F8(ctx, base);
	// 828198DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828198E0: 41820014  beq 0x828198f4
	if ctx.cr[0].eq {
	pc = 0x828198F4; continue 'dispatch;
	}
	// 828198E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828198E8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828198EC: 4BF2C7E5  bl 0x827460d0
	ctx.lr = 0x828198F0;
	sub_827460D0(ctx, base);
	// 828198F0: 4BFFFF8C  b 0x8281987c
	pc = 0x8281987C; continue 'dispatch;
	// 828198F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828198F8: 419A014C  beq cr6, 0x82819a44
	if ctx.cr[6].eq {
	pc = 0x82819A44; continue 'dispatch;
	}
	// 828198FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819900: 48990089  bl 0x831a9988
	ctx.lr = 0x82819904;
	sub_831A9988(ctx, base);
	// 82819904: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82819908: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281990C: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 82819910: 4898E7E9  bl 0x831a80f8
	ctx.lr = 0x82819914;
	sub_831A80F8(ctx, base);
	// 82819914: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82819918: 41820014  beq 0x8281992c
	if ctx.cr[0].eq {
	pc = 0x8281992C; continue 'dispatch;
	}
	// 8281991C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82819920: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82819924: 4BFFEB4D  bl 0x82818470
	ctx.lr = 0x82819928;
	sub_82818470(ctx, base);
	// 82819928: 4BFFFF54  b 0x8281987c
	pc = 0x8281987C; continue 'dispatch;
	// 8281992C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82819930: 419A0114  beq cr6, 0x82819a44
	if ctx.cr[6].eq {
	pc = 0x82819A44; continue 'dispatch;
	}
	// 82819934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819938: 48990051  bl 0x831a9988
	ctx.lr = 0x8281993C;
	sub_831A9988(ctx, base);
	// 8281993C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82819940: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82819944: 386B6BB0  addi r3, r11, 0x6bb0
	ctx.r[3].s64 = ctx.r[11].s64 + 27568;
	// 82819948: 4898E7B1  bl 0x831a80f8
	ctx.lr = 0x8281994C;
	sub_831A80F8(ctx, base);
	// 8281994C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82819950: 41820014  beq 0x82819964
	if ctx.cr[0].eq {
	pc = 0x82819964; continue 'dispatch;
	}
	// 82819954: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82819958: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8281995C: 4BFFDCED  bl 0x82817648
	ctx.lr = 0x82819960;
	sub_82817648(ctx, base);
	// 82819960: 4BFFFF1C  b 0x8281987c
	pc = 0x8281987C; continue 'dispatch;
	// 82819964: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82819968: 419A00DC  beq cr6, 0x82819a44
	if ctx.cr[6].eq {
	pc = 0x82819A44; continue 'dispatch;
	}
	// 8281996C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819970: 48990019  bl 0x831a9988
	ctx.lr = 0x82819974;
	sub_831A9988(ctx, base);
	// 82819974: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82819978: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281997C: 386BF668  addi r3, r11, -0x998
	ctx.r[3].s64 = ctx.r[11].s64 + -2456;
	// 82819980: 4898E779  bl 0x831a80f8
	ctx.lr = 0x82819984;
	sub_831A80F8(ctx, base);
	// 82819984: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82819988: 41820014  beq 0x8281999c
	if ctx.cr[0].eq {
	pc = 0x8281999C; continue 'dispatch;
	}
	// 8281998C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82819990: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82819994: 4BFFDC6D  bl 0x82817600
	ctx.lr = 0x82819998;
	sub_82817600(ctx, base);
	// 82819998: 4BFFFEE4  b 0x8281987c
	pc = 0x8281987C; continue 'dispatch;
	// 8281999C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828199A0: 419A00A4  beq cr6, 0x82819a44
	if ctx.cr[6].eq {
	pc = 0x82819A44; continue 'dispatch;
	}
	// 828199A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828199A8: 4898FFE1  bl 0x831a9988
	ctx.lr = 0x828199AC;
	sub_831A9988(ctx, base);
	// 828199AC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828199B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828199B4: 386BD5B0  addi r3, r11, -0x2a50
	ctx.r[3].s64 = ctx.r[11].s64 + -10832;
	// 828199B8: 4898E741  bl 0x831a80f8
	ctx.lr = 0x828199BC;
	sub_831A80F8(ctx, base);
	// 828199BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828199C0: 41820014  beq 0x828199d4
	if ctx.cr[0].eq {
	pc = 0x828199D4; continue 'dispatch;
	}
	// 828199C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828199C8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828199CC: 4BFFFB2D  bl 0x828194f8
	ctx.lr = 0x828199D0;
	sub_828194F8(ctx, base);
	// 828199D0: 4BFFFEAC  b 0x8281987c
	pc = 0x8281987C; continue 'dispatch;
	// 828199D4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828199D8: 419A006C  beq cr6, 0x82819a44
	if ctx.cr[6].eq {
	pc = 0x82819A44; continue 'dispatch;
	}
	// 828199DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828199E0: 4898FFA9  bl 0x831a9988
	ctx.lr = 0x828199E4;
	sub_831A9988(ctx, base);
	// 828199E4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 828199E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828199EC: 386BD9D8  addi r3, r11, -0x2628
	ctx.r[3].s64 = ctx.r[11].s64 + -9768;
	// 828199F0: 4898E709  bl 0x831a80f8
	ctx.lr = 0x828199F4;
	sub_831A80F8(ctx, base);
	// 828199F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828199F8: 41820014  beq 0x82819a0c
	if ctx.cr[0].eq {
	pc = 0x82819A0C; continue 'dispatch;
	}
	// 828199FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82819A00: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82819A04: 4BEA8AE5  bl 0x826c24e8
	ctx.lr = 0x82819A08;
	sub_826C24E8(ctx, base);
	// 82819A08: 4BFFFE74  b 0x8281987c
	pc = 0x8281987C; continue 'dispatch;
	// 82819A0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82819A10: 419A0034  beq cr6, 0x82819a44
	if ctx.cr[6].eq {
	pc = 0x82819A44; continue 'dispatch;
	}
	// 82819A14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819A18: 4898FF71  bl 0x831a9988
	ctx.lr = 0x82819A1C;
	sub_831A9988(ctx, base);
	// 82819A1C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82819A20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82819A24: 386B5AB4  addi r3, r11, 0x5ab4
	ctx.r[3].s64 = ctx.r[11].s64 + 23220;
	// 82819A28: 4898E6D1  bl 0x831a80f8
	ctx.lr = 0x82819A2C;
	sub_831A80F8(ctx, base);
	// 82819A2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82819A30: 41820014  beq 0x82819a44
	if ctx.cr[0].eq {
	pc = 0x82819A44; continue 'dispatch;
	}
	// 82819A34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82819A38: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82819A3C: 4BFFDCFD  bl 0x82817738
	ctx.lr = 0x82819A40;
	sub_82817738(ctx, base);
	// 82819A40: 4BFFFE3C  b 0x8281987c
	pc = 0x8281987C; continue 'dispatch;
	// 82819A44: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82819A48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82819A4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82819A50: 4BFD1B41  bl 0x827eb590
	ctx.lr = 0x82819A54;
	sub_827EB590(ctx, base);
	// 82819A54: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82819A58: 4898E760  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82819A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82819A60 size=268
    let mut pc: u32 = 0x82819A60;
    'dispatch: loop {
        match pc {
            0x82819A60 => {
    //   block [0x82819A60..0x82819B6C)
	// 82819A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82819A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82819A68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82819A6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82819A70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82819A74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82819A78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82819A7C: 817F0234  lwz r11, 0x234(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 82819A80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82819A84: 419A0088  beq cr6, 0x82819b0c
	if ctx.cr[6].eq {
	pc = 0x82819B0C; continue 'dispatch;
	}
	// 82819A88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82819A8C: 4BFFEB95  bl 0x82818620
	ctx.lr = 0x82819A90;
	sub_82818620(ctx, base);
	// 82819A90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819A94: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82819A98: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82819A9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82819AA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82819AA4: 419A0024  beq cr6, 0x82819ac8
	if ctx.cr[6].eq {
	pc = 0x82819AC8; continue 'dispatch;
	}
	// 82819AA8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82819AAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82819AB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82819AB4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82819AB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82819ABC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82819AC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82819AC4: 4082FFE8  bne 0x82819aac
	if !ctx.cr[0].eq {
	pc = 0x82819AAC; continue 'dispatch;
	}
	// 82819AC8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82819ACC: 80DF0234  lwz r6, 0x234(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 82819AD0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82819AD4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82819AD8: 388A9750  addi r4, r10, -0x68b0
	ctx.r[4].s64 = ctx.r[10].s64 + -26800;
	// 82819ADC: 38A0010C  li r5, 0x10c
	ctx.r[5].s64 = 268;
	// 82819AE0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82819AE4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82819AE8: 4863EF59  bl 0x82e58a40
	ctx.lr = 0x82819AEC;
	sub_82E58A40(ctx, base);
	// 82819AEC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82819AF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82819AF4: 419A0008  beq cr6, 0x82819afc
	if ctx.cr[6].eq {
	pc = 0x82819AFC; continue 'dispatch;
	}
	// 82819AF8: 4BAA6D99  bl 0x822c0890
	ctx.lr = 0x82819AFC;
	sub_822C0890(ctx, base);
	// 82819AFC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82819B00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82819B04: 419A0008  beq cr6, 0x82819b0c
	if ctx.cr[6].eq {
	pc = 0x82819B0C; continue 'dispatch;
	}
	// 82819B08: 4BAA6D89  bl 0x822c0890
	ctx.lr = 0x82819B0C;
	sub_822C0890(ctx, base);
	// 82819B0C: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 82819B10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82819B14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82819B18: 41990008  bgt cr6, 0x82819b20
	if ctx.cr[6].gt {
	pc = 0x82819B20; continue 'dispatch;
	}
	// 82819B1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82819B20: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82819B24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819B28: 4182000C  beq 0x82819b34
	if ctx.cr[0].eq {
	pc = 0x82819B34; continue 'dispatch;
	}
	// 82819B2C: 4BFFF3B5  bl 0x82818ee0
	ctx.lr = 0x82819B30;
	sub_82818EE0(ctx, base);
	// 82819B30: 48000008  b 0x82819b38
	pc = 0x82819B38; continue 'dispatch;
	// 82819B34: 4BFFF62D  bl 0x82819160
	ctx.lr = 0x82819B38;
	sub_82819160(ctx, base);
	// 82819B38: 807F021C  lwz r3, 0x21c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 82819B3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82819B40: 419A0008  beq cr6, 0x82819b48
	if ctx.cr[6].eq {
	pc = 0x82819B48; continue 'dispatch;
	}
	// 82819B44: 4832CB85  bl 0x82b466c8
	ctx.lr = 0x82819B48;
	sub_82B466C8(ctx, base);
	// 82819B48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82819B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819B50: 4BFD3129  bl 0x827ecc78
	ctx.lr = 0x82819B54;
	sub_827ECC78(ctx, base);
	// 82819B54: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82819B58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82819B5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82819B60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82819B64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82819B68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82819B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82819B70 size=80
    let mut pc: u32 = 0x82819B70;
    'dispatch: loop {
        match pc {
            0x82819B70 => {
    //   block [0x82819B70..0x82819BC0)
	// 82819B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82819B74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82819B78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82819B7C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82819B80: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82819B84: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82819B88: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82819B8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82819B90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819B94: 4BC9B645  bl 0x824b51d8
	ctx.lr = 0x82819B98;
	sub_824B51D8(ctx, base);
	// 82819B98: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82819B9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82819BA0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82819BA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819BA8: 4BC9B631  bl 0x824b51d8
	ctx.lr = 0x82819BAC;
	sub_824B51D8(ctx, base);
	// 82819BAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82819BB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82819BB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82819BB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82819BBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82819BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82819BC0 size=1652
    let mut pc: u32 = 0x82819BC0;
    'dispatch: loop {
        match pc {
            0x82819BC0 => {
    //   block [0x82819BC0..0x8281A234)
	// 82819BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82819BC4: 4898E591  bl 0x831a8154
	ctx.lr = 0x82819BC8;
	sub_831A8130(ctx, base);
	// 82819BC8: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82819BCC: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82819BD0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82819BD4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82819BD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82819BDC: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82819BE0: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819BE4: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819BE8: 4BFFD949  bl 0x82817530
	ctx.lr = 0x82819BEC;
	sub_82817530(ctx, base);
	// 82819BEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82819BF0: 41820634  beq 0x8281a224
	if ctx.cr[0].eq {
	pc = 0x8281A224; continue 'dispatch;
	}
	// 82819BF4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82819BF8: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819BFC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82819C00: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819C04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819C08: 4BFD2471  bl 0x827ec078
	ctx.lr = 0x82819C0C;
	sub_827EC078(ctx, base);
	// 82819C0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82819C10: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82819C14: 3B8B9BC9  addi r28, r11, -0x6437
	ctx.r[28].s64 = ctx.r[11].s64 + -25655;
	// 82819C18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82819C1C: 485D9DED  bl 0x82df3a08
	ctx.lr = 0x82819C20;
	sub_82DF3A08(ctx, base);
	// 82819C20: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82819C24: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82819C28: 485D9DE1  bl 0x82df3a08
	ctx.lr = 0x82819C2C;
	sub_82DF3A08(ctx, base);
	// 82819C2C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82819C30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82819C34: 485D9DD5  bl 0x82df3a08
	ctx.lr = 0x82819C38;
	sub_82DF3A08(ctx, base);
	// 82819C38: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819C3C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82819C40: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 82819C44: 485D9F8D  bl 0x82df3bd0
	ctx.lr = 0x82819C48;
	sub_82DF3BD0(ctx, base);
	// 82819C48: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819C4C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82819C50: 388B0038  addi r4, r11, 0x38
	ctx.r[4].s64 = ctx.r[11].s64 + 56;
	// 82819C54: 485D9F7D  bl 0x82df3bd0
	ctx.lr = 0x82819C58;
	sub_82DF3BD0(ctx, base);
	// 82819C58: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819C5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82819C60: 388B0030  addi r4, r11, 0x30
	ctx.r[4].s64 = ctx.r[11].s64 + 48;
	// 82819C64: 485D9F6D  bl 0x82df3bd0
	ctx.lr = 0x82819C68;
	sub_82DF3BD0(ctx, base);
	// 82819C68: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819C6C: 387F024C  addi r3, r31, 0x24c
	ctx.r[3].s64 = ctx.r[31].s64 + 588;
	// 82819C70: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82819C74: 485D9F5D  bl 0x82df3bd0
	ctx.lr = 0x82819C78;
	sub_82DF3BD0(ctx, base);
	// 82819C78: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82819C7C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819C80: 48610E69  bl 0x82e2aae8
	ctx.lr = 0x82819C84;
	sub_82E2AAE8(ctx, base);
	// 82819C84: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82819C88: 485D9529  bl 0x82df31b0
	ctx.lr = 0x82819C8C;
	sub_82DF31B0(ctx, base);
	// 82819C8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82819C90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82819C94: 485D9D75  bl 0x82df3a08
	ctx.lr = 0x82819C98;
	sub_82DF3A08(ctx, base);
	// 82819C98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82819C9C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82819CA0: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 82819CA4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82819CA8: 48614AF9  bl 0x82e2e7a0
	ctx.lr = 0x82819CAC;
	sub_82E2E7A0(ctx, base);
	// 82819CAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82819CB0: 485D9779  bl 0x82df3428
	ctx.lr = 0x82819CB4;
	sub_82DF3428(ctx, base);
	// 82819CB4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82819CB8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82819CBC: 3B8B9818  addi r28, r11, -0x67e8
	ctx.r[28].s64 = ctx.r[11].s64 + -26600;
	// 82819CC0: 3F408336  lis r26, -0x7cca
	ctx.r[26].s64 = -2093613056;
	// 82819CC4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82819CC8: 3B0A9750  addi r24, r10, -0x68b0
	ctx.r[24].s64 = ctx.r[10].s64 + -26800;
	// 82819CCC: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82819CD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82819CD4: 419A0148  beq cr6, 0x82819e1c
	if ctx.cr[6].eq {
	pc = 0x82819E1C; continue 'dispatch;
	}
	// 82819CD8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82819CDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82819CE0: 38A000B8  li r5, 0xb8
	ctx.r[5].s64 = 184;
	// 82819CE4: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82819CE8: 4BAA66F1  bl 0x822c03d8
	ctx.lr = 0x82819CEC;
	sub_822C03D8(ctx, base);
	// 82819CEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82819CF0: 41820014  beq 0x82819d04
	if ctx.cr[0].eq {
	pc = 0x82819D04; continue 'dispatch;
	}
	// 82819CF4: 389F00EC  addi r4, r31, 0xec
	ctx.r[4].s64 = ctx.r[31].s64 + 236;
	// 82819CF8: 4BFD81D1  bl 0x827f1ec8
	ctx.lr = 0x82819CFC;
	sub_827F1EC8(ctx, base);
	// 82819CFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82819D00: 48000008  b 0x82819d08
	pc = 0x82819D08; continue 'dispatch;
	// 82819D04: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82819D08: 3BDF020C  addi r30, r31, 0x20c
	ctx.r[30].s64 = ctx.r[31].s64 + 524;
	// 82819D0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82819D10: 4BEEE5C1  bl 0x827082d0
	ctx.lr = 0x82819D14;
	sub_827082D0(ctx, base);
	// 82819D14: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82819D18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82819D1C: 82FF020C  lwz r23, 0x20c(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 82819D20: 485D9CE9  bl 0x82df3a08
	ctx.lr = 0x82819D24;
	sub_82DF3A08(ctx, base);
	// 82819D24: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82819D28: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82819D2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82819D30: 485D9F11  bl 0x82df3c40
	ctx.lr = 0x82819D34;
	sub_82DF3C40(ctx, base);
	// 82819D34: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82819D38: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82819D3C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82819D40: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82819D44: 4BFD8275  bl 0x827f1fb8
	ctx.lr = 0x82819D48;
	sub_827F1FB8(ctx, base);
	// 82819D48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82819D4C: 485D96DD  bl 0x82df3428
	ctx.lr = 0x82819D50;
	sub_82DF3428(ctx, base);
	// 82819D50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82819D54: 485D96D5  bl 0x82df3428
	ctx.lr = 0x82819D58;
	sub_82DF3428(ctx, base);
	// 82819D58: 3D40827F  lis r10, -0x7d81
	ctx.r[10].s64 = -2105606144;
	// 82819D5C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82819D60: 394A2050  addi r10, r10, 0x2050
	ctx.r[10].s64 = ctx.r[10].s64 + 8272;
	// 82819D64: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82819D68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82819D6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82819D70: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82819D74: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82819D78: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82819D7C: 419A0024  beq cr6, 0x82819da0
	if ctx.cr[6].eq {
	pc = 0x82819DA0; continue 'dispatch;
	}
	// 82819D80: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82819D84: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82819D88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82819D8C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82819D90: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82819D94: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82819D98: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82819D9C: 4082FFE8  bne 0x82819d84
	if !ctx.cr[0].eq {
	pc = 0x82819D84; continue 'dispatch;
	}
	// 82819DA0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82819DA4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819DA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82819DAC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82819DB0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82819DB4: 419A0024  beq cr6, 0x82819dd8
	if ctx.cr[6].eq {
	pc = 0x82819DD8; continue 'dispatch;
	}
	// 82819DB8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82819DBC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82819DC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82819DC4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82819DC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82819DCC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82819DD0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82819DD4: 4082FFE8  bne 0x82819dbc
	if !ctx.cr[0].eq {
	pc = 0x82819DBC; continue 'dispatch;
	}
	// 82819DD8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82819DDC: 88DAAE34  lbz r6, -0x51cc(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(-20940 as u32) ) } as u64;
	// 82819DE0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82819DE4: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82819DE8: 4BEEF191  bl 0x82708f78
	ctx.lr = 0x82819DEC;
	sub_82708F78(ctx, base);
	// 82819DEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82819DF0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82819DF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82819DF8: 4BEEF9E1  bl 0x827097d8
	ctx.lr = 0x82819DFC;
	sub_827097D8(ctx, base);
	// 82819DFC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82819E00: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82819E04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819E08: 4BCF7039  bl 0x82510e40
	ctx.lr = 0x82819E0C;
	sub_82510E40(ctx, base);
	// 82819E0C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82819E10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82819E14: 419A0008  beq cr6, 0x82819e1c
	if ctx.cr[6].eq {
	pc = 0x82819E1C; continue 'dispatch;
	}
	// 82819E18: 4BAA6A79  bl 0x822c0890
	ctx.lr = 0x82819E1C;
	sub_822C0890(ctx, base);
	// 82819E1C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82819E20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82819E24: 419A0008  beq cr6, 0x82819e2c
	if ctx.cr[6].eq {
	pc = 0x82819E2C; continue 'dispatch;
	}
	// 82819E28: 4BAA6A69  bl 0x822c0890
	ctx.lr = 0x82819E2C;
	sub_822C0890(ctx, base);
	// 82819E2C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82819E30: 485D9381  bl 0x82df31b0
	ctx.lr = 0x82819E34;
	sub_82DF31B0(ctx, base);
	// 82819E34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82819E38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82819E3C: 485D9BCD  bl 0x82df3a08
	ctx.lr = 0x82819E40;
	sub_82DF3A08(ctx, base);
	// 82819E40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82819E44: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82819E48: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 82819E4C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82819E50: 48614951  bl 0x82e2e7a0
	ctx.lr = 0x82819E54;
	sub_82E2E7A0(ctx, base);
	// 82819E54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82819E58: 485D95D1  bl 0x82df3428
	ctx.lr = 0x82819E5C;
	sub_82DF3428(ctx, base);
	// 82819E5C: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82819E60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82819E64: 419A0148  beq cr6, 0x82819fac
	if ctx.cr[6].eq {
	pc = 0x82819FAC; continue 'dispatch;
	}
	// 82819E68: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82819E6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82819E70: 38A000BF  li r5, 0xbf
	ctx.r[5].s64 = 191;
	// 82819E74: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82819E78: 4BAA6561  bl 0x822c03d8
	ctx.lr = 0x82819E7C;
	sub_822C03D8(ctx, base);
	// 82819E7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82819E80: 41820014  beq 0x82819e94
	if ctx.cr[0].eq {
	pc = 0x82819E94; continue 'dispatch;
	}
	// 82819E84: 389F00EC  addi r4, r31, 0xec
	ctx.r[4].s64 = ctx.r[31].s64 + 236;
	// 82819E88: 4BFD8041  bl 0x827f1ec8
	ctx.lr = 0x82819E8C;
	sub_827F1EC8(ctx, base);
	// 82819E8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82819E90: 48000008  b 0x82819e98
	pc = 0x82819E98; continue 'dispatch;
	// 82819E94: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82819E98: 3BDF0214  addi r30, r31, 0x214
	ctx.r[30].s64 = ctx.r[31].s64 + 532;
	// 82819E9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82819EA0: 4BEEE431  bl 0x827082d0
	ctx.lr = 0x82819EA4;
	sub_827082D0(ctx, base);
	// 82819EA4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82819EA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82819EAC: 839F0214  lwz r28, 0x214(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 82819EB0: 485D9B59  bl 0x82df3a08
	ctx.lr = 0x82819EB4;
	sub_82DF3A08(ctx, base);
	// 82819EB4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82819EB8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82819EBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82819EC0: 485D9D81  bl 0x82df3c40
	ctx.lr = 0x82819EC4;
	sub_82DF3C40(ctx, base);
	// 82819EC4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82819EC8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82819ECC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82819ED0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82819ED4: 4BFD80E5  bl 0x827f1fb8
	ctx.lr = 0x82819ED8;
	sub_827F1FB8(ctx, base);
	// 82819ED8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82819EDC: 485D954D  bl 0x82df3428
	ctx.lr = 0x82819EE0;
	sub_82DF3428(ctx, base);
	// 82819EE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82819EE4: 485D9545  bl 0x82df3428
	ctx.lr = 0x82819EE8;
	sub_82DF3428(ctx, base);
	// 82819EE8: 3D40827F  lis r10, -0x7d81
	ctx.r[10].s64 = -2105606144;
	// 82819EEC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82819EF0: 394A2050  addi r10, r10, 0x2050
	ctx.r[10].s64 = ctx.r[10].s64 + 8272;
	// 82819EF4: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82819EF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82819EFC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82819F00: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82819F04: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82819F08: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 82819F0C: 419A0024  beq cr6, 0x82819f30
	if ctx.cr[6].eq {
	pc = 0x82819F30; continue 'dispatch;
	}
	// 82819F10: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82819F14: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82819F18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82819F1C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82819F20: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82819F24: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82819F28: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82819F2C: 4082FFE8  bne 0x82819f14
	if !ctx.cr[0].eq {
	pc = 0x82819F14; continue 'dispatch;
	}
	// 82819F30: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82819F34: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819F38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82819F3C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82819F40: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82819F44: 419A0024  beq cr6, 0x82819f68
	if ctx.cr[6].eq {
	pc = 0x82819F68; continue 'dispatch;
	}
	// 82819F48: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82819F4C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82819F50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82819F54: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82819F58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82819F5C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82819F60: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82819F64: 4082FFE8  bne 0x82819f4c
	if !ctx.cr[0].eq {
	pc = 0x82819F4C; continue 'dispatch;
	}
	// 82819F68: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82819F6C: 88DAAE34  lbz r6, -0x51cc(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(-20940 as u32) ) } as u64;
	// 82819F70: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82819F74: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82819F78: 4BEEF001  bl 0x82708f78
	ctx.lr = 0x82819F7C;
	sub_82708F78(ctx, base);
	// 82819F7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82819F80: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82819F84: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82819F88: 4BEEF851  bl 0x827097d8
	ctx.lr = 0x82819F8C;
	sub_827097D8(ctx, base);
	// 82819F8C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82819F90: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82819F94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82819F98: 4BCF6EA9  bl 0x82510e40
	ctx.lr = 0x82819F9C;
	sub_82510E40(ctx, base);
	// 82819F9C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82819FA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82819FA4: 419A0008  beq cr6, 0x82819fac
	if ctx.cr[6].eq {
	pc = 0x82819FAC; continue 'dispatch;
	}
	// 82819FA8: 4BAA68E9  bl 0x822c0890
	ctx.lr = 0x82819FAC;
	sub_822C0890(ctx, base);
	// 82819FAC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82819FB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82819FB4: 419A0008  beq cr6, 0x82819fbc
	if ctx.cr[6].eq {
	pc = 0x82819FBC; continue 'dispatch;
	}
	// 82819FB8: 4BAA68D9  bl 0x822c0890
	ctx.lr = 0x82819FBC;
	sub_822C0890(ctx, base);
	// 82819FBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82819FC0: 485D9BE9  bl 0x82df3ba8
	ctx.lr = 0x82819FC4;
	sub_82DF3BA8(ctx, base);
	// 82819FC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82819FC8: 40820090  bne 0x8281a058
	if !ctx.cr[0].eq {
	pc = 0x8281A058; continue 'dispatch;
	}
	// 82819FCC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82819FD0: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82819FD4: 4BADE9F5  bl 0x822f89c8
	ctx.lr = 0x82819FD8;
	sub_822F89C8(ctx, base);
	// 82819FD8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82819FDC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82819FE0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82819FE4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82819FE8: 4BADEB69  bl 0x822f8b50
	ctx.lr = 0x82819FEC;
	sub_822F8B50(ctx, base);
	// 82819FEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82819FF0: 38BF0028  addi r5, r31, 0x28
	ctx.r[5].s64 = ctx.r[31].s64 + 40;
	// 82819FF4: 409A0008  bne cr6, 0x82819ffc
	if !ctx.cr[6].eq {
	pc = 0x82819FFC; continue 'dispatch;
	}
	// 82819FF8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82819FFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281A000: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281A004: 808100A0  lwz r4, 0xa0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 8281A008: 83BF01CC  lwz r29, 0x1cc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 8281A00C: 4BADE3D5  bl 0x822f83e0
	ctx.lr = 0x8281A010;
	sub_822F83E0(ctx, base);
	// 8281A010: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281A014: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8281A018: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281A01C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281A020: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281A024: 4E800421  bctrl
	ctx.lr = 0x8281A028;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281A028: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281A02C: 817E007C  lwz r11, 0x7c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 8281A030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A034: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8281A038: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281A03C: 4E800421  bctrl
	ctx.lr = 0x8281A040;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281A040: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 8281A044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281A048: 419A0008  beq cr6, 0x8281a050
	if ctx.cr[6].eq {
	pc = 0x8281A050; continue 'dispatch;
	}
	// 8281A04C: 4BAA6845  bl 0x822c0890
	ctx.lr = 0x8281A050;
	sub_822C0890(ctx, base);
	// 8281A050: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281A054: 4BADE98D  bl 0x822f89e0
	ctx.lr = 0x8281A058;
	sub_822F89E0(ctx, base);
	// 8281A058: 807F01D4  lwz r3, 0x1d4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 8281A05C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281A060: 419A0014  beq cr6, 0x8281a074
	if ctx.cr[6].eq {
	pc = 0x8281A074; continue 'dispatch;
	}
	// 8281A064: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8281A068: 38802001  li r4, 0x2001
	ctx.r[4].s64 = 8193;
	// 8281A06C: 80AB8610  lwz r5, -0x79f0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31216 as u32) ) } as u64;
	// 8281A070: 4BC75109  bl 0x8248f178
	ctx.lr = 0x8281A074;
	sub_8248F178(ctx, base);
	// 8281A074: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A078: 4BFD20E9  bl 0x827ec160
	ctx.lr = 0x8281A07C;
	sub_827EC160(ctx, base);
	// 8281A07C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281A080: 4182000C  beq 0x8281a08c
	if ctx.cr[0].eq {
	pc = 0x8281A08C; continue 'dispatch;
	}
	// 8281A084: 889F0251  lbz r4, 0x251(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(593 as u32) ) } as u64;
	// 8281A088: 48000769  bl 0x8281a7f0
	ctx.lr = 0x8281A08C;
	sub_8281A7F0(ctx, base);
	// 8281A08C: 3880000D  li r4, 0xd
	ctx.r[4].s64 = 13;
	// 8281A090: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8281A094: 4BCEE5ED  bl 0x82508680
	ctx.lr = 0x8281A098;
	sub_82508680(ctx, base);
	// 8281A098: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281A09C: 907F0234  stw r3, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[3].u32 ) };
	// 8281A0A0: 418200B8  beq 0x8281a158
	if ctx.cr[0].eq {
	pc = 0x8281A158; continue 'dispatch;
	}
	// 8281A0A4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8281A0A8: 4BFD64A1  bl 0x827f0548
	ctx.lr = 0x8281A0AC;
	sub_827F0548(ctx, base);
	// 8281A0AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281A0B0: C3E30008  lfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8281A0B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A0B8: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 8281A0BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281A0C0: 4E800421  bctrl
	ctx.lr = 0x8281A0C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281A0C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281A0C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281A0CC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8281A0D0: 48000DA1  bl 0x8281ae70
	ctx.lr = 0x8281A0D4;
	sub_8281AE70(ctx, base);
	// 8281A0D4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8281A0D8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8281A0DC: 4BFFE4CD  bl 0x828185a8
	ctx.lr = 0x8281A0E0;
	sub_828185A8(ctx, base);
	// 8281A0E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281A0E4: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 8281A0E8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281A0EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281A0F0: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 8281A0F4: 419A0024  beq cr6, 0x8281a118
	if ctx.cr[6].eq {
	pc = 0x8281A118; continue 'dispatch;
	}
	// 8281A0F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281A0FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281A100: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281A104: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281A108: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281A10C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281A110: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281A114: 4082FFE8  bne 0x8281a0fc
	if !ctx.cr[0].eq {
	pc = 0x8281A0FC; continue 'dispatch;
	}
	// 8281A118: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8281A11C: 80DF0234  lwz r6, 0x234(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 8281A120: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8281A124: 38E10088  addi r7, r1, 0x88
	ctx.r[7].s64 = ctx.r[1].s64 + 136;
	// 8281A128: 38A000D9  li r5, 0xd9
	ctx.r[5].s64 = 217;
	// 8281A12C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8281A130: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281A134: 4863E90D  bl 0x82e58a40
	ctx.lr = 0x8281A138;
	sub_82E58A40(ctx, base);
	// 8281A138: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 8281A13C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281A140: 419A0008  beq cr6, 0x8281a148
	if ctx.cr[6].eq {
	pc = 0x8281A148; continue 'dispatch;
	}
	// 8281A144: 4BAA674D  bl 0x822c0890
	ctx.lr = 0x8281A148;
	sub_822C0890(ctx, base);
	// 8281A148: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 8281A14C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281A150: 419A0008  beq cr6, 0x8281a158
	if ctx.cr[6].eq {
	pc = 0x8281A158; continue 'dispatch;
	}
	// 8281A154: 4BAA673D  bl 0x822c0890
	ctx.lr = 0x8281A158;
	sub_822C0890(ctx, base);
	// 8281A158: 817F022C  lwz r11, 0x22c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 8281A15C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281A160: 409A0014  bne cr6, 0x8281a174
	if !ctx.cr[6].eq {
	pc = 0x8281A174; continue 'dispatch;
	}
	// 8281A164: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 8281A168: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8281A16C: 4BCEE515  bl 0x82508680
	ctx.lr = 0x8281A170;
	sub_82508680(ctx, base);
	// 8281A170: 907F022C  stw r3, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[3].u32 ) };
	// 8281A174: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8281A178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281A17C: 409A0014  bne cr6, 0x8281a190
	if !ctx.cr[6].eq {
	pc = 0x8281A190; continue 'dispatch;
	}
	// 8281A180: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 8281A184: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8281A188: 4BCEE4F9  bl 0x82508680
	ctx.lr = 0x8281A18C;
	sub_82508680(ctx, base);
	// 8281A18C: 907F0238  stw r3, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[3].u32 ) };
	// 8281A190: 897F0252  lbz r11, 0x252(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(594 as u32) ) } as u64;
	// 8281A194: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281A198: 4182002C  beq 0x8281a1c4
	if ctx.cr[0].eq {
	pc = 0x8281A1C4; continue 'dispatch;
	}
	// 8281A19C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281A1A0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8281A1A4: 48291B45  bl 0x82aabce8
	ctx.lr = 0x8281A1A8;
	sub_82AABCE8(ctx, base);
	// 8281A1A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281A1AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A1B0: 4BFFDD69  bl 0x82817f18
	ctx.lr = 0x8281A1B4;
	sub_82817F18(ctx, base);
	// 8281A1B4: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 8281A1B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281A1BC: 419A0008  beq cr6, 0x8281a1c4
	if ctx.cr[6].eq {
	pc = 0x8281A1C4; continue 'dispatch;
	}
	// 8281A1C0: 4BAA66D1  bl 0x822c0890
	ctx.lr = 0x8281A1C4;
	sub_822C0890(ctx, base);
	// 8281A1C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281A1C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A1CC: 816B0074  lwz r11, 0x74(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 8281A1D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281A1D4: 4E800421  bctrl
	ctx.lr = 0x8281A1D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281A1D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281A1DC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8281A1E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281A1E4: 915F023C  stw r10, 0x23c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[10].u32 ) };
	// 8281A1E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281A1EC: 915F0240  stw r10, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[10].u32 ) };
	// 8281A1F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8281A1F4: 915F0244  stw r10, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[10].u32 ) };
	// 8281A1F8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8281A1FC: 917F0248  stw r11, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[11].u32 ) };
	// 8281A200: 48610901  bl 0x82e2ab00
	ctx.lr = 0x8281A204;
	sub_82E2AB00(ctx, base);
	// 8281A204: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281A208: 485D9221  bl 0x82df3428
	ctx.lr = 0x8281A20C;
	sub_82DF3428(ctx, base);
	// 8281A20C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8281A210: 485D9219  bl 0x82df3428
	ctx.lr = 0x8281A214;
	sub_82DF3428(ctx, base);
	// 8281A214: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 8281A218: 485D9211  bl 0x82df3428
	ctx.lr = 0x8281A21C;
	sub_82DF3428(ctx, base);
	// 8281A21C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8281A220: 48000008  b 0x8281a228
	pc = 0x8281A228; continue 'dispatch;
	// 8281A224: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8281A228: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 8281A22C: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 8281A230: 4898DF74  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281A238 size=348
    let mut pc: u32 = 0x8281A238;
    'dispatch: loop {
        match pc {
            0x8281A238 => {
    //   block [0x8281A238..0x8281A394)
	// 8281A238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281A23C: 4898DF21  bl 0x831a815c
	ctx.lr = 0x8281A240;
	sub_831A8130(ctx, base);
	// 8281A240: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281A244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281A248: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8281A24C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 8281A250: 4BFD0BD9  bl 0x827eae28
	ctx.lr = 0x8281A254;
	sub_827EAE28(ctx, base);
	// 8281A254: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8281A258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A25C: 4BCF5115  bl 0x8250f370
	ctx.lr = 0x8281A260;
	sub_8250F370(ctx, base);
	// 8281A260: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281A264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A268: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8281A26C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281A270: 4E800421  bctrl
	ctx.lr = 0x8281A274;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281A274: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8281A278: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281A27C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281A280: 4BFFE2B1  bl 0x82818530
	ctx.lr = 0x8281A284;
	sub_82818530(ctx, base);
	// 8281A284: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 8281A288: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281A28C: 4BCEE3F5  bl 0x82508680
	ctx.lr = 0x8281A290;
	sub_82508680(ctx, base);
	// 8281A290: 83210064  lwz r25, 0x64(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8281A294: 83810060  lwz r28, 0x60(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8281A298: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281A29C: 907F0230  stw r3, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[3].u32 ) };
	// 8281A2A0: 41820060  beq 0x8281a300
	if ctx.cr[0].eq {
	pc = 0x8281A300; continue 'dispatch;
	}
	// 8281A2A4: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8281A2A8: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8281A2AC: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 8281A2B0: 419A0024  beq cr6, 0x8281a2d4
	if ctx.cr[6].eq {
	pc = 0x8281A2D4; continue 'dispatch;
	}
	// 8281A2B4: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 8281A2B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281A2BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281A2C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281A2C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281A2C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281A2CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281A2D0: 4082FFE8  bne 0x8281a2b8
	if !ctx.cr[0].eq {
	pc = 0x8281A2B8; continue 'dispatch;
	}
	// 8281A2D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281A2D8: 80DF0230  lwz r6, 0x230(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 8281A2DC: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8281A2E0: 388B9750  addi r4, r11, -0x68b0
	ctx.r[4].s64 = ctx.r[11].s64 + -26800;
	// 8281A2E4: 38A00093  li r5, 0x93
	ctx.r[5].s64 = 147;
	// 8281A2E8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8281A2EC: 4863CCFD  bl 0x82e56fe8
	ctx.lr = 0x8281A2F0;
	sub_82E56FE8(ctx, base);
	// 8281A2F0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281A2F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281A2F8: 419A0008  beq cr6, 0x8281a300
	if ctx.cr[6].eq {
	pc = 0x8281A300; continue 'dispatch;
	}
	// 8281A2FC: 4BAA6595  bl 0x822c0890
	ctx.lr = 0x8281A300;
	sub_822C0890(ctx, base);
	// 8281A300: 83BC0020  lwz r29, 0x20(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 8281A304: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8281A308: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 8281A30C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8281A310: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8281A314: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8281A318: 419A0024  beq cr6, 0x8281a33c
	if ctx.cr[6].eq {
	pc = 0x8281A33C; continue 'dispatch;
	}
	// 8281A31C: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 8281A320: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8281A324: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281A328: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8281A32C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8281A330: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281A334: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281A338: 4082FFE8  bne 0x8281a320
	if !ctx.cr[0].eq {
	pc = 0x8281A320; continue 'dispatch;
	}
	// 8281A33C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281A340: 419A001C  beq cr6, 0x8281a35c
	if ctx.cr[6].eq {
	pc = 0x8281A35C; continue 'dispatch;
	}
	// 8281A344: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8281A348: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 8281A34C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281A350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A354: 4BFFF86D  bl 0x82819bc0
	ctx.lr = 0x8281A358;
	sub_82819BC0(ctx, base);
	// 8281A358: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8281A35C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8281A360: 419A000C  beq cr6, 0x8281a36c
	if ctx.cr[6].eq {
	pc = 0x8281A36C; continue 'dispatch;
	}
	// 8281A364: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281A368: 4BAA6529  bl 0x822c0890
	ctx.lr = 0x8281A36C;
	sub_822C0890(ctx, base);
	// 8281A36C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281A370: 4082000C  bne 0x8281a37c
	if !ctx.cr[0].eq {
	pc = 0x8281A37C; continue 'dispatch;
	}
	// 8281A374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A378: 4BCF6259  bl 0x825105d0
	ctx.lr = 0x8281A37C;
	sub_825105D0(ctx, base);
	// 8281A37C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8281A380: 419A000C  beq cr6, 0x8281a38c
	if ctx.cr[6].eq {
	pc = 0x8281A38C; continue 'dispatch;
	}
	// 8281A384: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8281A388: 4BAA6509  bl 0x822c0890
	ctx.lr = 0x8281A38C;
	sub_822C0890(ctx, base);
	// 8281A38C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8281A390: 4898DE1C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281A398 size=4
    let mut pc: u32 = 0x8281A398;
    'dispatch: loop {
        match pc {
            0x8281A398 => {
    //   block [0x8281A398..0x8281A39C)
	// 8281A398: 4BFD38C8  b 0x827edc60
	sub_827EDC60(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281A3A0 size=16
    let mut pc: u32 = 0x8281A3A0;
    'dispatch: loop {
        match pc {
            0x8281A3A0 => {
    //   block [0x8281A3A0..0x8281A3B0)
	// 8281A3A0: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281A3A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281A3A8: 419A0008  beq cr6, 0x8281a3b0
	if ctx.cr[6].eq {
		sub_8281A3B0(ctx, base);
		return;
	}
	// 8281A3AC: 4BFFD1EC  b 0x82817598
	sub_82817598(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281A3B0 size=8
    let mut pc: u32 = 0x8281A3B0;
    'dispatch: loop {
        match pc {
            0x8281A3B0 => {
    //   block [0x8281A3B0..0x8281A3B8)
	// 8281A3B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8281A3B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281A3B8 size=8
    let mut pc: u32 = 0x8281A3B8;
    'dispatch: loop {
        match pc {
            0x8281A3B8 => {
    //   block [0x8281A3B8..0x8281A3C0)
	// 8281A3B8: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281A3BC: 4BFFE70C  b 0x82818ac8
	sub_82818AC8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281A3C0 size=36
    let mut pc: u32 = 0x8281A3C0;
    'dispatch: loop {
        match pc {
            0x8281A3C0 => {
    //   block [0x8281A3C0..0x8281A3E4)
	// 8281A3C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281A3C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281A3C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281A3CC: 4BFD344D  bl 0x827ed818
	ctx.lr = 0x8281A3D0;
	sub_827ED818(ctx, base);
	// 8281A3D0: 4BFD1E11  bl 0x827ec1e0
	ctx.lr = 0x8281A3D4;
	sub_827EC1E0(ctx, base);
	// 8281A3D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8281A3D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281A3DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281A3E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281A3E8 size=12
    let mut pc: u32 = 0x8281A3E8;
    'dispatch: loop {
        match pc {
            0x8281A3E8 => {
    //   block [0x8281A3E8..0x8281A3F4)
	// 8281A3E8: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281A3EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281A3F0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A3F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281A3F4 size=8
    let mut pc: u32 = 0x8281A3F4;
    'dispatch: loop {
        match pc {
            0x8281A3F4 => {
    //   block [0x8281A3F4..0x8281A3FC)
	// 8281A3F4: 4BFFE014  b 0x82818408
	sub_82818408(ctx, base);
	return;
	// 8281A3F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281A400 size=12
    let mut pc: u32 = 0x8281A400;
    'dispatch: loop {
        match pc {
            0x8281A400 => {
    //   block [0x8281A400..0x8281A40C)
	// 8281A400: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281A404: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281A408: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A40C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281A40C size=8
    let mut pc: u32 = 0x8281A40C;
    'dispatch: loop {
        match pc {
            0x8281A40C => {
    //   block [0x8281A40C..0x8281A414)
	// 8281A40C: 4BFFD2FC  b 0x82817708
	sub_82817708(ctx, base);
	return;
	// 8281A410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281A418 size=64
    let mut pc: u32 = 0x8281A418;
    'dispatch: loop {
        match pc {
            0x8281A418 => {
    //   block [0x8281A418..0x8281A458)
	// 8281A418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281A41C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281A420: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281A424: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281A428: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281A42C: 4BFD33ED  bl 0x827ed818
	ctx.lr = 0x8281A430;
	sub_827ED818(ctx, base);
	// 8281A430: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281A434: 41820010  beq 0x8281a444
	if ctx.cr[0].eq {
	pc = 0x8281A444; continue 'dispatch;
	}
	// 8281A438: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8281A43C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281A440: 4BFD2C31  bl 0x827ed070
	ctx.lr = 0x8281A444;
	sub_827ED070(ctx, base);
	// 8281A444: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8281A448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281A44C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281A450: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281A454: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281A458 size=8
    let mut pc: u32 = 0x8281A458;
    'dispatch: loop {
        match pc {
            0x8281A458 => {
    //   block [0x8281A458..0x8281A460)
	// 8281A458: 806300E0  lwz r3, 0xe0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) } as u64;
	// 8281A45C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281A460 size=72
    let mut pc: u32 = 0x8281A460;
    'dispatch: loop {
        match pc {
            0x8281A460 => {
    //   block [0x8281A460..0x8281A4A8)
	// 8281A460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281A464: 4898DD09  bl 0x831a816c
	ctx.lr = 0x8281A468;
	sub_831A8130(ctx, base);
	// 8281A468: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281A46C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281A470: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8281A474: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8281A478: 4BFD33A1  bl 0x827ed818
	ctx.lr = 0x8281A47C;
	sub_827ED818(ctx, base);
	// 8281A47C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281A480: 41820010  beq 0x8281a490
	if ctx.cr[0].eq {
	pc = 0x8281A490; continue 'dispatch;
	}
	// 8281A484: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8281A488: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281A48C: 4BFD2BE5  bl 0x827ed070
	ctx.lr = 0x8281A490;
	sub_827ED070(ctx, base);
	// 8281A490: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281A494: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281A498: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 8281A49C: 4BFDDF6D  bl 0x827f8408
	ctx.lr = 0x8281A4A0;
	sub_827F8408(ctx, base);
	// 8281A4A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281A4A4: 4898DD18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281A4A8 size=8
    let mut pc: u32 = 0x8281A4A8;
    'dispatch: loop {
        match pc {
            0x8281A4A8 => {
    //   block [0x8281A4A8..0x8281A4B0)
	// 8281A4A8: 806300E8  lwz r3, 0xe8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) } as u64;
	// 8281A4AC: 4BFDDE64  b 0x827f8310
	sub_827F8310(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281A4B0 size=8
    let mut pc: u32 = 0x8281A4B0;
    'dispatch: loop {
        match pc {
            0x8281A4B0 => {
    //   block [0x8281A4B0..0x8281A4B8)
	// 8281A4B0: 806300E8  lwz r3, 0xe8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) } as u64;
	// 8281A4B4: 4BFDDD34  b 0x827f81e8
	sub_827F81E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281A4B8 size=8
    let mut pc: u32 = 0x8281A4B8;
    'dispatch: loop {
        match pc {
            0x8281A4B8 => {
    //   block [0x8281A4B8..0x8281A4C0)
	// 8281A4B8: 806300E8  lwz r3, 0xe8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) } as u64;
	// 8281A4BC: 4BFDDABC  b 0x827f7f78
	sub_827F7F78(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281A4C0 size=8
    let mut pc: u32 = 0x8281A4C0;
    'dispatch: loop {
        match pc {
            0x8281A4C0 => {
    //   block [0x8281A4C0..0x8281A4C8)
	// 8281A4C0: 806300E8  lwz r3, 0xe8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) } as u64;
	// 8281A4C4: 4BFDDBB4  b 0x827f8078
	sub_827F8078(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281A4C8 size=108
    let mut pc: u32 = 0x8281A4C8;
    'dispatch: loop {
        match pc {
            0x8281A4C8 => {
    //   block [0x8281A4C8..0x8281A534)
	// 8281A4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281A4CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281A4D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281A4D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281A4D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281A4DC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281A4E0: 396B984C  addi r11, r11, -0x67b4
	ctx.r[11].s64 = ctx.r[11].s64 + -26548;
	// 8281A4E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281A4E8: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 8281A4EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281A4F0: 419A0008  beq cr6, 0x8281a4f8
	if ctx.cr[6].eq {
	pc = 0x8281A4F8; continue 'dispatch;
	}
	// 8281A4F4: 4BAA639D  bl 0x822c0890
	ctx.lr = 0x8281A4F8;
	sub_822C0890(ctx, base);
	// 8281A4F8: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 8281A4FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281A500: 419A0008  beq cr6, 0x8281a508
	if ctx.cr[6].eq {
	pc = 0x8281A508; continue 'dispatch;
	}
	// 8281A504: 4BAA638D  bl 0x822c0890
	ctx.lr = 0x8281A508;
	sub_822C0890(ctx, base);
	// 8281A508: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 8281A50C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281A510: 419A0008  beq cr6, 0x8281a518
	if ctx.cr[6].eq {
	pc = 0x8281A518; continue 'dispatch;
	}
	// 8281A514: 4BAA637D  bl 0x822c0890
	ctx.lr = 0x8281A518;
	sub_822C0890(ctx, base);
	// 8281A518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A51C: 4BFD4F2D  bl 0x827ef448
	ctx.lr = 0x8281A520;
	sub_827EF448(ctx, base);
	// 8281A520: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8281A524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281A528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281A52C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281A530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281A538 size=100
    let mut pc: u32 = 0x8281A538;
    'dispatch: loop {
        match pc {
            0x8281A538 => {
    //   block [0x8281A538..0x8281A59C)
	// 8281A538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281A53C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281A540: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281A544: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281A548: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281A54C: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8281A550: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8281A554: 397F00F0  addi r11, r31, 0xf0
	ctx.r[11].s64 = ctx.r[31].s64 + 240;
	// 8281A558: 813F00F0  lwz r9, 0xf0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281A5A0 size=188
    let mut pc: u32 = 0x8281A5A0;
    'dispatch: loop {
        match pc {
            0x8281A5A0 => {
    //   block [0x8281A5A0..0x8281A65C)
	// 8281A5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281A5A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281A5A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281A5AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281A5B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281A5B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281A5B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281A5BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8281A5C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281A5C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281A5C8: 4BAA6371  bl 0x822c0938
	ctx.lr = 0x8281A5CC;
	sub_822C0938(ctx, base);
	// 8281A5CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281A5D0: 41820028  beq 0x8281a5f8
	if ctx.cr[0].eq {
	pc = 0x8281A5F8; continue 'dispatch;
	}
	// 8281A5D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281A5D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8281A5DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8281A5E0: 392B9824  addi r9, r11, -0x67dc
	ctx.r[9].s64 = ctx.r[11].s64 + -26588;
	// 8281A5E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8281A5E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281A5EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8281A5F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8281A5F4: 48000008  b 0x8281a5fc
	pc = 0x8281A5FC; continue 'dispatch;
	// 8281A5F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281A5FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281A600: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281A604: 409A003C  bne cr6, 0x8281a640
	if !ctx.cr[6].eq {
	pc = 0x8281A640; continue 'dispatch;
	}
	// 8281A608: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281A60C: 419A0014  beq cr6, 0x8281a620
	if ctx.cr[6].eq {
	pc = 0x8281A620; continue 'dispatch;
	}
	// 8281A610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A614: 4BFB7785  bl 0x827d1d98
	ctx.lr = 0x8281A618;
	sub_827D1D98(ctx, base);
	// 8281A618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A61C: 485D7DBD  bl 0x82df23d8
	ctx.lr = 0x8281A620;
	sub_82DF23D8(ctx, base);
	// 8281A620: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281A624: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8281A628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281A62C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8281A630: 816BF6BC  lwz r11, -0x944(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2372 as u32) ) } as u64;
	// 8281A634: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8281A638: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281A63C: 4BAA59C5  bl 0x822c0000
	ctx.lr = 0x8281A640;
	sub_822C0000(ctx, base);
	// 8281A640: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281A644: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281A648: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281A64C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281A650: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281A654: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281A658: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281A660 size=188
    let mut pc: u32 = 0x8281A660;
    'dispatch: loop {
        match pc {
            0x8281A660 => {
    //   block [0x8281A660..0x8281A71C)
	// 8281A660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281A664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281A668: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281A66C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281A670: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281A674: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281A678: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281A67C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8281A680: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281A684: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281A688: 4BAA62B1  bl 0x822c0938
	ctx.lr = 0x8281A68C;
	sub_822C0938(ctx, base);
	// 8281A68C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281A690: 41820028  beq 0x8281a6b8
	if ctx.cr[0].eq {
	pc = 0x8281A6B8; continue 'dispatch;
	}
	// 8281A694: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281A698: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8281A69C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8281A6A0: 392B9838  addi r9, r11, -0x67c8
	ctx.r[9].s64 = ctx.r[11].s64 + -26568;
	// 8281A6A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8281A6A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281A6AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8281A6B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8281A6B4: 48000008  b 0x8281a6bc
	pc = 0x8281A6BC; continue 'dispatch;
	// 8281A6B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281A6BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281A6C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281A6C4: 409A003C  bne cr6, 0x8281a700
	if !ctx.cr[6].eq {
	pc = 0x8281A700; continue 'dispatch;
	}
	// 8281A6C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281A6CC: 419A0014  beq cr6, 0x8281a6e0
	if ctx.cr[6].eq {
	pc = 0x8281A6E0; continue 'dispatch;
	}
	// 8281A6D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A6D4: 4BFDDE55  bl 0x827f8528
	ctx.lr = 0x8281A6D8;
	sub_827F8528(ctx, base);
	// 8281A6D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A6DC: 4BAA5B8D  bl 0x822c0268
	ctx.lr = 0x8281A6E0;
	sub_822C0268(ctx, base);
	// 8281A6E0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281A6E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8281A6E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281A6EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8281A6F0: 816BF6BC  lwz r11, -0x944(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2372 as u32) ) } as u64;
	// 8281A6F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8281A6F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281A6FC: 4BAA5905  bl 0x822c0000
	ctx.lr = 0x8281A700;
	sub_822C0000(ctx, base);
	// 8281A700: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281A704: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281A708: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281A70C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281A710: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281A714: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281A718: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281A720 size=64
    let mut pc: u32 = 0x8281A720;
    'dispatch: loop {
        match pc {
            0x8281A720 => {
    //   block [0x8281A720..0x8281A760)
	// 8281A720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281A724: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281A728: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281A72C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281A730: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8281A734: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281A738: 419A0014  beq cr6, 0x8281a74c
	if ctx.cr[6].eq {
	pc = 0x8281A74C; continue 'dispatch;
	}
	// 8281A73C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A740: 4BFB7659  bl 0x827d1d98
	ctx.lr = 0x8281A744;
	sub_827D1D98(ctx, base);
	// 8281A744: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A748: 485D7C91  bl 0x82df23d8
	ctx.lr = 0x8281A74C;
	sub_82DF23D8(ctx, base);
	// 8281A74C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8281A750: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281A754: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281A758: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281A75C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281A760 size=64
    let mut pc: u32 = 0x8281A760;
    'dispatch: loop {
        match pc {
            0x8281A760 => {
    //   block [0x8281A760..0x8281A7A0)
	// 8281A760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281A764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281A768: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281A76C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281A770: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8281A774: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281A778: 419A0014  beq cr6, 0x8281a78c
	if ctx.cr[6].eq {
	pc = 0x8281A78C; continue 'dispatch;
	}
	// 8281A77C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A780: 4BFDDDA9  bl 0x827f8528
	ctx.lr = 0x8281A784;
	sub_827F8528(ctx, base);
	// 8281A784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A788: 4BAA5AE1  bl 0x822c0268
	ctx.lr = 0x8281A78C;
	sub_822C0268(ctx, base);
	// 8281A78C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8281A790: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281A794: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281A798: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281A79C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281A7A0 size=76
    let mut pc: u32 = 0x8281A7A0;
    'dispatch: loop {
        match pc {
            0x8281A7A0 => {
    //   block [0x8281A7A0..0x8281A7EC)
	// 8281A7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281A7A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281A7A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281A7AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281A7B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281A7B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281A7B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281A7BC: 4BFFFD0D  bl 0x8281a4c8
	ctx.lr = 0x8281A7C0;
	sub_8281A4C8(ctx, base);
	// 8281A7C0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281A7C4: 4182000C  beq 0x8281a7d0
	if ctx.cr[0].eq {
	pc = 0x8281A7D0; continue 'dispatch;
	}
	// 8281A7C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A7CC: 4BAA5A9D  bl 0x822c0268
	ctx.lr = 0x8281A7D0;
	sub_822C0268(ctx, base);
	// 8281A7D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A7D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281A7D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281A7DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281A7E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281A7E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281A7E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281A7F0 size=140
    let mut pc: u32 = 0x8281A7F0;
    'dispatch: loop {
        match pc {
            0x8281A7F0 => {
    //   block [0x8281A7F0..0x8281A87C)
	// 8281A7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281A7F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281A7F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281A7FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281A800: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281A804: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281A808: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281A80C: 41820030  beq 0x8281a83c
	if ctx.cr[0].eq {
	pc = 0x8281A83C; continue 'dispatch;
	}
	// 8281A810: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281A814: 83DF00E0  lwz r30, 0xe0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 8281A818: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281A81C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281A820: 4E800421  bctrl
	ctx.lr = 0x8281A824;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281A824: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8281A828: 389F00F0  addi r4, r31, 0xf0
	ctx.r[4].s64 = ctx.r[31].s64 + 240;
	// 8281A82C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281A830: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281A834: 4BFDD565  bl 0x827f7d98
	ctx.lr = 0x8281A838;
	sub_827F7D98(ctx, base);
	// 8281A838: 4800002C  b 0x8281a864
	pc = 0x8281A864; continue 'dispatch;
	// 8281A83C: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 8281A840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281A844: 419A0020  beq cr6, 0x8281a864
	if ctx.cr[6].eq {
	pc = 0x8281A864; continue 'dispatch;
	}
	// 8281A848: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281A84C: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 8281A850: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 8281A854: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281A858: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 8281A85C: 419A0008  beq cr6, 0x8281a864
	if ctx.cr[6].eq {
	pc = 0x8281A864; continue 'dispatch;
	}
	// 8281A860: 4BAA6031  bl 0x822c0890
	ctx.lr = 0x8281A864;
	sub_822C0890(ctx, base);
	// 8281A864: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281A868: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281A86C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281A870: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281A874: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281A878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281A880 size=260
    let mut pc: u32 = 0x8281A880;
    'dispatch: loop {
        match pc {
            0x8281A880 => {
    //   block [0x8281A880..0x8281A984)
	// 8281A880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281A884: 4898D8DD  bl 0x831a8160
	ctx.lr = 0x8281A888;
	sub_831A8130(ctx, base);
	// 8281A888: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281A88C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281A890: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8281A894: 4804A32D  bl 0x82864bc0
	ctx.lr = 0x8281A898;
	sub_82864BC0(ctx, base);
	// 8281A898: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8281A89C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8281A8A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A8A4: 4BFD4C15  bl 0x827ef4b8
	ctx.lr = 0x8281A8A8;
	sub_827EF4B8(ctx, base);
	// 8281A8A8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8281A8AC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281A8B0: 394A984C  addi r10, r10, -0x67b4
	ctx.r[10].s64 = ctx.r[10].s64 + -26548;
	// 8281A8B4: 3B8B9878  addi r28, r11, -0x6788
	ctx.r[28].s64 = ctx.r[11].s64 + -26504;
	// 8281A8B8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8281A8BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281A8C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8281A8C4: 38A0002E  li r5, 0x2e
	ctx.r[5].s64 = 46;
	// 8281A8C8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8281A8CC: 485D7B1D  bl 0x82df23e8
	ctx.lr = 0x8281A8D0;
	sub_82DF23E8(ctx, base);
	// 8281A8D0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8281A8D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281A8D8: 41820014  beq 0x8281a8ec
	if ctx.cr[0].eq {
	pc = 0x8281A8EC; continue 'dispatch;
	}
	// 8281A8DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8281A8E0: 4BFDD179  bl 0x827f7a58
	ctx.lr = 0x8281A8E4;
	sub_827F7A58(ctx, base);
	// 8281A8E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281A8E8: 48000008  b 0x8281a8f0
	pc = 0x8281A8F0; continue 'dispatch;
	// 8281A8EC: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 8281A8F0: 93DF00E0  stw r30, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[30].u32 ) };
	// 8281A8F4: 397F00E0  addi r11, r31, 0xe0
	ctx.r[11].s64 = ctx.r[31].s64 + 224;
	// 8281A8F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281A8FC: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 8281A900: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281A904: 4BFFFC9D  bl 0x8281a5a0
	ctx.lr = 0x8281A908;
	sub_8281A5A0(ctx, base);
	// 8281A908: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8281A90C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281A910: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281A914: 4BAA56ED  bl 0x822c0000
	ctx.lr = 0x8281A918;
	sub_822C0000(ctx, base);
	// 8281A918: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8281A91C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281A920: 38A0002F  li r5, 0x2f
	ctx.r[5].s64 = 47;
	// 8281A924: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8281A928: 4BAA5AB1  bl 0x822c03d8
	ctx.lr = 0x8281A92C;
	sub_822C03D8(ctx, base);
	// 8281A92C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281A930: 41820014  beq 0x8281a944
	if ctx.cr[0].eq {
	pc = 0x8281A944; continue 'dispatch;
	}
	// 8281A934: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8281A938: 4BFDDBF9  bl 0x827f8530
	ctx.lr = 0x8281A93C;
	sub_827F8530(ctx, base);
	// 8281A93C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281A940: 48000008  b 0x8281a948
	pc = 0x8281A948; continue 'dispatch;
	// 8281A944: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 8281A948: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 8281A94C: 397F00E8  addi r11, r31, 0xe8
	ctx.r[11].s64 = ctx.r[31].s64 + 232;
	// 8281A950: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281A954: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 8281A958: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281A95C: 4BFFFD05  bl 0x8281a660
	ctx.lr = 0x8281A960;
	sub_8281A660(ctx, base);
	// 8281A960: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8281A964: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281A968: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281A96C: 4BAA5695  bl 0x822c0000
	ctx.lr = 0x8281A970;
	sub_822C0000(ctx, base);
	// 8281A970: 935F00F0  stw r26, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[26].u32 ) };
	// 8281A974: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A978: 935F00F4  stw r26, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[26].u32 ) };
	// 8281A97C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8281A980: 4898D830  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281A988 size=92
    let mut pc: u32 = 0x8281A988;
    'dispatch: loop {
        match pc {
            0x8281A988 => {
    //   block [0x8281A988..0x8281A9E4)
	// 8281A988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281A98C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281A990: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281A994: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281A998: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281A99C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281A9A0: 419A0030  beq cr6, 0x8281a9d0
	if ctx.cr[6].eq {
	pc = 0x8281A9D0; continue 'dispatch;
	}
	// 8281A9A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8281A9A8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281A9AC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281A9B0: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 8281A9B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281A9B8: 4E800421  bctrl
	ctx.lr = 0x8281A9BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281A9BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281A9C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281A9C4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8281A9C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281A9CC: 4E800421  bctrl
	ctx.lr = 0x8281A9D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281A9D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8281A9D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281A9D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281A9DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281A9E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281A9E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281A9E8 size=280
    let mut pc: u32 = 0x8281A9E8;
    'dispatch: loop {
        match pc {
            0x8281A9E8 => {
    //   block [0x8281A9E8..0x8281AB00)
	// 8281A9E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281A9EC: 4898D77D  bl 0x831a8168
	ctx.lr = 0x8281A9F0;
	sub_831A8130(ctx, base);
	// 8281A9F0: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 8281A9F4: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8281A9F8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281A9FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281AA00: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 8281AA04: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8281AA08: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8281AA0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281AA10: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281AA14: 4BC77565  bl 0x82491f78
	ctx.lr = 0x8281AA18;
	sub_82491F78(ctx, base);
	// 8281AA18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8281AA1C: FC00F050  fneg f0, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 8281AA20: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8281AA24: 13C0F8C7  vcmpequd (lvx128) v30, v0, v31
	tmp.u32 = ctx.r[31].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8281AA28: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8281AA2C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 8281AA30: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8281AA34: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281AA38: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8281AA3C: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8281AA40: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8281AA44: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8281AA48: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8281AA4C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8281AA50: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8281AA54: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8281AA58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8281AA5C: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281AB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281AB00 size=236
    let mut pc: u32 = 0x8281AB00;
    'dispatch: loop {
        match pc {
            0x8281AB00 => {
    //   block [0x8281AB00..0x8281ABEC)
	// 8281AB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281AB04: 4898D661  bl 0x831a8164
	ctx.lr = 0x8281AB08;
	sub_831A8130(ctx, base);
	// 8281AB08: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281AB0C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8281AB10: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8281AB14: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8281AB18: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8281AB1C: 419A00C8  beq cr6, 0x8281abe4
	if ctx.cr[6].eq {
	pc = 0x8281ABE4; continue 'dispatch;
	}
	// 8281AB20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281AB24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281AB28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281AB2C: 4BB59975  bl 0x823744a0
	ctx.lr = 0x8281AB30;
	sub_823744A0(ctx, base);
	// 8281AB30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281AB34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8281AB38: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8281AB3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281AB40: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8281AB44: 4BAA991D  bl 0x822c4460
	ctx.lr = 0x8281AB48;
	sub_822C4460(ctx, base);
	// 8281AB48: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8281AB4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281AB50: 419A0008  beq cr6, 0x8281ab58
	if ctx.cr[6].eq {
	pc = 0x8281AB58; continue 'dispatch;
	}
	// 8281AB54: 4BAA5D3D  bl 0x822c0890
	ctx.lr = 0x8281AB58;
	sub_822C0890(ctx, base);
	// 8281AB58: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8281AB5C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8281AB60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281AB64: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8281AB68: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8281AB6C: 419A0024  beq cr6, 0x8281ab90
	if ctx.cr[6].eq {
	pc = 0x8281AB90; continue 'dispatch;
	}
	// 8281AB70: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8281AB74: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281AB78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281AB7C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281AB80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281AB84: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281AB88: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281AB8C: 4082FFE8  bne 0x8281ab74
	if !ctx.cr[0].eq {
	pc = 0x8281AB74; continue 'dispatch;
	}
	// 8281AB90: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281AB94: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8281AB98: 388B98C8  addi r4, r11, -0x6738
	ctx.r[4].s64 = ctx.r[11].s64 + -26424;
	// 8281AB9C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8281ABA0: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 8281ABA4: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 8281ABA8: 4863C441  bl 0x82e56fe8
	ctx.lr = 0x8281ABAC;
	sub_82E56FE8(ctx, base);
	// 8281ABAC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281ABB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281ABB4: 419A0008  beq cr6, 0x8281abbc
	if ctx.cr[6].eq {
	pc = 0x8281ABBC; continue 'dispatch;
	}
	// 8281ABB8: 4BAA5CD9  bl 0x822c0890
	ctx.lr = 0x8281ABBC;
	sub_822C0890(ctx, base);
	// 8281ABBC: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8281ABC0: 397E0018  addi r11, r30, 0x18
	ctx.r[11].s64 = ctx.r[30].s64 + 24;
	// 8281ABC4: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 8281ABC8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8281ABCC: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8281ABD0: 4BAA9891  bl 0x822c4460
	ctx.lr = 0x8281ABD4;
	sub_822C4460(ctx, base);
	// 8281ABD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281ABD8: 419A000C  beq cr6, 0x8281abe4
	if ctx.cr[6].eq {
	pc = 0x8281ABE4; continue 'dispatch;
	}
	// 8281ABDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281ABE0: 4BAA5CB1  bl 0x822c0890
	ctx.lr = 0x8281ABE4;
	sub_822C0890(ctx, base);
	// 8281ABE4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8281ABE8: 4898D5CC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281ABF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281ABF0 size=88
    let mut pc: u32 = 0x8281ABF0;
    'dispatch: loop {
        match pc {
            0x8281ABF0 => {
    //   block [0x8281ABF0..0x8281AC48)
	// 8281ABF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281ABF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281ABF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281ABFC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281AC00: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8281AC04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281AC08: 808B67A0  lwz r4, 0x67a0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26528 as u32) ) } as u64;
	// 8281AC0C: 4BACA325  bl 0x822e4f30
	ctx.lr = 0x8281AC10;
	sub_822E4F30(ctx, base);
	// 8281AC10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281AC14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281AC18: 4BACA2A9  bl 0x822e4ec0
	ctx.lr = 0x8281AC1C;
	sub_822E4EC0(ctx, base);
	// 8281AC1C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8281AC20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281AC24: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 8281AC28: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8281AC2C: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8281AC30: 4BC71659  bl 0x8248c288
	ctx.lr = 0x8281AC34;
	sub_8248C288(ctx, base);
	// 8281AC34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281AC38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281AC3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281AC40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281AC44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281AC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281AC48 size=268
    let mut pc: u32 = 0x8281AC48;
    'dispatch: loop {
        match pc {
            0x8281AC48 => {
    //   block [0x8281AC48..0x8281AD54)
	// 8281AC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281AC4C: 4898D519  bl 0x831a8164
	ctx.lr = 0x8281AC50;
	sub_831A8130(ctx, base);
	// 8281AC50: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8281AC54: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281AC58: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8281AC5C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8281AC60: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8281AC64: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8281AC68: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8281AC6C: 4BFFFF85  bl 0x8281abf0
	ctx.lr = 0x8281AC70;
	sub_8281ABF0(ctx, base);
	// 8281AC70: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281AC74: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8281AC78: 388B98C8  addi r4, r11, -0x6738
	ctx.r[4].s64 = ctx.r[11].s64 + -26424;
	// 8281AC7C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281AC80: 38A00035  li r5, 0x35
	ctx.r[5].s64 = 53;
	// 8281AC84: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8281AC88: 4BAA5751  bl 0x822c03d8
	ctx.lr = 0x8281AC8C;
	sub_822C03D8(ctx, base);
	// 8281AC8C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8281AC90: 41820060  beq 0x8281acf0
	if ctx.cr[0].eq {
	pc = 0x8281ACF0; continue 'dispatch;
	}
	// 8281AC94: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281AC98: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8281AC9C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8281ACA0: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8281ACA4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8281ACA8: 48685A89  bl 0x82ea0730
	ctx.lr = 0x8281ACAC;
	sub_82EA0730(ctx, base);
	// 8281ACAC: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 8281ACB0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8281ACB4: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 8281ACB8: 486FF539  bl 0x82f1a1f0
	ctx.lr = 0x8281ACBC;
	sub_82F1A1F0(ctx, base);
	// 8281ACBC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8281ACC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281ACC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281ACC8: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 8281ACCC: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 8281ACD0: 4BCF4849  bl 0x8250f518
	ctx.lr = 0x8281ACD4;
	sub_8250F518(ctx, base);
	// 8281ACD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281ACD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281ACDC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8281ACE0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8281ACE4: 4BC7750D  bl 0x824921f0
	ctx.lr = 0x8281ACE8;
	sub_824921F0(ctx, base);
	// 8281ACE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281ACEC: 48000008  b 0x8281acf4
	pc = 0x8281ACF4; continue 'dispatch;
	// 8281ACF0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8281ACF4: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8281ACF8: 3BBB0004  addi r29, r27, 4
	ctx.r[29].s64 = ctx.r[27].s64 + 4;
	// 8281ACFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281AD00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281AD04: 4BAC9FCD  bl 0x822e4cd0
	ctx.lr = 0x8281AD08;
	sub_822E4CD0(ctx, base);
	// 8281AD08: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8281AD0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281AD10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281AD14: 4BAA52ED  bl 0x822c0000
	ctx.lr = 0x8281AD18;
	sub_822C0000(ctx, base);
	// 8281AD18: 57CB07BD  rlwinm. r11, r30, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281AD1C: 41820010  beq 0x8281ad2c
	if ctx.cr[0].eq {
	pc = 0x8281AD2C; continue 'dispatch;
	}
	// 8281AD20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281AD24: 57DE07FA  rlwinm r30, r30, 0, 0x1f, 0x1d
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 8281AD28: 485D6F69  bl 0x82df1c90
	ctx.lr = 0x8281AD2C;
	sub_82DF1C90(ctx, base);
	// 8281AD2C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281AD30: 41820014  beq 0x8281ad44
	if ctx.cr[0].eq {
	pc = 0x8281AD44; continue 'dispatch;
	}
	// 8281AD34: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8281AD38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281AD3C: 419A0008  beq cr6, 0x8281ad44
	if ctx.cr[6].eq {
	pc = 0x8281AD44; continue 'dispatch;
	}
	// 8281AD40: 4BACD529  bl 0x822e8268
	ctx.lr = 0x8281AD44;
	sub_822E8268(ctx, base);
	// 8281AD44: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8281AD48: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8281AD4C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8281AD50: 4898D464  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281AD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281AD58 size=276
    let mut pc: u32 = 0x8281AD58;
    'dispatch: loop {
        match pc {
            0x8281AD58 => {
    //   block [0x8281AD58..0x8281AE6C)
	// 8281AD58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281AD5C: 4898D409  bl 0x831a8164
	ctx.lr = 0x8281AD60;
	sub_831A8130(ctx, base);
	// 8281AD60: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8281AD64: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281AD68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281AD6C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8281AD70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281AD74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281AD78: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8281AD7C: 4BAD545D  bl 0x822f01d8
	ctx.lr = 0x8281AD80;
	sub_822F01D8(ctx, base);
	// 8281AD80: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281AD84: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281AD88: 4BC771F1  bl 0x82491f78
	ctx.lr = 0x8281AD8C;
	sub_82491F78(ctx, base);
	// 8281AD8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8281AD90: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 8281AD94: FC00F850  fneg f0, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 8281AD98: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8281AD9C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8281ADA0: 13A0E8C7  vcmpequd (lvx128) v29, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8281ADA4: 3B8100A0  addi r28, r1, 0xa0
	ctx.r[28].s64 = ctx.r[1].s64 + 160;
	// 8281ADA8: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8281ADAC: 3B610090  addi r27, r1, 0x90
	ctx.r[27].s64 = ctx.r[1].s64 + 144;
	// 8281ADB0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8281ADB4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8281ADB8: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8281ADBC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8281ADC0: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8281ADC4: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 8281ADC8: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8281ADCC: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 8281ADD0: 13C048C7  vcmpequd (lvx128) v30, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8281ADD4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8281ADD8: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8281ADDC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281ADE0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8281ADE4: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8281ADE8: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281AE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8281AE70 size=12
    let mut pc: u32 = 0x8281AE70;
    'dispatch: loop {
        match pc {
            0x8281AE70 => {
    //   block [0x8281AE70..0x8281AE7C)
	// 8281AE70: D0230000  stfs f1, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8281AE74: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 8281AE78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281AE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281AE80 size=60
    let mut pc: u32 = 0x8281AE80;
    'dispatch: loop {
        match pc {
            0x8281AE80 => {
    //   block [0x8281AE80..0x8281AEBC)
	// 8281AE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281AE84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281AE88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281AE8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281AE90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281AE94: 4863E7ED  bl 0x82e59680
	ctx.lr = 0x8281AE98;
	sub_82E59680(ctx, base);
	// 8281AE98: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281AE9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281AEA0: 396B9924  addi r11, r11, -0x66dc
	ctx.r[11].s64 = ctx.r[11].s64 + -26332;
	// 8281AEA4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281AEA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8281AEAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281AEB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281AEB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281AEB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281AEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281AEC0 size=84
    let mut pc: u32 = 0x8281AEC0;
    'dispatch: loop {
        match pc {
            0x8281AEC0 => {
    //   block [0x8281AEC0..0x8281AF14)
	// 8281AEC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281AEC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281AEC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281AECC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281AED0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281AED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281AED8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281AEDC: 4863E7A5  bl 0x82e59680
	ctx.lr = 0x8281AEE0;
	sub_82E59680(ctx, base);
	// 8281AEE0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281AEE4: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 8281AEE8: 396B992C  addi r11, r11, -0x66d4
	ctx.r[11].s64 = ctx.r[11].s64 + -26324;
	// 8281AEEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281AEF0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281AEF4: 485D8B15  bl 0x82df3a08
	ctx.lr = 0x8281AEF8;
	sub_82DF3A08(ctx, base);
	// 8281AEF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281AEFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281AF00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281AF04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281AF08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281AF0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281AF10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281AF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281AF18 size=88
    let mut pc: u32 = 0x8281AF18;
    'dispatch: loop {
        match pc {
            0x8281AF18 => {
    //   block [0x8281AF18..0x8281AF70)
	// 8281AF18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281AF1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281AF20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281AF24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281AF28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281AF2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281AF30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281AF34: 4863E74D  bl 0x82e59680
	ctx.lr = 0x8281AF38;
	sub_82E59680(ctx, base);
	// 8281AF38: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281AF3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281AF40: 396B9948  addi r11, r11, -0x66b8
	ctx.r[11].s64 = ctx.r[11].s64 + -26296;
	// 8281AF44: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281AF48: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281AF4C: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8281AF50: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281AF54: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8281AF58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281AF5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281AF60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281AF64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281AF68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281AF6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281AF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281AF70 size=172
    let mut pc: u32 = 0x8281AF70;
    'dispatch: loop {
        match pc {
            0x8281AF70 => {
    //   block [0x8281AF70..0x8281B01C)
	// 8281AF70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281AF74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281AF78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281AF7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281AF80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281AF84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281AF88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281AF8C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8281AF90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281AF94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281AF98: 4BAA59A1  bl 0x822c0938
	ctx.lr = 0x8281AF9C;
	sub_822C0938(ctx, base);
	// 8281AF9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281AFA0: 41820028  beq 0x8281afc8
	if ctx.cr[0].eq {
	pc = 0x8281AFC8; continue 'dispatch;
	}
	// 8281AFA4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281AFA8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8281AFAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8281AFB0: 392B9934  addi r9, r11, -0x66cc
	ctx.r[9].s64 = ctx.r[11].s64 + -26316;
	// 8281AFB4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8281AFB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281AFBC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8281AFC0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8281AFC4: 48000008  b 0x8281afcc
	pc = 0x8281AFCC; continue 'dispatch;
	// 8281AFC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281AFCC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281AFD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281AFD4: 409A002C  bne cr6, 0x8281b000
	if !ctx.cr[6].eq {
	pc = 0x8281B000; continue 'dispatch;
	}
	// 8281AFD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281AFDC: 4BAA528D  bl 0x822c0268
	ctx.lr = 0x8281AFE0;
	sub_822C0268(ctx, base);
	// 8281AFE0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281AFE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8281AFE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281AFEC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8281AFF0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8281AFF4: 816BF77C  lwz r11, -0x884(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2180 as u32) ) } as u64;
	// 8281AFF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281AFFC: 4BAA5005  bl 0x822c0000
	ctx.lr = 0x8281B000;
	sub_822C0000(ctx, base);
	// 8281B000: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281B004: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281B008: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281B00C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281B010: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281B014: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281B018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281B020 size=144
    let mut pc: u32 = 0x8281B020;
    'dispatch: loop {
        match pc {
            0x8281B020 => {
    //   block [0x8281B020..0x8281B0B0)
	// 8281B020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281B024: 4898D145  bl 0x831a8168
	ctx.lr = 0x8281B028;
	sub_831A8130(ctx, base);
	// 8281B028: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281B02C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8281B030: 4800000C  b 0x8281b03c
	pc = 0x8281B03C; continue 'dispatch;
	// 8281B034: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281B038: 4BAE6C39  bl 0x82301c70
	ctx.lr = 0x8281B03C;
	sub_82301C70(ctx, base);
	// 8281B03C: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 8281B040: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281B044: 409AFFF0  bne cr6, 0x8281b034
	if !ctx.cr[6].eq {
	pc = 0x8281B034; continue 'dispatch;
	}
	// 8281B048: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8281B04C: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 8281B050: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8281B054: 419A0034  beq cr6, 0x8281b088
	if ctx.cr[6].eq {
	pc = 0x8281B088; continue 'dispatch;
	}
	// 8281B058: 57DF103A  slwi r31, r30, 2
	ctx.r[31].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 8281B05C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281B060: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 8281B064: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 8281B068: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 8281B06C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8281B070: 419A0010  beq cr6, 0x8281b080
	if ctx.cr[6].eq {
	pc = 0x8281B080; continue 'dispatch;
	}
	// 8281B074: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8281B078: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 8281B07C: 485D710D  bl 0x82df2188
	ctx.lr = 0x8281B080;
	sub_82DF2188(ctx, base);
	// 8281B080: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8281B084: 409AFFD8  bne cr6, 0x8281b05c
	if !ctx.cr[6].eq {
	pc = 0x8281B05C; continue 'dispatch;
	}
	// 8281B088: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281B08C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8281B090: 419A000C  beq cr6, 0x8281b09c
	if ctx.cr[6].eq {
	pc = 0x8281B09C; continue 'dispatch;
	}
	// 8281B094: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 8281B098: 485D70F1  bl 0x82df2188
	ctx.lr = 0x8281B09C;
	sub_82DF2188(ctx, base);
	// 8281B09C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281B0A0: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8281B0A4: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8281B0A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8281B0AC: 4898D10C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B0B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281B0B0 size=220
    let mut pc: u32 = 0x8281B0B0;
    'dispatch: loop {
        match pc {
            0x8281B0B0 => {
    //   block [0x8281B0B0..0x8281B18C)
	// 8281B0B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281B0B4: 4898D0B5  bl 0x831a8168
	ctx.lr = 0x8281B0B8;
	sub_831A8130(ctx, base);
	// 8281B0B8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8281B0BC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281B0C0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8281B0C4: 817C00C8  lwz r11, 0xc8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(200 as u32) ) } as u64;
	// 8281B0C8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281B0CC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8281B0D0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8281B0D4: 419A00AC  beq cr6, 0x8281b180
	if ctx.cr[6].eq {
	pc = 0x8281B180; continue 'dispatch;
	}
	// 8281B0D8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8281B0DC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281B0E0: 3BBC0028  addi r29, r28, 0x28
	ctx.r[29].s64 = ctx.r[28].s64 + 40;
	// 8281B0E4: 3BCB9950  addi r30, r11, -0x66b0
	ctx.r[30].s64 = ctx.r[11].s64 + -26288;
	// 8281B0E8: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8281B0EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281B0F0: 4BC45819  bl 0x82460908
	ctx.lr = 0x8281B0F4;
	sub_82460908(ctx, base);
	// 8281B0F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281B0F8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8281B0FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281B100: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281B104: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8281B108: 419A0024  beq cr6, 0x8281b12c
	if ctx.cr[6].eq {
	pc = 0x8281B12C; continue 'dispatch;
	}
	// 8281B10C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281B110: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281B114: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281B118: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281B11C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281B120: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281B124: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281B128: 4082FFE8  bne 0x8281b110
	if !ctx.cr[0].eq {
	pc = 0x8281B110; continue 'dispatch;
	}
	// 8281B12C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281B130: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8281B134: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8281B138: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8281B13C: 38A0011F  li r5, 0x11f
	ctx.r[5].s64 = 287;
	// 8281B140: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281B144: 4863D8FD  bl 0x82e58a40
	ctx.lr = 0x8281B148;
	sub_82E58A40(ctx, base);
	// 8281B148: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281B14C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281B150: 419A0008  beq cr6, 0x8281b158
	if ctx.cr[6].eq {
	pc = 0x8281B158; continue 'dispatch;
	}
	// 8281B154: 4BAA573D  bl 0x822c0890
	ctx.lr = 0x8281B158;
	sub_822C0890(ctx, base);
	// 8281B158: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8281B15C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281B160: 419A0008  beq cr6, 0x8281b168
	if ctx.cr[6].eq {
	pc = 0x8281B168; continue 'dispatch;
	}
	// 8281B164: 4BAA572D  bl 0x822c0890
	ctx.lr = 0x8281B168;
	sub_822C0890(ctx, base);
	// 8281B168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281B16C: 4BB8651D  bl 0x823a1688
	ctx.lr = 0x8281B170;
	sub_823A1688(ctx, base);
	// 8281B170: 817C00C8  lwz r11, 0xc8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(200 as u32) ) } as u64;
	// 8281B174: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8281B178: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8281B17C: 409AFF70  bne cr6, 0x8281b0ec
	if !ctx.cr[6].eq {
	pc = 0x8281B0EC; continue 'dispatch;
	}
	// 8281B180: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8281B184: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8281B188: 4898D030  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281B190 size=220
    let mut pc: u32 = 0x8281B190;
    'dispatch: loop {
        match pc {
            0x8281B190 => {
    //   block [0x8281B190..0x8281B26C)
	// 8281B190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281B194: 4898CFD5  bl 0x831a8168
	ctx.lr = 0x8281B198;
	sub_831A8130(ctx, base);
	// 8281B198: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8281B19C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281B1A0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8281B1A4: 817C00C8  lwz r11, 0xc8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(200 as u32) ) } as u64;
	// 8281B1A8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281B1AC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8281B1B0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8281B1B4: 419A00AC  beq cr6, 0x8281b260
	if ctx.cr[6].eq {
	pc = 0x8281B260; continue 'dispatch;
	}
	// 8281B1B8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8281B1BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281B1C0: 3BBC0028  addi r29, r28, 0x28
	ctx.r[29].s64 = ctx.r[28].s64 + 40;
	// 8281B1C4: 3BCB9950  addi r30, r11, -0x66b0
	ctx.r[30].s64 = ctx.r[11].s64 + -26288;
	// 8281B1C8: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8281B1CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281B1D0: 4BC8F0E9  bl 0x824aa2b8
	ctx.lr = 0x8281B1D4;
	sub_824AA2B8(ctx, base);
	// 8281B1D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281B1D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8281B1DC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281B1E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281B1E4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8281B1E8: 419A0024  beq cr6, 0x8281b20c
	if ctx.cr[6].eq {
	pc = 0x8281B20C; continue 'dispatch;
	}
	// 8281B1EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281B1F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281B1F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281B1F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281B1FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281B200: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281B204: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281B208: 4082FFE8  bne 0x8281b1f0
	if !ctx.cr[0].eq {
	pc = 0x8281B1F0; continue 'dispatch;
	}
	// 8281B20C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281B210: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8281B214: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8281B218: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8281B21C: 38A0012A  li r5, 0x12a
	ctx.r[5].s64 = 298;
	// 8281B220: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281B224: 4863D81D  bl 0x82e58a40
	ctx.lr = 0x8281B228;
	sub_82E58A40(ctx, base);
	// 8281B228: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281B22C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281B230: 419A0008  beq cr6, 0x8281b238
	if ctx.cr[6].eq {
	pc = 0x8281B238; continue 'dispatch;
	}
	// 8281B234: 4BAA565D  bl 0x822c0890
	ctx.lr = 0x8281B238;
	sub_822C0890(ctx, base);
	// 8281B238: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8281B23C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281B240: 419A0008  beq cr6, 0x8281b248
	if ctx.cr[6].eq {
	pc = 0x8281B248; continue 'dispatch;
	}
	// 8281B244: 4BAA564D  bl 0x822c0890
	ctx.lr = 0x8281B248;
	sub_822C0890(ctx, base);
	// 8281B248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281B24C: 4BB8643D  bl 0x823a1688
	ctx.lr = 0x8281B250;
	sub_823A1688(ctx, base);
	// 8281B250: 817C00C8  lwz r11, 0xc8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(200 as u32) ) } as u64;
	// 8281B254: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8281B258: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8281B25C: 409AFF70  bne cr6, 0x8281b1cc
	if !ctx.cr[6].eq {
	pc = 0x8281B1CC; continue 'dispatch;
	}
	// 8281B260: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8281B264: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8281B268: 4898CF50  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281B270 size=220
    let mut pc: u32 = 0x8281B270;
    'dispatch: loop {
        match pc {
            0x8281B270 => {
    //   block [0x8281B270..0x8281B34C)
	// 8281B270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281B274: 4898CEF5  bl 0x831a8168
	ctx.lr = 0x8281B278;
	sub_831A8130(ctx, base);
	// 8281B278: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8281B27C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281B280: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8281B284: 817C00C8  lwz r11, 0xc8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(200 as u32) ) } as u64;
	// 8281B288: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281B28C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8281B290: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8281B294: 419A00AC  beq cr6, 0x8281b340
	if ctx.cr[6].eq {
	pc = 0x8281B340; continue 'dispatch;
	}
	// 8281B298: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8281B29C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281B2A0: 3BBC0028  addi r29, r28, 0x28
	ctx.r[29].s64 = ctx.r[28].s64 + 40;
	// 8281B2A4: 3BCB9950  addi r30, r11, -0x66b0
	ctx.r[30].s64 = ctx.r[11].s64 + -26288;
	// 8281B2A8: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8281B2AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281B2B0: 4BDBCDA1  bl 0x825d8050
	ctx.lr = 0x8281B2B4;
	sub_825D8050(ctx, base);
	// 8281B2B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281B2B8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8281B2BC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281B2C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281B2C4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8281B2C8: 419A0024  beq cr6, 0x8281b2ec
	if ctx.cr[6].eq {
	pc = 0x8281B2EC; continue 'dispatch;
	}
	// 8281B2CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281B2D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281B2D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281B2D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281B2DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281B2E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281B2E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281B2E8: 4082FFE8  bne 0x8281b2d0
	if !ctx.cr[0].eq {
	pc = 0x8281B2D0; continue 'dispatch;
	}
	// 8281B2EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281B2F0: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8281B2F4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8281B2F8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8281B2FC: 38A00135  li r5, 0x135
	ctx.r[5].s64 = 309;
	// 8281B300: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281B304: 4863D73D  bl 0x82e58a40
	ctx.lr = 0x8281B308;
	sub_82E58A40(ctx, base);
	// 8281B308: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281B30C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281B310: 419A0008  beq cr6, 0x8281b318
	if ctx.cr[6].eq {
	pc = 0x8281B318; continue 'dispatch;
	}
	// 8281B314: 4BAA557D  bl 0x822c0890
	ctx.lr = 0x8281B318;
	sub_822C0890(ctx, base);
	// 8281B318: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8281B31C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281B320: 419A0008  beq cr6, 0x8281b328
	if ctx.cr[6].eq {
	pc = 0x8281B328; continue 'dispatch;
	}
	// 8281B324: 4BAA556D  bl 0x822c0890
	ctx.lr = 0x8281B328;
	sub_822C0890(ctx, base);
	// 8281B328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281B32C: 4BB8635D  bl 0x823a1688
	ctx.lr = 0x8281B330;
	sub_823A1688(ctx, base);
	// 8281B330: 817C00C8  lwz r11, 0xc8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(200 as u32) ) } as u64;
	// 8281B334: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8281B338: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8281B33C: 409AFF70  bne cr6, 0x8281b2ac
	if !ctx.cr[6].eq {
	pc = 0x8281B2AC; continue 'dispatch;
	}
	// 8281B340: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8281B344: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8281B348: 4898CE70  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281B350 size=484
    let mut pc: u32 = 0x8281B350;
    'dispatch: loop {
        match pc {
            0x8281B350 => {
    //   block [0x8281B350..0x8281B534)
	// 8281B350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281B354: 4898CE09  bl 0x831a815c
	ctx.lr = 0x8281B358;
	sub_831A8130(ctx, base);
	// 8281B358: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281B35C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281B360: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 8281B364: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 8281B368: 617FFFFF  ori r31, r11, 0xffff
	ctx.r[31].u64 = ctx.r[11].u64 | 65535;
	// 8281B36C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8281B370: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 8281B374: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8281B378: 40980008  bge cr6, 0x8281b380
	if !ctx.cr[6].lt {
	pc = 0x8281B380; continue 'dispatch;
	}
	// 8281B37C: 482894C5  bl 0x82aa4840
	ctx.lr = 0x8281B380;
	sub_82AA4840(ctx, base);
	// 8281B380: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8281B384: 556AF87E  srwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8281B388: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 8281B38C: 40980008  bge cr6, 0x8281b394
	if !ctx.cr[6].lt {
	pc = 0x8281B394; continue 'dispatch;
	}
	// 8281B390: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 8281B394: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8281B398: 40980014  bge cr6, 0x8281b3ac
	if !ctx.cr[6].lt {
	pc = 0x8281B3AC; continue 'dispatch;
	}
	// 8281B39C: 7D2AF850  subf r9, r10, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 8281B3A0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8281B3A4: 41990008  bgt cr6, 0x8281b3ac
	if ctx.cr[6].gt {
	pc = 0x8281B3AC; continue 'dispatch;
	}
	// 8281B3A8: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 8281B3AC: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 8281B3B0: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8281B3B4: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 8281B3B8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8281B3BC: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8281B3C0: 388908B0  addi r4, r9, 0x8b0
	ctx.r[4].s64 = ctx.r[9].s64 + 2224;
	// 8281B3C4: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 8281B3C8: 8079110C  lwz r3, 0x110c(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4364 as u32) ) } as u64;
	// 8281B3CC: 555DF87E  srwi r29, r10, 1
	ctx.r[29].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 8281B3D0: 485D6CF9  bl 0x82df20c8
	ctx.lr = 0x8281B3D4;
	sub_82DF20C8(ctx, base);
	// 8281B3D4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281B3D8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8281B3DC: 57BF103A  slwi r31, r29, 2
	ctx.r[31].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 8281B3E0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8281B3E4: 7CABFA14  add r5, r11, r31
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 8281B3E8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8281B3EC: 7C7FDA14  add r3, r31, r27
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[27].u64;
	// 8281B3F0: 7D455050  subf r10, r5, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 8281B3F4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8281B3F8: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281B3FC: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8281B400: 7F861A14  add r28, r6, r3
	ctx.r[28].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 8281B404: 4182000C  beq 0x8281b410
	if ctx.cr[0].eq {
	pc = 0x8281B410; continue 'dispatch;
	}
	// 8281B408: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 8281B40C: 4898D8FD  bl 0x831a8d08
	ctx.lr = 0x8281B410;
	sub_831A8D08(ctx, base);
	// 8281B410: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281B414: 7F1DD040  cmplw cr6, r29, r26
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8281B418: 4199007C  bgt cr6, 0x8281b494
	if ctx.cr[6].gt {
	pc = 0x8281B494; continue 'dispatch;
	}
	// 8281B41C: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 8281B420: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 8281B424: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281B428: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8281B42C: 7FE6E214  add r31, r6, r28
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[28].u64;
	// 8281B430: 41820010  beq 0x8281b440
	if ctx.cr[0].eq {
	pc = 0x8281B440; continue 'dispatch;
	}
	// 8281B434: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 8281B438: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8281B43C: 4898D8CD  bl 0x831a8d08
	ctx.lr = 0x8281B440;
	sub_831A8D08(ctx, base);
	// 8281B440: 7D7DD051  subf. r11, r29, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[29].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281B444: 41820024  beq 0x8281b468
	if ctx.cr[0].eq {
	pc = 0x8281B468; continue 'dispatch;
	}
	// 8281B448: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 8281B44C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8281B450: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281B454: 41820014  beq 0x8281b468
	if ctx.cr[0].eq {
	pc = 0x8281B468; continue 'dispatch;
	}
	// 8281B458: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281B45C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8281B460: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8281B464: 4200FFF8  bdnz 0x8281b45c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8281B45C; continue 'dispatch;
	}
	// 8281B468: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8281B46C: 419A009C  beq cr6, 0x8281b508
	if ctx.cr[6].eq {
	pc = 0x8281B508; continue 'dispatch;
	}
	// 8281B470: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 8281B474: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8281B478: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281B47C: 4182008C  beq 0x8281b508
	if ctx.cr[0].eq {
	pc = 0x8281B508; continue 'dispatch;
	}
	// 8281B480: 7FA903A6  mtctr r29
	ctx.ctr.u64 = ctx.r[29].u64;
	// 8281B484: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8281B488: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281B48C: 4200FFF8  bdnz 0x8281b484
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8281B484; continue 'dispatch;
	}
	// 8281B490: 48000078  b 0x8281b508
	pc = 0x8281B508; continue 'dispatch;
	// 8281B494: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 8281B498: 7D65E850  subf r11, r5, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[5].s64;
	// 8281B49C: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 8281B4A0: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281B4A4: 41820014  beq 0x8281b4b8
	if ctx.cr[0].eq {
	pc = 0x8281B4B8; continue 'dispatch;
	}
	// 8281B4A8: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8281B4AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8281B4B0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 8281B4B4: 4898D855  bl 0x831a8d08
	ctx.lr = 0x8281B4B8;
	sub_831A8D08(ctx, base);
	// 8281B4B8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281B4BC: 7CBD5A14  add r5, r29, r11
	ctx.r[5].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 8281B4C0: 7D655850  subf r11, r5, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 8281B4C4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 8281B4C8: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281B4CC: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8281B4D0: 7FE6DA14  add r31, r6, r27
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[27].u64;
	// 8281B4D4: 41820010  beq 0x8281b4e4
	if ctx.cr[0].eq {
	pc = 0x8281B4E4; continue 'dispatch;
	}
	// 8281B4D8: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 8281B4DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8281B4E0: 4898D829  bl 0x831a8d08
	ctx.lr = 0x8281B4E4;
	sub_831A8D08(ctx, base);
	// 8281B4E4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8281B4E8: 419A0020  beq cr6, 0x8281b508
	if ctx.cr[6].eq {
	pc = 0x8281B508; continue 'dispatch;
	}
	// 8281B4EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281B4F0: 281A0000  cmplwi r26, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281B4F4: 41820014  beq 0x8281b508
	if ctx.cr[0].eq {
	pc = 0x8281B508; continue 'dispatch;
	}
	// 8281B4F8: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 8281B4FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281B500: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 8281B504: 4200FFF8  bdnz 0x8281b4fc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8281B4FC; continue 'dispatch;
	}
	// 8281B508: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281B50C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8281B510: 419A000C  beq cr6, 0x8281b51c
	if ctx.cr[6].eq {
	pc = 0x8281B51C; continue 'dispatch;
	}
	// 8281B514: 8079110C  lwz r3, 0x110c(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4364 as u32) ) } as u64;
	// 8281B518: 485D6C71  bl 0x82df2188
	ctx.lr = 0x8281B51C;
	sub_82DF2188(ctx, base);
	// 8281B51C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8281B520: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 8281B524: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 8281B528: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8281B52C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8281B530: 4898CC7C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281B538 size=364
    let mut pc: u32 = 0x8281B538;
    'dispatch: loop {
        match pc {
            0x8281B538 => {
    //   block [0x8281B538..0x8281B6A4)
	// 8281B538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281B53C: 4898CC2D  bl 0x831a8168
	ctx.lr = 0x8281B540;
	sub_831A8130(ctx, base);
	// 8281B540: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281B544: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8281B548: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281B54C: 938100BC  stw r28, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[28].u32 ) };
	// 8281B550: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8281B554: 3BBF00C4  addi r29, r31, 0xc4
	ctx.r[29].s64 = ctx.r[31].s64 + 196;
	// 8281B558: 38A100BC  addi r5, r1, 0xbc
	ctx.r[5].s64 = ctx.r[1].s64 + 188;
	// 8281B55C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281B560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281B564: 48103965  bl 0x8291eec8
	ctx.lr = 0x8281B568;
	sub_8291EEC8(ctx, base);
	// 8281B568: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 8281B56C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8281B570: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8281B574: 409A0128  bne cr6, 0x8281b69c
	if !ctx.cr[6].eq {
	pc = 0x8281B69C; continue 'dispatch;
	}
	// 8281B578: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281B57C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281B580: 388B9950  addi r4, r11, -0x66b0
	ctx.r[4].s64 = ctx.r[11].s64 + -26288;
	// 8281B584: 38A000AA  li r5, 0xaa
	ctx.r[5].s64 = 170;
	// 8281B588: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8281B58C: 4BAA4E4D  bl 0x822c03d8
	ctx.lr = 0x8281B590;
	sub_822C03D8(ctx, base);
	// 8281B590: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281B594: 4182001C  beq 0x8281b5b0
	if ctx.cr[0].eq {
	pc = 0x8281B5B0; continue 'dispatch;
	}
	// 8281B598: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281B59C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281B5A0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281B5A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281B5A8: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8281B5AC: 48000008  b 0x8281b5b4
	pc = 0x8281B5B4; continue 'dispatch;
	// 8281B5B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8281B5B4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8281B5B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281B5BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8281B5C0: 4BFFF9B1  bl 0x8281af70
	ctx.lr = 0x8281B5C4;
	sub_8281AF70(ctx, base);
	// 8281B5C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8281B5C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281B5CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8281B5D0: 4BAA4A31  bl 0x822c0000
	ctx.lr = 0x8281B5D4;
	sub_822C0000(ctx, base);
	// 8281B5D4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8281B5D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8281B5DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281B5E0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8281B5E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8281B5E8: 419A0024  beq cr6, 0x8281b60c
	if ctx.cr[6].eq {
	pc = 0x8281B60C; continue 'dispatch;
	}
	// 8281B5EC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8281B5F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281B5F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281B5F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281B5FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281B600: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281B604: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281B608: 4082FFE8  bne 0x8281b5f0
	if !ctx.cr[0].eq {
	pc = 0x8281B5F0; continue 'dispatch;
	}
	// 8281B60C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8281B610: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8281B614: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8281B618: 4BC715F9  bl 0x8248cc10
	ctx.lr = 0x8281B61C;
	sub_8248CC10(ctx, base);
	// 8281B61C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8281B620: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281B624: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281B628: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281B62C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8281B630: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8281B634: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 8281B638: 419A0024  beq cr6, 0x8281b65c
	if ctx.cr[6].eq {
	pc = 0x8281B65C; continue 'dispatch;
	}
	// 8281B63C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281B640: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281B644: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281B648: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281B64C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281B650: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281B654: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281B658: 4082FFE8  bne 0x8281b640
	if !ctx.cr[0].eq {
	pc = 0x8281B640; continue 'dispatch;
	}
	// 8281B65C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8281B660: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281B664: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281B668: 4BFB4879  bl 0x827cfee0
	ctx.lr = 0x8281B66C;
	sub_827CFEE0(ctx, base);
	// 8281B66C: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8281B670: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281B674: 419A0008  beq cr6, 0x8281b67c
	if ctx.cr[6].eq {
	pc = 0x8281B67C; continue 'dispatch;
	}
	// 8281B678: 4BAA5219  bl 0x822c0890
	ctx.lr = 0x8281B67C;
	sub_822C0890(ctx, base);
	// 8281B67C: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281B680: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281B684: 419A0008  beq cr6, 0x8281b68c
	if ctx.cr[6].eq {
	pc = 0x8281B68C; continue 'dispatch;
	}
	// 8281B688: 4BAA5209  bl 0x822c0890
	ctx.lr = 0x8281B68C;
	sub_822C0890(ctx, base);
	// 8281B68C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281B690: 419A000C  beq cr6, 0x8281b69c
	if ctx.cr[6].eq {
	pc = 0x8281B69C; continue 'dispatch;
	}
	// 8281B694: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281B698: 4BAA51F9  bl 0x822c0890
	ctx.lr = 0x8281B69C;
	sub_822C0890(ctx, base);
	// 8281B69C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8281B6A0: 4898CB18  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281B6A8 size=76
    let mut pc: u32 = 0x8281B6A8;
    'dispatch: loop {
        match pc {
            0x8281B6A8 => {
    //   block [0x8281B6A8..0x8281B6F4)
	// 8281B6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281B6AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281B6B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281B6B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281B6B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281B6BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281B6C0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8281B6C4: 3BC40018  addi r30, r4, 0x18
	ctx.r[30].s64 = ctx.r[4].s64 + 24;
	// 8281B6C8: 487ECA61  bl 0x83008128
	ctx.lr = 0x8281B6CC;
	sub_83008128(ctx, base);
	// 8281B6CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281B6D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281B6D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8281B6D8: 4BFFFE61  bl 0x8281b538
	ctx.lr = 0x8281B6DC;
	sub_8281B538(ctx, base);
	// 8281B6DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281B6E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281B6E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281B6E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281B6EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281B6F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281B6F8 size=100
    let mut pc: u32 = 0x8281B6F8;
    'dispatch: loop {
        match pc {
            0x8281B6F8 => {
    //   block [0x8281B6F8..0x8281B75C)
	// 8281B6F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281B6FC: 4898CA71  bl 0x831a816c
	ctx.lr = 0x8281B700;
	sub_831A8130(ctx, base);
	// 8281B700: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281B704: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8281B708: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 8281B70C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281B710: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281B714: 4BC7146D  bl 0x8248cb80
	ctx.lr = 0x8281B718;
	sub_8248CB80(ctx, base);
	// 8281B718: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281B71C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8281B720: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8281B724: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281B728: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281B72C: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8281B730: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281B734: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281B738: 48103399  bl 0x8291ead0
	ctx.lr = 0x8281B73C;
	sub_8291EAD0(ctx, base);
	// 8281B73C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 8281B740: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8281B744: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281B748: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281B74C: 4BD0DADD  bl 0x82529228
	ctx.lr = 0x8281B750;
	sub_82529228(ctx, base);
	// 8281B750: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8281B754: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8281B758: 4898CA64  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281B760 size=208
    let mut pc: u32 = 0x8281B760;
    'dispatch: loop {
        match pc {
            0x8281B760 => {
    //   block [0x8281B760..0x8281B830)
	// 8281B760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281B764: 4898CA05  bl 0x831a8168
	ctx.lr = 0x8281B768;
	sub_831A8130(ctx, base);
	// 8281B768: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281B76C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281B770: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8281B774: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8281B778: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281B77C: 40820024  bne 0x8281b7a0
	if !ctx.cr[0].eq {
	pc = 0x8281B7A0; continue 'dispatch;
	}
	// 8281B780: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8281B784: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8281B788: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 8281B78C: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8281B790: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8281B794: 4199000C  bgt cr6, 0x8281b7a0
	if ctx.cr[6].gt {
	pc = 0x8281B7A0; continue 'dispatch;
	}
	// 8281B798: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8281B79C: 4BFFFBB5  bl 0x8281b350
	ctx.lr = 0x8281B7A0;
	sub_8281B350(ctx, base);
	// 8281B7A0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8281B7A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281B7A8: 409A000C  bne cr6, 0x8281b7b4
	if !ctx.cr[6].eq {
	pc = 0x8281B7B4; continue 'dispatch;
	}
	// 8281B7AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8281B7B0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8281B7B4: 3BABFFFF  addi r29, r11, -1
	ctx.r[29].s64 = ctx.r[11].s64 + -1;
	// 8281B7B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281B7BC: 57BE083A  rlwinm r30, r29, 1, 0, 0x1d
	ctx.r[30].u64 = ctx.r[29].u32 as u64 & 0x7FFFFFFFu64;
	// 8281B7C0: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8281B7C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281B7C8: 409A0028  bne cr6, 0x8281b7f0
	if !ctx.cr[6].eq {
	pc = 0x8281B7F0; continue 'dispatch;
	}
	// 8281B7CC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8281B7D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8281B7D4: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 8281B7D8: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 8281B7DC: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 8281B7E0: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 8281B7E4: 485D68E5  bl 0x82df20c8
	ctx.lr = 0x8281B7E8;
	sub_82DF20C8(ctx, base);
	// 8281B7E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281B7EC: 7C6BF12E  stwx r3, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[3].u32) };
	// 8281B7F0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281B7F4: 57AB1F38  rlwinm r11, r29, 3, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x1FFFFFFFu64;
	// 8281B7F8: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8281B7FC: 7FCA5A15  add. r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8281B800: 41820018  beq 0x8281b818
	if ctx.cr[0].eq {
	pc = 0x8281B818; continue 'dispatch;
	}
	// 8281B804: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8281B808: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281B80C: 485D83F5  bl 0x82df3c00
	ctx.lr = 0x8281B810;
	sub_82DF3C00(ctx, base);
	// 8281B810: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281B814: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8281B818: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8281B81C: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 8281B820: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8281B824: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8281B828: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8281B82C: 4898C98C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281B830 size=88
    let mut pc: u32 = 0x8281B830;
    'dispatch: loop {
        match pc {
            0x8281B830 => {
    //   block [0x8281B830..0x8281B888)
	// 8281B830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281B834: 4898C939  bl 0x831a816c
	ctx.lr = 0x8281B838;
	sub_831A8130(ctx, base);
	// 8281B838: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281B83C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281B840: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8281B844: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8281B848: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8281B84C: 2B0B0014  cmplwi cr6, r11, 0x14
	ctx.cr[6].compare_u32(ctx.r[11].u32, 20 as u32, &mut ctx.xer);
	// 8281B850: 4099000C  ble cr6, 0x8281b85c
	if !ctx.cr[6].gt {
	pc = 0x8281B85C; continue 'dispatch;
	}
	// 8281B854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281B858: 4BAE6419  bl 0x82301c70
	ctx.lr = 0x8281B85C;
	sub_82301C70(ctx, base);
	// 8281B85C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281B860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281B864: 485D81A5  bl 0x82df3a08
	ctx.lr = 0x8281B868;
	sub_82DF3A08(ctx, base);
	// 8281B868: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8281B86C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281B870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281B874: 4BFFFEED  bl 0x8281b760
	ctx.lr = 0x8281B878;
	sub_8281B760(ctx, base);
	// 8281B878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281B87C: 485D7BAD  bl 0x82df3428
	ctx.lr = 0x8281B880;
	sub_82DF3428(ctx, base);
	// 8281B880: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8281B884: 4898C938  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281B888 size=64
    let mut pc: u32 = 0x8281B888;
    'dispatch: loop {
        match pc {
            0x8281B888 => {
    //   block [0x8281B888..0x8281B8C8)
	// 8281B888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281B88C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281B890: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281B894: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281B898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281B89C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8281B8A0: 487EC889  bl 0x83008128
	ctx.lr = 0x8281B8A4;
	sub_83008128(ctx, base);
	// 8281B8A4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8281B8A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281B8AC: 387F00C4  addi r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 + 196;
	// 8281B8B0: 4BFFFE49  bl 0x8281b6f8
	ctx.lr = 0x8281B8B4;
	sub_8281B6F8(ctx, base);
	// 8281B8B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281B8B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281B8BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281B8C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281B8C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281B8C8 size=92
    let mut pc: u32 = 0x8281B8C8;
    'dispatch: loop {
        match pc {
            0x8281B8C8 => {
    //   block [0x8281B8C8..0x8281B924)
	// 8281B8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281B8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281B8D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281B8D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281B8D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281B8DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281B8E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281B8E4: 4863DDBD  bl 0x82e596a0
	ctx.lr = 0x8281B8E8;
	sub_82E596A0(ctx, base);
	// 8281B8E8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8281B8EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281B8F0: 394A99A4  addi r10, r10, -0x665c
	ctx.r[10].s64 = ctx.r[10].s64 + -26204;
	// 8281B8F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281B8F8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8281B8FC: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8281B900: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 8281B904: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 8281B908: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 8281B90C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281B910: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281B914: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281B918: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281B91C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281B920: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281B928 size=88
    let mut pc: u32 = 0x8281B928;
    'dispatch: loop {
        match pc {
            0x8281B928 => {
    //   block [0x8281B928..0x8281B980)
	// 8281B928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281B92C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281B930: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281B934: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281B938: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281B93C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281B940: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281B944: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 8281B948: 4BC4E6B9  bl 0x8246a000
	ctx.lr = 0x8281B94C;
	sub_8246A000(ctx, base);
	// 8281B94C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281B950: 4863DC89  bl 0x82e595d8
	ctx.lr = 0x8281B954;
	sub_82E595D8(ctx, base);
	// 8281B954: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281B958: 4182000C  beq 0x8281b964
	if ctx.cr[0].eq {
	pc = 0x8281B964; continue 'dispatch;
	}
	// 8281B95C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281B960: 485D6A79  bl 0x82df23d8
	ctx.lr = 0x8281B964;
	sub_82DF23D8(ctx, base);
	// 8281B964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281B968: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281B96C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281B970: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281B974: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281B978: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281B97C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281B980 size=96
    let mut pc: u32 = 0x8281B980;
    'dispatch: loop {
        match pc {
            0x8281B980 => {
    //   block [0x8281B980..0x8281B9E0)
	// 8281B980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281B984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281B988: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281B98C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281B990: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281B994: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281B998: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8281B99C: 396B99C0  addi r11, r11, -0x6640
	ctx.r[11].s64 = ctx.r[11].s64 + -26176;
	// 8281B9A0: 394A99AC  addi r10, r10, -0x6654
	ctx.r[10].s64 = ctx.r[10].s64 + -26196;
	// 8281B9A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281B9A8: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 8281B9AC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8281B9B0: 4BFFF671  bl 0x8281b020
	ctx.lr = 0x8281B9B4;
	sub_8281B020(ctx, base);
	// 8281B9B4: 387F00C4  addi r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 + 196;
	// 8281B9B8: 482D1941  bl 0x82aed2f8
	ctx.lr = 0x8281B9BC;
	sub_82AED2F8(ctx, base);
	// 8281B9BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281B9C0: 4BCF57D9  bl 0x82511198
	ctx.lr = 0x8281B9C4;
	sub_82511198(ctx, base);
	// 8281B9C4: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 8281B9C8: 485D6B89  bl 0x82df2550
	ctx.lr = 0x8281B9CC;
	sub_82DF2550(ctx, base);
	// 8281B9CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8281B9D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281B9D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281B9D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281B9DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281B9E0 size=8
    let mut pc: u32 = 0x8281B9E0;
    'dispatch: loop {
        match pc {
            0x8281B9E0 => {
    //   block [0x8281B9E0..0x8281B9E8)
	// 8281B9E0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8281B9E4: 480004FC  b 0x8281bee0
	sub_8281BEE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281B9E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281B9E8 size=440
    let mut pc: u32 = 0x8281B9E8;
    'dispatch: loop {
        match pc {
            0x8281B9E8 => {
    //   block [0x8281B9E8..0x8281BBA0)
	// 8281B9E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281B9EC: 4898C779  bl 0x831a8164
	ctx.lr = 0x8281B9F0;
	sub_831A8130(ctx, base);
	// 8281B9F0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281B9F4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8281B9F8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8281B9FC: 3BFC00D0  addi r31, r28, 0xd0
	ctx.r[31].s64 = ctx.r[28].s64 + 208;
	// 8281BA00: 83DC00DC  lwz r30, 0xdc(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(220 as u32) ) } as u64;
	// 8281BA04: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8281BA08: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8281BA0C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8281BA10: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8281BA14: 409A0010  bne cr6, 0x8281ba24
	if !ctx.cr[6].eq {
	pc = 0x8281BA24; continue 'dispatch;
	}
	// 8281BA18: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8281BA1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8281BA20: 419A0008  beq cr6, 0x8281ba28
	if ctx.cr[6].eq {
	pc = 0x8281BA28; continue 'dispatch;
	}
	// 8281BA24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281BA28: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281BA2C: 40820098  bne 0x8281bac4
	if !ctx.cr[0].eq {
	pc = 0x8281BAC4; continue 'dispatch;
	}
	// 8281BA30: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281BA34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281BA38: 485D7FD1  bl 0x82df3a08
	ctx.lr = 0x8281BA3C;
	sub_82DF3A08(ctx, base);
	// 8281BA3C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8281BA40: 57CBF87E  srwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8281BA44: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8281BA48: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8281BA4C: 41990008  bgt cr6, 0x8281ba54
	if ctx.cr[6].gt {
	pc = 0x8281BA54; continue 'dispatch;
	}
	// 8281BA50: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8281BA54: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281BA58: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8281BA5C: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8281BA60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281BA64: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8281BA68: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8281BA6C: 485D789D  bl 0x82df3308
	ctx.lr = 0x8281BA70;
	sub_82DF3308(ctx, base);
	// 8281BA70: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8281BA74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281BA78: 485D79B1  bl 0x82df3428
	ctx.lr = 0x8281BA7C;
	sub_82DF3428(ctx, base);
	// 8281BA7C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281BA80: 4082000C  bne 0x8281ba8c
	if !ctx.cr[0].eq {
	pc = 0x8281BA8C; continue 'dispatch;
	}
	// 8281BA84: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8281BA88: 4BFFFF7C  b 0x8281ba04
	pc = 0x8281BA04; continue 'dispatch;
	// 8281BA8C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8281BA90: 57CBF87E  srwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8281BA94: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8281BA98: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8281BA9C: 41990008  bgt cr6, 0x8281baa4
	if ctx.cr[6].gt {
	pc = 0x8281BAA4; continue 'dispatch;
	}
	// 8281BAA0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8281BAA4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281BAA8: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8281BAAC: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8281BAB0: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8281BAB4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8281BAB8: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281BABC: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 8281BAC0: 409A008C  bne cr6, 0x8281bb4c
	if !ctx.cr[6].eq {
	pc = 0x8281BB4C; continue 'dispatch;
	}
	// 8281BAC4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281BAC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281BACC: 485D7F3D  bl 0x82df3a08
	ctx.lr = 0x8281BAD0;
	sub_82DF3A08(ctx, base);
	// 8281BAD0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8281BAD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281BAD8: 4BCF3859  bl 0x8250f330
	ctx.lr = 0x8281BADC;
	sub_8250F330(ctx, base);
	// 8281BADC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281BAE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281BAE4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281BAE8: 4BCCF671  bl 0x824eb158
	ctx.lr = 0x8281BAEC;
	sub_824EB158(ctx, base);
	// 8281BAEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281BAF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281BAF4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8281BAF8: 409A0008  bne cr6, 0x8281bb00
	if !ctx.cr[6].eq {
	pc = 0x8281BB00; continue 'dispatch;
	}
	// 8281BAFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8281BB00: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8281BB04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281BB08: 4BCE5971  bl 0x82501478
	ctx.lr = 0x8281BB0C;
	sub_82501478(ctx, base);
	// 8281BB0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281BB10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281BB14: 485D617D  bl 0x82df1c90
	ctx.lr = 0x8281BB18;
	sub_82DF1C90(ctx, base);
	// 8281BB18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281BB1C: 485D6175  bl 0x82df1c90
	ctx.lr = 0x8281BB20;
	sub_82DF1C90(ctx, base);
	// 8281BB20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281BB24: 485D7905  bl 0x82df3428
	ctx.lr = 0x8281BB28;
	sub_82DF3428(ctx, base);
	// 8281BB28: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8281BB2C: 419A0018  beq cr6, 0x8281bb44
	if ctx.cr[6].eq {
	pc = 0x8281BB44; continue 'dispatch;
	}
	// 8281BB30: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8281BB34: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8281BB38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281BB3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8281BB40: 4BFFFCF1  bl 0x8281b830
	ctx.lr = 0x8281BB44;
	sub_8281B830(ctx, base);
	// 8281BB44: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 8281BB48: 419A0050  beq cr6, 0x8281bb98
	if ctx.cr[6].eq {
	pc = 0x8281BB98; continue 'dispatch;
	}
	// 8281BB4C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8281BB50: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8281BB54: 4BCF37DD  bl 0x8250f330
	ctx.lr = 0x8281BB58;
	sub_8250F330(ctx, base);
	// 8281BB58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281BB5C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8281BB60: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281BB64: 4BCCF5F5  bl 0x824eb158
	ctx.lr = 0x8281BB68;
	sub_824EB158(ctx, base);
	// 8281BB68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281BB6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281BB70: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8281BB74: 409A0008  bne cr6, 0x8281bb7c
	if !ctx.cr[6].eq {
	pc = 0x8281BB7C; continue 'dispatch;
	}
	// 8281BB78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8281BB7C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8281BB80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281BB84: 4BCE3FFD  bl 0x824ffb80
	ctx.lr = 0x8281BB88;
	sub_824FFB80(ctx, base);
	// 8281BB88: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8281BB8C: 485D6105  bl 0x82df1c90
	ctx.lr = 0x8281BB90;
	sub_82DF1C90(ctx, base);
	// 8281BB90: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8281BB94: 485D60FD  bl 0x82df1c90
	ctx.lr = 0x8281BB98;
	sub_82DF1C90(ctx, base);
	// 8281BB98: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8281BB9C: 4898C618  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281BBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281BBA0 size=88
    let mut pc: u32 = 0x8281BBA0;
    'dispatch: loop {
        match pc {
            0x8281BBA0 => {
    //   block [0x8281BBA0..0x8281BBF8)
	// 8281BBA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281BBA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281BBA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281BBAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281BBB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281BBB4: 3BE40018  addi r31, r4, 0x18
	ctx.r[31].s64 = ctx.r[4].s64 + 24;
	// 8281BBB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281BBBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BBC0: 485D7FE9  bl 0x82df3ba8
	ctx.lr = 0x8281BBC4;
	sub_82DF3BA8(ctx, base);
	// 8281BBC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281BBC8: 40820018  bne 0x8281bbe0
	if !ctx.cr[0].eq {
	pc = 0x8281BBE0; continue 'dispatch;
	}
	// 8281BBCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BBD0: 485D75E1  bl 0x82df31b0
	ctx.lr = 0x8281BBD4;
	sub_82DF31B0(ctx, base);
	// 8281BBD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281BBD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281BBDC: 4BFFFE0D  bl 0x8281b9e8
	ctx.lr = 0x8281BBE0;
	sub_8281B9E8(ctx, base);
	// 8281BBE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281BBE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281BBE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281BBEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281BBF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281BBF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281BBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281BBF8 size=124
    let mut pc: u32 = 0x8281BBF8;
    'dispatch: loop {
        match pc {
            0x8281BBF8 => {
    //   block [0x8281BBF8..0x8281BC74)
	// 8281BBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281BBFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281BC00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281BC04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281BC08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281BC0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281BC10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281BC14: 815E00C8  lwz r10, 0xc8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 8281BC18: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281BC1C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8281BC20: 48000034  b 0x8281bc54
	pc = 0x8281BC54; continue 'dispatch;
	// 8281BC24: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8281BC28: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8281BC2C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281BC30: 7D4A4839  and. r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8281BC34: 41820010  beq 0x8281bc44
	if ctx.cr[0].eq {
	pc = 0x8281BC44; continue 'dispatch;
	}
	// 8281BC38: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 8281BC3C: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 8281BC40: 4BC9D4D1  bl 0x824b9110
	ctx.lr = 0x8281BC44;
	sub_824B9110(ctx, base);
	// 8281BC44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281BC48: 4BB85A41  bl 0x823a1688
	ctx.lr = 0x8281BC4C;
	sub_823A1688(ctx, base);
	// 8281BC4C: 815E00C8  lwz r10, 0xc8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 8281BC50: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8281BC54: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8281BC58: 409AFFCC  bne cr6, 0x8281bc24
	if !ctx.cr[6].eq {
	pc = 0x8281BC24; continue 'dispatch;
	}
	// 8281BC5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281BC60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281BC64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281BC68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281BC6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281BC70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281BC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281BC78 size=500
    let mut pc: u32 = 0x8281BC78;
    'dispatch: loop {
        match pc {
            0x8281BC78 => {
    //   block [0x8281BC78..0x8281BE6C)
	// 8281BC78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281BC7C: 4898C4ED  bl 0x831a8168
	ctx.lr = 0x8281BC80;
	sub_831A8130(ctx, base);
	// 8281BC80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281BC84: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8281BC88: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281BC8C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281BC90: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8281BC94: 41820038  beq 0x8281bccc
	if ctx.cr[0].eq {
	pc = 0x8281BCCC; continue 'dispatch;
	}
	// 8281BC98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BC9C: 4898DCED  bl 0x831a9988
	ctx.lr = 0x8281BCA0;
	sub_831A9988(ctx, base);
	// 8281BCA0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281BCA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281BCA8: 386BF834  addi r3, r11, -0x7cc
	ctx.r[3].s64 = ctx.r[11].s64 + -1996;
	// 8281BCAC: 4898C44D  bl 0x831a80f8
	ctx.lr = 0x8281BCB0;
	sub_831A80F8(ctx, base);
	// 8281BCB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281BCB4: 41820018  beq 0x8281bccc
	if ctx.cr[0].eq {
	pc = 0x8281BCCC; continue 'dispatch;
	}
	// 8281BCB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281BCBC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8281BCC0: 4BFFF9E9  bl 0x8281b6a8
	ctx.lr = 0x8281BCC4;
	sub_8281B6A8(ctx, base);
	// 8281BCC4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8281BCC8: 4800019C  b 0x8281be64
	pc = 0x8281BE64; continue 'dispatch;
	// 8281BCCC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8281BCD0: 419A0184  beq cr6, 0x8281be54
	if ctx.cr[6].eq {
	pc = 0x8281BE54; continue 'dispatch;
	}
	// 8281BCD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BCD8: 4898DCB1  bl 0x831a9988
	ctx.lr = 0x8281BCDC;
	sub_831A9988(ctx, base);
	// 8281BCDC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281BCE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281BCE4: 386BF780  addi r3, r11, -0x880
	ctx.r[3].s64 = ctx.r[11].s64 + -2176;
	// 8281BCE8: 4898C411  bl 0x831a80f8
	ctx.lr = 0x8281BCEC;
	sub_831A80F8(ctx, base);
	// 8281BCEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281BCF0: 41820014  beq 0x8281bd04
	if ctx.cr[0].eq {
	pc = 0x8281BD04; continue 'dispatch;
	}
	// 8281BCF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281BCF8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8281BCFC: 4BFFFB8D  bl 0x8281b888
	ctx.lr = 0x8281BD00;
	sub_8281B888(ctx, base);
	// 8281BD00: 4BFFFFC4  b 0x8281bcc4
	pc = 0x8281BCC4; continue 'dispatch;
	// 8281BD04: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8281BD08: 419A014C  beq cr6, 0x8281be54
	if ctx.cr[6].eq {
	pc = 0x8281BE54; continue 'dispatch;
	}
	// 8281BD0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BD10: 4898DC79  bl 0x831a9988
	ctx.lr = 0x8281BD14;
	sub_831A9988(ctx, base);
	// 8281BD14: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281BD18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281BD1C: 386BF7AC  addi r3, r11, -0x854
	ctx.r[3].s64 = ctx.r[11].s64 + -2132;
	// 8281BD20: 4898C3D9  bl 0x831a80f8
	ctx.lr = 0x8281BD24;
	sub_831A80F8(ctx, base);
	// 8281BD24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281BD28: 41820014  beq 0x8281bd3c
	if ctx.cr[0].eq {
	pc = 0x8281BD3C; continue 'dispatch;
	}
	// 8281BD2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281BD30: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8281BD34: 4BFFFE6D  bl 0x8281bba0
	ctx.lr = 0x8281BD38;
	sub_8281BBA0(ctx, base);
	// 8281BD38: 4BFFFF8C  b 0x8281bcc4
	pc = 0x8281BCC4; continue 'dispatch;
	// 8281BD3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8281BD40: 419A0114  beq cr6, 0x8281be54
	if ctx.cr[6].eq {
	pc = 0x8281BE54; continue 'dispatch;
	}
	// 8281BD44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BD48: 4898DC41  bl 0x831a9988
	ctx.lr = 0x8281BD4C;
	sub_831A9988(ctx, base);
	// 8281BD4C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281BD50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281BD54: 386BF860  addi r3, r11, -0x7a0
	ctx.r[3].s64 = ctx.r[11].s64 + -1952;
	// 8281BD58: 4898C3A1  bl 0x831a80f8
	ctx.lr = 0x8281BD5C;
	sub_831A80F8(ctx, base);
	// 8281BD5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281BD60: 41820014  beq 0x8281bd74
	if ctx.cr[0].eq {
	pc = 0x8281BD74; continue 'dispatch;
	}
	// 8281BD64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281BD68: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8281BD6C: 4BFFFE8D  bl 0x8281bbf8
	ctx.lr = 0x8281BD70;
	sub_8281BBF8(ctx, base);
	// 8281BD70: 4BFFFF54  b 0x8281bcc4
	pc = 0x8281BCC4; continue 'dispatch;
	// 8281BD74: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8281BD78: 419A00DC  beq cr6, 0x8281be54
	if ctx.cr[6].eq {
	pc = 0x8281BE54; continue 'dispatch;
	}
	// 8281BD7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BD80: 4898DC09  bl 0x831a9988
	ctx.lr = 0x8281BD84;
	sub_831A9988(ctx, base);
	// 8281BD84: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 8281BD88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281BD8C: 386B5A88  addi r3, r11, 0x5a88
	ctx.r[3].s64 = ctx.r[11].s64 + 23176;
	// 8281BD90: 4898C369  bl 0x831a80f8
	ctx.lr = 0x8281BD94;
	sub_831A80F8(ctx, base);
	// 8281BD94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281BD98: 41820014  beq 0x8281bdac
	if ctx.cr[0].eq {
	pc = 0x8281BDAC; continue 'dispatch;
	}
	// 8281BD9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281BDA0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8281BDA4: 4BAA425D  bl 0x822c0000
	ctx.lr = 0x8281BDA8;
	sub_822C0000(ctx, base);
	// 8281BDA8: 4BFFFF1C  b 0x8281bcc4
	pc = 0x8281BCC4; continue 'dispatch;
	// 8281BDAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8281BDB0: 419A00A4  beq cr6, 0x8281be54
	if ctx.cr[6].eq {
	pc = 0x8281BE54; continue 'dispatch;
	}
	// 8281BDB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BDB8: 4898DBD1  bl 0x831a9988
	ctx.lr = 0x8281BDBC;
	sub_831A9988(ctx, base);
	// 8281BDBC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8281BDC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281BDC4: 386BD788  addi r3, r11, -0x2878
	ctx.r[3].s64 = ctx.r[11].s64 + -10360;
	// 8281BDC8: 4898C331  bl 0x831a80f8
	ctx.lr = 0x8281BDCC;
	sub_831A80F8(ctx, base);
	// 8281BDCC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281BDD0: 41820014  beq 0x8281bde4
	if ctx.cr[0].eq {
	pc = 0x8281BDE4; continue 'dispatch;
	}
	// 8281BDD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281BDD8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8281BDDC: 4BFFF495  bl 0x8281b270
	ctx.lr = 0x8281BDE0;
	sub_8281B270(ctx, base);
	// 8281BDE0: 4BFFFEE4  b 0x8281bcc4
	pc = 0x8281BCC4; continue 'dispatch;
	// 8281BDE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8281BDE8: 419A006C  beq cr6, 0x8281be54
	if ctx.cr[6].eq {
	pc = 0x8281BE54; continue 'dispatch;
	}
	// 8281BDEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BDF0: 4898DB99  bl 0x831a9988
	ctx.lr = 0x8281BDF4;
	sub_831A9988(ctx, base);
	// 8281BDF4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 8281BDF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281BDFC: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 8281BE00: 4898C2F9  bl 0x831a80f8
	ctx.lr = 0x8281BE04;
	sub_831A80F8(ctx, base);
	// 8281BE04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281BE08: 41820014  beq 0x8281be1c
	if ctx.cr[0].eq {
	pc = 0x8281BE1C; continue 'dispatch;
	}
	// 8281BE0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281BE10: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8281BE14: 4BFFF29D  bl 0x8281b0b0
	ctx.lr = 0x8281BE18;
	sub_8281B0B0(ctx, base);
	// 8281BE18: 4BFFFEAC  b 0x8281bcc4
	pc = 0x8281BCC4; continue 'dispatch;
	// 8281BE1C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8281BE20: 419A0034  beq cr6, 0x8281be54
	if ctx.cr[6].eq {
	pc = 0x8281BE54; continue 'dispatch;
	}
	// 8281BE24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BE28: 4898DB61  bl 0x831a9988
	ctx.lr = 0x8281BE2C;
	sub_831A9988(ctx, base);
	// 8281BE2C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 8281BE30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281BE34: 386B6BB0  addi r3, r11, 0x6bb0
	ctx.r[3].s64 = ctx.r[11].s64 + 27568;
	// 8281BE38: 4898C2C1  bl 0x831a80f8
	ctx.lr = 0x8281BE3C;
	sub_831A80F8(ctx, base);
	// 8281BE3C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281BE40: 41820014  beq 0x8281be54
	if ctx.cr[0].eq {
	pc = 0x8281BE54; continue 'dispatch;
	}
	// 8281BE44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281BE48: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8281BE4C: 4BFFF345  bl 0x8281b190
	ctx.lr = 0x8281BE50;
	sub_8281B190(ctx, base);
	// 8281BE50: 4BFFFE74  b 0x8281bcc4
	pc = 0x8281BCC4; continue 'dispatch;
	// 8281BE54: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8281BE58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281BE5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281BE60: 4BCF5739  bl 0x82511598
	ctx.lr = 0x8281BE64;
	sub_82511598(ctx, base);
	// 8281BE64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8281BE68: 4898C350  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281BE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281BE70 size=112
    let mut pc: u32 = 0x8281BE70;
    'dispatch: loop {
        match pc {
            0x8281BE70 => {
    //   block [0x8281BE70..0x8281BEE0)
	// 8281BE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281BE74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281BE78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281BE7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281BE80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281BE84: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 8281BE88: 485D6651  bl 0x82df24d8
	ctx.lr = 0x8281BE8C;
	sub_82DF24D8(ctx, base);
	// 8281BE8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BE90: 4BCF5261  bl 0x825110f0
	ctx.lr = 0x8281BE94;
	sub_825110F0(ctx, base);
	// 8281BE94: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281BE98: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8281BE9C: 396B99C0  addi r11, r11, -0x6640
	ctx.r[11].s64 = ctx.r[11].s64 + -26176;
	// 8281BEA0: 394A99AC  addi r10, r10, -0x6654
	ctx.r[10].s64 = ctx.r[10].s64 + -26196;
	// 8281BEA4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281BEA8: 387F00C4  addi r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 + 196;
	// 8281BEAC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8281BEB0: 4BF7FD49  bl 0x8279bbf8
	ctx.lr = 0x8281BEB4;
	sub_8279BBF8(ctx, base);
	// 8281BEB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281BEB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BEBC: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 8281BEC0: 917F00D8  stw r11, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 8281BEC4: 917F00DC  stw r11, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 8281BEC8: 917F00E0  stw r11, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 8281BECC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8281BED0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281BED4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281BED8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281BEDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281BEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281BEE0 size=76
    let mut pc: u32 = 0x8281BEE0;
    'dispatch: loop {
        match pc {
            0x8281BEE0 => {
    //   block [0x8281BEE0..0x8281BF2C)
	// 8281BEE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281BEE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281BEE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281BEEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281BEF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281BEF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281BEF8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281BEFC: 4BFFFA85  bl 0x8281b980
	ctx.lr = 0x8281BF00;
	sub_8281B980(ctx, base);
	// 8281BF00: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281BF04: 4182000C  beq 0x8281bf10
	if ctx.cr[0].eq {
	pc = 0x8281BF10; continue 'dispatch;
	}
	// 8281BF08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BF0C: 485D64CD  bl 0x82df23d8
	ctx.lr = 0x8281BF10;
	sub_82DF23D8(ctx, base);
	// 8281BF10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BF14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281BF18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281BF1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281BF20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281BF24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281BF28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281BF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281BF30 size=4
    let mut pc: u32 = 0x8281BF30;
    'dispatch: loop {
        match pc {
            0x8281BF30 => {
    //   block [0x8281BF30..0x8281BF34)
	// 8281BF30: 485D7280  b 0x82df31b0
	sub_82DF31B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281BF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281BF38 size=16
    let mut pc: u32 = 0x8281BF38;
    'dispatch: loop {
        match pc {
            0x8281BF38 => {
    //   block [0x8281BF38..0x8281BF48)
	// 8281BF38: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281BF3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8281BF40: 7D435830  slw r3, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 8281BF44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281BF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281BF48 size=88
    let mut pc: u32 = 0x8281BF48;
    'dispatch: loop {
        match pc {
            0x8281BF48 => {
    //   block [0x8281BF48..0x8281BFA0)
	// 8281BF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281BF4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281BF50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281BF54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281BF58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281BF5C: 485D7AAD  bl 0x82df3a08
	ctx.lr = 0x8281BF60;
	sub_82DF3A08(ctx, base);
	// 8281BF60: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8281BF64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8281BF68: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8281BF6C: 814BAE50  lwz r10, -0x51b0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20912 as u32) ) } as u64;
	// 8281BF70: 2B0A0020  cmplwi cr6, r10, 0x20
	ctx.cr[6].compare_u32(ctx.r[10].u32, 32 as u32, &mut ctx.xer);
	// 8281BF74: 40980014  bge cr6, 0x8281bf88
	if !ctx.cr[6].lt {
	pc = 0x8281BF88; continue 'dispatch;
	}
	// 8281BF78: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8281BF7C: 814BAE50  lwz r10, -0x51b0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20912 as u32) ) } as u64;
	// 8281BF80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281BF84: 914BAE50  stw r10, -0x51b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20912 as u32), ctx.r[10].u32 ) };
	// 8281BF88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BF8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8281BF90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281BF94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281BF98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281BF9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281BFA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281BFA0 size=340
    let mut pc: u32 = 0x8281BFA0;
    'dispatch: loop {
        match pc {
            0x8281BFA0 => {
    //   block [0x8281BFA0..0x8281C0F4)
	// 8281BFA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281BFA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281BFA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281BFAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281BFB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281BFB4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281BFB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281BFBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281BFC0: 388B9B50  addi r4, r11, -0x64b0
	ctx.r[4].s64 = ctx.r[11].s64 + -25776;
	// 8281BFC4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8281BFC8: 485D7A41  bl 0x82df3a08
	ctx.lr = 0x8281BFCC;
	sub_82DF3A08(ctx, base);
	// 8281BFCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281BFD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BFD4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8281BFD8: 4BFCFB59  bl 0x827ebb30
	ctx.lr = 0x8281BFDC;
	sub_827EBB30(ctx, base);
	// 8281BFDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281BFE0: 485D7449  bl 0x82df3428
	ctx.lr = 0x8281BFE4;
	sub_82DF3428(ctx, base);
	// 8281BFE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8281BFE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281BFEC: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 8281BFF0: 485D7A19  bl 0x82df3a08
	ctx.lr = 0x8281BFF4;
	sub_82DF3A08(ctx, base);
	// 8281BFF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281BFF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281BFFC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8281C000: 4BFCFB31  bl 0x827ebb30
	ctx.lr = 0x8281C004;
	sub_827EBB30(ctx, base);
	// 8281C004: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C008: 485D7421  bl 0x82df3428
	ctx.lr = 0x8281C00C;
	sub_82DF3428(ctx, base);
	// 8281C00C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281C010: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C014: 388B9B48  addi r4, r11, -0x64b8
	ctx.r[4].s64 = ctx.r[11].s64 + -25784;
	// 8281C018: 485D79F1  bl 0x82df3a08
	ctx.lr = 0x8281C01C;
	sub_82DF3A08(ctx, base);
	// 8281C01C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281C020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C024: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8281C028: 4BFCFB09  bl 0x827ebb30
	ctx.lr = 0x8281C02C;
	sub_827EBB30(ctx, base);
	// 8281C02C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C030: 485D73F9  bl 0x82df3428
	ctx.lr = 0x8281C034;
	sub_82DF3428(ctx, base);
	// 8281C034: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281C038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C03C: 388B9B40  addi r4, r11, -0x64c0
	ctx.r[4].s64 = ctx.r[11].s64 + -25792;
	// 8281C040: 485D79C9  bl 0x82df3a08
	ctx.lr = 0x8281C044;
	sub_82DF3A08(ctx, base);
	// 8281C044: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281C048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C04C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8281C050: 4BFCFAE1  bl 0x827ebb30
	ctx.lr = 0x8281C054;
	sub_827EBB30(ctx, base);
	// 8281C054: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C058: 485D73D1  bl 0x82df3428
	ctx.lr = 0x8281C05C;
	sub_82DF3428(ctx, base);
	// 8281C05C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281C060: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C064: 388B9B34  addi r4, r11, -0x64cc
	ctx.r[4].s64 = ctx.r[11].s64 + -25804;
	// 8281C068: 485D79A1  bl 0x82df3a08
	ctx.lr = 0x8281C06C;
	sub_82DF3A08(ctx, base);
	// 8281C06C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281C070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C074: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8281C078: 4BFCFAB9  bl 0x827ebb30
	ctx.lr = 0x8281C07C;
	sub_827EBB30(ctx, base);
	// 8281C07C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C080: 485D73A9  bl 0x82df3428
	ctx.lr = 0x8281C084;
	sub_82DF3428(ctx, base);
	// 8281C084: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281C088: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C08C: 388B9B2C  addi r4, r11, -0x64d4
	ctx.r[4].s64 = ctx.r[11].s64 + -25812;
	// 8281C090: 485D7979  bl 0x82df3a08
	ctx.lr = 0x8281C094;
	sub_82DF3A08(ctx, base);
	// 8281C094: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281C098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C09C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8281C0A0: 4BFCFB59  bl 0x827ebbf8
	ctx.lr = 0x8281C0A4;
	sub_827EBBF8(ctx, base);
	// 8281C0A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C0A8: 485D7381  bl 0x82df3428
	ctx.lr = 0x8281C0AC;
	sub_82DF3428(ctx, base);
	// 8281C0AC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281C0B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C0B4: 388B9B24  addi r4, r11, -0x64dc
	ctx.r[4].s64 = ctx.r[11].s64 + -25820;
	// 8281C0B8: 485D7951  bl 0x82df3a08
	ctx.lr = 0x8281C0BC;
	sub_82DF3A08(ctx, base);
	// 8281C0BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281C0C0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8281C0C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281C0C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C0CC: C02BA1C4  lfs f1, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281C0D0: 4BFCFCB1  bl 0x827ebd80
	ctx.lr = 0x8281C0D4;
	sub_827EBD80(ctx, base);
	// 8281C0D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C0D8: 485D7351  bl 0x82df3428
	ctx.lr = 0x8281C0DC;
	sub_82DF3428(ctx, base);
	// 8281C0DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281C0E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281C0E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281C0E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281C0EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281C0F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8281C0F8 size=12
    let mut pc: u32 = 0x8281C0F8;
    'dispatch: loop {
        match pc {
            0x8281C0F8 => {
    //   block [0x8281C0F8..0x8281C104)
	// 8281C0F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8281C0FC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281C100: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281C108 size=100
    let mut pc: u32 = 0x8281C108;
    'dispatch: loop {
        match pc {
            0x8281C108 => {
    //   block [0x8281C108..0x8281C16C)
	// 8281C108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281C10C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281C110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281C114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281C118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281C11C: 816300B0  lwz r11, 0xb0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) } as u64;
	// 8281C120: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8281C124: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281C128: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8281C12C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C130: 388A9B58  addi r4, r10, -0x64a8
	ctx.r[4].s64 = ctx.r[10].s64 + -25768;
	// 8281C134: 557EDFFE  rlwinm r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8281C138: 485D78D1  bl 0x82df3a08
	ctx.lr = 0x8281C13C;
	sub_82DF3A08(ctx, base);
	// 8281C13C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8281C140: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281C144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C148: 4BD85441  bl 0x825a1588
	ctx.lr = 0x8281C14C;
	sub_825A1588(ctx, base);
	// 8281C14C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C150: 485D72D9  bl 0x82df3428
	ctx.lr = 0x8281C154;
	sub_82DF3428(ctx, base);
	// 8281C154: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281C158: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281C15C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281C160: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281C164: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281C168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281C170 size=20
    let mut pc: u32 = 0x8281C170;
    'dispatch: loop {
        match pc {
            0x8281C170 => {
    //   block [0x8281C170..0x8281C184)
	// 8281C170: 816302B4  lwz r11, 0x2b4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281C174: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 8281C178: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8281C17C: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8281C180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281C188 size=32
    let mut pc: u32 = 0x8281C188;
    'dispatch: loop {
        match pc {
            0x8281C188 => {
    //   block [0x8281C188..0x8281C1A8)
	// 8281C188: 816302B4  lwz r11, 0x2b4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281C18C: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 8281C190: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 8281C194: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 8281C198: 41980008  blt cr6, 0x8281c1a0
	if ctx.cr[6].lt {
	pc = 0x8281C1A0; continue 'dispatch;
	}
	// 8281C19C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8281C1A0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8281C1A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281C1A8 size=188
    let mut pc: u32 = 0x8281C1A8;
    'dispatch: loop {
        match pc {
            0x8281C1A8 => {
    //   block [0x8281C1A8..0x8281C264)
	// 8281C1A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281C1AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281C1B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281C1B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281C1B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281C1BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281C1C0: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281C1C4: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 8281C1C8: 40980084  bge cr6, 0x8281c24c
	if !ctx.cr[6].lt {
	pc = 0x8281C24C; continue 'dispatch;
	}
	// 8281C1CC: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 8281C1D0: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8281C1D4: 409A0030  bne cr6, 0x8281c204
	if !ctx.cr[6].eq {
	pc = 0x8281C204; continue 'dispatch;
	}
	// 8281C1D8: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281C1DC: 817E0070  lwz r11, 0x70(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281C1E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281C1E4: 4E800421  bctrl
	ctx.lr = 0x8281C1E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281C1E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281C1EC: 817E0084  lwz r11, 0x84(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 8281C1F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C1F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281C1F8: 4E800421  bctrl
	ctx.lr = 0x8281C1FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281C1FC: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8281C200: 48000048  b 0x8281c248
	pc = 0x8281C248; continue 'dispatch;
	// 8281C204: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 8281C208: 409A0044  bne cr6, 0x8281c24c
	if !ctx.cr[6].eq {
	pc = 0x8281C24C; continue 'dispatch;
	}
	// 8281C20C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281C210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C214: 388B9B68  addi r4, r11, -0x6498
	ctx.r[4].s64 = ctx.r[11].s64 + -25752;
	// 8281C218: 485D77F1  bl 0x82df3a08
	ctx.lr = 0x8281C21C;
	sub_82DF3A08(ctx, base);
	// 8281C21C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281C220: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281C224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C228: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281C22C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281C230: 4E800421  bctrl
	ctx.lr = 0x8281C234;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281C234: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281C238: 4BFD2AB9  bl 0x827eecf0
	ctx.lr = 0x8281C23C;
	sub_827EECF0(ctx, base);
	// 8281C23C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 8281C240: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 8281C244: 915F02B8  stw r10, 0x2b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(696 as u32), ctx.r[10].u32 ) };
	// 8281C248: 917F02B4  stw r11, 0x2b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u32 ) };
	// 8281C24C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281C250: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281C254: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281C258: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281C25C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281C260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281C268 size=24
    let mut pc: u32 = 0x8281C268;
    'dispatch: loop {
        match pc {
            0x8281C268 => {
    //   block [0x8281C268..0x8281C280)
	// 8281C268: 816302B4  lwz r11, 0x2b4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281C26C: 396BFFF9  addi r11, r11, -7
	ctx.r[11].s64 = ctx.r[11].s64 + -7;
	// 8281C270: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8281C274: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8281C278: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 8281C27C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281C280 size=56
    let mut pc: u32 = 0x8281C280;
    'dispatch: loop {
        match pc {
            0x8281C280 => {
    //   block [0x8281C280..0x8281C2B8)
	// 8281C280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281C284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281C288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281C28C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281C290: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281C294: 4BCF68E5  bl 0x82512b78
	ctx.lr = 0x8281C298;
	sub_82512B78(ctx, base);
	// 8281C298: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8281C29C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C2A0: 4BCF37B1  bl 0x8250fa50
	ctx.lr = 0x8281C2A4;
	sub_8250FA50(ctx, base);
	// 8281C2A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8281C2A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281C2AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281C2B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281C2B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281C2B8 size=84
    let mut pc: u32 = 0x8281C2B8;
    'dispatch: loop {
        match pc {
            0x8281C2B8 => {
    //   block [0x8281C2B8..0x8281C30C)
	// 8281C2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281C2BC: 4898BEB1  bl 0x831a816c
	ctx.lr = 0x8281C2C0;
	sub_831A8130(ctx, base);
	// 8281C2C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281C2C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8281C2C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281C2CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281C2D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C2D4: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 8281C2D8: 485D7731  bl 0x82df3a08
	ctx.lr = 0x8281C2DC;
	sub_82DF3A08(ctx, base);
	// 8281C2DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C2E0: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 8281C2E4: 4BFCFEED  bl 0x827ec1d0
	ctx.lr = 0x8281C2E8;
	sub_827EC1D0(ctx, base);
	// 8281C2E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281C2EC: 4BFCE1F5  bl 0x827ea4e0
	ctx.lr = 0x8281C2F0;
	sub_827EA4E0(ctx, base);
	// 8281C2F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C2F4: 485D7135  bl 0x82df3428
	ctx.lr = 0x8281C2F8;
	sub_82DF3428(ctx, base);
	// 8281C2F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281C2FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C300: 4BFCF241  bl 0x827eb540
	ctx.lr = 0x8281C304;
	sub_827EB540(ctx, base);
	// 8281C304: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8281C308: 4898BEB4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281C310 size=84
    let mut pc: u32 = 0x8281C310;
    'dispatch: loop {
        match pc {
            0x8281C310 => {
    //   block [0x8281C310..0x8281C364)
	// 8281C310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281C314: 4898BE59  bl 0x831a816c
	ctx.lr = 0x8281C318;
	sub_831A8130(ctx, base);
	// 8281C318: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281C31C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281C320: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281C324: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281C328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C32C: 388B9B24  addi r4, r11, -0x64dc
	ctx.r[4].s64 = ctx.r[11].s64 + -25820;
	// 8281C330: 485D76D9  bl 0x82df3a08
	ctx.lr = 0x8281C334;
	sub_82DF3A08(ctx, base);
	// 8281C334: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C338: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 8281C33C: 4BFCFE95  bl 0x827ec1d0
	ctx.lr = 0x8281C340;
	sub_827EC1D0(ctx, base);
	// 8281C340: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281C344: 4BFCE19D  bl 0x827ea4e0
	ctx.lr = 0x8281C348;
	sub_827EA4E0(ctx, base);
	// 8281C348: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C34C: 485D70DD  bl 0x82df3428
	ctx.lr = 0x8281C350;
	sub_82DF3428(ctx, base);
	// 8281C350: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281C354: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C358: 4BFCEEB9  bl 0x827eb210
	ctx.lr = 0x8281C35C;
	sub_827EB210(ctx, base);
	// 8281C35C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8281C360: 4898BE5C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281C368 size=12
    let mut pc: u32 = 0x8281C368;
    'dispatch: loop {
        match pc {
            0x8281C368 => {
    //   block [0x8281C368..0x8281C374)
	// 8281C368: 816302B0  lwz r11, 0x2b0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(688 as u32) ) } as u64;
	// 8281C36C: 91640018  stw r11, 0x18(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8281C370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281C378 size=136
    let mut pc: u32 = 0x8281C378;
    'dispatch: loop {
        match pc {
            0x8281C378 => {
    //   block [0x8281C378..0x8281C400)
	// 8281C378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281C37C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281C380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281C384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281C388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281C38C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281C390: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281C394: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8281C398: 409A0020  bne cr6, 0x8281c3b8
	if !ctx.cr[6].eq {
	pc = 0x8281C3B8; continue 'dispatch;
	}
	// 8281C39C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281C3A0: 419A0048  beq cr6, 0x8281c3e8
	if ctx.cr[6].eq {
	pc = 0x8281C3E8; continue 'dispatch;
	}
	// 8281C3A4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 8281C3A8: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8281C3AC: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 8281C3B0: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8281C3B4: 48000034  b 0x8281c3e8
	pc = 0x8281C3E8; continue 'dispatch;
	// 8281C3B8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8281C3BC: 419A002C  beq cr6, 0x8281c3e8
	if ctx.cr[6].eq {
	pc = 0x8281C3E8; continue 'dispatch;
	}
	// 8281C3C0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281C3C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281C3C8: 388BFB38  addi r4, r11, -0x4c8
	ctx.r[4].s64 = ctx.r[11].s64 + -1224;
	// 8281C3CC: 4898BD2D  bl 0x831a80f8
	ctx.lr = 0x8281C3D0;
	sub_831A80F8(ctx, base);
	// 8281C3D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281C3D4: 4182000C  beq 0x8281c3e0
	if ctx.cr[0].eq {
	pc = 0x8281C3E0; continue 'dispatch;
	}
	// 8281C3D8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8281C3DC: 4800000C  b 0x8281c3e8
	pc = 0x8281C3E8; continue 'dispatch;
	// 8281C3E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281C3E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281C3E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281C3EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281C3F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281C3F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281C3F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281C3FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281C400 size=16
    let mut pc: u32 = 0x8281C400;
    'dispatch: loop {
        match pc {
            0x8281C400 => {
    //   block [0x8281C400..0x8281C410)
	// 8281C400: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281C404: 816C0088  lwz r11, 0x88(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(136 as u32) ) } as u64;
	// 8281C408: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281C40C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281C410 size=16
    let mut pc: u32 = 0x8281C410;
    'dispatch: loop {
        match pc {
            0x8281C410 => {
    //   block [0x8281C410..0x8281C420)
	// 8281C410: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281C414: 816C0098  lwz r11, 0x98(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(152 as u32) ) } as u64;
	// 8281C418: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281C41C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281C420 size=16
    let mut pc: u32 = 0x8281C420;
    'dispatch: loop {
        match pc {
            0x8281C420 => {
    //   block [0x8281C420..0x8281C430)
	// 8281C420: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281C424: 816C008C  lwz r11, 0x8c(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(140 as u32) ) } as u64;
	// 8281C428: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281C42C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281C430 size=16
    let mut pc: u32 = 0x8281C430;
    'dispatch: loop {
        match pc {
            0x8281C430 => {
    //   block [0x8281C430..0x8281C440)
	// 8281C430: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281C434: 816C0090  lwz r11, 0x90(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(144 as u32) ) } as u64;
	// 8281C438: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281C43C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281C440 size=16
    let mut pc: u32 = 0x8281C440;
    'dispatch: loop {
        match pc {
            0x8281C440 => {
    //   block [0x8281C440..0x8281C450)
	// 8281C440: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281C444: 816C0094  lwz r11, 0x94(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(148 as u32) ) } as u64;
	// 8281C448: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281C44C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281C450 size=500
    let mut pc: u32 = 0x8281C450;
    'dispatch: loop {
        match pc {
            0x8281C450 => {
    //   block [0x8281C450..0x8281C644)
	// 8281C450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281C454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281C458: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281C45C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8281C460: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281C464: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281C468: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281C46C: 4879464D  bl 0x82fb0ab8
	ctx.lr = 0x8281C470;
	sub_82FB0AB8(ctx, base);
	// 8281C470: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8281C474: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 8281C478: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8281C47C: 3CE08209  lis r7, -0x7df7
	ctx.r[7].s64 = -2113339392;
	// 8281C480: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 8281C484: C1A908A4  lfs f13, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8281C488: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8281C48C: C1889530  lfs f12, -0x6ad0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8281C490: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 8281C494: 394AA2F0  addi r10, r10, -0x5d10
	ctx.r[10].s64 = ctx.r[10].s64 + -23824;
	// 8281C498: D1A100B0  stfs f13, 0xb0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8281C49C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281C4A0: C007ACFC  lfs f0, -0x5304(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8281C4A4: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 8281C4A8: C1669534  lfs f11, -0x6acc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8281C4AC: 3C808203  lis r4, -0x7dfd
	ctx.r[4].s64 = -2113732608;
	// 8281C4B0: C1290A90  lfs f9, 0xa90(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2704 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8281C4B4: C1089450  lfs f8, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8281C4B8: 396B5D40  addi r11, r11, 0x5d40
	ctx.r[11].s64 = ctx.r[11].s64 + 23872;
	// 8281C4BC: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8281C4C0: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 8281C4C4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281C648 size=356
    let mut pc: u32 = 0x8281C648;
    'dispatch: loop {
        match pc {
            0x8281C648 => {
    //   block [0x8281C648..0x8281C7AC)
	// 8281C648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281C64C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281C650: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281C654: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281C658: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8281C65C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281C660: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281C664: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8281C668: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281C66C: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281C670: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8281C674: 419A000C  beq cr6, 0x8281c680
	if ctx.cr[6].eq {
	pc = 0x8281C680; continue 'dispatch;
	}
	// 8281C678: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8281C67C: 409A0038  bne cr6, 0x8281c6b4
	if !ctx.cr[6].eq {
	pc = 0x8281C6B4; continue 'dispatch;
	}
	// 8281C680: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281C684: C03F02C8  lfs f1, 0x2c8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281C688: 4BFD16B9  bl 0x827edd40
	ctx.lr = 0x8281C68C;
	sub_827EDD40(ctx, base);
	// 8281C68C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281C690: 41820024  beq 0x8281c6b4
	if ctx.cr[0].eq {
	pc = 0x8281C6B4; continue 'dispatch;
	}
	// 8281C694: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281C698: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281C69C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C6A0: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 8281C6A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281C6A8: 4E800421  bctrl
	ctx.lr = 0x8281C6AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281C6AC: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8281C6B0: 917F02B4  stw r11, 0x2b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u32 ) };
	// 8281C6B4: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281C6B8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8281C6BC: 409A0068  bne cr6, 0x8281c724
	if !ctx.cr[6].eq {
	pc = 0x8281C724; continue 'dispatch;
	}
	// 8281C6C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281C6C4: C03F02CC  lfs f1, 0x2cc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(716 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281C6C8: 4BFD1679  bl 0x827edd40
	ctx.lr = 0x8281C6CC;
	sub_827EDD40(ctx, base);
	// 8281C6CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281C6D0: 418200C0  beq 0x8281c790
	if ctx.cr[0].eq {
	pc = 0x8281C790; continue 'dispatch;
	}
	// 8281C6D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281C6D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281C6DC: 80BF02B8  lwz r5, 0x2b8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(696 as u32) ) } as u64;
	// 8281C6E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C6E4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8281C6E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281C6EC: 4E800421  bctrl
	ctx.lr = 0x8281C6F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281C6F0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281C6F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C6F8: 388B9B68  addi r4, r11, -0x6498
	ctx.r[4].s64 = ctx.r[11].s64 + -25752;
	// 8281C6FC: 485D730D  bl 0x82df3a08
	ctx.lr = 0x8281C700;
	sub_82DF3A08(ctx, base);
	// 8281C700: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281C704: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281C708: 4BFD2FB1  bl 0x827ef6b8
	ctx.lr = 0x8281C70C;
	sub_827EF6B8(ctx, base);
	// 8281C70C: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 8281C710: 915F02B4  stw r10, 0x2b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[10].u32 ) };
	// 8281C714: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281C718: C00B9B20  lfs f0, -0x64e0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8281C71C: D01F02C0  stfs f0, 0x2c0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(704 as u32), tmp.u32 ) };
	// 8281C720: 48000070  b 0x8281c790
	pc = 0x8281C790; continue 'dispatch;
	// 8281C724: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8281C728: 409A0068  bne cr6, 0x8281c790
	if !ctx.cr[6].eq {
	pc = 0x8281C790; continue 'dispatch;
	}
	// 8281C72C: C01F02C0  lfs f0, 0x2c0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8281C730: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8281C734: EDA0F828  fsubs f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8281C738: D1BF02C0  stfs f13, 0x2c0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(704 as u32), tmp.u32 ) };
	// 8281C73C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281C740: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8281C744: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8281C748: 40980020  bge cr6, 0x8281c768
	if !ctx.cr[6].lt {
	pc = 0x8281C768; continue 'dispatch;
	}
	// 8281C74C: C03F02CC  lfs f1, 0x2cc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(716 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281C750: 4BFD15F1  bl 0x827edd40
	ctx.lr = 0x8281C754;
	sub_827EDD40(ctx, base);
	// 8281C754: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281C758: 4082FFBC  bne 0x8281c714
	if !ctx.cr[0].eq {
	pc = 0x8281C714; continue 'dispatch;
	}
	// 8281C75C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8281C760: 917F02B4  stw r11, 0x2b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u32 ) };
	// 8281C764: 4800002C  b 0x8281c790
	pc = 0x8281C790; continue 'dispatch;
	// 8281C768: 4BFD1869  bl 0x827edfd0
	ctx.lr = 0x8281C76C;
	sub_827EDFD0(ctx, base);
	// 8281C76C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281C770: 41820020  beq 0x8281c790
	if ctx.cr[0].eq {
	pc = 0x8281C790; continue 'dispatch;
	}
	// 8281C774: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281C778: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C77C: 388B9B68  addi r4, r11, -0x6498
	ctx.r[4].s64 = ctx.r[11].s64 + -25752;
	// 8281C780: 485D7289  bl 0x82df3a08
	ctx.lr = 0x8281C784;
	sub_82DF3A08(ctx, base);
	// 8281C784: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281C788: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281C78C: 4BFD2F2D  bl 0x827ef6b8
	ctx.lr = 0x8281C790;
	sub_827EF6B8(ctx, base);
	// 8281C790: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8281C794: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281C798: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281C79C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8281C7A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281C7A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281C7A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281C7B0 size=200
    let mut pc: u32 = 0x8281C7B0;
    'dispatch: loop {
        match pc {
            0x8281C7B0 => {
    //   block [0x8281C7B0..0x8281C878)
	// 8281C7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281C7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281C7B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281C7BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281C7C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281C7C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281C7C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281C7CC: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281C7D0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8281C7D4: 419A000C  beq cr6, 0x8281c7e0
	if ctx.cr[6].eq {
	pc = 0x8281C7E0; continue 'dispatch;
	}
	// 8281C7D8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8281C7DC: 409A0038  bne cr6, 0x8281c814
	if !ctx.cr[6].eq {
	pc = 0x8281C814; continue 'dispatch;
	}
	// 8281C7E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281C7E4: C03F02C8  lfs f1, 0x2c8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281C7E8: 4BFD1559  bl 0x827edd40
	ctx.lr = 0x8281C7EC;
	sub_827EDD40(ctx, base);
	// 8281C7EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281C7F0: 41820024  beq 0x8281c814
	if ctx.cr[0].eq {
	pc = 0x8281C814; continue 'dispatch;
	}
	// 8281C7F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281C7F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281C7FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281C800: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 8281C804: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281C808: 4E800421  bctrl
	ctx.lr = 0x8281C80C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281C80C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8281C810: 917F02B4  stw r11, 0x2b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u32 ) };
	// 8281C814: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281C818: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8281C81C: 409A0010  bne cr6, 0x8281c82c
	if !ctx.cr[6].eq {
	pc = 0x8281C82C; continue 'dispatch;
	}
	// 8281C820: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 8281C824: 917F02B4  stw r11, 0x2b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u32 ) };
	// 8281C828: 48000038  b 0x8281c860
	pc = 0x8281C860; continue 'dispatch;
	// 8281C82C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8281C830: 409A0030  bne cr6, 0x8281c860
	if !ctx.cr[6].eq {
	pc = 0x8281C860; continue 'dispatch;
	}
	// 8281C834: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281C838: 4BFD1799  bl 0x827edfd0
	ctx.lr = 0x8281C83C;
	sub_827EDFD0(ctx, base);
	// 8281C83C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281C840: 41820020  beq 0x8281c860
	if ctx.cr[0].eq {
	pc = 0x8281C860; continue 'dispatch;
	}
	// 8281C844: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281C848: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C84C: 388B9B68  addi r4, r11, -0x6498
	ctx.r[4].s64 = ctx.r[11].s64 + -25752;
	// 8281C850: 485D71B9  bl 0x82df3a08
	ctx.lr = 0x8281C854;
	sub_82DF3A08(ctx, base);
	// 8281C854: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281C858: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281C85C: 4BFD2E5D  bl 0x827ef6b8
	ctx.lr = 0x8281C860;
	sub_827EF6B8(ctx, base);
	// 8281C860: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281C864: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281C868: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281C86C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281C870: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281C874: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281C878 size=152
    let mut pc: u32 = 0x8281C878;
    'dispatch: loop {
        match pc {
            0x8281C878 => {
    //   block [0x8281C878..0x8281C910)
	// 8281C878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281C87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281C880: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281C884: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281C888: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281C88C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8281C890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C894: 809F01DC  lwz r4, 0x1dc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 8281C898: 4BAD7411  bl 0x822f3ca8
	ctx.lr = 0x8281C89C;
	sub_822F3CA8(ctx, base);
	// 8281C89C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281C8A0: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8281C8A4: C00B964C  lfs f0, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8281C8A8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8281C8AC: 41980020  blt cr6, 0x8281c8cc
	if ctx.cr[6].lt {
	pc = 0x8281C8CC; continue 'dispatch;
	}
	// 8281C8B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8281C8B4: C19F02A4  lfs f12, 0x2a4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(676 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8281C8B8: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8281C8BC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 8281C8C0: 4098001C  bge cr6, 0x8281c8dc
	if !ctx.cr[6].lt {
	pc = 0x8281C8DC; continue 'dispatch;
	}
	// 8281C8C4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8281C8C8: 40990014  ble cr6, 0x8281c8dc
	if !ctx.cr[6].gt {
	pc = 0x8281C8DC; continue 'dispatch;
	}
	// 8281C8CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281C8D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281C8D4: C02BA9F0  lfs f1, -0x5610(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22032 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281C8D8: 48660C31  bl 0x82e7d508
	ctx.lr = 0x8281C8DC;
	sub_82E7D508(ctx, base);
	// 8281C8DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8281C8E0: 807F01DC  lwz r3, 0x1dc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 8281C8E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8281C8E8: 4BAD7451  bl 0x822f3d38
	ctx.lr = 0x8281C8EC;
	sub_822F3D38(ctx, base);
	// 8281C8EC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8281C8F0: 394002A0  li r10, 0x2a0
	ctx.r[10].s64 = 672;
	// 8281C8F4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281C910 size=132
    let mut pc: u32 = 0x8281C910;
    'dispatch: loop {
        match pc {
            0x8281C910 => {
    //   block [0x8281C910..0x8281C994)
	// 8281C910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281C914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281C918: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281C91C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281C920: 8163025C  lwz r11, 0x25c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(604 as u32) ) } as u64;
	// 8281C924: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281C928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281C92C: 419A0054  beq cr6, 0x8281c980
	if ctx.cr[6].eq {
	pc = 0x8281C980; continue 'dispatch;
	}
	// 8281C930: 814302B4  lwz r10, 0x2b4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281C934: 2B0A0007  cmplwi cr6, r10, 7
	ctx.cr[6].compare_u32(ctx.r[10].u32, 7 as u32, &mut ctx.xer);
	// 8281C938: 40980048  bge cr6, 0x8281c980
	if !ctx.cr[6].lt {
	pc = 0x8281C980; continue 'dispatch;
	}
	// 8281C93C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281C940: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8281C944: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8281C948: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281C94C: 4E800421  bctrl
	ctx.lr = 0x8281C950;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281C950: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8281C954: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8281C958: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8281C95C: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8281C960: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8281C964: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8281C968: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8281C96C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8281C970: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8281C974: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8281C978: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281C998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281C998 size=196
    let mut pc: u32 = 0x8281C998;
    'dispatch: loop {
        match pc {
            0x8281C998 => {
    //   block [0x8281C998..0x8281CA5C)
	// 8281C998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281C99C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281C9A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281C9A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281C9A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281C9AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281C9B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281C9B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8281C9B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281C9BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281C9C0: 4BAA3F79  bl 0x822c0938
	ctx.lr = 0x8281C9C4;
	sub_822C0938(ctx, base);
	// 8281C9C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281C9C8: 41820028  beq 0x8281c9f0
	if ctx.cr[0].eq {
	pc = 0x8281C9F0; continue 'dispatch;
	}
	// 8281C9CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281C9D0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8281C9D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8281C9D8: 392B9B88  addi r9, r11, -0x6478
	ctx.r[9].s64 = ctx.r[11].s64 + -25720;
	// 8281C9DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8281C9E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281C9E4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8281C9E8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8281C9EC: 48000008  b 0x8281c9f4
	pc = 0x8281C9F4; continue 'dispatch;
	// 8281C9F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281C9F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281C9F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281C9FC: 409A0044  bne cr6, 0x8281ca40
	if !ctx.cr[6].eq {
	pc = 0x8281CA40; continue 'dispatch;
	}
	// 8281CA00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281CA04: 419A001C  beq cr6, 0x8281ca20
	if ctx.cr[6].eq {
	pc = 0x8281CA20; continue 'dispatch;
	}
	// 8281CA08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281CA0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8281CA10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281CA14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281CA18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281CA1C: 4E800421  bctrl
	ctx.lr = 0x8281CA20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281CA20: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281CA24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8281CA28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281CA2C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8281CA30: 816BF8C4  lwz r11, -0x73c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1852 as u32) ) } as u64;
	// 8281CA34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8281CA38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281CA3C: 4BAA35C5  bl 0x822c0000
	ctx.lr = 0x8281CA40;
	sub_822C0000(ctx, base);
	// 8281CA40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281CA44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281CA48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281CA4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281CA50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281CA54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281CA58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281CA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281CA60 size=196
    let mut pc: u32 = 0x8281CA60;
    'dispatch: loop {
        match pc {
            0x8281CA60 => {
    //   block [0x8281CA60..0x8281CB24)
	// 8281CA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281CA64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281CA68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281CA6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281CA70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281CA74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281CA78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281CA7C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8281CA80: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281CA84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281CA88: 4BAA3EB1  bl 0x822c0938
	ctx.lr = 0x8281CA8C;
	sub_822C0938(ctx, base);
	// 8281CA8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281CA90: 41820028  beq 0x8281cab8
	if ctx.cr[0].eq {
	pc = 0x8281CAB8; continue 'dispatch;
	}
	// 8281CA94: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281CA98: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8281CA9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8281CAA0: 392B9B9C  addi r9, r11, -0x6464
	ctx.r[9].s64 = ctx.r[11].s64 + -25700;
	// 8281CAA4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8281CAA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281CAAC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8281CAB0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8281CAB4: 48000008  b 0x8281cabc
	pc = 0x8281CABC; continue 'dispatch;
	// 8281CAB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281CABC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281CAC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281CAC4: 409A0044  bne cr6, 0x8281cb08
	if !ctx.cr[6].eq {
	pc = 0x8281CB08; continue 'dispatch;
	}
	// 8281CAC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281CACC: 419A001C  beq cr6, 0x8281cae8
	if ctx.cr[6].eq {
	pc = 0x8281CAE8; continue 'dispatch;
	}
	// 8281CAD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281CAD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8281CAD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281CADC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281CAE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281CAE4: 4E800421  bctrl
	ctx.lr = 0x8281CAE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281CAE8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281CAEC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8281CAF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281CAF4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8281CAF8: 816BF8C4  lwz r11, -0x73c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1852 as u32) ) } as u64;
	// 8281CAFC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8281CB00: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281CB04: 4BAA34FD  bl 0x822c0000
	ctx.lr = 0x8281CB08;
	sub_822C0000(ctx, base);
	// 8281CB08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281CB0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281CB10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281CB14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281CB18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281CB1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281CB20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281CB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281CB28 size=196
    let mut pc: u32 = 0x8281CB28;
    'dispatch: loop {
        match pc {
            0x8281CB28 => {
    //   block [0x8281CB28..0x8281CBEC)
	// 8281CB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281CB2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281CB30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281CB34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281CB38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281CB3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281CB40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281CB44: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8281CB48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281CB4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281CB50: 4BAA3DE9  bl 0x822c0938
	ctx.lr = 0x8281CB54;
	sub_822C0938(ctx, base);
	// 8281CB54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281CB58: 41820028  beq 0x8281cb80
	if ctx.cr[0].eq {
	pc = 0x8281CB80; continue 'dispatch;
	}
	// 8281CB5C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281CB60: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8281CB64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8281CB68: 392B9BB0  addi r9, r11, -0x6450
	ctx.r[9].s64 = ctx.r[11].s64 + -25680;
	// 8281CB6C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8281CB70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281CB74: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8281CB78: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8281CB7C: 48000008  b 0x8281cb84
	pc = 0x8281CB84; continue 'dispatch;
	// 8281CB80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281CB84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281CB88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281CB8C: 409A0044  bne cr6, 0x8281cbd0
	if !ctx.cr[6].eq {
	pc = 0x8281CBD0; continue 'dispatch;
	}
	// 8281CB90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281CB94: 419A001C  beq cr6, 0x8281cbb0
	if ctx.cr[6].eq {
	pc = 0x8281CBB0; continue 'dispatch;
	}
	// 8281CB98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281CB9C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8281CBA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281CBA4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281CBA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281CBAC: 4E800421  bctrl
	ctx.lr = 0x8281CBB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281CBB0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281CBB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8281CBB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281CBBC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8281CBC0: 816BF8C4  lwz r11, -0x73c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1852 as u32) ) } as u64;
	// 8281CBC4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8281CBC8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281CBCC: 4BAA3435  bl 0x822c0000
	ctx.lr = 0x8281CBD0;
	sub_822C0000(ctx, base);
	// 8281CBD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281CBD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281CBD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281CBDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281CBE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281CBE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281CBE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281CBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281CBF0 size=196
    let mut pc: u32 = 0x8281CBF0;
    'dispatch: loop {
        match pc {
            0x8281CBF0 => {
    //   block [0x8281CBF0..0x8281CCB4)
	// 8281CBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281CBF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281CBF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281CBFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281CC00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281CC04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281CC08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281CC0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8281CC10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281CC14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281CC18: 4BAA3D21  bl 0x822c0938
	ctx.lr = 0x8281CC1C;
	sub_822C0938(ctx, base);
	// 8281CC1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281CC20: 41820028  beq 0x8281cc48
	if ctx.cr[0].eq {
	pc = 0x8281CC48; continue 'dispatch;
	}
	// 8281CC24: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281CC28: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8281CC2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8281CC30: 392B9BC4  addi r9, r11, -0x643c
	ctx.r[9].s64 = ctx.r[11].s64 + -25660;
	// 8281CC34: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8281CC38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281CC3C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8281CC40: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8281CC44: 48000008  b 0x8281cc4c
	pc = 0x8281CC4C; continue 'dispatch;
	// 8281CC48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281CC4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281CC50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281CC54: 409A0044  bne cr6, 0x8281cc98
	if !ctx.cr[6].eq {
	pc = 0x8281CC98; continue 'dispatch;
	}
	// 8281CC58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281CC5C: 419A001C  beq cr6, 0x8281cc78
	if ctx.cr[6].eq {
	pc = 0x8281CC78; continue 'dispatch;
	}
	// 8281CC60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281CC64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8281CC68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281CC6C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281CC70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281CC74: 4E800421  bctrl
	ctx.lr = 0x8281CC78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281CC78: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281CC7C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8281CC80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281CC84: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8281CC88: 816BF8C4  lwz r11, -0x73c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1852 as u32) ) } as u64;
	// 8281CC8C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8281CC90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281CC94: 4BAA336D  bl 0x822c0000
	ctx.lr = 0x8281CC98;
	sub_822C0000(ctx, base);
	// 8281CC98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281CC9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281CCA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281CCA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281CCA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281CCAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281CCB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281CCB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281CCB8 size=196
    let mut pc: u32 = 0x8281CCB8;
    'dispatch: loop {
        match pc {
            0x8281CCB8 => {
    //   block [0x8281CCB8..0x8281CD7C)
	// 8281CCB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281CCBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281CCC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281CCC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281CCC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281CCCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281CCD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281CCD4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8281CCD8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281CCDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281CCE0: 4BAA3C59  bl 0x822c0938
	ctx.lr = 0x8281CCE4;
	sub_822C0938(ctx, base);
	// 8281CCE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281CCE8: 41820028  beq 0x8281cd10
	if ctx.cr[0].eq {
	pc = 0x8281CD10; continue 'dispatch;
	}
	// 8281CCEC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281CCF0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8281CCF4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8281CCF8: 392B9BD8  addi r9, r11, -0x6428
	ctx.r[9].s64 = ctx.r[11].s64 + -25640;
	// 8281CCFC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8281CD00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281CD04: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8281CD08: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8281CD0C: 48000008  b 0x8281cd14
	pc = 0x8281CD14; continue 'dispatch;
	// 8281CD10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281CD14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281CD18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281CD1C: 409A0044  bne cr6, 0x8281cd60
	if !ctx.cr[6].eq {
	pc = 0x8281CD60; continue 'dispatch;
	}
	// 8281CD20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281CD24: 419A001C  beq cr6, 0x8281cd40
	if ctx.cr[6].eq {
	pc = 0x8281CD40; continue 'dispatch;
	}
	// 8281CD28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281CD2C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8281CD30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281CD34: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281CD38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281CD3C: 4E800421  bctrl
	ctx.lr = 0x8281CD40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281CD40: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281CD44: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8281CD48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281CD4C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8281CD50: 816BF8C4  lwz r11, -0x73c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1852 as u32) ) } as u64;
	// 8281CD54: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8281CD58: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281CD5C: 4BAA32A5  bl 0x822c0000
	ctx.lr = 0x8281CD60;
	sub_822C0000(ctx, base);
	// 8281CD60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281CD64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281CD68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281CD6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281CD70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281CD74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281CD78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281CD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281CD80 size=196
    let mut pc: u32 = 0x8281CD80;
    'dispatch: loop {
        match pc {
            0x8281CD80 => {
    //   block [0x8281CD80..0x8281CE44)
	// 8281CD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281CD84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281CD88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281CD8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281CD90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281CD94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281CD98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281CD9C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8281CDA0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281CDA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281CDA8: 4BAA3B91  bl 0x822c0938
	ctx.lr = 0x8281CDAC;
	sub_822C0938(ctx, base);
	// 8281CDAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281CDB0: 41820028  beq 0x8281cdd8
	if ctx.cr[0].eq {
	pc = 0x8281CDD8; continue 'dispatch;
	}
	// 8281CDB4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281CDB8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8281CDBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8281CDC0: 392B9BEC  addi r9, r11, -0x6414
	ctx.r[9].s64 = ctx.r[11].s64 + -25620;
	// 8281CDC4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8281CDC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281CDCC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8281CDD0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8281CDD4: 48000008  b 0x8281cddc
	pc = 0x8281CDDC; continue 'dispatch;
	// 8281CDD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281CDDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281CDE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281CDE4: 409A0044  bne cr6, 0x8281ce28
	if !ctx.cr[6].eq {
	pc = 0x8281CE28; continue 'dispatch;
	}
	// 8281CDE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281CDEC: 419A001C  beq cr6, 0x8281ce08
	if ctx.cr[6].eq {
	pc = 0x8281CE08; continue 'dispatch;
	}
	// 8281CDF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281CDF4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8281CDF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281CDFC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281CE00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281CE04: 4E800421  bctrl
	ctx.lr = 0x8281CE08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281CE08: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281CE0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8281CE10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281CE14: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8281CE18: 816BF8C4  lwz r11, -0x73c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1852 as u32) ) } as u64;
	// 8281CE1C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8281CE20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281CE24: 4BAA31DD  bl 0x822c0000
	ctx.lr = 0x8281CE28;
	sub_822C0000(ctx, base);
	// 8281CE28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281CE2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281CE30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281CE34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281CE38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281CE3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281CE40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281CE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281CE48 size=196
    let mut pc: u32 = 0x8281CE48;
    'dispatch: loop {
        match pc {
            0x8281CE48 => {
    //   block [0x8281CE48..0x8281CF0C)
	// 8281CE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281CE4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281CE50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281CE54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281CE58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281CE5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281CE60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281CE64: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8281CE68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281CE6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281CE70: 4BAA3AC9  bl 0x822c0938
	ctx.lr = 0x8281CE74;
	sub_822C0938(ctx, base);
	// 8281CE74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281CE78: 41820028  beq 0x8281cea0
	if ctx.cr[0].eq {
	pc = 0x8281CEA0; continue 'dispatch;
	}
	// 8281CE7C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281CE80: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8281CE84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8281CE88: 392B9C00  addi r9, r11, -0x6400
	ctx.r[9].s64 = ctx.r[11].s64 + -25600;
	// 8281CE8C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8281CE90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281CE94: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8281CE98: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8281CE9C: 48000008  b 0x8281cea4
	pc = 0x8281CEA4; continue 'dispatch;
	// 8281CEA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281CEA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281CEA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281CEAC: 409A0044  bne cr6, 0x8281cef0
	if !ctx.cr[6].eq {
	pc = 0x8281CEF0; continue 'dispatch;
	}
	// 8281CEB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281CEB4: 419A001C  beq cr6, 0x8281ced0
	if ctx.cr[6].eq {
	pc = 0x8281CED0; continue 'dispatch;
	}
	// 8281CEB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281CEBC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8281CEC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281CEC4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281CEC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281CECC: 4E800421  bctrl
	ctx.lr = 0x8281CED0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281CED0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281CED4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8281CED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281CEDC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8281CEE0: 816BF8C4  lwz r11, -0x73c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1852 as u32) ) } as u64;
	// 8281CEE4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8281CEE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281CEEC: 4BAA3115  bl 0x822c0000
	ctx.lr = 0x8281CEF0;
	sub_822C0000(ctx, base);
	// 8281CEF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281CEF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281CEF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281CEFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281CF00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281CF04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281CF08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281CF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281CF10 size=392
    let mut pc: u32 = 0x8281CF10;
    'dispatch: loop {
        match pc {
            0x8281CF10 => {
    //   block [0x8281CF10..0x8281D098)
	// 8281CF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281CF14: 4898B251  bl 0x831a8164
	ctx.lr = 0x8281CF18;
	sub_831A8130(ctx, base);
	// 8281CF18: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8281CF1C: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281CF20: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8281CF24: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8281CF28: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 8281CF2C: 392BBA80  addi r9, r11, -0x4580
	ctx.r[9].s64 = ctx.r[11].s64 + -17792;
	// 8281CF30: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 8281CF34: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 8281CF38: C00BBA80  lfs f0, -0x4580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8281CF3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281CF40: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8281CF44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281CF48: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8281CF4C: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8281CF50: C1A90008  lfs f13, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8281CF54: C189000C  lfs f12, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8281CF58: 83BE01DC  lwz r29, 0x1dc(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(476 as u32) ) } as u64;
	// 8281CF5C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8281CF60: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8281CF64: D181005C  stfs f12, 0x5c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281D098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281D098 size=232
    let mut pc: u32 = 0x8281D098;
    'dispatch: loop {
        match pc {
            0x8281D098 => {
    //   block [0x8281D098..0x8281D180)
	// 8281D098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281D09C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281D0A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281D0A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281D0A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281D0AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281D0B0: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281D0B4: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 8281D0B8: 409800B0  bge cr6, 0x8281d168
	if !ctx.cr[6].lt {
	pc = 0x8281D168; continue 'dispatch;
	}
	// 8281D0BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D0C0: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281D0C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281D0C8: 4E800421  bctrl
	ctx.lr = 0x8281D0CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281D0CC: 4BFD0765  bl 0x827ed830
	ctx.lr = 0x8281D0D0;
	sub_827ED830(ctx, base);
	// 8281D0D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D0D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281D0D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281D0DC: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281D0E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281D0E4: 4E800421  bctrl
	ctx.lr = 0x8281D0E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281D0E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281D0EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281D0F0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8281D0F4: 4BFD18F5  bl 0x827ee9e8
	ctx.lr = 0x8281D0F8;
	sub_827EE9E8(ctx, base);
	// 8281D0F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D0FC: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 8281D100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281D104: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281D108: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281D10C: 4E800421  bctrl
	ctx.lr = 0x8281D110;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281D110: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281D114: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8281D118: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8281D11C: 4BFD0FFD  bl 0x827ee118
	ctx.lr = 0x8281D120;
	sub_827EE118(ctx, base);
	// 8281D120: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8281D124: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8281D128: 807F02D4  lwz r3, 0x2d4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(724 as u32) ) } as u64;
	// 8281D12C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8281D130: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 8281D134: 3929F8E0  addi r9, r9, -0x720
	ctx.r[9].s64 = ctx.r[9].s64 + -1824;
	// 8281D138: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8281D13C: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 8281D140: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8281D144: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8281D148: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281D180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281D180 size=632
    let mut pc: u32 = 0x8281D180;
    'dispatch: loop {
        match pc {
            0x8281D180 => {
    //   block [0x8281D180..0x8281D3F8)
	// 8281D180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281D184: 4898AFE9  bl 0x831a816c
	ctx.lr = 0x8281D188;
	sub_831A8130(ctx, base);
	// 8281D188: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281D18C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8281D190: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281D194: 817D02B4  lwz r11, 0x2b4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281D198: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8281D19C: 409A0254  bne cr6, 0x8281d3f0
	if !ctx.cr[6].eq {
	pc = 0x8281D3F0; continue 'dispatch;
	}
	// 8281D1A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281D1A4: C03D02CC  lfs f1, 0x2cc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(716 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281D1A8: 4BFD0B99  bl 0x827edd40
	ctx.lr = 0x8281D1AC;
	sub_827EDD40(ctx, base);
	// 8281D1AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281D1B0: 41820240  beq 0x8281d3f0
	if ctx.cr[0].eq {
	pc = 0x8281D3F0; continue 'dispatch;
	}
	// 8281D1B4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D1B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281D1BC: 80BD02B8  lwz r5, 0x2b8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(696 as u32) ) } as u64;
	// 8281D1C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281D1C4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8281D1C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281D1CC: 4E800421  bctrl
	ctx.lr = 0x8281D1D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281D1D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8281D1D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D1D8: 3BEB0380  addi r31, r11, 0x380
	ctx.r[31].s64 = ctx.r[11].s64 + 896;
	// 8281D1DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281D1E0: 485D6829  bl 0x82df3a08
	ctx.lr = 0x8281D1E4;
	sub_82DF3A08(ctx, base);
	// 8281D1E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281D1E8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8281D1EC: 480464D5  bl 0x828636c0
	ctx.lr = 0x8281D1F0;
	sub_828636C0(ctx, base);
	// 8281D1F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D1F4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8281D1F8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281D1FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281D200: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8281D204: 419A0024  beq cr6, 0x8281d228
	if ctx.cr[6].eq {
	pc = 0x8281D228; continue 'dispatch;
	}
	// 8281D208: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281D20C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281D210: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D214: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281D218: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281D21C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281D220: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D224: 4082FFE8  bne 0x8281d20c
	if !ctx.cr[0].eq {
	pc = 0x8281D20C; continue 'dispatch;
	}
	// 8281D228: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8281D22C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281D230: 4BFD2471  bl 0x827ef6a0
	ctx.lr = 0x8281D234;
	sub_827EF6A0(ctx, base);
	// 8281D234: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281D238: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D23C: 419A0008  beq cr6, 0x8281d244
	if ctx.cr[6].eq {
	pc = 0x8281D244; continue 'dispatch;
	}
	// 8281D240: 4BAA3651  bl 0x822c0890
	ctx.lr = 0x8281D244;
	sub_822C0890(ctx, base);
	// 8281D244: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8281D248: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D24C: 419A0008  beq cr6, 0x8281d254
	if ctx.cr[6].eq {
	pc = 0x8281D254; continue 'dispatch;
	}
	// 8281D250: 4BAA3641  bl 0x822c0890
	ctx.lr = 0x8281D254;
	sub_822C0890(ctx, base);
	// 8281D254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D258: 485D61D1  bl 0x82df3428
	ctx.lr = 0x8281D25C;
	sub_82DF3428(ctx, base);
	// 8281D25C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281D260: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D264: 485D67A5  bl 0x82df3a08
	ctx.lr = 0x8281D268;
	sub_82DF3A08(ctx, base);
	// 8281D268: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281D26C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8281D270: 48046451  bl 0x828636c0
	ctx.lr = 0x8281D274;
	sub_828636C0(ctx, base);
	// 8281D274: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D278: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8281D27C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281D280: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281D284: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8281D288: 419A0024  beq cr6, 0x8281d2ac
	if ctx.cr[6].eq {
	pc = 0x8281D2AC; continue 'dispatch;
	}
	// 8281D28C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281D290: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281D294: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D298: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281D29C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281D2A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281D2A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D2A8: 4082FFE8  bne 0x8281d290
	if !ctx.cr[0].eq {
	pc = 0x8281D290; continue 'dispatch;
	}
	// 8281D2AC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8281D2B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281D2B4: 4BFD23ED  bl 0x827ef6a0
	ctx.lr = 0x8281D2B8;
	sub_827EF6A0(ctx, base);
	// 8281D2B8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8281D2BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D2C0: 419A0008  beq cr6, 0x8281d2c8
	if ctx.cr[6].eq {
	pc = 0x8281D2C8; continue 'dispatch;
	}
	// 8281D2C4: 4BAA35CD  bl 0x822c0890
	ctx.lr = 0x8281D2C8;
	sub_822C0890(ctx, base);
	// 8281D2C8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8281D2CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D2D0: 419A0008  beq cr6, 0x8281d2d8
	if ctx.cr[6].eq {
	pc = 0x8281D2D8; continue 'dispatch;
	}
	// 8281D2D4: 4BAA35BD  bl 0x822c0890
	ctx.lr = 0x8281D2D8;
	sub_822C0890(ctx, base);
	// 8281D2D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D2DC: 485D614D  bl 0x82df3428
	ctx.lr = 0x8281D2E0;
	sub_82DF3428(ctx, base);
	// 8281D2E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281D2E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D2E8: 485D6721  bl 0x82df3a08
	ctx.lr = 0x8281D2EC;
	sub_82DF3A08(ctx, base);
	// 8281D2EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281D2F0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8281D2F4: 480463CD  bl 0x828636c0
	ctx.lr = 0x8281D2F8;
	sub_828636C0(ctx, base);
	// 8281D2F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D2FC: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8281D300: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281D304: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281D308: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8281D30C: 419A0024  beq cr6, 0x8281d330
	if ctx.cr[6].eq {
	pc = 0x8281D330; continue 'dispatch;
	}
	// 8281D310: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281D314: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281D318: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D31C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281D320: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281D324: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281D328: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D32C: 4082FFE8  bne 0x8281d314
	if !ctx.cr[0].eq {
	pc = 0x8281D314; continue 'dispatch;
	}
	// 8281D330: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8281D334: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281D338: 4BFD2369  bl 0x827ef6a0
	ctx.lr = 0x8281D33C;
	sub_827EF6A0(ctx, base);
	// 8281D33C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8281D340: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D344: 419A0008  beq cr6, 0x8281d34c
	if ctx.cr[6].eq {
	pc = 0x8281D34C; continue 'dispatch;
	}
	// 8281D348: 4BAA3549  bl 0x822c0890
	ctx.lr = 0x8281D34C;
	sub_822C0890(ctx, base);
	// 8281D34C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 8281D350: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D354: 419A0008  beq cr6, 0x8281d35c
	if ctx.cr[6].eq {
	pc = 0x8281D35C; continue 'dispatch;
	}
	// 8281D358: 4BAA3539  bl 0x822c0890
	ctx.lr = 0x8281D35C;
	sub_822C0890(ctx, base);
	// 8281D35C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D360: 485D60C9  bl 0x82df3428
	ctx.lr = 0x8281D364;
	sub_82DF3428(ctx, base);
	// 8281D364: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281D368: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D36C: 485D669D  bl 0x82df3a08
	ctx.lr = 0x8281D370;
	sub_82DF3A08(ctx, base);
	// 8281D370: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281D374: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8281D378: 48046349  bl 0x828636c0
	ctx.lr = 0x8281D37C;
	sub_828636C0(ctx, base);
	// 8281D37C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D380: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8281D384: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281D388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281D38C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8281D390: 419A0024  beq cr6, 0x8281d3b4
	if ctx.cr[6].eq {
	pc = 0x8281D3B4; continue 'dispatch;
	}
	// 8281D394: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281D398: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281D39C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D3A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281D3A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281D3A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281D3AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D3B0: 4082FFE8  bne 0x8281d398
	if !ctx.cr[0].eq {
	pc = 0x8281D398; continue 'dispatch;
	}
	// 8281D3B4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8281D3B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281D3BC: 4BFD22E5  bl 0x827ef6a0
	ctx.lr = 0x8281D3C0;
	sub_827EF6A0(ctx, base);
	// 8281D3C0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8281D3C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D3C8: 419A0008  beq cr6, 0x8281d3d0
	if ctx.cr[6].eq {
	pc = 0x8281D3D0; continue 'dispatch;
	}
	// 8281D3CC: 4BAA34C5  bl 0x822c0890
	ctx.lr = 0x8281D3D0;
	sub_822C0890(ctx, base);
	// 8281D3D0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8281D3D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D3D8: 419A0008  beq cr6, 0x8281d3e0
	if ctx.cr[6].eq {
	pc = 0x8281D3E0; continue 'dispatch;
	}
	// 8281D3DC: 4BAA34B5  bl 0x822c0890
	ctx.lr = 0x8281D3E0;
	sub_822C0890(ctx, base);
	// 8281D3E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D3E4: 485D6045  bl 0x82df3428
	ctx.lr = 0x8281D3E8;
	sub_82DF3428(ctx, base);
	// 8281D3E8: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 8281D3EC: 917D02B4  stw r11, 0x2b4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(692 as u32), ctx.r[11].u32 ) };
	// 8281D3F0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8281D3F4: 4898ADC8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281D3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281D3F8 size=704
    let mut pc: u32 = 0x8281D3F8;
    'dispatch: loop {
        match pc {
            0x8281D3F8 => {
    //   block [0x8281D3F8..0x8281D6B8)
	// 8281D3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281D3FC: 4898AD71  bl 0x831a816c
	ctx.lr = 0x8281D400;
	sub_831A8130(ctx, base);
	// 8281D400: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281D404: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281D408: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281D40C: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281D410: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8281D414: 419A000C  beq cr6, 0x8281d420
	if ctx.cr[6].eq {
	pc = 0x8281D420; continue 'dispatch;
	}
	// 8281D418: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8281D41C: 409A0038  bne cr6, 0x8281d454
	if !ctx.cr[6].eq {
	pc = 0x8281D454; continue 'dispatch;
	}
	// 8281D420: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281D424: C03F02C8  lfs f1, 0x2c8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281D428: 4BFD0919  bl 0x827edd40
	ctx.lr = 0x8281D42C;
	sub_827EDD40(ctx, base);
	// 8281D42C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281D430: 41820024  beq 0x8281d454
	if ctx.cr[0].eq {
	pc = 0x8281D454; continue 'dispatch;
	}
	// 8281D434: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D438: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281D43C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281D440: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 8281D444: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281D448: 4E800421  bctrl
	ctx.lr = 0x8281D44C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281D44C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8281D450: 917F02B4  stw r11, 0x2b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u32 ) };
	// 8281D454: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281D458: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8281D45C: 409A0254  bne cr6, 0x8281d6b0
	if !ctx.cr[6].eq {
	pc = 0x8281D6B0; continue 'dispatch;
	}
	// 8281D460: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281D464: C03F02CC  lfs f1, 0x2cc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(716 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281D468: 4BFD08D9  bl 0x827edd40
	ctx.lr = 0x8281D46C;
	sub_827EDD40(ctx, base);
	// 8281D46C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281D470: 41820240  beq 0x8281d6b0
	if ctx.cr[0].eq {
	pc = 0x8281D6B0; continue 'dispatch;
	}
	// 8281D474: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D478: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281D47C: 80BF02B8  lwz r5, 0x2b8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(696 as u32) ) } as u64;
	// 8281D480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281D484: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8281D488: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281D48C: 4E800421  bctrl
	ctx.lr = 0x8281D490;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281D490: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8281D494: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D498: 3BAB0380  addi r29, r11, 0x380
	ctx.r[29].s64 = ctx.r[11].s64 + 896;
	// 8281D49C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281D4A0: 485D6569  bl 0x82df3a08
	ctx.lr = 0x8281D4A4;
	sub_82DF3A08(ctx, base);
	// 8281D4A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281D4A8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8281D4AC: 48046215  bl 0x828636c0
	ctx.lr = 0x8281D4B0;
	sub_828636C0(ctx, base);
	// 8281D4B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D4B4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8281D4B8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281D4BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281D4C0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8281D4C4: 419A0024  beq cr6, 0x8281d4e8
	if ctx.cr[6].eq {
	pc = 0x8281D4E8; continue 'dispatch;
	}
	// 8281D4C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281D4CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281D4D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D4D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281D4D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281D4DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281D4E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D4E4: 4082FFE8  bne 0x8281d4cc
	if !ctx.cr[0].eq {
	pc = 0x8281D4CC; continue 'dispatch;
	}
	// 8281D4E8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8281D4EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281D4F0: 4BFD21B1  bl 0x827ef6a0
	ctx.lr = 0x8281D4F4;
	sub_827EF6A0(ctx, base);
	// 8281D4F4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281D4F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D4FC: 419A0008  beq cr6, 0x8281d504
	if ctx.cr[6].eq {
	pc = 0x8281D504; continue 'dispatch;
	}
	// 8281D500: 4BAA3391  bl 0x822c0890
	ctx.lr = 0x8281D504;
	sub_822C0890(ctx, base);
	// 8281D504: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8281D508: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D50C: 419A0008  beq cr6, 0x8281d514
	if ctx.cr[6].eq {
	pc = 0x8281D514; continue 'dispatch;
	}
	// 8281D510: 4BAA3381  bl 0x822c0890
	ctx.lr = 0x8281D514;
	sub_822C0890(ctx, base);
	// 8281D514: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D518: 485D5F11  bl 0x82df3428
	ctx.lr = 0x8281D51C;
	sub_82DF3428(ctx, base);
	// 8281D51C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281D520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D524: 485D64E5  bl 0x82df3a08
	ctx.lr = 0x8281D528;
	sub_82DF3A08(ctx, base);
	// 8281D528: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281D52C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8281D530: 48046191  bl 0x828636c0
	ctx.lr = 0x8281D534;
	sub_828636C0(ctx, base);
	// 8281D534: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D538: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8281D53C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281D540: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281D544: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8281D548: 419A0024  beq cr6, 0x8281d56c
	if ctx.cr[6].eq {
	pc = 0x8281D56C; continue 'dispatch;
	}
	// 8281D54C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281D550: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281D554: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D558: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281D55C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281D560: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281D564: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D568: 4082FFE8  bne 0x8281d550
	if !ctx.cr[0].eq {
	pc = 0x8281D550; continue 'dispatch;
	}
	// 8281D56C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8281D570: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281D574: 4BFD212D  bl 0x827ef6a0
	ctx.lr = 0x8281D578;
	sub_827EF6A0(ctx, base);
	// 8281D578: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8281D57C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D580: 419A0008  beq cr6, 0x8281d588
	if ctx.cr[6].eq {
	pc = 0x8281D588; continue 'dispatch;
	}
	// 8281D584: 4BAA330D  bl 0x822c0890
	ctx.lr = 0x8281D588;
	sub_822C0890(ctx, base);
	// 8281D588: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8281D58C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D590: 419A0008  beq cr6, 0x8281d598
	if ctx.cr[6].eq {
	pc = 0x8281D598; continue 'dispatch;
	}
	// 8281D594: 4BAA32FD  bl 0x822c0890
	ctx.lr = 0x8281D598;
	sub_822C0890(ctx, base);
	// 8281D598: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D59C: 485D5E8D  bl 0x82df3428
	ctx.lr = 0x8281D5A0;
	sub_82DF3428(ctx, base);
	// 8281D5A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281D5A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D5A8: 485D6461  bl 0x82df3a08
	ctx.lr = 0x8281D5AC;
	sub_82DF3A08(ctx, base);
	// 8281D5AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281D5B0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8281D5B4: 4804610D  bl 0x828636c0
	ctx.lr = 0x8281D5B8;
	sub_828636C0(ctx, base);
	// 8281D5B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D5BC: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8281D5C0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281D5C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281D5C8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8281D5CC: 419A0024  beq cr6, 0x8281d5f0
	if ctx.cr[6].eq {
	pc = 0x8281D5F0; continue 'dispatch;
	}
	// 8281D5D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281D5D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281D5D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D5DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281D5E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281D5E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281D5E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D5EC: 4082FFE8  bne 0x8281d5d4
	if !ctx.cr[0].eq {
	pc = 0x8281D5D4; continue 'dispatch;
	}
	// 8281D5F0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8281D5F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281D5F8: 4BFD20A9  bl 0x827ef6a0
	ctx.lr = 0x8281D5FC;
	sub_827EF6A0(ctx, base);
	// 8281D5FC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8281D600: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D604: 419A0008  beq cr6, 0x8281d60c
	if ctx.cr[6].eq {
	pc = 0x8281D60C; continue 'dispatch;
	}
	// 8281D608: 4BAA3289  bl 0x822c0890
	ctx.lr = 0x8281D60C;
	sub_822C0890(ctx, base);
	// 8281D60C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 8281D610: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D614: 419A0008  beq cr6, 0x8281d61c
	if ctx.cr[6].eq {
	pc = 0x8281D61C; continue 'dispatch;
	}
	// 8281D618: 4BAA3279  bl 0x822c0890
	ctx.lr = 0x8281D61C;
	sub_822C0890(ctx, base);
	// 8281D61C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D620: 485D5E09  bl 0x82df3428
	ctx.lr = 0x8281D624;
	sub_82DF3428(ctx, base);
	// 8281D624: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281D628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D62C: 485D63DD  bl 0x82df3a08
	ctx.lr = 0x8281D630;
	sub_82DF3A08(ctx, base);
	// 8281D630: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281D634: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8281D638: 48046089  bl 0x828636c0
	ctx.lr = 0x8281D63C;
	sub_828636C0(ctx, base);
	// 8281D63C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D640: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8281D644: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281D648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281D64C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8281D650: 419A0024  beq cr6, 0x8281d674
	if ctx.cr[6].eq {
	pc = 0x8281D674; continue 'dispatch;
	}
	// 8281D654: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281D658: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281D65C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D660: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281D664: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281D668: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281D66C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D670: 4082FFE8  bne 0x8281d658
	if !ctx.cr[0].eq {
	pc = 0x8281D658; continue 'dispatch;
	}
	// 8281D674: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8281D678: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281D67C: 4BFD2025  bl 0x827ef6a0
	ctx.lr = 0x8281D680;
	sub_827EF6A0(ctx, base);
	// 8281D680: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8281D684: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D688: 419A0008  beq cr6, 0x8281d690
	if ctx.cr[6].eq {
	pc = 0x8281D690; continue 'dispatch;
	}
	// 8281D68C: 4BAA3205  bl 0x822c0890
	ctx.lr = 0x8281D690;
	sub_822C0890(ctx, base);
	// 8281D690: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8281D694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D698: 419A0008  beq cr6, 0x8281d6a0
	if ctx.cr[6].eq {
	pc = 0x8281D6A0; continue 'dispatch;
	}
	// 8281D69C: 4BAA31F5  bl 0x822c0890
	ctx.lr = 0x8281D6A0;
	sub_822C0890(ctx, base);
	// 8281D6A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D6A4: 485D5D85  bl 0x82df3428
	ctx.lr = 0x8281D6A8;
	sub_82DF3428(ctx, base);
	// 8281D6A8: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 8281D6AC: 917F02B4  stw r11, 0x2b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u32 ) };
	// 8281D6B0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8281D6B4: 4898AB08  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281D6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281D6B8 size=772
    let mut pc: u32 = 0x8281D6B8;
    'dispatch: loop {
        match pc {
            0x8281D6B8 => {
    //   block [0x8281D6B8..0x8281D9BC)
	// 8281D6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281D6BC: 4898AAB1  bl 0x831a816c
	ctx.lr = 0x8281D6C0;
	sub_831A8130(ctx, base);
	// 8281D6C0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281D6C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281D6C8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8281D6CC: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281D6D0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8281D6D4: 419A000C  beq cr6, 0x8281d6e0
	if ctx.cr[6].eq {
	pc = 0x8281D6E0; continue 'dispatch;
	}
	// 8281D6D8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8281D6DC: 409A003C  bne cr6, 0x8281d718
	if !ctx.cr[6].eq {
	pc = 0x8281D718; continue 'dispatch;
	}
	// 8281D6E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281D6E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281D6E8: C02B959C  lfs f1, -0x6a64(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281D6EC: 4BFD0655  bl 0x827edd40
	ctx.lr = 0x8281D6F0;
	sub_827EDD40(ctx, base);
	// 8281D6F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281D6F4: 41820024  beq 0x8281d718
	if ctx.cr[0].eq {
	pc = 0x8281D718; continue 'dispatch;
	}
	// 8281D6F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D6FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281D700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281D704: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 8281D708: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281D70C: 4E800421  bctrl
	ctx.lr = 0x8281D710;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281D710: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8281D714: 917F02B4  stw r11, 0x2b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u32 ) };
	// 8281D718: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281D71C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8281D720: 409A025C  bne cr6, 0x8281d97c
	if !ctx.cr[6].eq {
	pc = 0x8281D97C; continue 'dispatch;
	}
	// 8281D724: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281D728: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281D72C: C02B967C  lfs f1, -0x6984(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281D730: 4BFD0611  bl 0x827edd40
	ctx.lr = 0x8281D734;
	sub_827EDD40(ctx, base);
	// 8281D734: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281D738: 4182027C  beq 0x8281d9b4
	if ctx.cr[0].eq {
	pc = 0x8281D9B4; continue 'dispatch;
	}
	// 8281D73C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D740: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281D744: 80BF02B8  lwz r5, 0x2b8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(696 as u32) ) } as u64;
	// 8281D748: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281D74C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8281D750: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281D754: 4E800421  bctrl
	ctx.lr = 0x8281D758;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281D758: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8281D75C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D760: 3BCB0380  addi r30, r11, 0x380
	ctx.r[30].s64 = ctx.r[11].s64 + 896;
	// 8281D764: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281D768: 485D62A1  bl 0x82df3a08
	ctx.lr = 0x8281D76C;
	sub_82DF3A08(ctx, base);
	// 8281D76C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281D770: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8281D774: 48045F4D  bl 0x828636c0
	ctx.lr = 0x8281D778;
	sub_828636C0(ctx, base);
	// 8281D778: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D77C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8281D780: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281D784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281D788: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8281D78C: 419A0024  beq cr6, 0x8281d7b0
	if ctx.cr[6].eq {
	pc = 0x8281D7B0; continue 'dispatch;
	}
	// 8281D790: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281D794: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281D798: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D79C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281D7A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281D7A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281D7A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D7AC: 4082FFE8  bne 0x8281d794
	if !ctx.cr[0].eq {
	pc = 0x8281D794; continue 'dispatch;
	}
	// 8281D7B0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8281D7B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281D7B8: 4BFD1EE9  bl 0x827ef6a0
	ctx.lr = 0x8281D7BC;
	sub_827EF6A0(ctx, base);
	// 8281D7BC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281D7C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D7C4: 419A0008  beq cr6, 0x8281d7cc
	if ctx.cr[6].eq {
	pc = 0x8281D7CC; continue 'dispatch;
	}
	// 8281D7C8: 4BAA30C9  bl 0x822c0890
	ctx.lr = 0x8281D7CC;
	sub_822C0890(ctx, base);
	// 8281D7CC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8281D7D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D7D4: 419A0008  beq cr6, 0x8281d7dc
	if ctx.cr[6].eq {
	pc = 0x8281D7DC; continue 'dispatch;
	}
	// 8281D7D8: 4BAA30B9  bl 0x822c0890
	ctx.lr = 0x8281D7DC;
	sub_822C0890(ctx, base);
	// 8281D7DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D7E0: 485D5C49  bl 0x82df3428
	ctx.lr = 0x8281D7E4;
	sub_82DF3428(ctx, base);
	// 8281D7E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281D7E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D7EC: 485D621D  bl 0x82df3a08
	ctx.lr = 0x8281D7F0;
	sub_82DF3A08(ctx, base);
	// 8281D7F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281D7F4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8281D7F8: 48045EC9  bl 0x828636c0
	ctx.lr = 0x8281D7FC;
	sub_828636C0(ctx, base);
	// 8281D7FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D800: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8281D804: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281D808: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281D80C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8281D810: 419A0024  beq cr6, 0x8281d834
	if ctx.cr[6].eq {
	pc = 0x8281D834; continue 'dispatch;
	}
	// 8281D814: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281D818: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281D81C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D820: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281D824: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281D828: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281D82C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D830: 4082FFE8  bne 0x8281d818
	if !ctx.cr[0].eq {
	pc = 0x8281D818; continue 'dispatch;
	}
	// 8281D834: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8281D838: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281D83C: 4BFD1E65  bl 0x827ef6a0
	ctx.lr = 0x8281D840;
	sub_827EF6A0(ctx, base);
	// 8281D840: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8281D844: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D848: 419A0008  beq cr6, 0x8281d850
	if ctx.cr[6].eq {
	pc = 0x8281D850; continue 'dispatch;
	}
	// 8281D84C: 4BAA3045  bl 0x822c0890
	ctx.lr = 0x8281D850;
	sub_822C0890(ctx, base);
	// 8281D850: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8281D854: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D858: 419A0008  beq cr6, 0x8281d860
	if ctx.cr[6].eq {
	pc = 0x8281D860; continue 'dispatch;
	}
	// 8281D85C: 4BAA3035  bl 0x822c0890
	ctx.lr = 0x8281D860;
	sub_822C0890(ctx, base);
	// 8281D860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D864: 485D5BC5  bl 0x82df3428
	ctx.lr = 0x8281D868;
	sub_82DF3428(ctx, base);
	// 8281D868: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281D86C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D870: 485D6199  bl 0x82df3a08
	ctx.lr = 0x8281D874;
	sub_82DF3A08(ctx, base);
	// 8281D874: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281D878: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8281D87C: 48045E45  bl 0x828636c0
	ctx.lr = 0x8281D880;
	sub_828636C0(ctx, base);
	// 8281D880: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D884: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8281D888: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281D88C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281D890: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8281D894: 419A0024  beq cr6, 0x8281d8b8
	if ctx.cr[6].eq {
	pc = 0x8281D8B8; continue 'dispatch;
	}
	// 8281D898: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281D89C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281D8A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D8A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281D8A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281D8AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281D8B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D8B4: 4082FFE8  bne 0x8281d89c
	if !ctx.cr[0].eq {
	pc = 0x8281D89C; continue 'dispatch;
	}
	// 8281D8B8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8281D8BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281D8C0: 4BFD1DE1  bl 0x827ef6a0
	ctx.lr = 0x8281D8C4;
	sub_827EF6A0(ctx, base);
	// 8281D8C4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8281D8C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D8CC: 419A0008  beq cr6, 0x8281d8d4
	if ctx.cr[6].eq {
	pc = 0x8281D8D4; continue 'dispatch;
	}
	// 8281D8D0: 4BAA2FC1  bl 0x822c0890
	ctx.lr = 0x8281D8D4;
	sub_822C0890(ctx, base);
	// 8281D8D4: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 8281D8D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D8DC: 419A0008  beq cr6, 0x8281d8e4
	if ctx.cr[6].eq {
	pc = 0x8281D8E4; continue 'dispatch;
	}
	// 8281D8E0: 4BAA2FB1  bl 0x822c0890
	ctx.lr = 0x8281D8E4;
	sub_822C0890(ctx, base);
	// 8281D8E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D8E8: 485D5B41  bl 0x82df3428
	ctx.lr = 0x8281D8EC;
	sub_82DF3428(ctx, base);
	// 8281D8EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281D8F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D8F4: 485D6115  bl 0x82df3a08
	ctx.lr = 0x8281D8F8;
	sub_82DF3A08(ctx, base);
	// 8281D8F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281D8FC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8281D900: 48045DC1  bl 0x828636c0
	ctx.lr = 0x8281D904;
	sub_828636C0(ctx, base);
	// 8281D904: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D908: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8281D90C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281D910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281D914: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8281D918: 419A0024  beq cr6, 0x8281d93c
	if ctx.cr[6].eq {
	pc = 0x8281D93C; continue 'dispatch;
	}
	// 8281D91C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281D920: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281D924: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D928: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281D92C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281D930: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281D934: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281D938: 4082FFE8  bne 0x8281d920
	if !ctx.cr[0].eq {
	pc = 0x8281D920; continue 'dispatch;
	}
	// 8281D93C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8281D940: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281D944: 4BFD1D5D  bl 0x827ef6a0
	ctx.lr = 0x8281D948;
	sub_827EF6A0(ctx, base);
	// 8281D948: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8281D94C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D950: 419A0008  beq cr6, 0x8281d958
	if ctx.cr[6].eq {
	pc = 0x8281D958; continue 'dispatch;
	}
	// 8281D954: 4BAA2F3D  bl 0x822c0890
	ctx.lr = 0x8281D958;
	sub_822C0890(ctx, base);
	// 8281D958: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8281D95C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D960: 419A0008  beq cr6, 0x8281d968
	if ctx.cr[6].eq {
	pc = 0x8281D968; continue 'dispatch;
	}
	// 8281D964: 4BAA2F2D  bl 0x822c0890
	ctx.lr = 0x8281D968;
	sub_822C0890(ctx, base);
	// 8281D968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D96C: 485D5ABD  bl 0x82df3428
	ctx.lr = 0x8281D970;
	sub_82DF3428(ctx, base);
	// 8281D970: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 8281D974: 917F02B4  stw r11, 0x2b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u32 ) };
	// 8281D978: 4800003C  b 0x8281d9b4
	pc = 0x8281D9B4; continue 'dispatch;
	// 8281D97C: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 8281D980: 409A0034  bne cr6, 0x8281d9b4
	if !ctx.cr[6].eq {
	pc = 0x8281D9B4; continue 'dispatch;
	}
	// 8281D984: 807F027C  lwz r3, 0x27c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(636 as u32) ) } as u64;
	// 8281D988: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281D98C: 419A0028  beq cr6, 0x8281d9b4
	if ctx.cr[6].eq {
	pc = 0x8281D9B4; continue 'dispatch;
	}
	// 8281D990: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D994: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8281D998: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281D99C: 4E800421  bctrl
	ctx.lr = 0x8281D9A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281D9A0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8281D9A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281D9A8: 807F0274  lwz r3, 0x274(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 8281D9AC: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 8281D9B0: 48141E71  bl 0x8295f820
	ctx.lr = 0x8281D9B4;
	sub_8295F820(ctx, base);
	// 8281D9B4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8281D9B8: 4898A804  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281D9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281D9C0 size=324
    let mut pc: u32 = 0x8281D9C0;
    'dispatch: loop {
        match pc {
            0x8281D9C0 => {
    //   block [0x8281D9C0..0x8281DB04)
	// 8281D9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281D9C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281D9C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281D9CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281D9D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281D9D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281D9D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281D9DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281D9E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281D9E4: 388B9B40  addi r4, r11, -0x64c0
	ctx.r[4].s64 = ctx.r[11].s64 + -25792;
	// 8281D9E8: 485D6021  bl 0x82df3a08
	ctx.lr = 0x8281D9EC;
	sub_82DF3A08(ctx, base);
	// 8281D9EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281D9F0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8281D9F4: 48045CCD  bl 0x828636c0
	ctx.lr = 0x8281D9F8;
	sub_828636C0(ctx, base);
	// 8281D9F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281D9FC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8281DA00: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281DA04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281DA08: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8281DA0C: 419A0024  beq cr6, 0x8281da30
	if ctx.cr[6].eq {
	pc = 0x8281DA30; continue 'dispatch;
	}
	// 8281DA10: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281DA14: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281DA18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281DA1C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281DA20: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281DA24: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281DA28: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281DA2C: 4082FFE8  bne 0x8281da14
	if !ctx.cr[0].eq {
	pc = 0x8281DA14; continue 'dispatch;
	}
	// 8281DA30: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8281DA34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281DA38: 4BFCF321  bl 0x827ecd58
	ctx.lr = 0x8281DA3C;
	sub_827ECD58(ctx, base);
	// 8281DA3C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281DA40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281DA44: 419A0008  beq cr6, 0x8281da4c
	if ctx.cr[6].eq {
	pc = 0x8281DA4C; continue 'dispatch;
	}
	// 8281DA48: 4BAA2E49  bl 0x822c0890
	ctx.lr = 0x8281DA4C;
	sub_822C0890(ctx, base);
	// 8281DA4C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8281DA50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281DA54: 419A0008  beq cr6, 0x8281da5c
	if ctx.cr[6].eq {
	pc = 0x8281DA5C; continue 'dispatch;
	}
	// 8281DA58: 4BAA2E39  bl 0x822c0890
	ctx.lr = 0x8281DA5C;
	sub_822C0890(ctx, base);
	// 8281DA5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281DA60: 485D59C9  bl 0x82df3428
	ctx.lr = 0x8281DA64;
	sub_82DF3428(ctx, base);
	// 8281DA64: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281DA68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281DA6C: 388B9B34  addi r4, r11, -0x64cc
	ctx.r[4].s64 = ctx.r[11].s64 + -25804;
	// 8281DA70: 485D5F99  bl 0x82df3a08
	ctx.lr = 0x8281DA74;
	sub_82DF3A08(ctx, base);
	// 8281DA74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281DA78: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8281DA7C: 48045C45  bl 0x828636c0
	ctx.lr = 0x8281DA80;
	sub_828636C0(ctx, base);
	// 8281DA80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281DA84: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8281DA88: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281DA8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281DA90: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8281DA94: 419A0024  beq cr6, 0x8281dab8
	if ctx.cr[6].eq {
	pc = 0x8281DAB8; continue 'dispatch;
	}
	// 8281DA98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281DA9C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281DAA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281DAA4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281DAA8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281DAAC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281DAB0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281DAB4: 4082FFE8  bne 0x8281da9c
	if !ctx.cr[0].eq {
	pc = 0x8281DA9C; continue 'dispatch;
	}
	// 8281DAB8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8281DABC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281DAC0: 4BFD1BE1  bl 0x827ef6a0
	ctx.lr = 0x8281DAC4;
	sub_827EF6A0(ctx, base);
	// 8281DAC4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8281DAC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281DACC: 419A0008  beq cr6, 0x8281dad4
	if ctx.cr[6].eq {
	pc = 0x8281DAD4; continue 'dispatch;
	}
	// 8281DAD0: 4BAA2DC1  bl 0x822c0890
	ctx.lr = 0x8281DAD4;
	sub_822C0890(ctx, base);
	// 8281DAD4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8281DAD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281DADC: 419A0008  beq cr6, 0x8281dae4
	if ctx.cr[6].eq {
	pc = 0x8281DAE4; continue 'dispatch;
	}
	// 8281DAE0: 4BAA2DB1  bl 0x822c0890
	ctx.lr = 0x8281DAE4;
	sub_822C0890(ctx, base);
	// 8281DAE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281DAE8: 485D5941  bl 0x82df3428
	ctx.lr = 0x8281DAEC;
	sub_82DF3428(ctx, base);
	// 8281DAEC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8281DAF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281DAF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281DAF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281DAFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281DB00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281DB08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281DB08 size=520
    let mut pc: u32 = 0x8281DB08;
    'dispatch: loop {
        match pc {
            0x8281DB08 => {
    //   block [0x8281DB08..0x8281DD10)
	// 8281DB08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281DB0C: 4898A661  bl 0x831a816c
	ctx.lr = 0x8281DB10;
	sub_831A8130(ctx, base);
	// 8281DB10: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281DB14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281DB18: 817F02B8  lwz r11, 0x2b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(696 as u32) ) } as u64;
	// 8281DB1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281DB20: 409A0044  bne cr6, 0x8281db64
	if !ctx.cr[6].eq {
	pc = 0x8281DB64; continue 'dispatch;
	}
	// 8281DB24: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281DB28: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8281DB2C: 409A0050  bne cr6, 0x8281db7c
	if !ctx.cr[6].eq {
	pc = 0x8281DB7C; continue 'dispatch;
	}
	// 8281DB30: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281DB34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281DB38: 388B9C28  addi r4, r11, -0x63d8
	ctx.r[4].s64 = ctx.r[11].s64 + -25560;
	// 8281DB3C: 485D5ECD  bl 0x82df3a08
	ctx.lr = 0x8281DB40;
	sub_82DF3A08(ctx, base);
	// 8281DB40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281DB44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281DB48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281DB4C: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281DB50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281DB54: 4E800421  bctrl
	ctx.lr = 0x8281DB58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281DB58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281DB5C: 4BFD1B5D  bl 0x827ef6b8
	ctx.lr = 0x8281DB60;
	sub_827EF6B8(ctx, base);
	// 8281DB60: 4800001C  b 0x8281db7c
	pc = 0x8281DB7C; continue 'dispatch;
	// 8281DB64: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 8281DB68: 409A0014  bne cr6, 0x8281db7c
	if !ctx.cr[6].eq {
	pc = 0x8281DB7C; continue 'dispatch;
	}
	// 8281DB6C: 807F0274  lwz r3, 0x274(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 8281DB70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281DB74: 419A0008  beq cr6, 0x8281db7c
	if ctx.cr[6].eq {
	pc = 0x8281DB7C; continue 'dispatch;
	}
	// 8281DB78: 481419D9  bl 0x8295f550
	ctx.lr = 0x8281DB7C;
	sub_8295F550(ctx, base);
	// 8281DB7C: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281DB80: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 8281DB84: 409A0144  bne cr6, 0x8281dcc8
	if !ctx.cr[6].eq {
	pc = 0x8281DCC8; continue 'dispatch;
	}
	// 8281DB88: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8281DB8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281DB90: 3BCB0380  addi r30, r11, 0x380
	ctx.r[30].s64 = ctx.r[11].s64 + 896;
	// 8281DB94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281DB98: 485D5E71  bl 0x82df3a08
	ctx.lr = 0x8281DB9C;
	sub_82DF3A08(ctx, base);
	// 8281DB9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281DBA0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8281DBA4: 48045B1D  bl 0x828636c0
	ctx.lr = 0x8281DBA8;
	sub_828636C0(ctx, base);
	// 8281DBA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281DBAC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8281DBB0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281DBB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281DBB8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8281DBBC: 419A0024  beq cr6, 0x8281dbe0
	if ctx.cr[6].eq {
	pc = 0x8281DBE0; continue 'dispatch;
	}
	// 8281DBC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281DBC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281DBC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281DBCC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281DBD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281DBD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281DBD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281DBDC: 4082FFE8  bne 0x8281dbc4
	if !ctx.cr[0].eq {
	pc = 0x8281DBC4; continue 'dispatch;
	}
	// 8281DBE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281DBE4: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 8281DBE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281DBEC: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281DBF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281DBF4: 4E800421  bctrl
	ctx.lr = 0x8281DBF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281DBF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281DBFC: 4BFD1AA5  bl 0x827ef6a0
	ctx.lr = 0x8281DC00;
	sub_827EF6A0(ctx, base);
	// 8281DC00: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281DC04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281DC08: 419A0008  beq cr6, 0x8281dc10
	if ctx.cr[6].eq {
	pc = 0x8281DC10; continue 'dispatch;
	}
	// 8281DC0C: 4BAA2C85  bl 0x822c0890
	ctx.lr = 0x8281DC10;
	sub_822C0890(ctx, base);
	// 8281DC10: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8281DC14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281DC18: 419A0008  beq cr6, 0x8281dc20
	if ctx.cr[6].eq {
	pc = 0x8281DC20; continue 'dispatch;
	}
	// 8281DC1C: 4BAA2C75  bl 0x822c0890
	ctx.lr = 0x8281DC20;
	sub_822C0890(ctx, base);
	// 8281DC20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281DC24: 485D5805  bl 0x82df3428
	ctx.lr = 0x8281DC28;
	sub_82DF3428(ctx, base);
	// 8281DC28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281DC2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281DC30: 485D5DD9  bl 0x82df3a08
	ctx.lr = 0x8281DC34;
	sub_82DF3A08(ctx, base);
	// 8281DC34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281DC38: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8281DC3C: 48045A85  bl 0x828636c0
	ctx.lr = 0x8281DC40;
	sub_828636C0(ctx, base);
	// 8281DC40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281DC44: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8281DC48: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281DC4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281DC50: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8281DC54: 419A0024  beq cr6, 0x8281dc78
	if ctx.cr[6].eq {
	pc = 0x8281DC78; continue 'dispatch;
	}
	// 8281DC58: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281DC5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281DC60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281DC64: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281DC68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281DC6C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281DC70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281DC74: 4082FFE8  bne 0x8281dc5c
	if !ctx.cr[0].eq {
	pc = 0x8281DC5C; continue 'dispatch;
	}
	// 8281DC78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281DC7C: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 8281DC80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281DC84: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281DC88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281DC8C: 4E800421  bctrl
	ctx.lr = 0x8281DC90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281DC90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281DC94: 4BFD1A0D  bl 0x827ef6a0
	ctx.lr = 0x8281DC98;
	sub_827EF6A0(ctx, base);
	// 8281DC98: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8281DC9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281DCA0: 419A0008  beq cr6, 0x8281dca8
	if ctx.cr[6].eq {
	pc = 0x8281DCA8; continue 'dispatch;
	}
	// 8281DCA4: 4BAA2BED  bl 0x822c0890
	ctx.lr = 0x8281DCA8;
	sub_822C0890(ctx, base);
	// 8281DCA8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8281DCAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281DCB0: 419A0008  beq cr6, 0x8281dcb8
	if ctx.cr[6].eq {
	pc = 0x8281DCB8; continue 'dispatch;
	}
	// 8281DCB4: 4BAA2BDD  bl 0x822c0890
	ctx.lr = 0x8281DCB8;
	sub_822C0890(ctx, base);
	// 8281DCB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281DCBC: 485D576D  bl 0x82df3428
	ctx.lr = 0x8281DCC0;
	sub_82DF3428(ctx, base);
	// 8281DCC0: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8281DCC4: 48000040  b 0x8281dd04
	pc = 0x8281DD04; continue 'dispatch;
	// 8281DCC8: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 8281DCCC: 4098003C  bge cr6, 0x8281dd08
	if !ctx.cr[6].lt {
	pc = 0x8281DD08; continue 'dispatch;
	}
	// 8281DCD0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8281DCD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281DCD8: 388BCFB0  addi r4, r11, -0x3050
	ctx.r[4].s64 = ctx.r[11].s64 + -12368;
	// 8281DCDC: 485D5D2D  bl 0x82df3a08
	ctx.lr = 0x8281DCE0;
	sub_82DF3A08(ctx, base);
	// 8281DCE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281DCE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281DCE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281DCEC: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281DCF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281DCF4: 4E800421  bctrl
	ctx.lr = 0x8281DCF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281DCF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281DCFC: 4BFD19BD  bl 0x827ef6b8
	ctx.lr = 0x8281DD00;
	sub_827EF6B8(ctx, base);
	// 8281DD00: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8281DD04: 917F02B4  stw r11, 0x2b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u32 ) };
	// 8281DD08: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8281DD0C: 4898A4B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281DD10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281DD10 size=224
    let mut pc: u32 = 0x8281DD10;
    'dispatch: loop {
        match pc {
            0x8281DD10 => {
    //   block [0x8281DD10..0x8281DDF0)
	// 8281DD10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281DD14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281DD18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281DD1C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281DD20: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8281DD24: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8281DD28: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8281DD2C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281DDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281DDF0 size=256
    let mut pc: u32 = 0x8281DDF0;
    'dispatch: loop {
        match pc {
            0x8281DDF0 => {
    //   block [0x8281DDF0..0x8281DEF0)
	// 8281DDF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281DDF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281DDF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281DDFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281DE00: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8281DE04: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281DEF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281DEF0 size=84
    let mut pc: u32 = 0x8281DEF0;
    'dispatch: loop {
        match pc {
            0x8281DEF0 => {
    //   block [0x8281DEF0..0x8281DF44)
	// 8281DEF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281DEF4: 4898A279  bl 0x831a816c
	ctx.lr = 0x8281DEF8;
	sub_831A8130(ctx, base);
	// 8281DEF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281DEFC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281DF00: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8281DF04: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281DF08: 397F0058  addi r11, r31, 0x58
	ctx.r[11].s64 = ctx.r[31].s64 + 88;
	// 8281DF0C: 409A0008  bne cr6, 0x8281df14
	if !ctx.cr[6].eq {
	pc = 0x8281DF14; continue 'dispatch;
	}
	// 8281DF10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281DF14: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281DF18: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8281DF1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281DF20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281DF24: 4BFFEA75  bl 0x8281c998
	ctx.lr = 0x8281DF28;
	sub_8281C998(ctx, base);
	// 8281DF28: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8281DF2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281DF30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281DF34: 4BAA20CD  bl 0x822c0000
	ctx.lr = 0x8281DF38;
	sub_822C0000(ctx, base);
	// 8281DF38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281DF3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281DF40: 4898A27C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281DF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281DF48 size=72
    let mut pc: u32 = 0x8281DF48;
    'dispatch: loop {
        match pc {
            0x8281DF48 => {
    //   block [0x8281DF48..0x8281DF90)
	// 8281DF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281DF4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281DF50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281DF54: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 8281DF58: 419A001C  beq cr6, 0x8281df74
	if ctx.cr[6].eq {
	pc = 0x8281DF74; continue 'dispatch;
	}
	// 8281DF5C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8281DF60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8281DF64: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8281DF68: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8281DF6C: 4BFFE40D  bl 0x8281c378
	ctx.lr = 0x8281DF70;
	sub_8281C378(ctx, base);
	// 8281DF70: 48000010  b 0x8281df80
	pc = 0x8281DF80; continue 'dispatch;
	// 8281DF74: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8281DF78: 396BFB38  addi r11, r11, -0x4c8
	ctx.r[11].s64 = ctx.r[11].s64 + -1224;
	// 8281DF7C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281DF80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8281DF84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281DF88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281DF8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281DF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281DF90 size=156
    let mut pc: u32 = 0x8281DF90;
    'dispatch: loop {
        match pc {
            0x8281DF90 => {
    //   block [0x8281DF90..0x8281E02C)
	// 8281DF90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281DF94: 4898A1D9  bl 0x831a816c
	ctx.lr = 0x8281DF98;
	sub_831A8130(ctx, base);
	// 8281DF98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281DF9C: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281DFA0: 3BE301DC  addi r31, r3, 0x1dc
	ctx.r[31].s64 = ctx.r[3].s64 + 476;
	// 8281DFA4: 3BA50004  addi r29, r5, 4
	ctx.r[29].s64 = ctx.r[5].s64 + 4;
	// 8281DFA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281DFAC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 8281DFB0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281DFB4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281DFB8: 4BAA64A9  bl 0x822c4460
	ctx.lr = 0x8281DFBC;
	sub_822C4460(ctx, base);
	// 8281DFBC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8281DFC0: 419A0054  beq cr6, 0x8281e014
	if ctx.cr[6].eq {
	pc = 0x8281E014; continue 'dispatch;
	}
	// 8281DFC4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281DFC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281DFCC: 419A0048  beq cr6, 0x8281e014
	if ctx.cr[6].eq {
	pc = 0x8281E014; continue 'dispatch;
	}
	// 8281DFD0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281DFD4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281DFD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281DFDC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281DFE0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8281DFE4: 419A0024  beq cr6, 0x8281e008
	if ctx.cr[6].eq {
	pc = 0x8281E008; continue 'dispatch;
	}
	// 8281DFE8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281DFEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281DFF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281DFF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281DFF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281DFFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281E000: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281E004: 4082FFE8  bne 0x8281dfec
	if !ctx.cr[0].eq {
	pc = 0x8281DFEC; continue 'dispatch;
	}
	// 8281E008: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281E00C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E010: 48391619  bl 0x82baf628
	ctx.lr = 0x8281E014;
	sub_82BAF628(ctx, base);
	// 8281E014: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281E018: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281E01C: 419A0008  beq cr6, 0x8281e024
	if ctx.cr[6].eq {
	pc = 0x8281E024; continue 'dispatch;
	}
	// 8281E020: 4BAA2871  bl 0x822c0890
	ctx.lr = 0x8281E024;
	sub_822C0890(ctx, base);
	// 8281E024: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8281E028: 4898A194  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281E030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281E030 size=332
    let mut pc: u32 = 0x8281E030;
    'dispatch: loop {
        match pc {
            0x8281E030 => {
    //   block [0x8281E030..0x8281E17C)
	// 8281E030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281E034: 4898A131  bl 0x831a8164
	ctx.lr = 0x8281E038;
	sub_831A8130(ctx, base);
	// 8281E038: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8281E03C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281E040: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281E044: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8281E048: 817F01DC  lwz r11, 0x1dc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 8281E04C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281E050: 419A0074  beq cr6, 0x8281e0c4
	if ctx.cr[6].eq {
	pc = 0x8281E0C4; continue 'dispatch;
	}
	// 8281E054: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281E058: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 8281E05C: 41980068  blt cr6, 0x8281e0c4
	if ctx.cr[6].lt {
	pc = 0x8281E0C4; continue 'dispatch;
	}
	// 8281E060: 4BFCE171  bl 0x827ec1d0
	ctx.lr = 0x8281E064;
	sub_827EC1D0(ctx, base);
	// 8281E064: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8281E068: 41820108  beq 0x8281e170
	if ctx.cr[0].eq {
	pc = 0x8281E170; continue 'dispatch;
	}
	// 8281E06C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281E070: C3FD0000  lfs f31, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8281E074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E078: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281E07C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281E080: 4E800421  bctrl
	ctx.lr = 0x8281E084;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281E084: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8281E088: 48397411  bl 0x82bb5498
	ctx.lr = 0x8281E08C;
	sub_82BB5498(ctx, base);
	// 8281E08C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281E090: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E094: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281E098: C3FD0000  lfs f31, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8281E09C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281E0A0: 4E800421  bctrl
	ctx.lr = 0x8281E0A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281E0A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281E0A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281E0AC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8281E0B0: 4BFFEE61  bl 0x8281cf10
	ctx.lr = 0x8281E0B4;
	sub_8281CF10(ctx, base);
	// 8281E0B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281E0B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E0BC: 4BFCC195  bl 0x827ea250
	ctx.lr = 0x8281E0C0;
	sub_827EA250(ctx, base);
	// 8281E0C0: 480000B0  b 0x8281e170
	pc = 0x8281E170; continue 'dispatch;
	// 8281E0C4: 807F02D4  lwz r3, 0x2d4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(724 as u32) ) } as u64;
	// 8281E0C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281E0CC: 419A0008  beq cr6, 0x8281e0d4
	if ctx.cr[6].eq {
	pc = 0x8281E0D4; continue 'dispatch;
	}
	// 8281E0D0: 4815EA29  bl 0x8297caf8
	ctx.lr = 0x8281E0D4;
	sub_8297CAF8(ctx, base);
	// 8281E0D4: 897F02D0  lbz r11, 0x2d0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(720 as u32) ) } as u64;
	// 8281E0D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281E0DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281E0E0: 40820010  bne 0x8281e0f0
	if !ctx.cr[0].eq {
	pc = 0x8281E0F0; continue 'dispatch;
	}
	// 8281E0E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281E0E8: 4BFCCFA1  bl 0x827eb088
	ctx.lr = 0x8281E0EC;
	sub_827EB088(ctx, base);
	// 8281E0EC: 48000084  b 0x8281e170
	pc = 0x8281E170; continue 'dispatch;
	// 8281E0F0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8281E0F4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8281E0F8: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8281E0FC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8281E100: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281E180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281E180 size=288
    let mut pc: u32 = 0x8281E180;
    'dispatch: loop {
        match pc {
            0x8281E180 => {
    //   block [0x8281E180..0x8281E2A0)
	// 8281E180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281E184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281E188: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281E18C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281E190: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281E2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281E2A0 size=372
    let mut pc: u32 = 0x8281E2A0;
    'dispatch: loop {
        match pc {
            0x8281E2A0 => {
    //   block [0x8281E2A0..0x8281E414)
	// 8281E2A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281E2A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281E2A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281E2AC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281E2B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281E2B4: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281E2B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281E2BC: 409A00A4  bne cr6, 0x8281e360
	if !ctx.cr[6].eq {
	pc = 0x8281E360; continue 'dispatch;
	}
	// 8281E2C0: 548A063F  clrlwi. r10, r4, 0x18
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8281E2C4: 40820094  bne 0x8281e358
	if !ctx.cr[0].eq {
	pc = 0x8281E358; continue 'dispatch;
	}
	// 8281E2C8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281E2CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281E2D0: 388B9B50  addi r4, r11, -0x64b0
	ctx.r[4].s64 = ctx.r[11].s64 + -25776;
	// 8281E2D4: 485D5735  bl 0x82df3a08
	ctx.lr = 0x8281E2D8;
	sub_82DF3A08(ctx, base);
	// 8281E2D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281E2DC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8281E2E0: 480453E1  bl 0x828636c0
	ctx.lr = 0x8281E2E4;
	sub_828636C0(ctx, base);
	// 8281E2E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281E2E8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8281E2EC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281E2F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281E2F4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8281E2F8: 419A0024  beq cr6, 0x8281e31c
	if ctx.cr[6].eq {
	pc = 0x8281E31C; continue 'dispatch;
	}
	// 8281E2FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281E300: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281E304: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281E308: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281E30C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281E310: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281E314: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281E318: 4082FFE8  bne 0x8281e300
	if !ctx.cr[0].eq {
	pc = 0x8281E300; continue 'dispatch;
	}
	// 8281E31C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8281E320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281E324: 4BFCEA35  bl 0x827ecd58
	ctx.lr = 0x8281E328;
	sub_827ECD58(ctx, base);
	// 8281E328: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281E32C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281E330: 419A0008  beq cr6, 0x8281e338
	if ctx.cr[6].eq {
	pc = 0x8281E338; continue 'dispatch;
	}
	// 8281E334: 4BAA255D  bl 0x822c0890
	ctx.lr = 0x8281E338;
	sub_822C0890(ctx, base);
	// 8281E338: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8281E33C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281E340: 419A0008  beq cr6, 0x8281e348
	if ctx.cr[6].eq {
	pc = 0x8281E348; continue 'dispatch;
	}
	// 8281E344: 4BAA254D  bl 0x822c0890
	ctx.lr = 0x8281E348;
	sub_822C0890(ctx, base);
	// 8281E348: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281E34C: 485D50DD  bl 0x82df3428
	ctx.lr = 0x8281E350;
	sub_82DF3428(ctx, base);
	// 8281E350: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8281E354: 480000A8  b 0x8281e3fc
	pc = 0x8281E3FC; continue 'dispatch;
	// 8281E358: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281E35C: 419A00A4  beq cr6, 0x8281e400
	if ctx.cr[6].eq {
	pc = 0x8281E400; continue 'dispatch;
	}
	// 8281E360: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281E364: 4182009C  beq 0x8281e400
	if ctx.cr[0].eq {
	pc = 0x8281E400; continue 'dispatch;
	}
	// 8281E368: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281E36C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281E370: 388B9B2C  addi r4, r11, -0x64d4
	ctx.r[4].s64 = ctx.r[11].s64 + -25812;
	// 8281E374: 485D5695  bl 0x82df3a08
	ctx.lr = 0x8281E378;
	sub_82DF3A08(ctx, base);
	// 8281E378: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281E37C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281E380: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8281E384: C02B89AC  lfs f1, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281E388: 480453B1  bl 0x82863738
	ctx.lr = 0x8281E38C;
	sub_82863738(ctx, base);
	// 8281E38C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281E390: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8281E394: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281E398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281E39C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8281E3A0: 419A0024  beq cr6, 0x8281e3c4
	if ctx.cr[6].eq {
	pc = 0x8281E3C4; continue 'dispatch;
	}
	// 8281E3A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281E3A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281E3AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281E3B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281E3B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281E3B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281E3BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281E3C0: 4082FFE8  bne 0x8281e3a8
	if !ctx.cr[0].eq {
	pc = 0x8281E3A8; continue 'dispatch;
	}
	// 8281E3C4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8281E3C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281E3CC: 4BFCE98D  bl 0x827ecd58
	ctx.lr = 0x8281E3D0;
	sub_827ECD58(ctx, base);
	// 8281E3D0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8281E3D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281E3D8: 419A0008  beq cr6, 0x8281e3e0
	if ctx.cr[6].eq {
	pc = 0x8281E3E0; continue 'dispatch;
	}
	// 8281E3DC: 4BAA24B5  bl 0x822c0890
	ctx.lr = 0x8281E3E0;
	sub_822C0890(ctx, base);
	// 8281E3E0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8281E3E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281E3E8: 419A0008  beq cr6, 0x8281e3f0
	if ctx.cr[6].eq {
	pc = 0x8281E3F0; continue 'dispatch;
	}
	// 8281E3EC: 4BAA24A5  bl 0x822c0890
	ctx.lr = 0x8281E3F0;
	sub_822C0890(ctx, base);
	// 8281E3F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281E3F4: 485D5035  bl 0x82df3428
	ctx.lr = 0x8281E3F8;
	sub_82DF3428(ctx, base);
	// 8281E3F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281E3FC: 917F02B4  stw r11, 0x2b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u32 ) };
	// 8281E400: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8281E404: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281E408: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281E40C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281E410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281E418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281E418 size=112
    let mut pc: u32 = 0x8281E418;
    'dispatch: loop {
        match pc {
            0x8281E418 => {
    //   block [0x8281E418..0x8281E488)
	// 8281E418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281E41C: 48989D51  bl 0x831a816c
	ctx.lr = 0x8281E420;
	sub_831A8130(ctx, base);
	// 8281E420: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281E424: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281E428: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8281E42C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281E430: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8281E434: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8281E438: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8281E43C: 485D3FAD  bl 0x82df23e8
	ctx.lr = 0x8281E440;
	sub_82DF23E8(ctx, base);
	// 8281E440: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281E444: 41820010  beq 0x8281e454
	if ctx.cr[0].eq {
	pc = 0x8281E454; continue 'dispatch;
	}
	// 8281E448: 483349E9  bl 0x82b52e30
	ctx.lr = 0x8281E44C;
	sub_82B52E30(ctx, base);
	// 8281E44C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281E450: 48000008  b 0x8281e458
	pc = 0x8281E458; continue 'dispatch;
	// 8281E454: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8281E458: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8281E45C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8281E460: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281E464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E468: 4BFFE5F9  bl 0x8281ca60
	ctx.lr = 0x8281E46C;
	sub_8281CA60(ctx, base);
	// 8281E46C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8281E470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281E474: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E478: 4BAA1B89  bl 0x822c0000
	ctx.lr = 0x8281E47C;
	sub_822C0000(ctx, base);
	// 8281E47C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281E480: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281E484: 48989D38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281E488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281E488 size=124
    let mut pc: u32 = 0x8281E488;
    'dispatch: loop {
        match pc {
            0x8281E488 => {
    //   block [0x8281E488..0x8281E504)
	// 8281E488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281E48C: 48989CE1  bl 0x831a816c
	ctx.lr = 0x8281E490;
	sub_831A8130(ctx, base);
	// 8281E490: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281E494: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281E498: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8281E49C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281E4A0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8281E4A4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8281E4A8: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8281E4AC: 485D3F3D  bl 0x82df23e8
	ctx.lr = 0x8281E4B0;
	sub_82DF23E8(ctx, base);
	// 8281E4B0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8281E4B4: 4182001C  beq 0x8281e4d0
	if ctx.cr[0].eq {
	pc = 0x8281E4D0; continue 'dispatch;
	}
	// 8281E4B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281E4BC: 4863B1E5  bl 0x82e596a0
	ctx.lr = 0x8281E4C0;
	sub_82E596A0(ctx, base);
	// 8281E4C0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281E4C4: 396B9B78  addi r11, r11, -0x6488
	ctx.r[11].s64 = ctx.r[11].s64 + -25736;
	// 8281E4C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281E4CC: 48000008  b 0x8281e4d4
	pc = 0x8281E4D4; continue 'dispatch;
	// 8281E4D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8281E4D4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8281E4D8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8281E4DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281E4E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E4E4: 4BFFE645  bl 0x8281cb28
	ctx.lr = 0x8281E4E8;
	sub_8281CB28(ctx, base);
	// 8281E4E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8281E4EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281E4F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E4F4: 4BAA1B0D  bl 0x822c0000
	ctx.lr = 0x8281E4F8;
	sub_822C0000(ctx, base);
	// 8281E4F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281E4FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281E500: 48989CBC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281E508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281E508 size=124
    let mut pc: u32 = 0x8281E508;
    'dispatch: loop {
        match pc {
            0x8281E508 => {
    //   block [0x8281E508..0x8281E584)
	// 8281E508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281E50C: 48989C61  bl 0x831a816c
	ctx.lr = 0x8281E510;
	sub_831A8130(ctx, base);
	// 8281E510: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281E514: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281E518: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8281E51C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281E520: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8281E524: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8281E528: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8281E52C: 485D3EBD  bl 0x82df23e8
	ctx.lr = 0x8281E530;
	sub_82DF23E8(ctx, base);
	// 8281E530: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8281E534: 4182001C  beq 0x8281e550
	if ctx.cr[0].eq {
	pc = 0x8281E550; continue 'dispatch;
	}
	// 8281E538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281E53C: 4863B145  bl 0x82e59680
	ctx.lr = 0x8281E540;
	sub_82E59680(ctx, base);
	// 8281E540: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281E544: 396B9B80  addi r11, r11, -0x6480
	ctx.r[11].s64 = ctx.r[11].s64 + -25728;
	// 8281E548: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281E54C: 48000008  b 0x8281e554
	pc = 0x8281E554; continue 'dispatch;
	// 8281E550: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8281E554: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8281E558: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8281E55C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281E560: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E564: 4BFFE68D  bl 0x8281cbf0
	ctx.lr = 0x8281E568;
	sub_8281CBF0(ctx, base);
	// 8281E568: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8281E56C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281E570: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E574: 4BAA1A8D  bl 0x822c0000
	ctx.lr = 0x8281E578;
	sub_822C0000(ctx, base);
	// 8281E578: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281E57C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281E580: 48989C3C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281E588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281E588 size=120
    let mut pc: u32 = 0x8281E588;
    'dispatch: loop {
        match pc {
            0x8281E588 => {
    //   block [0x8281E588..0x8281E600)
	// 8281E588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281E58C: 48989BE1  bl 0x831a816c
	ctx.lr = 0x8281E590;
	sub_831A8130(ctx, base);
	// 8281E590: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281E594: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281E598: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8281E59C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281E5A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281E5A4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8281E5A8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8281E5AC: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 8281E5B0: 485D3E39  bl 0x82df23e8
	ctx.lr = 0x8281E5B4;
	sub_82DF23E8(ctx, base);
	// 8281E5B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281E5B8: 41820014  beq 0x8281e5cc
	if ctx.cr[0].eq {
	pc = 0x8281E5CC; continue 'dispatch;
	}
	// 8281E5BC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281E5C0: 4BFFD309  bl 0x8281b8c8
	ctx.lr = 0x8281E5C4;
	sub_8281B8C8(ctx, base);
	// 8281E5C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281E5C8: 48000008  b 0x8281e5d0
	pc = 0x8281E5D0; continue 'dispatch;
	// 8281E5CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8281E5D0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8281E5D4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8281E5D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281E5DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E5E0: 4BFFE6D9  bl 0x8281ccb8
	ctx.lr = 0x8281E5E4;
	sub_8281CCB8(ctx, base);
	// 8281E5E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8281E5E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281E5EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E5F0: 4BAA1A11  bl 0x822c0000
	ctx.lr = 0x8281E5F4;
	sub_822C0000(ctx, base);
	// 8281E5F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281E5F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281E5FC: 48989BC0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281E600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281E600 size=112
    let mut pc: u32 = 0x8281E600;
    'dispatch: loop {
        match pc {
            0x8281E600 => {
    //   block [0x8281E600..0x8281E670)
	// 8281E600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281E604: 48989B69  bl 0x831a816c
	ctx.lr = 0x8281E608;
	sub_831A8130(ctx, base);
	// 8281E608: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281E60C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281E610: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8281E614: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281E618: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8281E61C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8281E620: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8281E624: 485D3DC5  bl 0x82df23e8
	ctx.lr = 0x8281E628;
	sub_82DF23E8(ctx, base);
	// 8281E628: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281E62C: 41820010  beq 0x8281e63c
	if ctx.cr[0].eq {
	pc = 0x8281E63C; continue 'dispatch;
	}
	// 8281E630: 4802D899  bl 0x8284bec8
	ctx.lr = 0x8281E634;
	sub_8284BEC8(ctx, base);
	// 8281E634: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281E638: 48000008  b 0x8281e640
	pc = 0x8281E640; continue 'dispatch;
	// 8281E63C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8281E640: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8281E644: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8281E648: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281E64C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E650: 4BFFE731  bl 0x8281cd80
	ctx.lr = 0x8281E654;
	sub_8281CD80(ctx, base);
	// 8281E654: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8281E658: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281E65C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E660: 4BAA19A1  bl 0x822c0000
	ctx.lr = 0x8281E664;
	sub_822C0000(ctx, base);
	// 8281E664: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281E668: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281E66C: 48989B50  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281E670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281E670 size=112
    let mut pc: u32 = 0x8281E670;
    'dispatch: loop {
        match pc {
            0x8281E670 => {
    //   block [0x8281E670..0x8281E6E0)
	// 8281E670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281E674: 48989AF9  bl 0x831a816c
	ctx.lr = 0x8281E678;
	sub_831A8130(ctx, base);
	// 8281E678: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281E67C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281E680: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8281E684: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281E688: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8281E68C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8281E690: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8281E694: 485D3D55  bl 0x82df23e8
	ctx.lr = 0x8281E698;
	sub_82DF23E8(ctx, base);
	// 8281E698: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281E69C: 41820010  beq 0x8281e6ac
	if ctx.cr[0].eq {
	pc = 0x8281E6AC; continue 'dispatch;
	}
	// 8281E6A0: 4802D9E9  bl 0x8284c088
	ctx.lr = 0x8281E6A4;
	sub_8284C088(ctx, base);
	// 8281E6A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281E6A8: 48000008  b 0x8281e6b0
	pc = 0x8281E6B0; continue 'dispatch;
	// 8281E6AC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8281E6B0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8281E6B4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8281E6B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281E6BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E6C0: 4BFFE789  bl 0x8281ce48
	ctx.lr = 0x8281E6C4;
	sub_8281CE48(ctx, base);
	// 8281E6C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8281E6C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281E6CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E6D0: 4BAA1931  bl 0x822c0000
	ctx.lr = 0x8281E6D4;
	sub_822C0000(ctx, base);
	// 8281E6D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281E6D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281E6DC: 48989AE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281E6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281E6E0 size=160
    let mut pc: u32 = 0x8281E6E0;
    'dispatch: loop {
        match pc {
            0x8281E6E0 => {
    //   block [0x8281E6E0..0x8281E780)
	// 8281E6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281E6E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281E6E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281E6EC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281E6F0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281E6F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281E6F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8281E6FC: 388B9C40  addi r4, r11, -0x63c0
	ctx.r[4].s64 = ctx.r[11].s64 + -25536;
	// 8281E700: 485D5309  bl 0x82df3a08
	ctx.lr = 0x8281E704;
	sub_82DF3A08(ctx, base);
	// 8281E704: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281E708: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281E70C: 388B9C34  addi r4, r11, -0x63cc
	ctx.r[4].s64 = ctx.r[11].s64 + -25548;
	// 8281E710: 485D52F9  bl 0x82df3a08
	ctx.lr = 0x8281E714;
	sub_82DF3A08(ctx, base);
	// 8281E714: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281E718: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8281E71C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8281E720: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8281E724: 38A9F8C0  addi r5, r9, -0x740
	ctx.r[5].s64 = ctx.r[9].s64 + -1856;
	// 8281E728: C06B964C  lfs f3, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8281E72C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281E730: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8281E734: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 8281E738: 4BD84B71  bl 0x825a32a8
	ctx.lr = 0x8281E73C;
	sub_825A32A8(ctx, base);
	// 8281E73C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8281E740: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281E744: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281E748: 4BD83029  bl 0x825a1770
	ctx.lr = 0x8281E74C;
	sub_825A1770(ctx, base);
	// 8281E74C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8281E750: 485D4CD9  bl 0x82df3428
	ctx.lr = 0x8281E754;
	sub_82DF3428(ctx, base);
	// 8281E754: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8281E758: 4BAAA561  bl 0x822c8cb8
	ctx.lr = 0x8281E75C;
	sub_822C8CB8(ctx, base);
	// 8281E75C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281E760: 485D4CC9  bl 0x82df3428
	ctx.lr = 0x8281E764;
	sub_82DF3428(ctx, base);
	// 8281E764: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8281E768: 485D4CC1  bl 0x82df3428
	ctx.lr = 0x8281E76C;
	sub_82DF3428(ctx, base);
	// 8281E76C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8281E770: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281E774: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281E778: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281E77C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281E780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281E780 size=364
    let mut pc: u32 = 0x8281E780;
    'dispatch: loop {
        match pc {
            0x8281E780 => {
    //   block [0x8281E780..0x8281E8EC)
	// 8281E780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281E784: 489899E9  bl 0x831a816c
	ctx.lr = 0x8281E788;
	sub_831A8130(ctx, base);
	// 8281E788: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281E78C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8281E790: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8281E794: 3BDF0264  addi r30, r31, 0x264
	ctx.r[30].s64 = ctx.r[31].s64 + 612;
	// 8281E798: 817F0264  lwz r11, 0x264(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 8281E79C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281E7A0: 409A0108  bne cr6, 0x8281e8a8
	if !ctx.cr[6].eq {
	pc = 0x8281E8A8; continue 'dispatch;
	}
	// 8281E7A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281E7A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281E7AC: 388B7868  addi r4, r11, 0x7868
	ctx.r[4].s64 = ctx.r[11].s64 + 30824;
	// 8281E7B0: 485D5259  bl 0x82df3a08
	ctx.lr = 0x8281E7B4;
	sub_82DF3A08(ctx, base);
	// 8281E7B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281E7B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281E7BC: 4BFCDE0D  bl 0x827ec5c8
	ctx.lr = 0x8281E7C0;
	sub_827EC5C8(ctx, base);
	// 8281E7C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281E7C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8281E7C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281E7CC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281E7D0: 485F6861  bl 0x82e15030
	ctx.lr = 0x8281E7D4;
	sub_82E15030(ctx, base);
	// 8281E7D4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8281E7D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281E7DC: 419A0008  beq cr6, 0x8281e7e4
	if ctx.cr[6].eq {
	pc = 0x8281E7E4; continue 'dispatch;
	}
	// 8281E7E0: 4BAA20B1  bl 0x822c0890
	ctx.lr = 0x8281E7E4;
	sub_822C0890(ctx, base);
	// 8281E7E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281E7E8: 485D4C41  bl 0x82df3428
	ctx.lr = 0x8281E7EC;
	sub_82DF3428(ctx, base);
	// 8281E7EC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8281E7F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281E7F4: 419A00A4  beq cr6, 0x8281e898
	if ctx.cr[6].eq {
	pc = 0x8281E898; continue 'dispatch;
	}
	// 8281E7F8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8281E7FC: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 8281E800: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8281E804: 388AF8E0  addi r4, r10, -0x720
	ctx.r[4].s64 = ctx.r[10].s64 + -1824;
	// 8281E808: C02B7590  lfs f1, 0x7590(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281E80C: 4865E435  bl 0x82e7cc40
	ctx.lr = 0x8281E810;
	sub_82E7CC40(ctx, base);
	// 8281E810: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281E814: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8281E818: 3D208203  lis r9, -0x7dfd
	ctx.r[9].s64 = -2113732608;
	// 8281E81C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8281E820: C06B9CAC  lfs f3, -0x6354(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25428 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8281E824: C04A08A4  lfs f2, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8281E828: C0297BC8  lfs f1, 0x7bc8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(31688 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281E82C: 4865D7ED  bl 0x82e7c018
	ctx.lr = 0x8281E830;
	sub_82E7C018(ctx, base);
	// 8281E830: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281E834: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8281E838: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 8281E83C: 4865D65D  bl 0x82e7be98
	ctx.lr = 0x8281E840;
	sub_82E7BE98(ctx, base);
	// 8281E840: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281E844: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8281E848: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8281E84C: 4BAA60B5  bl 0x822c4900
	ctx.lr = 0x8281E850;
	sub_822C4900(ctx, base);
	// 8281E850: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281E854: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281E858: 388B9C50  addi r4, r11, -0x63b0
	ctx.r[4].s64 = ctx.r[11].s64 + -25520;
	// 8281E85C: 38A00143  li r5, 0x143
	ctx.r[5].s64 = 323;
	// 8281E860: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8281E864: 485D3B85  bl 0x82df23e8
	ctx.lr = 0x8281E868;
	sub_82DF23E8(ctx, base);
	// 8281E868: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8281E86C: 41820014  beq 0x8281e880
	if ctx.cr[0].eq {
	pc = 0x8281E880; continue 'dispatch;
	}
	// 8281E870: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8281E874: 485F487D  bl 0x82e130f0
	ctx.lr = 0x8281E878;
	sub_82E130F0(ctx, base);
	// 8281E878: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281E87C: 48000008  b 0x8281e884
	pc = 0x8281E884; continue 'dispatch;
	// 8281E880: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8281E884: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281E888: 4BAC34C9  bl 0x822e1d50
	ctx.lr = 0x8281E88C;
	sub_822E1D50(ctx, base);
	// 8281E88C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8281E890: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281E894: 485F459D  bl 0x82e12e30
	ctx.lr = 0x8281E898;
	sub_82E12E30(ctx, base);
	// 8281E898: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281E89C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281E8A0: 419A0008  beq cr6, 0x8281e8a8
	if ctx.cr[6].eq {
	pc = 0x8281E8A8; continue 'dispatch;
	}
	// 8281E8A4: 4BAA1FED  bl 0x822c0890
	ctx.lr = 0x8281E8A8;
	sub_822C0890(ctx, base);
	// 8281E8A8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281E8AC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281E8B0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281E8B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281E8B8: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8281E8BC: 419A0024  beq cr6, 0x8281e8e0
	if ctx.cr[6].eq {
	pc = 0x8281E8E0; continue 'dispatch;
	}
	// 8281E8C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281E8C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281E8C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281E8CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281E8D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281E8D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281E8D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281E8DC: 4082FFE8  bne 0x8281e8c4
	if !ctx.cr[0].eq {
	pc = 0x8281E8C4; continue 'dispatch;
	}
	// 8281E8E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281E8E4: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 8281E8E8: 489898D4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281E8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281E8F0 size=832
    let mut pc: u32 = 0x8281E8F0;
    'dispatch: loop {
        match pc {
            0x8281E8F0 => {
    //   block [0x8281E8F0..0x8281EC30)
	// 8281E8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281E8F4: 48989869  bl 0x831a815c
	ctx.lr = 0x8281E8F8;
	sub_831A8130(ctx, base);
	// 8281E8F8: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 8281E8FC: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8281E900: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281E904: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281E908: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8281E90C: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 8281E910: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8281E914: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281E918: 388B9C50  addi r4, r11, -0x63b0
	ctx.r[4].s64 = ctx.r[11].s64 + -25520;
	// 8281E91C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8281E920: 38A00152  li r5, 0x152
	ctx.r[5].s64 = 338;
	// 8281E924: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8281E928: 4BAA1AB1  bl 0x822c03d8
	ctx.lr = 0x8281E92C;
	sub_822C03D8(ctx, base);
	// 8281E92C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8281E930: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8281E934: 3B4B44A0  addi r26, r11, 0x44a0
	ctx.r[26].s64 = ctx.r[11].s64 + 17568;
	// 8281E938: 41820030  beq 0x8281e968
	if ctx.cr[0].eq {
	pc = 0x8281E968; continue 'dispatch;
	}
	// 8281E93C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8281E940: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281E944: 485D50C5  bl 0x82df3a08
	ctx.lr = 0x8281E948;
	sub_82DF3A08(ctx, base);
	// 8281E948: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281E94C: 38BB00B0  addi r5, r27, 0xb0
	ctx.r[5].s64 = ctx.r[27].s64 + 176;
	// 8281E950: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281E954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281E958: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 8281E95C: 4BD8DAB5  bl 0x825ac410
	ctx.lr = 0x8281E960;
	sub_825AC410(ctx, base);
	// 8281E960: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281E964: 48000008  b 0x8281e96c
	pc = 0x8281E96C; continue 'dispatch;
	// 8281E968: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8281E96C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8281E970: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281E974: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8281E978: 4BCD4A41  bl 0x824f33b8
	ctx.lr = 0x8281E97C;
	sub_824F33B8(ctx, base);
	// 8281E97C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8281E980: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281E984: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8281E988: 4BAA1679  bl 0x822c0000
	ctx.lr = 0x8281E98C;
	sub_822C0000(ctx, base);
	// 8281E98C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281E990: 4182000C  beq 0x8281e99c
	if ctx.cr[0].eq {
	pc = 0x8281E99C; continue 'dispatch;
	}
	// 8281E994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281E998: 485D4A91  bl 0x82df3428
	ctx.lr = 0x8281E99C;
	sub_82DF3428(ctx, base);
	// 8281E99C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281E9A0: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8281E9A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8281E9A8: 3BAB9B08  addi r29, r11, -0x64f8
	ctx.r[29].s64 = ctx.r[11].s64 + -25848;
	// 8281E9AC: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 8281E9B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281E9B4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281E9B8: 485D5051  bl 0x82df3a08
	ctx.lr = 0x8281E9BC;
	sub_82DF3A08(ctx, base);
	// 8281E9BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8281E9C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281E9C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8281E9C8: 4BD8D3F9  bl 0x825abdc0
	ctx.lr = 0x8281E9CC;
	sub_825ABDC0(ctx, base);
	// 8281E9CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281E9D0: 485D4A59  bl 0x82df3428
	ctx.lr = 0x8281E9D4;
	sub_82DF3428(ctx, base);
	// 8281E9D4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 8281E9D8: 397D0018  addi r11, r29, 0x18
	ctx.r[11].s64 = ctx.r[29].s64 + 24;
	// 8281E9DC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8281E9E0: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8281E9E4: 4198FFCC  blt cr6, 0x8281e9b0
	if ctx.cr[6].lt {
	pc = 0x8281E9B0; continue 'dispatch;
	}
	// 8281E9E8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8281E9EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281E9F0: 485D5019  bl 0x82df3a08
	ctx.lr = 0x8281E9F4;
	sub_82DF3A08(ctx, base);
	// 8281E9F4: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281E9F8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 8281E9FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281EA00: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8281EA04: 419A0024  beq cr6, 0x8281ea28
	if ctx.cr[6].eq {
	pc = 0x8281EA28; continue 'dispatch;
	}
	// 8281EA08: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8281EA0C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281EA10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281EA14: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281EA18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281EA1C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281EA20: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281EA24: 4082FFE8  bne 0x8281ea0c
	if !ctx.cr[0].eq {
	pc = 0x8281EA0C; continue 'dispatch;
	}
	// 8281EA28: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8281EA2C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281EA30: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8281EA34: 4BD836DD  bl 0x825a2110
	ctx.lr = 0x8281EA38;
	sub_825A2110(ctx, base);
	// 8281EA38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281EA3C: 485D49ED  bl 0x82df3428
	ctx.lr = 0x8281EA40;
	sub_82DF3428(ctx, base);
	// 8281EA40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281EA44: 419A000C  beq cr6, 0x8281ea50
	if ctx.cr[6].eq {
	pc = 0x8281EA50; continue 'dispatch;
	}
	// 8281EA48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281EA4C: 4BAA1E45  bl 0x822c0890
	ctx.lr = 0x8281EA50;
	sub_822C0890(ctx, base);
	// 8281EA50: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281EA54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281EA58: 388B9D24  addi r4, r11, -0x62dc
	ctx.r[4].s64 = ctx.r[11].s64 + -25308;
	// 8281EA5C: 485D4FAD  bl 0x82df3a08
	ctx.lr = 0x8281EA60;
	sub_82DF3A08(ctx, base);
	// 8281EA60: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281EA64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281EA68: 388B9B58  addi r4, r11, -0x64a8
	ctx.r[4].s64 = ctx.r[11].s64 + -25768;
	// 8281EA6C: 485D4F9D  bl 0x82df3a08
	ctx.lr = 0x8281EA70;
	sub_82DF3A08(ctx, base);
	// 8281EA70: 3CE00001  lis r7, 1
	ctx.r[7].s64 = 65536;
	// 8281EA74: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8281EA78: 60E7869F  ori r7, r7, 0x869f
	ctx.r[7].u64 = ctx.r[7].u64 | 34463;
	// 8281EA7C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281EA80: 38BB00A8  addi r5, r27, 0xa8
	ctx.r[5].s64 = ctx.r[27].s64 + 168;
	// 8281EA84: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8281EA88: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8281EA8C: 4BD8F105  bl 0x825adb90
	ctx.lr = 0x8281EA90;
	sub_825ADB90(ctx, base);
	// 8281EA90: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8281EA94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281EA98: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8281EA9C: 4BD8331D  bl 0x825a1db8
	ctx.lr = 0x8281EAA0;
	sub_825A1DB8(ctx, base);
	// 8281EAA0: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 8281EAA4: 485D4985  bl 0x82df3428
	ctx.lr = 0x8281EAA8;
	sub_82DF3428(ctx, base);
	// 8281EAA8: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 8281EAAC: 4BAAA20D  bl 0x822c8cb8
	ctx.lr = 0x8281EAB0;
	sub_822C8CB8(ctx, base);
	// 8281EAB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281EAB4: 485D4975  bl 0x82df3428
	ctx.lr = 0x8281EAB8;
	sub_82DF3428(ctx, base);
	// 8281EAB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281EABC: 485D496D  bl 0x82df3428
	ctx.lr = 0x8281EAC0;
	sub_82DF3428(ctx, base);
	// 8281EAC0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281EAC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281EAC8: 388B9D14  addi r4, r11, -0x62ec
	ctx.r[4].s64 = ctx.r[11].s64 + -25324;
	// 8281EACC: 485D4F3D  bl 0x82df3a08
	ctx.lr = 0x8281EAD0;
	sub_82DF3A08(ctx, base);
	// 8281EAD0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281EAD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281EAD8: 388B9D04  addi r4, r11, -0x62fc
	ctx.r[4].s64 = ctx.r[11].s64 + -25340;
	// 8281EADC: 485D4F2D  bl 0x82df3a08
	ctx.lr = 0x8281EAE0;
	sub_82DF3A08(ctx, base);
	// 8281EAE0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281EAE4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 8281EAE8: 38BB00C0  addi r5, r27, 0xc0
	ctx.r[5].s64 = ctx.r[27].s64 + 192;
	// 8281EAEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281EAF0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8281EAF4: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8281EAF8: C3CADD6C  lfs f30, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8281EAFC: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8281EB00: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8281EB04: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8281EB08: 4BD847A1  bl 0x825a32a8
	ctx.lr = 0x8281EB0C;
	sub_825A32A8(ctx, base);
	// 8281EB0C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8281EB10: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8281EB14: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8281EB18: 4BD82C59  bl 0x825a1770
	ctx.lr = 0x8281EB1C;
	sub_825A1770(ctx, base);
	// 8281EB1C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 8281EB20: 485D4909  bl 0x82df3428
	ctx.lr = 0x8281EB24;
	sub_82DF3428(ctx, base);
	// 8281EB24: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 8281EB28: 4BAAA191  bl 0x822c8cb8
	ctx.lr = 0x8281EB2C;
	sub_822C8CB8(ctx, base);
	// 8281EB2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281EB30: 485D48F9  bl 0x82df3428
	ctx.lr = 0x8281EB34;
	sub_82DF3428(ctx, base);
	// 8281EB34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281EB38: 485D48F1  bl 0x82df3428
	ctx.lr = 0x8281EB3C;
	sub_82DF3428(ctx, base);
	// 8281EB3C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281EB40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281EB44: 388B9CF4  addi r4, r11, -0x630c
	ctx.r[4].s64 = ctx.r[11].s64 + -25356;
	// 8281EB48: 485D4EC1  bl 0x82df3a08
	ctx.lr = 0x8281EB4C;
	sub_82DF3A08(ctx, base);
	// 8281EB4C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281EB50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281EB54: 388B9CE4  addi r4, r11, -0x631c
	ctx.r[4].s64 = ctx.r[11].s64 + -25372;
	// 8281EB58: 485D4EB1  bl 0x82df3a08
	ctx.lr = 0x8281EB5C;
	sub_82DF3A08(ctx, base);
	// 8281EB5C: 38BB00C4  addi r5, r27, 0xc4
	ctx.r[5].s64 = ctx.r[27].s64 + 196;
	// 8281EB60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281EB64: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8281EB68: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 8281EB6C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8281EB70: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8281EB74: 4BD84735  bl 0x825a32a8
	ctx.lr = 0x8281EB78;
	sub_825A32A8(ctx, base);
	// 8281EB78: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8281EB7C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8281EB80: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8281EB84: 4BD82BED  bl 0x825a1770
	ctx.lr = 0x8281EB88;
	sub_825A1770(ctx, base);
	// 8281EB88: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 8281EB8C: 485D489D  bl 0x82df3428
	ctx.lr = 0x8281EB90;
	sub_82DF3428(ctx, base);
	// 8281EB90: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 8281EB94: 4BAAA125  bl 0x822c8cb8
	ctx.lr = 0x8281EB98;
	sub_822C8CB8(ctx, base);
	// 8281EB98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281EB9C: 485D488D  bl 0x82df3428
	ctx.lr = 0x8281EBA0;
	sub_82DF3428(ctx, base);
	// 8281EBA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281EBA4: 485D4885  bl 0x82df3428
	ctx.lr = 0x8281EBA8;
	sub_82DF3428(ctx, base);
	// 8281EBA8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281EBAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281EBB0: 388B9CBC  addi r4, r11, -0x6344
	ctx.r[4].s64 = ctx.r[11].s64 + -25412;
	// 8281EBB4: 485D4E55  bl 0x82df3a08
	ctx.lr = 0x8281EBB8;
	sub_82DF3A08(ctx, base);
	// 8281EBB8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281EBBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281EBC0: 388B9CB0  addi r4, r11, -0x6350
	ctx.r[4].s64 = ctx.r[11].s64 + -25424;
	// 8281EBC4: 485D4E45  bl 0x82df3a08
	ctx.lr = 0x8281EBC8;
	sub_82DF3A08(ctx, base);
	// 8281EBC8: 38BB00C8  addi r5, r27, 0xc8
	ctx.r[5].s64 = ctx.r[27].s64 + 200;
	// 8281EBCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8281EBD0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8281EBD4: 4BD8447D  bl 0x825a3050
	ctx.lr = 0x8281EBD8;
	sub_825A3050(ctx, base);
	// 8281EBD8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8281EBDC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8281EBE0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8281EBE4: 4BD835A5  bl 0x825a2188
	ctx.lr = 0x8281EBE8;
	sub_825A2188(ctx, base);
	// 8281EBE8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8281EBEC: 485D483D  bl 0x82df3428
	ctx.lr = 0x8281EBF0;
	sub_82DF3428(ctx, base);
	// 8281EBF0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8281EBF4: 4BAAA0C5  bl 0x822c8cb8
	ctx.lr = 0x8281EBF8;
	sub_822C8CB8(ctx, base);
	// 8281EBF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281EBFC: 485D482D  bl 0x82df3428
	ctx.lr = 0x8281EC00;
	sub_82DF3428(ctx, base);
	// 8281EC00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281EC04: 485D4825  bl 0x82df3428
	ctx.lr = 0x8281EC08;
	sub_82DF3428(ctx, base);
	// 8281EC08: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8281EC0C: 387BFDF8  addi r3, r27, -0x208
	ctx.r[3].s64 = ctx.r[27].s64 + -520;
	// 8281EC10: 4BFF9589  bl 0x82818198
	ctx.lr = 0x8281EC14;
	sub_82818198(ctx, base);
	// 8281EC14: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8281EC18: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8281EC1C: 4BFF9D4D  bl 0x82818968
	ctx.lr = 0x8281EC20;
	sub_82818968(ctx, base);
	// 8281EC20: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 8281EC24: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8281EC28: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8281EC2C: 48989580  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281EC30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281EC30 size=360
    let mut pc: u32 = 0x8281EC30;
    'dispatch: loop {
        match pc {
            0x8281EC30 => {
    //   block [0x8281EC30..0x8281ED98)
	// 8281EC30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281EC34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281EC38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281EC3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281EC40: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281EC44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281EC48: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281EC4C: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281EC50: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 8281EC54: 40980108  bge cr6, 0x8281ed5c
	if !ctx.cr[6].lt {
	pc = 0x8281ED5C; continue 'dispatch;
	}
	// 8281EC58: 3D008282  lis r8, -0x7d7e
	ctx.r[8].s64 = -2105409536;
	// 8281EC5C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281EC60: 3D408282  lis r10, -0x7d7e
	ctx.r[10].s64 = -2105409536;
	// 8281EC64: 3CE08282  lis r7, -0x7d7e
	ctx.r[7].s64 = -2105409536;
	// 8281EC68: 3908C400  addi r8, r8, -0x3c00
	ctx.r[8].s64 = ctx.r[8].s64 + -15360;
	// 8281EC6C: 394AC440  addi r10, r10, -0x3bc0
	ctx.r[10].s64 = ctx.r[10].s64 + -15296;
	// 8281EC70: 3CA08282  lis r5, -0x7d7e
	ctx.r[5].s64 = -2105409536;
	// 8281EC74: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 8281EC78: 38E7C410  addi r7, r7, -0x3bf0
	ctx.r[7].s64 = ctx.r[7].s64 + -15344;
	// 8281EC7C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8281EC80: 3CC08282  lis r6, -0x7d7e
	ctx.r[6].s64 = -2105409536;
	// 8281EC84: 81290070  lwz r9, 0x70(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281EC88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281EC8C: 90E10060  stw r7, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[7].u32 ) };
	// 8281EC90: 3905C430  addi r8, r5, -0x3bd0
	ctx.r[8].s64 = ctx.r[5].s64 + -15312;
	// 8281EC94: 3946C420  addi r10, r6, -0x3be0
	ctx.r[10].s64 = ctx.r[6].s64 + -15328;
	// 8281EC98: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8281EC9C: 3CE08282  lis r7, -0x7d7e
	ctx.r[7].s64 = -2105409536;
	// 8281ECA0: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	// 8281ECA4: E8810070  ld r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 8281ECA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281ECAC: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 8281ECB0: 3947C400  addi r10, r7, -0x3c00
	ctx.r[10].s64 = ctx.r[7].s64 + -15360;
	// 8281ECB4: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8281ECB8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8281ECBC: E8E10058  ld r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8281ECC0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8281ECC4: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8281ECC8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8281ECCC: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8281ECD0: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 8281ECD4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8281ECD8: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 8281ECDC: F9610088  std r11, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u64 ) };
	// 8281ECE0: F8810080  std r4, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[4].u64 ) };
	// 8281ECE4: F9010090  std r8, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[8].u64 ) };
	// 8281ECE8: F8E10098  std r7, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[7].u64 ) };
	// 8281ECEC: F8C100A0  std r6, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[6].u64 ) };
	// 8281ECF0: F8A100A8  std r5, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[5].u64 ) };
	// 8281ECF4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8281ECF8: 4E800421  bctrl
	ctx.lr = 0x8281ECFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281ECFC: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8281ED00: 4182002C  beq 0x8281ed2c
	if ctx.cr[0].eq {
	pc = 0x8281ED2C; continue 'dispatch;
	}
	// 8281ED04: 817F02B8  lwz r11, 0x2b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(696 as u32) ) } as u64;
	// 8281ED08: 39410084  addi r10, r1, 0x84
	ctx.r[10].s64 = ctx.r[1].s64 + 132;
	// 8281ED0C: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 8281ED10: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281ED14: 55681838  slwi r8, r11, 3
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8281ED18: 7D68502E  lwzx r11, r8, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8281ED1C: 7D48482E  lwzx r10, r8, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8281ED20: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 8281ED24: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8281ED28: 4E800421  bctrl
	ctx.lr = 0x8281ED2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281ED2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281ED30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281ED34: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8281ED38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281ED3C: 4E800421  bctrl
	ctx.lr = 0x8281ED40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281ED40: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8281ED44: 41820018  beq 0x8281ed5c
	if ctx.cr[0].eq {
	pc = 0x8281ED5C; continue 'dispatch;
	}
	// 8281ED48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281ED4C: 4BFFF435  bl 0x8281e180
	ctx.lr = 0x8281ED50;
	sub_8281E180(ctx, base);
	// 8281ED50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281ED54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281ED58: 4BFFF549  bl 0x8281e2a0
	ctx.lr = 0x8281ED5C;
	sub_8281E2A0(ctx, base);
	// 8281ED5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281ED60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281ED64: 4BFF8925  bl 0x82817688
	ctx.lr = 0x8281ED68;
	sub_82817688(ctx, base);
	// 8281ED68: 809F01DC  lwz r4, 0x1dc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 8281ED6C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8281ED70: 419A0010  beq cr6, 0x8281ed80
	if ctx.cr[6].eq {
	pc = 0x8281ED80; continue 'dispatch;
	}
	// 8281ED74: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8281ED78: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8281ED7C: 4BAD4EED  bl 0x822f3c68
	ctx.lr = 0x8281ED80;
	sub_822F3C68(ctx, base);
	// 8281ED80: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8281ED84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281ED88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281ED8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281ED90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281ED94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281ED98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281ED98 size=216
    let mut pc: u32 = 0x8281ED98;
    'dispatch: loop {
        match pc {
            0x8281ED98 => {
    //   block [0x8281ED98..0x8281EE70)
	// 8281ED98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281ED9C: 489893C9  bl 0x831a8164
	ctx.lr = 0x8281EDA0;
	sub_831A8130(ctx, base);
	// 8281EDA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281EDA4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8281EDA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281EDAC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8281EDB0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8281EDB4: 485D4DF5  bl 0x82df3ba8
	ctx.lr = 0x8281EDB8;
	sub_82DF3BA8(ctx, base);
	// 8281EDB8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281EDBC: 408200A8  bne 0x8281ee64
	if !ctx.cr[0].eq {
	pc = 0x8281EE64; continue 'dispatch;
	}
	// 8281EDC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281EDC4: 4BFFF655  bl 0x8281e418
	ctx.lr = 0x8281EDC8;
	sub_8281E418(ctx, base);
	// 8281EDC8: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281EDCC: 83610058  lwz r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8281EDD0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281EDD4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8281EDD8: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 8281EDDC: 419A0024  beq cr6, 0x8281ee00
	if ctx.cr[6].eq {
	pc = 0x8281EE00; continue 'dispatch;
	}
	// 8281EDE0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8281EDE4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281EDE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281EDEC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281EDF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281EDF4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281EDF8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281EDFC: 4082FFE8  bne 0x8281ede4
	if !ctx.cr[0].eq {
	pc = 0x8281EDE4; continue 'dispatch;
	}
	// 8281EE00: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281EE04: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8281EE08: 388B9C50  addi r4, r11, -0x63b0
	ctx.r[4].s64 = ctx.r[11].s64 + -25520;
	// 8281EE0C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8281EE10: 38A0036B  li r5, 0x36b
	ctx.r[5].s64 = 875;
	// 8281EE14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281EE18: 486381D1  bl 0x82e56fe8
	ctx.lr = 0x8281EE1C;
	sub_82E56FE8(ctx, base);
	// 8281EE1C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8281EE20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281EE24: 419A0008  beq cr6, 0x8281ee2c
	if ctx.cr[6].eq {
	pc = 0x8281EE2C; continue 'dispatch;
	}
	// 8281EE28: 4BAA1A69  bl 0x822c0890
	ctx.lr = 0x8281EE2C;
	sub_822C0890(ctx, base);
	// 8281EE2C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8281EE30: 387B0018  addi r3, r27, 0x18
	ctx.r[3].s64 = ctx.r[27].s64 + 24;
	// 8281EE34: 485D44D5  bl 0x82df3308
	ctx.lr = 0x8281EE38;
	sub_82DF3308(ctx, base);
	// 8281EE38: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281EE3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281EE40: 41820018  beq 0x8281ee58
	if ctx.cr[0].eq {
	pc = 0x8281EE58; continue 'dispatch;
	}
	// 8281EE44: 419A000C  beq cr6, 0x8281ee50
	if ctx.cr[6].eq {
	pc = 0x8281EE50; continue 'dispatch;
	}
	// 8281EE48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281EE4C: 4BAA1A45  bl 0x822c0890
	ctx.lr = 0x8281EE50;
	sub_822C0890(ctx, base);
	// 8281EE50: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8281EE54: 48000014  b 0x8281ee68
	pc = 0x8281EE68; continue 'dispatch;
	// 8281EE58: 419A000C  beq cr6, 0x8281ee64
	if ctx.cr[6].eq {
	pc = 0x8281EE64; continue 'dispatch;
	}
	// 8281EE5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281EE60: 4BAA1A31  bl 0x822c0890
	ctx.lr = 0x8281EE64;
	sub_822C0890(ctx, base);
	// 8281EE64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8281EE68: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8281EE6C: 48989348  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281EE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281EE70 size=228
    let mut pc: u32 = 0x8281EE70;
    'dispatch: loop {
        match pc {
            0x8281EE70 => {
    //   block [0x8281EE70..0x8281EF54)
	// 8281EE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281EE74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281EE78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281EE7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281EE80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281EE84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281EE88: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 8281EE8C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 8281EE90: 409800A4  bge cr6, 0x8281ef34
	if !ctx.cr[6].lt {
	pc = 0x8281EF34; continue 'dispatch;
	}
	// 8281EE94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8281EE98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281EE9C: 99640018  stb r11, 0x18(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 8281EEA0: 4BDB91B1  bl 0x825d8050
	ctx.lr = 0x8281EEA4;
	sub_825D8050(ctx, base);
	// 8281EEA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281EEA8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8281EEAC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281EEB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281EEB4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8281EEB8: 419A0024  beq cr6, 0x8281eedc
	if ctx.cr[6].eq {
	pc = 0x8281EEDC; continue 'dispatch;
	}
	// 8281EEBC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281EEC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281EEC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281EEC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281EECC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281EED0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281EED4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281EED8: 4082FFE8  bne 0x8281eec0
	if !ctx.cr[0].eq {
	pc = 0x8281EEC0; continue 'dispatch;
	}
	// 8281EEDC: 3BFF0028  addi r31, r31, 0x28
	ctx.r[31].s64 = ctx.r[31].s64 + 40;
	// 8281EEE0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8281EEE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281EEE8: 487EA0D1  bl 0x83008fb8
	ctx.lr = 0x8281EEEC;
	sub_83008FB8(ctx, base);
	// 8281EEEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8281EEF0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8281EEF4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8281EEF8: 388A9C50  addi r4, r10, -0x63b0
	ctx.r[4].s64 = ctx.r[10].s64 + -25520;
	// 8281EEFC: 38A003DC  li r5, 0x3dc
	ctx.r[5].s64 = 988;
	// 8281EF00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281EF04: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8281EF08: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8281EF0C: 48639B35  bl 0x82e58a40
	ctx.lr = 0x8281EF10;
	sub_82E58A40(ctx, base);
	// 8281EF10: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8281EF14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281EF18: 419A0008  beq cr6, 0x8281ef20
	if ctx.cr[6].eq {
	pc = 0x8281EF20; continue 'dispatch;
	}
	// 8281EF1C: 4BAA1975  bl 0x822c0890
	ctx.lr = 0x8281EF20;
	sub_822C0890(ctx, base);
	// 8281EF20: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281EF24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281EF28: 419A0014  beq cr6, 0x8281ef3c
	if ctx.cr[6].eq {
	pc = 0x8281EF3C; continue 'dispatch;
	}
	// 8281EF2C: 4BAA1965  bl 0x822c0890
	ctx.lr = 0x8281EF30;
	sub_822C0890(ctx, base);
	// 8281EF30: 4800000C  b 0x8281ef3c
	pc = 0x8281EF3C; continue 'dispatch;
	// 8281EF34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281EF38: 99640018  stb r11, 0x18(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 8281EF3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8281EF40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281EF44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281EF48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281EF4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281EF50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281EF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281EF58 size=160
    let mut pc: u32 = 0x8281EF58;
    'dispatch: loop {
        match pc {
            0x8281EF58 => {
    //   block [0x8281EF58..0x8281EFF8)
	// 8281EF58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281EF5C: 4898920D  bl 0x831a8168
	ctx.lr = 0x8281EF60;
	sub_831A8130(ctx, base);
	// 8281EF60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281EF64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281EF68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281EF6C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8281EF70: 4BFFF519  bl 0x8281e488
	ctx.lr = 0x8281EF74;
	sub_8281E488(ctx, base);
	// 8281EF74: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281EF78: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8281EF7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281EF80: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8281EF84: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8281EF88: 419A0024  beq cr6, 0x8281efac
	if ctx.cr[6].eq {
	pc = 0x8281EFAC; continue 'dispatch;
	}
	// 8281EF8C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8281EF90: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281EF94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281EF98: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281EF9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281EFA0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281EFA4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281EFA8: 4082FFE8  bne 0x8281ef90
	if !ctx.cr[0].eq {
	pc = 0x8281EF90; continue 'dispatch;
	}
	// 8281EFAC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281EFB0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8281EFB4: 388B9C50  addi r4, r11, -0x63b0
	ctx.r[4].s64 = ctx.r[11].s64 + -25520;
	// 8281EFB8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8281EFBC: 38A0040F  li r5, 0x40f
	ctx.r[5].s64 = 1039;
	// 8281EFC0: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 8281EFC4: 48638025  bl 0x82e56fe8
	ctx.lr = 0x8281EFC8;
	sub_82E56FE8(ctx, base);
	// 8281EFC8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8281EFCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281EFD0: 419A0008  beq cr6, 0x8281efd8
	if ctx.cr[6].eq {
	pc = 0x8281EFD8; continue 'dispatch;
	}
	// 8281EFD4: 4BAA18BD  bl 0x822c0890
	ctx.lr = 0x8281EFD8;
	sub_822C0890(ctx, base);
	// 8281EFD8: 83DC0018  lwz r30, 0x18(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 8281EFDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281EFE0: 419A000C  beq cr6, 0x8281efec
	if ctx.cr[6].eq {
	pc = 0x8281EFEC; continue 'dispatch;
	}
	// 8281EFE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281EFE8: 4BAA18A9  bl 0x822c0890
	ctx.lr = 0x8281EFEC;
	sub_822C0890(ctx, base);
	// 8281EFEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281EFF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8281EFF4: 489891C4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281EFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281EFF8 size=376
    let mut pc: u32 = 0x8281EFF8;
    'dispatch: loop {
        match pc {
            0x8281EFF8 => {
    //   block [0x8281EFF8..0x8281F170)
	// 8281EFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281EFFC: 48989151  bl 0x831a814c
	ctx.lr = 0x8281F000;
	sub_831A8130(ctx, base);
	// 8281F000: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281F004: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 8281F008: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8281F00C: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 8281F010: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 8281F014: 83B80004  lwz r29, 4(r24)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 8281F018: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 8281F01C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8281F020: 419A0148  beq cr6, 0x8281f168
	if ctx.cr[6].eq {
	pc = 0x8281F168; continue 'dispatch;
	}
	// 8281F024: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281F028: 3EE08208  lis r23, -0x7df8
	ctx.r[23].s64 = -2113404928;
	// 8281F02C: 3B4B9C50  addi r26, r11, -0x63b0
	ctx.r[26].s64 = ctx.r[11].s64 + -25520;
	// 8281F030: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281F034: 8397E28C  lwz r28, -0x1d74(r23)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-7540 as u32) ) } as u64;
	// 8281F038: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8281F03C: 4BFFF5C5  bl 0x8281e600
	ctx.lr = 0x8281F040;
	sub_8281E600(ctx, base);
	// 8281F040: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8281F044: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8281F048: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281F04C: 419A0060  beq cr6, 0x8281f0ac
	if ctx.cr[6].eq {
	pc = 0x8281F0AC; continue 'dispatch;
	}
	// 8281F050: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8281F054: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8281F058: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 8281F05C: 419A0024  beq cr6, 0x8281f080
	if ctx.cr[6].eq {
	pc = 0x8281F080; continue 'dispatch;
	}
	// 8281F060: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 8281F064: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281F068: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281F06C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281F070: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281F074: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281F078: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281F07C: 4082FFE8  bne 0x8281f064
	if !ctx.cr[0].eq {
	pc = 0x8281F064; continue 'dispatch;
	}
	// 8281F080: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8281F084: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281F088: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8281F08C: 38A004C7  li r5, 0x4c7
	ctx.r[5].s64 = 1223;
	// 8281F090: 38790028  addi r3, r25, 0x28
	ctx.r[3].s64 = ctx.r[25].s64 + 40;
	// 8281F094: 48637F55  bl 0x82e56fe8
	ctx.lr = 0x8281F098;
	sub_82E56FE8(ctx, base);
	// 8281F098: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8281F09C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281F0A0: 419A0008  beq cr6, 0x8281f0a8
	if ctx.cr[6].eq {
	pc = 0x8281F0A8; continue 'dispatch;
	}
	// 8281F0A4: 4BAA17ED  bl 0x822c0890
	ctx.lr = 0x8281F0A8;
	sub_822C0890(ctx, base);
	// 8281F0A8: 839F0018  lwz r28, 0x18(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8281F0AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8281F0B0: 419A000C  beq cr6, 0x8281f0bc
	if ctx.cr[6].eq {
	pc = 0x8281F0BC; continue 'dispatch;
	}
	// 8281F0B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281F0B8: 4BAA17D9  bl 0x822c0890
	ctx.lr = 0x8281F0BC;
	sub_822C0890(ctx, base);
	// 8281F0BC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8281F0C0: 4BFFF5B1  bl 0x8281e670
	ctx.lr = 0x8281F0C4;
	sub_8281E670(ctx, base);
	// 8281F0C4: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8281F0C8: 83C1006C  lwz r30, 0x6c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8281F0CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8281F0D0: 419A0060  beq cr6, 0x8281f130
	if ctx.cr[6].eq {
	pc = 0x8281F130; continue 'dispatch;
	}
	// 8281F0D4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8281F0D8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8281F0DC: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 8281F0E0: 419A0024  beq cr6, 0x8281f104
	if ctx.cr[6].eq {
	pc = 0x8281F104; continue 'dispatch;
	}
	// 8281F0E4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 8281F0E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281F0EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281F0F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281F0F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281F0F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281F0FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281F100: 4082FFE8  bne 0x8281f0e8
	if !ctx.cr[0].eq {
	pc = 0x8281F0E8; continue 'dispatch;
	}
	// 8281F104: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8281F108: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281F10C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8281F110: 38A004CD  li r5, 0x4cd
	ctx.r[5].s64 = 1229;
	// 8281F114: 38790028  addi r3, r25, 0x28
	ctx.r[3].s64 = ctx.r[25].s64 + 40;
	// 8281F118: 48637ED1  bl 0x82e56fe8
	ctx.lr = 0x8281F11C;
	sub_82E56FE8(ctx, base);
	// 8281F11C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281F120: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281F124: 419A0008  beq cr6, 0x8281f12c
	if ctx.cr[6].eq {
	pc = 0x8281F12C; continue 'dispatch;
	}
	// 8281F128: 4BAA1769  bl 0x822c0890
	ctx.lr = 0x8281F12C;
	sub_822C0890(ctx, base);
	// 8281F12C: 837F0018  lwz r27, 0x18(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8281F130: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8281F134: 419A000C  beq cr6, 0x8281f140
	if ctx.cr[6].eq {
	pc = 0x8281F140; continue 'dispatch;
	}
	// 8281F138: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281F13C: 4BAA1755  bl 0x822c0890
	ctx.lr = 0x8281F140;
	sub_822C0890(ctx, base);
	// 8281F140: 7F16E000  cmpw cr6, r22, r28
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[28].s32, &mut ctx.xer);
	// 8281F144: 409A0014  bne cr6, 0x8281f158
	if !ctx.cr[6].eq {
	pc = 0x8281F158; continue 'dispatch;
	}
	// 8281F148: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8281F14C: 419A000C  beq cr6, 0x8281f158
	if ctx.cr[6].eq {
	pc = 0x8281F158; continue 'dispatch;
	}
	// 8281F150: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281F154: 91750000  stw r11, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281F158: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 8281F15C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8281F160: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8281F164: 409AFECC  bne cr6, 0x8281f030
	if !ctx.cr[6].eq {
	pc = 0x8281F030; continue 'dispatch;
	}
	// 8281F168: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8281F16C: 48989030  b 0x831a819c
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281F170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281F170 size=220
    let mut pc: u32 = 0x8281F170;
    'dispatch: loop {
        match pc {
            0x8281F170 => {
    //   block [0x8281F170..0x8281F24C)
	// 8281F170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281F174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281F178: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281F17C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281F180: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281F184: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281F188: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8281F18C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8281F190: 396B9DA4  addi r11, r11, -0x625c
	ctx.r[11].s64 = ctx.r[11].s64 + -25180;
	// 8281F194: 807F02D4  lwz r3, 0x2d4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(724 as u32) ) } as u64;
	// 8281F198: 394A9D90  addi r10, r10, -0x6270
	ctx.r[10].s64 = ctx.r[10].s64 + -25200;
	// 8281F19C: 39299D44  addi r9, r9, -0x62bc
	ctx.r[9].s64 = ctx.r[9].s64 + -25276;
	// 8281F1A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281F1A4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8281F1A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281F1AC: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 8281F1B0: 419A0018  beq cr6, 0x8281f1c8
	if ctx.cr[6].eq {
	pc = 0x8281F1C8; continue 'dispatch;
	}
	// 8281F1B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281F1B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8281F1BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281F1C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8281F1C4: 4E800421  bctrl
	ctx.lr = 0x8281F1C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8281F1C8: 387F0284  addi r3, r31, 0x284
	ctx.r[3].s64 = ctx.r[31].s64 + 644;
	// 8281F1CC: 4BC4AE35  bl 0x8246a000
	ctx.lr = 0x8281F1D0;
	sub_8246A000(ctx, base);
	// 8281F1D0: 807F0280  lwz r3, 0x280(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(640 as u32) ) } as u64;
	// 8281F1D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281F1D8: 419A0008  beq cr6, 0x8281f1e0
	if ctx.cr[6].eq {
	pc = 0x8281F1E0; continue 'dispatch;
	}
	// 8281F1DC: 4BAA16B5  bl 0x822c0890
	ctx.lr = 0x8281F1E0;
	sub_822C0890(ctx, base);
	// 8281F1E0: 807F0278  lwz r3, 0x278(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 8281F1E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281F1E8: 419A0008  beq cr6, 0x8281f1f0
	if ctx.cr[6].eq {
	pc = 0x8281F1F0; continue 'dispatch;
	}
	// 8281F1EC: 4BAA16A5  bl 0x822c0890
	ctx.lr = 0x8281F1F0;
	sub_822C0890(ctx, base);
	// 8281F1F0: 807F0270  lwz r3, 0x270(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(624 as u32) ) } as u64;
	// 8281F1F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281F1F8: 419A0008  beq cr6, 0x8281f200
	if ctx.cr[6].eq {
	pc = 0x8281F200; continue 'dispatch;
	}
	// 8281F1FC: 4BAA1695  bl 0x822c0890
	ctx.lr = 0x8281F200;
	sub_822C0890(ctx, base);
	// 8281F200: 807F0268  lwz r3, 0x268(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(616 as u32) ) } as u64;
	// 8281F204: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281F208: 419A0008  beq cr6, 0x8281f210
	if ctx.cr[6].eq {
	pc = 0x8281F210; continue 'dispatch;
	}
	// 8281F20C: 4BAA1685  bl 0x822c0890
	ctx.lr = 0x8281F210;
	sub_822C0890(ctx, base);
	// 8281F210: 807F0260  lwz r3, 0x260(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 8281F214: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281F218: 419A0008  beq cr6, 0x8281f220
	if ctx.cr[6].eq {
	pc = 0x8281F220; continue 'dispatch;
	}
	// 8281F21C: 4BAA1675  bl 0x822c0890
	ctx.lr = 0x8281F220;
	sub_822C0890(ctx, base);
	// 8281F220: 807F0258  lwz r3, 0x258(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 8281F224: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281F228: 419A0008  beq cr6, 0x8281f230
	if ctx.cr[6].eq {
	pc = 0x8281F230; continue 'dispatch;
	}
	// 8281F22C: 4BAA1665  bl 0x822c0890
	ctx.lr = 0x8281F230;
	sub_822C0890(ctx, base);
	// 8281F230: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281F234: 4BFF8C45  bl 0x82817e78
	ctx.lr = 0x8281F238;
	sub_82817E78(ctx, base);
	// 8281F238: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8281F23C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281F240: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281F244: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281F248: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281F250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281F250 size=8
    let mut pc: u32 = 0x8281F250;
    'dispatch: loop {
        match pc {
            0x8281F250 => {
    //   block [0x8281F250..0x8281F258)
	// 8281F250: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 8281F254: 4800040C  b 0x8281f660
	sub_8281F660(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281F258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281F258 size=8
    let mut pc: u32 = 0x8281F258;
    'dispatch: loop {
        match pc {
            0x8281F258 => {
    //   block [0x8281F258..0x8281F260)
	// 8281F258: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8281F25C: 48000404  b 0x8281f660
	sub_8281F660(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281F260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281F260 size=280
    let mut pc: u32 = 0x8281F260;
    'dispatch: loop {
        match pc {
            0x8281F260 => {
    //   block [0x8281F260..0x8281F378)
	// 8281F260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281F264: 48988F01  bl 0x831a8164
	ctx.lr = 0x8281F268;
	sub_831A8130(ctx, base);
	// 8281F268: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281F26C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 8281F270: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281F274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281F278: 386AAE64  addi r3, r10, -0x519c
	ctx.r[3].s64 = ctx.r[10].s64 + -20892;
	// 8281F27C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8281F280: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8281F284: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8281F288: 4BFFCCB1  bl 0x8281bf38
	ctx.lr = 0x8281F28C;
	sub_8281BF38(ctx, base);
	// 8281F28C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 8281F290: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8281F294: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8281F298: 4BFFF2F1  bl 0x8281e588
	ctx.lr = 0x8281F29C;
	sub_8281E588(ctx, base);
	// 8281F29C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281F2A0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8281F2A4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8281F2A8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281F2AC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8281F2B0: 4BAA51B1  bl 0x822c4460
	ctx.lr = 0x8281F2B4;
	sub_822C4460(ctx, base);
	// 8281F2B4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8281F2B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281F2BC: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8281F2C0: 7FAB0034  cntlzw r11, r29
	ctx.r[11].u64 = if ctx.r[29].u32 == 0 { 32 } else { ctx.r[29].u32.leading_zeros() as u64 };
	// 8281F2C4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8281F2C8: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 8281F2CC: 419A0008  beq cr6, 0x8281f2d4
	if ctx.cr[6].eq {
	pc = 0x8281F2D4; continue 'dispatch;
	}
	// 8281F2D0: 4BAA15C1  bl 0x822c0890
	ctx.lr = 0x8281F2D4;
	sub_822C0890(ctx, base);
	// 8281F2D4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281F2D8: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8281F2DC: 41820080  beq 0x8281f35c
	if ctx.cr[0].eq {
	pc = 0x8281F35C; continue 'dispatch;
	}
	// 8281F2E0: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 8281F2E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8281F2E8: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 8281F2EC: 419A0024  beq cr6, 0x8281f310
	if ctx.cr[6].eq {
	pc = 0x8281F310; continue 'dispatch;
	}
	// 8281F2F0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 8281F2F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8281F2F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281F2FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8281F300: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8281F304: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8281F308: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8281F30C: 4082FFE8  bne 0x8281f2f4
	if !ctx.cr[0].eq {
	pc = 0x8281F2F4; continue 'dispatch;
	}
	// 8281F310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281F314: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 8281F318: 4BFF8279  bl 0x82817590
	ctx.lr = 0x8281F31C;
	sub_82817590(ctx, base);
	// 8281F31C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281F320: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8281F324: 388B9C50  addi r4, r11, -0x63b0
	ctx.r[4].s64 = ctx.r[11].s64 + -25520;
	// 8281F328: 38A004B4  li r5, 0x4b4
	ctx.r[5].s64 = 1204;
	// 8281F32C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8281F330: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8281F334: 48637CB5  bl 0x82e56fe8
	ctx.lr = 0x8281F338;
	sub_82E56FE8(ctx, base);
	// 8281F338: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8281F33C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281F340: 419A0008  beq cr6, 0x8281f348
	if ctx.cr[6].eq {
	pc = 0x8281F348; continue 'dispatch;
	}
	// 8281F344: 4BAA154D  bl 0x822c0890
	ctx.lr = 0x8281F348;
	sub_822C0890(ctx, base);
	// 8281F348: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8281F34C: 38BD0018  addi r5, r29, 0x18
	ctx.r[5].s64 = ctx.r[29].s64 + 24;
	// 8281F350: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8281F354: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281F358: 4BFFFCA1  bl 0x8281eff8
	ctx.lr = 0x8281F35C;
	sub_8281EFF8(ctx, base);
	// 8281F35C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8281F360: 419A000C  beq cr6, 0x8281f36c
	if ctx.cr[6].eq {
	pc = 0x8281F36C; continue 'dispatch;
	}
	// 8281F364: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8281F368: 4BAA1529  bl 0x822c0890
	ctx.lr = 0x8281F36C;
	sub_822C0890(ctx, base);
	// 8281F36C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8281F370: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8281F374: 48988E40  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281F378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8281F378 size=740
    let mut pc: u32 = 0x8281F378;
    'dispatch: loop {
        match pc {
            0x8281F378 => {
    //   block [0x8281F378..0x8281F65C)
	// 8281F378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281F37C: 48988DE9  bl 0x831a8164
	ctx.lr = 0x8281F380;
	sub_831A8130(ctx, base);
	// 8281F380: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8281F384: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281F660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281F660 size=76
    let mut pc: u32 = 0x8281F660;
    'dispatch: loop {
        match pc {
            0x8281F660 => {
    //   block [0x8281F660..0x8281F6AC)
	// 8281F660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281F664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281F668: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8281F66C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281F670: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281F674: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281F678: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281F67C: 4BFFFAF5  bl 0x8281f170
	ctx.lr = 0x8281F680;
	sub_8281F170(ctx, base);
	// 8281F680: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281F684: 4182000C  beq 0x8281f690
	if ctx.cr[0].eq {
	pc = 0x8281F690; continue 'dispatch;
	}
	// 8281F688: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281F68C: 485D2D4D  bl 0x82df23d8
	ctx.lr = 0x8281F690;
	sub_82DF23D8(ctx, base);
	// 8281F690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281F694: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8281F698: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8281F69C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8281F6A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8281F6A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8281F6A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281F6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281F6B0 size=128
    let mut pc: u32 = 0x8281F6B0;
    'dispatch: loop {
        match pc {
            0x8281F6B0 => {
    //   block [0x8281F6B0..0x8281F730)
	// 8281F6B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281F6B4: 48988AB9  bl 0x831a816c
	ctx.lr = 0x8281F6B8;
	sub_831A8130(ctx, base);
	// 8281F6B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281F6BC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 8281F6C0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8281F6C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281F6C8: 3BEBAF04  addi r31, r11, -0x50fc
	ctx.r[31].s64 = ctx.r[11].s64 + -20732;
	// 8281F6CC: 816AAF0C  lwz r11, -0x50f4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20724 as u32) ) } as u64;
	// 8281F6D0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8281F6D4: 40820024  bne 0x8281f6f8
	if !ctx.cr[0].eq {
	pc = 0x8281F6F8; continue 'dispatch;
	}
	// 8281F6D8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 8281F6DC: 3D008282  lis r8, -0x7d7e
	ctx.r[8].s64 = -2105409536;
	// 8281F6E0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8281F6E4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 8281F6E8: 3908DF48  addi r8, r8, -0x20b8
	ctx.r[8].s64 = ctx.r[8].s64 + -8376;
	// 8281F6EC: 916AAF0C  stw r11, -0x50f4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-20724 as u32), ctx.r[11].u32 ) };
	// 8281F6F0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8281F6F4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8281F6F8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8281F6FC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8281F700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281F704: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 8281F708: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 8281F70C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8281F710: 4BE34EB1  bl 0x826545c0
	ctx.lr = 0x8281F714;
	sub_826545C0(ctx, base);
	// 8281F714: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281F718: 4182000C  beq 0x8281f724
	if ctx.cr[0].eq {
	pc = 0x8281F724; continue 'dispatch;
	}
	// 8281F71C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8281F720: 48000008  b 0x8281f728
	pc = 0x8281F728; continue 'dispatch;
	// 8281F724: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8281F728: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8281F72C: 48988A90  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281F730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281F730 size=1556
    let mut pc: u32 = 0x8281F730;
    'dispatch: loop {
        match pc {
            0x8281F730 => {
    //   block [0x8281F730..0x8281FD44)
	// 8281F730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281F734: 48988A29  bl 0x831a815c
	ctx.lr = 0x8281F738;
	sub_831A8130(ctx, base);
	// 8281F738: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 8281F73C: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 8281F740: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8281F744: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281F748: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8281F74C: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 8281F750: 4BFFAAE9  bl 0x8281a238
	ctx.lr = 0x8281F754;
	sub_8281A238(ctx, base);
	// 8281F754: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8281F758: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281F75C: 4BFCCE6D  bl 0x827ec5c8
	ctx.lr = 0x8281F760;
	sub_827EC5C8(ctx, base);
	// 8281F760: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8281F764: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8281F768: 419A0058  beq cr6, 0x8281f7c0
	if ctx.cr[6].eq {
	pc = 0x8281F7C0; continue 'dispatch;
	}
	// 8281F76C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281F770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281F774: 388B1EDC  addi r4, r11, 0x1edc
	ctx.r[4].s64 = ctx.r[11].s64 + 7900;
	// 8281F778: 485D4291  bl 0x82df3a08
	ctx.lr = 0x8281F77C;
	sub_82DF3A08(ctx, base);
	// 8281F77C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8281F780: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8281F784: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8281F788: 485F58A9  bl 0x82e15030
	ctx.lr = 0x8281F78C;
	sub_82E15030(ctx, base);
	// 8281F78C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8281F790: 395E025C  addi r10, r30, 0x25c
	ctx.r[10].s64 = ctx.r[30].s64 + 604;
	// 8281F794: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8281F798: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 8281F79C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281F7A0: 917E025C  stw r11, 0x25c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(604 as u32), ctx.r[11].u32 ) };
	// 8281F7A4: 4BAA4CBD  bl 0x822c4460
	ctx.lr = 0x8281F7A8;
	sub_822C4460(ctx, base);
	// 8281F7A8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8281F7AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281F7B0: 419A0008  beq cr6, 0x8281f7b8
	if ctx.cr[6].eq {
	pc = 0x8281F7B8; continue 'dispatch;
	}
	// 8281F7B4: 4BAA10DD  bl 0x822c0890
	ctx.lr = 0x8281F7B8;
	sub_822C0890(ctx, base);
	// 8281F7B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281F7BC: 485D3C6D  bl 0x82df3428
	ctx.lr = 0x8281F7C0;
	sub_82DF3428(ctx, base);
	// 8281F7C0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8281F7C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8281F7C8: 419A0008  beq cr6, 0x8281f7d0
	if ctx.cr[6].eq {
	pc = 0x8281F7D0; continue 'dispatch;
	}
	// 8281F7CC: 4BAA10C5  bl 0x822c0890
	ctx.lr = 0x8281F7D0;
	sub_822C0890(ctx, base);
	// 8281F7D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8281F7D4: 815E025C  lwz r10, 0x25c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(604 as u32) ) } as u64;
	// 8281F7D8: 3BFE025C  addi r31, r30, 0x25c
	ctx.r[31].s64 = ctx.r[30].s64 + 604;
	// 8281F7DC: 3F808332  lis r28, -0x7cce
	ctx.r[28].s64 = -2093875200;
	// 8281F7E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8281F7E4: C3AB08A8  lfs f29, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8281F7E8: 419A00F8  beq cr6, 0x8281f8e0
	if ctx.cr[6].eq {
	pc = 0x8281F8E0; continue 'dispatch;
	}
	// 8281F7EC: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281F7F0: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8281F7F4: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8281F7F8: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 8281F7FC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8281F800: 48680F31  bl 0x82ea0730
	ctx.lr = 0x8281F804;
	sub_82EA0730(ctx, base);
	// 8281F804: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8281F808: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8281F80C: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8281F810: 396BC4C0  addi r11, r11, -0x3b40
	ctx.r[11].s64 = ctx.r[11].s64 + -15168;
	// 8281F814: 394A5930  addi r10, r10, 0x5930
	ctx.r[10].s64 = ctx.r[10].s64 + 22832;
	// 8281F818: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 8281F81C: 390100E0  addi r8, r1, 0xe0
	ctx.r[8].s64 = ctx.r[1].s64 + 224;
	// 8281F820: 38E00060  li r7, 0x60
	ctx.r[7].s64 = 96;
	// 8281F824: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8281F828: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 8281F82C: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8281F830: B0E30004  sth r7, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281FD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281FD48 size=260
    let mut pc: u32 = 0x8281FD48;
    'dispatch: loop {
        match pc {
            0x8281FD48 => {
    //   block [0x8281FD48..0x8281FE4C)
	// 8281FD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281FD4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8281FD50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8281FD54: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 8281FD58: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8281FD5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281FD60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281FD64: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8281FD68: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 8281FD6C: 4BFF827D  bl 0x82817fe8
	ctx.lr = 0x8281FD70;
	sub_82817FE8(ctx, base);
	// 8281FD70: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281FD74: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8281FD78: 396B9DA4  addi r11, r11, -0x625c
	ctx.r[11].s64 = ctx.r[11].s64 + -25180;
	// 8281FD7C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8281FD80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8281FD84: 394A9D90  addi r10, r10, -0x6270
	ctx.r[10].s64 = ctx.r[10].s64 + -25200;
	// 8281FD88: 39299D44  addi r9, r9, -0x62bc
	ctx.r[9].s64 = ctx.r[9].s64 + -25276;
	// 8281FD8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281FD90: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8281FD94: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 8281FD98: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 8281FD9C: 917F0254  stw r11, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[11].u32 ) };
	// 8281FDA0: 392002A0  li r9, 0x2a0
	ctx.r[9].s64 = 672;
	// 8281FDA4: 917F0258  stw r11, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[11].u32 ) };
	// 8281FDA8: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 8281FDAC: 917F025C  stw r11, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[11].u32 ) };
	// 8281FDB0: 3D008336  lis r8, -0x7cca
	ctx.r[8].s64 = -2093613056;
	// 8281FDB4: 917F0260  stw r11, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[11].u32 ) };
	// 8281FDB8: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 8281FDBC: 917F0264  stw r11, 0x264(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(612 as u32), ctx.r[11].u32 ) };
	// 8281FDC0: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 8281FDC4: 917F0268  stw r11, 0x268(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(616 as u32), ctx.r[11].u32 ) };
	// 8281FDC8: 3CA0832B  lis r5, -0x7cd5
	ctx.r[5].s64 = -2094333952;
	// 8281FDCC: 917F026C  stw r11, 0x26c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[11].u32 ) };
	// 8281FDD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281FDD4: 917F0270  stw r11, 0x270(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), ctx.r[11].u32 ) };
	// 8281FDD8: 917F0274  stw r11, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[11].u32 ) };
	// 8281FDDC: C0079B20  lfs f0, -0x64e0(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-25824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8281FDE0: 917F0278  stw r11, 0x278(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), ctx.r[11].u32 ) };
	// 8281FDE4: 917F027C  stw r11, 0x27c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), ctx.r[11].u32 ) };
	// 8281FDE8: 917F0280  stw r11, 0x280(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), ctx.r[11].u32 ) };
	// 8281FDEC: 917F0288  stw r11, 0x288(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), ctx.r[11].u32 ) };
	// 8281FDF0: 917F028C  stw r11, 0x28c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(652 as u32), ctx.r[11].u32 ) };
	// 8281FDF4: 917F0290  stw r11, 0x290(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(656 as u32), ctx.r[11].u32 ) };
	// 8281FDF8: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281FE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8281FE50 size=240
    let mut pc: u32 = 0x8281FE50;
    'dispatch: loop {
        match pc {
            0x8281FE50 => {
    //   block [0x8281FE50..0x8281FF40)
	// 8281FE50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281FE54: 4898830D  bl 0x831a8160
	ctx.lr = 0x8281FE58;
	sub_831A8130(ctx, base);
	// 8281FE58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281FE5C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8281FE60: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8281FE64: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8281FE68: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 8281FE6C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8281FE70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8281FE74: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8281FE78: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8281FE7C: 80AB6768  lwz r5, 0x6768(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26472 as u32) ) } as u64;
	// 8281FE80: 808A6790  lwz r4, 0x6790(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26512 as u32) ) } as u64;
	// 8281FE84: 4BAD791D  bl 0x822f77a0
	ctx.lr = 0x8281FE88;
	sub_822F77A0(ctx, base);
	// 8281FE88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281FE8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8281FE90: 4BAC5031  bl 0x822e4ec0
	ctx.lr = 0x8281FE94;
	sub_822E4EC0(ctx, base);
	// 8281FE94: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8281FE98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281FE9C: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 8281FEA0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8281FEA4: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8281FEA8: 4BC6C3E1  bl 0x8248c288
	ctx.lr = 0x8281FEAC;
	sub_8248C288(ctx, base);
	// 8281FEAC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281FEB0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8281FEB4: 388B9C50  addi r4, r11, -0x63b0
	ctx.r[4].s64 = ctx.r[11].s64 + -25520;
	// 8281FEB8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8281FEBC: 38A000E0  li r5, 0xe0
	ctx.r[5].s64 = 224;
	// 8281FEC0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8281FEC4: 4BAA0515  bl 0x822c03d8
	ctx.lr = 0x8281FEC8;
	sub_822C03D8(ctx, base);
	// 8281FEC8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8281FECC: 41820030  beq 0x8281fefc
	if ctx.cr[0].eq {
	pc = 0x8281FEFC; continue 'dispatch;
	}
	// 8281FED0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8281FED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281FED8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 8281FEDC: 4BCEF63D  bl 0x8250f518
	ctx.lr = 0x8281FEE0;
	sub_8250F518(ctx, base);
	// 8281FEE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8281FEE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8281FEE8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8281FEEC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8281FEF0: 4BC72301  bl 0x824921f0
	ctx.lr = 0x8281FEF4;
	sub_824921F0(ctx, base);
	// 8281FEF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281FEF8: 48000008  b 0x8281ff00
	pc = 0x8281FF00; continue 'dispatch;
	// 8281FEFC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8281FF00: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8281FF04: 3BBA0004  addi r29, r26, 4
	ctx.r[29].s64 = ctx.r[26].s64 + 4;
	// 8281FF08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281FF0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281FF10: 4BAC4DC1  bl 0x822e4cd0
	ctx.lr = 0x8281FF14;
	sub_822E4CD0(ctx, base);
	// 8281FF14: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8281FF18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8281FF1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8281FF20: 4BAA00E1  bl 0x822c0000
	ctx.lr = 0x8281FF24;
	sub_822C0000(ctx, base);
	// 8281FF24: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281FF28: 4182000C  beq 0x8281ff34
	if ctx.cr[0].eq {
	pc = 0x8281FF34; continue 'dispatch;
	}
	// 8281FF2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8281FF30: 485D1D61  bl 0x82df1c90
	ctx.lr = 0x8281FF34;
	sub_82DF1C90(ctx, base);
	// 8281FF34: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8281FF38: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8281FF3C: 48988274  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8281FF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8281FF40 size=636
    let mut pc: u32 = 0x8281FF40;
    'dispatch: loop {
        match pc {
            0x8281FF40 => {
    //   block [0x8281FF40..0x828201BC)
	// 8281FF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8281FF44: 48988219  bl 0x831a815c
	ctx.lr = 0x8281FF48;
	sub_831A8130(ctx, base);
	// 8281FF48: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8281FF4C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8281FF50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8281FF54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8281FF58: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8281FF5C: 93C1011C  stw r30, 0x11c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), ctx.r[30].u32 ) };
	// 8281FF60: 817F0288  lwz r11, 0x288(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(648 as u32) ) } as u64;
	// 8281FF64: 48000014  b 0x8281ff78
	pc = 0x8281FF78; continue 'dispatch;
	// 8281FF68: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8281FF6C: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8281FF70: 419A0244  beq cr6, 0x828201b4
	if ctx.cr[6].eq {
	pc = 0x828201B4; continue 'dispatch;
	}
	// 8281FF74: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8281FF78: 815F028C  lwz r10, 0x28c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(652 as u32) ) } as u64;
	// 8281FF7C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8281FF80: 409AFFE8  bne cr6, 0x8281ff68
	if !ctx.cr[6].eq {
	pc = 0x8281FF68; continue 'dispatch;
	}
	// 8281FF84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8281FF88: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8281FF8C: 4082021C  bne 0x828201a8
	if !ctx.cr[0].eq {
	pc = 0x828201A8; continue 'dispatch;
	}
	// 8281FF90: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8281FF94: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 8281FF98: 392B6910  addi r9, r11, 0x6910
	ctx.r[9].s64 = ctx.r[11].s64 + 26896;
	// 8281FF9C: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 8281FFA0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8281FFA4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8281FFA8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8281FFAC: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8281FFB0: 3B6B9C50  addi r27, r11, -0x63b0
	ctx.r[27].s64 = ctx.r[11].s64 + -25520;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828201C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828201C0 size=80
    let mut pc: u32 = 0x828201C0;
    'dispatch: loop {
        match pc {
            0x828201C0 => {
    //   block [0x828201C0..0x82820210)
	// 828201C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828201C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828201C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828201CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828201D0: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 828201D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828201D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828201DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828201E0: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828201E4: 4BC94FF5  bl 0x824b51d8
	ctx.lr = 0x828201E8;
	sub_824B51D8(ctx, base);
	// 828201E8: 3960000D  li r11, 0xd
	ctx.r[11].s64 = 13;
	// 828201EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828201F0: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828201F4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828201F8: 4BC94FE1  bl 0x824b51d8
	ctx.lr = 0x828201FC;
	sub_824B51D8(ctx, base);
	// 828201FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82820200: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82820204: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82820208: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8282020C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82820210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82820210 size=244
    let mut pc: u32 = 0x82820210;
    'dispatch: loop {
        match pc {
            0x82820210 => {
    //   block [0x82820210..0x82820304)
	// 82820210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82820214: 48987F55  bl 0x831a8168
	ctx.lr = 0x82820218;
	sub_831A8130(ctx, base);
	// 82820218: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8282021C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82820220: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82820224: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82820228: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8282022C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82820230: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82820234: 808B8640  lwz r4, -0x79c0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31168 as u32) ) } as u64;
	// 82820238: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 8282023C: 4BB0C4ED  bl 0x8232c728
	ctx.lr = 0x82820240;
	sub_8232C728(ctx, base);
	// 82820240: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82820244: E86B0000  ld r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82820248: E88B0008  ld r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8282024C: 4BF9A125  bl 0x827ba370
	ctx.lr = 0x82820250;
	sub_827BA370(ctx, base);
	// 82820250: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82820254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820258: 4BF99CE1  bl 0x827b9f38
	ctx.lr = 0x8282025C;
	sub_827B9F38(ctx, base);
	// 8282025C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82820260: 4182003C  beq 0x8282029c
	if ctx.cr[0].eq {
	pc = 0x8282029C; continue 'dispatch;
	}
	// 82820264: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82820268: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282026C: 4BCEF0C5  bl 0x8250f330
	ctx.lr = 0x82820270;
	sub_8250F330(ctx, base);
	// 82820270: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82820274: 4BCC95DD  bl 0x824e9850
	ctx.lr = 0x82820278;
	sub_824E9850(ctx, base);
	// 82820278: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282027C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82820280: 485D1A11  bl 0x82df1c90
	ctx.lr = 0x82820284;
	sub_82DF1C90(ctx, base);
	// 82820284: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82820288: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8282028C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82820290: 4BFFDB61  bl 0x8281ddf0
	ctx.lr = 0x82820294;
	sub_8281DDF0(ctx, base);
	// 82820294: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82820298: 48000058  b 0x828202f0
	pc = 0x828202F0; continue 'dispatch;
	// 8282029C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828202A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828202A4: 808B8654  lwz r4, -0x79ac(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31148 as u32) ) } as u64;
	// 828202A8: 4BB0C481  bl 0x8232c728
	ctx.lr = 0x828202AC;
	sub_8232C728(ctx, base);
	// 828202AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828202B0: E86B0000  ld r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828202B4: E88B0008  ld r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 828202B8: 4BF9A0B9  bl 0x827ba370
	ctx.lr = 0x828202BC;
	sub_827BA370(ctx, base);
	// 828202BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828202C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828202C4: 4BF99C75  bl 0x827b9f38
	ctx.lr = 0x828202C8;
	sub_827B9F38(ctx, base);
	// 828202C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828202CC: 41820020  beq 0x828202ec
	if ctx.cr[0].eq {
	pc = 0x828202EC; continue 'dispatch;
	}
	// 828202D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828202D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828202D8: 4BCEF059  bl 0x8250f330
	ctx.lr = 0x828202DC;
	sub_8250F330(ctx, base);
	// 828202DC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828202E0: 4BCC9571  bl 0x824e9850
	ctx.lr = 0x828202E4;
	sub_824E9850(ctx, base);
	// 828202E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828202E8: 4BFFFF94  b 0x8282027c
	pc = 0x8282027C; continue 'dispatch;
	// 828202EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828202F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828202F4: 4BAD3A7D  bl 0x822f3d70
	ctx.lr = 0x828202F8;
	sub_822F3D70(ctx, base);
	// 828202F8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828202FC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82820300: 48987EB8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82820308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82820308 size=1392
    let mut pc: u32 = 0x82820308;
    'dispatch: loop {
        match pc {
            0x82820308 => {
    //   block [0x82820308..0x82820878)
	// 82820308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282030C: 48987E55  bl 0x831a8160
	ctx.lr = 0x82820310;
	sub_831A8130(ctx, base);
	// 82820310: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82820314: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82820318: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282031C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82820320: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82820324: 4BFF92ED  bl 0x82819610
	ctx.lr = 0x82820328;
	sub_82819610(ctx, base);
	// 82820328: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282032C: 41820540  beq 0x8282086c
	if ctx.cr[0].eq {
	pc = 0x8282086C; continue 'dispatch;
	}
	// 82820330: 817F01DC  lwz r11, 0x1dc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 82820334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82820338: 419A0534  beq cr6, 0x8282086c
	if ctx.cr[6].eq {
	pc = 0x8282086C; continue 'dispatch;
	}
	// 8282033C: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 82820340: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 82820344: 40980528  bge cr6, 0x8282086c
	if !ctx.cr[6].lt {
	pc = 0x8282086C; continue 'dispatch;
	}
	// 82820348: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 8282034C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820350: 917F02B4  stw r11, 0x2b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u32 ) };
	// 82820354: 4BFCB2E5  bl 0x827eb638
	ctx.lr = 0x82820358;
	sub_827EB638(ctx, base);
	// 82820358: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282035C: 48140205  bl 0x82960560
	ctx.lr = 0x82820360;
	sub_82960560(ctx, base);
	// 82820360: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82820364: 41820008  beq 0x8282036c
	if ctx.cr[0].eq {
	pc = 0x8282036C; continue 'dispatch;
	}
	// 82820368: 4BFCE879  bl 0x827eebe0
	ctx.lr = 0x8282036C;
	sub_827EEBE0(ctx, base);
	// 8282036C: 817F01DC  lwz r11, 0x1dc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 82820370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82820374: 419A00EC  beq cr6, 0x82820460
	if ctx.cr[6].eq {
	pc = 0x82820460; continue 'dispatch;
	}
	// 82820378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282037C: 4BFCBE55  bl 0x827ec1d0
	ctx.lr = 0x82820380;
	sub_827EC1D0(ctx, base);
	// 82820380: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82820384: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820388: 839F01DC  lwz r28, 0x1dc(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 8282038C: 481F32F5  bl 0x82a13680
	ctx.lr = 0x82820390;
	sub_82A13680(ctx, base);
	// 82820390: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82820394: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82820398: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282039C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828203A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828203A4: 4E800421  bctrl
	ctx.lr = 0x828203A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828203A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828203AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828203B0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828203B4: 4BAD6F0D  bl 0x822f72c0
	ctx.lr = 0x828203B8;
	sub_822F72C0(ctx, base);
	// 828203B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828203BC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828203C0: 83DF01DC  lwz r30, 0x1dc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 828203C4: 4BCEF155  bl 0x8250f518
	ctx.lr = 0x828203C8;
	sub_8250F518(ctx, base);
	// 828203C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828203CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828203D0: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 828203D4: 409A0008  bne cr6, 0x828203dc
	if !ctx.cr[6].eq {
	pc = 0x828203DC; continue 'dispatch;
	}
	// 828203D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828203DC: 839E0000  lwz r28, 0(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828203E0: 4BD07C61  bl 0x82528040
	ctx.lr = 0x828203E4;
	sub_82528040(ctx, base);
	// 828203E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828203E8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828203EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828203F0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828203F4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828203F8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828203FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82820400: 4E800421  bctrl
	ctx.lr = 0x82820404;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82820404: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82820408: 485D1889  bl 0x82df1c90
	ctx.lr = 0x8282040C;
	sub_82DF1C90(ctx, base);
	// 8282040C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820410: 4BFCBDC1  bl 0x827ec1d0
	ctx.lr = 0x82820414;
	sub_827EC1D0(ctx, base);
	// 82820414: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82820418: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282041C: 839F01DC  lwz r28, 0x1dc(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 82820420: 481F3269  bl 0x82a13688
	ctx.lr = 0x82820424;
	sub_82A13688(ctx, base);
	// 82820424: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82820428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282042C: 481F3255  bl 0x82a13680
	ctx.lr = 0x82820430;
	sub_82A13680(ctx, base);
	// 82820430: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82820434: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82820438: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282043C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82820440: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82820444: 4E800421  bctrl
	ctx.lr = 0x82820448;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82820448: 482C3449  bl 0x82ae3890
	ctx.lr = 0x8282044C;
	sub_82AE3890(ctx, base);
	// 8282044C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82820450: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82820454: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82820458: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8282045C: 4BAD3DFD  bl 0x822f4258
	ctx.lr = 0x82820460;
	sub_822F4258(ctx, base);
	// 82820460: 809F01DC  lwz r4, 0x1dc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 82820464: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82820468: 419A0014  beq cr6, 0x8282047c
	if ctx.cr[6].eq {
	pc = 0x8282047C; continue 'dispatch;
	}
	// 8282046C: 38BD0050  addi r5, r29, 0x50
	ctx.r[5].s64 = ctx.r[29].s64 + 80;
	// 82820470: 80DD0018  lwz r6, 0x18(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82820474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820478: 4BFFFD99  bl 0x82820210
	ctx.lr = 0x8282047C;
	sub_82820210(ctx, base);
	// 8282047C: 3F808336  lis r28, -0x7cca
	ctx.r[28].s64 = -2093613056;
	// 82820480: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82820484: 809C8640  lwz r4, -0x79c0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-31168 as u32) ) } as u64;
	// 82820488: 4BB0C2A1  bl 0x8232c728
	ctx.lr = 0x8282048C;
	sub_8232C728(ctx, base);
	// 8282048C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82820490: E86B0000  ld r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82820494: E88B0008  ld r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82820498: 4BF99ED9  bl 0x827ba370
	ctx.lr = 0x8282049C;
	sub_827BA370(ctx, base);
	// 8282049C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828204A0: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 828204A4: 4BF99A95  bl 0x827b9f38
	ctx.lr = 0x828204A8;
	sub_827B9F38(ctx, base);
	// 828204A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828204AC: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	// 828204B0: 40820094  bne 0x82820544
	if !ctx.cr[0].eq {
	pc = 0x82820544; continue 'dispatch;
	}
	// 828204B4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828204B8: 809E8654  lwz r4, -0x79ac(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-31148 as u32) ) } as u64;
	// 828204BC: 4BB0C26D  bl 0x8232c728
	ctx.lr = 0x828204C0;
	sub_8232C728(ctx, base);
	// 828204C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828204C4: E86B0000  ld r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828204C8: E88B0008  ld r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 828204CC: 4BF99EA5  bl 0x827ba370
	ctx.lr = 0x828204D0;
	sub_827BA370(ctx, base);
	// 828204D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828204D4: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 828204D8: 4BF99A61  bl 0x827b9f38
	ctx.lr = 0x828204DC;
	sub_827B9F38(ctx, base);
	// 828204DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828204E0: 40820064  bne 0x82820544
	if !ctx.cr[0].eq {
	pc = 0x82820544; continue 'dispatch;
	}
	// 828204E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828204E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828204EC: 4BCEEFDD  bl 0x8250f4c8
	ctx.lr = 0x828204F0;
	sub_8250F4C8(ctx, base);
	// 828204F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828204F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828204F8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 828204FC: 409A0008  bne cr6, 0x82820504
	if !ctx.cr[6].eq {
	pc = 0x82820504; continue 'dispatch;
	}
	// 82820500: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82820504: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82820508: 4BCE8511  bl 0x82508a18
	ctx.lr = 0x8282050C;
	sub_82508A18(ctx, base);
	// 8282050C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82820510: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82820514: 487E7C15  bl 0x83008128
	ctx.lr = 0x82820518;
	sub_83008128(ctx, base);
	// 82820518: 7D63D850  subf r11, r3, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[3].s64;
	// 8282051C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82820520: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82820524: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82820528: 697B0001  xori r27, r11, 1
	ctx.r[27].u64 = ctx.r[11].u64 ^ 1;
	// 8282052C: 485D1765  bl 0x82df1c90
	ctx.lr = 0x82820530;
	sub_82DF1C90(ctx, base);
	// 82820530: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82820534: 41820030  beq 0x82820564
	if ctx.cr[0].eq {
	pc = 0x82820564; continue 'dispatch;
	}
	// 82820538: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282053C: 808B8658  lwz r4, -0x79a8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31144 as u32) ) } as u64;
	// 82820540: 48000008  b 0x82820548
	pc = 0x82820548; continue 'dispatch;
	// 82820544: 809C8640  lwz r4, -0x79c0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-31168 as u32) ) } as u64;
	// 82820548: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8282054C: 4BB0C1DD  bl 0x8232c728
	ctx.lr = 0x82820550;
	sub_8232C728(ctx, base);
	// 82820550: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82820554: E88B0008  ld r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82820558: E86B0000  ld r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8282055C: 4BF99E15  bl 0x827ba370
	ctx.lr = 0x82820560;
	sub_827BA370(ctx, base);
	// 82820560: 907F02BC  stw r3, 0x2bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(700 as u32), ctx.r[3].u32 ) };
	// 82820564: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82820568: 809E8654  lwz r4, -0x79ac(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-31148 as u32) ) } as u64;
	// 8282056C: 4BB0C1BD  bl 0x8232c728
	ctx.lr = 0x82820570;
	sub_8232C728(ctx, base);
	// 82820570: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82820574: E86B0000  ld r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82820578: E88B0008  ld r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8282057C: 4BF99DF5  bl 0x827ba370
	ctx.lr = 0x82820580;
	sub_827BA370(ctx, base);
	// 82820580: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82820584: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82820588: 4BF999B1  bl 0x827b9f38
	ctx.lr = 0x8282058C;
	sub_827B9F38(ctx, base);
	// 8282058C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82820590: 418200E4  beq 0x82820674
	if ctx.cr[0].eq {
	pc = 0x82820674; continue 'dispatch;
	}
	// 82820594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820598: 481F30E9  bl 0x82a13680
	ctx.lr = 0x8282059C;
	sub_82A13680(ctx, base);
	// 8282059C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828205A0: C1BD0054  lfs f13, 0x54(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828205A4: C00B9534  lfs f0, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828205A8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828205AC: 40980024  bge cr6, 0x828205d0
	if !ctx.cr[6].lt {
	pc = 0x828205D0; continue 'dispatch;
	}
	// 828205B0: C01D0034  lfs f0, 0x34(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828205B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828205B8: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828205BC: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828205C0: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828205C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828205C8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828205CC: 41990008  bgt cr6, 0x828205d4
	if ctx.cr[6].gt {
	pc = 0x828205D4; continue 'dispatch;
	}
	// 828205D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828205D4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828205D8: 4182009C  beq 0x82820674
	if ctx.cr[0].eq {
	pc = 0x82820674; continue 'dispatch;
	}
	// 828205DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828205E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828205E4: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828205E8: D3FF02C4  stfs f31, 0x2c4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(708 as u32), tmp.u32 ) };
	// 828205EC: 487E7B3D  bl 0x83008128
	ctx.lr = 0x828205F0;
	sub_83008128(ctx, base);
	// 828205F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828205F4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828205F8: 4BFFDF11  bl 0x8281e508
	ctx.lr = 0x828205FC;
	sub_8281E508(ctx, base);
	// 828205FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82820600: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82820604: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82820608: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282060C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82820610: 419A0024  beq cr6, 0x82820634
	if ctx.cr[6].eq {
	pc = 0x82820634; continue 'dispatch;
	}
	// 82820614: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82820618: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8282061C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82820620: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82820624: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82820628: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8282062C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82820630: 4082FFE8  bne 0x82820618
	if !ctx.cr[0].eq {
	pc = 0x82820618; continue 'dispatch;
	}
	// 82820634: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82820638: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8282063C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82820640: 388B9C50  addi r4, r11, -0x63b0
	ctx.r[4].s64 = ctx.r[11].s64 + -25520;
	// 82820644: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82820648: 38A0044C  li r5, 0x44c
	ctx.r[5].s64 = 1100;
	// 8282064C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82820650: 486383F1  bl 0x82e58a40
	ctx.lr = 0x82820654;
	sub_82E58A40(ctx, base);
	// 82820654: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82820658: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282065C: 419A0008  beq cr6, 0x82820664
	if ctx.cr[6].eq {
	pc = 0x82820664; continue 'dispatch;
	}
	// 82820660: 4BAA0231  bl 0x822c0890
	ctx.lr = 0x82820664;
	sub_822C0890(ctx, base);
	// 82820664: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82820668: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282066C: 419A0008  beq cr6, 0x82820674
	if ctx.cr[6].eq {
	pc = 0x82820674; continue 'dispatch;
	}
	// 82820670: 4BAA0221  bl 0x822c0890
	ctx.lr = 0x82820674;
	sub_822C0890(ctx, base);
	// 82820674: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82820678: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8282067C: 4BCEEE4D  bl 0x8250f4c8
	ctx.lr = 0x82820680;
	sub_8250F4C8(ctx, base);
	// 82820680: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82820684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82820688: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8282068C: 409A0008  bne cr6, 0x82820694
	if !ctx.cr[6].eq {
	pc = 0x82820694; continue 'dispatch;
	}
	// 82820690: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82820694: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82820698: 4BCE8381  bl 0x82508a18
	ctx.lr = 0x8282069C;
	sub_82508A18(ctx, base);
	// 8282069C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828206A0: 4BFFE8B9  bl 0x8281ef58
	ctx.lr = 0x828206A4;
	sub_8281EF58(ctx, base);
	// 828206A4: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 828206A8: 409A0038  bne cr6, 0x828206e0
	if !ctx.cr[6].eq {
	pc = 0x828206E0; continue 'dispatch;
	}
	// 828206AC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828206B0: 809C8640  lwz r4, -0x79c0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-31168 as u32) ) } as u64;
	// 828206B4: 4BB0C075  bl 0x8232c728
	ctx.lr = 0x828206B8;
	sub_8232C728(ctx, base);
	// 828206B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828206BC: E86B0000  ld r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828206C0: E88B0008  ld r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 828206C4: 4BF99CAD  bl 0x827ba370
	ctx.lr = 0x828206C8;
	sub_827BA370(ctx, base);
	// 828206C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828206CC: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 828206D0: 4BF99869  bl 0x827b9f38
	ctx.lr = 0x828206D4;
	sub_827B9F38(ctx, base);
	// 828206D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828206D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828206DC: 40820008  bne 0x828206e4
	if !ctx.cr[0].eq {
	pc = 0x828206E4; continue 'dispatch;
	}
	// 828206E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828206E4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828206E8: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828206EC: 485D15A5  bl 0x82df1c90
	ctx.lr = 0x828206F0;
	sub_82DF1C90(ctx, base);
	// 828206F0: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828206F4: 418200D8  beq 0x828207cc
	if ctx.cr[0].eq {
	pc = 0x828207CC; continue 'dispatch;
	}
	// 828206F8: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82820878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82820878 size=668
    let mut pc: u32 = 0x82820878;
    'dispatch: loop {
        match pc {
            0x82820878 => {
    //   block [0x82820878..0x82820B14)
	// 82820878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282087C: 489878ED  bl 0x831a8168
	ctx.lr = 0x82820880;
	sub_831A8130(ctx, base);
	// 82820880: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82820884: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82820888: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8282088C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82820890: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82820894: 41820038  beq 0x828208cc
	if ctx.cr[0].eq {
	pc = 0x828208CC; continue 'dispatch;
	}
	// 82820898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282089C: 489890ED  bl 0x831a9988
	ctx.lr = 0x828208A0;
	sub_831A9988(ctx, base);
	// 828208A0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828208A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828208A8: 386BDBD4  addi r3, r11, -0x242c
	ctx.r[3].s64 = ctx.r[11].s64 + -9260;
	// 828208AC: 4898784D  bl 0x831a80f8
	ctx.lr = 0x828208B0;
	sub_831A80F8(ctx, base);
	// 828208B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828208B4: 41820018  beq 0x828208cc
	if ctx.cr[0].eq {
	pc = 0x828208CC; continue 'dispatch;
	}
	// 828208B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828208BC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828208C0: 4BFFB9C1  bl 0x8281c280
	ctx.lr = 0x828208C4;
	sub_8281C280(ctx, base);
	// 828208C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828208C8: 48000244  b 0x82820b0c
	pc = 0x82820B0C; continue 'dispatch;
	// 828208CC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828208D0: 419A022C  beq cr6, 0x82820afc
	if ctx.cr[6].eq {
	pc = 0x82820AFC; continue 'dispatch;
	}
	// 828208D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828208D8: 489890B1  bl 0x831a9988
	ctx.lr = 0x828208DC;
	sub_831A9988(ctx, base);
	// 828208DC: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 828208E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828208E4: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 828208E8: 48987811  bl 0x831a80f8
	ctx.lr = 0x828208EC;
	sub_831A80F8(ctx, base);
	// 828208EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828208F0: 41820014  beq 0x82820904
	if ctx.cr[0].eq {
	pc = 0x82820904; continue 'dispatch;
	}
	// 828208F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828208F8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828208FC: 4BFFFA0D  bl 0x82820308
	ctx.lr = 0x82820900;
	sub_82820308(ctx, base);
	// 82820900: 4BFFFFC4  b 0x828208c4
	pc = 0x828208C4; continue 'dispatch;
	// 82820904: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82820908: 419A01F4  beq cr6, 0x82820afc
	if ctx.cr[6].eq {
	pc = 0x82820AFC; continue 'dispatch;
	}
	// 8282090C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820910: 48989079  bl 0x831a9988
	ctx.lr = 0x82820914;
	sub_831A9988(ctx, base);
	// 82820914: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82820918: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282091C: 386BC8E4  addi r3, r11, -0x371c
	ctx.r[3].s64 = ctx.r[11].s64 + -14108;
	// 82820920: 489877D9  bl 0x831a80f8
	ctx.lr = 0x82820924;
	sub_831A80F8(ctx, base);
	// 82820924: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82820928: 41820014  beq 0x8282093c
	if ctx.cr[0].eq {
	pc = 0x8282093C; continue 'dispatch;
	}
	// 8282092C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82820930: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82820934: 4BFFE53D  bl 0x8281ee70
	ctx.lr = 0x82820938;
	sub_8281EE70(ctx, base);
	// 82820938: 4BFFFF8C  b 0x828208c4
	pc = 0x828208C4; continue 'dispatch;
	// 8282093C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82820940: 419A01BC  beq cr6, 0x82820afc
	if ctx.cr[6].eq {
	pc = 0x82820AFC; continue 'dispatch;
	}
	// 82820944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820948: 48989041  bl 0x831a9988
	ctx.lr = 0x8282094C;
	sub_831A9988(ctx, base);
	// 8282094C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82820950: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82820954: 386B59D8  addi r3, r11, 0x59d8
	ctx.r[3].s64 = ctx.r[11].s64 + 23000;
	// 82820958: 489877A1  bl 0x831a80f8
	ctx.lr = 0x8282095C;
	sub_831A80F8(ctx, base);
	// 8282095C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82820960: 41820014  beq 0x82820974
	if ctx.cr[0].eq {
	pc = 0x82820974; continue 'dispatch;
	}
	// 82820964: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82820968: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8282096C: 4BFFB8FD  bl 0x8281c268
	ctx.lr = 0x82820970;
	sub_8281C268(ctx, base);
	// 82820970: 4800019C  b 0x82820b0c
	pc = 0x82820B0C; continue 'dispatch;
	// 82820974: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82820978: 419A0184  beq cr6, 0x82820afc
	if ctx.cr[6].eq {
	pc = 0x82820AFC; continue 'dispatch;
	}
	// 8282097C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820980: 48989009  bl 0x831a9988
	ctx.lr = 0x82820984;
	sub_831A9988(ctx, base);
	// 82820984: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82820988: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282098C: 386BCAE8  addi r3, r11, -0x3518
	ctx.r[3].s64 = ctx.r[11].s64 + -13592;
	// 82820990: 48987769  bl 0x831a80f8
	ctx.lr = 0x82820994;
	sub_831A80F8(ctx, base);
	// 82820994: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82820998: 41820014  beq 0x828209ac
	if ctx.cr[0].eq {
	pc = 0x828209AC; continue 'dispatch;
	}
	// 8282099C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828209A0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828209A4: 4BFFBF6D  bl 0x8281c910
	ctx.lr = 0x828209A8;
	sub_8281C910(ctx, base);
	// 828209A8: 4BFFFF1C  b 0x828208c4
	pc = 0x828208C4; continue 'dispatch;
	// 828209AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828209B0: 419A014C  beq cr6, 0x82820afc
	if ctx.cr[6].eq {
	pc = 0x82820AFC; continue 'dispatch;
	}
	// 828209B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828209B8: 48988FD1  bl 0x831a9988
	ctx.lr = 0x828209BC;
	sub_831A9988(ctx, base);
	// 828209BC: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 828209C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828209C4: 386BD9D8  addi r3, r11, -0x2628
	ctx.r[3].s64 = ctx.r[11].s64 + -9768;
	// 828209C8: 48987731  bl 0x831a80f8
	ctx.lr = 0x828209CC;
	sub_831A80F8(ctx, base);
	// 828209CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828209D0: 41820014  beq 0x828209e4
	if ctx.cr[0].eq {
	pc = 0x828209E4; continue 'dispatch;
	}
	// 828209D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828209D8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828209DC: 4BFFB7AD  bl 0x8281c188
	ctx.lr = 0x828209E0;
	sub_8281C188(ctx, base);
	// 828209E0: 4BFFFEE4  b 0x828208c4
	pc = 0x828208C4; continue 'dispatch;
	// 828209E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828209E8: 419A0114  beq cr6, 0x82820afc
	if ctx.cr[6].eq {
	pc = 0x82820AFC; continue 'dispatch;
	}
	// 828209EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828209F0: 48988F99  bl 0x831a9988
	ctx.lr = 0x828209F4;
	sub_831A9988(ctx, base);
	// 828209F4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828209F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828209FC: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 82820A00: 489876F9  bl 0x831a80f8
	ctx.lr = 0x82820A04;
	sub_831A80F8(ctx, base);
	// 82820A04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82820A08: 41820014  beq 0x82820a1c
	if ctx.cr[0].eq {
	pc = 0x82820A1C; continue 'dispatch;
	}
	// 82820A0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82820A10: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82820A14: 4BFFF7AD  bl 0x828201c0
	ctx.lr = 0x82820A18;
	sub_828201C0(ctx, base);
	// 82820A18: 4BFFFEAC  b 0x828208c4
	pc = 0x828208C4; continue 'dispatch;
	// 82820A1C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82820A20: 419A00DC  beq cr6, 0x82820afc
	if ctx.cr[6].eq {
	pc = 0x82820AFC; continue 'dispatch;
	}
	// 82820A24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820A28: 48988F61  bl 0x831a9988
	ctx.lr = 0x82820A2C;
	sub_831A9988(ctx, base);
	// 82820A2C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82820A30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82820A34: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 82820A38: 489876C1  bl 0x831a80f8
	ctx.lr = 0x82820A3C;
	sub_831A80F8(ctx, base);
	// 82820A3C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82820A40: 41820014  beq 0x82820a54
	if ctx.cr[0].eq {
	pc = 0x82820A54; continue 'dispatch;
	}
	// 82820A44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82820A48: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82820A4C: 4BFFB75D  bl 0x8281c1a8
	ctx.lr = 0x82820A50;
	sub_8281C1A8(ctx, base);
	// 82820A50: 4BFFFE74  b 0x828208c4
	pc = 0x828208C4; continue 'dispatch;
	// 82820A54: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82820A58: 419A00A4  beq cr6, 0x82820afc
	if ctx.cr[6].eq {
	pc = 0x82820AFC; continue 'dispatch;
	}
	// 82820A5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820A60: 48988F29  bl 0x831a9988
	ctx.lr = 0x82820A64;
	sub_831A9988(ctx, base);
	// 82820A64: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82820A68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82820A6C: 386BFC14  addi r3, r11, -0x3ec
	ctx.r[3].s64 = ctx.r[11].s64 + -1004;
	// 82820A70: 48987689  bl 0x831a80f8
	ctx.lr = 0x82820A74;
	sub_831A80F8(ctx, base);
	// 82820A74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82820A78: 41820014  beq 0x82820a8c
	if ctx.cr[0].eq {
	pc = 0x82820A8C; continue 'dispatch;
	}
	// 82820A7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82820A80: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82820A84: 4BFFB8E5  bl 0x8281c368
	ctx.lr = 0x82820A88;
	sub_8281C368(ctx, base);
	// 82820A88: 4BFFFE3C  b 0x828208c4
	pc = 0x828208C4; continue 'dispatch;
	// 82820A8C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82820A90: 419A006C  beq cr6, 0x82820afc
	if ctx.cr[6].eq {
	pc = 0x82820AFC; continue 'dispatch;
	}
	// 82820A94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820A98: 48988EF1  bl 0x831a9988
	ctx.lr = 0x82820A9C;
	sub_831A9988(ctx, base);
	// 82820A9C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82820AA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82820AA4: 386B5CA0  addi r3, r11, 0x5ca0
	ctx.r[3].s64 = ctx.r[11].s64 + 23712;
	// 82820AA8: 48987651  bl 0x831a80f8
	ctx.lr = 0x82820AAC;
	sub_831A80F8(ctx, base);
	// 82820AAC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82820AB0: 41820014  beq 0x82820ac4
	if ctx.cr[0].eq {
	pc = 0x82820AC4; continue 'dispatch;
	}
	// 82820AB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82820AB8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82820ABC: 4BFFB7FD  bl 0x8281c2b8
	ctx.lr = 0x82820AC0;
	sub_8281C2B8(ctx, base);
	// 82820AC0: 4BFFFE04  b 0x828208c4
	pc = 0x828208C4; continue 'dispatch;
	// 82820AC4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82820AC8: 419A0034  beq cr6, 0x82820afc
	if ctx.cr[6].eq {
	pc = 0x82820AFC; continue 'dispatch;
	}
	// 82820ACC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820AD0: 48988EB9  bl 0x831a9988
	ctx.lr = 0x82820AD4;
	sub_831A9988(ctx, base);
	// 82820AD4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82820AD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82820ADC: 386B5CC8  addi r3, r11, 0x5cc8
	ctx.r[3].s64 = ctx.r[11].s64 + 23752;
	// 82820AE0: 48987619  bl 0x831a80f8
	ctx.lr = 0x82820AE4;
	sub_831A80F8(ctx, base);
	// 82820AE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82820AE8: 41820014  beq 0x82820afc
	if ctx.cr[0].eq {
	pc = 0x82820AFC; continue 'dispatch;
	}
	// 82820AEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82820AF0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82820AF4: 4BFFB81D  bl 0x8281c310
	ctx.lr = 0x82820AF8;
	sub_8281C310(ctx, base);
	// 82820AF8: 4BFFFDCC  b 0x828208c4
	pc = 0x828208C4; continue 'dispatch;
	// 82820AFC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82820B00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82820B04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82820B08: 4BFF8D29  bl 0x82819830
	ctx.lr = 0x82820B0C;
	sub_82819830(ctx, base);
	// 82820B0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82820B10: 489876A8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82820B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82820B18 size=284
    let mut pc: u32 = 0x82820B18;
    'dispatch: loop {
        match pc {
            0x82820B18 => {
    //   block [0x82820B18..0x82820C34)
	// 82820B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82820B1C: 48987651  bl 0x831a816c
	ctx.lr = 0x82820B20;
	sub_831A8130(ctx, base);
	// 82820B20: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82820B24: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82820B28: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82820B2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82820B30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82820B34: 4BACF6A5  bl 0x822f01d8
	ctx.lr = 0x82820B38;
	sub_822F01D8(ctx, base);
	// 82820B38: 809E026C  lwz r4, 0x26c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(620 as u32) ) } as u64;
	// 82820B3C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82820B40: 419A0060  beq cr6, 0x82820ba0
	if ctx.cr[6].eq {
	pc = 0x82820BA0; continue 'dispatch;
	}
	// 82820B44: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82820B48: 4BC71459  bl 0x82491fa0
	ctx.lr = 0x82820B4C;
	sub_82491FA0(ctx, base);
	// 82820B4C: C01F0030  lfs f0, 0x30(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82820B50: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82820B54: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82820B58: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82820B5C: C17F003C  lfs f11, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82820B60: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82820B64: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82820B68: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82820B6C: D161007C  stfs f11, 0x7c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82820B70: 83BE026C  lwz r29, 0x26c(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(620 as u32) ) } as u64;
	// 82820B74: 487E8445  bl 0x83008fb8
	ctx.lr = 0x82820B78;
	sub_83008FB8(ctx, base);
	// 82820B78: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82820B7C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82820B80: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82820B84: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82820B88: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82820B8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82820B90: 4BC713D1  bl 0x82491f60
	ctx.lr = 0x82820B94;
	sub_82491F60(ctx, base);
	// 82820B94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82820B98: 807E026C  lwz r3, 0x26c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(620 as u32) ) } as u64;
	// 82820B9C: 4BC713F5  bl 0x82491f90
	ctx.lr = 0x82820BA0;
	sub_82491F90(ctx, base);
	// 82820BA0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82820BA4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82820BA8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82820BAC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82820BB0: 419A0070  beq cr6, 0x82820c20
	if ctx.cr[6].eq {
	pc = 0x82820C20; continue 'dispatch;
	}
	// 82820BB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82820BB8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82820BBC: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82820BC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82820BC4: 419A0044  beq cr6, 0x82820c08
	if ctx.cr[6].eq {
	pc = 0x82820C08; continue 'dispatch;
	}
	// 82820BC8: 4BFB9409  bl 0x827d9fd0
	ctx.lr = 0x82820BCC;
	sub_827D9FD0(ctx, base);
	// 82820BCC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82820BD0: 41820038  beq 0x82820c08
	if ctx.cr[0].eq {
	pc = 0x82820C08; continue 'dispatch;
	}
	// 82820BD4: C01F0020  lfs f0, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82820BD8: 3BA10080  addi r29, r1, 0x80
	ctx.r[29].s64 = ctx.r[1].s64 + 128;
	// 82820BDC: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82820BE0: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82820BE4: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82820BE8: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82820BEC: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82820BF0: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82820BF4: 487E83C5  bl 0x83008fb8
	ctx.lr = 0x82820BF8;
	sub_83008FB8(ctx, base);
	// 82820BF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82820BFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82820C00: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82820C04: 4BFFF33D  bl 0x8281ff40
	ctx.lr = 0x82820C08;
	sub_8281FF40(ctx, base);
	// 82820C08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82820C0C: 4BCC85ED  bl 0x824e91f8
	ctx.lr = 0x82820C10;
	sub_824E91F8(ctx, base);
	// 82820C10: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82820C14: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82820C18: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82820C1C: 409AFFA0  bne cr6, 0x82820bbc
	if !ctx.cr[6].eq {
	pc = 0x82820BBC; continue 'dispatch;
	}
	// 82820C20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82820C24: 4BACFDF5  bl 0x822f0a18
	ctx.lr = 0x82820C28;
	sub_822F0A18(ctx, base);
	// 82820C28: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82820C2C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82820C30: 4898758C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82820C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82820C38 size=492
    let mut pc: u32 = 0x82820C38;
    'dispatch: loop {
        match pc {
            0x82820C38 => {
    //   block [0x82820C38..0x82820E24)
	// 82820C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82820C3C: 4898752D  bl 0x831a8168
	ctx.lr = 0x82820C40;
	sub_831A8130(ctx, base);
	// 82820C40: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82820C44: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82820C48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82820C4C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82820C50: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 82820C54: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 82820C58: 419801B4  blt cr6, 0x82820e0c
	if ctx.cr[6].lt {
	pc = 0x82820E0C; continue 'dispatch;
	}
	// 82820C5C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82820C60: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82820C64: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 82820C68: 388ABA80  addi r4, r10, -0x4580
	ctx.r[4].s64 = ctx.r[10].s64 + -17792;
	// 82820C6C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82820C70: 4BAE6B09  bl 0x82307778
	ctx.lr = 0x82820C74;
	sub_82307778(ctx, base);
	// 82820C74: 807F025C  lwz r3, 0x25c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 82820C78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82820C7C: 419A0088  beq cr6, 0x82820d04
	if ctx.cr[6].eq {
	pc = 0x82820D04; continue 'dispatch;
	}
	// 82820C80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82820C84: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82820C88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82820C8C: 4E800421  bctrl
	ctx.lr = 0x82820C90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82820C90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82820C94: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82820C98: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82820C9C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82820CA0: C01E0030  lfs f0, 0x30(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82820CA4: C1BE0034  lfs f13, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82820CA8: C19E0038  lfs f12, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82820CAC: C17E003C  lfs f11, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82820CB0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82820CB4: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82820CB8: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82820CBC: D161006C  stfs f11, 0x6c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82820CC0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82820E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82820E28 size=92
    let mut pc: u32 = 0x82820E28;
    'dispatch: loop {
        match pc {
            0x82820E28 => {
    //   block [0x82820E28..0x82820E84)
	// 82820E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82820E2C: 4898733D  bl 0x831a8168
	ctx.lr = 0x82820E30;
	sub_831A8130(ctx, base);
	// 82820E30: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82820E34: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82820E38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82820E3C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82820E40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82820E44: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82820E48: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82820E4C: 485D2DB5  bl 0x82df3c00
	ctx.lr = 0x82820E50;
	sub_82DF3C00(ctx, base);
	// 82820E50: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82820E54: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82820E58: 485D2DA9  bl 0x82df3c00
	ctx.lr = 0x82820E5C;
	sub_82DF3C00(ctx, base);
	// 82820E5C: D3FF0008  stfs f31, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82820E60: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82820E64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82820E68: 485D25C1  bl 0x82df3428
	ctx.lr = 0x82820E6C;
	sub_82DF3428(ctx, base);
	// 82820E6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82820E70: 485D25B9  bl 0x82df3428
	ctx.lr = 0x82820E74;
	sub_82DF3428(ctx, base);
	// 82820E74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820E78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82820E7C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82820E80: 48987338  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82820E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82820E88 size=84
    let mut pc: u32 = 0x82820E88;
    'dispatch: loop {
        match pc {
            0x82820E88 => {
    //   block [0x82820E88..0x82820EDC)
	// 82820E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82820E8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82820E90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82820E94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82820E98: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82820E9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82820EA0: 388BAF2C  addi r4, r11, -0x50d4
	ctx.r[4].s64 = ctx.r[11].s64 + -20692;
	// 82820EA4: 4BFCF985  bl 0x827f0828
	ctx.lr = 0x82820EA8;
	sub_827F0828(ctx, base);
	// 82820EA8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82820EAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820EB0: 388BAF48  addi r4, r11, -0x50b8
	ctx.r[4].s64 = ctx.r[11].s64 + -20664;
	// 82820EB4: 4BFD523D  bl 0x827f60f0
	ctx.lr = 0x82820EB8;
	sub_827F60F0(ctx, base);
	// 82820EB8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82820EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82820EC0: 388BAF58  addi r4, r11, -0x50a8
	ctx.r[4].s64 = ctx.r[11].s64 + -20648;
	// 82820EC4: 4BFCFC05  bl 0x827f0ac8
	ctx.lr = 0x82820EC8;
	sub_827F0AC8(ctx, base);
	// 82820EC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82820ECC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82820ED0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82820ED4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82820ED8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82820EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82820EE0 size=440
    let mut pc: u32 = 0x82820EE0;
    'dispatch: loop {
        match pc {
            0x82820EE0 => {
    //   block [0x82820EE0..0x82821098)
	// 82820EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82820EE4: 48987289  bl 0x831a816c
	ctx.lr = 0x82820EE8;
	sub_831A8130(ctx, base);
	// 82820EE8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82820EEC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82820EF0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82820EF4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82820EF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82820EFC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82820F00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82820F04: 388B9F1C  addi r4, r11, -0x60e4
	ctx.r[4].s64 = ctx.r[11].s64 + -24804;
	// 82820F08: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82820F0C: 485D2AFD  bl 0x82df3a08
	ctx.lr = 0x82820F10;
	sub_82DF3A08(ctx, base);
	// 82820F10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82820F14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82820F18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82820F1C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82820F20: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82820F24: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82820F28: 4BFCAD91  bl 0x827ebcb8
	ctx.lr = 0x82820F2C;
	sub_827EBCB8(ctx, base);
	// 82820F2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82820F30: 485D24F9  bl 0x82df3428
	ctx.lr = 0x82820F34;
	sub_82DF3428(ctx, base);
	// 82820F34: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82820F38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82820F3C: 388B9F10  addi r4, r11, -0x60f0
	ctx.r[4].s64 = ctx.r[11].s64 + -24816;
	// 82820F40: 485D2AC9  bl 0x82df3a08
	ctx.lr = 0x82820F44;
	sub_82DF3A08(ctx, base);
	// 82820F44: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82820F48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82820F4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82820F50: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82820F54: C3CBC664  lfs f30, -0x399c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82820F58: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82820F5C: 4BFCAD5D  bl 0x827ebcb8
	ctx.lr = 0x82820F60;
	sub_827EBCB8(ctx, base);
	// 82820F60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82820F64: 485D24C5  bl 0x82df3428
	ctx.lr = 0x82820F68;
	sub_82DF3428(ctx, base);
	// 82820F68: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82820F6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82820F70: 388B9F00  addi r4, r11, -0x6100
	ctx.r[4].s64 = ctx.r[11].s64 + -24832;
	// 82820F74: 485D2A95  bl 0x82df3a08
	ctx.lr = 0x82820F78;
	sub_82DF3A08(ctx, base);
	// 82820F78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82820F7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82820F80: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82820F84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82820F88: 4BFCAD31  bl 0x827ebcb8
	ctx.lr = 0x82820F8C;
	sub_827EBCB8(ctx, base);
	// 82820F8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82820F90: 485D2499  bl 0x82df3428
	ctx.lr = 0x82820F94;
	sub_82DF3428(ctx, base);
	// 82820F94: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82820F98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82820F9C: 388B9EF4  addi r4, r11, -0x610c
	ctx.r[4].s64 = ctx.r[11].s64 + -24844;
	// 82820FA0: 485D2A69  bl 0x82df3a08
	ctx.lr = 0x82820FA4;
	sub_82DF3A08(ctx, base);
	// 82820FA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82820FA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82820FAC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82820FB0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82820FB4: 4BFCAD05  bl 0x827ebcb8
	ctx.lr = 0x82820FB8;
	sub_827EBCB8(ctx, base);
	// 82820FB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82820FBC: 485D246D  bl 0x82df3428
	ctx.lr = 0x82820FC0;
	sub_82DF3428(ctx, base);
	// 82820FC0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82820FC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82820FC8: 388B9EE4  addi r4, r11, -0x611c
	ctx.r[4].s64 = ctx.r[11].s64 + -24860;
	// 82820FCC: 485D2A3D  bl 0x82df3a08
	ctx.lr = 0x82820FD0;
	sub_82DF3A08(ctx, base);
	// 82820FD0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82820FD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82820FD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82820FDC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82820FE0: C3CBACFC  lfs f30, -0x5304(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82820FE4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82820FE8: 4BFCACD1  bl 0x827ebcb8
	ctx.lr = 0x82820FEC;
	sub_827EBCB8(ctx, base);
	// 82820FEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82820FF0: 485D2439  bl 0x82df3428
	ctx.lr = 0x82820FF4;
	sub_82DF3428(ctx, base);
	// 82820FF4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82820FF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82820FFC: 388B9ED4  addi r4, r11, -0x612c
	ctx.r[4].s64 = ctx.r[11].s64 + -24876;
	// 82821000: 485D2A09  bl 0x82df3a08
	ctx.lr = 0x82821004;
	sub_82DF3A08(ctx, base);
	// 82821004: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82821008: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282100C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82821010: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82821014: 4BFCACA5  bl 0x827ebcb8
	ctx.lr = 0x82821018;
	sub_827EBCB8(ctx, base);
	// 82821018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282101C: 485D240D  bl 0x82df3428
	ctx.lr = 0x82821020;
	sub_82DF3428(ctx, base);
	// 82821020: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82821024: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821028: 388B9EC4  addi r4, r11, -0x613c
	ctx.r[4].s64 = ctx.r[11].s64 + -24892;
	// 8282102C: 485D29DD  bl 0x82df3a08
	ctx.lr = 0x82821030;
	sub_82DF3A08(ctx, base);
	// 82821030: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82821034: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82821038: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282103C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82821040: 4BFCAD41  bl 0x827ebd80
	ctx.lr = 0x82821044;
	sub_827EBD80(ctx, base);
	// 82821044: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821048: 485D23E1  bl 0x82df3428
	ctx.lr = 0x8282104C;
	sub_82DF3428(ctx, base);
	// 8282104C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82821050: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821054: 388B9EB4  addi r4, r11, -0x614c
	ctx.r[4].s64 = ctx.r[11].s64 + -24908;
	// 82821058: 485D29B1  bl 0x82df3a08
	ctx.lr = 0x8282105C;
	sub_82DF3A08(ctx, base);
	// 8282105C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82821060: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82821064: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82821068: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8282106C: 4BFCAD15  bl 0x827ebd80
	ctx.lr = 0x82821070;
	sub_827EBD80(ctx, base);
	// 82821070: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821074: 485D23B5  bl 0x82df3428
	ctx.lr = 0x82821078;
	sub_82DF3428(ctx, base);
	// 82821078: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8282107C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82821080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82821084: 4BFFAF1D  bl 0x8281bfa0
	ctx.lr = 0x82821088;
	sub_8281BFA0(ctx, base);
	// 82821088: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8282108C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82821090: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82821094: 48987128  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82821098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82821098 size=12
    let mut pc: u32 = 0x82821098;
    'dispatch: loop {
        match pc {
            0x82821098 => {
    //   block [0x82821098..0x828210A4)
	// 82821098: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8282109C: 386BAE8C  addi r3, r11, -0x5174
	ctx.r[3].s64 = ctx.r[11].s64 + -20852;
	// 828210A0: 4BFFAE90  b 0x8281bf30
	sub_8281BF30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828210A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828210A8 size=12
    let mut pc: u32 = 0x828210A8;
    'dispatch: loop {
        match pc {
            0x828210A8 => {
    //   block [0x828210A8..0x828210B4)
	// 828210A8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828210AC: 386BAE8C  addi r3, r11, -0x5174
	ctx.r[3].s64 = ctx.r[11].s64 + -20852;
	// 828210B0: 4BFFAE88  b 0x8281bf38
	sub_8281BF38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828210B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828210B8 size=12
    let mut pc: u32 = 0x828210B8;
    'dispatch: loop {
        match pc {
            0x828210B8 => {
    //   block [0x828210B8..0x828210C4)
	// 828210B8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828210BC: 386BAF48  addi r3, r11, -0x50b8
	ctx.r[3].s64 = ctx.r[11].s64 + -20664;
	// 828210C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828210C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828210C8 size=12
    let mut pc: u32 = 0x828210C8;
    'dispatch: loop {
        match pc {
            0x828210C8 => {
    //   block [0x828210C8..0x828210D4)
	// 828210C8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828210CC: 386BAF2C  addi r3, r11, -0x50d4
	ctx.r[3].s64 = ctx.r[11].s64 + -20692;
	// 828210D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828210D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828210D8 size=12
    let mut pc: u32 = 0x828210D8;
    'dispatch: loop {
        match pc {
            0x828210D8 => {
    //   block [0x828210D8..0x828210E4)
	// 828210D8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828210DC: 386BAF58  addi r3, r11, -0x50a8
	ctx.r[3].s64 = ctx.r[11].s64 + -20648;
	// 828210E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828210E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828210E8 size=4
    let mut pc: u32 = 0x828210E8;
    'dispatch: loop {
        match pc {
            0x828210E8 => {
    //   block [0x828210E8..0x828210EC)
	// 828210E8: 4BFFCA20  b 0x8281db08
	sub_8281DB08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828210F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828210F0 size=4
    let mut pc: u32 = 0x828210F0;
    'dispatch: loop {
        match pc {
            0x828210F0 => {
    //   block [0x828210F0..0x828210F4)
	// 828210F0: 4BFFF218  b 0x82820308
	sub_82820308(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828210F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828210F8 size=76
    let mut pc: u32 = 0x828210F8;
    'dispatch: loop {
        match pc {
            0x828210F8 => {
    //   block [0x828210F8..0x82821144)
	// 828210F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828210FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82821100: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82821104: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82821108: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282110C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82821110: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82821114: 388B9F2C  addi r4, r11, -0x60d4
	ctx.r[4].s64 = ctx.r[11].s64 + -24788;
	// 82821118: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282111C: 4BFF7B8D  bl 0x82818ca8
	ctx.lr = 0x82821120;
	sub_82818CA8(ctx, base);
	// 82821120: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82821124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82821128: 4BFFB159  bl 0x8281c280
	ctx.lr = 0x8282112C;
	sub_8281C280(ctx, base);
	// 8282112C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82821130: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82821134: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82821138: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282113C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82821140: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82821148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82821148 size=136
    let mut pc: u32 = 0x82821148;
    'dispatch: loop {
        match pc {
            0x82821148 => {
    //   block [0x82821148..0x828211D0)
	// 82821148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282114C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82821150: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82821154: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82821158: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282115C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82821160: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82821164: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82821168: 409A0020  bne cr6, 0x82821188
	if !ctx.cr[6].eq {
	pc = 0x82821188; continue 'dispatch;
	}
	// 8282116C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82821170: 419A0048  beq cr6, 0x828211b8
	if ctx.cr[6].eq {
	pc = 0x828211B8; continue 'dispatch;
	}
	// 82821174: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82821178: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8282117C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82821180: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82821184: 48000034  b 0x828211b8
	pc = 0x828211B8; continue 'dispatch;
	// 82821188: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8282118C: 419A002C  beq cr6, 0x828211b8
	if ctx.cr[6].eq {
	pc = 0x828211B8; continue 'dispatch;
	}
	// 82821190: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82821194: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82821198: 388BFC60  addi r4, r11, -0x3a0
	ctx.r[4].s64 = ctx.r[11].s64 + -928;
	// 8282119C: 48986F5D  bl 0x831a80f8
	ctx.lr = 0x828211A0;
	sub_831A80F8(ctx, base);
	// 828211A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828211A4: 4182000C  beq 0x828211b0
	if ctx.cr[0].eq {
	pc = 0x828211B0; continue 'dispatch;
	}
	// 828211A8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828211AC: 4800000C  b 0x828211b8
	pc = 0x828211B8; continue 'dispatch;
	// 828211B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828211B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828211B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828211BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828211C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828211C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828211C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828211CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828211D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828211D0 size=136
    let mut pc: u32 = 0x828211D0;
    'dispatch: loop {
        match pc {
            0x828211D0 => {
    //   block [0x828211D0..0x82821258)
	// 828211D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828211D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828211D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828211DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828211E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828211E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828211E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828211EC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828211F0: 409A0020  bne cr6, 0x82821210
	if !ctx.cr[6].eq {
	pc = 0x82821210; continue 'dispatch;
	}
	// 828211F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828211F8: 419A0048  beq cr6, 0x82821240
	if ctx.cr[6].eq {
	pc = 0x82821240; continue 'dispatch;
	}
	// 828211FC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82821200: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82821204: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82821208: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8282120C: 48000034  b 0x82821240
	pc = 0x82821240; continue 'dispatch;
	// 82821210: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82821214: 419A002C  beq cr6, 0x82821240
	if ctx.cr[6].eq {
	pc = 0x82821240; continue 'dispatch;
	}
	// 82821218: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282121C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82821220: 388BFD20  addi r4, r11, -0x2e0
	ctx.r[4].s64 = ctx.r[11].s64 + -736;
	// 82821224: 48986ED5  bl 0x831a80f8
	ctx.lr = 0x82821228;
	sub_831A80F8(ctx, base);
	// 82821228: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282122C: 4182000C  beq 0x82821238
	if ctx.cr[0].eq {
	pc = 0x82821238; continue 'dispatch;
	}
	// 82821230: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82821234: 4800000C  b 0x82821240
	pc = 0x82821240; continue 'dispatch;
	// 82821238: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282123C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82821240: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82821244: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82821248: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282124C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82821250: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82821254: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82821258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82821258 size=208
    let mut pc: u32 = 0x82821258;
    'dispatch: loop {
        match pc {
            0x82821258 => {
    //   block [0x82821258..0x82821328)
	// 82821258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282125C: 48986F11  bl 0x831a816c
	ctx.lr = 0x82821260;
	sub_831A8130(ctx, base);
	// 82821260: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82821264: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82821268: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282126C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821270: 388B9EB4  addi r4, r11, -0x614c
	ctx.r[4].s64 = ctx.r[11].s64 + -24908;
	// 82821274: 485D2795  bl 0x82df3a08
	ctx.lr = 0x82821278;
	sub_82DF3A08(ctx, base);
	// 82821278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282127C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82821280: 4BFCAF51  bl 0x827ec1d0
	ctx.lr = 0x82821284;
	sub_827EC1D0(ctx, base);
	// 82821284: 4BFC9025  bl 0x827ea2a8
	ctx.lr = 0x82821288;
	sub_827EA2A8(ctx, base);
	// 82821288: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8282128C: 485D207D  bl 0x82df3308
	ctx.lr = 0x82821290;
	sub_82DF3308(ctx, base);
	// 82821290: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82821294: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821298: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8282129C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828212A0: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 828212A4: 485D2185  bl 0x82df3428
	ctx.lr = 0x828212A8;
	sub_82DF3428(ctx, base);
	// 828212A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828212AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828212B0: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 828212B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828212B8: 4E800421  bctrl
	ctx.lr = 0x828212BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828212BC: 4BFCC575  bl 0x827ed830
	ctx.lr = 0x828212C0;
	sub_827ED830(ctx, base);
	// 828212C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828212C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828212C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828212CC: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 828212D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828212D4: 4E800421  bctrl
	ctx.lr = 0x828212D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828212D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828212DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828212E0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828212E4: 4BFCD705  bl 0x827ee9e8
	ctx.lr = 0x828212E8;
	sub_827EE9E8(ctx, base);
	// 828212E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828212EC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828212F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828212F4: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 828212F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828212FC: 4E800421  bctrl
	ctx.lr = 0x82821300;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82821300: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82821304: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82821308: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8282130C: 4BFCCE0D  bl 0x827ee118
	ctx.lr = 0x82821310;
	sub_827EE118(ctx, base);
	// 82821310: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82821314: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82821318: 807F02E0  lwz r3, 0x2e0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(736 as u32) ) } as u64;
	// 8282131C: 4815BEB5  bl 0x8297d1d0
	ctx.lr = 0x82821320;
	sub_8297D1D0(ctx, base);
	// 82821320: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82821324: 48986E98  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82821328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82821328 size=212
    let mut pc: u32 = 0x82821328;
    'dispatch: loop {
        match pc {
            0x82821328 => {
    //   block [0x82821328..0x828213FC)
	// 82821328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282132C: 48986E41  bl 0x831a816c
	ctx.lr = 0x82821330;
	sub_831A8130(ctx, base);
	// 82821330: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82821334: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82821338: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8282133C: 817F0304  lwz r11, 0x304(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(772 as u32) ) } as u64;
	// 82821340: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82821344: 418200B0  beq 0x828213f4
	if ctx.cr[0].eq {
	pc = 0x828213F4; continue 'dispatch;
	}
	// 82821348: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8282134C: 809F02E8  lwz r4, 0x2e8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(744 as u32) ) } as u64;
	// 82821350: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82821354: 392BBA80  addi r9, r11, -0x4580
	ctx.r[9].s64 = ctx.r[11].s64 + -17792;
	// 82821358: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 8282135C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82821360: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82821364: C00BBA80  lfs f0, -0x4580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82821368: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8282136C: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82821370: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82821374: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82821378: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8282137C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82821380: C1A90008  lfs f13, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82821384: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82821388: C189000C  lfs f12, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8282138C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82821390: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82821394: D181005C  stfs f12, 0x5c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82821400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82821400 size=212
    let mut pc: u32 = 0x82821400;
    'dispatch: loop {
        match pc {
            0x82821400 => {
    //   block [0x82821400..0x828214D4)
	// 82821400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82821404: 48986D69  bl 0x831a816c
	ctx.lr = 0x82821408;
	sub_831A8130(ctx, base);
	// 82821408: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282140C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82821410: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82821414: 817F0304  lwz r11, 0x304(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(772 as u32) ) } as u64;
	// 82821418: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8282141C: 418200B0  beq 0x828214cc
	if ctx.cr[0].eq {
	pc = 0x828214CC; continue 'dispatch;
	}
	// 82821420: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82821424: 809F02EC  lwz r4, 0x2ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(748 as u32) ) } as u64;
	// 82821428: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 8282142C: 392BBA80  addi r9, r11, -0x4580
	ctx.r[9].s64 = ctx.r[11].s64 + -17792;
	// 82821430: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 82821434: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82821438: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 8282143C: C00BBA80  lfs f0, -0x4580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82821440: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82821444: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82821448: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8282144C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82821450: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82821454: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82821458: C1A90008  lfs f13, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8282145C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82821460: C189000C  lfs f12, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82821464: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82821468: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8282146C: D181005C  stfs f12, 0x5c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828214D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828214D8 size=96
    let mut pc: u32 = 0x828214D8;
    'dispatch: loop {
        match pc {
            0x828214D8 => {
    //   block [0x828214D8..0x82821538)
	// 828214D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828214DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828214E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828214E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828214E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828214EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828214F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828214F4: 807F02E0  lwz r3, 0x2e0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(736 as u32) ) } as u64;
	// 828214F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828214FC: 419A0008  beq cr6, 0x82821504
	if ctx.cr[6].eq {
	pc = 0x82821504; continue 'dispatch;
	}
	// 82821500: 4815B5F9  bl 0x8297caf8
	ctx.lr = 0x82821504;
	sub_8297CAF8(ctx, base);
	// 82821504: 807F02E4  lwz r3, 0x2e4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(740 as u32) ) } as u64;
	// 82821508: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282150C: 419A0008  beq cr6, 0x82821514
	if ctx.cr[6].eq {
	pc = 0x82821514; continue 'dispatch;
	}
	// 82821510: 4815B5E9  bl 0x8297caf8
	ctx.lr = 0x82821514;
	sub_8297CAF8(ctx, base);
	// 82821514: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82821518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282151C: 4BFFD715  bl 0x8281ec30
	ctx.lr = 0x82821520;
	sub_8281EC30(ctx, base);
	// 82821520: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82821524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82821528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282152C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82821530: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82821534: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82821538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82821538 size=164
    let mut pc: u32 = 0x82821538;
    'dispatch: loop {
        match pc {
            0x82821538 => {
    //   block [0x82821538..0x828215DC)
	// 82821538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282153C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82821540: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82821544: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82821548: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8282154C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82821550: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82821554: C04B959C  lfs f2, -0x6a64(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82821558: C02A9C28  lfs f1, -0x63d8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25560 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8282155C: 4BFFE7ED  bl 0x8281fd48
	ctx.lr = 0x82821560;
	sub_8281FD48(ctx, base);
	// 82821560: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82821564: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82821568: 396B9FD4  addi r11, r11, -0x602c
	ctx.r[11].s64 = ctx.r[11].s64 + -24620;
	// 8282156C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82821570: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82821574: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82821578: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 8282157C: 394A9FC0  addi r10, r10, -0x6040
	ctx.r[10].s64 = ctx.r[10].s64 + -24640;
	// 82821580: 39299F74  addi r9, r9, -0x608c
	ctx.r[9].s64 = ctx.r[9].s64 + -24716;
	// 82821584: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82821588: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8282158C: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 82821590: C008D5B8  lfs f0, -0x2a48(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82821594: 917F02E0  stw r11, 0x2e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(736 as u32), ctx.r[11].u32 ) };
	// 82821598: C1A7A1C4  lfs f13, -0x5e3c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8282159C: 917F02E4  stw r11, 0x2e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(740 as u32), ctx.r[11].u32 ) };
	// 828215A0: D01F02F8  stfs f0, 0x2f8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(760 as u32), tmp.u32 ) };
	// 828215A4: D1BF02FC  stfs f13, 0x2fc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(764 as u32), tmp.u32 ) };
	// 828215A8: 917F02E8  stw r11, 0x2e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(744 as u32), ctx.r[11].u32 ) };
	// 828215AC: 917F02EC  stw r11, 0x2ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(748 as u32), ctx.r[11].u32 ) };
	// 828215B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828215B4: 917F02F0  stw r11, 0x2f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(752 as u32), ctx.r[11].u32 ) };
	// 828215B8: 917F02F4  stw r11, 0x2f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(756 as u32), ctx.r[11].u32 ) };
	// 828215BC: 917F0300  stw r11, 0x300(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(768 as u32), ctx.r[11].u32 ) };
	// 828215C0: 917F0304  stw r11, 0x304(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(772 as u32), ctx.r[11].u32 ) };
	// 828215C4: 997F0308  stb r11, 0x308(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(776 as u32), ctx.r[11].u8 ) };
	// 828215C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828215CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828215D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828215D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828215D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828215E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828215E0 size=8
    let mut pc: u32 = 0x828215E0;
    'dispatch: loop {
        match pc {
            0x828215E0 => {
    //   block [0x828215E0..0x828215E8)
	// 828215E0: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 828215E4: 480002C4  b 0x828218a8
	sub_828218A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828215E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828215E8 size=8
    let mut pc: u32 = 0x828215E8;
    'dispatch: loop {
        match pc {
            0x828215E8 => {
    //   block [0x828215E8..0x828215F0)
	// 828215E8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828215EC: 480002BC  b 0x828218a8
	sub_828218A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828215F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828215F0 size=148
    let mut pc: u32 = 0x828215F0;
    'dispatch: loop {
        match pc {
            0x828215F0 => {
    //   block [0x828215F0..0x82821684)
	// 828215F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828215F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828215F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828215FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82821600: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82821604: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82821608: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8282160C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82821610: 396B9FD4  addi r11, r11, -0x602c
	ctx.r[11].s64 = ctx.r[11].s64 + -24620;
	// 82821614: 807F02E4  lwz r3, 0x2e4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(740 as u32) ) } as u64;
	// 82821618: 394A9FC0  addi r10, r10, -0x6040
	ctx.r[10].s64 = ctx.r[10].s64 + -24640;
	// 8282161C: 39299F74  addi r9, r9, -0x608c
	ctx.r[9].s64 = ctx.r[9].s64 + -24716;
	// 82821620: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82821624: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82821628: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282162C: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 82821630: 419A0018  beq cr6, 0x82821648
	if ctx.cr[6].eq {
	pc = 0x82821648; continue 'dispatch;
	}
	// 82821634: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82821638: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8282163C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82821640: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82821644: 4E800421  bctrl
	ctx.lr = 0x82821648;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82821648: 807F02E0  lwz r3, 0x2e0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(736 as u32) ) } as u64;
	// 8282164C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82821650: 419A0018  beq cr6, 0x82821668
	if ctx.cr[6].eq {
	pc = 0x82821668; continue 'dispatch;
	}
	// 82821654: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82821658: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8282165C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82821660: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82821664: 4E800421  bctrl
	ctx.lr = 0x82821668;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82821668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282166C: 4BFFDB05  bl 0x8281f170
	ctx.lr = 0x82821670;
	sub_8281F170(ctx, base);
	// 82821670: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82821674: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82821678: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282167C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82821680: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82821688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82821688 size=196
    let mut pc: u32 = 0x82821688;
    'dispatch: loop {
        match pc {
            0x82821688 => {
    //   block [0x82821688..0x8282174C)
	// 82821688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282168C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82821690: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82821694: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82821698: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282169C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828216A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828216A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828216A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828216AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828216B0: 4BA9F289  bl 0x822c0938
	ctx.lr = 0x828216B4;
	sub_822C0938(ctx, base);
	// 828216B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828216B8: 41820028  beq 0x828216e0
	if ctx.cr[0].eq {
	pc = 0x828216E0; continue 'dispatch;
	}
	// 828216BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828216C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828216C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828216C8: 392B9F4C  addi r9, r11, -0x60b4
	ctx.r[9].s64 = ctx.r[11].s64 + -24756;
	// 828216CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828216D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828216D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828216D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828216DC: 48000008  b 0x828216e4
	pc = 0x828216E4; continue 'dispatch;
	// 828216E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828216E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828216E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828216EC: 409A0044  bne cr6, 0x82821730
	if !ctx.cr[6].eq {
	pc = 0x82821730; continue 'dispatch;
	}
	// 828216F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828216F4: 419A001C  beq cr6, 0x82821710
	if ctx.cr[6].eq {
	pc = 0x82821710; continue 'dispatch;
	}
	// 828216F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828216FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82821700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82821704: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82821708: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8282170C: 4E800421  bctrl
	ctx.lr = 0x82821710;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82821710: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82821714: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82821718: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282171C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82821720: 816BFC40  lwz r11, -0x3c0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-960 as u32) ) } as u64;
	// 82821724: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82821728: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8282172C: 4BA9E8D5  bl 0x822c0000
	ctx.lr = 0x82821730;
	sub_822C0000(ctx, base);
	// 82821730: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82821734: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82821738: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8282173C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82821740: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82821744: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82821748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82821750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82821750 size=196
    let mut pc: u32 = 0x82821750;
    'dispatch: loop {
        match pc {
            0x82821750 => {
    //   block [0x82821750..0x82821814)
	// 82821750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82821754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82821758: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8282175C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82821760: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82821764: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82821768: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282176C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82821770: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82821774: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82821778: 4BA9F1C1  bl 0x822c0938
	ctx.lr = 0x8282177C;
	sub_822C0938(ctx, base);
	// 8282177C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82821780: 41820028  beq 0x828217a8
	if ctx.cr[0].eq {
	pc = 0x828217A8; continue 'dispatch;
	}
	// 82821784: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82821788: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8282178C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82821790: 392B9F60  addi r9, r11, -0x60a0
	ctx.r[9].s64 = ctx.r[11].s64 + -24736;
	// 82821794: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82821798: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8282179C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828217A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828217A4: 48000008  b 0x828217ac
	pc = 0x828217AC; continue 'dispatch;
	// 828217A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828217AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828217B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828217B4: 409A0044  bne cr6, 0x828217f8
	if !ctx.cr[6].eq {
	pc = 0x828217F8; continue 'dispatch;
	}
	// 828217B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828217BC: 419A001C  beq cr6, 0x828217d8
	if ctx.cr[6].eq {
	pc = 0x828217D8; continue 'dispatch;
	}
	// 828217C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828217C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828217C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828217CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828217D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828217D4: 4E800421  bctrl
	ctx.lr = 0x828217D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828217D8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828217DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828217E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828217E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828217E8: 816BFC40  lwz r11, -0x3c0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-960 as u32) ) } as u64;
	// 828217EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828217F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828217F4: 4BA9E80D  bl 0x822c0000
	ctx.lr = 0x828217F8;
	sub_822C0000(ctx, base);
	// 828217F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828217FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82821800: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82821804: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82821808: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282180C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82821810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82821818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82821818 size=72
    let mut pc: u32 = 0x82821818;
    'dispatch: loop {
        match pc {
            0x82821818 => {
    //   block [0x82821818..0x82821860)
	// 82821818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282181C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82821820: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82821824: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82821828: 419A001C  beq cr6, 0x82821844
	if ctx.cr[6].eq {
	pc = 0x82821844; continue 'dispatch;
	}
	// 8282182C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82821830: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82821834: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82821838: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8282183C: 4BFFF90D  bl 0x82821148
	ctx.lr = 0x82821840;
	sub_82821148(ctx, base);
	// 82821840: 48000010  b 0x82821850
	pc = 0x82821850; continue 'dispatch;
	// 82821844: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82821848: 396BFC60  addi r11, r11, -0x3a0
	ctx.r[11].s64 = ctx.r[11].s64 + -928;
	// 8282184C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82821850: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82821854: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82821858: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8282185C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82821860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82821860 size=72
    let mut pc: u32 = 0x82821860;
    'dispatch: loop {
        match pc {
            0x82821860 => {
    //   block [0x82821860..0x828218A8)
	// 82821860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82821864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82821868: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282186C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82821870: 419A001C  beq cr6, 0x8282188c
	if ctx.cr[6].eq {
	pc = 0x8282188C; continue 'dispatch;
	}
	// 82821874: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82821878: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8282187C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82821880: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82821884: 4BFFF94D  bl 0x828211d0
	ctx.lr = 0x82821888;
	sub_828211D0(ctx, base);
	// 82821888: 48000010  b 0x82821898
	pc = 0x82821898; continue 'dispatch;
	// 8282188C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82821890: 396BFD20  addi r11, r11, -0x2e0
	ctx.r[11].s64 = ctx.r[11].s64 + -736;
	// 82821894: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82821898: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8282189C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828218A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828218A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828218A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828218A8 size=76
    let mut pc: u32 = 0x828218A8;
    'dispatch: loop {
        match pc {
            0x828218A8 => {
    //   block [0x828218A8..0x828218F4)
	// 828218A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828218AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828218B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828218B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828218B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828218BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828218C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828218C4: 4BFFFD2D  bl 0x828215f0
	ctx.lr = 0x828218C8;
	sub_828215F0(ctx, base);
	// 828218C8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828218CC: 4182000C  beq 0x828218d8
	if ctx.cr[0].eq {
	pc = 0x828218D8; continue 'dispatch;
	}
	// 828218D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828218D4: 485D0B05  bl 0x82df23d8
	ctx.lr = 0x828218D8;
	sub_82DF23D8(ctx, base);
	// 828218D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828218DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828218E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828218E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828218E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828218EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828218F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828218F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828218F8 size=984
    let mut pc: u32 = 0x828218F8;
    'dispatch: loop {
        match pc {
            0x828218F8 => {
    //   block [0x828218F8..0x82821CD0)
	// 828218F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828218FC: 48986869  bl 0x831a8164
	ctx.lr = 0x82821900;
	sub_831A8130(ctx, base);
	// 82821900: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82821904: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82821908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8282190C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82821910: 817F0304  lwz r11, 0x304(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(772 as u32) ) } as u64;
	// 82821914: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82821918: 41820010  beq 0x82821928
	if ctx.cr[0].eq {
	pc = 0x82821928; continue 'dispatch;
	}
	// 8282191C: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82821920: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82821924: 40820008  bne 0x8282192c
	if !ctx.cr[0].eq {
	pc = 0x8282192C; continue 'dispatch;
	}
	// 82821928: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282192C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82821930: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821934: 41820284  beq 0x82821bb8
	if ctx.cr[0].eq {
	pc = 0x82821BB8; continue 'dispatch;
	}
	// 82821938: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282193C: 388B9F00  addi r4, r11, -0x6100
	ctx.r[4].s64 = ctx.r[11].s64 + -24832;
	// 82821940: 485D20C9  bl 0x82df3a08
	ctx.lr = 0x82821944;
	sub_82DF3A08(ctx, base);
	// 82821944: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82821948: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8282194C: 48041D75  bl 0x828636c0
	ctx.lr = 0x82821950;
	sub_828636C0(ctx, base);
	// 82821950: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82821954: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82821958: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8282195C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82821960: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82821964: 419A0024  beq cr6, 0x82821988
	if ctx.cr[6].eq {
	pc = 0x82821988; continue 'dispatch;
	}
	// 82821968: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8282196C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82821970: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82821974: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82821978: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8282197C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82821980: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82821984: 4082FFE8  bne 0x8282196c
	if !ctx.cr[0].eq {
	pc = 0x8282196C; continue 'dispatch;
	}
	// 82821988: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8282198C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82821990: 4BFCD2E1  bl 0x827eec70
	ctx.lr = 0x82821994;
	sub_827EEC70(ctx, base);
	// 82821994: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82821998: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8282199C: 419A0008  beq cr6, 0x828219a4
	if ctx.cr[6].eq {
	pc = 0x828219A4; continue 'dispatch;
	}
	// 828219A0: 4BA9EEF1  bl 0x822c0890
	ctx.lr = 0x828219A4;
	sub_822C0890(ctx, base);
	// 828219A4: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 828219A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828219AC: 419A0008  beq cr6, 0x828219b4
	if ctx.cr[6].eq {
	pc = 0x828219B4; continue 'dispatch;
	}
	// 828219B0: 4BA9EEE1  bl 0x822c0890
	ctx.lr = 0x828219B4;
	sub_822C0890(ctx, base);
	// 828219B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828219B8: 485D1A71  bl 0x82df3428
	ctx.lr = 0x828219BC;
	sub_82DF3428(ctx, base);
	// 828219BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828219C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828219C4: 388BA07C  addi r4, r11, -0x5f84
	ctx.r[4].s64 = ctx.r[11].s64 + -24452;
	// 828219C8: C3FF02F8  lfs f31, 0x2f8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(760 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828219CC: 485D203D  bl 0x82df3a08
	ctx.lr = 0x828219D0;
	sub_82DF3A08(ctx, base);
	// 828219D0: 817F0300  lwz r11, 0x300(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(768 as u32) ) } as u64;
	// 828219D4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828219D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828219DC: 3B8A9EA8  addi r28, r10, -0x6158
	ctx.r[28].s64 = ctx.r[10].s64 + -24920;
	// 828219E0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828219E4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828219E8: 7C8BE02E  lwzx r4, r11, r28
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 828219EC: 485D201D  bl 0x82df3a08
	ctx.lr = 0x828219F0;
	sub_82DF3A08(ctx, base);
	// 828219F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828219F4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828219F8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 828219FC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82821A00: 38E0000A  li r7, 0xa
	ctx.r[7].s64 = 10;
	// 82821A04: 4BFFF425  bl 0x82820e28
	ctx.lr = 0x82821A08;
	sub_82820E28(ctx, base);
	// 82821A08: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82821A0C: 38A100E0  addi r5, r1, 0xe0
	ctx.r[5].s64 = ctx.r[1].s64 + 224;
	// 82821A10: C03F02FC  lfs f1, 0x2fc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(764 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82821A14: 3BAB9EB4  addi r29, r11, -0x614c
	ctx.r[29].s64 = ctx.r[11].s64 + -24908;
	// 82821A18: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82821A1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82821A20: 48044501  bl 0x82865f20
	ctx.lr = 0x82821A24;
	sub_82865F20(ctx, base);
	// 82821A24: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82821A28: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82821A2C: 388BA070  addi r4, r11, -0x5f90
	ctx.r[4].s64 = ctx.r[11].s64 + -24464;
	// 82821A30: C3FF02F8  lfs f31, 0x2f8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(760 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82821A34: 485D1FD5  bl 0x82df3a08
	ctx.lr = 0x82821A38;
	sub_82DF3A08(ctx, base);
	// 82821A38: 817F0300  lwz r11, 0x300(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(768 as u32) ) } as u64;
	// 82821A3C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82821A40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821A44: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82821A48: 7C8BE02E  lwzx r4, r11, r28
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82821A4C: 485D1FBD  bl 0x82df3a08
	ctx.lr = 0x82821A50;
	sub_82DF3A08(ctx, base);
	// 82821A50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82821A54: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82821A58: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82821A5C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82821A60: 38E0000A  li r7, 0xa
	ctx.r[7].s64 = 10;
	// 82821A64: 4BFFF3C5  bl 0x82820e28
	ctx.lr = 0x82821A68;
	sub_82820E28(ctx, base);
	// 82821A68: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82821A6C: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82821A70: C03F02FC  lfs f1, 0x2fc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(764 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82821A74: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82821A78: 480444A9  bl 0x82865f20
	ctx.lr = 0x82821A7C;
	sub_82865F20(ctx, base);
	// 82821A7C: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 82821A80: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82821A84: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82821A88: 48042759  bl 0x828641e0
	ctx.lr = 0x82821A8C;
	sub_828641E0(ctx, base);
	// 82821A8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82821A90: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82821A94: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82821A98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82821A9C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82821AA0: 419A0024  beq cr6, 0x82821ac4
	if ctx.cr[6].eq {
	pc = 0x82821AC4; continue 'dispatch;
	}
	// 82821AA4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82821AA8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82821AAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82821AB0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82821AB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82821AB8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82821ABC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82821AC0: 4082FFE8  bne 0x82821aa8
	if !ctx.cr[0].eq {
	pc = 0x82821AA8; continue 'dispatch;
	}
	// 82821AC4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82821AC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82821ACC: 4BFCDBD5  bl 0x827ef6a0
	ctx.lr = 0x82821AD0;
	sub_827EF6A0(ctx, base);
	// 82821AD0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82821AD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82821AD8: 419A0008  beq cr6, 0x82821ae0
	if ctx.cr[6].eq {
	pc = 0x82821AE0; continue 'dispatch;
	}
	// 82821ADC: 4BA9EDB5  bl 0x822c0890
	ctx.lr = 0x82821AE0;
	sub_822C0890(ctx, base);
	// 82821AE0: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82821AE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82821AE8: 419A0008  beq cr6, 0x82821af0
	if ctx.cr[6].eq {
	pc = 0x82821AF0; continue 'dispatch;
	}
	// 82821AEC: 4BA9EDA5  bl 0x822c0890
	ctx.lr = 0x82821AF0;
	sub_822C0890(ctx, base);
	// 82821AF0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82821AF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821AF8: 388B9EF4  addi r4, r11, -0x610c
	ctx.r[4].s64 = ctx.r[11].s64 + -24844;
	// 82821AFC: 485D1F0D  bl 0x82df3a08
	ctx.lr = 0x82821B00;
	sub_82DF3A08(ctx, base);
	// 82821B00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82821B04: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82821B08: 48041BB9  bl 0x828636c0
	ctx.lr = 0x82821B0C;
	sub_828636C0(ctx, base);
	// 82821B0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82821B10: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82821B14: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82821B18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82821B1C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82821B20: 419A0024  beq cr6, 0x82821b44
	if ctx.cr[6].eq {
	pc = 0x82821B44; continue 'dispatch;
	}
	// 82821B24: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82821B28: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82821B2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82821B30: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82821B34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82821B38: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82821B3C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82821B40: 4082FFE8  bne 0x82821b28
	if !ctx.cr[0].eq {
	pc = 0x82821B28; continue 'dispatch;
	}
	// 82821B44: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82821B48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82821B4C: 4BFCDB55  bl 0x827ef6a0
	ctx.lr = 0x82821B50;
	sub_827EF6A0(ctx, base);
	// 82821B50: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82821B54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82821B58: 419A0008  beq cr6, 0x82821b60
	if ctx.cr[6].eq {
	pc = 0x82821B60; continue 'dispatch;
	}
	// 82821B5C: 4BA9ED35  bl 0x822c0890
	ctx.lr = 0x82821B60;
	sub_822C0890(ctx, base);
	// 82821B60: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82821B64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82821B68: 419A0008  beq cr6, 0x82821b70
	if ctx.cr[6].eq {
	pc = 0x82821B70; continue 'dispatch;
	}
	// 82821B6C: 4BA9ED25  bl 0x822c0890
	ctx.lr = 0x82821B70;
	sub_822C0890(ctx, base);
	// 82821B70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821B74: 485D18B5  bl 0x82df3428
	ctx.lr = 0x82821B78;
	sub_82DF3428(ctx, base);
	// 82821B78: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82821B7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82821B80: 419A0008  beq cr6, 0x82821b88
	if ctx.cr[6].eq {
	pc = 0x82821B88; continue 'dispatch;
	}
	// 82821B84: 4BA9ED0D  bl 0x822c0890
	ctx.lr = 0x82821B88;
	sub_822C0890(ctx, base);
	// 82821B88: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 82821B8C: 485D189D  bl 0x82df3428
	ctx.lr = 0x82821B90;
	sub_82DF3428(ctx, base);
	// 82821B90: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82821B94: 485D1895  bl 0x82df3428
	ctx.lr = 0x82821B98;
	sub_82DF3428(ctx, base);
	// 82821B98: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82821B9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82821BA0: 419A0008  beq cr6, 0x82821ba8
	if ctx.cr[6].eq {
	pc = 0x82821BA8; continue 'dispatch;
	}
	// 82821BA4: 4BA9ECED  bl 0x822c0890
	ctx.lr = 0x82821BA8;
	sub_822C0890(ctx, base);
	// 82821BA8: 386100E4  addi r3, r1, 0xe4
	ctx.r[3].s64 = ctx.r[1].s64 + 228;
	// 82821BAC: 485D187D  bl 0x82df3428
	ctx.lr = 0x82821BB0;
	sub_82DF3428(ctx, base);
	// 82821BB0: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82821BB4: 4800010C  b 0x82821cc0
	pc = 0x82821CC0; continue 'dispatch;
	// 82821BB8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82821BBC: 388B9EE4  addi r4, r11, -0x611c
	ctx.r[4].s64 = ctx.r[11].s64 + -24860;
	// 82821BC0: 485D1E49  bl 0x82df3a08
	ctx.lr = 0x82821BC4;
	sub_82DF3A08(ctx, base);
	// 82821BC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82821BC8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82821BCC: 48041AF5  bl 0x828636c0
	ctx.lr = 0x82821BD0;
	sub_828636C0(ctx, base);
	// 82821BD0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82821BD4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82821BD8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82821BDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82821BE0: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82821BE4: 419A0024  beq cr6, 0x82821c08
	if ctx.cr[6].eq {
	pc = 0x82821C08; continue 'dispatch;
	}
	// 82821BE8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82821BEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82821BF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82821BF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82821BF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82821BFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82821C00: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82821C04: 4082FFE8  bne 0x82821bec
	if !ctx.cr[0].eq {
	pc = 0x82821BEC; continue 'dispatch;
	}
	// 82821C08: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82821C0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82821C10: 4BFCD061  bl 0x827eec70
	ctx.lr = 0x82821C14;
	sub_827EEC70(ctx, base);
	// 82821C14: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82821C18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82821C1C: 419A0008  beq cr6, 0x82821c24
	if ctx.cr[6].eq {
	pc = 0x82821C24; continue 'dispatch;
	}
	// 82821C20: 4BA9EC71  bl 0x822c0890
	ctx.lr = 0x82821C24;
	sub_822C0890(ctx, base);
	// 82821C24: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82821C28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82821C2C: 419A0008  beq cr6, 0x82821c34
	if ctx.cr[6].eq {
	pc = 0x82821C34; continue 'dispatch;
	}
	// 82821C30: 4BA9EC61  bl 0x822c0890
	ctx.lr = 0x82821C34;
	sub_822C0890(ctx, base);
	// 82821C34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821C38: 485D17F1  bl 0x82df3428
	ctx.lr = 0x82821C3C;
	sub_82DF3428(ctx, base);
	// 82821C3C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82821C40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821C44: 388B9ED4  addi r4, r11, -0x612c
	ctx.r[4].s64 = ctx.r[11].s64 + -24876;
	// 82821C48: 485D1DC1  bl 0x82df3a08
	ctx.lr = 0x82821C4C;
	sub_82DF3A08(ctx, base);
	// 82821C4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82821C50: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82821C54: 48041A6D  bl 0x828636c0
	ctx.lr = 0x82821C58;
	sub_828636C0(ctx, base);
	// 82821C58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82821C5C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82821C60: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82821C64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82821C68: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82821C6C: 419A0024  beq cr6, 0x82821c90
	if ctx.cr[6].eq {
	pc = 0x82821C90; continue 'dispatch;
	}
	// 82821C70: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82821C74: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82821C78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82821C7C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82821C80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82821C84: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82821C88: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82821C8C: 4082FFE8  bne 0x82821c74
	if !ctx.cr[0].eq {
	pc = 0x82821C74; continue 'dispatch;
	}
	// 82821C90: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82821C94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82821C98: 4BFCDA09  bl 0x827ef6a0
	ctx.lr = 0x82821C9C;
	sub_827EF6A0(ctx, base);
	// 82821C9C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82821CA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82821CA4: 419A0008  beq cr6, 0x82821cac
	if ctx.cr[6].eq {
	pc = 0x82821CAC; continue 'dispatch;
	}
	// 82821CA8: 4BA9EBE9  bl 0x822c0890
	ctx.lr = 0x82821CAC;
	sub_822C0890(ctx, base);
	// 82821CAC: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82821CB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82821CB4: 419A0008  beq cr6, 0x82821cbc
	if ctx.cr[6].eq {
	pc = 0x82821CBC; continue 'dispatch;
	}
	// 82821CB8: 4BA9EBD9  bl 0x822c0890
	ctx.lr = 0x82821CBC;
	sub_822C0890(ctx, base);
	// 82821CBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821CC0: 485D1769  bl 0x82df3428
	ctx.lr = 0x82821CC4;
	sub_82DF3428(ctx, base);
	// 82821CC4: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82821CC8: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82821CCC: 489864E8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82821CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82821CD0 size=456
    let mut pc: u32 = 0x82821CD0;
    'dispatch: loop {
        match pc {
            0x82821CD0 => {
    //   block [0x82821CD0..0x82821E98)
	// 82821CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82821CD4: 48986499  bl 0x831a816c
	ctx.lr = 0x82821CD8;
	sub_831A8130(ctx, base);
	// 82821CD8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82821CDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82821CE0: 3BC40018  addi r30, r4, 0x18
	ctx.r[30].s64 = ctx.r[4].s64 + 24;
	// 82821CE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82821CE8: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82821CEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82821CF0: 4E800421  bctrl
	ctx.lr = 0x82821CF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82821CF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82821CF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82821CFC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82821D00: 4BFCCB21  bl 0x827ee820
	ctx.lr = 0x82821D04;
	sub_827EE820(ctx, base);
	// 82821D04: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82821D08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82821D0C: 419A0174  beq cr6, 0x82821e80
	if ctx.cr[6].eq {
	pc = 0x82821E80; continue 'dispatch;
	}
	// 82821D10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82821D14: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82821D18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82821D1C: 4E800421  bctrl
	ctx.lr = 0x82821D20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82821D20: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82821D24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82821D28: 388B9E94  addi r4, r11, -0x616c
	ctx.r[4].s64 = ctx.r[11].s64 + -24940;
	// 82821D2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821D30: 485D1CD9  bl 0x82df3a08
	ctx.lr = 0x82821D34;
	sub_82DF3A08(ctx, base);
	// 82821D34: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82821D38: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 82821D3C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82821D40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82821D44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82821D48: C02B9524  lfs f1, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82821D4C: 4BFCA4B5  bl 0x827ec200
	ctx.lr = 0x82821D50;
	sub_827EC200(ctx, base);
	// 82821D50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821D54: 485D16D5  bl 0x82df3428
	ctx.lr = 0x82821D58;
	sub_82DF3428(ctx, base);
	// 82821D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82821D5C: 481F192D  bl 0x82a13688
	ctx.lr = 0x82821D60;
	sub_82A13688(ctx, base);
	// 82821D60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82821D64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82821D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82821D6C: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82821D70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82821D74: 4E800421  bctrl
	ctx.lr = 0x82821D78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82821D78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82821D7C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82821D80: 4BFCC161  bl 0x827edee0
	ctx.lr = 0x82821D84;
	sub_827EDEE0(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82821E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82821E98 size=220
    let mut pc: u32 = 0x82821E98;
    'dispatch: loop {
        match pc {
            0x82821E98 => {
    //   block [0x82821E98..0x82821F74)
	// 82821E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82821E9C: 489862CD  bl 0x831a8168
	ctx.lr = 0x82821EA0;
	sub_831A8130(ctx, base);
	// 82821EA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82821EA4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82821EA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82821EAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82821EB0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82821EB4: 41820038  beq 0x82821eec
	if ctx.cr[0].eq {
	pc = 0x82821EEC; continue 'dispatch;
	}
	// 82821EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82821EBC: 48987ACD  bl 0x831a9988
	ctx.lr = 0x82821EC0;
	sub_831A9988(ctx, base);
	// 82821EC0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82821EC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82821EC8: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 82821ECC: 4898622D  bl 0x831a80f8
	ctx.lr = 0x82821ED0;
	sub_831A80F8(ctx, base);
	// 82821ED0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82821ED4: 41820018  beq 0x82821eec
	if ctx.cr[0].eq {
	pc = 0x82821EEC; continue 'dispatch;
	}
	// 82821ED8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82821EDC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82821EE0: 4BFFF211  bl 0x828210f0
	ctx.lr = 0x82821EE4;
	sub_828210F0(ctx, base);
	// 82821EE4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82821EE8: 48000084  b 0x82821f6c
	pc = 0x82821F6C; continue 'dispatch;
	// 82821EEC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82821EF0: 419A006C  beq cr6, 0x82821f5c
	if ctx.cr[6].eq {
	pc = 0x82821F5C; continue 'dispatch;
	}
	// 82821EF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82821EF8: 48987A91  bl 0x831a9988
	ctx.lr = 0x82821EFC;
	sub_831A9988(ctx, base);
	// 82821EFC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82821F00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82821F04: 386BDBD4  addi r3, r11, -0x242c
	ctx.r[3].s64 = ctx.r[11].s64 + -9260;
	// 82821F08: 489861F1  bl 0x831a80f8
	ctx.lr = 0x82821F0C;
	sub_831A80F8(ctx, base);
	// 82821F0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82821F10: 41820014  beq 0x82821f24
	if ctx.cr[0].eq {
	pc = 0x82821F24; continue 'dispatch;
	}
	// 82821F14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82821F18: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82821F1C: 4BFFF1DD  bl 0x828210f8
	ctx.lr = 0x82821F20;
	sub_828210F8(ctx, base);
	// 82821F20: 4BFFFFC4  b 0x82821ee4
	pc = 0x82821EE4; continue 'dispatch;
	// 82821F24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82821F28: 419A0034  beq cr6, 0x82821f5c
	if ctx.cr[6].eq {
	pc = 0x82821F5C; continue 'dispatch;
	}
	// 82821F2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82821F30: 48987A59  bl 0x831a9988
	ctx.lr = 0x82821F34;
	sub_831A9988(ctx, base);
	// 82821F34: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82821F38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82821F3C: 386BFE6C  addi r3, r11, -0x194
	ctx.r[3].s64 = ctx.r[11].s64 + -404;
	// 82821F40: 489861B9  bl 0x831a80f8
	ctx.lr = 0x82821F44;
	sub_831A80F8(ctx, base);
	// 82821F44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82821F48: 41820014  beq 0x82821f5c
	if ctx.cr[0].eq {
	pc = 0x82821F5C; continue 'dispatch;
	}
	// 82821F4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82821F50: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82821F54: 4BFFFD7D  bl 0x82821cd0
	ctx.lr = 0x82821F58;
	sub_82821CD0(ctx, base);
	// 82821F58: 4BFFFF8C  b 0x82821ee4
	pc = 0x82821EE4; continue 'dispatch;
	// 82821F5C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82821F60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82821F64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82821F68: 4BFFE911  bl 0x82820878
	ctx.lr = 0x82821F6C;
	sub_82820878(ctx, base);
	// 82821F6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82821F70: 48986248  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82821F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82821F78 size=700
    let mut pc: u32 = 0x82821F78;
    'dispatch: loop {
        match pc {
            0x82821F78 => {
    //   block [0x82821F78..0x82822234)
	// 82821F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82821F7C: 489861E9  bl 0x831a8164
	ctx.lr = 0x82821F80;
	sub_831A8130(ctx, base);
	// 82821F80: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82821F84: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82821F88: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82821F8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82821F90: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82821F94: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82821F98: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82821F9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82821FA0: 388BA0E8  addi r4, r11, -0x5f18
	ctx.r[4].s64 = ctx.r[11].s64 + -24344;
	// 82821FA4: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82821FA8: 38A000EA  li r5, 0xea
	ctx.r[5].s64 = 234;
	// 82821FAC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82821FB0: 4BA9E429  bl 0x822c03d8
	ctx.lr = 0x82821FB4;
	sub_822C03D8(ctx, base);
	// 82821FB4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82821FB8: 41820034  beq 0x82821fec
	if ctx.cr[0].eq {
	pc = 0x82821FEC; continue 'dispatch;
	}
	// 82821FBC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82821FC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82821FC4: 388BA0DC  addi r4, r11, -0x5f24
	ctx.r[4].s64 = ctx.r[11].s64 + -24356;
	// 82821FC8: 485D1A41  bl 0x82df3a08
	ctx.lr = 0x82821FCC;
	sub_82DF3A08(ctx, base);
	// 82821FCC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82821FD0: 38BC00F8  addi r5, r28, 0xf8
	ctx.r[5].s64 = ctx.r[28].s64 + 248;
	// 82821FD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82821FD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82821FDC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82821FE0: 4BD8A431  bl 0x825ac410
	ctx.lr = 0x82821FE4;
	sub_825AC410(ctx, base);
	// 82821FE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82821FE8: 48000008  b 0x82821ff0
	pc = 0x82821FF0; continue 'dispatch;
	// 82821FEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82821FF0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82821FF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82821FF8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82821FFC: 4BCD13BD  bl 0x824f33b8
	ctx.lr = 0x82822000;
	sub_824F33B8(ctx, base);
	// 82822000: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82822004: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82822008: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8282200C: 4BA9DFF5  bl 0x822c0000
	ctx.lr = 0x82822010;
	sub_822C0000(ctx, base);
	// 82822010: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82822014: 4182000C  beq 0x82822020
	if ctx.cr[0].eq {
	pc = 0x82822020; continue 'dispatch;
	}
	// 82822018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282201C: 485D140D  bl 0x82df3428
	ctx.lr = 0x82822020;
	sub_82DF3428(ctx, base);
	// 82822020: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822024: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82822028: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8282202C: 3BCB9EA8  addi r30, r11, -0x6158
	ctx.r[30].s64 = ctx.r[11].s64 + -24920;
	// 82822030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822034: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82822038: 485D19D1  bl 0x82df3a08
	ctx.lr = 0x8282203C;
	sub_82DF3A08(ctx, base);
	// 8282203C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82822040: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82822044: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82822048: 4BD89D79  bl 0x825abdc0
	ctx.lr = 0x8282204C;
	sub_825ABDC0(ctx, base);
	// 8282204C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822050: 485D13D9  bl 0x82df3428
	ctx.lr = 0x82822054;
	sub_82DF3428(ctx, base);
	// 82822054: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82822058: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 8282205C: 2B1F0003  cmplwi cr6, r31, 3
	ctx.cr[6].compare_u32(ctx.r[31].u32, 3 as u32, &mut ctx.xer);
	// 82822060: 4198FFD0  blt cr6, 0x82822030
	if ctx.cr[6].lt {
	pc = 0x82822030; continue 'dispatch;
	}
	// 82822064: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282206C: 388BA0D0  addi r4, r11, -0x5f30
	ctx.r[4].s64 = ctx.r[11].s64 + -24368;
	// 82822070: 485D1999  bl 0x82df3a08
	ctx.lr = 0x82822074;
	sub_82DF3A08(ctx, base);
	// 82822074: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82822078: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 8282207C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82822080: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82822084: 419A0024  beq cr6, 0x828220a8
	if ctx.cr[6].eq {
	pc = 0x828220A8; continue 'dispatch;
	}
	// 82822088: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8282208C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82822090: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82822094: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82822098: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8282209C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828220A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828220A4: 4082FFE8  bne 0x8282208c
	if !ctx.cr[0].eq {
	pc = 0x8282208C; continue 'dispatch;
	}
	// 828220A8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828220AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828220B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828220B4: 4BD8005D  bl 0x825a2110
	ctx.lr = 0x828220B8;
	sub_825A2110(ctx, base);
	// 828220B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828220BC: 485D136D  bl 0x82df3428
	ctx.lr = 0x828220C0;
	sub_82DF3428(ctx, base);
	// 828220C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828220C4: 419A000C  beq cr6, 0x828220d0
	if ctx.cr[6].eq {
	pc = 0x828220D0; continue 'dispatch;
	}
	// 828220C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828220CC: 4BA9E7C5  bl 0x822c0890
	ctx.lr = 0x828220D0;
	sub_822C0890(ctx, base);
	// 828220D0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828220D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828220D8: 388BA0B8  addi r4, r11, -0x5f48
	ctx.r[4].s64 = ctx.r[11].s64 + -24392;
	// 828220DC: 485D192D  bl 0x82df3a08
	ctx.lr = 0x828220E0;
	sub_82DF3A08(ctx, base);
	// 828220E0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828220E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828220E8: 388BED88  addi r4, r11, -0x1278
	ctx.r[4].s64 = ctx.r[11].s64 + -4728;
	// 828220EC: 485D191D  bl 0x82df3a08
	ctx.lr = 0x828220F0;
	sub_82DF3A08(ctx, base);
	// 828220F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828220F4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 828220F8: 38BC00F4  addi r5, r28, 0xf4
	ctx.r[5].s64 = ctx.r[28].s64 + 244;
	// 828220FC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82822100: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82822104: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82822108: C3CADD6C  lfs f30, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8282210C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82822110: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82822114: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82822118: 4BD81191  bl 0x825a32a8
	ctx.lr = 0x8282211C;
	sub_825A32A8(ctx, base);
	// 8282211C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82822120: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82822124: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82822128: 4BD7F649  bl 0x825a1770
	ctx.lr = 0x8282212C;
	sub_825A1770(ctx, base);
	// 8282212C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82822130: 485D12F9  bl 0x82df3428
	ctx.lr = 0x82822134;
	sub_82DF3428(ctx, base);
	// 82822134: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82822138: 4BAA6B81  bl 0x822c8cb8
	ctx.lr = 0x8282213C;
	sub_822C8CB8(ctx, base);
	// 8282213C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822140: 485D12E9  bl 0x82df3428
	ctx.lr = 0x82822144;
	sub_82DF3428(ctx, base);
	// 82822144: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82822148: 485D12E1  bl 0x82df3428
	ctx.lr = 0x8282214C;
	sub_82DF3428(ctx, base);
	// 8282214C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822154: 388BA0A8  addi r4, r11, -0x5f58
	ctx.r[4].s64 = ctx.r[11].s64 + -24408;
	// 82822158: 485D18B1  bl 0x82df3a08
	ctx.lr = 0x8282215C;
	sub_82DF3A08(ctx, base);
	// 8282215C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82822160: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82822164: 388BED64  addi r4, r11, -0x129c
	ctx.r[4].s64 = ctx.r[11].s64 + -4764;
	// 82822168: 485D18A1  bl 0x82df3a08
	ctx.lr = 0x8282216C;
	sub_82DF3A08(ctx, base);
	// 8282216C: 38BC00F0  addi r5, r28, 0xf0
	ctx.r[5].s64 = ctx.r[28].s64 + 240;
	// 82822170: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82822174: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82822178: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8282217C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82822180: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82822184: 4BD81125  bl 0x825a32a8
	ctx.lr = 0x82822188;
	sub_825A32A8(ctx, base);
	// 82822188: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8282218C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82822190: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82822194: 4BD7F5DD  bl 0x825a1770
	ctx.lr = 0x82822198;
	sub_825A1770(ctx, base);
	// 82822198: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 8282219C: 485D128D  bl 0x82df3428
	ctx.lr = 0x828221A0;
	sub_82DF3428(ctx, base);
	// 828221A0: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 828221A4: 4BAA6B15  bl 0x822c8cb8
	ctx.lr = 0x828221A8;
	sub_822C8CB8(ctx, base);
	// 828221A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828221AC: 485D127D  bl 0x82df3428
	ctx.lr = 0x828221B0;
	sub_82DF3428(ctx, base);
	// 828221B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828221B4: 485D1275  bl 0x82df3428
	ctx.lr = 0x828221B8;
	sub_82DF3428(ctx, base);
	// 828221B8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828221BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828221C0: 388BA094  addi r4, r11, -0x5f6c
	ctx.r[4].s64 = ctx.r[11].s64 + -24428;
	// 828221C4: 485D1845  bl 0x82df3a08
	ctx.lr = 0x828221C8;
	sub_82DF3A08(ctx, base);
	// 828221C8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828221CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828221D0: 388BA088  addi r4, r11, -0x5f78
	ctx.r[4].s64 = ctx.r[11].s64 + -24440;
	// 828221D4: 485D1835  bl 0x82df3a08
	ctx.lr = 0x828221D8;
	sub_82DF3A08(ctx, base);
	// 828221D8: 38BC0100  addi r5, r28, 0x100
	ctx.r[5].s64 = ctx.r[28].s64 + 256;
	// 828221DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828221E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828221E4: 4BD80E6D  bl 0x825a3050
	ctx.lr = 0x828221E8;
	sub_825A3050(ctx, base);
	// 828221E8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828221EC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828221F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828221F4: 4BD7FF95  bl 0x825a2188
	ctx.lr = 0x828221F8;
	sub_825A2188(ctx, base);
	// 828221F8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828221FC: 485D122D  bl 0x82df3428
	ctx.lr = 0x82822200;
	sub_82DF3428(ctx, base);
	// 82822200: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82822204: 4BAA6AB5  bl 0x822c8cb8
	ctx.lr = 0x82822208;
	sub_822C8CB8(ctx, base);
	// 82822208: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8282220C: 485D121D  bl 0x82df3428
	ctx.lr = 0x82822210;
	sub_82DF3428(ctx, base);
	// 82822210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822214: 485D1215  bl 0x82df3428
	ctx.lr = 0x82822218;
	sub_82DF3428(ctx, base);
	// 82822218: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8282221C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82822220: 4BFFC6D1  bl 0x8281e8f0
	ctx.lr = 0x82822224;
	sub_8281E8F0(ctx, base);
	// 82822224: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82822228: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8282222C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82822230: 48985F84  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82822238 size=120
    let mut pc: u32 = 0x82822238;
    'dispatch: loop {
        match pc {
            0x82822238 => {
    //   block [0x82822238..0x828222B0)
	// 82822238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282223C: 48985F31  bl 0x831a816c
	ctx.lr = 0x82822240;
	sub_831A8130(ctx, base);
	// 82822240: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82822244: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82822248: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8282224C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82822250: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82822254: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82822258: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8282225C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82822260: 485D0189  bl 0x82df23e8
	ctx.lr = 0x82822264;
	sub_82DF23E8(ctx, base);
	// 82822264: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82822268: 41820014  beq 0x8282227c
	if ctx.cr[0].eq {
	pc = 0x8282227C; continue 'dispatch;
	}
	// 8282226C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82822270: 48330711  bl 0x82b52980
	ctx.lr = 0x82822274;
	sub_82B52980(ctx, base);
	// 82822274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82822278: 48000008  b 0x82822280
	pc = 0x82822280; continue 'dispatch;
	// 8282227C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82822280: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82822284: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82822288: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282228C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82822290: 4BFFF4C1  bl 0x82821750
	ctx.lr = 0x82822294;
	sub_82821750(ctx, base);
	// 82822294: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82822298: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8282229C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828222A0: 4BA9DD61  bl 0x822c0000
	ctx.lr = 0x828222A4;
	sub_822C0000(ctx, base);
	// 828222A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828222A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828222AC: 48985F10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828222B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828222B0 size=380
    let mut pc: u32 = 0x828222B0;
    'dispatch: loop {
        match pc {
            0x828222B0 => {
    //   block [0x828222B0..0x8282242C)
	// 828222B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828222B4: 48985EB9  bl 0x831a816c
	ctx.lr = 0x828222B8;
	sub_831A8130(ctx, base);
	// 828222B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828222BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828222C0: 817E0304  lwz r11, 0x304(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(772 as u32) ) } as u64;
	// 828222C4: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828222C8: 408200AC  bne 0x82822374
	if !ctx.cr[0].eq {
	pc = 0x82822374; continue 'dispatch;
	}
	// 828222CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828222D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828222D4: 388BA070  addi r4, r11, -0x5f90
	ctx.r[4].s64 = ctx.r[11].s64 + -24464;
	// 828222D8: 4BFFFF61  bl 0x82822238
	ctx.lr = 0x828222DC;
	sub_82822238(ctx, base);
	// 828222DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828222E0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828222E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828222E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828222EC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828222F0: 419A0024  beq cr6, 0x82822314
	if ctx.cr[6].eq {
	pc = 0x82822314; continue 'dispatch;
	}
	// 828222F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828222F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828222FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82822300: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82822304: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82822308: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8282230C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82822310: 4082FFE8  bne 0x828222f8
	if !ctx.cr[0].eq {
	pc = 0x828222F8; continue 'dispatch;
	}
	// 82822314: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 82822318: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 8282231C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822320: 487E6C99  bl 0x83008fb8
	ctx.lr = 0x82822324;
	sub_83008FB8(ctx, base);
	// 82822324: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82822328: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8282232C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82822330: 388AA0E8  addi r4, r10, -0x5f18
	ctx.r[4].s64 = ctx.r[10].s64 + -24344;
	// 82822334: 38A0016C  li r5, 0x16c
	ctx.r[5].s64 = 364;
	// 82822338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282233C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82822340: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82822344: 486366FD  bl 0x82e58a40
	ctx.lr = 0x82822348;
	sub_82E58A40(ctx, base);
	// 82822348: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8282234C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82822350: 419A0008  beq cr6, 0x82822358
	if ctx.cr[6].eq {
	pc = 0x82822358; continue 'dispatch;
	}
	// 82822354: 4BA9E53D  bl 0x822c0890
	ctx.lr = 0x82822358;
	sub_822C0890(ctx, base);
	// 82822358: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8282235C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82822360: 419A0008  beq cr6, 0x82822368
	if ctx.cr[6].eq {
	pc = 0x82822368; continue 'dispatch;
	}
	// 82822364: 4BA9E52D  bl 0x822c0890
	ctx.lr = 0x82822368;
	sub_822C0890(ctx, base);
	// 82822368: 817E0304  lwz r11, 0x304(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(772 as u32) ) } as u64;
	// 8282236C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82822370: 480000B0  b 0x82822420
	pc = 0x82822420; continue 'dispatch;
	// 82822374: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82822378: 408200AC  bne 0x82822424
	if !ctx.cr[0].eq {
	pc = 0x82822424; continue 'dispatch;
	}
	// 8282237C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822380: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82822384: 388BA07C  addi r4, r11, -0x5f84
	ctx.r[4].s64 = ctx.r[11].s64 + -24452;
	// 82822388: 4BFFFEB1  bl 0x82822238
	ctx.lr = 0x8282238C;
	sub_82822238(ctx, base);
	// 8282238C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82822390: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82822394: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82822398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8282239C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828223A0: 419A0024  beq cr6, 0x828223c4
	if ctx.cr[6].eq {
	pc = 0x828223C4; continue 'dispatch;
	}
	// 828223A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828223A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828223AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828223B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828223B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828223B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828223BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828223C0: 4082FFE8  bne 0x828223a8
	if !ctx.cr[0].eq {
	pc = 0x828223A8; continue 'dispatch;
	}
	// 828223C4: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 828223C8: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 828223CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828223D0: 487E6BE9  bl 0x83008fb8
	ctx.lr = 0x828223D4;
	sub_83008FB8(ctx, base);
	// 828223D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828223D8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828223DC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828223E0: 388AA0E8  addi r4, r10, -0x5f18
	ctx.r[4].s64 = ctx.r[10].s64 + -24344;
	// 828223E4: 38A00171  li r5, 0x171
	ctx.r[5].s64 = 369;
	// 828223E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828223EC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828223F0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828223F4: 4863664D  bl 0x82e58a40
	ctx.lr = 0x828223F8;
	sub_82E58A40(ctx, base);
	// 828223F8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828223FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82822400: 419A0008  beq cr6, 0x82822408
	if ctx.cr[6].eq {
	pc = 0x82822408; continue 'dispatch;
	}
	// 82822404: 4BA9E48D  bl 0x822c0890
	ctx.lr = 0x82822408;
	sub_822C0890(ctx, base);
	// 82822408: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8282240C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82822410: 419A0008  beq cr6, 0x82822418
	if ctx.cr[6].eq {
	pc = 0x82822418; continue 'dispatch;
	}
	// 82822414: 4BA9E47D  bl 0x822c0890
	ctx.lr = 0x82822418;
	sub_822C0890(ctx, base);
	// 82822418: 817E0304  lwz r11, 0x304(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(772 as u32) ) } as u64;
	// 8282241C: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 82822420: 917E0304  stw r11, 0x304(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(772 as u32), ctx.r[11].u32 ) };
	// 82822424: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82822428: 48985D94  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82822430 size=476
    let mut pc: u32 = 0x82822430;
    'dispatch: loop {
        match pc {
            0x82822430 => {
    //   block [0x82822430..0x8282260C)
	// 82822430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82822434: 48985D31  bl 0x831a8164
	ctx.lr = 0x82822438;
	sub_831A8130(ctx, base);
	// 82822438: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8282243C: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82822440: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822444: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82822448: 3BCBA0E8  addi r30, r11, -0x5f18
	ctx.r[30].s64 = ctx.r[11].s64 + -24344;
	// 8282244C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82822450: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82822454: 38A00050  li r5, 0x50
	ctx.r[5].s64 = 80;
	// 82822458: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8282245C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82822460: 38600310  li r3, 0x310
	ctx.r[3].s64 = 784;
	// 82822464: 485CFF85  bl 0x82df23e8
	ctx.lr = 0x82822468;
	sub_82DF23E8(ctx, base);
	// 82822468: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8282246C: 41820010  beq 0x8282247c
	if ctx.cr[0].eq {
	pc = 0x8282247C; continue 'dispatch;
	}
	// 82822470: 4BFFF0C9  bl 0x82821538
	ctx.lr = 0x82822474;
	sub_82821538(ctx, base);
	// 82822474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82822478: 48000008  b 0x82822480
	pc = 0x82822480; continue 'dispatch;
	// 8282247C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82822480: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82822484: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82822488: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8282248C: 4BFFF1FD  bl 0x82821688
	ctx.lr = 0x82822490;
	sub_82821688(ctx, base);
	// 82822490: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82822494: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82822498: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8282249C: 4BA9DB65  bl 0x822c0000
	ctx.lr = 0x828224A0;
	sub_822C0000(ctx, base);
	// 828224A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828224A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828224A8: 38A00051  li r5, 0x51
	ctx.r[5].s64 = 81;
	// 828224AC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828224B0: 4BA9DF29  bl 0x822c03d8
	ctx.lr = 0x828224B4;
	sub_822C03D8(ctx, base);
	// 828224B4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828224B8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828224BC: 418200E0  beq 0x8282259c
	if ctx.cr[0].eq {
	pc = 0x8282259C; continue 'dispatch;
	}
	// 828224C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828224C4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828224C8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828224CC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828224D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828224D4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828224D8: 396A0208  addi r11, r10, 0x208
	ctx.r[11].s64 = ctx.r[10].s64 + 520;
	// 828224DC: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828224E0: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828224E4: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828224E8: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828224EC: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828224F0: 409A0008  bne cr6, 0x828224f8
	if !ctx.cr[6].eq {
	pc = 0x828224F8; continue 'dispatch;
	}
	// 828224F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828224F8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828224FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82822500: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82822504: 419A0024  beq cr6, 0x82822528
	if ctx.cr[6].eq {
	pc = 0x82822528; continue 'dispatch;
	}
	// 82822508: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8282250C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82822510: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82822514: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82822518: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8282251C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82822520: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82822524: 4082FFE8  bne 0x8282250c
	if !ctx.cr[0].eq {
	pc = 0x8282250C; continue 'dispatch;
	}
	// 82822528: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8282252C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82822530: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82822534: 419A0024  beq cr6, 0x82822558
	if ctx.cr[6].eq {
	pc = 0x82822558; continue 'dispatch;
	}
	// 82822538: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8282253C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82822540: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82822544: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82822548: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8282254C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82822550: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82822554: 4082FFE8  bne 0x8282253c
	if !ctx.cr[0].eq {
	pc = 0x8282253C; continue 'dispatch;
	}
	// 82822558: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8282255C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82822560: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82822564: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82822568: 4865A6D9  bl 0x82e7cc40
	ctx.lr = 0x8282256C;
	sub_82E7CC40(ctx, base);
	// 8282256C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82822570: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82822574: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82822578: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8282257C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82822580: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82822584: 4BF769AD  bl 0x82798f30
	ctx.lr = 0x82822588;
	sub_82798F30(ctx, base);
	// 82822588: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8282258C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822590: 4BF790D9  bl 0x8279b668
	ctx.lr = 0x82822594;
	sub_8279B668(ctx, base);
	// 82822594: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82822598: 48000008  b 0x828225a0
	pc = 0x828225A0; continue 'dispatch;
	// 8282259C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828225A0: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828225A4: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828225A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828225AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828225B0: 4BD756A1  bl 0x82597c50
	ctx.lr = 0x828225B4;
	sub_82597C50(ctx, base);
	// 828225B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828225B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828225BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828225C0: 4BA9DA41  bl 0x822c0000
	ctx.lr = 0x828225C4;
	sub_822C0000(ctx, base);
	// 828225C4: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828225C8: 41820024  beq 0x828225ec
	if ctx.cr[0].eq {
	pc = 0x828225EC; continue 'dispatch;
	}
	// 828225CC: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828225D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828225D4: 419A0008  beq cr6, 0x828225dc
	if ctx.cr[6].eq {
	pc = 0x828225DC; continue 'dispatch;
	}
	// 828225D8: 4BA9E2B9  bl 0x822c0890
	ctx.lr = 0x828225DC;
	sub_822C0890(ctx, base);
	// 828225DC: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828225E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828225E4: 419A0008  beq cr6, 0x828225ec
	if ctx.cr[6].eq {
	pc = 0x828225EC; continue 'dispatch;
	}
	// 828225E8: 4BA9E2A9  bl 0x822c0890
	ctx.lr = 0x828225EC;
	sub_822C0890(ctx, base);
	// 828225EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828225F0: 419A000C  beq cr6, 0x828225fc
	if ctx.cr[6].eq {
	pc = 0x828225FC; continue 'dispatch;
	}
	// 828225F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828225F8: 4BA9E299  bl 0x822c0890
	ctx.lr = 0x828225FC;
	sub_822C0890(ctx, base);
	// 828225FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82822600: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82822604: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82822608: 48985BAC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82822610 size=128
    let mut pc: u32 = 0x82822610;
    'dispatch: loop {
        match pc {
            0x82822610 => {
    //   block [0x82822610..0x82822690)
	// 82822610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82822614: 48985B59  bl 0x831a816c
	ctx.lr = 0x82822618;
	sub_831A8130(ctx, base);
	// 82822618: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282261C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82822620: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82822624: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82822628: 3BEBAF10  addi r31, r11, -0x50f0
	ctx.r[31].s64 = ctx.r[11].s64 + -20720;
	// 8282262C: 816AAF18  lwz r11, -0x50e8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20712 as u32) ) } as u64;
	// 82822630: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82822634: 40820024  bne 0x82822658
	if !ctx.cr[0].eq {
	pc = 0x82822658; continue 'dispatch;
	}
	// 82822638: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 8282263C: 3D008282  lis r8, -0x7d7e
	ctx.r[8].s64 = -2105409536;
	// 82822640: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82822644: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 82822648: 39081818  addi r8, r8, 0x1818
	ctx.r[8].s64 = ctx.r[8].s64 + 6168;
	// 8282264C: 916AAF18  stw r11, -0x50e8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-20712 as u32), ctx.r[11].u32 ) };
	// 82822650: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82822654: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82822658: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8282265C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82822660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822664: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82822668: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 8282266C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82822670: 4BE31F51  bl 0x826545c0
	ctx.lr = 0x82822674;
	sub_826545C0(ctx, base);
	// 82822674: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82822678: 4182000C  beq 0x82822684
	if ctx.cr[0].eq {
	pc = 0x82822684; continue 'dispatch;
	}
	// 8282267C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82822680: 48000008  b 0x82822688
	pc = 0x82822688; continue 'dispatch;
	// 82822684: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82822688: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8282268C: 48985B30  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82822690 size=128
    let mut pc: u32 = 0x82822690;
    'dispatch: loop {
        match pc {
            0x82822690 => {
    //   block [0x82822690..0x82822710)
	// 82822690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82822694: 48985AD9  bl 0x831a816c
	ctx.lr = 0x82822698;
	sub_831A8130(ctx, base);
	// 82822698: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282269C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828226A0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828226A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828226A8: 3BEBAF1C  addi r31, r11, -0x50e4
	ctx.r[31].s64 = ctx.r[11].s64 + -20708;
	// 828226AC: 816AAF24  lwz r11, -0x50dc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20700 as u32) ) } as u64;
	// 828226B0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828226B4: 40820024  bne 0x828226d8
	if !ctx.cr[0].eq {
	pc = 0x828226D8; continue 'dispatch;
	}
	// 828226B8: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 828226BC: 3D008282  lis r8, -0x7d7e
	ctx.r[8].s64 = -2105409536;
	// 828226C0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828226C4: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 828226C8: 39081860  addi r8, r8, 0x1860
	ctx.r[8].s64 = ctx.r[8].s64 + 6240;
	// 828226CC: 916AAF24  stw r11, -0x50dc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-20700 as u32), ctx.r[11].u32 ) };
	// 828226D0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828226D4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828226D8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828226DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828226E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828226E4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828226E8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828226EC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828226F0: 4BE31ED1  bl 0x826545c0
	ctx.lr = 0x828226F4;
	sub_826545C0(ctx, base);
	// 828226F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828226F8: 4182000C  beq 0x82822704
	if ctx.cr[0].eq {
	pc = 0x82822704; continue 'dispatch;
	}
	// 828226FC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82822700: 48000008  b 0x82822708
	pc = 0x82822708; continue 'dispatch;
	// 82822704: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82822708: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8282270C: 48985AB0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82822710 size=1296
    let mut pc: u32 = 0x82822710;
    'dispatch: loop {
        match pc {
            0x82822710 => {
    //   block [0x82822710..0x82822C20)
	// 82822710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82822714: 48985A45  bl 0x831a8158
	ctx.lr = 0x82822718;
	sub_831A8130(ctx, base);
	// 82822718: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 8282271C: 4898635D  bl 0x831a8a78
	ctx.lr = 0x82822720;
	sub_831A8A40(ctx, base);
	// 82822720: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82822724: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82822728: 4BFFD009  bl 0x8281f730
	ctx.lr = 0x8282272C;
	sub_8281F730(ctx, base);
	// 8282272C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82822730: 4BFC9AA1  bl 0x827ec1d0
	ctx.lr = 0x82822734;
	sub_827EC1D0(ctx, base);
	// 82822734: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82822738: 418204C4  beq 0x82822bfc
	if ctx.cr[0].eq {
	pc = 0x82822BFC; continue 'dispatch;
	}
	// 8282273C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822744: 388B9F10  addi r4, r11, -0x60f0
	ctx.r[4].s64 = ctx.r[11].s64 + -24816;
	// 82822748: 485D12C1  bl 0x82df3a08
	ctx.lr = 0x8282274C;
	sub_82DF3A08(ctx, base);
	// 8282274C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82822750: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82822754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822758: C38B964C  lfs f28, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8282275C: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82822760: 4BFC7BD9  bl 0x827ea338
	ctx.lr = 0x82822764;
	sub_827EA338(ctx, base);
	// 82822764: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822768: 485D0CC1  bl 0x82df3428
	ctx.lr = 0x8282276C;
	sub_82DF3428(ctx, base);
	// 8282276C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822774: 388B9EE4  addi r4, r11, -0x611c
	ctx.r[4].s64 = ctx.r[11].s64 + -24860;
	// 82822778: 485D1291  bl 0x82df3a08
	ctx.lr = 0x8282277C;
	sub_82DF3A08(ctx, base);
	// 8282277C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82822780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822784: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82822788: 4BFC7BB1  bl 0x827ea338
	ctx.lr = 0x8282278C;
	sub_827EA338(ctx, base);
	// 8282278C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822790: 485D0C99  bl 0x82df3428
	ctx.lr = 0x82822794;
	sub_82DF3428(ctx, base);
	// 82822794: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822798: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282279C: 3BCB9ED4  addi r30, r11, -0x612c
	ctx.r[30].s64 = ctx.r[11].s64 + -24876;
	// 828227A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828227A4: 485D1265  bl 0x82df3a08
	ctx.lr = 0x828227A8;
	sub_82DF3A08(ctx, base);
	// 828227A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828227AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828227B0: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828227B4: 4BFC7B85  bl 0x827ea338
	ctx.lr = 0x828227B8;
	sub_827EA338(ctx, base);
	// 828227B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828227BC: 485D0C6D  bl 0x82df3428
	ctx.lr = 0x828227C0;
	sub_82DF3428(ctx, base);
	// 828227C0: 3D608282  lis r11, -0x7d7e
	ctx.r[11].s64 = -2105409536;
	// 828227C4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828227C8: 396B1258  addi r11, r11, 0x1258
	ctx.r[11].s64 = ctx.r[11].s64 + 4696;
	// 828227CC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828227D0: 388AA198  addi r4, r10, -0x5e68
	ctx.r[4].s64 = ctx.r[10].s64 + -24168;
	// 828227D4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828227D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828227DC: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828227E0: 485D1229  bl 0x82df3a08
	ctx.lr = 0x828227E4;
	sub_82DF3A08(ctx, base);
	// 828227E4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828227E8: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828227EC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828227F0: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828227F4: 938100B0  stw r28, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[28].u32 ) };
	// 828227F8: 4BFFFE19  bl 0x82822610
	ctx.lr = 0x828227FC;
	sub_82822610(ctx, base);
	// 828227FC: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 82822800: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82822804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822808: 4BFC8001  bl 0x827ea808
	ctx.lr = 0x8282280C;
	sub_827EA808(ctx, base);
	// 8282280C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822810: 485D0C19  bl 0x82df3428
	ctx.lr = 0x82822814;
	sub_82DF3428(ctx, base);
	// 82822814: 3D608282  lis r11, -0x7d7e
	ctx.r[11].s64 = -2105409536;
	// 82822818: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8282281C: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82822820: 396B1328  addi r11, r11, 0x1328
	ctx.r[11].s64 = ctx.r[11].s64 + 4904;
	// 82822824: 388AA188  addi r4, r10, -0x5e78
	ctx.r[4].s64 = ctx.r[10].s64 + -24184;
	// 82822828: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282282C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82822830: 485D11D9  bl 0x82df3a08
	ctx.lr = 0x82822834;
	sub_82DF3A08(ctx, base);
	// 82822834: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82822838: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 8282283C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82822840: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82822844: 938100B0  stw r28, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[28].u32 ) };
	// 82822848: 4BFFFDC9  bl 0x82822610
	ctx.lr = 0x8282284C;
	sub_82822610(ctx, base);
	// 8282284C: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 82822850: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82822854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822858: 4BFC7FB1  bl 0x827ea808
	ctx.lr = 0x8282285C;
	sub_827EA808(ctx, base);
	// 8282285C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822860: 485D0BC9  bl 0x82df3428
	ctx.lr = 0x82822864;
	sub_82DF3428(ctx, base);
	// 82822864: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822868: 3D408282  lis r10, -0x7d7e
	ctx.r[10].s64 = -2105409536;
	// 8282286C: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82822870: 388BA178  addi r4, r11, -0x5e88
	ctx.r[4].s64 = ctx.r[11].s64 + -24200;
	// 82822874: 396A1400  addi r11, r10, 0x1400
	ctx.r[11].s64 = ctx.r[10].s64 + 5120;
	// 82822878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282287C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82822880: 485D1189  bl 0x82df3a08
	ctx.lr = 0x82822884;
	sub_82DF3A08(ctx, base);
	// 82822884: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82822888: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 8282288C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82822890: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82822894: 938100B0  stw r28, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[28].u32 ) };
	// 82822898: 4BFFFD79  bl 0x82822610
	ctx.lr = 0x8282289C;
	sub_82822610(ctx, base);
	// 8282289C: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 828228A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828228A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828228A8: 4BFC7F61  bl 0x827ea808
	ctx.lr = 0x828228AC;
	sub_827EA808(ctx, base);
	// 828228AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828228B0: 485D0B79  bl 0x82df3428
	ctx.lr = 0x828228B4;
	sub_82DF3428(ctx, base);
	// 828228B4: 3D608282  lis r11, -0x7d7e
	ctx.r[11].s64 = -2105409536;
	// 828228B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828228BC: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828228C0: 396B22B0  addi r11, r11, 0x22b0
	ctx.r[11].s64 = ctx.r[11].s64 + 8880;
	// 828228C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828228C8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828228CC: 485D113D  bl 0x82df3a08
	ctx.lr = 0x828228D0;
	sub_82DF3A08(ctx, base);
	// 828228D0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828228D4: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828228D8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828228DC: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828228E0: 938100B0  stw r28, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[28].u32 ) };
	// 828228E4: 4BFFFDAD  bl 0x82822690
	ctx.lr = 0x828228E8;
	sub_82822690(ctx, base);
	// 828228E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828228EC: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 828228F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828228F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828228F8: C02B959C  lfs f1, -0x6a64(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828228FC: 4BFC7EB5  bl 0x827ea7b0
	ctx.lr = 0x82822900;
	sub_827EA7B0(ctx, base);
	// 82822900: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822904: 485D0B25  bl 0x82df3428
	ctx.lr = 0x82822908;
	sub_82DF3428(ctx, base);
	// 82822908: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282290C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822910: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82822914: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82822918: 4E800421  bctrl
	ctx.lr = 0x8282291C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8282291C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82822920: 418200B4  beq 0x828229d4
	if ctx.cr[0].eq {
	pc = 0x828229D4; continue 'dispatch;
	}
	// 82822924: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82822928: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282292C: 388BF818  addi r4, r11, -0x7e8
	ctx.r[4].s64 = ctx.r[11].s64 + -2024;
	// 82822930: 485D10D9  bl 0x82df3a08
	ctx.lr = 0x82822934;
	sub_82DF3A08(ctx, base);
	// 82822934: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82822938: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282293C: 48391F4D  bl 0x82bb4888
	ctx.lr = 0x82822940;
	sub_82BB4888(ctx, base);
	// 82822940: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 82822944: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822948: 917D02EC  stw r11, 0x2ec(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(748 as u32), ctx.r[11].u32 ) };
	// 8282294C: 485D0ADD  bl 0x82df3428
	ctx.lr = 0x82822950;
	sub_82DF3428(ctx, base);
	// 82822950: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82822954: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822958: 388BF820  addi r4, r11, -0x7e0
	ctx.r[4].s64 = ctx.r[11].s64 + -2016;
	// 8282295C: 485D10AD  bl 0x82df3a08
	ctx.lr = 0x82822960;
	sub_82DF3A08(ctx, base);
	// 82822960: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82822964: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82822968: 48391F21  bl 0x82bb4888
	ctx.lr = 0x8282296C;
	sub_82BB4888(ctx, base);
	// 8282296C: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 82822970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822974: 917D02E8  stw r11, 0x2e8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(744 as u32), ctx.r[11].u32 ) };
	// 82822978: 485D0AB1  bl 0x82df3428
	ctx.lr = 0x8282297C;
	sub_82DF3428(ctx, base);
	// 8282297C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822984: 388BA16C  addi r4, r11, -0x5e94
	ctx.r[4].s64 = ctx.r[11].s64 + -24212;
	// 82822988: 485D1081  bl 0x82df3a08
	ctx.lr = 0x8282298C;
	sub_82DF3A08(ctx, base);
	// 8282298C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82822990: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82822994: 48391EF5  bl 0x82bb4888
	ctx.lr = 0x82822998;
	sub_82BB4888(ctx, base);
	// 82822998: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 8282299C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828229A0: 917D02F4  stw r11, 0x2f4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(756 as u32), ctx.r[11].u32 ) };
	// 828229A4: 485D0A85  bl 0x82df3428
	ctx.lr = 0x828229A8;
	sub_82DF3428(ctx, base);
	// 828229A8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828229AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828229B0: 388BA160  addi r4, r11, -0x5ea0
	ctx.r[4].s64 = ctx.r[11].s64 + -24224;
	// 828229B4: 485D1055  bl 0x82df3a08
	ctx.lr = 0x828229B8;
	sub_82DF3A08(ctx, base);
	// 828229B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828229BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828229C0: 48391EC9  bl 0x82bb4888
	ctx.lr = 0x828229C4;
	sub_82BB4888(ctx, base);
	// 828229C4: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 828229C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828229CC: 917D02F0  stw r11, 0x2f0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(752 as u32), ctx.r[11].u32 ) };
	// 828229D0: 485D0A59  bl 0x82df3428
	ctx.lr = 0x828229D4;
	sub_82DF3428(ctx, base);
	// 828229D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828229D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828229DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828229E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828229E4: 4E800421  bctrl
	ctx.lr = 0x828229E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828229E8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828229EC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828229F0: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 828229F4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828229F8: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828229FC: C3A92984  lfs f29, 0x2984(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10628 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82822A00: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82822A04: C3E808A4  lfs f31, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82822A08: 3B6BA0E8  addi r27, r11, -0x5f18
	ctx.r[27].s64 = ctx.r[11].s64 + -24344;
	// 82822A0C: C3C708A8  lfs f30, 0x8a8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82822A10: 3B4A3F2C  addi r26, r10, 0x3f2c
	ctx.r[26].s64 = ctx.r[10].s64 + 16172;
	// 82822A14: 418200E8  beq 0x82822afc
	if ctx.cr[0].eq {
	pc = 0x82822AFC; continue 'dispatch;
	}
	// 82822A18: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82822A1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822A20: 485D0FE9  bl 0x82df3a08
	ctx.lr = 0x82822A24;
	sub_82DF3A08(ctx, base);
	// 82822A24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82822A28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82822A2C: 4838B235  bl 0x82badc60
	ctx.lr = 0x82822A30;
	sub_82BADC60(ctx, base);
	// 82822A30: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82822A34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822A38: 485D09F1  bl 0x82df3428
	ctx.lr = 0x82822A3C;
	sub_82DF3428(ctx, base);
	// 82822A3C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822A40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822A44: 388BA154  addi r4, r11, -0x5eac
	ctx.r[4].s64 = ctx.r[11].s64 + -24236;
	// 82822A48: 485D0FC1  bl 0x82df3a08
	ctx.lr = 0x82822A4C;
	sub_82DF3A08(ctx, base);
	// 82822A4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82822A50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82822A54: 4838B20D  bl 0x82badc60
	ctx.lr = 0x82822A58;
	sub_82BADC60(ctx, base);
	// 82822A58: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82822A5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822A60: 485D09C9  bl 0x82df3428
	ctx.lr = 0x82822A64;
	sub_82DF3428(ctx, base);
	// 82822A64: D3C10060  stfs f30, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82822A68: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82822A6C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82822A70: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82822A74: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82822A78: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82822A7C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82822A80: D3C10070  stfs f30, 0x70(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82822A84: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82822A88: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82822A8C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82822A90: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82822A94: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82822A98: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82822A9C: 4815A755  bl 0x8297d1f0
	ctx.lr = 0x82822AA0;
	sub_8297D1F0(ctx, base);
	// 82822AA0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82822AA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82822AA8: 38A00099  li r5, 0x99
	ctx.r[5].s64 = 153;
	// 82822AAC: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82822AB0: 4BA9D929  bl 0x822c03d8
	ctx.lr = 0x82822AB4;
	sub_822C03D8(ctx, base);
	// 82822AB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82822AB8: 41820018  beq 0x82822ad0
	if ctx.cr[0].eq {
	pc = 0x82822AD0; continue 'dispatch;
	}
	// 82822ABC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82822AC0: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82822AC4: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82822AC8: 4815A771  bl 0x8297d238
	ctx.lr = 0x82822ACC;
	sub_8297D238(ctx, base);
	// 82822ACC: 48000008  b 0x82822ad4
	pc = 0x82822AD4; continue 'dispatch;
	// 82822AD0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82822AD4: 817D02E0  lwz r11, 0x2e0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(736 as u32) ) } as u64;
	// 82822AD8: 907D02E0  stw r3, 0x2e0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(736 as u32), ctx.r[3].u32 ) };
	// 82822ADC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82822AE0: 419A001C  beq cr6, 0x82822afc
	if ctx.cr[6].eq {
	pc = 0x82822AFC; continue 'dispatch;
	}
	// 82822AE4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82822AE8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82822AEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82822AF0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82822AF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82822AF8: 4E800421  bctrl
	ctx.lr = 0x82822AFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82822AFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82822B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822B04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82822B08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82822B0C: 4E800421  bctrl
	ctx.lr = 0x82822B10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82822B10: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82822B14: 418200E8  beq 0x82822bfc
	if ctx.cr[0].eq {
	pc = 0x82822BFC; continue 'dispatch;
	}
	// 82822B18: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82822B1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822B20: 485D0EE9  bl 0x82df3a08
	ctx.lr = 0x82822B24;
	sub_82DF3A08(ctx, base);
	// 82822B24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82822B28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822B2C: 4838B135  bl 0x82badc60
	ctx.lr = 0x82822B30;
	sub_82BADC60(ctx, base);
	// 82822B30: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82822B34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822B38: 485D08F1  bl 0x82df3428
	ctx.lr = 0x82822B3C;
	sub_82DF3428(ctx, base);
	// 82822B3C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822B40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822B44: 388BA148  addi r4, r11, -0x5eb8
	ctx.r[4].s64 = ctx.r[11].s64 + -24248;
	// 82822B48: 485D0EC1  bl 0x82df3a08
	ctx.lr = 0x82822B4C;
	sub_82DF3A08(ctx, base);
	// 82822B4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82822B50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822B54: 4838B10D  bl 0x82badc60
	ctx.lr = 0x82822B58;
	sub_82BADC60(ctx, base);
	// 82822B58: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82822B5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822B60: 485D08C9  bl 0x82df3428
	ctx.lr = 0x82822B64;
	sub_82DF3428(ctx, base);
	// 82822B64: D3C10080  stfs f30, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82822B68: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82822B6C: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82822B70: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82822B74: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 82822B78: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82822B7C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82822B80: D3C10090  stfs f30, 0x90(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82822B84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82822B88: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82822B8C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82822B90: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82822B94: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82822B98: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82822B9C: 4815A655  bl 0x8297d1f0
	ctx.lr = 0x82822BA0;
	sub_8297D1F0(ctx, base);
	// 82822BA0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82822BA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82822BA8: 38A000A1  li r5, 0xa1
	ctx.r[5].s64 = 161;
	// 82822BAC: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82822BB0: 4BA9D829  bl 0x822c03d8
	ctx.lr = 0x82822BB4;
	sub_822C03D8(ctx, base);
	// 82822BB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82822BB8: 41820018  beq 0x82822bd0
	if ctx.cr[0].eq {
	pc = 0x82822BD0; continue 'dispatch;
	}
	// 82822BBC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82822BC0: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82822BC4: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82822BC8: 4815A671  bl 0x8297d238
	ctx.lr = 0x82822BCC;
	sub_8297D238(ctx, base);
	// 82822BCC: 48000008  b 0x82822bd4
	pc = 0x82822BD4; continue 'dispatch;
	// 82822BD0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82822BD4: 817D02E4  lwz r11, 0x2e4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(740 as u32) ) } as u64;
	// 82822BD8: 907D02E4  stw r3, 0x2e4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(740 as u32), ctx.r[3].u32 ) };
	// 82822BDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82822BE0: 419A001C  beq cr6, 0x82822bfc
	if ctx.cr[6].eq {
	pc = 0x82822BFC; continue 'dispatch;
	}
	// 82822BE4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82822BE8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82822BEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82822BF0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82822BF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82822BF8: 4E800421  bctrl
	ctx.lr = 0x82822BFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82822BFC: 897D0308  lbz r11, 0x308(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(776 as u32) ) } as u64;
	// 82822C00: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82822C04: 4082000C  bne 0x82822c10
	if !ctx.cr[0].eq {
	pc = 0x82822C10; continue 'dispatch;
	}
	// 82822C08: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82822C0C: 917D0304  stw r11, 0x304(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(772 as u32), ctx.r[11].u32 ) };
	// 82822C10: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82822C14: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82822C18: 48985EAD  bl 0x831a8ac4
	ctx.lr = 0x82822C1C;
	sub_831A8A8C(ctx, base);
	// 82822C1C: 4898558C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82822C20 size=84
    let mut pc: u32 = 0x82822C20;
    'dispatch: loop {
        match pc {
            0x82822C20 => {
    //   block [0x82822C20..0x82822C74)
	// 82822C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82822C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82822C28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82822C2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82822C30: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82822C34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82822C38: 388BAF78  addi r4, r11, -0x5088
	ctx.r[4].s64 = ctx.r[11].s64 + -20616;
	// 82822C3C: 4BFCDBED  bl 0x827f0828
	ctx.lr = 0x82822C40;
	sub_827F0828(ctx, base);
	// 82822C40: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82822C44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822C48: 388BAF94  addi r4, r11, -0x506c
	ctx.r[4].s64 = ctx.r[11].s64 + -20588;
	// 82822C4C: 4BFD34A5  bl 0x827f60f0
	ctx.lr = 0x82822C50;
	sub_827F60F0(ctx, base);
	// 82822C50: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82822C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822C58: 388BAFA4  addi r4, r11, -0x505c
	ctx.r[4].s64 = ctx.r[11].s64 + -20572;
	// 82822C5C: 4BFCDE6D  bl 0x827f0ac8
	ctx.lr = 0x82822C60;
	sub_827F0AC8(ctx, base);
	// 82822C60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82822C64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82822C68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82822C6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82822C70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82822C78 size=100
    let mut pc: u32 = 0x82822C78;
    'dispatch: loop {
        match pc {
            0x82822C78 => {
    //   block [0x82822C78..0x82822CDC)
	// 82822C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82822C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82822C80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82822C84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82822C88: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82822C8C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82822C90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82822C94: C04B959C  lfs f2, -0x6a64(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82822C98: C02A9648  lfs f1, -0x69b8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27064 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82822C9C: 4BFFD0AD  bl 0x8281fd48
	ctx.lr = 0x82822CA0;
	sub_8281FD48(ctx, base);
	// 82822CA0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822CA4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82822CA8: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82822CAC: 396BA204  addi r11, r11, -0x5dfc
	ctx.r[11].s64 = ctx.r[11].s64 + -24060;
	// 82822CB0: 394AA1F0  addi r10, r10, -0x5e10
	ctx.r[10].s64 = ctx.r[10].s64 + -24080;
	// 82822CB4: 3929A1A4  addi r9, r9, -0x5e5c
	ctx.r[9].s64 = ctx.r[9].s64 + -24156;
	// 82822CB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82822CBC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82822CC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822CC4: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 82822CC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82822CCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82822CD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82822CD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82822CD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82822CE0 size=40
    let mut pc: u32 = 0x82822CE0;
    'dispatch: loop {
        match pc {
            0x82822CE0 => {
    //   block [0x82822CE0..0x82822D08)
	// 82822CE0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822CE4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82822CE8: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82822CEC: 396BA204  addi r11, r11, -0x5dfc
	ctx.r[11].s64 = ctx.r[11].s64 + -24060;
	// 82822CF0: 394AA1F0  addi r10, r10, -0x5e10
	ctx.r[10].s64 = ctx.r[10].s64 + -24080;
	// 82822CF4: 3929A1A4  addi r9, r9, -0x5e5c
	ctx.r[9].s64 = ctx.r[9].s64 + -24156;
	// 82822CF8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82822CFC: 91430028  stw r10, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82822D00: 91230208  stw r9, 0x208(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 82822D04: 4BFFC46C  b 0x8281f170
	sub_8281F170(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82822D08 size=192
    let mut pc: u32 = 0x82822D08;
    'dispatch: loop {
        match pc {
            0x82822D08 => {
    //   block [0x82822D08..0x82822DC8)
	// 82822D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82822D0C: 48985461  bl 0x831a816c
	ctx.lr = 0x82822D10;
	sub_831A8130(ctx, base);
	// 82822D10: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82822D14: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82822D18: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822D1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82822D20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82822D24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822D28: 388BA2B8  addi r4, r11, -0x5d48
	ctx.r[4].s64 = ctx.r[11].s64 + -23880;
	// 82822D2C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82822D30: 485D0CD9  bl 0x82df3a08
	ctx.lr = 0x82822D34;
	sub_82DF3A08(ctx, base);
	// 82822D34: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82822D38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82822D3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82822D40: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82822D44: C3EB9450  lfs f31, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82822D48: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82822D4C: 4BFC8F6D  bl 0x827ebcb8
	ctx.lr = 0x82822D50;
	sub_827EBCB8(ctx, base);
	// 82822D50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822D54: 485D06D5  bl 0x82df3428
	ctx.lr = 0x82822D58;
	sub_82DF3428(ctx, base);
	// 82822D58: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822D5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822D60: 388BA2AC  addi r4, r11, -0x5d54
	ctx.r[4].s64 = ctx.r[11].s64 + -23892;
	// 82822D64: 485D0CA5  bl 0x82df3a08
	ctx.lr = 0x82822D68;
	sub_82DF3A08(ctx, base);
	// 82822D68: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82822D6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82822D70: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82822D74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82822D78: 4BFC8F41  bl 0x827ebcb8
	ctx.lr = 0x82822D7C;
	sub_827EBCB8(ctx, base);
	// 82822D7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822D80: 485D06A9  bl 0x82df3428
	ctx.lr = 0x82822D84;
	sub_82DF3428(ctx, base);
	// 82822D84: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822D88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822D8C: 388BA2A0  addi r4, r11, -0x5d60
	ctx.r[4].s64 = ctx.r[11].s64 + -23904;
	// 82822D90: 485D0C79  bl 0x82df3a08
	ctx.lr = 0x82822D94;
	sub_82DF3A08(ctx, base);
	// 82822D94: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82822D98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82822D9C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82822DA0: 4BFC8D91  bl 0x827ebb30
	ctx.lr = 0x82822DA4;
	sub_827EBB30(ctx, base);
	// 82822DA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822DA8: 485D0681  bl 0x82df3428
	ctx.lr = 0x82822DAC;
	sub_82DF3428(ctx, base);
	// 82822DAC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82822DB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82822DB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822DB8: 4BFF91E9  bl 0x8281bfa0
	ctx.lr = 0x82822DBC;
	sub_8281BFA0(ctx, base);
	// 82822DBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82822DC0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82822DC4: 489853F8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82822DC8 size=12
    let mut pc: u32 = 0x82822DC8;
    'dispatch: loop {
        match pc {
            0x82822DC8 => {
    //   block [0x82822DC8..0x82822DD4)
	// 82822DC8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82822DCC: 386BAE74  addi r3, r11, -0x518c
	ctx.r[3].s64 = ctx.r[11].s64 + -20876;
	// 82822DD0: 4BFF9160  b 0x8281bf30
	sub_8281BF30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82822DD8 size=12
    let mut pc: u32 = 0x82822DD8;
    'dispatch: loop {
        match pc {
            0x82822DD8 => {
    //   block [0x82822DD8..0x82822DE4)
	// 82822DD8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82822DDC: 386BAE74  addi r3, r11, -0x518c
	ctx.r[3].s64 = ctx.r[11].s64 + -20876;
	// 82822DE0: 4BFF9158  b 0x8281bf38
	sub_8281BF38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82822DE8 size=12
    let mut pc: u32 = 0x82822DE8;
    'dispatch: loop {
        match pc {
            0x82822DE8 => {
    //   block [0x82822DE8..0x82822DF4)
	// 82822DE8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82822DEC: 386BAF94  addi r3, r11, -0x506c
	ctx.r[3].s64 = ctx.r[11].s64 + -20588;
	// 82822DF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82822DF8 size=12
    let mut pc: u32 = 0x82822DF8;
    'dispatch: loop {
        match pc {
            0x82822DF8 => {
    //   block [0x82822DF8..0x82822E04)
	// 82822DF8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82822DFC: 386BAF78  addi r3, r11, -0x5088
	ctx.r[3].s64 = ctx.r[11].s64 + -20616;
	// 82822E00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82822E08 size=12
    let mut pc: u32 = 0x82822E08;
    'dispatch: loop {
        match pc {
            0x82822E08 => {
    //   block [0x82822E08..0x82822E14)
	// 82822E08: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82822E0C: 386BAFA4  addi r3, r11, -0x505c
	ctx.r[3].s64 = ctx.r[11].s64 + -20572;
	// 82822E10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82822E18 size=4
    let mut pc: u32 = 0x82822E18;
    'dispatch: loop {
        match pc {
            0x82822E18 => {
    //   block [0x82822E18..0x82822E1C)
	// 82822E18: 4BFFBAD8  b 0x8281e8f0
	sub_8281E8F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82822E20 size=4
    let mut pc: u32 = 0x82822E20;
    'dispatch: loop {
        match pc {
            0x82822E20 => {
    //   block [0x82822E20..0x82822E24)
	// 82822E20: 4BFFDE18  b 0x82820c38
	sub_82820C38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82822E28 size=4
    let mut pc: u32 = 0x82822E28;
    'dispatch: loop {
        match pc {
            0x82822E28 => {
    //   block [0x82822E28..0x82822E2C)
	// 82822E28: 4BFFBE08  b 0x8281ec30
	sub_8281EC30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82822E30 size=68
    let mut pc: u32 = 0x82822E30;
    'dispatch: loop {
        match pc {
            0x82822E30 => {
    //   block [0x82822E30..0x82822E74)
	// 82822E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82822E34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82822E38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82822E3C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82822E40: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822E44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82822E48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82822E4C: 388BA2C4  addi r4, r11, -0x5d3c
	ctx.r[4].s64 = ctx.r[11].s64 + -23868;
	// 82822E50: 485D0BB9  bl 0x82df3a08
	ctx.lr = 0x82822E54;
	sub_82DF3A08(ctx, base);
	// 82822E54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82822E58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822E5C: 4BFCBE95  bl 0x827eecf0
	ctx.lr = 0x82822E60;
	sub_827EECF0(ctx, base);
	// 82822E60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82822E64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82822E68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82822E6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82822E70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82822E78 size=76
    let mut pc: u32 = 0x82822E78;
    'dispatch: loop {
        match pc {
            0x82822E78 => {
    //   block [0x82822E78..0x82822EC4)
	// 82822E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82822E7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82822E80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82822E84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82822E88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82822E8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822E90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82822E94: 388BA2CC  addi r4, r11, -0x5d34
	ctx.r[4].s64 = ctx.r[11].s64 + -23860;
	// 82822E98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82822E9C: 4BFF5E0D  bl 0x82818ca8
	ctx.lr = 0x82822EA0;
	sub_82818CA8(ctx, base);
	// 82822EA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82822EA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822EA8: 4BFF93D9  bl 0x8281c280
	ctx.lr = 0x82822EAC;
	sub_8281C280(ctx, base);
	// 82822EAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82822EB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82822EB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82822EB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82822EBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82822EC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82822EC8 size=8
    let mut pc: u32 = 0x82822EC8;
    'dispatch: loop {
        match pc {
            0x82822EC8 => {
    //   block [0x82822EC8..0x82822ED0)
	// 82822EC8: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 82822ECC: 480000B4  b 0x82822f80
	sub_82822F80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82822ED0 size=8
    let mut pc: u32 = 0x82822ED0;
    'dispatch: loop {
        match pc {
            0x82822ED0 => {
    //   block [0x82822ED0..0x82822ED8)
	// 82822ED0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82822ED4: 480000AC  b 0x82822f80
	sub_82822F80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82822ED8 size=164
    let mut pc: u32 = 0x82822ED8;
    'dispatch: loop {
        match pc {
            0x82822ED8 => {
    //   block [0x82822ED8..0x82822F7C)
	// 82822ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82822EDC: 4898528D  bl 0x831a8168
	ctx.lr = 0x82822EE0;
	sub_831A8130(ctx, base);
	// 82822EE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82822EE4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82822EE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82822EEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82822EF0: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82822EF4: 41820038  beq 0x82822f2c
	if ctx.cr[0].eq {
	pc = 0x82822F2C; continue 'dispatch;
	}
	// 82822EF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822EFC: 48986A8D  bl 0x831a9988
	ctx.lr = 0x82822F00;
	sub_831A9988(ctx, base);
	// 82822F00: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82822F04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82822F08: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 82822F0C: 489851ED  bl 0x831a80f8
	ctx.lr = 0x82822F10;
	sub_831A80F8(ctx, base);
	// 82822F10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82822F14: 41820018  beq 0x82822f2c
	if ctx.cr[0].eq {
	pc = 0x82822F2C; continue 'dispatch;
	}
	// 82822F18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82822F1C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82822F20: 4BFFE1D1  bl 0x828210f0
	ctx.lr = 0x82822F24;
	sub_828210F0(ctx, base);
	// 82822F24: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82822F28: 4800004C  b 0x82822f74
	pc = 0x82822F74; continue 'dispatch;
	// 82822F2C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82822F30: 419A0034  beq cr6, 0x82822f64
	if ctx.cr[6].eq {
	pc = 0x82822F64; continue 'dispatch;
	}
	// 82822F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822F38: 48986A51  bl 0x831a9988
	ctx.lr = 0x82822F3C;
	sub_831A9988(ctx, base);
	// 82822F3C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82822F40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82822F44: 386BDBD4  addi r3, r11, -0x242c
	ctx.r[3].s64 = ctx.r[11].s64 + -9260;
	// 82822F48: 489851B1  bl 0x831a80f8
	ctx.lr = 0x82822F4C;
	sub_831A80F8(ctx, base);
	// 82822F4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82822F50: 41820014  beq 0x82822f64
	if ctx.cr[0].eq {
	pc = 0x82822F64; continue 'dispatch;
	}
	// 82822F54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82822F58: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82822F5C: 4BFFFF1D  bl 0x82822e78
	ctx.lr = 0x82822F60;
	sub_82822E78(ctx, base);
	// 82822F60: 4BFFFFC4  b 0x82822f24
	pc = 0x82822F24; continue 'dispatch;
	// 82822F64: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82822F68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82822F6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82822F70: 4BFFD909  bl 0x82820878
	ctx.lr = 0x82822F74;
	sub_82820878(ctx, base);
	// 82822F74: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82822F78: 48985240  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82822F80 size=112
    let mut pc: u32 = 0x82822F80;
    'dispatch: loop {
        match pc {
            0x82822F80 => {
    //   block [0x82822F80..0x82822FF0)
	// 82822F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82822F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82822F88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82822F8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82822F90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82822F94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82822F98: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82822F9C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82822FA0: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82822FA4: 396BA204  addi r11, r11, -0x5dfc
	ctx.r[11].s64 = ctx.r[11].s64 + -24060;
	// 82822FA8: 394AA1F0  addi r10, r10, -0x5e10
	ctx.r[10].s64 = ctx.r[10].s64 + -24080;
	// 82822FAC: 3929A1A4  addi r9, r9, -0x5e5c
	ctx.r[9].s64 = ctx.r[9].s64 + -24156;
	// 82822FB0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82822FB4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82822FB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82822FBC: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 82822FC0: 4BFFC1B1  bl 0x8281f170
	ctx.lr = 0x82822FC4;
	sub_8281F170(ctx, base);
	// 82822FC4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82822FC8: 4182000C  beq 0x82822fd4
	if ctx.cr[0].eq {
	pc = 0x82822FD4; continue 'dispatch;
	}
	// 82822FCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822FD0: 485CF409  bl 0x82df23d8
	ctx.lr = 0x82822FD4;
	sub_82DF23D8(ctx, base);
	// 82822FD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82822FD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82822FDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82822FE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82822FE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82822FE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82822FEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82822FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82822FF0 size=196
    let mut pc: u32 = 0x82822FF0;
    'dispatch: loop {
        match pc {
            0x82822FF0 => {
    //   block [0x82822FF0..0x828230B4)
	// 82822FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82822FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82822FF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82822FFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82823000: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82823004: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82823008: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282300C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82823010: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82823014: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82823018: 4BA9D921  bl 0x822c0938
	ctx.lr = 0x8282301C;
	sub_822C0938(ctx, base);
	// 8282301C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82823020: 41820028  beq 0x82823048
	if ctx.cr[0].eq {
	pc = 0x82823048; continue 'dispatch;
	}
	// 82823024: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82823028: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8282302C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82823030: 392BA2EC  addi r9, r11, -0x5d14
	ctx.r[9].s64 = ctx.r[11].s64 + -23828;
	// 82823034: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82823038: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8282303C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82823040: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82823044: 48000008  b 0x8282304c
	pc = 0x8282304C; continue 'dispatch;
	// 82823048: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8282304C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82823050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82823054: 409A0044  bne cr6, 0x82823098
	if !ctx.cr[6].eq {
	pc = 0x82823098; continue 'dispatch;
	}
	// 82823058: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8282305C: 419A001C  beq cr6, 0x82823078
	if ctx.cr[6].eq {
	pc = 0x82823078; continue 'dispatch;
	}
	// 82823060: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82823064: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82823068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282306C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82823070: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82823074: 4E800421  bctrl
	ctx.lr = 0x82823078;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82823078: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8282307C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82823080: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82823084: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82823088: 816BFE98  lwz r11, -0x168(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-360 as u32) ) } as u64;
	// 8282308C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82823090: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82823094: 4BA9CF6D  bl 0x822c0000
	ctx.lr = 0x82823098;
	sub_822C0000(ctx, base);
	// 82823098: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8282309C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828230A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828230A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828230A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828230AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828230B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828230B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828230B8 size=280
    let mut pc: u32 = 0x828230B8;
    'dispatch: loop {
        match pc {
            0x828230B8 => {
    //   block [0x828230B8..0x828231D0)
	// 828230B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828230BC: 489850AD  bl 0x831a8168
	ctx.lr = 0x828230C0;
	sub_831A8130(ctx, base);
	// 828230C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828230C4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828230C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828230CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828230D0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828230D4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828230D8: 2B1D0004  cmplwi cr6, r29, 4
	ctx.cr[6].compare_u32(ctx.r[29].u32, 4 as u32, &mut ctx.xer);
	// 828230DC: 409A0030  bne cr6, 0x8282310c
	if !ctx.cr[6].eq {
	pc = 0x8282310C; continue 'dispatch;
	}
	// 828230E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828230E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828230E8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828230EC: 4BCEC245  bl 0x8250f330
	ctx.lr = 0x828230F0;
	sub_8250F330(ctx, base);
	// 828230F0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828230F4: 4BCC675D  bl 0x824e9850
	ctx.lr = 0x828230F8;
	sub_824E9850(ctx, base);
	// 828230F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828230FC: C00BC664  lfs f0, -0x399c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82823100: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82823104: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82823108: 41990008  bgt cr6, 0x82823110
	if ctx.cr[6].gt {
	pc = 0x82823110; continue 'dispatch;
	}
	// 8282310C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82823110: 57EA07FF  clrlwi. r10, r31, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82823114: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82823118: 4182000C  beq 0x82823124
	if ctx.cr[0].eq {
	pc = 0x82823124; continue 'dispatch;
	}
	// 8282311C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82823120: 485CEB71  bl 0x82df1c90
	ctx.lr = 0x82823124;
	sub_82DF1C90(ctx, base);
	// 82823124: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82823128: 41820090  beq 0x828231b8
	if ctx.cr[0].eq {
	pc = 0x828231B8; continue 'dispatch;
	}
	// 8282312C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82823130: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82823134: 388BA2A0  addi r4, r11, -0x5d60
	ctx.r[4].s64 = ctx.r[11].s64 + -23904;
	// 82823138: 485D08D1  bl 0x82df3a08
	ctx.lr = 0x8282313C;
	sub_82DF3A08(ctx, base);
	// 8282313C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82823140: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82823144: 4804057D  bl 0x828636c0
	ctx.lr = 0x82823148;
	sub_828636C0(ctx, base);
	// 82823148: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8282314C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82823150: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82823154: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82823158: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8282315C: 419A0024  beq cr6, 0x82823180
	if ctx.cr[6].eq {
	pc = 0x82823180; continue 'dispatch;
	}
	// 82823160: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82823164: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82823168: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282316C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82823170: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82823174: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82823178: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282317C: 4082FFE8  bne 0x82823164
	if !ctx.cr[0].eq {
	pc = 0x82823164; continue 'dispatch;
	}
	// 82823180: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82823184: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82823188: 4BFC9BD1  bl 0x827ecd58
	ctx.lr = 0x8282318C;
	sub_827ECD58(ctx, base);
	// 8282318C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82823190: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82823194: 419A0008  beq cr6, 0x8282319c
	if ctx.cr[6].eq {
	pc = 0x8282319C; continue 'dispatch;
	}
	// 82823198: 4BA9D6F9  bl 0x822c0890
	ctx.lr = 0x8282319C;
	sub_822C0890(ctx, base);
	// 8282319C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828231A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828231A4: 419A0008  beq cr6, 0x828231ac
	if ctx.cr[6].eq {
	pc = 0x828231AC; continue 'dispatch;
	}
	// 828231A8: 4BA9D6E9  bl 0x822c0890
	ctx.lr = 0x828231AC;
	sub_822C0890(ctx, base);
	// 828231AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828231B0: 485D0279  bl 0x82df3428
	ctx.lr = 0x828231B4;
	sub_82DF3428(ctx, base);
	// 828231B4: 48000014  b 0x828231c8
	pc = 0x828231C8; continue 'dispatch;
	// 828231B8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828231BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828231C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828231C4: 4BFFA7FD  bl 0x8281d9c0
	ctx.lr = 0x828231C8;
	sub_8281D9C0(ctx, base);
	// 828231C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828231CC: 48984FEC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828231D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828231D0 size=372
    let mut pc: u32 = 0x828231D0;
    'dispatch: loop {
        match pc {
            0x828231D0 => {
    //   block [0x828231D0..0x82823344)
	// 828231D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828231D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828231D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828231DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828231E0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828231E4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828231E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828231EC: 4BFFC545  bl 0x8281f730
	ctx.lr = 0x828231F0;
	sub_8281F730(ctx, base);
	// 828231F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828231F4: 4BFC8FDD  bl 0x827ec1d0
	ctx.lr = 0x828231F8;
	sub_827EC1D0(ctx, base);
	// 828231F8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828231FC: 4182012C  beq 0x82823328
	if ctx.cr[0].eq {
	pc = 0x82823328; continue 'dispatch;
	}
	// 82823200: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82823204: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82823208: 388BA300  addi r4, r11, -0x5d00
	ctx.r[4].s64 = ctx.r[11].s64 + -23808;
	// 8282320C: 38A00061  li r5, 0x61
	ctx.r[5].s64 = 97;
	// 82823210: 38600198  li r3, 0x198
	ctx.r[3].s64 = 408;
	// 82823214: 485CF1D5  bl 0x82df23e8
	ctx.lr = 0x82823218;
	sub_82DF23E8(ctx, base);
	// 82823218: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8282321C: 41820010  beq 0x8282322c
	if ctx.cr[0].eq {
	pc = 0x8282322C; continue 'dispatch;
	}
	// 82823220: 4BADBE59  bl 0x822ff078
	ctx.lr = 0x82823224;
	sub_822FF078(ctx, base);
	// 82823224: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82823228: 48000008  b 0x82823230
	pc = 0x82823230; continue 'dispatch;
	// 8282322C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82823230: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82823234: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82823238: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8282323C: 4BB2F375  bl 0x823525b0
	ctx.lr = 0x82823240;
	sub_823525B0(ctx, base);
	// 82823240: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82823244: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82823248: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8282324C: 4BA9CDB5  bl 0x822c0000
	ctx.lr = 0x82823250;
	sub_822C0000(ctx, base);
	// 82823250: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82823254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82823258: 388BA2B8  addi r4, r11, -0x5d48
	ctx.r[4].s64 = ctx.r[11].s64 + -23880;
	// 8282325C: 485D07AD  bl 0x82df3a08
	ctx.lr = 0x82823260;
	sub_82DF3A08(ctx, base);
	// 82823260: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82823264: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82823268: 4BADBD59  bl 0x822fefc0
	ctx.lr = 0x8282326C;
	sub_822FEFC0(ctx, base);
	// 8282326C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82823270: 485D01B9  bl 0x82df3428
	ctx.lr = 0x82823274;
	sub_82DF3428(ctx, base);
	// 82823274: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82823278: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282327C: 388BA2AC  addi r4, r11, -0x5d54
	ctx.r[4].s64 = ctx.r[11].s64 + -23892;
	// 82823280: 485D0789  bl 0x82df3a08
	ctx.lr = 0x82823284;
	sub_82DF3A08(ctx, base);
	// 82823284: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82823288: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8282328C: 4BADBD35  bl 0x822fefc0
	ctx.lr = 0x82823290;
	sub_822FEFC0(ctx, base);
	// 82823290: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82823294: 485D0195  bl 0x82df3428
	ctx.lr = 0x82823298;
	sub_82DF3428(ctx, base);
	// 82823298: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 8282329C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828232A0: 3BEB2D64  addi r31, r11, 0x2d64
	ctx.r[31].s64 = ctx.r[11].s64 + 11620;
	// 828232A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828232A8: 485D0761  bl 0x82df3a08
	ctx.lr = 0x828232AC;
	sub_82DF3A08(ctx, base);
	// 828232AC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828232B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828232B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828232B8: 4BFC7841  bl 0x827eaaf8
	ctx.lr = 0x828232BC;
	sub_827EAAF8(ctx, base);
	// 828232BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828232C0: 485D0169  bl 0x82df3428
	ctx.lr = 0x828232C4;
	sub_82DF3428(ctx, base);
	// 828232C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828232C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828232CC: 485D073D  bl 0x82df3a08
	ctx.lr = 0x828232D0;
	sub_82DF3A08(ctx, base);
	// 828232D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828232D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828232D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828232DC: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828232E0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828232E4: 4BFC7045  bl 0x827ea328
	ctx.lr = 0x828232E8;
	sub_827EA328(ctx, base);
	// 828232E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828232EC: 485D013D  bl 0x82df3428
	ctx.lr = 0x828232F0;
	sub_82DF3428(ctx, base);
	// 828232F0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828232F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828232F8: 388BA2A0  addi r4, r11, -0x5d60
	ctx.r[4].s64 = ctx.r[11].s64 + -23904;
	// 828232FC: 485D070D  bl 0x82df3a08
	ctx.lr = 0x82823300;
	sub_82DF3A08(ctx, base);
	// 82823300: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82823304: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82823308: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8282330C: 4BFC702D  bl 0x827ea338
	ctx.lr = 0x82823310;
	sub_827EA338(ctx, base);
	// 82823310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82823314: 485D0115  bl 0x82df3428
	ctx.lr = 0x82823318;
	sub_82DF3428(ctx, base);
	// 82823318: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8282331C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82823320: 419A0008  beq cr6, 0x82823328
	if ctx.cr[6].eq {
	pc = 0x82823328; continue 'dispatch;
	}
	// 82823324: 4BA9D56D  bl 0x822c0890
	ctx.lr = 0x82823328;
	sub_822C0890(ctx, base);
	// 82823328: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8282332C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82823330: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82823334: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82823338: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282333C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82823340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82823348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82823348 size=476
    let mut pc: u32 = 0x82823348;
    'dispatch: loop {
        match pc {
            0x82823348 => {
    //   block [0x82823348..0x82823524)
	// 82823348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282334C: 48984E19  bl 0x831a8164
	ctx.lr = 0x82823350;
	sub_831A8130(ctx, base);
	// 82823350: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82823354: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82823358: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282335C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82823360: 3BCBA300  addi r30, r11, -0x5d00
	ctx.r[30].s64 = ctx.r[11].s64 + -23808;
	// 82823364: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82823368: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8282336C: 38A0003A  li r5, 0x3a
	ctx.r[5].s64 = 58;
	// 82823370: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82823374: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82823378: 386002E0  li r3, 0x2e0
	ctx.r[3].s64 = 736;
	// 8282337C: 485CF06D  bl 0x82df23e8
	ctx.lr = 0x82823380;
	sub_82DF23E8(ctx, base);
	// 82823380: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82823384: 41820010  beq 0x82823394
	if ctx.cr[0].eq {
	pc = 0x82823394; continue 'dispatch;
	}
	// 82823388: 4BFFF8F1  bl 0x82822c78
	ctx.lr = 0x8282338C;
	sub_82822C78(ctx, base);
	// 8282338C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82823390: 48000008  b 0x82823398
	pc = 0x82823398; continue 'dispatch;
	// 82823394: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82823398: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8282339C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828233A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828233A4: 4BFFFC4D  bl 0x82822ff0
	ctx.lr = 0x828233A8;
	sub_82822FF0(ctx, base);
	// 828233A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828233AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828233B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828233B4: 4BA9CC4D  bl 0x822c0000
	ctx.lr = 0x828233B8;
	sub_822C0000(ctx, base);
	// 828233B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828233BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828233C0: 38A0003B  li r5, 0x3b
	ctx.r[5].s64 = 59;
	// 828233C4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828233C8: 4BA9D011  bl 0x822c03d8
	ctx.lr = 0x828233CC;
	sub_822C03D8(ctx, base);
	// 828233CC: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828233D0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828233D4: 418200E0  beq 0x828234b4
	if ctx.cr[0].eq {
	pc = 0x828234B4; continue 'dispatch;
	}
	// 828233D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828233DC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828233E0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828233E4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828233E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828233EC: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828233F0: 396A0208  addi r11, r10, 0x208
	ctx.r[11].s64 = ctx.r[10].s64 + 520;
	// 828233F4: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828233F8: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828233FC: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82823400: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82823404: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82823408: 409A0008  bne cr6, 0x82823410
	if !ctx.cr[6].eq {
	pc = 0x82823410; continue 'dispatch;
	}
	// 8282340C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82823410: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82823414: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82823418: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8282341C: 419A0024  beq cr6, 0x82823440
	if ctx.cr[6].eq {
	pc = 0x82823440; continue 'dispatch;
	}
	// 82823420: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82823424: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82823428: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282342C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82823430: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82823434: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82823438: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282343C: 4082FFE8  bne 0x82823424
	if !ctx.cr[0].eq {
	pc = 0x82823424; continue 'dispatch;
	}
	// 82823440: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82823444: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82823448: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8282344C: 419A0024  beq cr6, 0x82823470
	if ctx.cr[6].eq {
	pc = 0x82823470; continue 'dispatch;
	}
	// 82823450: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82823454: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82823458: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282345C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82823460: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82823464: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82823468: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8282346C: 4082FFE8  bne 0x82823454
	if !ctx.cr[0].eq {
	pc = 0x82823454; continue 'dispatch;
	}
	// 82823470: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82823474: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82823478: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8282347C: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82823480: 486597C1  bl 0x82e7cc40
	ctx.lr = 0x82823484;
	sub_82E7CC40(ctx, base);
	// 82823484: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82823488: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8282348C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82823490: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82823494: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82823498: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8282349C: 4BF75A95  bl 0x82798f30
	ctx.lr = 0x828234A0;
	sub_82798F30(ctx, base);
	// 828234A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828234A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828234A8: 4BF781C1  bl 0x8279b668
	ctx.lr = 0x828234AC;
	sub_8279B668(ctx, base);
	// 828234AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828234B0: 48000008  b 0x828234b8
	pc = 0x828234B8; continue 'dispatch;
	// 828234B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828234B8: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828234BC: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828234C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828234C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828234C8: 4BD74789  bl 0x82597c50
	ctx.lr = 0x828234CC;
	sub_82597C50(ctx, base);
	// 828234CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828234D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828234D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828234D8: 4BA9CB29  bl 0x822c0000
	ctx.lr = 0x828234DC;
	sub_822C0000(ctx, base);
	// 828234DC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828234E0: 41820024  beq 0x82823504
	if ctx.cr[0].eq {
	pc = 0x82823504; continue 'dispatch;
	}
	// 828234E4: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828234E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828234EC: 419A0008  beq cr6, 0x828234f4
	if ctx.cr[6].eq {
	pc = 0x828234F4; continue 'dispatch;
	}
	// 828234F0: 4BA9D3A1  bl 0x822c0890
	ctx.lr = 0x828234F4;
	sub_822C0890(ctx, base);
	// 828234F4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828234F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828234FC: 419A0008  beq cr6, 0x82823504
	if ctx.cr[6].eq {
	pc = 0x82823504; continue 'dispatch;
	}
	// 82823500: 4BA9D391  bl 0x822c0890
	ctx.lr = 0x82823504;
	sub_822C0890(ctx, base);
	// 82823504: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82823508: 419A000C  beq cr6, 0x82823514
	if ctx.cr[6].eq {
	pc = 0x82823514; continue 'dispatch;
	}
	// 8282350C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82823510: 4BA9D381  bl 0x822c0890
	ctx.lr = 0x82823514;
	sub_822C0890(ctx, base);
	// 82823514: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82823518: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8282351C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82823520: 48984C94  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82823528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82823528 size=136
    let mut pc: u32 = 0x82823528;
    'dispatch: loop {
        match pc {
            0x82823528 => {
    //   block [0x82823528..0x828235B0)
	// 82823528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282352C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82823530: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82823534: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82823538: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282353C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82823540: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82823544: 4BFF8A5D  bl 0x8281bfa0
	ctx.lr = 0x82823548;
	sub_8281BFA0(ctx, base);
	// 82823548: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8282354C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82823550: 388BA3EC  addi r4, r11, -0x5c14
	ctx.r[4].s64 = ctx.r[11].s64 + -23572;
	// 82823554: 485D04B5  bl 0x82df3a08
	ctx.lr = 0x82823558;
	sub_82DF3A08(ctx, base);
	// 82823558: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8282355C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82823560: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82823564: 4BFC85CD  bl 0x827ebb30
	ctx.lr = 0x82823568;
	sub_827EBB30(ctx, base);
	// 82823568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282356C: 485CFEBD  bl 0x82df3428
	ctx.lr = 0x82823570;
	sub_82DF3428(ctx, base);
	// 82823570: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82823574: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82823578: 388BA3DC  addi r4, r11, -0x5c24
	ctx.r[4].s64 = ctx.r[11].s64 + -23588;
	// 8282357C: 485D048D  bl 0x82df3a08
	ctx.lr = 0x82823580;
	sub_82DF3A08(ctx, base);
	// 82823580: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82823584: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82823588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282358C: 4BFC85A5  bl 0x827ebb30
	ctx.lr = 0x82823590;
	sub_827EBB30(ctx, base);
	// 82823590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82823594: 485CFE95  bl 0x82df3428
	ctx.lr = 0x82823598;
	sub_82DF3428(ctx, base);
	// 82823598: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8282359C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828235A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828235A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828235A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828235AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828235B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828235B0 size=8
    let mut pc: u32 = 0x828235B0;
    'dispatch: loop {
        match pc {
            0x828235B0 => {
    //   block [0x828235B0..0x828235B8)
	// 828235B0: 80630304  lwz r3, 0x304(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(772 as u32) ) } as u64;
	// 828235B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828235B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828235B8 size=92
    let mut pc: u32 = 0x828235B8;
    'dispatch: loop {
        match pc {
            0x828235B8 => {
    //   block [0x828235B8..0x82823614)
	// 828235B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828235BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828235C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828235C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828235C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828235CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828235D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828235D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828235D8: 388BF614  addi r4, r11, -0x9ec
	ctx.r[4].s64 = ctx.r[11].s64 + -2540;
	// 828235DC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828235E0: 485D0429  bl 0x82df3a08
	ctx.lr = 0x828235E4;
	sub_82DF3A08(ctx, base);
	// 828235E4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828235E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828235EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828235F0: 4BD7DF99  bl 0x825a1588
	ctx.lr = 0x828235F4;
	sub_825A1588(ctx, base);
	// 828235F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828235F8: 485CFE31  bl 0x82df3428
	ctx.lr = 0x828235FC;
	sub_82DF3428(ctx, base);
	// 828235FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82823600: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82823604: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82823608: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8282360C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82823610: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82823618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82823618 size=172
    let mut pc: u32 = 0x82823618;
    'dispatch: loop {
        match pc {
            0x82823618 => {
    //   block [0x82823618..0x828236C4)
	// 82823618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8282361C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82823620: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82823624: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82823628: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282362C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82823630: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82823634: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82823638: 388BEDA0  addi r4, r11, -0x1260
	ctx.r[4].s64 = ctx.r[11].s64 + -4704;
	// 8282363C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82823640: 485D03C9  bl 0x82df3a08
	ctx.lr = 0x82823644;
	sub_82DF3A08(ctx, base);
	// 82823644: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82823648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8282364C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82823650: 4BD7DF39  bl 0x825a1588
	ctx.lr = 0x82823654;
	sub_825A1588(ctx, base);
	// 82823654: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82823658: 485CFDD1  bl 0x82df3428
	ctx.lr = 0x8282365C;
	sub_82DF3428(ctx, base);
	// 8282365C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82823660: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82823664: 388BED88  addi r4, r11, -0x1278
	ctx.r[4].s64 = ctx.r[11].s64 + -4728;
	// 82823668: 485D03A1  bl 0x82df3a08
	ctx.lr = 0x8282366C;
	sub_82DF3A08(ctx, base);
	// 8282366C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82823670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82823674: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82823678: 4BD7DF11  bl 0x825a1588
	ctx.lr = 0x8282367C;
	sub_825A1588(ctx, base);
	// 8282367C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82823680: 485CFDA9  bl 0x82df3428
	ctx.lr = 0x82823684;
	sub_82DF3428(ctx, base);
	// 82823684: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82823688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282368C: 388BED64  addi r4, r11, -0x129c
	ctx.r[4].s64 = ctx.r[11].s64 + -4764;
	// 82823690: 485D0379  bl 0x82df3a08
	ctx.lr = 0x82823694;
	sub_82DF3A08(ctx, base);
	// 82823694: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82823698: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8282369C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828236A0: 4BD7DEE9  bl 0x825a1588
	ctx.lr = 0x828236A4;
	sub_825A1588(ctx, base);
	// 828236A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828236A8: 485CFD81  bl 0x82df3428
	ctx.lr = 0x828236AC;
	sub_82DF3428(ctx, base);
	// 828236AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828236B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828236B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828236B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828236BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828236C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828236C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828236C8 size=84
    let mut pc: u32 = 0x828236C8;
    'dispatch: loop {
        match pc {
            0x828236C8 => {
    //   block [0x828236C8..0x8282371C)
	// 828236C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828236CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828236D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828236D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828236D8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828236DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828236E0: 388BAFE4  addi r4, r11, -0x501c
	ctx.r[4].s64 = ctx.r[11].s64 + -20508;
	// 828236E4: 4BFCD145  bl 0x827f0828
	ctx.lr = 0x828236E8;
	sub_827F0828(ctx, base);
	// 828236E8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828236EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828236F0: 388BB000  addi r4, r11, -0x5000
	ctx.r[4].s64 = ctx.r[11].s64 + -20480;
	// 828236F4: 4BFD29FD  bl 0x827f60f0
	ctx.lr = 0x828236F8;
	sub_827F60F0(ctx, base);
	// 828236F8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828236FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82823700: 388BB010  addi r4, r11, -0x4ff0
	ctx.r[4].s64 = ctx.r[11].s64 + -20464;
	// 82823704: 4BFCD3C5  bl 0x827f0ac8
	ctx.lr = 0x82823708;
	sub_827F0AC8(ctx, base);
	// 82823708: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8282370C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82823710: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82823714: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82823718: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82823720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82823720 size=128
    let mut pc: u32 = 0x82823720;
    'dispatch: loop {
        match pc {
            0x82823720 => {
    //   block [0x82823720..0x828237A0)
	// 82823720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82823724: 48984A49  bl 0x831a816c
	ctx.lr = 0x82823728;
	sub_831A8130(ctx, base);
	// 82823728: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8282372C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82823730: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82823734: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82823738: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282373C: 388BA3F4  addi r4, r11, -0x5c0c
	ctx.r[4].s64 = ctx.r[11].s64 + -23564;
	// 82823740: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82823744: 485D02C5  bl 0x82df3a08
	ctx.lr = 0x82823748;
	sub_82DF3A08(ctx, base);
	// 82823748: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8282374C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82823750: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82823754: 4BFC83DD  bl 0x827ebb30
	ctx.lr = 0x82823758;
	sub_827EBB30(ctx, base);
	// 82823758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8282375C: 485CFCCD  bl 0x82df3428
	ctx.lr = 0x82823760;
	sub_82DF3428(ctx, base);
	// 82823760: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82823764: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82823768: 388B2D64  addi r4, r11, 0x2d64
	ctx.r[4].s64 = ctx.r[11].s64 + 11620;
	// 8282376C: 485D029D  bl 0x82df3a08
	ctx.lr = 0x82823770;
	sub_82DF3A08(ctx, base);
	// 82823770: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82823774: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82823778: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8282377C: 4BFC83B5  bl 0x827ebb30
	ctx.lr = 0x82823780;
	sub_827EBB30(ctx, base);
	// 82823780: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82823784: 485CFCA5  bl 0x82df3428
	ctx.lr = 0x82823788;
	sub_82DF3428(ctx, base);
	// 82823788: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8282378C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82823790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82823794: 4BFFFD95  bl 0x82823528
	ctx.lr = 0x82823798;
	sub_82823528(ctx, base);
	// 82823798: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8282379C: 48984A20  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828237A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828237A0 size=12
    let mut pc: u32 = 0x828237A0;
    'dispatch: loop {
        match pc {
            0x828237A0 => {
    //   block [0x828237A0..0x828237AC)
	// 828237A0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828237A4: 386BAE7C  addi r3, r11, -0x5184
	ctx.r[3].s64 = ctx.r[11].s64 + -20868;
	// 828237A8: 4BFF8788  b 0x8281bf30
	sub_8281BF30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


